<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的Java集合相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——Java集合">
<meta property="og:url" content="http://linyishui.top/2019102101.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Java集合相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/%E9%9B%86%E5%90%88.svg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-get.svg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-put.svg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-size.svg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-addCount.svg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-transfer.svg">
<meta property="article:published_time" content="2019-10-21T08:06:06.000Z">
<meta property="article:modified_time" content="2025-02-06T11:34:53.337Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/%E9%9B%86%E5%90%88.svg">


<link rel="canonical" href="http://linyishui.top/2019102101.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102101.html","path":"2019102101.html","title":"面试整理——Java集合"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——Java集合 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88"><span class="nav-text">Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E7%BB%BC%E5%90%88"><span class="nav-text">第一节 综合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ajava%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-text">问：java的集合框架有哪几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%B9%B3%E5%B8%B8%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9F"><span class="nav-text">问：平常用到哪些集合类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%9B%86%E5%90%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：集合迭代器的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5-fail-fast-%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5-fail-safe-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BA%86%E8%A7%A3%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%EF%BC%8C%E4%BB%8Elist%E5%88%B0map%E9%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="nav-text">问：了解了哪些并发安全集合，从list到map都讲一下？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AList%EF%BC%8CMap%EF%BC%8CSet-%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-text">问：List，Map，Set 接口在存取元素时，各有什么特点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%8E%A5%E5%8F%A3RandomAccess%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">问：接口RandomAccess的作用？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-List"><span class="nav-text">第二节 List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AList%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">问：List你使用过哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93vector%E5%92%8CArrayList%E5%92%8ClinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%E5%98%9B%EF%BC%9F%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E7%AD%89%EF%BC%9F"><span class="nav-text">问：你知道vector和ArrayList和linkedList的区别嘛？扩容机制等？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%EF%BC%9F%E6%80%8E%E4%B9%88%E6%8F%92%E5%85%A5%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%EF%BC%9F%E5%9C%A8%E9%81%8D%E5%8E%86ArrayList%E6%97%B6%EF%BC%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9FLinkedList%E5%91%A2%EF%BC%9F"><span class="nav-text">问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">问：ArrayList和LinkedList区别？使用场景？链表和数组的优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%9F%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：讲一下写时复制？写时复制和读写锁的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ACopyOnWriteArrayList-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：CopyOnWriteArrayList 原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AArrayBlockingQueue-%E5%92%8C-LinkedBlockingQueue-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：ArrayBlockingQueue 和 LinkedBlockingQueue 区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-Set"><span class="nav-text">第三节 Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashSet-%E5%92%8C-TreeSet-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：HashSet 和 TreeSet 原理？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-Map"><span class="nav-text">第四节 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-HashMap"><span class="nav-text">4.1 HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84HashMap%E5%90%A7%EF%BC%9F%E8%83%BD%E8%AE%B2%E8%AE%B2HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9FHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FHashMap%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F1-8%E7%89%88%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96-%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">**问：说说你了解的HashMap吧？能讲讲HashMap的实现原理吗？HashMap的底层是什么？HashMap内部数据结构？1.8版本的优化 **⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：解决hash冲突的方法有哪些？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ahashmap%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%83%BD%E8%BE%BE%E5%88%B0O-1-%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E9%87%8C%E9%9D%A2%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F%E2%AD%90"><span class="nav-text">问：hashmap查询的时间复杂度能达到O(1)是什么实现的？里面的索引是怎么计算的？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E8%A1%8Crehash%EF%BC%9F%E2%AD%90"><span class="nav-text">问：HashMap什么时候会进行rehash？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%A4%9A%E5%B0%91%E6%AF%94%E8%BE%83%E5%90%88%E9%80%82%E5%91%A2%EF%BC%9F"><span class="nav-text">问：HashMap的初始容量设置成多少比较合适呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E8%AE%A9HashMap%E5%8F%98%E5%BE%97%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9FHashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F%E2%AD%90"><span class="nav-text">问：HashMap为什么不是线程安全的？怎么让HashMap变得线程安全？HashMap多线程有什么问题？怎么解决？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E8%AF%B4%E8%AF%B4HashMap%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%AD%BB%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="nav-text">问：结合源码说说HashMap在高并发场景中为什么会出现死循环？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%83%BD%E6%98%AF-2-%E7%9A%84-N-%E6%AC%A1%E5%B9%82%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：HashMap 扩容机制，为什么都是 2 的 N 次幂？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%90%E6%98%AF0-75%EF%BC%9F%E2%AD%90"><span class="nav-text">问：为什么HashMap装填因子是0.75？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap%E5%92%8CHashTable%E5%92%8CConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：HashMap和HashTable和ConcurrentHashMap的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap%E5%92%8CHashTable%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-text">问：HashMap和HashTable有何不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap-%E5%92%8C-WeakHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：HashMap 和 WeakHashMap 的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%9C%A8-hash-%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：HashMap 和 ConcurrentHashMap 的区别？在 hash 上的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashMap-1-8%E7%89%88%E6%9C%AC%E5%89%8D%E5%90%8E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FJDK8-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%8C%96%E5%AE%B9%E9%87%8F%EF%BC%9F%E6%AF%94%E5%A6%82%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E5%88%AB%E7%9A%84%E6%A0%91%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9B%E4%B8%BA%E4%BB%80%E4%B9%88-8-%E7%9A%84%E6%97%B6%E5%80%99%E6%A0%91%E5%8C%96%EF%BC%8C4-%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：HashMap 1.8版本前后的区别？JDK8 做了什么优化？最小树化容量？比如为什么是红黑树，别的树不可以吗；为什么 8 的时候树化，4 不可以吗？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ajdk1-8%E4%B8%AD%EF%BC%8C%E5%AF%B9HashMap%E5%92%8CConcurrentHashMap%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">问：jdk1.8中，对HashMap和ConcurrentHashMap做了哪些优化？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-ConcurrentHashMap"><span class="nav-text">4.2 ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84ConcurrentHashMap%EF%BC%9FConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%86%E6%AE%B5%EF%BC%9F1-7%E4%B8%8E1-8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：讲一下你所知道的ConcurrentHashMap？ConcurrentHashMap分段锁？如何分段？1.7与1.8版本的区别？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%A3%E5%88%97%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：ConcurrentHashMap如何进行散列？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%EF%BC%9Fget-%E6%B5%81%E7%A8%8B%EF%BC%9F%E2%AD%90"><span class="nav-text">问：ConcurrentHashMap如何获取元素？get()流程？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E5%A6%82%E4%BD%95%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0%EF%BC%9Fput-%E6%B5%81%E7%A8%8B%EF%BC%9F%E2%AD%90"><span class="nav-text">问：ConcurrentHashMap如何放置元素？put()流程？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%9B%AE%EF%BC%9Fsize-%E6%B5%81%E7%A8%8B%EF%BC%9F%E2%AD%90"><span class="nav-text">问：ConcurrentHashMap如何统计数目？size()流程？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9FaddCount-%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：ConcurrentHashMap如何更新计数器？addCount()流程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F%EF%BC%9Ftransfer-%E6%B5%81%E7%A8%8B%EF%BC%9F%E2%AD%90"><span class="nav-text">问：ConcurrentHashMap的扩容方式？transfer()流程？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4ConcurrentHashMap%E5%8F%AA%E5%85%B7%E6%9C%89%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-text">问：为什么说ConcurrentHashMap只具有弱一致性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E5%92%8CLinkedHashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：ConcurrentHashMap和LinkedHashMap有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%98%80%E5%80%BC%E6%98%AF8%EF%BC%9F"><span class="nav-text">问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-ConcurrentSkipListMap"><span class="nav-text">4.3 ConcurrentSkipListMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFConcurrentSkipListMap%EF%BC%9F%E4%BB%96%E5%92%8CConcurrentHashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-LinkedHashMap"><span class="nav-text">4.4 LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ALinkedHashMap%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E8%AE%B2%E4%B8%80%E4%B8%8B%EF%BC%9F%E5%AD%98%E8%BF%9B%E9%9B%86%E5%90%88%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-text">问：LinkedHashMap用过吗？讲一下？存进集合如何比较大小保证顺序？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-TreeMap"><span class="nav-text">4.5 TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2TreeMap%EF%BC%9F"><span class="nav-text">问：讲讲TreeMap？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ATreeMap%E6%9F%A5%E8%AF%A2%E5%86%99%E5%85%A5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-text">问：TreeMap查询写入的时间复杂度多少？</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102101.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——Java集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-21 16:06:06" itemprop="dateCreated datePublished" datetime="2019-10-21T16:06:06+08:00">2019-10-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-02-06 19:34:53" itemprop="dateModified" datetime="2025-02-06T19:34:53+08:00">2025-02-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的Java集合相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a><strong>Java集合</strong></h1><h2 id="第一节-综合"><a href="#第一节-综合" class="headerlink" title="第一节 综合"></a><strong>第一节 综合</strong></h2><h4 id="问：java的集合框架有哪几种？"><a href="#问：java的集合框架有哪几种？" class="headerlink" title="问：java的集合框架有哪几种？"></a><strong>问：java的集合框架有哪几种？</strong></h4><p>两种：collection和map，其中collection分为set和List。</p>
<h4 id="问：平常用到哪些集合类？"><a href="#问：平常用到哪些集合类？" class="headerlink" title="问：平常用到哪些集合类？"></a><strong>问：平常用到哪些集合类？</strong></h4><p>答：ArrayList，LinkedList，HashSet，HashMap，TreeMap等（补充：ArrayQueue，PriorityQueue，TreeSet，EnumSet，LinkedHashSet，EnumMap，LinkedHashMap，WeakHashMap，IdentityHashMap）</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/%E9%9B%86%E5%90%88.svg"></p>
<p><a href="../2019040901.html" title="Title">Java集合(一) 概述</a></p>
<h4 id="问：集合迭代器的原理？"><a href="#问：集合迭代器的原理？" class="headerlink" title="问：集合迭代器的原理？"></a><strong>问：集合迭代器的原理？</strong></h4><p>集合接口Collection继承了接口Iterable，此接口有一个方法 <code>iterator()</code> 返回一个迭代器Iterator接口。</p>
<p>Iterator接口定义了三个方法：<code>hasNext()</code> 、<code>next()</code> 、<code>remove()</code> 。</p>
<p>在如AbstractList和ArrayList中通过私有类Itr实现Iterator接口，采用快速失败模式，定义了一个计数器ModCount来保证在遍历过程中内容未被修改，否则抛出异常。</p>
<h4 id="问：快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#问：快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a><strong>问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</strong></h4><p>快速失败是指迭代器遍历集合对象时发现内容被同时修改，且修改导致了计数器与期待值不同，导致抛出异常Concurrent Modification Exception（迭代器内部有计数器ModCount，每次移动指针前会检查当前值是否是expected，若修改不会使modCount不匹配就不会抛出异常）</p>
<p>安全失败则是指相应集合并不直接在内部访问，而是先拷贝副本，在副本上进行遍历，所以遍历过程中的修改不会影响到读取。</p>
<h4 id="问：了解了哪些并发安全集合，从list到map都讲一下？"><a href="#问：了解了哪些并发安全集合，从list到map都讲一下？" class="headerlink" title="问：了解了哪些并发安全集合，从list到map都讲一下？"></a><strong>问：了解了哪些并发安全集合，从list到map都讲一下？</strong></h4><ul>
<li><p>被弃用的两个集合：vector，HashTable。</p>
</li>
<li><p>Collections对集合的安全封装（如Collections.synchronizedList）</p>
</li>
<li><p>Concurrent包提供的：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue，还有加了写锁的CopyOnWriteArrayList和CopyOnWriteArraySet。</p>
</li>
</ul>
<h4 id="问：List，Map，Set-接口在存取元素时，各有什么特点？"><a href="#问：List，Map，Set-接口在存取元素时，各有什么特点？" class="headerlink" title="问：List，Map，Set 接口在存取元素时，各有什么特点？"></a><strong>问：List，Map，Set 接口在存取元素时，各有什么特点？</strong></h4><ul>
<li>List：元素存入有顺序，可重复。取元素时可以用迭代器遍历获取，也可以根据下标获取。</li>
<li>Map：元素按键值对存储，无存放顺序，键不可重复，值可重复。可以根据键获得值，也可以获得所有键或值的集合，以及键值组合的对象Entry的集合。</li>
<li>Set：元素存入无顺序，不可重复。取元素时需要用迭代器遍历获取。</li>
</ul>
<h4 id="问：接口RandomAccess的作用？"><a href="#问：接口RandomAccess的作用？" class="headerlink" title="问：接口RandomAccess的作用？"></a><strong>问：接口RandomAccess的作用？</strong></h4><p>类似于Serializable和Cloneable，RandomAccess也是一个标记接口，表示对象支持快速随机访问。比如ArrayList实现了此接口，其底层是数组，而LinkedList则未实现此接口，其底层是链表。</p>
<p>对于支持快速随机访问的集合可以使用循环来高效遍历，而不支持的有序集合最好使用迭代器来遍历。</p>
<hr>
<h2 id="第二节-List"><a href="#第二节-List" class="headerlink" title="第二节 List"></a><strong>第二节 List</strong></h2><h4 id="问：List你使用过哪些？"><a href="#问：List你使用过哪些？" class="headerlink" title="问：List你使用过哪些？"></a><strong>问：List你使用过哪些？</strong></h4><p>ArrayList和LinkedList使用的最多，也最具代表性。</p>
<h4 id="问：你知道vector和ArrayList和linkedList的区别嘛？扩容机制等？"><a href="#问：你知道vector和ArrayList和linkedList的区别嘛？扩容机制等？" class="headerlink" title="问：你知道vector和ArrayList和linkedList的区别嘛？扩容机制等？"></a><strong>问：你知道vector和ArrayList和linkedList的区别嘛？扩容机制等？</strong></h4><p>ArrayList实现是一个数组，可变数组，默认初始化长度为10，也可以我们设置容量，但是没有设置的时候是默认的空数组，只有在第一步add的时候会进行扩容至10（重新创建了数组），后续扩容按照3/2的大小进行扩容，是线程不安全的，适用多读取，少插入的情况。</p>
<p>linkedList是基于双向链表的实现，使用了尾插法的方式，内部维护了链表的长度，以及头节点和尾节点，所以获取长度不需要遍历。适合一些插入/删除频繁的情况。</p>
<p>Vector是线程安全的，实现方式和ArrayList相似，也是基于数组，但是方法上面都有synchronized关键词修饰。其扩容方式是原来的两倍。</p>
<h4 id="问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？"><a href="#问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？" class="headerlink" title="问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？"></a><strong>问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？</strong></h4><p>ArrayList底层通过数组来存放元素，但因为实现了自动扩容所以也叫作动态数组。扩容、插入和删除操作都通过grow函数调用数组浅复制库函数（System.arraycopy），其中扩容通过复制生成副本返回一个新的数组，非尾部插入和删除则是对当前数组进行覆盖式的复制，删除操作最后会移除末尾元素。</p>
<p>对于ArrayList，删除元素时，后续元素会前移，所以如果遍历方向是正向，会漏掉删除操作后一位的元素判断，如果使用for-each循环遍历会因为修改了操作数而直接抛出异常。</p>
<p>对于LinkedList，删除元素时会先后断开要元素和前后节点的链接，然后重新链接前后节点，根据情况更新链表首尾节点，并清空元素值。</p>
<p><a href="../2019041002.html" title="Title">Java集合(三) List</a></p>
<h4 id="问：ArrayList和LinkedList区别？使用场景？链表和数组的优缺点？"><a href="#问：ArrayList和LinkedList区别？使用场景？链表和数组的优缺点？" class="headerlink" title="问：ArrayList和LinkedList区别？使用场景？链表和数组的优缺点？"></a><strong>问：ArrayList和LinkedList区别？使用场景？链表和数组的优缺点？</strong></h4><p>答：ArrayList是动态索引数组，LinkedList则是有序链表。前者可以快速随机访问，后者则会较慢。但链表更方便删除，因为只要局部变动，而数组则会影响到后续所有元素。所以数组易查难改，链表易改难查。LinkedList也通过迭代器进行插入操作。</p>
<p>ArrayList适合在频繁读取的场景，而LinkedList则适合在频繁插入删除的场景。</p>
<h4 id="问：讲一下写时复制？写时复制和读写锁的区别？"><a href="#问：讲一下写时复制？写时复制和读写锁的区别？" class="headerlink" title="问：讲一下写时复制？写时复制和读写锁的区别？"></a><strong>问：讲一下写时复制？写时复制和读写锁的区别？</strong></h4><p>写时复制即CopyOnWrite，通过延迟更新的策略，牺牲数据实时性，保证数据一致性和读线程互不阻塞。</p>
<ul>
<li><p>相同点：两者都是通过读写分离思想实现，都实现了读线程间互不阻塞。</p>
</li>
<li><p>不同点：使用读写锁依然会存在线程阻塞等待的情况，而COW则牺牲了数据实时性，保证读线程不会存在等待。</p>
</li>
</ul>
<h4 id="问：CopyOnWriteArrayList-原理？"><a href="#问：CopyOnWriteArrayList-原理？" class="headerlink" title="问：CopyOnWriteArrayList 原理？"></a><strong>问：CopyOnWriteArrayList 原理？</strong></h4><p>CopyOnWriteArrayList 通过写时复制思想来实现线程安全的动态数组，底层数据结构仍是对象数组，但被 <code>volatile</code> 修饰来保证可见性。通过可重入锁 <code>ReentrantLock</code> 来保证写线程安全，读操作与单线程无异，写操作则先获取锁，然后通过 <code>System.arraycopy()</code> 进行数组浅复制，在新数组上添加元素，最终再更新数组引用。因为 <code>happens-before</code> 规则，保证读线程可以感知。</p>
<h4 id="问：ArrayBlockingQueue-和-LinkedBlockingQueue-区别？"><a href="#问：ArrayBlockingQueue-和-LinkedBlockingQueue-区别？" class="headerlink" title="问：ArrayBlockingQueue 和 LinkedBlockingQueue 区别？"></a><strong>问：ArrayBlockingQueue 和 LinkedBlockingQueue 区别？</strong></h4><ol>
<li><strong>队列中锁的实现不同</strong>：<ul>
<li><code>ArrayBlockingQueue</code> 队列中的锁是没有分离的，即生产和消费用的是同一个锁；</li>
<li><code>LinkedBlockingQueue</code> 队列中的锁是分离的，即生产用的是 <code>putLock</code> ，消费是 <code>takeLock</code> 。</li>
</ul>
</li>
<li><strong>在生产或消费时操作不同</strong>：<ul>
<li><code>ArrayBlockingQueue</code> 队列中在生产和消费的时候，是直接将枚举对象插入或移除的；</li>
<li><code>LinkedBlockingQueue</code> 队列中在生产和消费的时候，需要把枚举对象转换为 <code>Node&lt;E&gt;</code> 进行插入或移除，会影响性能。</li>
</ul>
</li>
<li><strong>队列大小初始化方式不同</strong>：<ul>
<li><code>ArrayBlockingQueue</code> 实现的队列中必须指定队列的大小；</li>
<li><code>LinkedBlockingQueue</code> 实现的队列中可以不指定队列的大小，但是默认是 <code>Integer.MAX_VALUE</code> 。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第三节-Set"><a href="#第三节-Set" class="headerlink" title="第三节 Set"></a><strong>第三节 Set</strong></h2><h4 id="问：HashSet-和-TreeSet-原理？"><a href="#问：HashSet-和-TreeSet-原理？" class="headerlink" title="问：HashSet 和 TreeSet 原理？"></a><strong>问：HashSet 和 TreeSet 原理？</strong></h4><p><code>HashSet</code> 即散列集，因为散列的关系所以集合的访问顺序是随机的。底层是基于一个 <code>HashMap</code> 来实现的，相关操作也是直接调用  <code>HashMap</code> API来完成。其设计就是利用 <code>HashMap</code> 的键来存放元素，用统一的 <code>PRESENT</code> 来作为 <code>HashMap</code> 的值，利用 <code>HashMap</code> 的键的唯一性来实现集合的元素不重复。<br><code>TreeSet</code> 即树集，与散列集不同，树集是一个有序集合，其排序通过红黑树来实现，每次新增元素时都会放在正确的排序位置，以新增操作的开销来实现有序访问。</p>
<hr>
<h2 id="第四节-Map"><a href="#第四节-Map" class="headerlink" title="第四节 Map"></a><strong>第四节 Map</strong></h2><h3 id="4-1-HashMap"><a href="#4-1-HashMap" class="headerlink" title="4.1 HashMap"></a><strong>4.1 HashMap</strong></h3><h4 id="问：说说你了解的HashMap吧？能讲讲HashMap的实现原理吗？HashMap的底层是什么？HashMap内部数据结构？1-8版本的优化-⭐⭐⭐"><a href="#问：说说你了解的HashMap吧？能讲讲HashMap的实现原理吗？HashMap的底层是什么？HashMap内部数据结构？1-8版本的优化-⭐⭐⭐" class="headerlink" title="**问：说说你了解的HashMap吧？能讲讲HashMap的实现原理吗？HashMap的底层是什么？HashMap内部数据结构？1.8版本的优化 **⭐⭐⭐"></a>**问：说说你了解的HashMap吧？能讲讲HashMap的实现原理吗？HashMap的底层是什么？HashMap内部数据结构？1.8版本的优化 **⭐⭐⭐</h4><p>hashMap</p>
<ul>
<li>内部使用数组+链表的方式实现。默认负载因子是0.75。</li>
<li>通过散列函数把元素均匀的分散到不同的散列值上，也就是对应的数组下标上。</li>
<li>因为散列是不可靠的，会出现哈希冲突，所以采用链表来存放因为哈希冲突而产生的相同哈希值但不同的元素。</li>
<li>1.8版本后增加了红黑树进行优化，在链表结构超过8个节点后就裂变为红黑树，把查询的复杂度变成O(logn)。</li>
</ul>
<p>操作：</p>
<ol>
<li>get：计算hashcode，通过(n-1)&amp;hash获取数组下标，遍历链表或红黑树找到节点。</li>
<li>put：通过(n-1)&amp;hash获取数组下标，获取头节点，若为空则要新建Node，分别判断头节点是否命中，以及是否裂变为红黑树，循环遍历链表或红黑树找到节点或者未命中，若未命中则新建节点加入链表，并判断长度是否超过8要变树，若命中则更新value。</li>
<li>扩容：旧容量*2，遍历旧哈希表，重新ReHash再散列到新哈希表。</li>
<li>裂变：链表长度超过8就升级为红黑树。</li>
</ol>
<p>1.8版本的优化：</p>
<ol>
<li>计算hashcode优化为h^(h&gt;&gt;&gt;16)，高16位不变，低16位变为原高16位和原低16位的异或，因为获取数组下标时(n-1)&amp;hash，n一般很小，高16位失去意义，异或后可以降低哈希冲突发生的概率。</li>
<li>数组+链表优化为数组+链表+红黑树，使链表查询效率O(n/2)O(n)优化为O(logn)。</li>
<li>头插法改为尾插法，因为头插法多线程扩容时容易导致形成单循环链表，线程1先扩容，新链表顺序倒转，线程2恢复扩容，形成环状结构。</li>
<li>1.7版本扩容操作每个元素都要rehash，1.8优化为hash&amp;oldCap=0则不需要变动位置，而要变动位置的新坐标new=旧坐标x+oldCap。证明：与oldCap=0，表示oldCap为1的位置为0，即oldCap=0100，则X0XX。求下标时为(n-1)&amp;hash，即0011&amp;X0XX，结果为00XX。扩容后(2n-1)&amp;hash，即0111&amp;X0XX，结果还是00XX。所以下标扩容前后不会变。</li>
</ol>
<h4 id="问：解决hash冲突的方法有哪些？⭐⭐"><a href="#问：解决hash冲突的方法有哪些？⭐⭐" class="headerlink" title="问：解决hash冲突的方法有哪些？⭐⭐"></a><strong>问：解决hash冲突的方法有哪些？</strong>⭐⭐</h4><ul>
<li><p><strong>开放定址法</strong>、<strong>链地址法（拉链法）</strong>、<strong>再哈希法</strong>、公共溢出区、布谷鸟哈希。</p>
</li>
<li><p>开放定址法（Open Addressing）：当发生哈希冲突时，<strong>寻找数组中其他空闲位置</strong>的方法。</p>
<ul>
<li>常见策略：<ul>
<li><strong>线性探测：</strong> 从冲突位置开始，依次检查下一个位置，直到找到空闲位置为止。</li>
<li><strong>二次探测：</strong> 与线性探测类似，但是每次移动的步长是二次方数，例如 1，4，9，…。</li>
<li><strong>随机探测：</strong> 使用随机数生成器来确定下一个要检查的位置。</li>
<li><strong>双重散列</strong>：如果索引位置被占用，就用另一个哈希函数来决定步长。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>简单：</strong> 实现起来比较简单。</li>
<li><strong>节省空间：</strong> 不需要额外的链表等数据结构。</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><strong>容易产生聚集：</strong> 线性探测容易产生聚集现象，导致查询效率降低。</li>
<li><strong>删除操作复杂：</strong> 删除元素时需要进行特殊处理，以避免影响其他元素的查找。</li>
</ul>
</li>
</ul>
</li>
<li><p>链地址法（Separate Chaining）：将<strong>所有哈希地址相同的元素</strong>都存储在<strong>同一个链表</strong>（或红黑树）中的方法。每个数组位置都指向一个链表的头部，当发生哈希冲突时，将新元素添加到链表的尾部。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简单：</strong> 实现起来比较简单。</li>
<li><strong>解决聚集问题：</strong> 可以有效地解决聚集现象。</li>
<li><strong>删除操作简单：</strong> 删除元素时只需要从链表中移除即可。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>占用额外空间：</strong> 需要额外的空间来存储链表。</li>
<li><strong>查询效率可能降低：</strong> 当链表过长时，查询效率会降低。</li>
</ul>
</li>
<li><p>再哈希法（Rehashing）：指使用<strong>多个不同的哈希函数</strong>。当发生哈希冲突时，使用第二个哈希函数计算新的哈希地址，直到找到空闲位置为止。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>减少聚集：</strong> 可以有效地减少聚集现象。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>计算开销大：</strong> 需要计算多个哈希函数。</li>
</ul>
</li>
<li><p>公共溢出区：建立一个<strong>公共溢出区</strong>，用于存储所有发生哈希冲突的元素。当发生哈希冲突时，将元素放入溢出区。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简单：</strong> 实现起来比较简单。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>查询效率可能降低：</strong> 当溢出区元素过多时，查询效率会降低。</li>
</ul>
</li>
<li><p>布谷鸟哈希：使用<strong>两个哈希函数</strong>，每个元素有两个可能存储位置。如果发生冲突，<strong>踢出</strong>原有元素，原有元素再找新位置。</p>
</li>
<li><p>开发地址法会在发生哈希碰撞时通过探测技术继续在哈希表中找到空闲位置来存放，根据探测方式的不同有线性探测、二次探测和双散列探测。链地址法就是将每个散列表元素都对应一个链表。</p>
</li>
</ul>
<h4 id="问：hashmap查询的时间复杂度能达到O-1-是什么实现的？里面的索引是怎么计算的？⭐"><a href="#问：hashmap查询的时间复杂度能达到O-1-是什么实现的？里面的索引是怎么计算的？⭐" class="headerlink" title="问：hashmap查询的时间复杂度能达到O(1)是什么实现的？里面的索引是怎么计算的？⭐"></a><strong>问：hashmap查询的时间复杂度能达到O(1)是什么实现的？里面的索引是怎么计算的？</strong>⭐</h4><ul>
<li>HashMap查询时根据哈希映射计算得到哈希码，直接走数组索引找到对应链表，不考虑哈希冲突的情况，可以达到O(1)。</li>
<li>索引通过调用对象的hashcode方法获取原始哈希码，然后右移16位使高区16位和低区16位进行异或运算，保留原高区16位，因为高区16位基本用不到，这样融合高区和低区的特征。在计算数组索引时再通过 <code>(n - 1) &amp; hash</code> 来得到相应下标。</li>
</ul>
<h4 id="问：HashMap什么时候会进行rehash？⭐"><a href="#问：HashMap什么时候会进行rehash？⭐" class="headerlink" title="问：HashMap什么时候会进行rehash？⭐"></a><strong>问：HashMap什么时候会进行rehash？</strong>⭐</h4><p>当所存键值对超过阈值，即容量和装填因子loadFactor的积时，HashMap需要扩容并因为容量的变更而对元素进行再散列。</p>
<h4 id="问：HashMap的初始容量设置成多少比较合适呢？"><a href="#问：HashMap的初始容量设置成多少比较合适呢？" class="headerlink" title="问：HashMap的初始容量设置成多少比较合适呢？"></a><strong>问：HashMap的初始容量设置成多少比较合适呢？</strong></h4><p>一般设置为预测元素数的75%到150%，因为一般装填因子为0.75，扩容和再散列会比较影响哈希表性能，所以要尽量保证不会发生多次再散列。</p>
<h4 id="问：HashMap为什么不是线程安全的？怎么让HashMap变得线程安全？HashMap多线程有什么问题？怎么解决？⭐"><a href="#问：HashMap为什么不是线程安全的？怎么让HashMap变得线程安全？HashMap多线程有什么问题？怎么解决？⭐" class="headerlink" title="问：HashMap为什么不是线程安全的？怎么让HashMap变得线程安全？HashMap多线程有什么问题？怎么解决？⭐"></a><strong>问：HashMap为什么不是线程安全的？怎么让HashMap变得线程安全？HashMap多线程有什么问题？怎么解决？</strong>⭐</h4><p>因为HashMap实现中并没有添加锁机制，多线程时容易导致数据错误。</p>
<p>比如：</p>
<ol>
<li>put操作，多个线程得到相同的哈希码，可能会导致A线程结果覆盖掉B线程结果。</li>
<li>旧版本的resize因为头插法的实现多线程会导致单向循环链表，get操作会陷入死循环。</li>
</ol>
<ol>
<li>Collections.synchronizedMap()，生成一个新的SynchronizedMap，向HashMap实现中增加锁机制的设计可以使其线程安全。</li>
<li>使用线程安全的ConcurrentHashMap。虽然Hashtable有加锁，但synchronized会大大降低效率，而ConcurrentHashMap使用了分段锁技术，效率会更高。当然单线程的HashMap的效率更高，能使用就尽量使用。多线程环境下，也可以运用栈封闭、ThreadLocal类、UnmodifiableMap类等方式使用HashMap。</li>
</ol>
<h4 id="问：结合源码说说HashMap在高并发场景中为什么会出现死循环？"><a href="#问：结合源码说说HashMap在高并发场景中为什么会出现死循环？" class="headerlink" title="问：结合源码说说HashMap在高并发场景中为什么会出现死循环？"></a><strong>问：结合源码说说HashMap在高并发场景中为什么会出现死循环？</strong></h4><p>高并发场景中多线程间会发生竞争，HashMap在put时会因为容量不足而进行扩容，旧版本新增元素是头插法，新元素会插在前面链接老元素，而在扩容后新数组链表会倒置，多线程环境下，线程间竞争一个线程读取数据后挂起，另一个线程执行使链表倒置，线程恢复后继续执行形成循环链表，所以形成了死循环。</p>
<h4 id="问：HashMap-扩容机制，为什么都是-2-的-N-次幂？⭐⭐"><a href="#问：HashMap-扩容机制，为什么都是-2-的-N-次幂？⭐⭐" class="headerlink" title="问：HashMap 扩容机制，为什么都是 2 的 N 次幂？⭐⭐"></a><strong>问：HashMap 扩容机制，为什么都是 2 的 N 次幂？</strong>⭐⭐</h4><p>根据哈希码获取数组索引是 <code>(n - 1) &amp; hash</code> ，计算机可以高效进行按位与运算，<strong>当数组长度是2的N次方，其减一后会是前0后1的二进制格式，因此在进行与运算时1的部分就可以充分散列，如果后面还有0就会导致不同哈希码与运算得到相同索引，使散布不均匀</strong>。</p>
<h4 id="问：为什么HashMap装填因子是0-75？⭐"><a href="#问：为什么HashMap装填因子是0-75？⭐" class="headerlink" title="问：为什么HashMap装填因子是0.75？⭐"></a>问：为什么HashMap装填因子是0.75？⭐</h4><p>为什么是0.75呢？</p>
<ul>
<li>当负载因子太小，就很容易触发扩容，如果负载因子太大就容易出现碰撞。所以这个是空间和时间的一个均衡点</li>
<li>0.75的负载因子中，能让随机hash更加满足0.5的泊松分布。</li>
</ul>
<h4 id="问：HashMap和HashTable和ConcurrentHashMap的区别？"><a href="#问：HashMap和HashTable和ConcurrentHashMap的区别？" class="headerlink" title="问：HashMap和HashTable和ConcurrentHashMap的区别？"></a><strong>问：HashMap和HashTable和ConcurrentHashMap的区别？</strong></h4><ul>
<li>HashMap：是map类型的一种最常用的数据结构，其底部实现是数组+链表/红黑树，其key是可以为null的，默认hash值为0，扩容以2的幂等次，是线程不安全的。</li>
<li>HashTable：实现形式和hashMap差不多，它是线程安全的，是继承了Dictionary，也是key-value的模式，但是其key不能为null。</li>
<li>ConcurrentHashMap：是并发包提供的一种线程安全的并发容器，采用分段的思想，早期版本通过分段锁Segment—基于ReetrantLock来实现的，1.8版本修改为 Node[] + CAS + Synchronized。</li>
</ul>
<h4 id="问：HashMap和HashTable有何不同？"><a href="#问：HashMap和HashTable有何不同？" class="headerlink" title="问：HashMap和HashTable有何不同？"></a><strong>问：HashMap和HashTable有何不同？</strong></h4><p>Hashtable对部分方法有线程安全优化，而HashMap非线程安全。HashMap的键值允许为空，Hashtable则都不能为空。Hashtable因为使用synchronized效率不高，而HashMap在单线程环境下效率很高。</p>
<h4 id="问：HashMap-和-WeakHashMap-的区别？"><a href="#问：HashMap-和-WeakHashMap-的区别？" class="headerlink" title="问：HashMap 和 WeakHashMap 的区别？"></a><strong>问：HashMap 和 WeakHashMap 的区别？</strong></h4><ul>
<li>WeakHashMap通过弱引用来保存键，如果没有普通对象引用只剩弱引用在使用对象（忽略映射中value对对象的强引用），GC会在周期性的垃圾回收中收回这些无用对象。</li>
<li>当只剩弱引用在使用对象时WeakHashMap就相当于退化为了HashMap。</li>
</ul>
<h4 id="问：HashMap-和-ConcurrentHashMap-的区别？在-hash-上的区别？"><a href="#问：HashMap-和-ConcurrentHashMap-的区别？在-hash-上的区别？" class="headerlink" title="问：HashMap 和 ConcurrentHashMap 的区别？在 hash 上的区别？"></a><strong>问：HashMap 和 ConcurrentHashMap 的区别？在 hash 上的区别？</strong></h4><ul>
<li>ConcurrentHashMap线程安全，HashMap非线程安全。</li>
<li>ConcurrentHashMap插入前判断是否需要扩容，HashMap则是插入元素后。</li>
<li>1.8版本的ConcurrentHashMap和HashMap都通过Node数组来实现，但ConcurrentHashMap的Node的val和next是volatile修饰的。</li>
<li>TODO</li>
</ul>
<h4 id="问：HashMap-1-8版本前后的区别？JDK8-做了什么优化？最小树化容量？比如为什么是红黑树，别的树不可以吗；为什么-8-的时候树化，4-不可以吗？⭐⭐"><a href="#问：HashMap-1-8版本前后的区别？JDK8-做了什么优化？最小树化容量？比如为什么是红黑树，别的树不可以吗；为什么-8-的时候树化，4-不可以吗？⭐⭐" class="headerlink" title="问：HashMap 1.8版本前后的区别？JDK8 做了什么优化？最小树化容量？比如为什么是红黑树，别的树不可以吗；为什么 8 的时候树化，4 不可以吗？⭐⭐"></a><strong>问：HashMap 1.8版本前后的区别？JDK8 做了什么优化？最小树化容量？比如为什么是红黑树，别的树不可以吗；为什么 8 的时候树化，4 不可以吗？</strong>⭐⭐</h4><p>HashMap优化：</p>
<ol>
<li>计算hashcode优化为h^(h&gt;&gt;&gt;16)，高16位不变，低16位变为原高16位和原低16位的异或，因为获取数组下标时(n-1)&amp;hash，n一般很小，高16位失去意义，异或后可以降低哈希冲突发生的概率。</li>
<li>数组+链表优化为数组+链表+红黑树，使链表查询效率O(n/2)O(n)优化为O(logn)。</li>
<li>头插法改为尾插法，因为头插法多线程扩容时容易导致形成单循环链表，线程1先扩容，新链表顺序倒转，线程2恢复扩容，形成环状结构。</li>
<li>1.7版本扩容操作每个元素都要rehash，1.8优化为hash&amp;oldCap=0则不需要变动位置，而要变动位置的新坐标new=旧坐标x+oldCap。证明：与oldCap=0，表示oldCap为1的位置为0，即oldCap=0100，则X0XX。求下标时为(n-1)&amp;hash，即0011&amp;X0XX，结果为00XX。扩容后(2n-1)&amp;hash，即0111&amp;X0XX，结果还是00XX。所以下标扩容前后不会变。</li>
</ol>
<p>最小树化容量？</p>
<ul>
<li>MIN_TREEIFY_CAPACITY = 64，区别于树化阈值8，其约束哈希表容量超过此值时才能将链表转换为红黑树，通过此参数可以决定是扩容还是树形化。</li>
<li>防止在哈希表容量较小时，链表长度可能频繁地在 8 附近波动，导致 HashMap 不断地进行树化和反树化操作，这会降低性能。</li>
</ul>
<p>为什么是红黑树？</p>
<ul>
<li>AVL树是高平衡二叉树，其树的调整和旋转频率更高，当然查询更快，<strong>适合查询多、增删少的场景</strong>。</li>
<li>红黑树则对平衡要求没那么高，调整代价也更低，旋转次数更少，同时查询也不慢，<strong>适合增删频繁的场景</strong>。</li>
<li>相比如AVL树等，在单链表过长时，通过优化为红黑树更有利于后续更多节点的插入删除操作，综合性能要优于AVL树。</li>
</ul>
<p>为什么树化阈值是8：</p>
<ul>
<li>首先当散列均匀时，链表升级为红黑树的概率不大：理想情况下随机散列函数，概率分布遵循泊松分布，链表长度达到8的概率几乎为不可能。</li>
<li>当节点数量较少时，采用红黑树的意义不大，且因为红黑树节点的大小是普通链表节点大小的两倍，所以还会造成空间上的浪费。</li>
</ul>
<h4 id="问：jdk1-8中，对HashMap和ConcurrentHashMap做了哪些优化？"><a href="#问：jdk1-8中，对HashMap和ConcurrentHashMap做了哪些优化？" class="headerlink" title="问：jdk1.8中，对HashMap和ConcurrentHashMap做了哪些优化？"></a><strong>问：jdk1.8中，对HashMap和ConcurrentHashMap做了哪些优化？</strong></h4><p>HashMap优化：</p>
<ul>
<li>优化了散列函数，通过移位异或，融合了高位特征；</li>
<li>底层由数组+链表改为数组+链表+红黑树，引入了红黑树来处理链表太长的极端情况，提高插入和查询整体效率；</li>
<li>头插法变为尾插法，链表顺序不会改变，从而优化了多线程的死循环问题。</li>
</ul>
<p>ConcurrentHashMap优化：</p>
<ul>
<li>舍弃了臃肿的Segment + HashEntry，改为Node + CAS + Synchronized：Segment继承了ReentrantLock，其分段区域在初始时即确定，即并发数 concurrentLevel是固定的；而后者的并发数 concurrentLevel 是和数组大小保持一致的，每次扩容，并发度扩大一倍。</li>
<li>引入了红黑树来处理链表太长的极端情况等</li>
<li>synchronized在JVM进行了优化：锁粗化、锁消除、锁自旋等等。</li>
</ul>
<h3 id="4-2-ConcurrentHashMap"><a href="#4-2-ConcurrentHashMap" class="headerlink" title="4.2 ConcurrentHashMap"></a><strong>4.2 ConcurrentHashMap</strong></h3><h4 id="问：讲一下你所知道的ConcurrentHashMap？ConcurrentHashMap分段锁？如何分段？1-7与1-8版本的区别？⭐⭐⭐"><a href="#问：讲一下你所知道的ConcurrentHashMap？ConcurrentHashMap分段锁？如何分段？1-7与1-8版本的区别？⭐⭐⭐" class="headerlink" title="问：讲一下你所知道的ConcurrentHashMap？ConcurrentHashMap分段锁？如何分段？1.7与1.8版本的区别？⭐⭐⭐"></a><strong>问：讲一下你所知道的ConcurrentHashMap？ConcurrentHashMap分段锁？如何分段？</strong>1.7与1.8版本的区别？⭐⭐⭐</h4><ol>
<li><p><strong>ConcurrentHashMap 介绍</strong>？</p>
<ul>
<li><strong><code>ConcurrentHashMap</code> 是 Java 并发包（JUC）提供的线程安全 <code>Map</code> 实现</strong>。</li>
<li>主要优化点：<ul>
<li><strong>JDK 1.7 采用</strong> <strong>分段锁（Segment + ReentrantLock）</strong>，减少锁粒度，提高并发性能。</li>
<li><strong>JDK 1.8 采用</strong> <strong>CAS + <code>synchronized</code> + 自旋锁</strong>，移除 <code>Segment</code>，优化性能，支持链表转红黑树。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>JDK 1.7：Segment 分段锁</strong></p>
<p><strong>✅ 1.7 版数据结构</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line"> ├── Segment[] segments  <span class="regexp">//</span> <span class="number">16</span>个Segment，类似小的HashMap，每个独立加锁</span><br><span class="line"> │   ├── table[]         <span class="regexp">//</span> 每个 Segment 维护自己的哈希表</span><br><span class="line"> │   │   ├── HashEntry   <span class="regexp">//</span> 组成链表的节点</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>ConcurrentHashMap</code> 内部维护了 <code>Segment[]</code> 数组（默认16个），每个 <code>Segment</code> 相当于一个小的 <code>HashMap</code>，独立加锁</strong>。</li>
<li>**每个 <code>Segment</code> 继承 <code>ReentrantLock</code>**，写操作时锁住 <code>Segment</code>，不同 <code>Segment</code> 可以并发操作。</li>
<li><strong>最终 <code>size()</code> 计算方式：所有 <code>Segment</code> 的 <code>count</code> 之和</strong>。</li>
</ul>
<p><strong>✅ 1.7 版 put 过程</strong></p>
<ol>
<li><p><strong>计算 key 的 hash</strong></p>
</li>
<li><p>确定 Segment（段）：初始化Segment通过并发级别 <code>concurrencyLevel</code> 计算得到Segment长度和段偏移量 <code>segmentShift</code> 和段掩码 <code>segmentMask</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">segmentIndex = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取 <code>Segment</code> 的 <code>ReentrantLock</code></strong></p>
</li>
<li><p><strong>计算 <code>table</code> 位置，插入 <code>HashEntry</code></strong></p>
</li>
<li><p><strong>释放 <code>Segment</code> 锁</strong></p>
</li>
</ol>
<p><strong>✅ 1.7 版问题</strong></p>
<ul>
<li>**每次 <code>put()</code> 需要锁整个 <code>Segment</code>**，粒度仍然较大。</li>
<li>**扩容时需要迁移整个 <code>Segment</code>**，仍然影响并发性能。</li>
</ul>
</li>
<li><p><strong>JDK 1.8：CAS + synchronized</strong></p>
<p><strong>✅ 1.8 版数据结构</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line"> ├── Node[] table  <span class="regexp">//</span> 直接维护一个哈希表，代替 Segment</span><br><span class="line"> │   ├── Node      <span class="regexp">//</span> 链表节点</span><br><span class="line"> │   ├── TreeNode  <span class="regexp">//</span> 红黑树节点（当链表 &gt; <span class="number">8</span> 时转红黑树）</span><br></pre></td></tr></table></figure>



<p><strong>✅ 1.8 版优化</strong></p>
<ol>
<li><strong>移除了 <code>Segment</code>，直接使用 <code>Node[] table</code></strong></li>
<li>**写操作采用 <code>CAS + synchronized</code>**（减少锁粒度）</li>
<li><strong>链表长度 &gt;8 时，自动转换为红黑树</strong>（提高查询效率）</li>
</ol>
<p><strong>✅ 1.8 版 put 过程</strong></p>
<ol>
<li><strong>计算 hash 值，确定数组索引</strong></li>
<li><strong>如果 <code>table[index] == null</code>，用 CAS 插入</strong></li>
<li><strong>如果 <code>table[index]</code> 非空，使用 <code>synchronized</code> 锁住</strong> <strong>链表头节点</strong></li>
<li><strong>如果是链表，遍历并插入</strong></li>
<li><strong>如果链表长度 &gt; 8，转换为红黑树</strong></li>
</ol>
<p><strong>✅ 1.8 版扩容</strong></p>
<ul>
<li>采用 <strong><code>transfer()</code> + <code>synchronized</code></strong> 控制线程迁移数据，避免 <code>Segment</code> 级扩容的性能瓶颈。</li>
</ul>
</li>
<li><p><strong>JDK 1.7 vs JDK 1.8 对比</strong></p>
<table>
<thead>
<tr>
<th><strong>版本</strong></th>
<th><strong>数据结构</strong></th>
<th><strong>加锁机制</strong></th>
<th><strong>扩容方式</strong></th>
<th><strong>链表优化</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>JDK 1.7</strong></td>
<td><code>Segment[] + HashEntry[]</code></td>
<td><strong>分段锁</strong>（<code>ReentrantLock</code>）</td>
<td><strong>Segment 级别扩容</strong></td>
<td>❌ 无优化</td>
</tr>
<tr>
<td><strong>JDK 1.8</strong></td>
<td><code>Node[]</code></td>
<td><strong>CAS + synchronized</strong>（头结点锁）</td>
<td><strong>全局 <code>transfer()</code>，减少锁竞争</strong></td>
<td>✅ <strong>链表 → 红黑树</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>重点面试题 &amp; 回答思路</strong></p>
<p><strong>❓1. <code>ConcurrentHashMap</code> 在 1.7 和 1.8 的区别？</strong></p>
<p>✅ <strong>回答要点：</strong></p>
<ul>
<li>JDK 1.7：<ul>
<li>采用 **<code>Segment[]</code> + <code>ReentrantLock</code>**（分段锁）。</li>
<li>**每个 <code>Segment</code> 维护自己的 <code>table</code>**，并独立加锁。</li>
<li>**<code>size()</code> 计算需要遍历所有 <code>Segment</code>**，效率较低。</li>
</ul>
</li>
<li>JDK 1.8：<ul>
<li>移除了 <code>Segment</code>，采用 <strong><code>Node[] table</code> 直接存储数据</strong>。</li>
<li>采用 <strong>CAS + <code>synchronized</code> 头节点锁</strong>，减少锁粒度，提高并发性能。</li>
<li><strong>支持链表转红黑树</strong>（<code>TreeNode</code>），提高查询性能。</li>
</ul>
</li>
</ul>
<p><strong>❓2. <code>ConcurrentHashMap</code> 的 put() 过程？</strong></p>
<p>✅ <strong>回答要点（JDK 1.8）</strong></p>
<ol>
<li><p>计算 hash 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = spread(key.hashCode());</span><br></pre></td></tr></table></figure></li>
<li><p>确定数组索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br></pre></td></tr></table></figure></li>
<li><p>如果 <code>table[index] == null</code>，CAS 直接插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果 <code>table[index]</code> 非空</p>
<ul>
<li><strong><code>synchronized</code> 锁住头结点</strong></li>
<li><strong>遍历链表，更新值或插入节点</strong></li>
<li><strong>如果链表长度 &gt; 8，转换为红黑树</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 确保未被修改</span></span><br><span class="line">        <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">            ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K, V&gt; p;</span><br><span class="line">            <span class="keyword">if</span> ((p = putVal(f, hash, key, value)) != <span class="keyword">null</span>)</span><br><span class="line">                oldVal = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>❓3. <code>ConcurrentHashMap</code> 为什么线程安全？</strong></p>
<p>✅ <strong>回答要点</strong></p>
<ol>
<li><strong>写操作</strong><ul>
<li><strong>CAS</strong> 直接插入，无锁操作。</li>
<li><strong>synchronized 锁住头结点</strong>，保证链表/红黑树插入安全。</li>
</ul>
</li>
<li><strong>扩容</strong><ul>
<li><strong><code>transfer()</code> 迁移数据</strong>，防止并发冲突。</li>
<li><strong>并发迁移时，使用 <code>ForwardingNode</code> 作为占位符，防止数据重复迁移</strong>。</li>
</ul>
</li>
<li><strong>读操作</strong><ul>
<li><strong>大部分 <code>get()</code> 只读，不加锁</strong>。</li>
<li><strong>链表结构遍历时不会修改数据，保证可见性</strong>。</li>
</ul>
</li>
</ol>
<p><strong>❓4. <code>ConcurrentHashMap</code> 为什么比 <code>HashTable</code> 性能高？</strong></p>
<p>✅ <strong>回答要点</strong></p>
<ul>
<li><code>HashTable</code> 使用 <code>synchronized</code> <strong>锁住整个 Map</strong>，导致并发性能低。</li>
<li><code>ConcurrentHashMap</code> <strong>1.7 采用分段锁，1.8 采用 CAS + 头结点锁</strong>，提高并发能力。</li>
</ul>
</li>
<li><p><strong>总结</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>版本</strong></th>
<th><strong>数据结构</strong></th>
<th><strong>加锁机制</strong></th>
<th><strong>扩容优化</strong></th>
<th><strong>链表优化</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>JDK 1.7</strong></td>
<td><code>Segment[] + HashEntry[]</code></td>
<td><strong>分段锁（<code>ReentrantLock</code>）</strong></td>
<td><strong>Segment 级别扩容</strong></td>
<td>❌ 无优化</td>
</tr>
<tr>
<td><strong>JDK 1.8</strong></td>
<td><code>Node[]</code></td>
<td><strong>CAS + <code>synchronized</code></strong></td>
<td><strong>全局 <code>transfer()</code>，减少锁竞争</strong></td>
<td>✅ <strong>链表 → 红黑树</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>1.7 采用 <code>Segment</code> 分段锁，锁粒度较大。</strong></li>
<li><strong>1.8 移除 <code>Segment</code>，采用 <code>CAS + synchronized</code>，并支持链表转红黑树，提高并发能力！</strong></li>
</ul>
<h4 id="问：ConcurrentHashMap如何进行散列？⭐⭐"><a href="#问：ConcurrentHashMap如何进行散列？⭐⭐" class="headerlink" title="问：ConcurrentHashMap如何进行散列？⭐⭐"></a><strong>问：ConcurrentHashMap如何进行散列？</strong>⭐⭐</h4><p>1.7版本：</p>
<ul>
<li>ConcurrentHashMap会先在Segment分段时对获得的hashcode进行一次再散列，保证元素能均匀的分布在不同分段上，此阶段定位为 <code>(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask</code> 。</li>
<li>在确定分段后，还会再一次散列，分配到不同的HashEntry中，此阶段定位为 <code>hash &amp; (tab.length - 1)</code> 。两次散列方式不同，这样可以避免一次散列后得到的值过于雷同，导致第二次散列时聚集。</li>
</ul>
<p>1.8版本：</p>
<ul>
<li>通过获取键的哈希码，并将其高位右移异或 <code>(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS</code> ，合并高低位特征，得到新的哈希码。</li>
<li>定位数组索引则通过  <code>(tab.length - 1) &amp; hash</code> 。</li>
</ul>
<ul>
<li><p><strong>1.7：两次散列</strong></p>
<ol>
<li><p><strong>第一次散列（分段索引）</strong>：ConcurrentHashMap在 <code>Segment</code> 分段时，对 <code>key.hashCode()</code> 进行一次再散列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">segmentShift = <span class="number">32</span> - sshift;<span class="comment">//计算得到段偏移量        </span></span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;<span class="comment">//计算得到段掩码 </span></span><br><span class="line">segmentIndex = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></pre></td></tr></table></figure>

<p>作用：<strong>保证 key 均匀分布到不同的 <code>Segment</code>，减少冲突</strong>。</p>
</li>
<li><p><strong>第二次散列（桶索引）</strong>：在 <code>Segment</code> 内部，再次计算 table 数组索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash &amp; (table.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>作用：<strong>减少 Hash 冲突，避免过多链表或红黑树结构</strong>。</p>
</li>
</ol>
</li>
<li><p><strong>1.8：单次散列</strong></p>
<p>JDK 1.8 取消了 <code>Segment</code>，采用单层 <code>Node[]</code> 结构，优化了哈希计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>高 16 位与低 16 位异或</strong>，降低哈希冲突，提高分布均匀性。</p>
<p>定位到 table 的索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (n - <span class="number">1</span>) &amp; hash;</span><br></pre></td></tr></table></figure>

<p>作用：<strong>减少 Hash 冲突，避免哈希桶过度堆积</strong>。</p>
</li>
</ul>
<h4 id="问：ConcurrentHashMap如何获取元素？get-流程？⭐"><a href="#问：ConcurrentHashMap如何获取元素？get-流程？⭐" class="headerlink" title="问：ConcurrentHashMap如何获取元素？get()流程？⭐"></a><strong>问：ConcurrentHashMap如何获取元素？get()流程？</strong>⭐</h4><p><strong>✅ <code>get()</code> 查询流程</strong>：</p>
<ol>
<li><p>计算 hash 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = spread(key.hashCode());</span><br></pre></td></tr></table></figure></li>
<li><p>定位 <code>Node[] table</code> 的索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br></pre></td></tr></table></figure></li>
<li><p>找到桶的头节点，依次匹配：</p>
<ul>
<li><strong>如果首节点 key 匹配，直接返回</strong>。</li>
<li><strong>如果是链表，遍历查找</strong>。</li>
<li><strong>如果是红黑树，进行 <code>TreeNode</code> 查找</strong>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高位异或到低位，更多哈希冲突的场景用红黑树来优化，所以采用这种即方便又能解决问题的方案。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定下标在哈希表中的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//把键的hashcode再散列得到h，合并高位低位特征，使散列更均匀</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//散列表不为空，获取节点e，通过(tab.length - 1) &amp; h与运算定位下标，判断对应下标是否已有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//e不为空，且hash值等于h，再判断key是否相等，是则表示命中，直接返回对应的值</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//e的hash值不等于h，且为负数，表示此时结构为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//尝试遍历树查询key并返回</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//e未命中，若还有后续节点，则遍历链表查询key并返回</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未能找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-get.svg"></p>
<h4 id="问：ConcurrentHashMap如何放置元素？put-流程？⭐"><a href="#问：ConcurrentHashMap如何放置元素？put-流程？⭐" class="headerlink" title="问：ConcurrentHashMap如何放置元素？put()流程？⭐"></a><strong>问：ConcurrentHashMap如何放置元素？put()流程？</strong>⭐</h4><p><strong>✅ <code>put()</code> 主要流程</strong></p>
<ol>
<li><p>计算 hash 值，进入死循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = spread(key.hashCode());</span><br></pre></td></tr></table></figure></li>
<li><p>**如果 <code>table</code> 为空，则初始化 <code>table</code>**。</p>
</li>
<li><p>计算 <code>table</code> 索引位置：</p>
<ul>
<li><strong>如果该位置为空，则 CAS 插入</strong>。</li>
<li><strong>否则，进入 <code>synchronized</code> 锁定头节点，进行链表或红黑树插入</strong>。</li>
</ul>
</li>
<li><p><strong>链表长度 &gt; 8，转换为红黑树</strong>。</p>
</li>
<li><p><strong>如果 <code>size()</code> 超过阈值，触发扩容</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Encodings for Node hash fields. 特殊的哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes 转移节点的hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees 树根的hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先不允许新增空键或空值</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//把键的hashcode再散列得到h，合并高位低位特征，使散列更均匀</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//初始化binCount，用来记录修改的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//死循环遍历Node数组，直到操作成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//判断若是首次执行putVal()，则调用initTable进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//已有哈希表，并且hash对应下标节点还为null，此桶还未被使用，CAS新增节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过Unsafe的compareAndSwapObject尝试新增链表节点，完成任务跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已有哈希表，首节点也已存在，但f处于MOVED状态表示此时正在扩容，则当前线程尝试帮助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);<span class="comment">//帮助扩容</span></span><br><span class="line">        <span class="comment">//已有哈希表，链表也已初始化，且节点不在移动状态，则加锁进行操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//oldVal用来记录旧值</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//代码块加锁同步f节点，根据链表或红黑树分别进行操作</span></span><br><span class="line">            <span class="comment">//链表则覆盖或尾插法新增节点</span></span><br><span class="line">            <span class="comment">//红黑树则调用API，返回对应节点（可能是新建节点），并覆盖</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//若f此时未被修改，则继续操作，否则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//1.首节点hash&gt;=0，表示正常态，即链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//binCount记录为1，至少已有一个</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历此链表，直到完成操作显式终止循环，计算链表长度</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//命中节点，覆盖value，完成操作后跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//记录oldVal，此时表示map中此键已对应有值</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//当onlyIfAbsent为false时才进行覆盖</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="comment">//跳出循环</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点还不是，e移到下个节点next</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//已遍历完链表，未找到则新增节点，尾插法，完成跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.非正常态，而是TreeBin节点，则向红黑树插入节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//binCount更新为2</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//插入树节点，完成操作</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同步块结束</span></span><br><span class="line">            <span class="comment">//binCount不为0表示put已对数据产生了影响，不管是否有覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//若达到链表阈值，就转此节点链表为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);<span class="comment">//转换红黑树</span></span><br><span class="line">                <span class="comment">//oldVal不为空，表示是一次更新操作，没有对元素个数产生影响，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="comment">//否则元素个数已改变，跳出死循环，继续后续操作</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//binCount还为0，put操作未成功，继续死循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新计数值，并继续判断是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial table capacity.  Must be a power of 2</span></span><br><span class="line"><span class="comment"> * (i.e., at least 1) and at most MAXIMUM_CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//当哈希表为空或长度为0时循环操作，否则直接返回</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//若sizeCtl&lt;0，表示散列表正在初始化或扩容，正在被其他线程处理</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin 自旋等待</span></span><br><span class="line">        <span class="comment">//否则CAS更新sizeCtl为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//确认此时还未初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//初始化时sizeCtl可能会自定义，若未自定义则取默认值16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//新建节点数组，初始化table</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//sizeCtl取和无符号右移2位后的差，即每隔n个4，就要减去n，也就是合理的取阈值0.75</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//更新sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-put.svg"></p>
<h4 id="问：ConcurrentHashMap如何统计数目？size-流程？⭐"><a href="#问：ConcurrentHashMap如何统计数目？size-流程？⭐" class="headerlink" title="问：ConcurrentHashMap如何统计数目？size()流程？⭐"></a><strong>问：ConcurrentHashMap如何统计数目？size()流程？⭐</strong></h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-size.svg"></p>
<p>无并发时只要用baseCount就足以，但一旦并发时CAS修改baseCount失败，就要启用counterCells，计算size时会将所有计数单元数组累加。</p>
<p>两种技术器都是通过 <code>addCount()</code> 来更新，但可能会因为并发而更新失败，会采用备用方法 <code>fullAddCount()</code>，死循环不断尝试。</p>
<p><strong>✅ <code>size()</code> 统计方式</strong></p>
<ol>
<li>**如果计数单元数组 <code>counterCells</code> 为空，则直接返回 <code>baseCount</code>**。</li>
<li>**如果 <code>counterCells</code> 存在，则累加所有 <code>counterCells</code> 和 <code>baseCount</code>**。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="问：ConcurrentHashMap如何更新计数器？addCount-流程？"><a href="#问：ConcurrentHashMap如何更新计数器？addCount-流程？" class="headerlink" title="问：ConcurrentHashMap如何更新计数器？addCount()流程？"></a><strong>问：ConcurrentHashMap如何更新计数器？addCount()流程？</strong></h4><p>更新计数器流程分两部分：<strong>并发更新</strong>和<strong>扩容</strong>。</p>
<ol>
<li>首先判断计数单元数组是否已创建，或尝试CAS对baseCount计数更新是否可以成功，二者皆为并发特征。</li>
<li>如果不满足，表示不需要进行<strong>并发更新</strong>，然后根据check参数是否&gt;=0判断是否需要扩容检查，如果不需要则结束。</li>
<li>如果满足，则表示baseCount不可靠，需要更新计数单元数组。</li>
<li>若当前计数单元数组为空，或选定计数单元为空，或CAS更新计数单元失败，则调用备案fullAddCount，然后结束。</li>
<li>若非上述情况，则表示CAS更新成功，再判断所给check，若&lt;=1表示还是链表，则直接返回，不进行扩容检查；若check&gt;1，表示已是红黑树，需还要再算一下此时的size。</li>
<li>然后进入<strong>扩容</strong>流程，首先判断只有 <code>check &gt;= 0</code> 才有必要扩容。</li>
<li>当此时size达到sizeCtl扩容阈值等，以此作为循环条件，则进行<strong>扩容</strong>循环，否则函数执行完毕。</li>
<li>通过哈希表长度获得一个resize标识，是一个低16位首位为1的大数，从而能在左移后变成一个负数。</li>
<li>判断 <code>sizeCtl &lt; 0</code> ，表示其他线程已经在扩容，然后根据五种特征判断扩容是否要结束，若满足即可跳出<strong>扩容</strong>循环。</li>
<li>若不满足特征，表示扩容还在继续，则尝试CAS原子操作 <code>sizeCtl++</code> ，表示帮助线程+1，并执行扩容transfer。</li>
<li>若 <code>sizeCtl &gt;= 0</code> 此时不在扩容，则尝试开启扩容流程，关键在于 <code>(resize &lt;&lt; 16) + 2</code> 得到一个大的负数作为初始值，并CAS覆盖 <code>sizeCtl</code> ，后续每个线程都直接  <code>sizeCtl++</code> ，成功后，执行扩容transfer。</li>
<li>等扩容执行完毕后，更新一下当前size，继续循环，直到扩容条件不满足。</li>
</ol>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-addCount.svg"></p>
<h4 id="问：ConcurrentHashMap的扩容方式？transfer-流程？⭐"><a href="#问：ConcurrentHashMap的扩容方式？transfer-流程？⭐" class="headerlink" title="问：ConcurrentHashMap的扩容方式？transfer()流程？⭐"></a><strong>问：ConcurrentHashMap的扩容方式？transfer()流程？</strong>⭐</h4><p>1.7版本：concurrentHashMap是基于了segment的，segment内部维护了HashEntity数组，所以扩容是在这个基础上的，类比hashmap的扩容。</p>
<p>1.8版本：</p>
<ol>
<li>扩容流程可以多线程协作提高速度，每个线程负责一块区域，要求至少16个桶。</li>
<li>扩容通过转移节点到新表来完成，新表初始化为旧表2倍大小。</li>
<li>因为要线程间协作，在某线程转移某下标链表后，会在旧表用一个转移节点替换表示已处理。</li>
<li>线程按分区一段一段倒序内循环，完成遍历后更新 <code>sizeCtl--</code> ，表示参与转移线程数-1。</li>
<li>当线程要进行转移时，根据链表和红黑树有不同的实现，但思路是一样的，都保留哈希码不变的，转移哈希码变更的。</li>
<li>转移过程通过 <code>synchronized</code> 锁住同步资源-首节点。</li>
</ol>
<p><strong>✅ JDK 1.7 扩容</strong></p>
<ul>
<li><strong>使用 <code>ReentrantLock</code> 加锁 <code>Segment</code>，然后扩容</strong>。</li>
</ul>
<p><strong>✅ JDK 1.8 扩容</strong></p>
<ul>
<li><strong>采用 <code>transfer()</code> 迁移数据</strong>，支持<strong>多线程并发扩容</strong>。</li>
<li><strong>标记 <code>ForwardingNode</code> 占位，防止重复迁移</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// 每个线程负责的最小任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += stride)</span><br><span class="line">        transferStep(tab, nextTab, i, stride);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/ConcurrentHashMap-transfer.svg"></p>
<h4 id="问：为什么说ConcurrentHashMap只具有弱一致性？"><a href="#问：为什么说ConcurrentHashMap只具有弱一致性？" class="headerlink" title="问：为什么说ConcurrentHashMap只具有弱一致性？"></a><strong>问：为什么说ConcurrentHashMap只具有弱一致性？</strong></h4><p>首先什么是数据弱一致性：</p>
<p>一致性常包含两类：<strong>数据一致性</strong>和<strong>事务一致性</strong>。导致数据一致性问题的原因是<strong>复制</strong>，弱一致性是相对于强一致性。<strong>强一致性的复制是同步的，弱一致性的复制是异步的</strong>。强一致性保证数据一定是一致的。</p>
<p>回到问题，并发容器具有弱一致性，主要是因为<strong>Java内存模型的 <code>happens-before</code> 原则</strong>。</p>
<p>现象是对于ConcurrentHashMap，当put一个元素后，并不一定能立刻get到此元素。对于 hb原则 来说，就是put和get的 hb关系 并非代码层面的顺序。即get操作运行到某行代码后，此时put操作还未完成，那么对于此get是无法感知到变化的。</p>
<p>ConcurrentHashMap能够保证每一次调用都是原子操作，但是并不保证多次调用之间也是原子操作。</p>
<p>所以Java API中声明的是保证get操作一定能看到<strong>已完成</strong>的put操作。</p>
<p>ConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样了。</p>
<h4 id="问：ConcurrentHashMap和LinkedHashMap有什么区别？"><a href="#问：ConcurrentHashMap和LinkedHashMap有什么区别？" class="headerlink" title="问：ConcurrentHashMap和LinkedHashMap有什么区别？"></a><strong>问：ConcurrentHashMap和LinkedHashMap有什么区别？</strong></h4><ul>
<li>LinkedHashMap的节点链表是双向，ConcurrentHashMap则是单向</li>
<li>ConcurrentHashMap是并发容器，LinkedHashMap则不能保证线程安全。</li>
</ul>
<h4 id="问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？"><a href="#问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？" class="headerlink" title="问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？"></a><strong>问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？</strong></h4><p>红黑树的占用空间是普通链表的两倍，如果哈希表的离散性足够好，各个节点的分布应该很均衡，所以很难会出现某个节点链表聚集的情况，但离散性较差时，就可能出现某个节点频繁哈希碰撞，所以根据概率统计得出随机哈希案例中桶达到8的概率很小仅为0.00000006，置换为红黑树就是为了防止糟糕的设计，使哈希表失去其效率，不如直接替换为红黑树来提升性能。</p>
<p>为什么树化阈值是8：</p>
<ul>
<li>首先当散列均匀时，链表升级为红黑树的概率不大：理想情况下随机散列函数，概率分布遵循泊松分布，链表长度达到8的概率几乎为不可能。</li>
<li>当节点数量较少时，采用红黑树的意义不大，且因为红黑树节点的大小是普通链表节点大小的两倍，所以还会造成空间上的浪费。</li>
</ul>
<h3 id="4-3-ConcurrentSkipListMap"><a href="#4-3-ConcurrentSkipListMap" class="headerlink" title="4.3 ConcurrentSkipListMap"></a><strong>4.3 ConcurrentSkipListMap</strong></h3><h4 id="问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？"><a href="#问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？" class="headerlink" title="问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？"></a><strong>问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？</strong></h4><p>ConcurrentSkipListMap是跳跃列表映射</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line"> ❌ <span class="keyword">Sorted</span></span><br><span class="line"> ❌ Navigable</span><br><span class="line"> ✅ Concurrent</span><br><span class="line">ConcurrentSkipListMap</span><br><span class="line"> ✅ <span class="keyword">Sorted</span></span><br><span class="line"> ✅ Navigable</span><br><span class="line"> ✅ Concurrent</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ConcurrentSkipListMap是有序的，ConcurrentHashMap则非有序。</p>
</li>
<li><p>ConcurrentHashMap不能保证其操作的运行时间（散列结构因为重新散列的情况），允许对某些负载因子进行调整（大致是同时修改它的线程数）。ConcurrentSkipListMap则保证了各种操作的平均 O(log n) 性能，其本身是并发的，不支持为了并发性而进行的调优，而ConcurrentHashMap则可以进行并发调优。</p>
</li>
<li><p>ConcurrentSkipListMap还有许多ConcurrentHashMap没有的操作：<code>ceilingEntry/Key</code> 、<code>floorEntry/Key</code> 等。</p>
</li>
</ul>
<p>因为要维护一个排序顺序，相比ConcurrentHashMap，它的 <code>get/put/contains</code> 操作要慢，但它支持SortedMap，NavigableMap，ConcurrentNavigableMap等接口。如果使用ConcurrentHashMap得到一个顺序映射，则必须计算排序顺序（费用很高）。</p>
<p>通常情况下，如果需要快速添加单个键/值对和快速查找单个键，最好使用HashMap。如果需要更快的顺序遍历，并且能够负担额外的插入成本，可以使用SkipListMap。</p>
<p>ConcurrentSkipListMap通过随机数来保持平衡。</p>
<h3 id="4-4-LinkedHashMap"><a href="#4-4-LinkedHashMap" class="headerlink" title="4.4 LinkedHashMap"></a><strong>4.4 LinkedHashMap</strong></h3><h4 id="问：LinkedHashMap用过吗？讲一下？存进集合如何比较大小保证顺序？"><a href="#问：LinkedHashMap用过吗？讲一下？存进集合如何比较大小保证顺序？" class="headerlink" title="问：LinkedHashMap用过吗？讲一下？存进集合如何比较大小保证顺序？"></a><strong>问：LinkedHashMap用过吗？讲一下？存进集合如何比较大小保证顺序？</strong></h4><p>答：用过，LinkedHashMap会在每次访问元素后把元素放置到节点链表的尾部，也就记录了链表的访问顺序，可以用来实现LRU。</p>
<p>重写removeEldestEntry方法，使其判断当此时链表达到限制地阈值大小时，返回true，这样put方法被调用时会自动删除最老元素即此时链表的首节点。</p>
<p>LinkedHashMap是HashMap的一种特殊分支，是某种有序的hashMap，和TreeMap是不一样的概念，是用了HashMap+链表的方式来构造的，有两者有序模式：访问有序，插入顺序，插入顺序是一直存在的，因为是调用了hashMap的put方法，并没有重载，但是重载了newNode方法，在这个方法中，会把节点插入链表中，访问有序默认是关闭的，如果打开，则在每次get的时候都会把链表的节点移除掉，放到链表的最后面。这样子就是一个LRU的一种实现方式。</p>
<h3 id="4-5-TreeMap"><a href="#4-5-TreeMap" class="headerlink" title="4.5 TreeMap"></a><strong>4.5 TreeMap</strong></h3><h4 id="问：讲讲TreeMap？"><a href="#问：讲讲TreeMap？" class="headerlink" title="问：讲讲TreeMap？"></a><strong>问：讲讲TreeMap？</strong></h4><p>TreeMap是Map中的一种很特殊的map，我们知道Map基本是无序的，但是TreeMap是会自动进行排序的，也就是一个有序Map(使用了红黑树来实现），如果设置了Comparator比较器，则会根据比较器来对比两者的大小，如果没有则key需要是Comparable的子类（代码中没有事先check，会直接抛出转化异常，有点坑啊）。<br>树映射TreeMap，由红黑树实现的有序映射。<strong>TreeMap为增、删、改、查这些操作提供了 O(log n) 的时间开销</strong>，相比HashMap的 O(1) 存储效率要差些，但查询统计的 O(log n) 比HashMap O(n) 要高效。 </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pony1223/p/7892401.html">Java提高十六：TreeMap深入分析</a></p>
<h4 id="问：TreeMap查询写入的时间复杂度多少？"><a href="#问：TreeMap查询写入的时间复杂度多少？" class="headerlink" title="问：TreeMap查询写入的时间复杂度多少？"></a><strong>问：TreeMap查询写入的时间复杂度多少？</strong></h4><p><strong>TreeMap为增、删、改、查这些操作提供了log(N)的时间开销</strong>。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050501.html" rel="bookmark">面试整理——Redis</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050401.html" rel="bookmark">面试整理——Dubbo</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050301.html" rel="bookmark">面试整理——Mybatis</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050201.html" rel="bookmark">面试整理——MQ</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050101.html" rel="bookmark">面试整理——Spring Cloud</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102101.html" title="面试整理——Java集合">http://linyishui.top/2019102101.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102002.html" rel="prev" title="面试整理——Java基础">
                  <i class="fa fa-chevron-left"></i> 面试整理——Java基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102201.html" rel="next" title="面试整理——Java并发编程">
                  面试整理——Java并发编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
