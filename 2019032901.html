<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java,lock," />





  <link rel="alternate" href="/atom.xml" title="沂水博客" type="application/atom+xml" />






<meta name="description" content="介绍Java中可重入的独占锁ReentrantLock的相关内容，包括：特性，ReentrantLock的重进入和公平性，源码分析，加锁过程和解锁过程。">
<meta name="keywords" content="java,lock">
<meta property="og:type" content="article">
<meta property="og:title" content="可重入的独占锁ReentrantLock的实现原理">
<meta property="og:url" content="http://linyishui.top/2019032901.html">
<meta property="og:site_name" content="沂水博客">
<meta property="og:description" content="介绍Java中可重入的独占锁ReentrantLock的相关内容，包括：特性，ReentrantLock的重进入和公平性，源码分析，加锁过程和解锁过程。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010113.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010114.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160109.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160110.jpg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160111.jpg">
<meta property="og:updated_time" content="2019-10-14T07:26:39.081Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="可重入的独占锁ReentrantLock的实现原理">
<meta name="twitter:description" content="介绍Java中可重入的独占锁ReentrantLock的相关内容，包括：特性，ReentrantLock的重进入和公平性，源码分析，加锁过程和解锁过程。">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010113.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linyishui.top/2019032901.html"/>





  <title>可重入的独占锁ReentrantLock的实现原理 | 沂水博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沂水博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">编程和心历记录</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019032901.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沂水">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沂水博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">可重入的独占锁ReentrantLock的实现原理</h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T16:03:02+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术文档/" itemprop="url" rel="index">
                    <span itemprop="name">技术文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,451
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          
              <div class="post-description">
                  介绍Java中可重入的独占锁ReentrantLock的相关内容，包括：特性，ReentrantLock的重进入和公平性，源码分析，加锁过程和解锁过程。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h1><hr>
<h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;<strong>重入锁</strong>-ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<p>&emsp;&emsp;ReentrantLock还是一个<strong>独占/排他锁</strong>。相对于synchronized，它更加灵活，但是需要自己写出加锁和解锁的过程。它的灵活性在于它拥有很多特性，相关内容在<a href="../2019081201.html" title="Title">Lock接口</a>已有描述。ReentrantLock需要显示地进行释放锁，特别是在程序异常时，synchronized会自动释放锁，而ReentrantLock并不会自动释放锁，所以必须在finally中进行释放锁。</p>
<blockquote>
<p>ReentrantLock的特性：</p>
<ul>
<li><strong>公平性</strong>：支持公平锁和非公平锁，默认使用了非公平锁。</li>
<li><strong>可重入</strong>：支持重进入，反复进行加锁。</li>
<li><strong>可中断</strong>：相对于synchronized，它是可中断的锁，能够对中断作出响应。</li>
<li><strong>超时机制</strong>：超时后不能获得锁，因此不会造成死锁。</li>
</ul>
</blockquote>
<hr>
<h2 id="第二节-锁的重进入和公平性"><a href="#第二节-锁的重进入和公平性" class="headerlink" title="第二节 锁的重进入和公平性"></a><strong>第二节 锁的重进入和公平性</strong></h2><p>&emsp;&emsp;回忆在<a href="../2019040401.html" title="Title">同步器AQS的实现原理</a>一节中的示例（Mutex），同时考虑如下场景：当一个线程调用Mutex的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。简单地说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。</p>
<p>&emsp;&emsp;ReentrantLock虽然没能像synchronized关键字一样支持<strong>隐式的重进入</strong>，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<p>&emsp;&emsp;这里提到一个锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</p>
<p>&emsp;&emsp;事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为唯一的指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</p>
<p>&emsp;&emsp;下面将着重分析ReentrantLock是如何实现重进入和公平性获取锁的特性，并通过测试来验证公平性获取锁对性能的影响。</p>
<hr>
<h3 id="1-实现重进入"><a href="#1-实现重进入" class="headerlink" title="1 实现重进入"></a><strong>1 实现重进入</strong></h3><p>&emsp;&emsp;重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p>
<blockquote>
<ol>
<li>线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。</li>
<li>锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;ReentrantLock是通过组合自定义同步器来实现锁的获取与释放，以非公平性（默认的）实现为例，获取同步状态的代码如下列代码所示。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//当前线程为获取锁的线程</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);<span class="comment">//计数更新</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。</p>
<p>&emsp;&emsp;成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值，该方法的代码如下列代码所示。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;<span class="comment">//减少同步状态值</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//完全释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">//设置占用线程为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<hr>
<h3 id="2-公平与非公平获取锁的区别"><a href="#2-公平与非公平获取锁的区别" class="headerlink" title="2 公平与非公平获取锁的区别"></a><strong>2 公平与非公平获取锁的区别</strong></h3><p>&emsp;&emsp;公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。</p>
<p>&emsp;&emsp;回顾<a href="../2019040401.html" title="Title">同步器AQS的实现原理</a>中介绍的nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同，如下列代码所示。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<p>&emsp;&emsp;下面编写一个测试来观察公平和非公平锁在获取锁时的区别，在测试用例中定义了内部类ReentrantLock2，该类主要公开了getQueuedThreads()方法，该方法返回正在等待获取锁的线程列表，由于列表是逆序输出，为了方便观察结果，将其进行反转，测试用例（部分）如下列代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动5个Job（略）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 连续2次打印当前的Thread和等待队列中的Thread（略）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="keyword">super</span>.</span><br><span class="line">            getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;分别运行fair()和unfair()两个测试方法，输出结果如下表所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010113.png" alt="fair()和unfair()两个测试方法的输出结果"></p>
<p>&emsp;&emsp;观察上表所示的结果（其中每个数字代表一个线程），公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。</p>
<p>&emsp;&emsp;为什么会出现线程连续获取锁的情况呢？回顾nonfairTryAcquire(int acquires)方法，当一个线程请求锁时，只要获取了同步状态即成功获取锁。在这个前提下，刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。</p>
<p>&emsp;&emsp;非公平性锁可能使线程“饥饿”，为什么它又被设定成默认的实现呢？再次观察上表的结果，如果把每次不同线程获取到锁定义为1次切换，公平性锁在测试中进行了10次切换，而非公平性锁只有5次切换，这说明非公平性锁的开销更小。下面运行测试用例（测试环境：ubuntu server 14.04 i5-34708GB，测试场景：10个线程，每个线程获取100000次锁），通过vmstat统计测试运行时系统线程上下文切换的次数，运行结果如下表所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010114.png" alt="公平性和非公平性在系统线程上下文切换方面的对比"></p>
<p>&emsp;&emsp;在测试中公平性锁与非公平性锁相比，总耗时是其94.3倍，总切换次数是其133倍。可以看出，公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
<hr>
<h2 id="第三节-ReentrantLock源码分析"><a href="#第三节-ReentrantLock源码分析" class="headerlink" title="第三节 ReentrantLock源码分析"></a><strong>第三节 ReentrantLock源码分析</strong></h2><p>&emsp;&emsp;ReentrantLock是很多类的基础，例如 ConcurrentHashMap 内部使用的 Segment 就是继承 ReentrantLock，CopyOnWriteArrayList 也使用了 ReentrantLock。</p>
<blockquote>
<p>锁无法使用try-resource机制来释放，因为首先释放锁不是close()方法，然后try-resource机制希望在首部里声明一个新变量，而锁则需要多个线程共享此变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">myLock.lock();//确保任何时刻只有一个线程进入临界区</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">try&#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&#125;finally&#123;//如果抛出异常，也要顺利释放锁，否则其他线程将一直被阻塞</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    myLock.unlock();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>&emsp;&emsp;Lock在硬件层面依赖CPU指令，完全由Java代码完成，底层利用LockSupport类和Unsafe类进行操作；</p>
<p>&emsp;&emsp;虽然锁有很多实现，但是都依赖AbstractQueuedSynchronizer类，我们用代码来讲下ReentrantLock的实现</p>
<hr>
<h3 id="1-Sync"><a href="#1-Sync" class="headerlink" title="1 Sync"></a><strong>1 Sync</strong></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="title">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;<span class="comment">//ReentrantLock类的API调用都委托给了内部类 Sync，Sync又分为两个子类</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;<span class="comment">//非公平锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;<span class="comment">//公平锁</span></span><br><span class="line">        <span class="meta">@ReservedStackAccess</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">ReentrantLock</span>() &#123;<span class="comment">//默认为非公平锁，因为效率相较较高</span></span><br><span class="line">        sync = <span class="keyword">new</span> <span class="type">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">ReentrantLock</span>(boolean fair) &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="type">FairSync</span>() : <span class="keyword">new</span> <span class="type">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160109.png" alt="类依赖图"></p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160110.jpg" alt="调用lock API时的流程图"></p>
<hr>
<h3 id="2-Lock相关"><a href="#2-Lock相关" class="headerlink" title="2 Lock相关"></a><strong>2 Lock相关</strong></h3><h4 id="2-1-nofairTryAcquire"><a href="#2-1-nofairTryAcquire" class="headerlink" title="2.1 nofairTryAcquire"></a><strong>2.1 nofairTryAcquire</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;来看这段代码，首先获取当前状态（初始化为0），当它等于0的时候，代表还没有任何线程获得该锁，然后通过CAS（底层是通过CompareAndSwapInt实现）改变state，并且设置当前线程为持有锁的线程；其他线程会直接返回false;当该线程重入的时候，state已经不等于0，这个时候并不需要CAS，因为该线程已经持有锁，然后会重新通过setState设置state的值，这里就实现了一个偏向锁的功能，即锁偏向该线程；</p>
<h4 id="2-2-addWaiter"><a href="#2-2-addWaiter" class="headerlink" title="2.2 addWaiter"></a><strong>2.2 addWaiter</strong></h4><p>&emsp;&emsp;只有当锁被一个线程持有，另外一个线程请求获得该锁的时候才会进入这个方法</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates <span class="keyword">and</span> enqueues <span class="keyword">node</span> <span class="title">for</span> current thread <span class="keyword">and</span> given mode.</span><br><span class="line"> *</span><br><span class="line"> * @param mode <span class="keyword">Node</span>.<span class="title">EXCLUSIVE</span> for exclusive, <span class="keyword">Node</span>.<span class="title">SHARED</span> for shared</span><br><span class="line"> * @return the new <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title"> */</span></span><br><span class="line"><span class="title">private</span> <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>) &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), mode);</span><br><span class="line">    // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">pred</span> = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">prev</span> = pred;</span><br><span class="line">        if (compareAndSetTail(pred, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">            pred</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">            return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">    enq</span>(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160111.jpg" alt=""></p>
<p>&emsp;&emsp;首先，new一个节点，这个时候模式为：mode为 Node.EXCLUSIVE，默认为null即排它锁；</p>
<p>&emsp;&emsp;然后，如果该队列已经有node即tail!=null，则将新节点的前驱节点置为tail，再通过CAS将tail指向当前节点，前驱节点的后继节点指向当前节点，然后返回当前节点；</p>
<p>&emsp;&emsp;如果队列为空或者CAS失败，则通过enq入队</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts <span class="keyword">node</span> <span class="title">into</span> queue, initializing if necessary. See picture above.</span><br><span class="line"> * @param <span class="keyword">node</span> <span class="title">the</span> <span class="keyword">node</span> <span class="title">to</span> insert</span><br><span class="line"> * @return <span class="keyword">node</span><span class="title">'s</span> predecessor</span><br><span class="line"> */</span><br><span class="line">private <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">t</span> = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))</span></span><br><span class="line"><span class="title">                tail</span> = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = t;</span><br><span class="line">            if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">                t</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;进队的时候，要么是第一个入队并且设置head节点并且循环设置tail，要么是add tail，如果CAS不成功，则会无限循环，直到设置成功，即使高并发的场景，也最终能够保证设置成功，然后返回包装好的node节点；</p>
<h4 id="2-3-acquireQueued"><a href="#2-3-acquireQueued" class="headerlink" title="2.3 acquireQueued"></a><strong>2.3 acquireQueued</strong></h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Acquires <span class="keyword">in</span> exclusive uninterruptible mode for thread already <span class="keyword">in</span></span><br><span class="line"> * queue. Used by condition wait methods as well as acquire.</span><br><span class="line"> *</span><br><span class="line"> * @param <span class="keyword">node</span> <span class="title">the</span> <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title"> * @param</span> arg the acquire argument</span><br><span class="line"> * @return &#123;@code <span class="literal">true</span>&#125; if interrupted while waiting</span><br><span class="line"> */</span><br><span class="line">final boolean acquireQueued(final <span class="keyword">Node</span> <span class="title">node</span>, int arg) &#123;</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">                p</span>.next = null; // help GC</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></span><br><span class="line"><span class="title">                parkAndCheckInterrupt</span>())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该方法的主要作用就是将已经进入虚拟队列的节点进行阻塞，我们看到，如果当前节点的前驱节点是head并且尝试获取锁的时候成功了，则直接返回，不需要阻塞；<br>如果前驱节点不是头节点或者获取锁的时候失败了，则进行判定是否需要阻塞：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Checks <span class="keyword">and</span> updates status for a <span class="keyword">node</span> <span class="title">that</span> failed to acquire.</span><br><span class="line"> * Returns <span class="literal">true</span> if thread should block. This is the main signal</span><br><span class="line"> * control <span class="keyword">in</span> all acquire loops.  Requires that pred == <span class="keyword">node</span>.<span class="title">prev</span>.</span><br><span class="line"> *</span><br><span class="line"> * @param pred <span class="keyword">node</span><span class="title">'s</span> predecessor holding status</span><br><span class="line"> * @param <span class="keyword">node</span> <span class="title">the</span> <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title"> * @return</span> &#123;@code <span class="literal">true</span>&#125; if thread should block</span><br><span class="line"> */</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(<span class="keyword">Node</span> <span class="title">pred</span>, <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    if (ws == <span class="keyword">Node</span>.<span class="title">SIGNAL</span>)</span><br><span class="line">        /*</span><br><span class="line">         * This <span class="keyword">node</span> <span class="title">has</span> already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         */</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    if (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors <span class="keyword">and</span></span><br><span class="line">         * indicate retry.</span><br><span class="line">         */</span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125; else</span> &#123;</span><br><span class="line">        /*</span><br><span class="line">         * waitStatus must be <span class="number">0</span> <span class="keyword">or</span> PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don't park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码对该节点的前驱节点的状态进行判断，如果前驱节点已经处于signal状态，则返回true，表明当前节点可以进入阻塞状态；</p>
<p>&emsp;&emsp;否则，将前驱节点状态CAS置为signal状态，然后通过上层的for循环进入parkAndCheckInterrupt代码块park：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Convenience method to park<span class="built_in"> and </span>then<span class="built_in"> check </span>if interrupted</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;@code true&#125;<span class="built_in"> if </span>interrupted</span><br><span class="line"> */</span><br><span class="line">private<span class="keyword"> final</span> boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">   <span class="built_in"> return </span>Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个时候将该线程交给操作系统内核进行阻塞；</p>
<p>&emsp;&emsp;总体来讲，acquireQueued就是依靠前驱节点的状态来决定当前线程是否应该处于阻塞状态，如果前驱节点处于cancel状态，则丢弃这些节点，重新构建队列；</p>
<hr>
<h3 id="3-Unlock相关"><a href="#3-Unlock相关" class="headerlink" title="3 Unlock相关"></a><strong>3 Unlock相关</strong></h3><p>&emsp;&emsp;流程类似lock api相关类的流程，这里讲主要的代码，unlock相对的比较简单;</p>
<h4 id="3-1-release"><a href="#3-1-release" class="headerlink" title="3.1 release"></a><strong>3.1 release</strong></h4><p>&emsp;&emsp;首先 ReentrantLock 调用 Sync的release接口也就是AbstractQueuedSynchronizer的release接口;</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-tryRelease"><a href="#3-2-tryRelease" class="headerlink" title="3.2 tryRelease"></a><strong>3.2 tryRelease</strong></h4><p>&emsp;&emsp;这个时候会先调用Sync的tryRelease，如果返回true，则释放锁成功</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个接口的作用很简单，如果不是获得锁的线程调用直接抛出异常，否则，如果当前state-releases==0也就是lock已经完全释放，返回true，清除资源；</p>
<h4 id="3-3-unparkSuccessor"><a href="#3-3-unparkSuccessor" class="headerlink" title="3.3 unparkSuccessor"></a><strong>3.3 unparkSuccessor</strong></h4><p>&emsp;&emsp;这个返回free之后，release拿到head节点，进入以下代码：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Wakes up <span class="keyword">node</span><span class="title">'s</span> successor, if one exists.</span><br><span class="line"> *</span><br><span class="line"> * @param <span class="keyword">node</span> <span class="title">the</span> <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title"> */</span></span><br><span class="line"><span class="title">private</span> void unparkSuccessor(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear <span class="keyword">in</span> anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails <span class="keyword">or</span> if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = <span class="keyword">node</span>.<span class="title">waitStatus</span>;</span><br><span class="line">    if (ws <span class="tag">&lt; 0)</span></span><br><span class="line"><span class="tag">        compareAndSetWaitStatus(node, ws, 0);</span></span><br><span class="line"><span class="tag"> </span></span><br><span class="line"><span class="tag">    /*</span></span><br><span class="line"><span class="tag">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="tag">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="tag">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="tag">     * non-cancelled successor.</span></span><br><span class="line"><span class="tag">     */</span></span><br><span class="line"><span class="tag">    Node s = node.next;</span></span><br><span class="line"><span class="tag">    if (s == null || s.waitStatus &gt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (<span class="keyword">Node</span> <span class="title">t</span> = tail; t != null &amp;&amp; t != <span class="keyword">node</span><span class="title">; t</span> = t.prev)</span><br><span class="line">            if (t.waitStatus <span class="tag">&lt;= 0)</span></span><br><span class="line"><span class="tag">                s = t;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">    if (s != null)</span></span><br><span class="line"><span class="tag">        LockSupport.unpark(s.thread);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个作用即：当头结点的状态小于0，则将头结点的状态CAS为0，然后通过链表获取下一个节点，如果下一个节点为null或者不符合要求的状态，则从队尾遍历整个链表，直到遍历到离head节点最近的一个节点并且<br>等待状态符合预期，则将头结点的后继节点置为该节点；</p>
<p>&emsp;&emsp;对刚刚筛出来的符合要求的节点唤醒，也就是该节点获得 争夺 锁的权利；</p>
<p>&emsp;&emsp;这就是非公平锁的特点：在队列一直等待的线程不一定比后来的线程先获得锁，至此，unlock 已经解释完成</p>
<hr>
<h2 id="第四节-ReentrantLock加锁过程"><a href="#第四节-ReentrantLock加锁过程" class="headerlink" title="第四节 ReentrantLock加锁过程"></a><strong>第四节 ReentrantLock加锁过程</strong></h2><p>&emsp;&emsp;下面我们精细分析加锁过程，深入理解锁逻辑控制。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AQS</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  public <span class="keyword">final</span> void acquire(int arg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(<span class="type">Node</span>.<span class="type">EXCLUSIVE</span>), arg))</span><br><span class="line">         selfInterrupt();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;acquire 的 if 判断语句要分为三个部分，tryAcquire 方法表示当前的线程尝试加锁，如果加锁不成功就需要排队，这时候调用 addWaiter 方法，将当前线程入队。然后再调用 acquireQueued 方法，开始了 park 、醒来重试加锁、加锁不成功继续 park 的循环重试加锁过程。直到加锁成功 acquire 方法才会返回。</p>
<p>&emsp;&emsp;如果在循环重试加锁过程中被其它线程打断了，acquireQueued 方法就会返回 true。这时候线程就需要调用 selfInterrupt() 方法给当前线程设置一个被打断的标识位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打断当前线程，其实就是设置一个标识位</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;线程如何知道自己被其它线程打断了呢？在 park 醒来之后调用 Thread.interrupted() 就知道了，不过这个方法只能调用一次，因为它在调用之后就会立即 clear 打断标志位。这也是为什么 acquire 方法里需要调用 selfInterrupt() ，为的就是重新设置打断标志位。这样上层的逻辑才可以通过 Thread.interrupted() 知道自己有没有被打断。</p>
<p>&emsp;&emsp;acquireQueued 和 addWaiter 方法由 AQS 类提供，tryAcquire 需要由子类自己实现。不同的锁会有不同的实现。下面我们来看看 ReentrantLock 的公平锁 tryAcquire 方法的实现</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">-3000897897090466540</span>L;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> current = <span class="type">Thread</span>.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里有个 if else 分支，其中 else if 部分表示锁的重入，当前尝试加锁的线程是已经持有了这把锁的线程，也就是同一个线程重复加锁，这时只需要增加计数值就行了。锁的 state 记录的就是加锁计数，重入一次就 +1。AQS 对象里有一个 exclusiveOwnerThread 字段，记录了当前持有排他锁的线程。</p>
<p>&emsp;&emsp;if(c == 0) 意味着当前锁是自由态，计数值为零。这时就需要争抢锁，因为同一时间可能会有多个线程在调用 tryAcquire。争抢的方式是用 CAS 操作 compareAndSetState，成功将锁计数值从 0 改成 1 的线程将获得这把锁，将当前的线程记录到 exclusiveOwnerThread 中。</p>
<p>&emsp;&emsp;代码里还有一个 hasQueuedPredecessors() 判断，这个判断非常重要，它的意思是看看当前的 AQS 等待队列里有没有其它线程在排队，公平锁在加锁之前需要 check 一下，如果有排队的，自己就不能插队。而非公平锁就不需要 check，公平锁和非公平锁的全部的实现差异就在于此，就这一个 check 决定了锁的公平与否。</p>
<p>&emsp;&emsp;下面我们再看看 addWaiter 方法的实现，参数 mode 表示是共享锁还是排他锁，它对应 Node.nextWaiter 属性。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates <span class="keyword">and</span> enqueues <span class="keyword">node</span> <span class="title">for</span> current thread <span class="keyword">and</span> given mode.</span><br><span class="line"> *</span><br><span class="line"> * @param mode <span class="keyword">Node</span>.<span class="title">EXCLUSIVE</span> for exclusive, <span class="keyword">Node</span>.<span class="title">SHARED</span> for shared</span><br><span class="line"> * @return the new <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title"> */</span></span><br><span class="line"><span class="title">private</span> <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>) &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(mode</span>);</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">oldTail</span> = tail;</span><br><span class="line">        if (oldTail != null) &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">setPrevRelaxed</span>(oldTail);</span><br><span class="line">            if (compareAndSetTail(oldTail, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">                oldTail</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">            &#125;</span></span><br><span class="line"><span class="title">        &#125; else</span> &#123;</span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** Constructor used by addWaiter. */</span><br><span class="line"><span class="keyword">Node</span><span class="title">(Node</span> nextWaiter) &#123;</span><br><span class="line">    this.nextWaiter = nextWaiter;</span><br><span class="line">    THREAD.set(this, Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line"> * Initializes head <span class="keyword">and</span> tail fields on first contention.</span><br><span class="line"> */</span><br><span class="line">private final void initializeSyncQueue() &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">h</span>;</span><br><span class="line">    if (HEAD.compareAndSet(this, null, (h = new <span class="keyword">Node</span><span class="title">())))</span></span><br><span class="line"><span class="title">        tail</span> = h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CASes tail field.</span><br><span class="line"> */</span><br><span class="line">private final boolean compareAndSetTail(<span class="keyword">Node</span> <span class="title">expect</span>, <span class="keyword">Node</span> <span class="title">update</span>) &#123;</span><br><span class="line">    return TAIL.compareAndSet(this, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;addWaiter 需要将新的节点添加到 AQS 等待队列的队尾。如果队尾 tail 是空的意味着队列还没有初始化，那就需要初始化一下。AQS 队列在初始化时需要一个冗余的头部节点，这个节点的 thread 字段是空的。</p>
<p>&emsp;&emsp;将新节点添加到队尾也是需要考虑多线程并发的，所以代码里再一次使用了 CAS 操作 compareAndSetTail 来竞争队尾指针。没有竞争到的线程就会继续下一轮竞争 for(;;) 继续使用 CAS 操作将新节点往队尾添加。</p>
<p>&emsp;&emsp;下面我们再看看 acquireQueue 方法的代码实现，它会重复 park、尝试再次加锁、加锁失败继续 park 的循环过程。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final boolean acquireQueued(final <span class="keyword">Node</span> <span class="title">node</span>, int arg) &#123;</span><br><span class="line">    boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">                p</span>.next = null; // help GC</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">))</span></span><br><span class="line"><span class="title">                interrupted</span> |= parkAndCheckInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">        if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        throw t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;acquireQueue 在尝试加锁之前会先看看自己是不是 AQS 等待队列的第一个节点，如果不是它就继续去 park。这意味着不管是公平还是非公平锁，在这里它们都统一采取了公平的方案，看看队列中是不是轮到自己了。也就是说「一朝排队，永远排队」。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;线程在 park 返回醒来之后要立即检测一下是否被其它线程中断了。不过即使发生中断了，它还会继续尝试获取锁，如果获取不到，还会继续睡眠，直到锁获取到了才将中断状态返回。这意味着打断线程并不会导致死锁状态（拿不到锁）退出。</p>
<p>&emsp;&emsp;同时我们还可以注意到锁是可以取消的 cancelAcquire()，准确地说是取消处于等待加锁的状态，线程处于 AQS 的等待队列中等待加锁。那什么情况下才会抛出异常而导致取消加锁呢，唯一的可能就是 tryAcquire 方法，这个方法是由子类实现的，子类的行为不受 AQS 控制。当子类的 tryAcquire 方法抛出了异常，那 AQS 最好的处理方法就是取消加锁了。cancelAcquire 会将当前节点从等待队列中移除。</p>
<hr>
<h2 id="第五节-ReentrantLock解锁过程"><a href="#第五节-ReentrantLock解锁过程" class="headerlink" title="第五节 ReentrantLock解锁过程"></a><strong>第五节 ReentrantLock解锁过程</strong></h2><p>&emsp;&emsp;解锁的过程要简单一些，将锁计数降为零后，唤醒等待队列中的第一个有效节点。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 解铃还须系铃人</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;考虑到可重入锁，需要判断锁计数是否降为零才可以确定锁是否彻底被释放。只有锁彻底被释放了才能唤醒后继等待节点。unparkSuccessor 会跳过无效节点（已取消的节点），找到第一个有效节点调用 unpark() 唤醒相应的线程。</p>
<hr>
<p><em>部分参考以下内容：</em></p>
<blockquote>
<p>《Java并发编程的艺术》</p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/22324918" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22324918</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/52280869" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52280869</a></p>
</blockquote>
<p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>

      
    </div>
    
    
    

    

    

    

    
      <div>
         ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/lock/" rel="tag"># lock</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019032701.html" rel="next" title="synchronized">
                <i class="fa fa-chevron-left"></i> synchronized
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019032902.html" rel="prev" title="锁机制">
                锁机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg"
                alt="沂水" />
            
              <p class="site-author-name" itemprop="name">沂水</p>
              <p class="site-description motion-element" itemprop="description">记录编程点滴，写点生活中的酸甜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">159</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LAILAIWA" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:linyishui168@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/linyishui618" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5340162234" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo.com"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节-简介"><span class="nav-number">1.1.</span> <span class="nav-text">第一节 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节-锁的重进入和公平性"><span class="nav-number">1.2.</span> <span class="nav-text">第二节 锁的重进入和公平性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-实现重进入"><span class="nav-number">1.2.1.</span> <span class="nav-text">1 实现重进入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-公平与非公平获取锁的区别"><span class="nav-number">1.2.2.</span> <span class="nav-text">2 公平与非公平获取锁的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节-ReentrantLock源码分析"><span class="nav-number">1.3.</span> <span class="nav-text">第三节 ReentrantLock源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Sync"><span class="nav-number">1.3.1.</span> <span class="nav-text">1 Sync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Lock相关"><span class="nav-number">1.3.2.</span> <span class="nav-text">2 Lock相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-nofairTryAcquire"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">2.1 nofairTryAcquire</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-addWaiter"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2.2 addWaiter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-acquireQueued"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">2.3 acquireQueued</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Unlock相关"><span class="nav-number">1.3.3.</span> <span class="nav-text">3 Unlock相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-release"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.1 release</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-tryRelease"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.2 tryRelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-unparkSuccessor"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.3 unparkSuccessor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四节-ReentrantLock加锁过程"><span class="nav-number">1.4.</span> <span class="nav-text">第四节 ReentrantLock加锁过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五节-ReentrantLock解锁过程"><span class="nav-number">1.5.</span> <span class="nav-text">第五节 ReentrantLock解锁过程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沂水</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<!-- 
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>

-->



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
   <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":125,"height":250},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script>

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
</body>
</html>
