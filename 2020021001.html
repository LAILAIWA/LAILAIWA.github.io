<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig Dug.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="mask-icon" href="/images/gamepad playstation.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="spring,bean,">





  <link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">






<meta name="description" content="简单整理Spring Bean，内容包括：概述（Spring Bean是什么、概念、BeanFactory和ApplicationContext），生命周期（实例化Bean、依赖注入、BeanNameAware、BeanFactoryAware、ApplicationContextAware、BeanPostProcessor、InitializingBean与init-method、Dispos">
<meta name="keywords" content="spring,bean">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Bean">
<meta property="og:url" content="http://linyishui.top/2020021001.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="简单整理Spring Bean，内容包括：概述（Spring Bean是什么、概念、BeanFactory和ApplicationContext），生命周期（实例化Bean、依赖注入、BeanNameAware、BeanFactoryAware、ApplicationContextAware、BeanPostProcessor、InitializingBean与init-method、Dispos">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020101.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010140.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010141.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/754a34e03cfaa40008de8e2b9c1b815c_1440w.jpg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020102.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020106.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020107.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020107.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020109.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020110.png">
<meta property="og:updated_time" content="2020-10-02T09:16:10.089Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring Bean">
<meta name="twitter:description" content="简单整理Spring Bean，内容包括：概述（Spring Bean是什么、概念、BeanFactory和ApplicationContext），生命周期（实例化Bean、依赖注入、BeanNameAware、BeanFactoryAware、ApplicationContextAware、BeanPostProcessor、InitializingBean与init-method、Dispos">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020101.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linyishui.top/2020021001.html">





  <title>Spring Bean | 俺的部落格</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">俺的部落格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">俺寻思俺需要记点东西</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2020021001.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林沂水">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring Bean</h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-10T15:41:41+08:00">
                2020-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术文档/" itemprop="url" rel="index">
                    <span itemprop="name">技术文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  22,156
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  91
                </span>
              
            </div>
          

          
              <div class="post-description">
                  简单整理Spring Bean，内容包括：概述（Spring Bean是什么、概念、BeanFactory和ApplicationContext），生命周期（实例化Bean、依赖注入、BeanNameAware、BeanFactoryAware、ApplicationContextAware、BeanPostProcessor、InitializingBean与init-method、DisposableBean和destroy-method），装配Bean（Spring配置的可选方案、自动化装配bean、通过Java代码装配bean、通过XML装配bean、导入和混合配置），高级装配（环境与profile、条件化的bean、处理自动装配的歧义性、bean的作用域、运行时值注入），Bean的创建过程（过程、IoC容器依赖注入、Bean的循环依赖是如何解决的、Aware究竟是什么）等。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a><strong>Spring Bean</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-Spring-Bean是什么？"><a href="#1-1-Spring-Bean是什么？" class="headerlink" title="1.1 Spring Bean是什么？"></a><strong>1.1 Spring Bean是什么？</strong></h3><p><strong>在Spring中，用来构成应用程序主干并由Spring IoC容器管理的对象就是bean，所以Spring Bean是一个由Spring IoC容器实例化、组装和管理的对象</strong>。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020101.png" alt></p>
<h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a><strong>1.2 概念</strong></h3><ul>
<li><strong>IoC</strong>：IoC（Inversion of Control）即控制反转，通过依赖注入（DI）的方式动态生成依赖对象并注入被依赖对象中，动态的绑定二者。</li>
<li><strong>Bean容器</strong>：即Spring IoC容器，管理对象和依赖，以及依赖的注入。</li>
<li><strong>Bean</strong>：Java对象，遵循Bean规范，由Bean容器生成。</li>
<li><strong>Bean规范</strong>：满足几个条件，包括所有属性为private，提供默认构造方法，提供getter和setter，实现serializable接口。</li>
</ul>
<h3 id="1-3-BeanFactory和ApplicationContext"><a href="#1-3-BeanFactory和ApplicationContext" class="headerlink" title="1.3 BeanFactory和ApplicationContext"></a><strong>1.3 BeanFactory和ApplicationContext</strong></h3><p>Spring自带了多个容器实现，可以归为两种不同的类型：</p>
<ul>
<li><strong>BeanFactory</strong>：<strong>bean工厂</strong>是最简单的容器，提供基本的DI支持。</li>
<li><strong>ApplicationContext</strong>：<strong>应用上下文</strong>基于 <code>BeanFactory</code> 构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。</li>
</ul>
<h4 id="1-3-1-BeanFactory"><a href="#1-3-1-BeanFactory" class="headerlink" title="1.3.1 BeanFactory"></a><strong>1.3.1 BeanFactory</strong></h4><p><code>org.springframework.beans.factory.BeanFactory</code> 是Spring的Bean容器的一个非常基本的接口，位于spring-beans模块。它包括了各种 <code>getBean</code> 方法，如通过名称、类型、参数等，试图从Bean容器中返回一个Bean实例。还包括诸如 <code>containsBean</code> , <code>isSingleton</code> , <code>isPrototype</code> 等方法判断Bean容器中是否存在某个Bean或是判断Bean是否为单例/原型等等。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010140.png" alt></p>
<ul>
<li><strong>ListableBeanFactory</strong>：在BeanFactory基础上，支持对Bean容器中Bean的枚举。</li>
<li><strong>HierarchicalBeanFactory</strong> -&gt; <strong>ConfigurableBeanFactory</strong>：<code>HierarchicalBeanFactory</code> 有个<code>getParentBeanFactory</code> 方法，使得Bean容器具有亲缘关系。而 <code>ConfigurableBeanFactory</code> 则是对BeanFactory的一系列配置功能提供了支持。</li>
<li><strong>AutowireCapableBeanFactory</strong>：提供了一系列用于自动装配Bean的方法，用户代码比较少用到，更多是作为Spring内部使用。</li>
</ul>
<p>虽然我们可以在bean工厂和应用上下文之间任选一种，但bean工厂对大多数应用来说往往太低级了，因此，应用上下文要比bean工厂更受欢迎。</p>
<h4 id="1-3-2-ApplicationContext"><a href="#1-3-2-ApplicationContext" class="headerlink" title="1.3.2 ApplicationContext"></a><strong>1.3.2 ApplicationContext</strong></h4><p><code>org.springframework.context.ApplicationContext</code> 是Spring上下文的底层接口，位于 <code>spring-context</code> 模块。它可以视作是 <code>Spring IoC</code> 容器的一种高级形式，也是我们用Spring企业开发时必然会用到的接口，它含有许多面向框架的特性，也对应用环境作了适配。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010141.png" alt></p>
<p>我们可以看到 <code>ApplicationContext</code> 作为 <code>BeanFactory</code> 的子接口，与 <code>BeanFactory</code> 之间也是通过 <code>HierarchicalBeanFactory</code> 与 <code>ListableBeanFactory</code> 桥接的。<code>ApplicationContext</code> 接口，继承了 <code>MessageSource</code> , <code>ResourceLoader</code> , <code>ApplicationEventPublisher</code> 接口，以 <code>BeanFactory</code> 为主线添加了许多高级容器特性。</p>
<ul>
<li><strong>AnnotationConfigApplicationContext</strong>：从一个或多个基于Java的配置类中加载Spring应用上下文。</li>
<li><strong>AnnotationConfigWebApplicationContext</strong>：从一个或多个基于Java的配置类中加载Spring Web应用上下文。 </li>
<li><strong>ClassPathXmlApplicationContext</strong>：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。 </li>
<li><strong>FileSystemXmlapplicationcontext</strong>：从文件系统下的一个或多个XML配置文件中加载上下文定义。</li>
<li><strong>XmlWebApplicationContext</strong>：从Web应用下的一个或多个XML配置文件中加载上下文定义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从系统文件中加载上下文</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"C:/a.xml"</span>);</span><br><span class="line"><span class="comment">// 从应用类路径加载上下文</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"a.xml"</span>);</span><br><span class="line"><span class="comment">// 从Java配置中加载上下文</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(com.xxx.xxx...Config.class);</span><br></pre></td></tr></table></figure>
<p>当应用上下文准备就绪后就可以调用 <code>context.getBean()</code> 从容器中获取bean。</p>
<hr>
<h2 id="第二节-生命周期"><a href="#第二节-生命周期" class="headerlink" title="第二节 生命周期"></a><strong>第二节 生命周期</strong></h2><p>在传统的Java应用中，bean的生命周期很简单：使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。 </p>
<p>相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。Spring Bean的生命周期的执行过程如下：</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/754a34e03cfaa40008de8e2b9c1b815c_1440w.jpg" alt="Spring Bean的生命周期"></p>
<p>详细描述：</p>
<ol>
<li>Spring实例化Bean对象，默认为单例。</li>
<li>Spring将值和Bean的引用注入到对应的对象属性中，即进行依赖注入。</li>
<li>如果bean实现了 <code>BeanNameAware</code> 接口，Spring将Bean的ID传递给 <code>setBeanName()</code> 方法。</li>
<li>如果bean实现了 <code>BeanFactoryAware</code> 接口，Spring将调用 <code>setBeanFactory()</code> 方法，将 <code>BeanFactory</code> 容器实例传入。</li>
<li>如果bean实现了 <code>ApplicationContextAware</code> 接口，Spring将调用 <code>setApplicationContext()</code> 方法，将bean所在的应用上下文引用传入。</li>
<li>如果bean实现了 <code>BeanPostProcessor</code> 接口，Spring将调用 <code>postProcessBeforeInitialization()</code> 方法，即前置处理。</li>
<li>如果bean实现了 <code>InitializingBean</code> 接口，Spring将调用 <code>afterPropertiesSet()</code> 方法。</li>
<li>如果bean配置了自定义的 <code>init-method</code> ，若声明则调用对应方法。</li>
<li>如果bean实现了 <code>BeanPostProcessor</code> 接口，Spring将调用 <code>postProcessAfterInitialization()</code> 方法，即后置处理。</li>
<li>此时Bean已准备就绪可以被应用使用了，将一直驻留在应用上下文中，直到此上下文被销毁。</li>
<li>如果bean实现了 <code>DisposableBean</code> 接口，Spring将调用 <code>destroy()</code> 方法。</li>
<li>如果bean配置了自定义 <code>destroy-method</code> ，则会调用对应销毁方法。</li>
</ol>
<h3 id="2-1-实例化Bean"><a href="#2-1-实例化Bean" class="headerlink" title="2.1 实例化Bean"></a><strong>2.1 实例化Bean</strong></h3><ul>
<li><p>对于 <code>BeanFactory</code> 容器，当用户向容器请求一个尚未初始化的Bean时，或者是初始化Bean的时候需要注入另一个尚未初始化的依赖时，容器会调用 <code>createBean()</code> 进行实例化。</p>
</li>
<li><p>对于 <code>ApplicationContext</code> 容器，容器启动后就实例化所有Bean。</p>
</li>
</ul>
<p><strong>容器通过获取 <code>BeanDefinition</code> 对象中的信息进行实例化</strong>。并且这一步仅仅是简单的实例化，并未进行依赖注入。实例化对象被包装在 <code>BeanWrapper</code> 对象中，<code>BeanWrapper</code> 提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p>
<h3 id="2-2-依赖注入"><a href="#2-2-依赖注入" class="headerlink" title="2.2 依赖注入"></a><strong>2.2 依赖注入</strong></h3><p>设置对象属性，按照Spring上下文对实例化的Bean进行配置。</p>
<h3 id="2-3-BeanNameAware"><a href="#2-3-BeanNameAware" class="headerlink" title="2.3 BeanNameAware"></a><strong>2.3 BeanNameAware</strong></h3><p>紧接着，Spring会检测该Bean对象是否实现了 <code>BeanNameAware</code> 接口，如果实现了则Spring将Bean的ID传递给 <code>setBeanName()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现此接口主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-BeanFactoryAware"><a href="#2-4-BeanFactoryAware" class="headerlink" title="2.4 BeanFactoryAware"></a><strong>2.4 BeanFactoryAware</strong></h3><p>继续检测Bean是否实现了 <code>BeanFactoryAware</code> 接口，如果实现了，则调用 <code>setBeanFactory()</code> 方法，并传递 <code>BeanFactory</code> 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-ApplicationContextAware"><a href="#2-5-ApplicationContextAware" class="headerlink" title="2.5 ApplicationContextAware"></a><strong>2.5 ApplicationContextAware</strong></h3><p>继续检测Bean是否实现了 <code>ApplicationContextAware</code> 接口，如果实现了，则调用 <code>setApplicationContext()</code> 方法，并传递应用上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext的参数传入，而Spring容器在调用setBeanDactory前需要指定（注入）setBeanDactory里的参数BeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-BeanPostProcessor"><a href="#2-6-BeanPostProcessor" class="headerlink" title="2.6 BeanPostProcessor"></a><strong>2.6 BeanPostProcessor</strong></h3><p>当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过 <code>BeanPostProcessor</code> 接口实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口提供了两个函数：</p>
<ul>
<li><code>postProcessBeforeInitialization(Object bean, String beanName)</code> ：当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会先于 <code>InitialzationBean</code> 执行，因此称为<strong>前置处理</strong>。所有Aware接口的注入就是在这一步完成的。</li>
<li><code>postProcessAfterInitialization(Object bean, String beanName)</code> ：当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会在 <code>InitialzationBean</code> 完成后执行，因此称为<strong>后置处理</strong>。</li>
</ul>
<h3 id="2-7-InitializingBean与init-method"><a href="#2-7-InitializingBean与init-method" class="headerlink" title="2.7 InitializingBean与init-method"></a><strong>2.7 InitializingBean与init-method</strong></h3><p>当 <code>BeanPostProcessor</code> 的前置处理完成后就会进入本阶段，调用 <code>afterPropertiesSet()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 </p>
<p>若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行 <code>afterPropertiesSet()</code> 函数。当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了 <code>init-method</code> 属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。<code>init-method</code> 本质上仍然使用了 <code>InitializingBean</code> 接口。</p>
<h3 id="2-8-DisposableBean和destroy-method"><a href="#2-8-DisposableBean和destroy-method" class="headerlink" title="2.8 DisposableBean和destroy-method"></a><strong>2.8 DisposableBean和destroy-method</strong></h3><p>经过以上的工作后，Bean将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁。</p>
<p>Bean可以实现 <code>DisposableBean</code> 接口，和 <code>init-method</code> 一样，通过给 <code>destroy-method</code> 指定函数，就可以在bean销毁前执行指定的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第三节-装配Bean"><a href="#第三节-装配Bean" class="headerlink" title="第三节 装配Bean"></a><strong>第三节 装配Bean</strong></h2><p>在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。例如，一个订单管理组件需要信用卡认证组件，但它不需要自己创建信用卡认证组件。订单管理组件只需要表明自己两手空空，容器就会主动赋予它一个信用卡认证组件。</p>
<p>创建应用对象之间协作关系的行为通常称为<strong>装配</strong>（wiring），这也是<strong>依赖注入</strong>（DI）的本质。</p>
<h3 id="3-1-Spring配置的可选方案"><a href="#3-1-Spring配置的可选方案" class="headerlink" title="3.1 Spring配置的可选方案"></a><strong>3.1 Spring配置的可选方案</strong></h3><p>作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制： </p>
<ul>
<li>在XML中进行显式配置。 </li>
<li>在Java中进行显式配置。 </li>
<li>隐式的bean发现机制和自动装配。 </li>
</ul>
<p>我们需要根据情况选择最适合的方案，通常建议尽量使用<strong>自动化装配</strong>、然后是显式的JavaConfig、避免使用XML。</p>
<h3 id="3-2-自动化装配bean"><a href="#3-2-自动化装配bean" class="headerlink" title="3.2 自动化装配bean"></a><strong>3.2 自动化装配bean</strong></h3><p>Spring从两个角度来实现自动化装配： </p>
<ul>
<li><strong>组件扫描</strong>（component scanning）：Spring会自动发现应用上下文中所创建的bean。 </li>
<li><strong>自动装配</strong>（autowiring）：Spring自动满足bean之间的依赖。</li>
</ul>
<p>我们通过CD播放器和CD的案例来阐述DI依赖注入如何运行。</p>
<h4 id="3-2-1-创建可被发现的bean"><a href="#3-2-1-创建可被发现的bean" class="headerlink" title="3.2.1 创建可被发现的bean"></a><strong>3.2.1 创建可被发现的bean</strong></h4><p>CompactDisc接口在Java中定义了CD的概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CpmpactDisc</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带有 <code>@Component</code> 注解的CompactDisc实现类SgtPeppers。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String title = <span class="string">"Sgt. Pepper`s Lonely Hearts Club Band"</span>;</span><br><span class="line">	<span class="keyword">private</span> String artist = <span class="string">"The Beatles"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Playing "</span> + title + <span class="string">" by "</span> + artist);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@ComponentScan</code> 注解启用了组件扫描，组件扫描默认是不启用的，默认会扫描与配置类相同的包，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你更倾向于使用XML来启用组件扫描的话，那么可以使用 <code>Spring context</code> 命名空间的 <code>&lt;context:component-scan&gt;</code> 元素。</p>
<p>接下来就可以通过JUnit来测试我们创建的两个类，判断CompactDisc是否被创建出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> CompactDisc cd;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assertNotNull(cd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-为组件扫描的bean命名"><a href="#3-2-2-为组件扫描的bean命名" class="headerlink" title="3.2.2 为组件扫描的bean命名"></a><strong>3.2.2 为组件扫描的bean命名</strong></h4><p><strong>Spring应用上下文中所有的bean都会给定一个ID</strong>。尽管我们没有明确地为SgtPeppers bean设置ID，但Spring会根据类名为其指定一个ID。具体来讲，这个bean所给定的ID为sgtPeppers，也就是将类名的第一个字母变为小写。 如果想为这个bean设置不同的ID，你所要做的就是将期望的ID作为值传递给 <code>@Component</code> 注解，或使用Java依赖注入规范（Java Dependency Injection）中所提供的 <code>@Named</code> 注解来为bean设置ID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Named("lonelyHeartsClub")</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"lonelyHeartsClub"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-设置组件扫描的基础包"><a href="#3-2-3-设置组件扫描的基础包" class="headerlink" title="3.2.3 设置组件扫描的基础包"></a><strong>3.2.3 设置组件扫描的基础包</strong></h4><p>我们没有为 <code>@ComponentScan</code> 设置任何属性。这意味着，按照默认规则，它会以配置类所在的包作为<strong>基础包</strong>（base package）来扫描组件。但是，如果你想扫描不同的包，那该怎么办呢？或者，如果你想扫描多个基础包，那又该怎么办呢？</p>
<p>如果我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来，那默认的基础包就不能满足要求了。为了指定不同的基础包，你所需要做的就是在 <code>@ComponentScan</code> 的value属性中指明包的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"soundsystem"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想更加清晰地表明你所设置的是基础包，那么你可以通过basePackages属性进行配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages=<span class="string">"soundsystem"</span>)</span><br><span class="line"><span class="comment">// 复数数组：@ComponentScan(basePackages=&#123;"soundsystem","video"&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，所设置的基础包是以String类型表示的。我认为这是可以的，但这种方法是类型不安全（not type-safe）的。如果你重构代码的话，那么所指定的基础包可能就会出现错误了。 除了将包设置为简单的String类型之外，<code>@ComponentScan</code> 还提供了另外一种方法，那就是将其指定为包中所包含的类或接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackageClasses=&#123;CDPlayer.class, DVDPlayer.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些类所在的包将会作为组件扫描的基础包。 尽管在样例中，我为 <code>basePackageClasses</code> 设置的是组件类，但是你可以考虑在包中创建一个用来进行扫描的<strong>空标记接口</strong>（marker interface）。通过标记接口的方式，你依然能够保持对重构友好的接口引用，但是可以避免引用任何实际的应用程序代码（在稍后重构中，这些应用代码有可能会从想要扫描的包中移除掉）。</p>
<p>在你的应用程序中，如果所有的对象都是独立的，彼此之间没有任何依赖，就像 SgtPeppersbean这样，那么你所需要的可能就是组件扫描而已。但是，很多对象会依赖其他的对象才能完成任务。这样的话，我们就需要有一种方法能够将组件扫描得到的bean和它们的依赖装配在一起。要完成这项任务，我们需要了解一下Spring自动化配置的另外一方面内容，那就是自动装配。</p>
<h4 id="3-2-4-通过为bean添加注解实现自动装配"><a href="#3-2-4-通过为bean添加注解实现自动装配" class="headerlink" title="3.2.4 通过为bean添加注解实现自动装配"></a><strong>3.2.4 通过为bean添加注解实现自动装配</strong></h4><p>简单来说，自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以借助Spring的 <code>@Autowired</code> 注解。 </p>
<p>比方说如下代码中的CDPlayer类。它的构造器上添加了 <code>@Autowired</code> 注解，这表明当Spring创建CDPlayer bean的时候，会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过自动装配，将一个CompactDisc注入到CDPlayer之中</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> CompactDisc cd;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cd = cd;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cd.play();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Autowired注解不仅能够用在构造器上，还能用在属性的Setter方法上。比如说，如果 CDPlayer有一个 <code>setCompactDisc()</code> 方法，那么可以采用如下的注解形式进行自动装配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompactDisc</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，Setter方法并没有什么特殊之处。<code>@Autowired</code> 注解可以用在类的任何方法上。假 设CDPlayer类有一个 <code>insertDisc()</code> 方法，那么@Autowired能够像在 <code>setCompactDisc()</code> 上那样，发挥完全相同的作用。</p>
<p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。 假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。 如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将 <code>@Autowired</code> 的required属性设置为false：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将required属性设置为false时，Spring仍会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现 <code>NullPointerException</code> 。如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配（自动装配中的歧义性）。 </p>
<p><code>@Autowired</code> 是Spring特有的注解。如果你不愿意在代码中到处使用Spring的特定注解来完成自动装配任务的话，那么你可以考虑将其替换为 <code>@Inject</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Named</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Inject</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cd = cd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Inject</code> 注解来源于Java依赖注入规范，该规范同时还为我们定义了 <code>@Named</code> 注解。在自动 装配中，Spring同时支持 <code>@Inject</code> 和 <code>@Autowired</code> 。尽管 <code>@Inject</code> 和 <code>@Autowired</code> 之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p>
<h4 id="3-2-5-验证自动装配"><a href="#3-2-5-验证自动装配" class="headerlink" title="3.2.5 验证自动装配"></a><strong>3.2.5 验证自动装配</strong></h4><p>现在，我们已经在CDPlayer的构造器中添加了@Autowired注解，Spring将把一个可分配给CompactDisc类型的bean自动注入进来。为了验证这一点，让我们修改一下CDPlayerTest，使其能够借助CDPlayer bean播放CD：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Rule</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> StandardOutputStreamLog log = <span class="keyword">new</span> StandardOutputStreamLog();</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MediaPlayer player;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> CompactDisc cd;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assertNotNull(cd);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		player.paly();</span><br><span class="line">		assertEquals(</span><br><span class="line">			<span class="string">"Playing Sgt. Pepper`s Lonely Hearts Club Band"</span> + </span><br><span class="line">			<span class="string">" by The Beatles\n"</span>,</span><br><span class="line">			log.getLog());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，除了注入CompactDisc，我们还将CDPlayer bean注入到测试代码的player成员变量之中（它是更为通用的MediaPlayer类型）。在 <code>play()</code> 测试方法中，我们可以调用CDPlayer的 <code>play()</code> 方法，并断言它的行为与你的预期一致。 在测试代码中使用 <code>System.out.println()</code> 是稍微有点棘手的事情。因此，该样例中使用了 <code>StandardOutputStreamLog</code>，这是来源于<a href="http://stefanbirkner.github.io/system-rules/index.html" title="Title" target="_blank" rel="noopener">System Rules库</a>的一个JUnit规则，该规则能够基于控制台的输出编写断言。在这里，我们断言 <code>SgtPeppers.play()</code> 方法的输出被发送到了控制台上。</p>
<p>现在我们先将组件扫描和自动装配放在一边，看一下在Spring中如何显式地装配bean，首先从通过Java代码编写配置开始。</p>
<h3 id="3-3-通过Java代码装配bean"><a href="#3-3-通过Java代码装配bean" class="headerlink" title="3.3 通过Java代码装配bean"></a><strong>3.3 通过Java代码装配bean</strong></h3><p>尽管在很多场景下通过组件扫描和自动装配实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加 <code>@Component</code> 和 <code>@Autowired</code> 注解的，因此就不能使用自动化装配的方案了。 </p>
<p>在进行显式配置的时候，有两种可选方案： Java和XML。在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。因为它就是Java代码，就像应用程序中的其他Java代码一样。 同时，JavaConfig与其他的Java代码又有所区别，在概念上，它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其他的组件一样都使用相同的语言进行表述，但JavaConfig是 配置代码。这意味着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码之中。尽管不是必须的，但通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。</p>
<h4 id="3-3-1-创建配置类"><a href="#3-3-1-创建配置类" class="headerlink" title="3.3.1 创建配置类"></a><strong>3.3.1 创建配置类</strong></h4><p>重温一下前文样例中的CDPlayerConfig：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建JavaConfig类的关键在于为其添加 <code>@Configuration</code> 注解，<code>@Configuration</code>注解表明这个类是一个配置类，该类应该包含在Spring应用上下文中如何创建bean的细节。 </p>
<p>到此为止，我们都是依赖组件扫描来发现Spring应该创建的bean。尽管我们可以同时使用组件扫描和显式配置，但是在这里，我们更加关注于显式配置，因此将CDPlayerConfig的 <code>@ComponentScan</code> 注解移除掉了。移除了 <code>@ComponentScan</code>注解，此时的CDPlayerConfig类就没有任何作用了。如果你现在运行CDPlayerTest的话，测试会失败，并且会出现 <code>BeanCreationException</code> 异常。</p>
<p>测试期望被注入CDPlayer和CompactDisc，但是这些bean根本就没有创建，因为组件扫描不会发现它们。 为了再次让测试通过，你可以将 <code>@ComponentScan</code> 注解添加回去，但是我们这里更关注显式配置，因此让我们看一下如何使用JavaConfig装配CDPlayer和CompactDisc。</p>
<h4 id="3-3-2-声明简单的bean"><a href="#3-3-2-声明简单的bean" class="headerlink" title="3.3.2 声明简单的bean"></a><strong>3.3.2 声明简单的bean</strong></h4><p>要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加 <code>@Bean</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Bean</code> 注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。 </p>
<p>默认情况下，bean的ID与带有@Bean注解的方法名是一样的。在本例中，bean的名字将会是 <code>sgtPeppers</code> 。如果你想为其设置成一个不同的名字的话，那么可以重命名该方法，也可以通过name属性指定一个不同的名字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"xx"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法体返回了一个新的SgtPeppers实例。这里是使用Java来进行描述的，因此我们可以发挥Java提供的所有功 能，只要最终生成一个CompactDisc实例即可。 比如我们可以在一组CD中随机选取一个CompactDisc来播放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompactDisc <span class="title">randomBeatlesCD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> choice = (<span class="keyword">int</span>) Math.floor(Math.random() * <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WhiteAlbum();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HardDaysNight();</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Resolver();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-借助JavaConfig实现注入"><a href="#3-3-3-借助JavaConfig实现注入" class="headerlink" title="3.3.3 借助JavaConfig实现注入"></a><strong>3.3.3 借助JavaConfig实现注入</strong></h4><p>我们前面所声明的CompactDisc bean是非常简单的，它自身没有其他的依赖。但现在，我们需要声明CDPlayer bean，它依赖于CompactDisc。在JavaConfig中，要如何将它们装配在一起呢？</p>
<p>在JavaConfig中装配bean的最简单方式就是引用创建bean的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cdPlayer()</code> 方法像 <code>sgtPeppers()</code> 方法一样，同样使用了 <code>@Bean</code> 注解，这表明这个方法会创建一个bean实例并将其注册到Spring应用上下文中。</p>
<p>看起来，CompactDisc是通过调用 <code>sgtPeppers()</code> 得到的，但情况并非完全如此。因为 <code>sgtPeppers()</code> 方法上添加了 <code>@Bean</code> 注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。 </p>
<p>比如引入了一个其他的CDPlayerbean，它和之前的那个bean完全一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CDPlayer <span class="title">anotherCdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如对 <code>sgtPeppers()</code> 的调用就像其他的Java方法调用一样的话，那么每个CDPlayer实例都会有一个自己特有的SgtPeppers实例。D光盘的话，这么做是有意义的。如果你有两台CD播放器，在物理上并没有办法将同一张CD光盘放到两个CD播放器中。 但是，在软件领域中，我们完全可以将同一个SgtPeppers实例注入到任意数量的其他bean之中。</p>
<p>默认情况下，Spring中的bean都是单例的，我们并没有必要为第二个CDPlayer bean创建完全相同的SgtPeppers实例。所以，Spring会拦截对 <code>sgtPeppers()</code> 的调用并确保返回的是Spring所创建的bean，也就是Spring本身在调用 <code>sgtPeppers()</code> 时所创建的CompactDisc bean。因此，两个CDPlayer bean会得到相同的SgtPeppers实例。 </p>
<p>可以看到，通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">(CompactDisc compactDisc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(compactDisc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>cdPlayer()</code> 方法请求一个CompactDisc作为参数。当Spring调用 <code>cdPlayer()</code> 创建CDPlayer bean的时候，它会自动装配一个CompactDisc到配置方法之中。然后，方法体就可以按照合适的方式来使用它。借助这种技术，<code>cdPlayer()</code> 方法也能够将CompactDisc注入到CDPlayer的构造器中，而且不用明确引用CompactDisc的 <code>@Bean</code> 方法。 </p>
<h3 id="3-4-通过XML装配bean"><a href="#3-4-通过XML装配bean" class="headerlink" title="3.4 通过XML装配bean"></a><strong>3.4 通过XML装配bean</strong></h3><p>在Spring刚刚出现的时候，XML是描述配置的主要方式。在Spring的名义下，我们创建了无数行XML代码，在一定程度上，Spring成为了XML配置的同义词。 希望本部分内容只是用来帮助你维护已有的XML配置，在完成新的Spring工作时，建议使用自动化配置和JavaConfig。</p>
<h4 id="3-4-1-创建XML配置规范"><a href="#3-4-1-创建XML配置规范" class="headerlink" title="3.4.1 创建XML配置规范"></a><strong>3.4.1 创建XML配置规范</strong></h4><p>在使用XML为Spring装配bean之前，你需要创建一个新的配置规范。在使用JavaConfig的时候，这意味着要创建一个带有 <code>@Configuration</code> 注解的类，而在XML配置中，这意味着要创建一个XML文件，并且要以 <code>&lt;beans&gt;</code> 元素为根。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"...."</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- configuration details go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用来装配bean的最基本的XML元素包含在spring-beans模式之中，在上面这个XML文件中，它被定义为根命名空间。<code>&lt;beans&gt;</code> 是该模式中的一个元素，它是所有Spring配置文件的根元素。</p>
<h4 id="3-4-2-声明一个简单的-lt-bean-gt"><a href="#3-4-2-声明一个简单的-lt-bean-gt" class="headerlink" title="3.4.2 声明一个简单的 &lt;bean&gt;"></a><strong>3.4.2 声明一个简单的 <code>&lt;bean&gt;</code></strong></h4><p><code>&lt;bean&gt;</code> 元素类似于JavaConfig中的@Bean注解：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"xx.SgtPeppers"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里声明了一个很简单的bean，创建这个bean的类通过class属性来指定的，并且要使用全限定的类名。</p>
<p>因为没有明确给定ID，所以这个bean将会根据全限定类名来进行命名。在本例中，bean的ID将会是 <code>“xx.SgtPeppers#0”</code> 。其中，“#0”是一个计数的形式，用来区分相同类型的其他bean。如果你声明了另外一个SgtPeppers，并且没有明确进行标识，那么它自动得到的ID将会是 <code>“xx.SgtPeppers#1”</code> 。 </p>
<p>尽管自动化的bean命名方式非常方便，但如果你要稍后引用它的话，那自动产生的名字就没有多大的用处了。因此，通常来讲更好的办法是借助id属性，为每个bean设置一个你自己选择的名字：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"xx.SgtPeppers"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>声明后我们不再需要直接负责创建SgtPeppers的实例，Spring的XML配置并不能从编译期的类型检查中获益，需要其他工具来帮助检查XML配置的合法性。</p>
<h4 id="3-4-3-借助构造器注入初始化bean"><a href="#3-4-3-借助构造器注入初始化bean" class="headerlink" title="3.4.3 借助构造器注入初始化bean"></a><strong>3.4.3 借助构造器注入初始化bean</strong></h4><p>在XML中声明DI时，会有多种可选的配置方案和风格。具体到构造器注入，有两种基本的配置方案可供选择： </p>
<ul>
<li><code>&lt;constructor-arg&gt;</code> 元素</li>
<li>使用Spring 3.0所引入的 <code>c-</code> 命名空间 </li>
</ul>
<p>两者的区别在很大程度就是是否冗长烦琐。可以看到，<code>&lt;constructor-arg&gt;</code> 元素比使用 <code>c-</code> 命名空间会更加冗长，从而导致XML更加难以读懂。另外，有些事情 <code>&lt;constructor-arg&gt;</code> 可以做到，但是使用 <code>c-</code> 命名空间却无法实现。 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 构造器注入bean引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdPlayer"</span> <span class="attr">class</span>=<span class="string">"xx.CDPlayer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"compactDisc"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- c-命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdPlayer"</span> <span class="attr">class</span>=<span class="string">"xx.CDPlayer"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">c:cd-ref</span>=<span class="string">"compactDisc"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当Spring遇到这个 <code>&lt;bean&gt;</code> 元素时，它会创建一个CDPlayer实例。<code>&lt;constructor-arg&gt;</code> 元素会告知Spring要将一个ID为 <code>compactDisc</code> 的bean引用传递到CDPlayer的构造器中。 </p>
<p>属性名以 <code>c:</code> 开头，也就是命名空间的前缀。<code>cd</code> 就是要装配的构造器参数名（可以改为序号如 <code>_0</code> 或 <code>_</code> ），在此之后是 <code>-ref</code> ，这是一个命名的约定，它会告诉Spring，正在装配的是一个bean的引用，这个bean的名字是compactDisc，而不是字面量“compactDisc”。 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将字面量注入到构造器中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"xx.BlankDisc"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Sgt. Pepper`s Lonely Hearts Club Band"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"The Beatles"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- c-命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"xx.BlankDisc"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">c:_title</span>=<span class="string">"Sgt. Pepper`s Lonely Hearts Club Band"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">c:_artist</span>=<span class="string">"The Beatles"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>XML不允许某个元素的多个属性具有相同的名字。</p>
<p>有一种情况是 <code>&lt;constructor-arg&gt;</code> 能够实现，<code>c-</code> 命名空间却无法做到：<strong>装配集合</strong>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 装配集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"xx.BlankDisc"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Sgt. Pepper`s Lonely Hearts Club Band"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"The Beatles"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;list&gt;</code> 元素是 <code>&lt;constructor-arg&gt;</code> 的子元素，这表明一个包含值的列表将会传递 到构造器中。其中，<code>&lt;value&gt;</code> 元素用来指定列表中的每个元素。 </p>
<p>与之类似，我们也可以使用 <code>&lt;ref&gt;</code> 元素替代 <code>&lt;value&gt;</code>，实现bean引用列表的装配。<code>&lt;list&gt;</code> 元素当然也可以换成 <code>&lt;set&gt;</code> 元素。</p>
<h4 id="3-4-4-设置属性"><a href="#3-4-4-设置属性" class="headerlink" title="3.4.4 设置属性"></a><strong>3.4.4 设置属性</strong></h4><p>到目前为止，CDPlayer和BlankDisc类完全是通过构造器注入的，没有使用属性的Setter方法。接下来，我们就看一下如何使用Spring XML实现属性注入。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdPlayer"</span> <span class="attr">class</span>=<span class="string">"xx.CDPlayer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"compactDisc"</span> <span class="attr">ref</span>=<span class="string">"compactDisc"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;property&gt;</code> 元素为属性的Setter方法所提供的功能与 <code>&lt;constructor-arg&gt;</code> 元素为构造器所提供的功能是一样的。在本例中，它引用了ID为compactDisc的bean（通过 <code>ref</code> 属性），并将其注入到compactDisc属性中（通过 <code>setCompactDisc()</code> 方法）。如果你现在运行测试的话，它应该就能通过了。</p>
<p>Spring提供了更加简洁的 <code>p-</code> 命名空间，作为 <code>&lt;property&gt;</code> 元素的替代方案。</p>
<h3 id="3-5-导入和混合配置"><a href="#3-5-导入和混合配置" class="headerlink" title="3.5 导入和混合配置"></a><strong>3.5 导入和混合配置</strong></h3><p>在自动装配时，容器并不在意要装配的bean来自哪里。自动装配的时候会考虑到Spring容器中所有的bean，不管它是在JavaConfig或XML中声明的还是通过组件扫描获取到的。</p>
<h4 id="3-5-1-在JavaConfig中引用XML配置"><a href="#3-5-1-在JavaConfig中引用XML配置" class="headerlink" title="3.5.1 在JavaConfig中引用XML配置"></a><strong>3.5.1 在JavaConfig中引用XML配置</strong></h4><p><code>@Import</code> 注解将配置类组合在一起，<code>@ImportResource</code> 注解引入XML配置。</p>
<h4 id="3-5-2-在XML配置中引用JavaConfig"><a href="#3-5-2-在XML配置中引用JavaConfig" class="headerlink" title="3.5.2 在XML配置中引用JavaConfig"></a><strong>3.5.2 在XML配置中引用JavaConfig</strong></h4><p>在XML中，我们可以使用import元素来拆分XML配置。 但 <code>&lt;import&gt;</code> 元素只能导入其他的XML配置文件，并没有XML元素能够导入JavaConfig类。 </p>
<p>但是，有一个你已经熟知的元素能够用来将Java配置导入到XML配置中：<code>&lt;bean&gt;</code> 元素。为了将JavaConfig类导入到XML配置中，我们可以这样声明bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"xx.CDConfig"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdPlayer"</span> <span class="attr">class</span>=<span class="string">"xx.CDPlayer"</span> </span></span><br><span class="line"><span class="tag">	  <span class="attr">c:cd-ref</span>=<span class="string">"compactDisc"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或是通过XML将两个配置文件组合在一起：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"xx.CDConfig"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"cdPlayer-config.xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第四节-高级装配"><a href="#第四节-高级装配" class="headerlink" title="第四节 高级装配"></a><strong>第四节 高级装配</strong></h2><p>在开发软件的时候，有一个很大的挑战就是将应用程序从一个环境迁移到另外一个环境。不同的环境很多参数配置等可能都需要变化，如数据库配置、加密算法以及与外部系统的集成等是跨环境部署时会发生变化的几个典型例子。</p>
<p>例如我们必须要有一种方法来配置DataSource，使其在每种环境下都会选择最为合适的配置。 其中一种方式就是在单独的配置类（或XML文件）中配置每个bean，然后在构建阶段（可能会使用Maven的profiles）确定要将哪一个配置编译到可部署的应用中。这种方式的问题在于要为每种环境重新构建应用。当从开发阶段迁移到QA阶段时，重新构建也许算不上什么大问题。但是，从QA阶段迁移到生产阶段时，重新构建可能会引入bug并且会在QA团队的成员中带来不安的情绪。</p>
<h3 id="4-1-环境与profile"><a href="#4-1-环境与profile" class="headerlink" title="4.1 环境与profile"></a><strong>4.1 环境与profile</strong></h3><p>Spring为环境相关的bean所提供的解决方案：不是在构建的时候做出这样的决策，而是等到运行时再来确定。这样的结果就是同一个部署单元（可能会是WAR文件）能够适用于所有的环境，没有必要进行重新构建。 </p>
<h4 id="4-1-1-配置profile-bean"><a href="#4-1-1-配置profile-bean" class="headerlink" title="4.1.1 配置profile bean"></a><strong>4.1.1 配置profile bean</strong></h4><p>在3.1版本中，Spring引入了 <code>bean profile</code> 的功能。要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署到每个环境时，要确保对应的profile处于激活（active）的状态。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevelopmentProfileConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>(destroyMethod=<span class="string">"shutdown"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">			.setType(EmbeddedDatabaseType.H2)</span><br><span class="line">			.addScript(<span class="string">"classpath:schema.sql"</span>)</span><br><span class="line">			.addScript(<span class="string">"classpath:test-data.sql"</span>)</span><br><span class="line">			.build();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Profile</code> 注解应用在类上，告诉Spring这个配置类中的bean只有在 <code>dev profile</code> 激活时才会创建。如果 <code>dev profile</code> 没有激活的话，那么带有 <code>@Bean</code> 注解的方法都会被忽略掉。</p>
<p>从Spring 3.2开始，也可以在方法级别上使用 <code>@Profile</code> 注解，与 <code>@Bean</code> 注解一同使用。这样的话，就能将这两个bean的声明放到同一个配置类之中。</p>
<p>注意：没有指定profile的bean始终都会被创建，与激活哪个profile没有关系。</p>
<p>我们也可以通过 <code>&lt;beans&gt;</code> 元素的<strong>profile属性</strong>，在XML中配置 <code>profile bean</code> 。</p>
<h4 id="4-1-2-激活profile"><a href="#4-1-2-激活profile" class="headerlink" title="4.1.2 激活profile"></a><strong>4.1.2 激活profile</strong></h4><p>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：</p>
<ul>
<li><code>spring.profiles.active</code></li>
<li><code>spring.profiles.default</code></li>
</ul>
<ol>
<li>如果设置了 <code>spring.profiles.active</code> 属性的话，那么它的值就会用来确定哪个profile是激活的。</li>
<li>如果没有设置 <code>spring.profiles.active</code> 属性的话，那Spring将会查找 <code>spring.profiles.default</code> 的值。</li>
<li>如果 <code>spring.profiles.active</code> 和  <code>spring.profiles.default</code> 均没有设置的话，那就没有激活的profile，因此只会创建那些没有定义在profile中的bean。</li>
</ol>
<p>有多种方式来设置这两个属性： </p>
<ul>
<li>作为DispatcherServlet的初始化参数；</li>
<li>作为Web应用的上下文参数； </li>
<li>作为JNDI条目；</li>
<li>作为环境变量；</li>
<li>作为JVM的系统属性； </li>
<li>在集成测试类上，使用 <code>@ActiveProfiles</code> 注解设置。 </li>
</ul>
<p>Spring提供了 <code>@ActiveProfiles</code> 注解，我们可以使用它来指定运行测试时要激活哪个profile。</p>
<p>在条件化创建bean方面，Spring的profile机制是一种很棒的方法，这里的条件要基于哪个profile处于激活状态来判断。Spring 4.0中提供了一种更为通用的机制来实现条件化的bean定义，在这种机制之中，条件完全由你来确定。让我们看一下如何使用Spring 4和 <code>@Conditional</code> 注解定义条件化的bean。</p>
<h3 id="4-2-条件化的bean"><a href="#4-2-条件化的bean" class="headerlink" title="4.2 条件化的bean"></a><strong>4.2 条件化的bean</strong></h3><p>假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。 </p>
<p>Spring 4引入了一个新的 <code>@Conditional</code> 注解，它可以用到带有 <code>@Bean</code> 注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。</p>
<p>假设有一个名为MagicBean的类，我们希望只有设置了magic环境属性的时候，Spring才会实例化这个类。如果环境中没有这个属性，那么MagicBean将会被忽略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional</span>(MagicExistsCondition.class) <span class="comment">// 条件化的创建bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MagicBean <span class="title">magicBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MagicBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，@Conditional中给定了一个Class，它指明了条件——在本例中，也就是 <code>MagicExistsCondition</code> 。<code>@Conditional</code> 将会通过 <code>Condition</code> 接口进行条件对比：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext ctxt, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置给 <code>@Conditional</code> 的类可以是任意实现了 <code>Condition</code> 接口的类型。可以看出来，这个 接口实现起来很简单直接，只需提供 <code>matches()</code> 方法的实现即可。如果 <code>matches()</code> 方法返 回true，那么就会创建带有 <code>@Conditional</code> 注解的bean。如果 <code>matches()</code> 方法返回 false，将不会创建这些bean。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicExistsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext ctxt, AnnotatedTypeMetadata metadata)</span></span>&#123;</span><br><span class="line">		Environment env = context.getEnvironment();</span><br><span class="line">		<span class="keyword">return</span> env.containsProperty(<span class="string">"magic"</span>);  <span class="comment">// 检查magic属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过给定的 <code>ConditionContext</code> 对象进而得到 <code>Environment</code> 对象，并使用这个对象检查环境中是否存在名为magic的环境属性。在本例中，属性的值是什么无所谓，只要属性存在即可满足要 求。如果满足这个条件的话，<code>matches()</code> 方法就会返回true。所带来的结果就是条件能够得到满足，所有 <code>@Conditional</code> 注解上引用 <code>MagicExistsCondition</code> 的bean都会被创建。 </p>
<p><code>ConditionContext</code> 是一个接口，大致如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionContext</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 通过BeanDefinitionRegistry检查bean定义</span></span><br><span class="line">	<span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 通过ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性</span></span><br><span class="line">	<span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 通过Environment检查环境变量是否存在以及它的值是什么</span></span><br><span class="line">	<span class="function">Environment <span class="title">getEnvironment</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 通过ResourceLoader读取并检查加载的资源</span></span><br><span class="line">	<span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 通过ClassLoader加载并检查类是否存在</span></span><br><span class="line">	<span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AnnotatedTypeMetadata</code> 则能够让我们检查带有 <code>@Bean</code> 注解的方法上还有什么其他的注 解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 判断带有@Bean注解的方式是不是还有其他特定的注解</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotated</span><span class="params">(String annotationType)</span></span>;</span><br><span class="line">	<span class="comment">// 其他方法用来检查@Bean注解的方法上其他注解的属性。 </span></span><br><span class="line">	<span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationType)</span></span>;</span><br><span class="line">	<span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String annotationType, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</span><br><span class="line">	<span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationType)</span></span>;</span><br><span class="line">	<span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String annotationType, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常有意思的是，从Spring 4开始，<code>@Profile</code> 注解进行了重构，使其基于 <code>@Conditional</code> 和 <code>Condition</code> 实现。作为如何使用 <code>@Conditional</code> 和 <code>Condition</code> 的例子，我们来看一下在Spring 4中，<code>@Profile</code> 是如何实现的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Targer</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(ProfileCondition.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Profile &#123;</span><br><span class="line">	String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext ctxt, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(context.getEnvironment() != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">// 得到用于@Profile注解的所有属性</span></span><br><span class="line">			MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line">			<span class="keyword">if</span>(attrs != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="comment">// 检查value属性，此属性包含了bean的Profile名称</span></span><br><span class="line">				<span class="keyword">for</span>(Object value : attrs.get(<span class="string">"value"</span>))&#123;</span><br><span class="line">					<span class="comment">// 检查该Profile是否处于激活状态</span></span><br><span class="line">					<span class="keyword">if</span>(context.getEnvironment()</span><br><span class="line">					          .acceptsProfiles((String[]) value)))</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-处理自动装配的歧义性"><a href="#4-3-处理自动装配的歧义性" class="headerlink" title="4.3 处理自动装配的歧义性"></a><strong>4.3 处理自动装配的歧义性</strong></h3><p>如果不仅有一个bean能够匹配结果的话，这种歧义性会阻碍Spring自动装配属性、构造器参数或方法参数。 </p>
<p>为了阐述自动装配的歧义性，假设我们使用 <code>@Autowired</code> 注解标注了 <code>setDessert()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dessert是一个接口，并且有三个类实现了这个接口，分别为Cake、Cookies 和IceCream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookies</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>因为这三个实现均使用了 <code>@Component</code> 注解，在组件扫描的时候，能够发现它们并将其创建为<strong>Spring应用上下文里面的bean</strong>。然后，当Spring试图自动装配 <code>setDessert()</code> 中的 Dessert参数时，它并没有唯一、无歧义的可选值。在从多种甜点中做出选择时，尽管大多数人并不会有什么困难，但是Spring却无法做出选择。Spring此时别无他法，只好宣告失败并抛出异常 <code>NoUniqueBeanDefinitionException</code> 。</p>
<p>当确实发生歧义性的时候，Spring提供了多种可选方案来解决这样的问题：</p>
<ul>
<li>你可以将可选bean中的某一个设为<strong>首选</strong>（primary）的bean。</li>
<li>使用<strong>限定符</strong>（qualifier）来帮助Spring将可选的bean的范围缩小到只有一个bean。</li>
</ul>
<h4 id="4-3-1-标示首选的bean"><a href="#4-3-1-标示首选的bean" class="headerlink" title="4.3.1 标示首选的bean"></a><strong>4.3.1 标示首选的bean</strong></h4><p>在Spring中，可以通过 <code>@Primary</code> 来表达最喜欢的方案。<code>@Primary</code> 能够与 <code>@Component</code> 组合用在组件扫描的bean上，也可以与 <code>@Bean</code> 组合用在Java配置的bean声明中。比如，下面的代码展现了如何将 <code>@Component</code> 注解的IceCream bean声明为首选的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>或者，如果你通过Java配置显式地声明IceCream，那么 <code>@Bean</code> 方法应该如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dessert <span class="title">iceCream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> IceCream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用XML配置bean的话，同样可以实现这样的功能。<code>&lt;bean&gt;</code> 元素有一个primary属性用来指定首选的bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"iceCream"</span> <span class="attr">class</span>=<span class="string">"xx.IceCream"</span> <span class="attr">primary</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你标示了两个或更多的首选bean，那么它就无法正常工作了。<strong>就解决歧义性问题而言，限定符是一种更为强大的机制</strong>。</p>
<h4 id="4-3-2-限定自动装配的bean"><a href="#4-3-2-限定自动装配的bean" class="headerlink" title="4.3.2 限定自动装配的bean"></a><strong>4.3.2 限定自动装配的bean</strong></h4><p><strong>设置首选bean的局限性</strong>在于 <code>@Primary</code> 无法将可选方案的范围限定到唯一一个无歧义性的选项中。它只能标示一个优先的可选方案。当首选bean的数量超过一个时，我们并没有其他的方法进一步缩小可选范围。</p>
<p>与之相反，Spring的限定符能够在所有可选的bean上进行缩小范围的操作，最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小选择范围。 </p>
<p><code>@Qualifier</code> 注解是使用限定符的主要方式。它可以与 <code>@Autowired</code> 和 <code>@Inject</code> 协同使用，在注入的时候指定想要注入进去的是哪个bean。例如，我们想要确保要将IceCream注入到setDessert()之中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"iceCream"</span>) <span class="comment">// 限定符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是使用限定符的最简单的例子。为 <code>@Qualifier</code> 注解所设置的参数就是想要注入的bean的 ID。所有使用 <code>@Component</code> 注解声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名。因此，<code>@Qualifier(&quot;iceCream&quot;)</code> 指向的是组件扫描时所创建的bean，并且这个bean是IceCream类的实例。 </p>
<p><code>@Qualifier(&quot;iceCream&quot;)</code> 所引用的bean要具有String类型的 <code>“iceCream”</code> 作为限定符。如果没有指定其他的限定符的话，所有的bean都会给定一个默认的限定符，这个限定符与bean的ID相同。因此，框架会将具有 <code>“iceCream”</code> 限定符的bean注入到 <code>setDessert()</code> 方法中。恰巧就是ID为iceCream的bean，它是IceCream类在组件扫描的时候创建的。 </p>
<p>如果你重构了IceCream类，将其重命名为Gelato的话，那此时会发生什么情况呢？如果这样的话，bean的ID和默认的限定符会变为gelato，这就无法匹配 <code>setDessert()</code> 方法中的限定符。自动 装配会失败。</p>
<p><strong>这里的问题在于 <code>setDessert()</code> 方法上所指定的限定符与要注入的bean的名称是紧耦合的</strong>。<strong>对类名称的任意改动都会导致限定符失效</strong>。</p>
<h5 id="（1）创建自定义的限定符"><a href="#（1）创建自定义的限定符" class="headerlink" title="（1）创建自定义的限定符"></a><strong>（1）创建自定义的限定符</strong></h5><p>我们可以为bean设置自己的限定符，而不是依赖于将bean ID作为限定符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，cold限定符分配给了IceCreambean。因为它没有耦合类名，因此你可以随意重构IceCream的类名，而不必担心会破坏自动装配。在注入的地方，只要引用cold限定符就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="（2）使用自定义的限定符注解"><a href="#（2）使用自定义的限定符注解" class="headerlink" title="（2）使用自定义的限定符注解"></a><strong>（2）使用自定义的限定符注解</strong></h5><p>面向特性的限定符要比基于bean ID的限定符更好一些。但是，如果多个bean都具备相同特性的话，这种做法也会出现问题。例如，如果引入了这个新的Dessert bean，会发生什么情况呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Popsicle</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们有了两个带有“cold”限定符的甜点，需要使用更多的限定符来将可选范围限定到只有一个bean。 </p>
<p>首先想到方案如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"creamy"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"fruity"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Popsicle</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"creamy"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里只有一个小问题：<strong>Java不允许在同一个条目上重复出现相同类型的多个注解</strong>（Java 8允许出现重复的注解，只要这个注解本身在定义的时候带有 <code>@Repeatable</code> 注解就可以。不过，Spring的 <code>@Qualifier</code> 注解并没有在定义时添加 <code>@Repeatable</code> 注解）。不过我们可以创建自定义的限定符注解，借助这样的注解来表达bean所希望限定的特性。 </p>
<p>创建一个新的 <code>@Cold</code> 注解来代替 <code>@Qualifier(&quot;cold&quot;)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Targer</span>(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Cold &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个新的 <code>@Creamy</code> 注解来代替 <code>@Qualifier(&quot;creamy&quot;)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Targer</span>(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Creamy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义注解的方案如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Cold</span></span><br><span class="line"><span class="meta">@Creamy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Cold</span></span><br><span class="line"><span class="meta">@Fruity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Popsicle</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Cold</span></span><br><span class="line">	<span class="meta">@Creamy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>通过声明自定义的限定符注解，我们可以同时使用多个限定符，不会再有Java编译器的限制或错误。与此同时，相对于使用原始的 <code>@Qualifier</code> 并借助String类型来指定限定符，自定义的注解也<strong>更为类型安全</strong>。 </p>
<h3 id="4-4-bean的作用域"><a href="#4-4-bean的作用域" class="headerlink" title="4.4 bean的作用域"></a><strong>4.4 bean的作用域</strong></h3><p>在默认情况下，Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。 </p>
<p>在大多数情况下，单例bean是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p>
<p>有时候，可能会发现，你所使用的类是<strong>易变的</strong>（mutable），它们会保持一些状态，因此重用 是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被污染，稍后重用的时候会出现意想不到的问题。</p>
<p>Spring的五种作用域如下：</p>
<ul>
<li><strong>Singleton</strong>（单例）：在整个应用中，只创建bean的一个实例。 </li>
<li><strong>Prototype</strong>（原型）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。 </li>
<li><strong>Request</strong> ：每次HTTP请求都会创建一个新的Bean，该作用域仅适用于 <code>WebApplicationContext</code> 环境。</li>
<li><strong>Session</strong> ：同一个 <code>HTTP Session</code> 共享一个Bean，不同Session使用不同Bean，仅适用于 <code>WebApplicationContext</code> 环境。</li>
<li><strong>GlobalSession</strong> ：一般用于 Portlet 应用环境，它映射到 Portlet 的 global 范围内的 session，仅适用于 <code>WebApplicationContext</code> 环境。</li>
</ul>
<p>选择其他的作用域，要使用 <code>@Scope</code> 注解，它可以与 <code>@Component</code> 或 <code>@Bean</code> 一起使用。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="comment">// 选用原型作用域，也可以这样写：@Scope("prototype")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>XML中配置bean的作用域如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明Bean为原型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">singleton</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-1-使用会话和请求作用域"><a href="#4-4-1-使用会话和请求作用域" class="headerlink" title="4.4.1 使用会话和请求作用域"></a><strong>4.4.1 使用会话和请求作用域</strong></h4><p>在Web应用中，如果能够实例化在会话和请求范围内共享的bean，那将是非常有价值的事情。例如，在典型的电子商务应用中，可能会有一个bean代表用户的购物车。如果购物车是单例的话，那么将会导致所有的用户都会向同一个购物车中添加商品。另一方面，如果购物车是原型作用域的，那么在应用中某一个地方往购物车中添加商品，在应用的另外一个地方可能就不可用了，因为在这里注入的是另外一个原型作用域的购物车。</p>
<p>就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大。要指定会话作用域，我们可以使用 <code>@Scope</code> 注解，它的使用方式与指定原型作用域是相同的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(value=WebApplicationContext.SCOPE_SESSION,</span><br><span class="line">	   proxyMode=ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ShoppingCart <span class="title">cart</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>Spring为Web应用中的每个会话创建一个ShoppingCart。这会创建多个ShoppingCart bean的实例，但是对于给定的会话只会创建一个实例，在当前会话相关的操作中，这个bean实际上相当于单例的。 </p>
<p>要注意的是，<code>@Scope</code> 同时还有一个proxyMode属性，它被设置成了  <code>ScopedProxyMode.INTERFACES</code> 。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题（通过动态代理技术生成会话/请求作用域的代理类作为注入对象，等到方法被调用时再委托给真正的bean）。</p>
<p>假设我们要将ShoppingCart bean注入到单例StoreService bean的Setter方法中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreService</span> </span>&#123; </span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShoppingCart</span><span class="params">(ShoppingCart shoppingCart)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.shoppingCart = shoppingCart;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为StoreService是一个单例的bean，会在Spring应用上下文加载的时候创建。当它创建的时候，Spring会试图将ShoppingCart bean注入到 <code>setShoppingCart()</code> 方法中。但是ShoppingCart bean是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。 </p>
<p>Spring并不会将实际的ShoppingCart bean注入到StoreService中，Spring会注入一个到ShoppingCart bean的代理，如图3.1所示。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。 </p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020102.png" alt></p>
<p>现在，我们带着对这个作用域的理解，讨论一下proxyMode属性。如配置所示，proxyMode属性被设置成了 <code>ScopedProxyMode.INTERFACES</code> ，这表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean。 </p>
<p>如果ShoppingCart是接口而不是类的话，这是可以的（也是最为理想的代理模式）。但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了（JDK动态代理基于接口）。此时，它必须使用<strong>CGLib来生成基于类的代理</strong>。所以，如果bean类型是具体类的话，我们必须要将proxyMode属性设置为 <code>ScopedProxyMode.TARGET_CLASS</code> ，以此来表明要以生成目标类扩展的方式创建代理。当然请求作用域的bean会面临相同的装配问题。</p>
<h4 id="4-4-2-在XML中声明作用域代理"><a href="#4-4-2-在XML中声明作用域代理" class="headerlink" title="4.4.2 在XML中声明作用域代理"></a><strong>4.4.2 在XML中声明作用域代理</strong></h4><p>使用XML来声明会话或请求作用域的bean，那么就不能使用 <code>@Scope</code> 注解及其proxyMode属性了。<code>&lt;bean&gt;</code> 元素的scope属性能够设置bean的作用域，但是该怎样指定代理模式呢？ </p>
<p>要设置代理模式，我们需要使用 <code>Spring aop</code> 命名空间的一个新元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cart"</span> <span class="attr">class</span>=<span class="string">"xxx.ShoppingCart"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 默认CGLib代理 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:scoped-proxy</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- JDK代理 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:scoped-proxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <code>&lt;aop:scoped-proxy&gt;</code> 是与 <code>@Scope</code> 注解的proxyMode属性功能相同的Spring XML配置元素。它会告诉Spring为bean创建一个作用域代理。<strong>默认情况下，它会使用CGLib创建目标类的代理</strong>。但是我们也可以将 <code>proxy-target-class</code> 属性设置为false，进而要求它生成基于接口的代理：</p>
<h3 id="4-5-运行时值注入"><a href="#4-5-运行时值注入" class="headerlink" title="4.5 运行时值注入"></a><strong>4.5 运行时值注入</strong></h3><p>当讨论依赖注入的时候，我们通常所讨论的是将一个bean引用注入到另一个bean的属性或构造器参数中。它通常来讲指的是将一个对象与另一个对象进行关联。但是bean装配的另外一个方面指的是将一个值注入到bean的属性或者构造器参数中，实现的时候是将值硬编码在配置类中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(</span><br><span class="line">		<span class="string">"Sgt. Peppers`s Lonely Hearts Club Band"</span>,</span><br><span class="line">		<span class="string">"The Beatles"</span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候硬编码是可以的，但有的时候，我们可能会希望避免硬编码值，而是想让这些值在运行时再确定。为了实现这些功能，Spring提供了两种在运行时求值的方式： </p>
<ul>
<li><strong>属性占位符</strong>（Property placeholder）。</li>
<li><strong>Spring表达式语言</strong>（SpEL）。</li>
</ul>
<h4 id="4-5-1-注入外部的值"><a href="#4-5-1-注入外部的值" class="headerlink" title="4.5.1 注入外部的值"></a><strong>4.5.1 注入外部的值</strong></h4><p>在Spring中，处理外部值的最简单方式就是<strong>声明属性源并通过Spring的Environment来检索属性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/xxx/app.properties"</span>) <span class="comment">// 声明属性源</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressiveConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	Environment env;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BlankDisc <span class="title">disc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(</span><br><span class="line">			<span class="comment">// 检索属性值</span></span><br><span class="line">			env.getProperty(<span class="string">"disc.title"</span>),</span><br><span class="line">			env.getProperty(<span class="string">"disc.artist"</span>)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring一直支持将属性定义到外部的属性的文件中，并使用占位符值将其插入到Spring bean中。在Spring装配中，占位符的形式为使用 <code>${ ... }</code> 包装的属性名称。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sgtPeppers"</span> <span class="attr">class</span>=<span class="string">"xxx.BlankDisc"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">c:_title</span>=<span class="string">"$&#123;disc.title&#125;"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">c:_artist</span>=<span class="string">"$&#123;disc.artist&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们依赖于组件扫描和自动装配来创建和初始化应用组件的话，那么就没有指定占位符的配置文件或类了。在这种情况下，我们可以使用 <code>@Value</code> 注解，它的使用方式与 <code>@Autowired</code> 注解非常相似。比如，在BlankDisc类中，构造器可以改成如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span> <span class="params">(@Value(<span class="string">"$&#123;disc.title&#125;"</span>)</span> String title,</span></span><br><span class="line"><span class="function">                     @<span class="title">Value</span><span class="params">(<span class="string">"$&#123;disc.artist&#125;"</span>)</span> String artist)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.title = title;</span><br><span class="line">	<span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用占位符，我们必须要配置一个 <code>PropertyPlaceholderConfigurer bean</code> 或 <code>PropertySourcesPlaceholderConfigurer bean</code> 。从Spring 3.1开始，推荐使用 <code>PropertySourcesPlaceholderConfigurer</code> ，因为它能够基于 <code>Spring Environment</code> 及其属性源来解析占位符。 </p>
<p>如下的 <code>@Bean</code> 方法在Java中配置了 <code>PropertySourcesPlaceholderConfigurer</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">placeholderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XML通过Spring context命名空间中的 <code>&lt;context:propertyplaceholder&gt;</code> 元素为你生成 <code>PropertySourcesPlaceholderConfigurer bean</code> ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:propertyplaceholder</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-5-2-使用Spring表达式语言进行装配"><a href="#4-5-2-使用Spring表达式语言进行装配" class="headerlink" title="4.5.2 使用Spring表达式语言进行装配"></a><strong>4.5.2 使用Spring表达式语言进行装配</strong></h4><p>Spring 3引入了<strong>Spring表达式语言</strong>（Spring Expression Language，SpEL），它能够以一种强大和简洁的方式将值装配到bean属性和构造器参数中，在这个过程中所使用的表达式会在运行时计算得到值。</p>
<p>SpEL拥有很多特性，包括： </p>
<ul>
<li>使用bean的ID来引用bean； </li>
<li>调用方法和访问对象的属性；</li>
<li>对值进行算术、关系和逻辑运算； </li>
<li>正则表达式匹配； </li>
<li>集合操作。</li>
</ul>
<p>SpEL能够用在依赖注入以外的其他地方，例如Spring Security支持使用SpEL表达式定义安全限制规则。另外，如果你在Spring MVC应用中使用Thymeleaf模板作为视图的话，那么这些模板可以使用SpEL表达式引用模型数据。 </p>
<h5 id="（1）SpEL样例"><a href="#（1）SpEL样例" class="headerlink" title="（1）SpEL样例"></a><strong>（1）SpEL样例</strong></h5><p>需要了解的第一件事情就是SpEL表达式要放到 <code>#{ ... }</code> 之中，类似于属性占位符需要放到 <code>${ ... }</code> 之中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的SpEL表达式</span></span><br><span class="line">#&#123;1&#125;</span><br><span class="line"><span class="comment">// 计算表达式当前时间，T()表达式会将java.lang.System视为Java中对应的类型，因此可以调用其static修饰的currentTimeMillis()方法。</span></span><br><span class="line">#&#123;T(System).currentTimeMilis()&#125;</span><br><span class="line"><span class="comment">// 引用其他的bean或其他bean的属性</span></span><br><span class="line">#&#123;sgtPeppers.artist&#125;</span><br><span class="line"><span class="comment">// 可以通过systemProperties对象引用系统属性</span></span><br><span class="line">#&#123;systemProperties[disc.title]&#125;</span><br></pre></td></tr></table></figure>
<p>在bean装配的时候如何使用这些表达式？</p>
<p>如果通过组件扫描创建bean的话，在注入属性和构造器参数时，我们可以使用 <code>@Value</code> 注解，这与之前看到的属性占位符非常类似。不过，在这里我们所使用的不是占位符表达式， 而是SpEL表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span> <span class="params">(@Value(<span class="string">"#&#123;systemProperties[disc.title]&#125;"</span>)</span> String title,</span></span><br><span class="line"><span class="function">                     @<span class="title">Value</span><span class="params">(<span class="string">"#&#123;systemProperties[disc.artist]&#125;"</span>)</span> String artist)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.title = title;</span><br><span class="line">	<span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在XML配置中，你可以将SpEL表达式传入 <code>&lt;property&gt;</code> 或 <code>&lt;constructor-arg&gt;</code> 的value 属性中，或者将其作为 <code>p-</code> 命名空间或 <code>c-</code> 命名空间条目的值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sgtPeppers"</span> <span class="attr">class</span>=<span class="string">"xxx.BlankDisc"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">c:_title</span>=<span class="string">"#&#123;systemProperties[disc.title]&#125;"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">c:_artist</span>=<span class="string">"#&#123;systemProperties[disc.artist]&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="（2）SpEL所支持的基础表达式"><a href="#（2）SpEL所支持的基础表达式" class="headerlink" title="（2）SpEL所支持的基础表达式"></a><strong>（2）SpEL所支持的基础表达式</strong></h5><ul>
<li><p><strong>表示字面值</strong>：SpEL可以用来表示 浮点数、String值以及Boolean值。但很少这样用，几乎所有情况下字面值并不需要使用SpEL。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&#123;3.1415&#125;</span><br><span class="line">#&#123;9.87E4&#125;</span><br><span class="line">#&#123;'Hello'&#125;</span><br><span class="line">#&#123;false&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用bean、属性和方法</strong>：SpEL可以通过ID引用其他的bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#&#123;sgtPeppers&#125;</span><br><span class="line">#&#123;sgtPeppers.artist&#125;</span><br><span class="line">#&#123;artistSelector.selectArtist()&#125;</span><br><span class="line">#&#123;artistSelector.selectArtist().toUpperCase()&#125;</span><br><span class="line"><span class="comment">// 为了避免出现NullPointerException，可以使用类型安全的运算符：</span></span><br><span class="line">#&#123;artistSelector.selectArtist()?.toUpperCase()&#125;</span><br><span class="line"><span class="comment">// 如果selectArtist()的返回值是null的话，那么SpEL将不会调用toUpperCase()方法。表达式的返回值会是null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在表达式中使用类型</strong>：在SpEL中访问类作用域的方法和常量的话，要依赖 <code>T()</code> 这个关键的运算符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T()运算符的结果会是一个Class对象，代表了java.lang.Math</span></span><br><span class="line">T(java.lang.Math)</span><br><span class="line"><span class="comment">// 如果需要的话，我们甚至可以将其装配到一个Class类型的bean属性中。但是T()运算符的真正价值在于它能够访问目标类型的静态方法和常量。</span></span><br><span class="line">T(java.lang.Math).PI</span><br><span class="line">T(java.lang.Math).random()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>概述了SpEL运算符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符类型</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">算术运算</td>
<td>+、-、 * 、/、%、^</td>
</tr>
<tr>
<td style="text-align:center">比较运算</td>
<td>&lt; 、 &gt; 、 == 、 &lt;= 、 &gt;= 、 lt 、 gt 、 eq 、 le 、 ge</td>
</tr>
<tr>
<td style="text-align:center">逻辑运算</td>
<td>and 、 or 、 not 、│</td>
</tr>
<tr>
<td style="text-align:center">条件运算</td>
<td>?: (ternary) 、 ?: (Elvis)</td>
</tr>
<tr>
<td style="text-align:center">正则表达式</td>
<td>matches</td>
</tr>
</tbody>
</table>
<p> 使用案例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpEL乘法运算符</span></span><br><span class="line">#&#123;2 * T(java.lang.Math).PI * circle.radius&#125;</span><br><span class="line"><span class="comment">// 三元运算符（ternary）</span></span><br><span class="line">#&#123;scoreboard.score &gt; 1000 ? "Winner!" : "Loser"&#125;</span><br><span class="line"><span class="comment">// 默认值代替null，也叫Elvis运算符</span></span><br><span class="line">#&#123;disc.title ?: 'Rattle and Hum'&#125;</span><br><span class="line"><span class="comment">// 正则表达式，判断字符串是否包含有效的邮箱地址</span></span><br><span class="line">#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'&#125;</span><br><span class="line"><span class="comment">// 计算集合</span></span><br><span class="line"><span class="comment">// 引用列表中的一个元素</span></span><br><span class="line">#&#123;jukebox.songs[4].title&#125;</span><br><span class="line"><span class="comment">// 随机获取列表中的一个元素</span></span><br><span class="line">#&#123;jukebox.songs[T(java.lang.Math).random() * jukebox.songs.size()].title&#125;</span><br><span class="line"><span class="comment">// 字符串也可以看作数组，返回第四个字符s</span></span><br><span class="line">#&#123;'This is a test'[3]&#125;</span><br><span class="line"><span class="comment">// 查询运算符（.?[]），它会用来对集合进行过滤，得到集合的一个子集。</span></span><br><span class="line">#&#123;jukebox.songs.?[artist eq 'Aerosmith']&#125;</span><br><span class="line"><span class="comment">// 另外两个查询运算符：“.^[]”和“.$[]”，它们分别用来在集合中查询第一个匹配项和最后一个匹配项。</span></span><br><span class="line">#&#123;jukebox.songs.^[artist eq 'Aerosmith']&#125;</span><br><span class="line"><span class="comment">// 投影运算符（.![]），它会从集合的每个成员中选择特定的属性放到另外一个集合中。</span></span><br><span class="line">#&#123;jukebox.songs.![title]&#125;</span><br><span class="line"><span class="comment">// 组合使用</span></span><br><span class="line">#&#123;jukebox.songs.?[artist eq 'Aerosmith'].![title]&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第四节-源码解析"><a href="#第四节-源码解析" class="headerlink" title="第四节 源码解析"></a><strong>第四节 源码解析</strong></h2><h3 id="4-1-Bean"><a href="#4-1-Bean" class="headerlink" title="4.1 Bean"></a><strong>4.1 Bean</strong></h3><p><code>@Bean</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Autowire <span class="title">autowire</span><span class="params">()</span> <span class="keyword">default</span> Autowire.NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">initMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">destroyMethod</span><span class="params">()</span> <span class="keyword">default</span> "<span class="params">(inferred)</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-BeanDefinition"><a href="#4-2-BeanDefinition" class="headerlink" title="4.2 BeanDefinition"></a><strong>4.2 BeanDefinition</strong></h3><p><code>BeanDefinition</code> 与 <code>Bean</code> 的关系类似于类与对象的关系，通过 <code>BeanDefinition</code> 定义的数据结构，Ioc 容器能够方便的对 <code>Bean</code> 进行管理。<code>BeanDefinition</code> 就是对控制反转模式中管理的对象依赖关系的数据抽象，也是容器实现控制反转功能的核心数据结构，控制反转功能都是围绕对这个 <code>BeanDefinition</code> 的处理来完成的。</p>
<p><code>BeanDefinition</code> 事实上就是 Bean 的定义在运行时的表现。无论是 xml 配置的 Bean，还是注解定义的 Bean，又或者是自定义扫描进来的 Bean，最终都通过 <code>BeanDefinition</code> 来承载。如果有自定义的 xml 标签，解析后也是生成 <code>BeanDefinition</code> 注册到 IOC 中。这样设计，IOC 只需要关心 <code>BeanDefinition</code> 即可，极大增加了扩展性和灵活性。当我们 <code>getBean</code> 的时候，如果 Bean 还没有初始化，容器就会找到 <code>BeanDefinition</code> ，然后根据 <code>BeanDefinition</code> 初始化 Bean 及其依赖。</p>
<p><code>BeanDefinition</code> 的接口定义和实现类如图所示，整体也是分层设计。基于注解的 Bean 定义使用  <code>AnnotatedBeanDefinition</code> 描述，定义了获取具体 <code>Method</code> 的方法。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020106.png" alt></p>
<p>该接口定义了一些构造Bean需要的方法，可以获取以及设置Bean的基本信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">    String SCOPE_SINGLETON = <span class="string">"singleton"</span>;</span><br><span class="line">    String SCOPE_PROTOTYPE = <span class="string">"prototype"</span>;</span><br><span class="line">    <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Bean的类名称</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取作用域</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否懒加载</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的FactoryBean名称</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取构造器参数，可以通过 xml、注解注入</span></span><br><span class="line">    <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.getConstructorArgumentValues().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性参数，可以通过 xml、注解注入</span></span><br><span class="line">    <span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.getPropertyValues().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-1-Resource定位"><a href="#4-2-1-Resource定位" class="headerlink" title="4.2.1 Resource定位"></a><strong>4.2.1 Resource定位</strong></h4><p><strong>Resource定位</strong> 即 <code>BeanDefinition</code> 的资源定位，由 <code>ResourceLoader</code> 通过统一的 <code>Resource</code> 接口来实现。Spring提供了适用于各种场景的默认实现，如类路径下的资源可以用 <code>ClassPathResource</code> 、网络上的资源可以用 <code>UrlResource</code> 等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Channels.newChannel(<span class="keyword">this</span>.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">createRelative</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultResourceLoader</code> 实现了 <code>ResourceLoader</code> 接口，其是各种 <code>XXResourceLoader</code> 和 <code>XXApplicationContext</code> 的父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    String CLASSPATH_URL_PREFIX = <span class="string">"classpath:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-BeanDefinition的载入过程"><a href="#4-2-2-BeanDefinition的载入过程" class="headerlink" title="4.2.2 BeanDefinition的载入过程"></a><strong>4.2.2 BeanDefinition的载入过程</strong></h4><p><code>BeanDefinition</code> 的载入过程，就是解析 <code>Resource</code> 对象得到 <code>BeanDefinitionHolder</code> 对象的过程。</p>
<p><code>BeanDefinitionHolder</code> 的作用是<strong>根据名称或者别名持有 <code>beanDefinition</code> ，承载了 <code>name</code> 和 <code>BeanDefinition</code> 的映射信息</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际持有的 beanDefinition 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line">    <span class="comment">// Bean 的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line">    <span class="comment">// Bean 的别名</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinitionHolder</span><span class="params">(BeanDefinition beanDefinition, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(beanDefinition, beanName, (String[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinitionHolder</span><span class="params">(BeanDefinition beanDefinition, String beanName, @Nullable String[] aliases)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition = beanDefinition;</span><br><span class="line">        <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">        <span class="keyword">this</span>.aliases = aliases;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinitionHolder</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanDefinitionHolder, <span class="string">"BeanDefinitionHolder must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition = beanDefinitionHolder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">this</span>.beanName = beanDefinitionHolder.getBeanName();</span><br><span class="line">        <span class="keyword">this</span>.aliases = beanDefinitionHolder.getAliases();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> String[] getAliases() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.aliases;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition.getSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较适配Bean名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchesName</span><span class="params">(@Nullable String candidateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> candidateName != <span class="keyword">null</span> &amp;&amp; (candidateName.equals(<span class="keyword">this</span>.beanName) || candidateName.equals(BeanFactoryUtils.transformedBeanName(<span class="keyword">this</span>.beanName)) || ObjectUtils.containsElement(<span class="keyword">this</span>.aliases, candidateName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShortDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"Bean definition with name '"</span>).append(<span class="keyword">this</span>.beanName).append(<span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">" and aliases ["</span>).append(StringUtils.arrayToCommaDelimitedString(<span class="keyword">this</span>.aliases)).append(<span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLongDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="keyword">this</span>.getShortDescription());</span><br><span class="line">        sb.append(<span class="string">": "</span>).append(<span class="keyword">this</span>.beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getLongDescription();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == other) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(other <span class="keyword">instanceof</span> BeanDefinitionHolder)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BeanDefinitionHolder otherHolder = (BeanDefinitionHolder)other;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition.equals(otherHolder.beanDefinition) &amp;&amp; <span class="keyword">this</span>.beanName.equals(otherHolder.beanName) &amp;&amp; ObjectUtils.nullSafeEquals(<span class="keyword">this</span>.aliases, otherHolder.aliases);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashCode = <span class="keyword">this</span>.beanDefinition.hashCode();</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + <span class="keyword">this</span>.beanName.hashCode();</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.aliases);</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 并不是直接把 XML 文件的内容转换成 <code>BeanDefinitionHolder</code> 。解析时先解析 XML 得到 <code>Document</code> 对象，<code>Document</code> 对象就是 XML 文件在内存里的存储形式。从 <code>Document</code> 对象提取数据用的是 <code>BeanDefinitionDocumentReader</code> 。</p>
<p>对于 <code>Document</code> 对象中的一个节点 <code>Element</code> ，是使用 <code>BeanDefinitionParser</code> 进行解析。开发者也可以自定义 <code>BeanDefinitionParser</code> 从而实现对 XML 配置的自定义解析，可以实现诸如自定义 XML 标签的功能。</p>
<h4 id="4-2-3-BeanDefinition的注册"><a href="#4-2-3-BeanDefinition的注册" class="headerlink" title="4.2.3 BeanDefinition的注册"></a><strong>4.2.3 BeanDefinition的注册</strong></h4><p>这个操作是通过调用 <code>BeanDefinitionRegistry</code> 接口来实现的。这个注册过程把载入过程中解析得到的 <code>BeanDeifinition</code> 向 Ioc 容器进行注册。</p>
<p>调用 <code>registerBeanDefinition</code> 方法解析 <code>BeanDefinitionHolder</code> 对象，按照 Bean 的名称、别名将 <code>BeanDefinition</code> 注册到 IoC 容器中，存储在 <code>beanDefinitionMap</code> 中。至此，容器的初始化基本完成。</p>
<p><code>registerBeanDefinition</code> 是一个可以复用的方法，毕竟 Spring 内部注册的流程是确定的，因此 <code>registerBeanDefinition</code> 处于底层实现中。各种形式不同的上层实现最终都调用了同一个注册方法，殊途同归。在阿里很多软件架构中，也都采用了类似的设计，把注册配置统一收口便于管理。</p>
<h3 id="4-3-BeanFactory"><a href="#4-3-BeanFactory" class="headerlink" title="4.3 BeanFactory"></a><strong>4.3 BeanFactory</strong></h3><p><code>BeanFactory</code> 接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line">	<span class="comment">// getBean系列获取Bean实例</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String var1, @Nullable Class&lt;T&gt; var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1, Object... var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; var1, Object... var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String var1, ResolvableType var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String var1, @Nullable Class&lt;?&gt; var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String var1) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BeanFactory</code> 只定义了基本功能，是一个最核心的容器接口定义。在 <code>BeanFactory</code> 的基础上 Spring 通过继承逐层扩充容器的能力。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020107.png" alt></p>
<p><code>HierarchicalBeanFactory</code> 接口在继承了 <code>BeanFactory</code> 后，增加了 <code>getParentBeanFactory</code> 方法，使 <code>BeanFactory</code> 具备了<strong>双亲IoC容器</strong>的管理功能。</p>
<p>在 <code>ConfigurableBeanFactory</code> 中，定义了一些对 <code>BeanFactory</code> 的配置功能，比如通过 <code>setParentBeanFactory</code> 方法设置双亲IoC容器，通过 <code>addBeanPostProcessor</code> 方法配置Bean后置处理器。</p>
<h3 id="4-4-ApplicationContext"><a href="#4-4-ApplicationContext" class="headerlink" title="4.4 ApplicationContext"></a><strong>4.4 ApplicationContext</strong></h3><p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>, <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 <code>ApplicationContext</code> 为核心的接口系列中，<code>ListableBeanFactory</code> 和 <code>HierarchicalBeanFactory</code> 两个接口连接了 <code>BeanFactory</code> 接口定义和 <code>ApplicationConext</code> 应用上下文的接口定义。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020107.png" alt></p>
<p>在 <code>ListableBeanFactory</code> 接口中，细化了许多 <code>BeanFactory</code> 的接口功能，比如定义了 <code>getBeanDefinitionNames</code> 接口方法。对于 <code>ApplicationContext</code> 接口，它通过继承 <code>MessageSource</code> 、<code>ResourceLoader</code> 、<code>ApplicationEventPublisher</code> 接口，在 <code>BeanFactory</code> 的基础上添加了对高级容器特性的支持。</p>
<p><strong><code>ApplicationContext</code> 继承了 <code>BeanFactory</code> 接口，具有了容器的基本功能，同时根据上下文的特点，也用 <code>ListableBeanFactory</code> 接口做了功能扩展。上下文与容器的主要区别，还是体现在容器高级特性上，比如 <code>MessageSource</code> 实现了国际化、<code>ResourceLoader</code> 实现了资源加载、<code>ApplicationEventPublisher</code> 实现了事件机制。因此平时工作中使用上下文会多一点，一般不直接使用 <code>BeanFactory</code> 简单容器。</strong></p>
<h3 id="4-5-FactoryBean"><a href="#4-5-FactoryBean" class="headerlink" title="4.5 FactoryBean"></a><strong>4.5 FactoryBean</strong></h3><p>在 <code>BeanFactory</code> 中，<code>Bean</code> 是通过 <code>FactoryBean</code> 来获取的。<code>FactoryBean</code> 是一个工厂Bean，可以生成某一个类型 <code>Bean</code> 的实例，它最大的一个作用是：<strong>可以让我们自定义 <code>Bean</code> 的创建过程</strong>。可以使用转义符 <code>&amp;</code> 得到  <code>FactoryBean</code> 本身，用来区分通过容器来获取 <code>FactoryBean</code> 产生的对象和获取 <code>FactoryBean</code> 本身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>FactoryBean</code> 和 <code>BeanFactory</code> ，一个是 Factory，也就是 IOC 容器工厂，一个是特色类型的 Bean。所有的 <code>Bean</code> 都是由 <code>BeanFactory</code> 管理。<code>FactoryBean</code> 是一个能产生或者修饰对象生成的工厂 Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。这两个类型名称比较接近，很多人容易混淆，只要记住结尾区分即可，一个是工厂，一个是 Bean。</strong></p>
<h3 id="4-6-DefaultListableBeanFactory"><a href="#4-6-DefaultListableBeanFactory" class="headerlink" title="4.6 DefaultListableBeanFactory"></a><strong>4.6 DefaultListableBeanFactory</strong></h3><p><code>DefaultListableBeanFactory</code> 实际上包含了基本IoC容器所具有的重要功能，在Spring中，实际上是把  <code>DefaultListableBeanFactory</code> 作为一个默认的功能完整的 IoC 容器来使用的。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020109.png" alt></p>
<p><strong>一个真正完整的容器在启动阶段主要做几个事情：</strong></p>
<ol>
<li><strong>找到 Bean 定义，如 xml、注解等，如果是资源文件可以用 Resource 类来封装，支持 ClassPath、jar、URL 等；</strong></li>
<li><strong>初始化 Reader 注入 Resource，BeanDefinitionReader 接口定义了解析相关的方法，Spring 默认提供了很多实现类；</strong></li>
<li><strong>Reader 解析 BeanDefinition，初始化后注册到容器中。</strong></li>
</ol>
<h3 id="4-7-FileSystemXmlApplicationContext"><a href="#4-7-FileSystemXmlApplicationContext" class="headerlink" title="4.7 FileSystemXmlApplicationContext"></a><strong>4.7 FileSystemXmlApplicationContext</strong></h3><p>主要功能已经在 <code>AbstractXmlApplicationContext</code> 中实现了，在 <code>FileSystemXmlApplicationContext</code> 中，作为一个具体的应用上下文，只需要实现和它自身设计相关的两个功能。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005020110.png" alt></p>
<p>如果应用直接使用 <code>FileSystemXmlApplicationContext</code> ，对于实例化这个应用上下文的支持，同时启动IoC容器的 <code>refresh()</code> 过程。这个 <code>refresh()</code> 过程会牵涉 IoC 容器启动的一系列复杂操作，同时，对于不同的容器实现，这些操作都是类似的，因此在基类中将它们封装好。所以，我们在 <code>FileSystemXml</code> 的设计中看到的只是一个简单的调用。</p>
<p>FileSystemXmlApplicationContext 是一个从文件系统加载 XML 的上下文实现，因此</p>
<p>设计了从文件系统中加载XML的功能。</p>
<p><strong>解读：</strong></p>
<p><strong>可以看到，Spring 内部上下文的实现和继承关系非常复杂，难以理解。实际上，按照实现分层的思路去理解还是比较容易的，每一层只实现自己相关的功能。类似或者公用的能力都往下沉淀变为底层的基础能力，上层实现只做调用。看源码的时候，要有全局视野，哪些是公用能力，哪些是本层次定制功能，这样就会好理解一点。</strong></p>
<h3 id="4-8-refresh"><a href="#4-8-refresh" class="headerlink" title="4.8 refresh()"></a><strong>4.8 refresh()</strong></h3><p><strong>refresh 是上下文的很重要的一个操作。Spring容器的启动，初始化一些容器启动必要的资源，BeanFactory 的创建、初始化，Bean 的创建、初始化、注册、非懒加载，注册和设置国际化工具类MessageSource，注册和设置事件，等一系列过程都在这个 refresh 方法里面进行调用。</strong></p>
<h4 id="4-8-1-refresh"><a href="#4-8-1-refresh" class="headerlink" title="4.8.1 refresh()"></a><strong>4.8.1 refresh()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    	<span class="comment">// 一些重置操作以及初始化操作</span></span><br><span class="line">        <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从Spring容器获取BeanFactory(Spring Bean容器)并进行相关的设置为后续的使用做准备</span></span><br><span class="line">        <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">            <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">            <span class="keyword">this</span>.onRefresh();</span><br><span class="line">            <span class="keyword">this</span>.registerListeners();</span><br><span class="line">            <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">            <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">            <span class="keyword">throw</span> var9;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-2-prepareRefresh"><a href="#4-8-2-prepareRefresh" class="headerlink" title="4.8.2 prepareRefresh()"></a><strong>4.8.2 prepareRefresh()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些重置操作以及初始化操作</span></span><br><span class="line">    <span class="comment">// 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性源信息(Property)</span></span><br><span class="line">    <span class="keyword">this</span>.initPropertySources();</span><br><span class="line">    <span class="comment">// 验证环境信息里一些必须存在的属性</span></span><br><span class="line">    <span class="keyword">this</span>.getEnvironment().validateRequiredProperties();</span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-3-obtainFreshBeanFactory"><a href="#4-8-3-obtainFreshBeanFactory" class="headerlink" title="4.8.3 obtainFreshBeanFactory()"></a><strong>4.8.3 obtainFreshBeanFactory()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.refreshBeanFactory();</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Bean factory for "</span> + <span class="keyword">this</span>.getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-4-prepareBeanFactory"><a href="#4-8-4-prepareBeanFactory" class="headerlink" title="4.8.4 prepareBeanFactory()"></a><strong>4.8.4 prepareBeanFactory()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    beanFactory.setBeanClassLoader(<span class="keyword">this</span>.getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, <span class="keyword">this</span>.getEnvironment()));</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(<span class="string">"loadTimeWeaver"</span>)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">"environment"</span>)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"environment"</span>, <span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">"systemProperties"</span>)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"systemProperties"</span>, <span class="keyword">this</span>.getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">"systemEnvironment"</span>)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"systemEnvironment"</span>, <span class="keyword">this</span>.getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-4-prepareBeanFactory-1"><a href="#4-8-4-prepareBeanFactory-1" class="headerlink" title="4.8.4 prepareBeanFactory()"></a><strong>4.8.4 prepareBeanFactory()</strong></h4><h4 id="4-8-4-prepareBeanFactory-2"><a href="#4-8-4-prepareBeanFactory-2" class="headerlink" title="4.8.4 prepareBeanFactory()"></a><strong>4.8.4 prepareBeanFactory()</strong></h4><h4 id="4-8-4-prepareBeanFactory-3"><a href="#4-8-4-prepareBeanFactory-3" class="headerlink" title="4.8.4 prepareBeanFactory()"></a><strong>4.8.4 prepareBeanFactory()</strong></h4><h4 id="4-8-4-prepareBeanFactory-4"><a href="#4-8-4-prepareBeanFactory-4" class="headerlink" title="4.8.4 prepareBeanFactory()"></a><strong>4.8.4 prepareBeanFactory()</strong></h4><h4 id="4-8-4-prepareBeanFactory-5"><a href="#4-8-4-prepareBeanFactory-5" class="headerlink" title="4.8.4 prepareBeanFactory()"></a><strong>4.8.4 prepareBeanFactory()</strong></h4><h4 id="4-8-4-prepareBeanFactory-6"><a href="#4-8-4-prepareBeanFactory-6" class="headerlink" title="4.8.4 prepareBeanFactory()"></a><strong>4.8.4 prepareBeanFactory()</strong></h4><hr>
<h2 id="第五节-Bean的创建过程"><a href="#第五节-Bean的创建过程" class="headerlink" title="第五节 Bean的创建过程"></a><strong>第五节 Bean的创建过程</strong></h2><h3 id="5-1-过程"><a href="#5-1-过程" class="headerlink" title="5.1 过程"></a><strong>5.1 过程</strong></h3><ol>
<li>实例化 <code>BeanFactoryPostProcessor</code> 实现类</li>
<li>调用 <code>BeanFactoryPostProcessor</code> # <code>postProcessBeanFactory</code></li>
<li>实例化 <code>BeanPostProcessor</code> 实现类</li>
<li>调用 <code>InstantiationAwareBeanPostProcessor</code> # <code>postProcessBeforeInstantiation</code> </li>
<li>实例化 <code>Bean</code></li>
<li>调用 <code>InstantiationAwareBeanProcessor</code> # <code>postProcessAfterInstantiation</code></li>
<li>调用 <code>InstantiationAwareBeanPostProcessor</code> # <code>postProcessPropertyValues</code></li>
<li>为 <code>Bean</code> 注入属性</li>
<li>调用 <code>BeanNameAware</code> # <code>setBeanName</code></li>
<li>调用 <code>BeanClassLoaderAware</code> # <code>setBeanClassLoader</code></li>
<li>调用 <code>BeanFactoryAware</code> # <code>setBeanFactory</code></li>
<li>调用 <code>BeanPostProcessor</code> # <code>postProcessBeforeInitialization</code></li>
<li>调用 <code>InitializingBean</code> # <code>afterPropertiesSet</code></li>
<li>调用 <code>Bean</code> 的 <code>init-method</code></li>
<li>调用 <code>BeanPostProcessor</code> # <code>postProcessAfterInitialization</code></li>
</ol>
<h3 id="5-2-IoC容器依赖注入"><a href="#5-2-IoC容器依赖注入" class="headerlink" title="5.2 IoC容器依赖注入"></a><strong>5.2 IoC容器依赖注入</strong></h3><p>在IoC容器初始化的过程中，建立 <code>BeanDefinition</code> 的数据映射，之后所有的依赖的注入都依托于已经存在的 <code>BeanDefinition</code> 。 <code>BeanDefinition</code> 通过资源定位、载入、注册流程后完成容器的初始化，接下来重点关注上下文的 <code>getBean</code> 。</p>
<p>在 <code>AbstractApplicationContext</code> 抽象类中有一个 <code>getBeanFactory</code> 方法用于返回一个 <code>ConfigurableListableBeanFactory</code> ，所有 <code>BeanFactory</code> 接口的方法实际上都委托给子类内部的 <code>ConfigurableListableBeanFactory</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如 <code>AnnotationConfigApplicationContext</code> ，它在被构造时，内部的beanFactory实际上是由父类 <code>GenericApplicationContext</code> 初始化的 <code>DefaultListableBeanFactory</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> customClassLoader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean refreshed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customClassLoader = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.refreshed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因此我们看某个bean是如何被加载的可以从 <code>DefaultListableBeanFactory</code> 的 <code>getBean</code> 方法看起，对于 <code>DefaultListableBeanFactory</code> 而言那些 <code>getBean</code> 方法实际上在 <code>AbstractBeanFactory</code> 这一层就都已经实现了，并且都委托给了 <code>AbstractBeanFactory</code> # <code>doGetBean</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, @Nullable Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    NamedBeanHolder&lt;T&gt; namedBean = <span class="keyword">this</span>.resolveNamedBean(requiredType, args);</span><br><span class="line">    <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> namedBean.getBeanInstance();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BeanFactory parent = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> args != <span class="keyword">null</span> ? parent.getBean(requiredType, args) : parent.getBean(requiredType);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AbstractBeanFactory</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doGetBean(name, (Class)<span class="keyword">null</span>, (Object[])<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">        Object bean;</span><br><span class="line">        <span class="comment">// 尝试从缓存中拿取一个Bean实例</span></span><br><span class="line">        <span class="comment">// Spring会在Bean还未完全初始化完毕前，通过一个ObjectFactory提前暴露出bean实例，这样为解决循环依赖提供了便利</span></span><br><span class="line">        Object sharedInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// DEBUG日志</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName + <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对FactoryBean的情况进行特殊处理</span></span><br><span class="line">            bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果正在创建的bean为原型并且已经正在创建，这种循环依赖是无法解决的，要抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果该beanFactory中不包含要创建bean的beanDefinition，则尝试从父beanFactory中寻找。</span></span><br><span class="line">            BeanFactory parentBeanFactory = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                String nameToLookup = <span class="keyword">this</span>.originalBeanName(name);</span><br><span class="line">                <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">                <span class="keyword">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RootBeanDefinition mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                <span class="keyword">this</span>.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">                <span class="comment">// 有些bean是有depends-on/@DependsOn的，需要先初始化这些依赖。</span></span><br><span class="line">                String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">                String[] var11;</span><br><span class="line">                <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var11 = dependsOn;</span><br><span class="line">                    <span class="keyword">int</span> var12 = dependsOn.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var13 = <span class="number">0</span>; var13 &lt; var12; ++var13) &#123;</span><br><span class="line">                        String dep = var11[var13];</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.isDependent(beanName, dep)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">this</span>.registerDependentBean(dep, beanName);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">this</span>.getBean(dep);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException var24) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, var24);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 创建单例bean。</span></span><br><span class="line">                <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                	<span class="comment">//调用父类DefaultSingletonBeanRegistry的getSingleton，具体创建bean的工作实际上仍然是回调参数中传递的ObjectFactory#getObject方法，而createBean实际上是子类AbstractAutowireCapableBeanFactory实现的。</span></span><br><span class="line">                    sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> var5;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 对FactoryBean的情况进行特殊处理。</span></span><br><span class="line">                    bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 创建原型bean。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                    var11 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    Object prototypeInstance;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 前置处理，维护prototypesCurrentlyInCreation，加入当前bean记录。</span></span><br><span class="line">                        <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="comment">// 委托给子类AbstractAutowireCapableBeanFactory来完成具体的创建bean工作。</span></span><br><span class="line">                        prototypeInstance = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 后置处理，维护prototypesCurrentlyInCreation信息，删除当前bean记录。</span></span><br><span class="line">                        <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对FactoryBean的情况进行特殊处理。</span></span><br><span class="line">                    bean = <span class="keyword">this</span>.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String scopeName = mbd.getScope();</span><br><span class="line">                    Scope scope = (Scope)<span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                    <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                            <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line"></span><br><span class="line">                            Object var4;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                var4 = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> var4;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        bean = <span class="keyword">this</span>.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalStateException var23) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>, var23);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var26) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">                <span class="keyword">throw</span> var26;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里一个bean就已经创建完了，最后一步检查类型，如果不匹配会尝试转换。</span></span><br><span class="line">        <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                T convertedBean = <span class="keyword">this</span>.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">                <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> convertedBean;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TypeMismatchException var25) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> + ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, var25);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面针对 <code>AbstractBeanFactory</code> # <code>doGetBean</code> 方法进行了源码分析，从中我们可以看出它主要会干这几件事情：</p>
<ol>
<li>转换beanName。</li>
<li>尝试从缓存的单例中拿实例。</li>
<li>如果要创建的bean是原型模式，且已经在尝试创建，这种循环依赖是无法解决的。</li>
<li>当前beanFactory不包含要创建的bean的beanDefinition，会尝试从parentBeanFactory中获取。</li>
<li>如果当前bean有依赖(xml的话就是有depends-on,注解的话有@DependsOn)，则需要先完成那些bean的创建初始化。</li>
<li>针对scope分类讨论创建。我们比较关心的就是单例，其次是原型。</li>
<li>类型检查，并且尝试转换。</li>
</ol>
<p>我们一般比较关心的就是单例bean和原型bean的创建。<br>在获取单例bean时doGetBean方法会调用父类DefaultSingletonBeanRegistry#getSingleton。可以把DefaultSingletonBeanRegistry当作一个“单例bean桶”，因为它确实就是一个用来存放单例bean的桶。但是这个桶本身不关心bean到底该怎么创建，所以对于桶里还没有的bean，它将创建bean的职责通过回调ObjectFactory#getObject来完成，而AbstractBeanFactory中传递给getSingleton方法的ObjectFactory#getObject的具体实现是调用createBean，这个方法是真正创建并初始化bean的方法，由子类AbstractAutowireCapableBeanFactory完成。<br>对于获取原型bean则简单多了，不用关心放到桶里缓存的事情，直接调用createBean创建就是了。</p>
<p>所以我们接下来通过AbstractAutowireCapableBeanFactory来看一下一个Bean具体是如何创建并初始化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 在对象被实例化前，这里有一个短路逻辑，会调用InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation。</span></span><br><span class="line"><span class="comment">         * 如果存在某个InstantiationAwareBeanPostProcessor的调用结果不为null，则形成了短路，接下来调用BeanPostProcessor#postProcessAfterInitialization。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 实际上，一般Spring里默认就LazyInitTargetSourceCreator和QuickTargetSourceCreator可能会使得这里的短路生效。</span></span><br><span class="line"><span class="comment">         * 大部分情况AOP还是在bean被正常实例化后通过调用postProcessAfterInitialization实现的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建bean的主要方法。</span></span><br><span class="line">    Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到AbstractAutowireCapableBeanFactory#createBean是创建bean的主要入口方法，但仍然不是最主要在“干活”的方法。继续向下看<code>doCreateBean</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="comment">// 尝试从factoryBean缓存中获取。</span></span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建bean实例。</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Spring为了解决单例bean的循环引用问题，会在bean还没有完全初始化完毕前通过添加singletonFactory</span></span><br><span class="line"><span class="comment">     * 使得其它bean可以拿到某个bean的实例引用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下去初始化bean。</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 填充bean中的属性。</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 调用初始化方法,比如:</span></span><br><span class="line"><span class="comment">             * 1. 各种aware回调</span></span><br><span class="line"><span class="comment">             * 2. 调用BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment">             * 3. 调用InitializingBean#afterPropertiesSet, xml中的init-method</span></span><br><span class="line"><span class="comment">             * 4. 调用BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 上面的getSingleton第二个参数为false表示不会主动触发early reference的创建。</span></span><br><span class="line"><span class="comment">         * 所以此处earlySingletonReference只有在bean创建过程中发现有别的bean与当前bean有循环依赖才不为空。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果当前bean调用initializeBean没有增强原始bean实例,则取earlySingletonReference。</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 举例:</span></span><br><span class="line"><span class="comment">             * BeanA与BeanB互相依赖。Srping先创建BeanA,再创建BeanB。</span></span><br><span class="line"><span class="comment">             * BeanA通过addSingletonFactory暴露了获取BeanA引用的途径。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 在populateBean的时候需要注入BeanB,而BeanB又需要注入BeanA,</span></span><br><span class="line"><span class="comment">             * 则在获取BeanA时会调用原先BeanA暴露的ObjectFactory,继而使得earlySingletonObjects中加入了BeanA引用。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 回到BeanA的创建过程，走到此步时，发现initializeBean没有增强原始bean实例,</span></span><br><span class="line"><span class="comment">             * 则需要取其它循环依赖bean拿BeanA时在registry留下的结果(原始bean经过SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference回调)。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 获取当前bean依赖的其它bean。</span></span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                <span class="comment">// 过滤筛选出真正依赖的bean。</span></span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 举例:</span></span><br><span class="line"><span class="comment">                 * BeanA与BeanB互相依赖。Srping先创建BeanA,再创建BeanB。</span></span><br><span class="line"><span class="comment">                 * BeanA的创建走到这里时会抛出异常。</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 原因是上面的exposedObject != bean说明initializeBean方法的调用增强了原始的BeanA。</span></span><br><span class="line"><span class="comment">                 * 而BeanB中注入的BeanA很可能是原始beanA(可能会有SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference回调,</span></span><br><span class="line"><span class="comment">                 * 也就是BeanB中注入的BeanA不是此处BeanA的最终版exposedObject。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-Bean的循环依赖是如何解决的"><a href="#5-3-Bean的循环依赖是如何解决的" class="headerlink" title="5.3 Bean的循环依赖是如何解决的"></a><strong>5.3 Bean的循环依赖是如何解决的</strong></h3><p>不是所有的循环依赖Spring都能够解决的。</p>
<ul>
<li>对于最简单的情况，bean为单例,且使用Autowired或者setter注入，Spring是可以解决这样的循环依赖的。通过上面的代码中我们可以看出，在一个Bean实例化后,会调用addSingletonFactory方法，在IOC容器中通过一个ObjectFactory暴露出可以获取还未完全初始化完毕的bean引用。若存在循环依赖，则依赖的bean可以在调用getBean时通过getSingleton方法获取到循环依赖的bean。</li>
<li>但是Spring是不允许出现原型环的，举例来说,BeanA和BeanB循环依赖且scope都为prototype。因为prototype的bean，不会触发addSingletonFactory，即每次get这样的bean都会新创建一个。所以创建BeanA需要注入一个BeanB，而这个BeanB又需要注入一个新的BeanA，这样的循环依赖是没办法解决的。Spring会判断当前bean是否是prototype并且已经在创建中，然后抛出异常。</li>
<li>对于构造器依赖，可以作一下讨论，下面讨论的bean的scope都为单例<ul>
<li>如果BeanA构造器中依赖BeanB，并且BeanA先创建，则无论BeanB以哪种形式依赖BeanA，都没办法解决这样的循环依赖。因为实例化BeanA需要先得到BeanB（此时还未提前暴露引用），BeanB依赖BeanA，但是拿不到BeanA提前暴露的引用，这就形成了无限循环。这种情况会在BeanB试图获取BeanA时在beforeSingletonCreation方法抛出异常。</li>
<li>如果BeanA非构造器依赖BeanB，并且BeanA先创建，BeanB即使构造器依赖BeanA，也可以进行解决循环依赖。 因为这种情况BeanB可以拿到BeanA提前暴露的引用。</li>
</ul>
</li>
</ul>
<h3 id="5-4-Aware究竟是什么"><a href="#5-4-Aware究竟是什么" class="headerlink" title="5.4 Aware究竟是什么"></a><strong>5.4 Aware究竟是什么</strong></h3><p>Spring中有很多XXXAware接口，从字面意思上很容易理解：就是bean能够“感知”XXX。通常这些接口的方法都是setXXX。在项目里做一个工具类实现ApplicationContextAware接口，里面可以塞一个ApplicationContext实例到静态域中，在代码中就可以很方便获取到Spring上下文进行一些操作。</p>
<p>那么Spring对于这些Aware接口是在哪一步调用的呢？答案其实在上面的源码分析中已经提到。在AbstractAutowireCapableBeanFactory#initializeBean方法中，Spring默认会对实现BeanNameAware, BeanClassLoaderAware, BeanFactoryAware进行回调，为它们注入beanName, classLoader, beanFactory等。</p>
<p>而对于更多的一些扩展，Spring基于那些processor实现了很强的可拓展性与可插拔性。比如我们非常熟悉的ApplicationContextAware接口实际上是通过ApplicationContextAwareProcessor来实际调用的，它继承了BeanPostProcessor，其中postProcessBeforeInitialization方法中会对EnvironmentAware, EmbeddedValueResolverAware, ApplicationContextAware等等一系列Aware接口的子类Bean进行回调，为其注入相关资源。</p>
<p>那么ApplicationContextAwareProcessor是什么时候出现在BeanPostProcessor集合中的呢？在AbstractApplicationContext#prepareBeanFactory方法中，Spring有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p>也就是当Spring上下文在初始化prepareBeanFactory的时候就已经添加了ApplicationContextAwareProcessor。</p>
<hr>
<p>参考：</p>
<p>🔗 《Spring 实战》<br>🔗 <a href="https://www.awaimai.com/2596.html" title="Title" target="_blank" rel="noopener">spring bean是什么</a><br>🔗 <a href="https://www.zhihu.com/question/38597960" title="Title" target="_blank" rel="noopener">Spring中Bean的生命周期是怎样的？</a><br>🔗 <a href="https://www.cnblogs.com/micrari/p/7354650.html" target="_blank" rel="noopener">Spring IOC容器创建bean过程浅析</a><br>🔗 <a href="https://zhuanlan.zhihu.com/p/50153734" target="_blank" rel="noopener">Spring BeanDefinition 与 IoC 容器启动过程</a></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    林沂水
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://linyishui.top/2020021001.html" title="Spring Bean">http://linyishui.top/2020021001.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    
      <div>
         ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/spring/" rel="tag"># spring</a>
          
            <a href="/tags/bean/" rel="tag"># bean</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020020701.html" rel="next" title="gitlab-ci.yml语法">
                <i class="fa fa-chevron-left"></i> gitlab-ci.yml语法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020021101.html" rel="prev" title="面试整理——其它">
                面试整理——其它 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div class="comments" id="comments">
       

<script src="https://utteranc.es/client.js" repo="LAILAIWA/LAILAIWA.github.io" issue-term="pathname" label="💬Comments" theme="github-light" crossorigin="anonymous" async>
</script>



     </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg" alt="林沂水">
            
              <p class="site-author-name" itemprop="name">林沂水</p>
              <p class="site-description motion-element" itemprop="description">记录编程点滴，写点生活中的酸甜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">293</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LAILAIWA" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:linyishui168@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/linyishui618" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/linyishui618" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5340162234" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo.com"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="days"></div>
<script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("07/26/2018 00:00:00");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
    secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
    e_daysold=timeold/msPerDay
    daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i) {
    if (i<10) {
        i="0" + i
    };
    return i;
}
show_date_time();
</script>  
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Bean"><span class="nav-number">1.</span> <span class="nav-text">Spring Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节-概述"><span class="nav-number">1.1.</span> <span class="nav-text">第一节 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Spring-Bean是什么？"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 Spring Bean是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-概念"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-BeanFactory和ApplicationContext"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 BeanFactory和ApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-BeanFactory"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1.3.1 BeanFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-ApplicationContext"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">1.3.2 ApplicationContext</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节-生命周期"><span class="nav-number">1.2.</span> <span class="nav-text">第二节 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-实例化Bean"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 实例化Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-依赖注入"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 依赖注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-BeanNameAware"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 BeanNameAware</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-BeanFactoryAware"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 BeanFactoryAware</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-ApplicationContextAware"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 ApplicationContextAware</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-BeanPostProcessor"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 BeanPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-InitializingBean与init-method"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 InitializingBean与init-method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-DisposableBean和destroy-method"><span class="nav-number">1.2.8.</span> <span class="nav-text">2.8 DisposableBean和destroy-method</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节-装配Bean"><span class="nav-number">1.3.</span> <span class="nav-text">第三节 装配Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Spring配置的可选方案"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 Spring配置的可选方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-自动化装配bean"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 自动化装配bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-创建可被发现的bean"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1 创建可被发现的bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-为组件扫描的bean命名"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">3.2.2 为组件扫描的bean命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-设置组件扫描的基础包"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3.2.3 设置组件扫描的基础包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-通过为bean添加注解实现自动装配"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">3.2.4 通过为bean添加注解实现自动装配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-验证自动装配"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">3.2.5 验证自动装配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-通过Java代码装配bean"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 通过Java代码装配bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-创建配置类"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1 创建配置类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-声明简单的bean"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2 声明简单的bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-借助JavaConfig实现注入"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.3.3 借助JavaConfig实现注入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-通过XML装配bean"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 通过XML装配bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-创建XML配置规范"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">3.4.1 创建XML配置规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-声明一个简单的-lt-bean-gt"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">3.4.2 声明一个简单的 &lt;bean&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-借助构造器注入初始化bean"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3.4.3 借助构造器注入初始化bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-设置属性"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">3.4.4 设置属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-导入和混合配置"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 导入和混合配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-在JavaConfig中引用XML配置"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">3.5.1 在JavaConfig中引用XML配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-在XML配置中引用JavaConfig"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">3.5.2 在XML配置中引用JavaConfig</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四节-高级装配"><span class="nav-number">1.4.</span> <span class="nav-text">第四节 高级装配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-环境与profile"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 环境与profile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-配置profile-bean"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1 配置profile bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-激活profile"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">4.1.2 激活profile</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-条件化的bean"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 条件化的bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-处理自动装配的歧义性"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 处理自动装配的歧义性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-标示首选的bean"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">4.3.1 标示首选的bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-限定自动装配的bean"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">4.3.2 限定自动装配的bean</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）创建自定义的限定符"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">（1）创建自定义的限定符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）使用自定义的限定符注解"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">（2）使用自定义的限定符注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-bean的作用域"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 bean的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-使用会话和请求作用域"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">4.4.1 使用会话和请求作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-在XML中声明作用域代理"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">4.4.2 在XML中声明作用域代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-运行时值注入"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 运行时值注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-注入外部的值"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">4.5.1 注入外部的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-使用Spring表达式语言进行装配"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">4.5.2 使用Spring表达式语言进行装配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）SpEL样例"><span class="nav-number">1.4.5.2.1.</span> <span class="nav-text">（1）SpEL样例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）SpEL所支持的基础表达式"><span class="nav-number">1.4.5.2.2.</span> <span class="nav-text">（2）SpEL所支持的基础表达式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四节-源码解析"><span class="nav-number">1.5.</span> <span class="nav-text">第四节 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Bean"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1 Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BeanDefinition"><span class="nav-number">1.5.2.</span> <span class="nav-text">4.2 BeanDefinition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-Resource定位"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">4.2.1 Resource定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-BeanDefinition的载入过程"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">4.2.2 BeanDefinition的载入过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-BeanDefinition的注册"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">4.2.3 BeanDefinition的注册</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BeanFactory"><span class="nav-number">1.5.3.</span> <span class="nav-text">4.3 BeanFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-ApplicationContext"><span class="nav-number">1.5.4.</span> <span class="nav-text">4.4 ApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-FactoryBean"><span class="nav-number">1.5.5.</span> <span class="nav-text">4.5 FactoryBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-DefaultListableBeanFactory"><span class="nav-number">1.5.6.</span> <span class="nav-text">4.6 DefaultListableBeanFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-FileSystemXmlApplicationContext"><span class="nav-number">1.5.7.</span> <span class="nav-text">4.7 FileSystemXmlApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-refresh"><span class="nav-number">1.5.8.</span> <span class="nav-text">4.8 refresh()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-1-refresh"><span class="nav-number">1.5.8.1.</span> <span class="nav-text">4.8.1 refresh()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-2-prepareRefresh"><span class="nav-number">1.5.8.2.</span> <span class="nav-text">4.8.2 prepareRefresh()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-3-obtainFreshBeanFactory"><span class="nav-number">1.5.8.3.</span> <span class="nav-text">4.8.3 obtainFreshBeanFactory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-prepareBeanFactory"><span class="nav-number">1.5.8.4.</span> <span class="nav-text">4.8.4 prepareBeanFactory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-prepareBeanFactory-1"><span class="nav-number">1.5.8.5.</span> <span class="nav-text">4.8.4 prepareBeanFactory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-prepareBeanFactory-2"><span class="nav-number">1.5.8.6.</span> <span class="nav-text">4.8.4 prepareBeanFactory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-prepareBeanFactory-3"><span class="nav-number">1.5.8.7.</span> <span class="nav-text">4.8.4 prepareBeanFactory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-prepareBeanFactory-4"><span class="nav-number">1.5.8.8.</span> <span class="nav-text">4.8.4 prepareBeanFactory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-prepareBeanFactory-5"><span class="nav-number">1.5.8.9.</span> <span class="nav-text">4.8.4 prepareBeanFactory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-prepareBeanFactory-6"><span class="nav-number">1.5.8.10.</span> <span class="nav-text">4.8.4 prepareBeanFactory()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五节-Bean的创建过程"><span class="nav-number">1.6.</span> <span class="nav-text">第五节 Bean的创建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-过程"><span class="nav-number">1.6.1.</span> <span class="nav-text">5.1 过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-IoC容器依赖注入"><span class="nav-number">1.6.2.</span> <span class="nav-text">5.2 IoC容器依赖注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Bean的循环依赖是如何解决的"><span class="nav-number">1.6.3.</span> <span class="nav-text">5.3 Bean的循环依赖是如何解决的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Aware究竟是什么"><span class="nav-number">1.6.4.</span> <span class="nav-text">5.4 Aware究竟是什么</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林沂水</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
   

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
