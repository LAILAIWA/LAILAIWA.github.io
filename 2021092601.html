<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理Spring AMQP相关文档。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring AMQP">
<meta property="og:url" content="http://linyishui.top/2021092601.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理Spring AMQP相关文档。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-amqp/2.1.2.RELEASE/cacheStats.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010120.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010121.png">
<meta property="og:image" content="https://res-static.hc-cdn.cn/fms/img/e30c505f6dfcc7704eb104d6169c202c1612517532882">
<meta property="og:image" content="https://res-static.hc-cdn.cn/fms/img/7f0590fab310e55f8ae8dc0d28d7fd161612517532882">
<meta property="og:image" content="https://res-static.hc-cdn.cn/fms/img/1cea2b3e1b552149cc102993db8107b01612517532884">
<meta property="og:image" content="https://res-static.hc-cdn.cn/fms/img/58afc4c9952d12a7f18af4c48a0530d61612517532884">
<meta property="og:image" content="https://res-static.hc-cdn.cn/fms/img/13fe637438a9c721adc6711b97ec6e821612517532885">
<meta property="og:image" content="https://res-static.hc-cdn.cn/fms/img/900030467c62c0b1f34878b69da926141612517532885">
<meta property="og:image" content="https://res-static.hc-cdn.cn/fms/img/22d4831ca9b00a68417829fadee786621612517532886">
<meta property="og:image" content="https://res-static.hc-cdn.cn/fms/img/57ad7c2ab6ba47794d532f6fca2a51201612517532886">
<meta property="article:published_time" content="2021-09-26T06:22:55.000Z">
<meta property="article:modified_time" content="2021-11-04T11:49:16.000Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="distributed">
<meta property="article:tag" content="mom">
<meta property="article:tag" content="rabbitmq">
<meta property="article:tag" content="amqp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.docs4dev.com/images/spring-amqp/2.1.2.RELEASE/cacheStats.png">


<link rel="canonical" href="http://linyishui.top/2021092601.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2021092601.html","path":"2021092601.html","title":"Spring AMQP"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring AMQP | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-AMQP"><span class="nav-text">Spring AMQP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E7%AE%80%E4%BB%8B"><span class="nav-text">一. 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFSpring-AMQP"><span class="nav-text">1.1 什么是Spring AMQP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-text">1.2 简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Maven%E4%BE%9D%E8%B5%96"><span class="nav-text">（1）Maven依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="nav-text">（2）快速上手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89XML%E9%85%8D%E7%BD%AE"><span class="nav-text">（3）XML配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Java%E9%85%8D%E7%BD%AE"><span class="nav-text">（4）Java配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8"><span class="nav-text">二. 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-ConnectionFactory%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE"><span class="nav-text">2.1 ConnectionFactory默认配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-com-rabbitmq-client-ConnectionFactory%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE"><span class="nav-text">2.2 com.rabbitmq.client.ConnectionFactory自定义配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-AmqpTemplate%E9%85%8D%E7%BD%AE"><span class="nav-text">2.3 AmqpTemplate配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-RabbitListenerContainerFactory%E9%85%8D%E7%BD%AE"><span class="nav-text">2.4 RabbitListenerContainerFactory配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-text">2.5 发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-text">2.6 接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8B%89%E6%A8%A1%E5%BC%8F"><span class="nav-text">（1）拉模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8E%A8%E6%A8%A1%E5%BC%8F"><span class="nav-text">（2）推模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-MessageConverter"><span class="nav-text">2.7 MessageConverter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">2.8 异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-%E4%BA%8B%E5%8A%A1"><span class="nav-text">2.9 事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-Listeners"><span class="nav-text">2.10 Listeners</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-%E5%A4%9A%E4%B8%AA-RabbitListener%E6%B6%88%E8%B4%B9%E4%B8%80%E4%B8%AAqueue"><span class="nav-text">2.11 多个@RabbitListener消费一个queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6confirm-and-return"><span class="nav-text">2.12 生产者消息确认机制confirm and return</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-13-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="nav-text">2.13 重试机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-14-%E5%8F%91%E9%80%81%E7%AB%AF%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="nav-text">2.14 发送端的消息丢失</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84Connection%E4%B8%AD%E6%96%AD"><span class="nav-text">（1）可恢复的Connection中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%95%BF%E6%97%B6%E9%97%B4%E6%97%A0%E6%B3%95%E6%81%A2%E5%A4%8D%E7%9A%84Connection%E4%B8%AD%E6%96%AD"><span class="nav-text">（2）长时间无法恢复的Connection中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-15-%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E6%B6%88%E6%81%AF%E5%8E%BB%E9%87%8D"><span class="nav-text">2.15 消费端的消息去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-16-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84Connection"><span class="nav-text">2.16 消息发送和接收使用不同的Connection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-17-%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F"><span class="nav-text">2.17 消息过期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-18-Dead-letter-exchange"><span class="nav-text">2.18 Dead letter exchange</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%8E%9F%E7%90%86"><span class="nav-text">三. 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%9E%B6%E6%9E%84"><span class="nav-text">3.1 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="nav-text">3.2 核心类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Message"><span class="nav-text">（1）Message</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Exchange"><span class="nav-text">（2）Exchange</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Queue"><span class="nav-text">（3）Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Binding"><span class="nav-text">（4）Binding</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%B5%84%E6%BA%90Management"><span class="nav-text">3.3 连接和资源Management</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89ConnectionFactory-%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82%E7%B1%BB"><span class="nav-text">（1）ConnectionFactory-连接工厂类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89ConnectionNameStrategy-%E8%BF%9E%E6%8E%A5%E5%91%BD%E5%90%8D"><span class="nav-text">（2）ConnectionNameStrategy-连接命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%98%BB%E6%AD%A2%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-text">（3）阻止的连接和资源限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%A1%80-Client-%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82"><span class="nav-text">（4）配置基础 Client 端连接工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89RabbitConnectionFactoryBean-%E5%92%8C%E9%85%8D%E7%BD%AE-SSL"><span class="nav-text">（5）RabbitConnectionFactoryBean 和配置 SSL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E8%B7%AF%E7%94%B1%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82"><span class="nav-text">（6）路由连接工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E9%98%9F%E5%88%97%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%92%8CLocalizedQueueConnectionFactory"><span class="nav-text">（7）队列相似性和LocalizedQueueConnectionFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E5%8F%91%E5%B8%83%E8%80%85%E7%A1%AE%E8%AE%A4%E5%B9%B6return"><span class="nav-text">（8）发布者确认并return</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89%E8%BF%9E%E6%8E%A5%E5%92%8C-Channels-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">（9）连接和 Channels 监听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89%E8%AE%B0%E5%BD%95-Channels-%E5%85%B3%E9%97%AD%E4%BA%8B%E4%BB%B6"><span class="nav-text">（10）记录 Channels 关闭事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BC%93%E5%AD%98%E5%B1%9E%E6%80%A7"><span class="nav-text">（11）运行时缓存属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8812%EF%BC%89RabbitMQ-%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5-%E6%8B%93%E6%89%91%E6%81%A2%E5%A4%8D"><span class="nav-text">（12）RabbitMQ 自动连接&#x2F;拓扑恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89-Client-%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="nav-text">3.4 添加自定义 Client 端连接属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-AmqpTemplate"><span class="nav-text">3.5 AmqpTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%B7%BB%E5%8A%A0%E9%87%8D%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="nav-text">（1）添加重试功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8F%91%E5%B8%83%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%88%90%E5%8A%9F%E5%92%8C%E5%A4%B1%E8%B4%A5"><span class="nav-text">（2）发布是异步的-如何检测成功和失败</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8F%91%E5%B8%83%E8%80%85%E7%A1%AE%E8%AE%A4%E5%B9%B6return"><span class="nav-text">（3）发布者确认并return</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Scoped-Operations"><span class="nav-text">（4）Scoped Operations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89Messaging-integration"><span class="nav-text">（5）Messaging integration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E5%B7%B2%E9%AA%8C%E8%AF%81%E7%9A%84%E7%94%A8%E6%88%B7ID"><span class="nav-text">（6）已验证的用户ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E4%BD%BF%E7%94%A8%E5%8D%95%E7%8B%AC%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-text">（7）使用单独的连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-text">3.6 发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Message-Builder"><span class="nav-text">（1）Message Builder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Publisher-Returns"><span class="nav-text">（2）Publisher Returns</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Batching"><span class="nav-text">（3）Batching</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-text">3.7 接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Polling-Consumer"><span class="nav-text">（1）Polling Consumer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Asynchronous-Consumer"><span class="nav-text">（2）Asynchronous Consumer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Message-Listener"><span class="nav-text">（3）Message Listener</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89MessageListenerAdapter"><span class="nav-text">（4）MessageListenerAdapter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89Container"><span class="nav-text">（5）Container</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89Consumer-Priority"><span class="nav-text">（6）Consumer Priority</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89auto-delete-Queues"><span class="nav-text">（7）auto-delete Queues</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89Batched-Messages"><span class="nav-text">（8）Batched Messages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89Consumer-Events"><span class="nav-text">（9）Consumer Events</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89Consumer-Tags"><span class="nav-text">（10）Consumer Tags</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8%E7%AB%AF%E7%82%B9"><span class="nav-text">（11）注解驱动的监听器端点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-text">四. 源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-RabbitMQ%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B"><span class="nav-text">4.1 RabbitMQ消费流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">（1）启动流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B"><span class="nav-text">（2）消费流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89ack%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F"><span class="nav-text">（3）ack消费模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-RabbitTemplate"><span class="nav-text">4.2 RabbitTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-text">（1）接收消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-RabbitListener%E6%B3%A8%E8%A7%A3"><span class="nav-text">4.3 @RabbitListener注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-SimpleMessageListenerContainer"><span class="nav-text">4.5 SimpleMessageListenerContainer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0"><span class="nav-text">（1）概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">（2）基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-text">（3）核心原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AbstractMessageListenerContainer-start"><span class="nav-text">AbstractMessageListenerContainer#start</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SimpleMessageListenerContainer-doStart"><span class="nav-text">SimpleMessageListenerContainer#doStart</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncMessageProcessingConsumer-run"><span class="nav-text">AsyncMessageProcessingConsumer#run</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BlockingQueueConsumer-start"><span class="nav-text">BlockingQueueConsumer#start</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageListenerContainer%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">MessageListenerContainer的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SimpleMessageListenerContainer%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">SimpleMessageListenerContainer接收消息的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageListener%E8%B0%83%E7%94%A8-RabbitListener%E6%B3%A8%E8%A7%A3%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">MessageListener调用@RabbitListener注解方法处理消息的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-CachingConnectionFactory"><span class="nav-text">4.2 CachingConnectionFactory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%A1%88%E4%BE%8B"><span class="nav-text">五. 案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E"><span class="nav-text">5.1 自动重连</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">5.2 解决消息幂等性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-RabbitMQ%E8%87%AA%E5%8A%A8%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="nav-text">5.2.1 RabbitMQ自动重试机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%80%89%E6%8B%A9%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">5.2.2 如何合理选择重试机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6"><span class="nav-text">5.2.3 调用第三方接口自动实现补偿机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E8%B4%B9%E8%80%85%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%8C%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="nav-text">5.2.4 如何解决消费者幂等性问题，防止重复消费</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5-SpringBoot%E6%95%B4%E5%90%88RabbitMQ%E5%BA%94%E7%AD%94%E6%A8%A1%E5%BC%8F-ACK"><span class="nav-text">5.2.5 SpringBoot整合RabbitMQ应答模式(ACK)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E9%99%90%E6%B5%81"><span class="nav-text">5.3 限流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="nav-text">（1）通过配置文件实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89-RabbitListener"><span class="nav-text">（2）@RabbitListener</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2021092601.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring AMQP
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-26 14:22:55" itemprop="dateCreated datePublished" datetime="2021-09-26T14:22:55+08:00">2021-09-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-04 19:49:16" itemprop="dateModified" datetime="2021-11-04T19:49:16+08:00">2021-11-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">技术文档</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>143k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:10</span>
    </span>
</div>

            <div class="post-description">整理Spring AMQP相关文档。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><h3 id="1-1-什么是Spring-AMQP"><a href="#1-1-什么是Spring-AMQP" class="headerlink" title="1.1 什么是Spring AMQP"></a>1.1 什么是Spring AMQP</h3><p>Advanced Message Queuing Protocol，即高级消息队列协议，旨在提供一种跨平台跨语言的消息服务，AMQP是一种应用层协议，不同于JMS(API接口)，使用 TCP 提供可靠投递的应用层协议。</p>
<p>Spring AMQP则是Spring方便开发RabbitMQ程序集成的一个第三方类库。</p>
<ul>
<li>提供“模板”作为用于发送和接收消息的高级抽象。</li>
<li>还为消息驱动的 POJO 提供支持。</li>
</ul>
<h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a>1.2 简单使用</h3><h4 id="（1）Maven依赖"><a href="#（1）Maven依赖" class="headerlink" title="（1）Maven依赖"></a>（1）Maven依赖</h4><p>引入Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>此包同时包含：</p>
<ul>
<li>spring-context</li>
<li>spring-tx</li>
<li>spring-web</li>
<li>spring-messaging</li>
<li>spring-retry</li>
<li>spring-amqp</li>
<li>amqp-client</li>
</ul>
<h4 id="（2）快速上手"><a href="#（2）快速上手" class="headerlink" title="（2）快速上手"></a>（2）快速上手</h4><p>基于默认配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">AmqpAdmin admin = <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span><br><span class="line">admin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;myqueue&quot;</span>));</span><br><span class="line">AmqpTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">template.convertAndSend(<span class="string">&quot;myqueue&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">String foo = (String) template.receiveAndConvert(<span class="string">&quot;myqueue&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="（3）XML配置"><a href="#（3）XML配置" class="headerlink" title="（3）XML配置"></a>（3）XML配置</h4><p>基于XML配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> GenericXmlApplicationContext(<span class="string">&quot;classpath:/rabbit-context.xml&quot;</span>);</span><br><span class="line">AmqpTemplate template = context.getBean(AmqpTemplate.class);</span><br><span class="line">template.convertAndSend(<span class="string">&quot;myqueue&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">String foo = (String) template.receiveAndConvert(<span class="string">&quot;myqueue&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/rabbit/spring-rabbit.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;amqpTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;myqueue&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="（4）Java配置"><a href="#（4）Java配置" class="headerlink" title="（4）Java配置"></a>（4）Java配置</h4><p>同样的示例使用 Java 中的外部配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(RabbitConfiguration.class);</span><br><span class="line">	AmqpTemplate template = context.getBean(AmqpTemplate.class);</span><br><span class="line">	template.convertAndSend(<span class="string">&quot;myqueue&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">	String foo = (String) template.receiveAndConvert(<span class="string">&quot;myqueue&quot;</span>);</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CachingConnectionFactory(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AmqpAdmin <span class="title">amqpAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitAdmin(connectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">myQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;myqueue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二-使用"><a href="#二-使用" class="headerlink" title="二. 使用"></a>二. 使用</h2><h3 id="2-1-ConnectionFactory默认配置"><a href="#2-1-ConnectionFactory默认配置" class="headerlink" title="2.1 ConnectionFactory默认配置"></a>2.1 ConnectionFactory默认配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqProducerConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">amqpConnectionFactory</span><span class="params">(ConnectionListener connectionListener,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  RecoveryListener recoveryListener,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  ChannelListener channelListener)</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        <span class="comment">// 配置rabbitmq的地址、端口，集群部署的情况下可填写多个，“,”分隔</span></span><br><span class="line">        connectionFactory.setAddresses(<span class="string">&quot;localhost:5672&quot;</span>);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">		<span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">		<span class="comment">// 虚拟主机</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置缓存模式，共有两种，CHANNEL和CONNECTION模式</span></span><br><span class="line">        connectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CHANNEL);</span><br><span class="line">		<span class="comment">// 设置每个Connection中可以缓存的Channel的数量，非数量上限，获取Channel前会先尝试从缓存中找到一个闲置的，若无则会创建新的，当数量超过缓存数量时，多出来的会被关闭。该值修改只会影响后创建的Connection</span></span><br><span class="line">        connectionFactory.setChannelCacheSize(<span class="number">25</span>);</span><br><span class="line">        <span class="comment">// 设置Channel等待时间，大于0时setChannelCacheSize会同时变为数量上限，从缓存取不到可用的Channel时不会创建新的，而是等待该值指定的毫秒时间，若到点仍无可用的Channel会抛出AmqpTimeoutException异常；Connection模式下，该值也同样是Connection的获取超时时间</span></span><br><span class="line">        connectionFactory.setChannelCheckoutTimeout(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Producer端消息确认机制开关，return机制</span></span><br><span class="line">        connectionFactory.setPublisherReturns(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// Producer端消息确认机制开关，confirm机制</span></span><br><span class="line">        connectionFactory.setPublisherConfirms(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 配置ConnectionListener</span></span><br><span class="line">        connectionFactory.addConnectionListener(connectionListener);</span><br><span class="line">        <span class="comment">// 配置ChannelListener</span></span><br><span class="line">        connectionFactory.addChannelListener(channelListener);</span><br><span class="line">        <span class="comment">// 配置RecoveryListener</span></span><br><span class="line">        connectionFactory.setRecoveryListener(recoveryListener);</span><br><span class="line">        <span class="comment">// 仅在Connection模式下使用，设置Connection的缓存数量</span></span><br><span class="line">        <span class="comment">//connectionFactory.setConnectionCacheSize(1);</span></span><br><span class="line">        <span class="comment">// 仅在Connection模式下使用，设置Connection的数量上限</span></span><br><span class="line">        <span class="comment">//connectionFactory.setConnectionLimit(Integer.MAX_VALUE);</span></span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Channel模式：</strong>程序运行期间ConnectionFactory会维护一个Connection，所有的操作都使用此Connection，但一个Connection中可以有多个Channel，操作rabbitmq之前都必须先获取到一个Channel，否则就会阻塞（可以通过 <code>setChannelCheckoutTimeout()</code> 设置等待时间），这些Channel会被缓存（缓存的数量可以通过 <code>setChannelCacheSize()</code> 设置）；</li>
<li><strong>Connection模式：</strong>这个模式下允许创建多个Connection，会缓存一定数量的Connection，每个Connection中同样会缓存一些Channel，除了可以有多个Connection，其它都跟CHANNEL模式一样。</li>
</ul>
<h3 id="2-2-com-rabbitmq-client-ConnectionFactory自定义配置"><a href="#2-2-com-rabbitmq-client-ConnectionFactory自定义配置" class="headerlink" title="2.2 com.rabbitmq.client.ConnectionFactory自定义配置"></a>2.2 com.rabbitmq.client.ConnectionFactory自定义配置</h3><p>ConnectionFactory类连接MQ节点的Connection配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Default user name */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_USER = <span class="string">&quot;guest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default password */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PASS = <span class="string">&quot;guest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default virtual host */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_VHOST = <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default maximum channel number;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*  zero for unlimited */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_CHANNEL_MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default maximum frame size;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*  zero means no limit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_FRAME_MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default heart-beat interval;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*  60 seconds */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_HEARTBEAT = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default host */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_HOST = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** &#x27;Use the default port&#x27; port */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    USE_DEFAULT_PORT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default non-ssl port */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_AMQP_PORT = AMQP.PROTOCOL.PORT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default ssl port */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_AMQP_OVER_SSL_PORT = <span class="number">5671</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default TCP connection timeout: 60 seconds */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_CONNECTION_TIMEOUT = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* The default AMQP 0-9-1 connection handshake timeout. See DEFAULT_CONNECTION_TIMEOUT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* for TCP (socket) connection timeout.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_HANDSHAKE_TIMEOUT = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default shutdown timeout;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*  zero means wait indefinitely */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_SHUTDOWN_TIMEOUT = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default continuation timeout for RPC calls in channels: 10 minutes */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_CHANNEL_RPC_TIMEOUT = (<span class="keyword">int</span>) MINUTES.toMillis(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default network recovery interval: 5000 millis */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>  DEFAULT_NETWORK_RECOVERY_INTERVAL = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFERRED_TLS_PROTOCOL = <span class="string">&quot;TLSv1.2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FALLBACK_TLS_PROTOCOL = <span class="string">&quot;TLSv1&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>修改默认连接配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">(com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory)</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(rabbitConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> com.rabbitmq.client.<span class="function">ConnectionFactory <span class="title">rabbitConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    com.rabbitmq.client.ConnectionFactory connectionFactory = <span class="keyword">new</span> com.rabbitmq.client.ConnectionFactory();</span><br><span class="line">    connectionFactory.setAutomaticRecoveryEnabled(<span class="keyword">false</span>);</span><br><span class="line">    connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">    connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">    connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-AmqpTemplate配置"><a href="#2-3-AmqpTemplate配置" class="headerlink" title="2.3 AmqpTemplate配置"></a>2.3 AmqpTemplate配置</h3><p>若消费者端通过 <code>@RabbitListener</code> 注解的方式接收消息，则用不到此Bean。不建议直接使用ConnectionFactory获取Channel操作MQ，而是使用AmqpTemplate。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpTemplate <span class="title">amqpTemplate</span><span class="params">(ConnectionFactory amqpConnectionFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                RabbitTemplate.ReturnCallback returnCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                RabbitTemplate.ConfirmCallback confirmCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                RetryTemplate retryTemplate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                MessageConverter messageConverter)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">    <span class="comment">// 设置spring-amqp的ConnectionFactory</span></span><br><span class="line">    rabbitTemplate.setConnectionFactory(amqpConnectionFactory);</span><br><span class="line">    <span class="comment">// 设置重试机制</span></span><br><span class="line">    rabbitTemplate.setRetryTemplate(retryTemplate);</span><br><span class="line">    <span class="comment">// 设置MessageConverter，用于java对象与Message对象（实际发送和接收的消息对象）之间的相互转换</span></span><br><span class="line">    rabbitTemplate.setMessageConverter(messageConverter);</span><br><span class="line">    <span class="comment">// 打开或关闭Channel的事务</span></span><br><span class="line">    rabbitTemplate.setChannelTransacted(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// return机制的回调接口</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">    <span class="comment">// confirm机制的回调接口</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">    <span class="comment">// 设为true使ReturnCallback生效</span></span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-RabbitListenerContainerFactory配置"><a href="#2-4-RabbitListenerContainerFactory配置" class="headerlink" title="2.4 RabbitListenerContainerFactory配置"></a>2.4 RabbitListenerContainerFactory配置</h3><p>这个bean仅在消费者端通过 <code>@RabbitListener</code> 注解的方式接收消息时使用，每一个 <code>@RabbitListener</code> 注解的方法都会由这个RabbitListenerContainerFactory创建一个MessageListenerContainer，负责接收消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">(CachingConnectionFactory cachingConnectionFactory, ErrorHandler errorHandler, MessageConverter messageConverter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line"><span class="comment">// 设置spring-amqp的ConnectionFactory</span></span><br><span class="line">      factory.setConnectionFactory(cachingConnectionFactory);</span><br><span class="line"><span class="comment">// 对于消费者端，MessageConverter也可以在这里配置</span></span><br><span class="line">      factory.setMessageConverter(messageConverter);</span><br><span class="line"><span class="comment">// 设置消费者端的应答模式，共有三种：NONE、AUTO、MANUAL</span></span><br><span class="line">      factory.setAcknowledgeMode(AcknowledgeMode.AUTO);</span><br><span class="line"><span class="comment">// 设置每个MessageListenerContainer将会创建的Consumer的最小数量，默认是1个</span></span><br><span class="line">      factory.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置每个MessageListenerContainer将会创建的Consumer的最大数量，默认等于最小数量</span></span><br><span class="line">      factory.setMaxConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置每次请求发送给每个Consumer的消息数量</span></span><br><span class="line">      factory.setPrefetchCount(<span class="number">250</span>);</span><br><span class="line"><span class="comment">// 设置Channel的事务</span></span><br><span class="line">      factory.setChannelTransacted(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 设置事务当中可以处理的消息数量</span></span><br><span class="line">      factory.setTxSize(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置当rabbitmq收到nack/reject确认信息时的处理方式，设为true，扔回queue头部，设为false，丢弃</span></span><br><span class="line">      factory.setDefaultRequeueRejected(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 实现ErrorHandler接口设置进去，所有未catch的异常都会由ErrorHandler处理</span></span><br><span class="line">      factory.setErrorHandler(errorHandler);</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>消费者端的应答模式：</p>
<ul>
<li><strong>NONE：</strong>无应答，这种模式下rabbitmq默认consumer能正确处理所有发出的消息，所以不管消息有没有被consumer收到，有没有正确处理都不会恢复。</li>
<li><strong>AUTO：</strong>由Container自动应答，正确处理发出ack信息，处理失败发出nack信息，rabbitmq发出消息后将会等待consumer端的应答，只有收到ack确认信息才会把消息清除掉，收到nack信息的处理办法由setDefaultRequeueRejected()方法设置，所以在这种模式下，发生错误的消息是可以恢复的。</li>
<li><strong>MANUAL：</strong>基本同AUTO模式，区别是需要人为调用方法给应答。</li>
</ul>
<h3 id="2-5-发送消息"><a href="#2-5-发送消息" class="headerlink" title="2.5 发送消息"></a>2.5 发送消息</h3><p>AmqpTamplate的发送消息接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure>



<p>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amqpTemplate.send(exchange, routingKey, <span class="keyword">new</span> Message(JSON.toJSONString(event).getBytes(), MessagePropertiesBuilder.newInstance().build()));</span><br></pre></td></tr></table></figure>



<h3 id="2-6-接收消息"><a href="#2-6-接收消息" class="headerlink" title="2.6 接收消息"></a>2.6 接收消息</h3><h4 id="（1）拉模式"><a href="#（1）拉模式" class="headerlink" title="（1）拉模式"></a>（1）拉模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轮询调用方法一次获取一条</span></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果queue里面没有消息，会立刻返回null；传入timeoutMillis参数后可阻塞等待一段时间</span></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure>



<p>直接转换为Java对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这四个方法需要配置org.springframework.amqp.support.converter.SmartMessageConverter，这是一个接口，Jackson2JsonMessageConverter已经实现了这个接口，所以只要将Jackson2JsonMessageConverter设置到RabbitTemplate中即可。</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(String queueName, ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis, ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis, ParameterizedTypeReference&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">Foo&lt;Bar&lt;Baz, Qux&gt;&gt; foo = rabbitTemplate.receiveAndConvert(<span class="keyword">new</span> ParameterizedTypeReference&lt;Foo&lt;Bar&lt;Baz, Qux&gt;&gt;&gt;() &#123; &#125;);</span><br></pre></td></tr></table></figure>



<h4 id="（2）推模式"><a href="#（2）推模式" class="headerlink" title="（2）推模式"></a>（2）推模式</h4><p>通过方法 <code>channel.basicConsume()</code> 实现推模式，或者使用注解 <code>@RabbitListener</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queueName&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        JSON.parseObject(<span class="keyword">new</span> String(message.getBody()), typeReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果在@RabbitListener注解中指明binding信息，就能自动创建queue、exchange并建立binding关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// direct和topic类型的exchange需要routingKey</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;myQueue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;auto.exch&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;orderRoutingKey.#&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fanout类型的exchange</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;myQueue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;auto.exch&quot;, durable = &quot;true&quot;, type = ExchangeTypes.FANOUT))</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.0版本之后，可以指定多个routingKey：key = &#123; &quot;red&quot;, &quot;yellow&quot; &#125; </span></span><br><span class="line"><span class="comment">// 并且支持arguments属性，可用于headers类型的exchange</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;auto.headers&quot;, autoDelete = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                        arguments = @Argument(name = &quot;x-message-ttl&quot;, value = &quot;10000&quot;,</span></span><br><span class="line"><span class="meta">                                                type = &quot;java.lang.Integer&quot;)),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;auto.headers&quot;, type = ExchangeTypes.HEADERS, autoDelete = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        arguments = &#123;</span></span><br><span class="line"><span class="meta">                @Argument(name = &quot;x-match&quot;, value = &quot;all&quot;),</span></span><br><span class="line"><span class="meta">                @Argument(name = &quot;foo&quot;, value = &quot;bar&quot;),</span></span><br><span class="line"><span class="meta">                @Argument(name = &quot;baz&quot;)</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>



<p>@Queue有两个参数：</p>
<ul>
<li><p>exclusive：排他队列，只对创建这个queue的Connection可见，Connection关闭则queue删除；</p>
</li>
<li><p>autoDelete：没有consumer对这个queue消费时删除。</p>
</li>
</ul>
<p>对于这两种队列，durable=true是不起作用的。另外，如果注解申明的queue和exchange及binding关系都已经存在，但与已存在的设置不同，比如，已存在的exchange的是direct类型，这里尝试改为fanout类型，结果是不会有任何影响，不论是修改或者新增参数都不会生效。</p>
<p>如果queue存在，exchange存在，但没有binding，那么程序启动后会自动建立起binding关系。</p>
<p>消费者消息处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动ACK消息，后一个参数用于多条ACK，&lt;=deliveryTag同时ACK掉。</span></span><br><span class="line">channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不确认deliveryTag对应的消息</span></span><br><span class="line"><span class="comment">// 第二个参数是否应用于多消息</span></span><br><span class="line"><span class="comment">// 第三个参数是否重新放入队列requeue，与basic.reject区别就是同时支持多个消息，可以nack该消费者先前接收未ack的所有消息，nack后的消息也会被自己消费到。</span></span><br><span class="line">channel.basicNack(deliveryTag, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 抛弃此消息</span></span><br><span class="line">channel.basicNack(deliveryTag, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝deliveryTag对应的消息</span></span><br><span class="line"><span class="comment">// 第二个参数是否requeue，true则重新入队列，否则丢弃或者进入死信队列。该方法reject后，该消费者还是会消费到该条被reject的消息。</span></span><br><span class="line">channel.basicReject(deliveryTag, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否恢复消息到队列，参数为是否requeue，true则重新入队列，并且尽可能的将之前recover的消息投递给其他消费者消费，而不是自己再次消费。false则消息会重新被投递给自己。</span></span><br><span class="line">channel.basicRecover(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-7-MessageConverter"><a href="#2-7-MessageConverter" class="headerlink" title="2.7 MessageConverter"></a>2.7 MessageConverter</h3><p>在发送和接收消息时自动完成Message和Java对象的转换。</p>
<p>MessageConverter 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageConverter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Object <span class="title">fromMessage</span><span class="params">(Message&lt;?&gt; message, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Message&lt;?&gt; toMessage(Object payload, <span class="meta">@Nullable</span> MessageHeaders headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>即使不手动配置MessageConverter，也会有一个默认的SimpleMessageConverter，它会直接将java对象序列化。</p>
<p>官方文档不建议使用这个MessageConverter，因为SimpleMessageConverter是将java对象在producer端序列化，然后在consumer端反序列化，这会将producer和consumer紧密地耦合在一起，并且仅限于java平台。</p>
<p>推荐用JsonMessageConverter、Jackson2JsonMessageConverter，这两个是都将java对象转化为json再转为 <code>byte[]</code> 来构造Message对象，前一个用的是jackson json lib，后一个用的是jackson 2 json lib。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    MessageConverter messageConverter)</span> </span>&#123;</span><br><span class="line">    RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">    template.setMessageConverter(messageConverter);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-8-异常处理"><a href="#2-8-异常处理" class="headerlink" title="2.8 异常处理"></a>2.8 异常处理</h3><p><code>spring-rabbit</code> 暴露了两个接口可供实现用来处理 <code>@RabbitListener</code> 注解方法抛出的异常：</p>
<ul>
<li>RabbitListenerErrorHandler</li>
<li>org.springframework.util.ErrorHandler</li>
</ul>
<p>RabbitListenerErrorHandler，设置在 <code>@RabbitListener</code> 注解上，只对当前注解的方法生效（当前方法抛异常时被调用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitListenerErrorHandler <span class="title">rabbitListenerErrorHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitListenerErrorHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">handleError</span><span class="params">(Message amqpMessage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  org.springframework.messaging.Message&lt;?&gt; message,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  ListenerExecutionFailedException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(message);</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;test_queue_1&quot;, errorHandler = &quot;rabbitListenerErrorHandler&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>ErrorHandler，是 <code>spring-core</code> 包下面的 <code>ErrorHandler</code> ，可实现这个接口设置在 <code>RabbitListenerContainerFactory</code> 里面，示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">(CachingConnectionFactory cachingConnectionFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                     MessageConverter messageConverter)</span></span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(cachingConnectionFactory);</span><br><span class="line">    factory.setMessageConverter(messageConverter);</span><br><span class="line">    factory.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">    factory.setMaxConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">    factory.setPrefetchCount(<span class="number">1</span>);</span><br><span class="line">    factory.setErrorHandler(<span class="keyword">new</span> ErrorHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    factory.setDefaultRequeueRejected(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这个ErrorHandler对所有@RabbitListener注解方法生效。</p>
<p>二者对比：</p>
<ul>
<li><strong>作用范围：</strong>RabbitListenerErrorHandler只对当前 <code>@RabbitListener</code> 注解方法生效，ErrorHandler对所有 <code>@RabbitListener</code> 注解方法生效；</li>
<li>调用顺序：RabbitListenerErrorHandler先被调用，ErrorHandler后被调用；</li>
<li>处理粒度：RabbitListenerErrorHandler粒度比较细，可以获取到当前Message，以便做细致处理，ErrorHandler只能获取到Throwable参数；</li>
<li>默认配置：RabbitListenerErrorHandler没有默认配置，ErrorHandler有默认值ConditionalRejectingErrorHandler。</li>
</ul>
<p>ConditionalRejectingErrorHandler的作用：</p>
<ul>
<li>打印日志；</li>
<li>部分异常导致的失败不会requeue消息（默认处理失败的消息会requeue，AcknowledgeMode.NONE模式除外）。</li>
</ul>
<h3 id="2-9-事务"><a href="#2-9-事务" class="headerlink" title="2.9 事务"></a>2.9 事务</h3><p>amqp事务仅仅适用于publish和ack，rabbitmq增加了reject的事务。其它操作都不具备事务特性。</p>
<p>也就是说，rabbitmq本身的事务可以保证producer端发出的消息成功被broker收到（不能保证一定会进入queue），consumer端发出的确认信息成功被broker收到，其它诸如consumer端具体的消费逻辑之类如果想要获得事务功能，需要引入外部事务。</p>
<p>引入rabbitmq事务很简单，将RabbitTemplate或者RabbitListenerContainerFactory的channelTransacted属性设为true即可，示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpTemplate <span class="title">amqpTemplate</span><span class="params">(ConnectionFactory amqpConnectionFactory)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">    rabbitTemplate.setConnectionFactory(amqpConnectionFactory);</span><br><span class="line">    rabbitTemplate.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可以直接操作Channel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = cachingConnectionFactory.createConnection().createChannel(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//channel.txSelect();上面createChannel已经设为true了，这句可以去掉</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;xxx&quot;</span>, <span class="keyword">new</span> AMQP.BasicProperties(), JSON.toJSONString(event).getBytes());</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.txRollback();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.close()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要注意的是，直接通过Connection获取的Channel需要手动close。</p>
<p>对于producer端，同样的发送一条消息到一个不存在的exchange：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amqpTemplate.convertAndSend(<span class="string">&quot;notExistExchange&quot;</span>, <span class="string">&quot;routingKey&quot;</span>, object);</span><br></pre></td></tr></table></figure>



<ul>
<li>如果关闭事务，CachingConnectionFactory会打出一条错误日志，但程序会正常运行。</li>
<li>如果打开事务，由于消息没有到达broker，这里会抛出异常。</li>
</ul>
<p>对于consumer端，当consumer正在处理一条消息时：</p>
<ul>
<li>如果broker挂掉，程序会不断尝试重连，当broker恢复时，会重新收到这条消息；</li>
<li>如果程序挂掉，broker发现还没有收到consumer的确认信息但consumer没了，会将这条消息恢复；</li>
<li>长时间没有收到consumer端的确认信息，也会将消息从unacked状态变成ready状态；</li>
<li>如果程序处理消息期间抛异常，broker会收到一个nack或者reject，也会将这条消息恢复。</li>
</ul>
<p>所以，rabbitmq是可以将没有成功消费的消息恢复的，consumer端使用rabbitmq事务的意义并不是很大，也许可以用于consumer端消息去重：</p>
<ul>
<li>consumer处理成功向rabbitmq发出了ack，consumer默认rabbitmq收到了这个ack所以consumer认为这条消息处理结束，但实际可能rabbitmq没有收到ack又将这条消息放回queue然后重新发给consumer导致消息重复处理。如果开启了事务，能保证rabbitmq一定能收到确认信息，否则事务提交失败。</li>
</ul>
<p>另外，需要注意的是，开启事务会大幅降低消息发送及接收效率，因为当已经有一个事务存在时，后面的消息是不能被发送或者接收（对同一个consumer而言）的，所以以上两种场景都不推荐使用事务来解决。</p>
<h3 id="2-10-Listeners"><a href="#2-10-Listeners" class="headerlink" title="2.10 Listeners"></a>2.10 Listeners</h3><p>ChannelListener接口，监听Channel的创建和异常关闭：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelListener <span class="title">channelListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ChannelListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> transactional)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;channel number:&#123;&#125;, nextPublishSqlNo:&#123;&#125;&quot;</span>,</span><br><span class="line">                    channel.getChannelNumber(),</span><br><span class="line">                    channel.getNextPublishSeqNo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;channel shutdown, reason:&#123;&#125;, errorLevel:&#123;&#125;&quot;</span>,</span><br><span class="line">                    signal.getReason().protocolMethodName(),</span><br><span class="line">                    signal.isHardError() ? <span class="string">&quot;connection&quot;</span> : <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BlockedListener监听Connection的block和unblock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockedListener <span class="title">blockedListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlockedListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBlocked</span><span class="params">(String reason)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;connection blocked, reason:&#123;&#125;&quot;</span>, reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUnblocked</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;connection unblocked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ConnectionListener监听Connection的创建、关闭和异常终止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionListener <span class="title">connectionListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConnectionListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;connection created.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;connection closed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;connection shutdown, reason:&#123;&#125;, errorLevel:&#123;&#125;&quot;</span>,</span><br><span class="line">                    signal.getReason().protocolMethodName(),</span><br><span class="line">                    signal.isHardError() ? <span class="string">&quot;connection&quot;</span> : <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>RecoveryListener监听开始自动恢复Connection、自动恢复连接完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RecoveryListener <span class="title">recoveryListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecoveryListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecovery</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;automatic recovery completed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecoveryStarted</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;automatic recovery started&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ConnectionListener、ChannelListener、RecoveryListener设置到ConnectionFactory即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">cachingConnectionFactory</span><span class="params">(ConnectionListener connectionListener,  ChannelListener channelListener, RecoveryListener recoveryListener)</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    connectionFactory.setAddresses(mqConfigBean.getAddresses());</span><br><span class="line">    connectionFactory.setUsername(mqConfigBean.getUsername());</span><br><span class="line">    connectionFactory.setPassword(mqConfigBean.getPassword());</span><br><span class="line">    connectionFactory.setVirtualHost(mqConfigBean.getVirtualHost());</span><br><span class="line">    connectionFactory.addConnectionListener(connectionListener);</span><br><span class="line">    connectionFactory.addChannelListener(channelListener);</span><br><span class="line">    connectionFactory.setRecoveryListener(recoveryListener);</span><br><span class="line">    connectionFactory.setChannelCacheSize(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过ConnectionListener和ChannelListener可以debug看出Connection和Channel都是有缓存的，因为 <code>onCreate()</code> 方法不会每次都调用。并且Connection和Channel的创建都是lazy的，程序启动时不会创建Connection和Channel，在第一次用到的时候才会创建。</p>
<h3 id="2-11-多个-RabbitListener消费一个queue"><a href="#2-11-多个-RabbitListener消费一个queue" class="headerlink" title="2.11 多个@RabbitListener消费一个queue"></a>2.11 多个@RabbitListener消费一个queue</h3><p>一个服务中可以有多个@RabbitListener注解的方法消费一个queue，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;queueName&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener1</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;queueName&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener2</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样写使用的仍是同一个Connection，一条消息也不会被两个方法都调用，如果RabbitListenerContainerFactory中设置concurrentConsumer为3，意味着每个方法产生3个consumer，一共会有6个consumer对这个queue进行消费。也可以分布在不同的应用程序中，那样会在不同的Connection中。</p>
<p>一个服务中有如上的两个方法消费同一个queue，另一个服务中有一个方法消费同一个queue，则会有两个消费者Connection，一个有3个Channel，一个有6个Channel。</p>
<h3 id="2-12-生产者消息确认机制confirm-and-return"><a href="#2-12-生产者消息确认机制confirm-and-return" class="headerlink" title="2.12 生产者消息确认机制confirm and return"></a>2.12 生产者消息确认机制confirm and return</h3><p>为了能让producer端知道消息是否成功进入了queue，并且避免使用事务大幅降低消息发送效率，可以用confirm和return机制来代替事务。</p>
<p>首先实现两个Callback，ReturnCallback和ConfirmCallback，需要哪个实现哪个，不一定都需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RabbitTemplate.<span class="function">ReturnCallback <span class="title">returnCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;return call back&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RabbitTemplate.<span class="function">ConfirmCallback <span class="title">confirmCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;confirm call back&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后将这两个Callback设置到RabbitTemplate中，将mandatory属性设为true（ReturnCallback需要，ConfirmCallback不需要）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<p>然后在ConnectionFactory中将这Confirm和Return机制打开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.setPublisherReturns(<span class="keyword">true</span>);</span><br><span class="line">connectionFactory.setPublisherConfirms(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<p>调用条件：</p>
<ul>
<li><p>ConfirmCallback：每一条发出的消息都会调用ConfirmCallback；</p>
</li>
<li><p>ReturnCallback：只有在消息进入exchange但没有进入queue时才会调用。</p>
</li>
</ul>
<p>参数：</p>
<ul>
<li>correlationData：RabbitTemplate的send系列方法中有带这个参数的，如果传了这个参数，会在回调时拿到；</li>
<li>ack：消息进入exchange，为true，未能进入exchange，为false，由于Connection中断发出的消息进入exchange但没有收到confirm信息的情况，也会是false；</li>
<li>cause：消息发送失败时的失败原因信息。</li>
</ul>
<p>关于confirm和return官方文档上有下面这段信息，有必要了解一下：</p>
<blockquote>
<p> When a rabbit template send operation completes, the channel is closed; this would preclude the reception of confirms or returns in the case when the connection factory cache is full (when there is space in the cache, the channel is not physically closed and the returns/confirms will proceed as normal). When the cache is full, the framework defers the close for up to 5 seconds, in order to allow time for the confirms/returns to be received. When using confirms, the channel will be closed when the last confirm is received. When using only returns, the channel will remain open for the full 5 seconds. It is generally recommended to set the connection factory’s channelCacheSize to a large enough value so that the channel on which a message is published is returned to the cache instead of being closed. You can monitor channel usage using the RabbitMQ management plugin; if you see channels being opened/closed rapidly you should consider increasing the cache size to reduce overhead on the server.</p>
<p>当RabbitTemplate发送操作完成后，通道被关闭；这将排斥了在连接工厂缓存已满的情况下接收确认或返回（当缓存有空间时，通道不会被物理关闭，返回/确认将正常进行）。当缓存已满时，框架会将关闭时间推迟5秒，以便有时间接收确认/返回信息。</p>
<ul>
<li>当使用确认时，通道将在收到最后一个确认时被关闭。</li>
<li>当只使用返回时，通道将保持完整的5秒开放。</li>
</ul>
<p>通常建议将连接工厂的 channelCacheSize 设置为足够大的值，以便将发布消息的通道返回到缓存中而不是关闭。您可以使用 RabbitMQ 管理插件监控通道的使用情况；如果您看到通道被快速打开/关闭，您应该考虑增加缓存大小以减少服务器上的开销。</p>
</blockquote>
<p>异步的接收confirm和return时仍然需要走原来发送消息用到的那个Channel，如果那个Channel被关闭了，是收不到confirm/return信息的。好在根据以上说明，Channel会等到最后一个confirm接收到时才会close，所以应该也不用担心Channel被关闭而接收不到confirm的问题（异常会导致Channel提前关闭吗）。</p>
<h3 id="2-13-重试机制"><a href="#2-13-重试机制" class="headerlink" title="2.13 重试机制"></a>2.13 重试机制</h3><p>重试机制主要是解决网络不稳导致连接中断的问题。所以其实并不是重新发送消息，而是重新建立。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RetryTemplate <span class="title">retryTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">    SimpleRetryPolicy simpleRetryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(Integer.MAX_VALUE);</span><br><span class="line">    retryTemplate.setRetryPolicy(simpleRetryPolicy);</span><br><span class="line">    <span class="keyword">return</span> retryTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如上，配置一个RetryTemplate，再设置到AmqpTemplate即可。</p>
<p>RetryTemplate与 <code>spring-amqp</code> 及rabbitmq都没有关系，这是 <code>spring-retry</code> 中的类。以上示例中使用了最简单的重试策略，不断重试，直到 <code>Integer.MAX_VALUE</code> 次为止。</p>
<p>对producer端而言，如果Connection正常，但发送消息失败是不会重试的，<strong>如指定的exchange不存在的情况</strong>：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">1</span>条confirm，ack:<span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">26</span>:<span class="number">09.544</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">第2条发送完毕</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">收到第2条<span class="title">confirm</span>，<span class="title">ack</span>:</span><span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">26</span>:<span class="number">10.552</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">第3条发送完毕</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">收到第3条<span class="title">confirm</span>，<span class="title">ack</span>:</span><span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">26</span>:<span class="number">11.559</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br></pre></td></tr></table></figure>



<p><strong>由Connection中断导致的发送消息失败，会进行重试</strong>：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">7</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">7</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">8</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">8</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">9</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">9</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">10</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">10</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">11</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">11</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">01</span>:<span class="number">44.000</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: connection error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">connection</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=320, reply-text=CONNECTION_FORCED - broker forced connection closure <span class="keyword">with</span> reason <span class="string">&#x27;shutdown&#x27;</span>, <span class="keyword">class</span>-id=0, <span class="keyword">method</span>-id=0)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">17:</span><span class="number">01</span>:<span class="number">44.005</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] WARN  [ForgivingExceptionHandler.java:<span class="number">115</span>] - An unexpected connection driver error occured (Exception message: Connection reset)</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">01</span>:<span class="number">44.602</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">2</span>] INFO  [AbstractConnectionFactory.java:<span class="number">455</span>] - Attempting <span class="keyword">to</span> connect <span class="keyword">to</span>: [localhost:<span class="number">5672</span>]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">02</span>:<span class="number">23.076</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">2</span>] INFO  [AbstractConnectionFactory.java:<span class="number">455</span>] - Attempting <span class="keyword">to</span> connect <span class="keyword">to</span>: [localhost:<span class="number">5672</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">02</span>:<span class="number">24.578</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">2</span>] INFO  [AbstractConnectionFactory.java:<span class="number">471</span>] - Created <span class="keyword">new</span> connection: amqpConnectionFactory<span class="string">#3412</span>a3fd:<span class="number">20</span>/SimpleConnection@<span class="number">41298</span>ed [<span class="keyword">delegate</span>=amqp:<span class="comment">//guest@0:0:0:0:0:0:0:1:5672/test, localPort= 55092]</span></span><br><span class="line"></span><br><span class="line">第<span class="number">12</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">12</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">13</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">13</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">14</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">14</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">15</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">15</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br></pre></td></tr></table></figure>



<p><strong>没有配置重试，或到达了重试次数依然失败，会抛出异常</strong>：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">15</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">15</span>条confirm，ack:<span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">41</span>:<span class="number">13.571</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;paas_v3_vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">第16条发送完毕</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">收到第16条<span class="title">confirm</span>，<span class="title">ack</span>:</span><span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">41</span>:<span class="number">14.583</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;paas_v3_vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">17:</span><span class="number">41</span>:<span class="number">15.322</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] WARN  [ForgivingExceptionHandler.java:<span class="number">115</span>] - An unexpected connection driver error occured (Exception message: Connection reset)</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">41</span>:<span class="number">15.579</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] INFO  [AbstractConnectionFactory.java:<span class="number">455</span>] - Attempting <span class="keyword">to</span> connect <span class="keyword">to</span>: [localhost:<span class="number">5672</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">41</span>:<span class="number">17.609</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] ERROR [ExceptionHandler.java:<span class="number">41</span>] - unknown error</span><br><span class="line"></span><br><span class="line">org.springframework.amqp.AmqpConnectException: java.net.ConnectException: Connection refused: connect</span><br><span class="line"></span><br><span class="line">at org.springframework.amqp.rabbit.support.RabbitExceptionTranslator.convertRabbitAccessException(RabbitExceptionTranslator.java:<span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">at org.springframework.amqp.rabbit.connection.AbstractConnectionFactory.createBareConnection(AbstractConnectionFactory.java:<span class="number">484</span>)</span><br><span class="line"></span><br><span class="line">at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createConnection(CachingConnectionFactory.java:<span class="number">626</span>)</span><br><span class="line"></span><br><span class="line">at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createBareChannel(CachingConnectionFactory.java:<span class="number">576</span>)</span><br></pre></td></tr></table></figure>



<p>对Consumer端，如果采用的是 <code>@RabbitListener</code> 或其它类似异步接收消息的方式，则没必要配置重试。Consumer端有Ack机制，Connection中断导致RabbitMq收不到Ack信息，消息会重新入队（可能会导致同一条消息重复消费）。</p>
<p>对于直接调用RabbitTemplate的Receive系列方法获取消息的消费方式，则同消息发送端，没有Retry或Retry次数达到，则抛异常。</p>
<h3 id="2-14-发送端的消息丢失"><a href="#2-14-发送端的消息丢失" class="headerlink" title="2.14 发送端的消息丢失"></a>2.14 发送端的消息丢失</h3><p>讨论两种情况可能产生的消息丢失：</p>
<ol>
<li>RabbitMq没挂，只是短暂的网络异常，连接可以恢复，消息发送出去但没有到exchange。</li>
<li>RabbitMq挂了且长时间无法恢复，消息没有发出去；</li>
</ol>
<h4 id="（1）可恢复的Connection中断"><a href="#（1）可恢复的Connection中断" class="headerlink" title="（1）可恢复的Connection中断"></a>（1）可恢复的Connection中断</h4><p>配置开启Retry情况下，Connection中断会根据配置的retry策略尝试重连，但即使重新连上了，消息依然可能会丢失。</p>
<ul>
<li>本地测试，单线程间隔1毫秒循环发送1万条消息，模拟一个不断有消息发出的场景，在发送过程中手动关闭Rabbitmq服务再重新启动，模拟Connection短暂中断的场景。</li>
<li>因为每一条消息都带有唯一的messageId（实际上是“线程名-序号”的形式），所以能轻易地从消费端读出所有消息之后找到丢失的消息。</li>
<li>测试结果：发送1万条消息，实际收到9999条，丢失1条。</li>
</ul>
<p>发送端通过ConfirmCallback打印出所有ack=false的消息：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----------打印ack=false的消息----------</span><br><span class="line"></span><br><span class="line">size:4</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-5881</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-5882</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-5883</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-5884</span></span><br></pre></td></tr></table></figure>



<p>消费端读出所有消息后，找出丢失的消息：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">total:10000</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">contain</span> <span class="comment">size:</span> <span class="comment">9999</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">absent</span> <span class="comment">size:</span> <span class="comment">1</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">pool</span><span class="literal">-</span><span class="comment">5</span><span class="literal">-</span><span class="comment">thread</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="comment">5883</span></span><br></pre></td></tr></table></figure>



<p>可以看到，ack=false的消息有4条，但实际上只丢了一条。因为消息的发送和Confirm是异步进行的，如果在消息发送出去之后，异步的confirm回来之前，Connection中断，那么ConfirmCallback会立即被调用，并且ack=false，原因是Channel被关闭了。</p>
<ul>
<li>单线程情况下应该最多只会丢失一条，也有可能不会丢。</li>
<li>多线程的情况下丢消息的现象就很严重了。本地测试5个线程发消息的情况，一共50000条消息，丢失了1500多条。但其实如果把这5个线程分到5个请求，一个请求只跑一个线程，情况会好很多，类似于上面单线程的情况。</li>
<li><strong>解决方案</strong>：首先可以想到的解决方案是事务，但事务一般不建议使用，为了rabbitmq的效率，退而求其次，采用confirm机制。</li>
</ul>
<p>从上面的测试可以看到，在ConfirmCallback中ack=false的消息未必真的没有到达exchange，但没有到达exchange的消息ack一定是false，所以只需要将ack=false的消息重新发送一遍即可（这种方案会导致消息重复发送，后面再解决这一问题）。</p>
<p><strong>ConfirmCallback的回调方法中没有Message对象</strong>，你可能会想从ConfirmCallback中拿到Message对象，当ack=false的时候将这个Message再重新发出去，但方法入参中没有Message对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReissueMessageConfirmCallback</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReissueMessageConfirmCallback.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (correlationData <span class="keyword">instanceof</span> MessageCorrelationData) &#123;</span><br><span class="line">            MessageCorrelationData messageCorrelationData = (MessageCorrelationData) correlationData;</span><br><span class="line">            logger.info(<span class="string">&quot;------------messageId: &quot;</span> + messageCorrelationData.getMessage().getMessageProperties().getMessageId() +</span><br><span class="line">                    <span class="string">&quot;, ack: &quot;</span> + ack + <span class="string">&quot;, cause:&quot;</span> + cause + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                SendFailedMessageHolder.add(messageCorrelationData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意到入参中有一个<strong>CorrelationData</strong>对象，同时在RabbitTemplate中有相应的send方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> String exchange, <span class="keyword">final</span> String routingKey, <span class="keyword">final</span> Message message, <span class="keyword">final</span> CorrelationData correlationData)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个方法AmqpTemplate中是没有的，是RabbitTemplate扩展的。所以，虽然ConfirmCallback不能直接拿到Message，但可以拿到CorrelationData，于是问题就解决了。</p>
<p><strong>直接在ConfirmCallback中调用RabbitTemplate发送消息导致死锁</strong>，现在我们可以通过CorrelationData在ConfirmCallback中拿到Message对象了，我们也有办法拿到RabbitTemplate，为了避免bean的循环依赖，我是这样做的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">amqpTemplate</span><span class="params">(ConnectionFactory amqpConnectionFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  RetryTemplate retryTemplate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  MessageConverter messageConverter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  //RabbitTemplate.ConfirmCallback confirmCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  RabbitTemplate.ReturnCallback returnCallback)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">    rabbitTemplate.setConnectionFactory(amqpConnectionFactory);</span><br><span class="line">    rabbitTemplate.setRetryTemplate(retryTemplate);</span><br><span class="line">    rabbitTemplate.setMessageConverter(messageConverter);</span><br><span class="line">    <span class="comment">//rabbitTemplate.setChannelTransacted(true);</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> ReissueMessageConfirmCallback(rabbitTemplate));</span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ReissueMessageConfirmCallback是自己写的一个实现类，将RabbitTemplate bean自己设置进去。然后我们在ConfirmCallback中发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReissueMessageConfirmCallback</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReissueMessageConfirmCallback.class);</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReissueMessageConfirmCallback</span><span class="params">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (correlationData <span class="keyword">instanceof</span> MessageCorrelationData) &#123;</span><br><span class="line">            MessageCorrelationData messageCorrelationData = (MessageCorrelationData) correlationData;</span><br><span class="line">            String exchange = messageCorrelationData.getExchange();</span><br><span class="line">            String routingKey = messageCorrelationData.getRoutingKey();</span><br><span class="line">            Message message = messageCorrelationData.getMessage();</span><br><span class="line">            <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                rabbitTemplate.send(exchange, routingKey, message, messageCorrelationData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>MessageCorrelationData是自己写的CorrelationData扩展类，增加了Message、exchange、routingKey属性。</p>
<p>在请求主线程发送1万条消息的过程中，将rabbitmq关闭，这时请求主线程和ConfirmCallback线程都在等待Connection恢复，然后重新启动rabbitmq，当程序重新建立Connection之后，这两个线程会死锁。</p>
<p><strong>可行的方案：定时任务重发</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReissueMessageSchedule</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scheduledExecutorService.scheduleWithFixedDelay(<span class="keyword">new</span> ReissueTask(rabbitTemplate), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReissueTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReissueTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReissueTask</span><span class="params">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;MessageCorrelationData&gt; messageCorrelationDataList = <span class="keyword">new</span> ArrayList&lt;&gt;(SendFailedMessageHolder.getAll());</span><br><span class="line">        logger.info(<span class="string">&quot;------------------获取到&quot;</span> + messageCorrelationDataList.size() + <span class="string">&quot;条ack=false的消息，准备重发------------------&quot;</span>);</span><br><span class="line">        SendFailedMessageHolder.clear();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (MessageCorrelationData messageCorrelationData : messageCorrelationDataList) &#123;</span><br><span class="line">            Message message = messageCorrelationData.getMessage();</span><br><span class="line">            String messageId = message.getMessageProperties().getMessageId();</span><br><span class="line">            logger.info(<span class="string">&quot;------------------重发第&quot;</span> + i + <span class="string">&quot;条消息，id: &quot;</span> + messageId + <span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">            message.getMessageProperties().setMessageId(messageId + <span class="string">&quot;-重发&quot;</span>);</span><br><span class="line">            rabbitTemplate.send(messageCorrelationData.getExchange(), messageCorrelationData.getRoutingKey(),</span><br><span class="line">            messageCorrelationData.getMessage(), messageCorrelationData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;------------------重发完成------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重发的消息会在原消息id后面跟上“重发”二字。</p>
<p>本地测试打印出的相关信息，发送端：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">07</span>:<span class="number">36.063</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:29]</span> - ------------------获取到<span class="number">13</span>条发送失败的消息，准备重发------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">07</span>:<span class="number">36.063</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">1</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7439</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">07</span>:<span class="number">38.030</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:455]</span> - Attempting to connect to: <span class="selector-attr">[localhost:5672]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">07</span>:<span class="number">40.036</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:455]</span> - Attempting to connect to: <span class="selector-attr">[localhost:5672]</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">14.188</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:455]</span> - Attempting to connect to: <span class="selector-attr">[localhost:5672]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.190</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:455]</span> - Attempting to connect to: <span class="selector-attr">[localhost:5672]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.710</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:471]</span> - Created new connection: amqpConnectionFactory<span class="number">#2127e6</span>6e:<span class="number">25</span>/SimpleConnection@ee0d88b <span class="selector-attr">[delegate=amqp://guest@127.0.0.1:5672/test, localPort= 57212]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.716</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">2</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7440</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.716</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7452</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7452</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.717</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">3</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7441</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.718</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">4</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7442</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.718</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7453</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7453</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.718</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">5</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7443</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.719</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">6</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7444</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.719</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">7</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7445</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.719</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">8</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7446</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.720</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7454</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7454</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.720</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">9</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7447</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.720</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">10</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7448</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.720</span> <span class="selector-attr">[AMQP Connection 127.0.0.1:5672]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.r</span><span class="selector-class">.ReissueMessageConfirmCallback</span> <span class="selector-attr">[ReissueMessageConfirmCallback.java:21]</span> - ------------messageId: reactor-http-nio-<span class="number">3</span>-<span class="number">7451</span>, ack: true, cause:null--------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.721</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">11</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7449</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.721</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7455</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7455</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.721</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">12</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7450</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.722</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7456</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7456</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.723</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">13</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7451</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.723</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:41]</span> - ------------------重发完成------------------</span><br></pre></td></tr></table></figure>



<p>reactor-http-nio-3是请求主线程，pool-3-thread-1是执行重发消息定时任务的线程。</p>
<p>从以上日志信息可以看出，当rabbitmq关闭的时候，主线程与重发线程都在尝试重连，直到rabbitmq重启完成恢复Connection。重发的消息有13条：reactor-http-nio-3-7439 ~ reactor-http-nio-3-7451。</p>
<p>再看消费端整理并打印出来的接收到的所有消息：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--------should receive:10000---------</span><br><span class="line"></span><br><span class="line">----------actually receive: 10013----------</span><br><span class="line"></span><br><span class="line">----------absent messages:0---------</span><br><span class="line"></span><br><span class="line">----------resend messages: 13----------</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7439</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7440</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7441</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7442</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7443</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7444</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7446</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7447</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7445</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7449</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7448</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7450</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7451</span>-重发</span><br></pre></td></tr></table></figure>



<p>可以看到，我们正确收到了上面那重发的13条消息。不过这次运气比较好，没有消息遗漏。同时，这里注意到一件事，消费端代码没有对重发的消息做排序，收到的重发消息的顺序与发送端重发消息的顺序是不匹配的，所以rabbitmq可能不保证先发出的消息一定先被接收。</p>
<p>下面是5个线程同时发送消息的测试结果，发送端：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">42</span>:<span class="number">40.602</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:29]</span> - ------------------获取到<span class="number">642</span>条发送失败的消息，准备重发------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">42</span>:<span class="number">40.602</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">1</span>条消息，id: pool-<span class="number">5</span>-thread-<span class="number">4</span>-<span class="number">6951</span>------------------</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">省略重连过程</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">43</span>:<span class="number">07.628</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">2</span>条消息，id: pool-<span class="number">5</span>-thread-<span class="number">5</span>-<span class="number">6605</span>------------------</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">省略中间<span class="number">600</span>多条消息的重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">43</span>:<span class="number">07.794</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">641</span>条消息，id: pool-<span class="number">5</span>-thread-<span class="number">1</span>-<span class="number">6704</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">43</span>:<span class="number">07.794</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">642</span>条消息，id: pool-<span class="number">5</span>-thread-<span class="number">4</span>-<span class="number">7088</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">43</span>:<span class="number">07.794</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:41]</span> - ------------------重发完成------------------</span><br></pre></td></tr></table></figure>



<p>消费端：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">--------should receive:50000---------</span><br><span class="line"></span><br><span class="line">----------actually receive: 50014----------</span><br><span class="line"></span><br><span class="line">----------absent messages:628---------</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6583</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6584</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6705</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-2</span><span class="string">-6538</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-2</span><span class="string">-6653</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-3</span><span class="string">-6093</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-3</span><span class="string">-6218</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-4</span><span class="string">-6955</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-4</span><span class="string">-7087</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6605</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6733</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6734</span></span><br><span class="line"></span><br><span class="line">----------resend messages: 642----------</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6580</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6581</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6705</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6706</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-2</span><span class="string">-6537</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-2</span><span class="string">-6654</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-3</span><span class="string">-6093</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-3</span><span class="string">-6219</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-4</span><span class="string">-6951</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-4</span><span class="string">-7088</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6604</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6734</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6735</span>-重发</span><br></pre></td></tr></table></figure>



<p>可以看到，丢失的消息被完美地包含在重发的消息里面了。</p>
<h4 id="（2）长时间无法恢复的Connection中断"><a href="#（2）长时间无法恢复的Connection中断" class="headerlink" title="（2）长时间无法恢复的Connection中断"></a>（2）长时间无法恢复的Connection中断</h4><p>上面讨论了retry之后可以恢复Connection的情况，也有可能长时间retry之后依然不能恢复Connection，如rabbitmq挂掉的情况，不能一直retry下去阻塞接口调用。</p>
<p>这种情况是没有confirm的，因为消息都没有发出去。所以处理就更简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    rabbitTemplate.send(messageCorrelationData.getExchange(), messageCorrelationData.getRoutingKey(), messageCorrelationData.getMessage(), messageCorrelationData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AmqpConnectException e) &#123;</span><br><span class="line">    SendFailedMessageHolder.add(messageCorrelationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>retry失败或者没有retry机制都会抛出AmqpConnectException，catch之后将消息保存起来即可。</p>
<h3 id="2-15-消费端的消息去重"><a href="#2-15-消费端的消息去重" class="headerlink" title="2.15 消费端的消息去重"></a>2.15 消费端的消息去重</h3><p>如果发送端采用confirm机制来做丢失消息的重发，上面提到，可能会出现没有丢失的消息也被重发了，导致消息重复。</p>
<p>这个问题很容易解决，MessageProperties中是有messageId属性的，每条消息设置一个唯一的messageId即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message message = messageConverter.toMessage(messageId, <span class="keyword">new</span> MessageProperties());</span><br><span class="line">message.getMessageProperties().setMessageId(messageId);</span><br></pre></td></tr></table></figure>



<h3 id="2-16-消息发送和接收使用不同的Connection"><a href="#2-16-消息发送和接收使用不同的Connection" class="headerlink" title="2.16 消息发送和接收使用不同的Connection"></a>2.16 消息发送和接收使用不同的Connection</h3><p>当一个服务同时作为消息发送端和接收端时，建议使用不同的Connection以避免一方出现故障影响到另一方。</p>
<p>并不需要做很多事情，只需RabbitTemplate配置中加一个属性设置即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<p>RabbitTemplate在创建Connection时，会根据这个boolean参数选择使用ConnectionFactory本身或者ConnectionFactory中的publisherConnectionFactory（也是一个ConnectionFactory）来创建，相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a connection with this connection factory and/or its publisher factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connectionFactory the connection factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> publisherConnectionIfPossible true to use the publisher factory, if present.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the connection.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">createConnection</span><span class="params">(<span class="keyword">final</span> ConnectionFactory connectionFactory, <span class="keyword">final</span> <span class="keyword">boolean</span> publisherConnectionIfPossible)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (publisherConnectionIfPossible) &#123;</span><br><span class="line">           ConnectionFactory publisherFactory = connectionFactory.getPublisherConnectionFactory();</span><br><span class="line">           <span class="keyword">if</span> (publisherFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> publisherFactory.createConnection();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> connectionFactory.createConnection();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-17-消息过期"><a href="#2-17-消息过期" class="headerlink" title="2.17 消息过期"></a>2.17 消息过期</h3><p>在发送端，可通过如下方式设置消息过期时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.getMessageProperties().setExpiration(<span class="string">&quot;30000&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>这样，这条消息的有效期是30秒，30秒没有被消费掉会被丢弃。</p>
<h3 id="2-18-Dead-letter-exchange"><a href="#2-18-Dead-letter-exchange" class="headerlink" title="2.18 Dead letter exchange"></a>2.18 Dead letter exchange</h3><p>这个与spring-amqp无关，是rabbitmq的设置。将一个queue设置了 <code>x-dead-letter-exchange</code> 及 <code>x-dead-letter-routing-key</code> 两个参数后，这个queue里丢弃的消息将会进入 <code>dead letter exchange</code> ，并route到相应的queue里去。</p>
<p>这里，被丢弃的消息包括：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The message <span class="keyword">is</span> rejected (basic.reject <span class="keyword">or</span> basic.nack) <span class="keyword">with</span> <span class="keyword">requeue</span>=<span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">The TTL <span class="keyword">for</span> the message expires; <span class="keyword">or</span></span><br><span class="line"></span><br><span class="line">The queue length limit <span class="keyword">is</span> exceeded.</span><br></pre></td></tr></table></figure>



<h2 id="三-原理"><a href="#三-原理" class="headerlink" title="三. 原理"></a>三. 原理</h2><h3 id="3-1-架构"><a href="#3-1-架构" class="headerlink" title="3.1 架构"></a>3.1 架构</h3><p>Spring AMQP的构成：</p>
<ul>
<li>spring-amqp：包含 <code>org.springframework.amqp.core</code>软件包，提供不依赖任何特定 AMQP 代理实现或 Client 端库的通用抽象。最终用户代码将只能在抽象层上开发，因此在各个供应商的实现中将更具可移植性。</li>
<li>spring-rabbit：RabbitMQ实现。</li>
</ul>
<h3 id="3-2-核心类"><a href="#3-2-核心类" class="headerlink" title="3.2 核心类"></a>3.2 核心类</h3><h4 id="（1）Message"><a href="#（1）Message" class="headerlink" title="（1）Message"></a>（1）Message</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageProperties messageProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">byte</span>[] body, MessageProperties messageProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">        <span class="keyword">this</span>.messageProperties = messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProperties <span class="title">getMessageProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>MessageProperties</code> 接口定义了一些常用属性（如Header、exchange、routing key、消息创建时间timestamp等），也可以通过header扩展：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProperties</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1619000546531112290L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_BYTES = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_TEXT_PLAIN = <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_SERIALIZED_OBJECT = <span class="string">&quot;application/x-java-serialized-object&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_JSON = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_JSON_ALT = <span class="string">&quot;text/x-json&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_XML = <span class="string">&quot;application/xml&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_BATCH_FORMAT = <span class="string">&quot;springBatchFormat&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BATCH_FORMAT_LENGTH_HEADER4 = <span class="string">&quot;lengthHeader4&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_AUTO_DECOMPRESS = <span class="string">&quot;springAutoDecompress&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_DELAY = <span class="string">&quot;x-delay&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTENT_TYPE = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageDeliveryMode DEFAULT_DELIVERY_MODE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PRIORITY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Date timestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String messageId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String appId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String clusterId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">byte</span>[] correlationId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String correlationIdString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String replyTo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String contentType = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String contentEncoding;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> contentLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> contentLengthSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MessageDeliveryMode deliveryMode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String expiration;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer priority;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean redelivered;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String receivedExchange;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String receivedRoutingKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String receivedUserId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> deliveryTag;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> deliveryTagSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer messageCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String consumerTag;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String consumerQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer receivedDelay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MessageDeliveryMode receivedDeliveryMode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Type inferredArgumentType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method targetMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object targetBean;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（2）Exchange"><a href="#（2）Exchange" class="headerlink" title="（2）Exchange"></a>（2）Exchange</h4><p><code>Exchange</code> 接口表示一个 AMQP 交换器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Exchange</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换器类型</span></span><br><span class="line">    <span class="function">String <span class="title">getExchangeType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否持久化</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDurable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否自动删除</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoDelete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他一些结构化参数</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getArguments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Exchange：<code>Direct</code> ，<code>Topic</code> ，<code>Fanout</code> 和 <code>Headers</code> 。库中可以找到每种类型的<code>Exchange</code> 接口的实现。不同交换器类型可以参考：<a href="http://linyishui.top/2020091901.html">RabbitMQ（一）简介和入门</a>。</p>
<h4 id="（3）Queue"><a href="#（3）Queue" class="headerlink" title="（3）Queue"></a>（3）Queue</h4><p><code>Queue</code> 类表示消息队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否持久化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> durable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否排他，仅对首次声明它的连接可见，并在连接断开时自动删除，适用于一个客户端同时发送和读取消息的应用场景。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exclusive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否自动删除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> autoDelete;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他一些参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The queue is durable, non-exclusive and non auto-delete.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name the name of the queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters omitted for brevity</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>构造函数采用队列名称。取决于实现方式，Management 模板可以提供用于生成唯一命名的队列的方法。这样的队列可用作“答复”地址或其他“临时”情况。因此，自动生成的 Queue 的  exclusive 和 autoDelete 属性都将设置为 true 。</p>
<h4 id="（4）Binding"><a href="#（4）Binding" class="headerlink" title="（4）Binding"></a>（4）Binding</h4><p>生产者发送到 Exchange，而消费者从队列接收，将队列连接到 Exchange 的绑定至关重要。Spring AMQP 中定义了一个 <code>Binding</code> 类来表示这些连接。</p>
<p>可以使用固定的路由键将队列绑定到 DirectExchange。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someDirectExchange, <span class="string">&quot;foo.bar&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>可以使用路由模式将队列绑定到 TopicExchange。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someTopicExchange, <span class="string">&quot;foo.*&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>可以使用路由键将队列绑定到 FanoutExchange。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someFanoutExchange)</span><br></pre></td></tr></table></figure>



<p>还提供 <code>BindingBuilder</code> 以促进“Fluent 的 API”样式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对bind()方法使用静态导入样式效果很好</span></span><br><span class="line">Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with(<span class="string">&quot;foo.*&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><code>AmqpAdmin</code> 类可以使用绑定实例来实际触发代理上的绑定操作，可以在<code>@Configuration</code> 类中使用 Spring 的 <code>@Bean</code> -style 定义 Binding 实例。</p>
<h3 id="3-3-连接和资源Management"><a href="#3-3-连接和资源Management" class="headerlink" title="3.3 连接和资源Management"></a>3.3 连接和资源Management</h3><p>这一部分区别于核心类是基于具体实现的，RabbitMQ是目前唯一支持的实现。</p>
<h4 id="（1）ConnectionFactory-连接工厂类"><a href="#（1）ConnectionFactory-连接工厂类" class="headerlink" title="（1）ConnectionFactory-连接工厂类"></a>（1）ConnectionFactory-连接工厂类</h4><ul>
<li><code>ConnectionFactory</code> 接口是用于 Management 与 RabbitMQ 代理的连接的中央组件。 </li>
<li><code>ConnectionFactory</code> 的职责是提供<code>org.springframework.amqp.rabbit.connection.Connection</code> 的实例，该实例是 <code>com.rabbitmq.client.Connection</code> 的包装器。</li>
<li>提供的唯一具体实现是 <code>CachingConnectionFactory</code> ，默认情况下，它构建一个可以由应用程序共享的单个连接代理。</li>
<li>可以共享连接，因为与 AMQP 进行消息传递的“工作单元”实际上是一个“通道”(在某些方面，这类似于 JMS 中的 Connection 和 Session 之间的关系)。可以想象，连接实例提供了 <code>createChannel</code> 方法。 </li>
<li><code>CachingConnectionFactory</code> 实现支持这些通道的缓存，并且根据它们是否是事务性的，为通道维护单独的缓存。创建 <code>CachingConnectionFactory</code> 的实例时，可以通过构造函数提供hostname。还应该提供username和password属性。如果要配置通道缓存的大小(默认值为25)，则也可以在此处调用 <code>setChannelCacheSize()</code> 方法。</li>
<li>从1.3版本开始，可以将 <code>CachingConnectionFactory</code> 配置为缓存连接以及通道。在这种情况下，每次对 <code>createConnection()</code> 的调用都会创建一个新连接(或从缓存中检索一个空闲的连接)。关闭连接会将其返回到缓存(如果尚未达到缓存大小)。在此类连接上创建的通道也将被缓存。</li>
<li>在某些环境中，使用单独的连接可能很有用，例如从 HA 群集中使用负载，并与负载均衡器一起连接到不同的群集成员。将 <code>cacheMode</code> 设置为<code>CacheMode.CONNECTION</code> 。</li>
<li>从1.5.5版本开始，提供了一个新属性 <code>connectionLimit</code> 。设置此选项后，它将限制允许的连接总数。设置后，如果达到限制，则使用 <code>channelCheckoutTimeLimit</code> await 连接变为空闲。如果超过时间，则抛出 <code>AmqpTimeoutException</code> 。</li>
<li>当使用大量连接时，应考虑在 <code>CachingConnectionFactory</code> 上设置自定义<code>executor</code> 。然后，所有连接将使用同一执行程序，并且可以共享其线程。执行程序的线程池应该是无界的，或者应为预期的使用率进行适当设置(通常每个连接至少一个线程)。如果在每个连接上创建多个通道，则池大小将影响并发性，因此，变量(或简单缓存)线程池执行程序将是最合适的。</li>
<li>从1.6版本开始，默认的通道缓存大小已从1增加到25。在大容量，多线程的环境中，小的缓存意味着将以较高的速率创建和关闭通道。增加默认缓存大小将避免这种开销。您应该通过 RabbitMQ Admin UI 监视正在使用的通道，如果看到许多正在创建和关闭的通道，请考虑进一步增加缓存大小。缓存将仅按需增长(以适应应用程序的并发要求)，因此此更改不会影响现有的小批量应用程序。</li>
<li>从1.4.2版本开始，<code>CachingConnectionFactory</code> 具有属性<code>channelCheckoutTimeout</code> 。当此属性大于零时，<code>channelCacheSize</code> 成为可在连接上创建的通道数的限制。如果达到限制，则调用线程将阻塞，直到某个通道可用或达到此超时为止，在这种情况下将引发 <code>AmqpTimeoutException</code> 。</li>
<li>框架内使用的通道(例如<code>RabbitTemplate</code>)将可靠地返回到缓存。如果您在框架外部创建通道(例如，通过直接访问连接并调用 <code>createChannel()</code> )，则必须(通过关闭)可靠地返回它们(可能在 <code>finally</code> 块中)，以避免耗尽通道。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(<span class="string">&quot;somehost&quot;</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br></pre></td></tr></table></figure>



<p> XML ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;somehost&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>可以使用 Rabbit 名称空间快速便捷地创建<code>ConnectionFactory</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p>在大多数情况下，这是可取的，因为框架可以为您选择最佳的默认值。创建的实例将是 <code>CachingConnectionFactory</code> 。请记住，通道的默认缓存大小为 25。如果要缓存更多通道，请通过channelCacheSize属性设置一个较大的值。在 XML 中，它看起来像这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;somehost&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;channelCacheSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="（2）ConnectionNameStrategy-连接命名"><a href="#（2）ConnectionNameStrategy-连接命名" class="headerlink" title="（2）ConnectionNameStrategy-连接命名"></a>（2）ConnectionNameStrategy-连接命名</h4><p>从1.7 版本开始，提供了 <code>ConnectionNameStrategy</code> 以便注入<code>AbstractionConnectionFactory</code> 。生成的名称用于目标 RabbitMQ 连接的特定于应用程序的标识。如果 RabbitMQ 服务器支持，则连接名称将显示在 ManagementUI 中。此值不必是唯一的，也不能用作连接标识符，例如在 HTTP API 请求中。该值应该是人类可读的，并且是<code>connection_name</code>键下<code>ClientProperties</code>的一部分。</p>
<p>可以使用一个简单的 Lambda：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.setConnectionNameStrategy(connectionFactory -&gt; &quot;MY_CONNECTION&quot;);</span><br></pre></td></tr></table></figure>



<p><code>ConnectionFactory</code> 参数可用于通过某些逻辑来区分目标连接名称。默认情况下，<code>AbstractConnectionFactory</code> 的 <code>beanName</code> ，代表对象的十六进制字符串和内部计数器用于生成 <code>connection_name</code> 。 <code>&lt;rabbit:connection-factory&gt; </code>名称空间组件也随 <code>connection-name-strategy</code> 属性一起提供。</p>
<p>提供了实现 <code>SimplePropertyValueConnectionNameStrategy</code> ，该实现将连接名称设置为应用程序属性。将其声明为 <code>@Bean</code> 并将其注入连接工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionNameStrategy <span class="title">cns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimplePropertyValueConnectionNameStrategy(<span class="string">&quot;spring.application.name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">rabbitConnectionFactory</span><span class="params">(ConnectionNameStrategy cns)</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    ...</span><br><span class="line">    connectionFactory.setConnectionNameStrategy(cns);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 Spring Boot 及其自动配置的连接工厂时，仅需要声明 <code>ConnectionNameStrategy</code> 的 <code>@Bean</code>。引导程序将自动检测到该 bean，并将其连接到工厂。</p>
<h4 id="（3）阻止的连接和资源限制"><a href="#（3）阻止的连接和资源限制" class="headerlink" title="（3）阻止的连接和资源限制"></a>（3）阻止的连接和资源限制</h4><p>RabbitMQ内存警告（Memory Alarm）连接可能被阻止与 Broker 进行交互。从2.0开始，提供 <code>com.rabbitmq.client.BlockedListener</code> ，以通知连接被阻止和未被阻止的事件。此外，<code>AbstractConnectionFactory</code> 通过其内部<code>BlockedListener</code> 实现分别发出 <code>ConnectionBlockedEvent</code> 和 <code>ConnectionUnblockedEvent</code> 。这些使您能够提供应用程序逻辑，以对代理程序上的问题做出适当反应，并采取一些纠正措施。</p>
<p>当应用程序配置有单个 <code>CachingConnectionFactory</code> 时(默认情况下使用 Spring Boot 自动配置)，当代理阻止连接时，应用程序将停止工作。当它被 broker 阻止时，它的任何 Client 都会停止工作。如果我们在同一应用程序中具有生产者和消费者，那么当生产者阻塞连接时，由于代理上不再有资源，并且由于连接被阻塞，消费者也无法释放它们，我们可能最终陷入阻塞。</p>
<p>为了缓解该问题，建议再使用一个具有相同选项的单独的 <code>CachingConnectionFactory</code> 实例：一个用于生产者，一个用于消费者。对于在消费者线程上执行的事务生产者，不可能使用单独的 <code>CachingConnectionFactory</code> ，因为他们应该重用与消费者事务相关联的<code>Channel</code> 。</p>
<p>从版本2.0.2开始，<code>RabbitTemplate</code> 具有配置选项，以自动使用第二个连接工厂，除非正在使用事务。发布者连接的 <code>ConnectionNameStrategy</code> 与主要策略相同，在调用方法的结果后附加 <code>.publisher</code> 。</p>
<p>从1.7.7开始，提供了一个 <code>AmqpResourceNotAvailableException</code> ，例如当<code>SimpleConnection.createChannel()</code> 无法创建<code>Channel</code>时抛出该<code>AmqpResourceNotAvailableException</code> ，因为达到了 <code>channelMax</code> 的限制并且缓存中没有可用的通道。可以在 <code>RetryPolicy</code> 中使用此异常，以在某些回退之后恢复操作。</p>
<h4 id="（4）配置基础-Client-端连接工厂"><a href="#（4）配置基础-Client-端连接工厂" class="headerlink" title="（4）配置基础 Client 端连接工厂"></a>（4）配置基础 Client 端连接工厂</h4><p><code>CachingConnectionFactory</code> 使用 RabbitClient 端 <code>ConnectionFactory</code> 的实例；在 <code>CachingConnectionFactory</code> 上设置等效属性时，会传递许多配置属性(例如<code>host, port, userName, password, requestedHeartBeat, connectionTimeout</code>)。要设置其他属性(例如<code>clientProperties</code>)，请定义 Rabbit 工厂的实例，并使用<code>CachingConnectionFactory</code>的适当构造函数为其提供引用。如上所述使用命名空间时，请在<code>connection-factory</code>属性中提供对已配置工厂的引用。为方便起见，提供了工厂 bean 来帮助在 Spring 应用程序上下文中配置连接工厂，如下一节所述。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:connection-factory</span><br><span class="line">      id=&quot;connectionFactory&quot; connection-factory=&quot;rabbitConnectionFactory&quot;/&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>4.0.x客户端默认启用了自动恢复功能；虽然与此功能兼容，但Spring AMQP有自己的恢复机制，一般不需要客户端的恢复功能。</li>
<li>建议禁用amqp-client自动恢复功能，以避免在代理可用但连接尚未恢复的情况下得到AutoRecoverConnectionNotCurrentlyOpenException。您可能会注意到这种异常，例如，当RabbitTemplate中配置了RetryTemplate时，甚至在故障转移到集群中的另一个代理时也是如此。</li>
<li>由于自动恢复连接是在一个计时器上恢复的，因此使用 Spring AMQP 的恢复机制可以更快地恢复连接。从 1.7.1 版开始，Spring AMQP 禁用它，除非您明确创建自己的 RabbitMQ 连接工厂并将其提供给 CachingConnectionFactory。由 RabbitConnectionFactoryBean 创建的 RabbitMQ ConnectionFactory 实例也将默认禁用该选项。</li>
</ul>
<h4 id="（5）RabbitConnectionFactoryBean-和配置-SSL"><a href="#（5）RabbitConnectionFactoryBean-和配置-SSL" class="headerlink" title="（5）RabbitConnectionFactoryBean 和配置 SSL"></a>（5）RabbitConnectionFactoryBean 和配置 SSL</h4><p>从1.4开始，提供了一个方便的<code>RabbitConnectionFactoryBean</code>，以使用依赖注入的方式在Client端连接工厂上配置 SSL 属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;rabbitConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">connection-factory</span>=<span class="string">&quot;clientConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">host</span>=<span class="string">&quot;$&#123;host&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">port</span>=<span class="string">&quot;$&#123;port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">virtual-host</span>=<span class="string">&quot;$&#123;vhost&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span> <span class="attr">password</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.connection.RabbitConnectionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useSSL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sslPropertiesLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;file:/secrets/rabbitSSL.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>省略<code>keyStore</code>和<code>trustStore</code>配置以通过 SSL 进行连接而无需证书验证。密钥和信任库配置可以如下提供：</p>
<p><code>sslPropertiesLocation</code>属性是 Spring <code>Resource</code>，它指向包含以下键的属性文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keyStore=file:/secret/keycert.p12</span><br><span class="line">trustStore=file:/secret/trustStore</span><br><span class="line">keyStore.passPhrase=secret</span><br><span class="line">trustStore.passPhrase=secret</span><br></pre></td></tr></table></figure>



<p><code>keyStore</code>和<code>truststore</code>是指向 Store 的 Spring <code>Resources</code>。通常，此属性文件将由 os 保护，并且应用程序具有读取访问权限。</p>
<p>从 Spring AMQP 版本 1.5 开始，可以直接在工厂 bean 上设置这些属性。如果同时提供了离散属性和<code>sslPropertiesLocation</code>，则后者中的属性将覆盖离散值。</p>
<h4 id="（6）路由连接工厂"><a href="#（6）路由连接工厂" class="headerlink" title="（6）路由连接工厂"></a>（6）路由连接工厂</h4><p>从1.3开始，引入了<code>AbstractRoutingConnectionFactory</code>。这提供了一种机制，可在运行时为多个<code>ConnectionFactories</code>配置 Map 并由某个<code>lookupKey</code>确定目标<code>ConnectionFactory</code>。</p>
<p>Spring AMQP 提供了<code>SimpleRoutingConnectionFactory</code>，它从<code>SimpleResourceHolder</code>获取当前线程绑定的<code>lookupKey</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.connection.SimpleRoutingConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetConnectionFactories&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;#&#123;connectionFactory1.virtualHost&#125;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory1&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;#&#123;connectionFactory2.virtualHost&#125;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory2&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;template&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(String vHost, String payload)</span> </span>&#123;</span><br><span class="line">        SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);</span><br><span class="line">        rabbitTemplate.convertAndSend(payload);</span><br><span class="line">        <span class="comment">// 使用后解除绑定资源很重要</span></span><br><span class="line">        SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从版本 1.4 开始，<code>RabbitTemplate</code>支持 SpEL <code>sendConnectionFactorySelectorExpression</code> 和 <code>receiveConnectionFactorySelectorExpression</code> 属性，这些属性在每个 AMQP 协议交互操作(<code>send</code>，<code>sendAndReceive</code>，<code>receive</code>或<code>receiveAndReply</code>)上进行评估，对于提供的<code>AbstractRoutingConnectionFactory</code> 解析为 <code>lookupKey</code> 值。表达式中可以使用 Bean 引用，例如<code>&quot;@vHostResolver.getVHost(#root)&quot;</code>。对于<code>send</code>操作，要发送的消息是根评估对象。对于<code>receive</code>操作，queueName 是根评估对象。</p>
<p>路由算法为：</p>
<ul>
<li>如果 selectors 表达式为null，或者计算为null，或者提供的ConnectionFactory不是<code>AbstractRoutingConnectionFactory</code>的实例，则所有操作都像以前一样，取决于提供的ConnectionFactory实现。</li>
<li>如果评估结果不是null，但是没有针对该lookupKey的目标ConnectionFactory，并且<code>AbstractRoutingConnectionFactory</code>配置为<code>lenientFallback = true</code>，则会发生相同的情况。</li>
<li>当然，在<code>AbstractRoutingConnectionFactory</code>的情况下，它会回退到基于<code>determineCurrentLookupKey()</code>的<code>routing</code>实现。但是，如果<code>lenientFallback = false</code>，则抛出<code>IllegalStateException</code>。</li>
</ul>
<p>命名空间支持还在<code>&lt;rabbit:template&gt;</code>组件上提供了<code>send-connection-factory-selector-expression</code>和<code>receive-connection-factory-selector-expression</code>属性。</p>
<p>同样从1.4开始，可以在侦听器容器中配置路由连接工厂。在这种情况下，队列名称列表将用作查找关键字。例如，如果您使用<code>setQueueNames(&quot;foo&quot;, &quot;bar&quot;)</code>配置容器，则查找键将为<code>&quot;[foo,bar]&quot;</code>(无空格)。</p>
<p>从版本 1.6.9 开始，可以使用侦听器容器上的<code>setLookupKeyQualifier</code>向查找键添加限定符。</p>
<p>例如，这将允许侦听具有相同名称但在不同虚拟主机中的队列(每个虚拟主机中都有一个连接工厂)。</p>
<p>例如，在使用查找键限定符<code>foo</code>和侦听队列<code>bar</code>的容器的情况下，用于注册目标连接工厂的查找键将是<code>foo[bar]</code>。</p>
<h4 id="（7）队列相似性和LocalizedQueueConnectionFactory"><a href="#（7）队列相似性和LocalizedQueueConnectionFactory" class="headerlink" title="（7）队列相似性和LocalizedQueueConnectionFactory"></a>（7）队列相似性和LocalizedQueueConnectionFactory</h4><p>在集群中使用HA队列时，为了获得最佳性能，可能需要连接到主队列所在的物理代理。 <code>CachingConnectionFactory</code>可以配置多个代理地址；这是为了进行故障转移，Client 端将尝试按 Sequences 连接。 </p>
<p><code>LocalizedQueueConnectionFactory</code>使用 Management 插件提供的 REST API 来确定要控制队列的节点。然后，它创建(或从缓存中检索)<code>CachingConnectionFactory</code>，该<code>CachingConnectionFactory</code>将仅连接到该节点。如果连接失败，那么将确定新的主节点，并且使用者将连接到该主节点。</p>
<p> <code>LocalizedQueueConnectionFactory</code>配置有默认的连接工厂，以防无法确定队列的物理位置，在这种情况下，它将正常连接到群集。</p>
<p><code>LocalizedQueueConnectionFactory</code>是<code>RoutingConnectionFactory</code>，而<code>SimpleMessageListenerContainer</code>使用队列名称作为查找关键字。</p>
<p>注意</p>
<ul>
<li>由于使用队列名称进行查找这个原因，只有在将容器配置为侦听单个队列时，才能使用<code>LocalizedQueueConnectionFactory</code>。</li>
<li>必须在每个节点上启用 RabbitMQManagement 插件。</li>
<li>此连接工厂用于长期连接，例如<code>SimpleMessageListenerContainer</code>使用的连接。它不适用于短连接，例如用于<code>RabbitTemplate</code>，因为在构建连接之前调用 REST API 会产生开销。同样，对于发布操作，队列是未知的，并且无论如何该消息都会发布给所有集群成员，因此查找节点的逻辑几乎没有价值。</li>
</ul>
<p>这是一个示例配置，使用 Spring Boot 的 RabbitProperties 配置工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitProperties props;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] adminUris = &#123; <span class="string">&quot;http://host1:15672&quot;</span>, <span class="string">&quot;http://host2:15672&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] nodes = &#123; <span class="string">&quot;[emailprotected]&quot;</span>, <span class="string">&quot;[emailprotected]&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">defaultConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory cf = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    cf.setAddresses(<span class="keyword">this</span>.props.getAddresses());</span><br><span class="line">    cf.setUsername(<span class="keyword">this</span>.props.getUsername());</span><br><span class="line">    cf.setPassword(<span class="keyword">this</span>.props.getPassword());</span><br><span class="line">    cf.setVirtualHost(<span class="keyword">this</span>.props.getVirtualHost());</span><br><span class="line">    <span class="keyword">return</span> cf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">queueAffinityCF</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Qualifier(&quot;defaultConnectionFactory&quot;)</span> ConnectionFactory defaultCF)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalizedQueueConnectionFactory(defaultCF,</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray(<span class="keyword">this</span>.props.getAddresses()),</span><br><span class="line">            <span class="keyword">this</span>.adminUris, <span class="keyword">this</span>.nodes,</span><br><span class="line">            <span class="keyword">this</span>.props.getVirtualHost(), <span class="keyword">this</span>.props.getUsername(), <span class="keyword">this</span>.props.getPassword(),</span><br><span class="line">            <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>请注意，前三个参数是<code>addresses</code>，<code>adminUris</code>和<code>nodes</code>的数组。这些是适当的，因为当容器尝试连接到队列时，它确定队列在哪个节点上被控制，并连接到同一阵列位置中的地址。</p>
<h4 id="（8）发布者确认并return"><a href="#（8）发布者确认并return" class="headerlink" title="（8）发布者确认并return"></a>（8）发布者确认并return</h4><p>通过将<code>CachingConnectionFactory</code>的<code>publisherConfirms</code>和<code>publisherReturns</code>属性分别设置为’true’，可以支持确认和返回的消息。</p>
<p>设置这些选项后，工厂创建的<code>Channel</code>将被包装在<code>PublisherCallbackChannel</code>中，方便回调。当获得这样的 Channels 时，Client 端可以向<code>Channel</code>注册<code>PublisherCallbackChannel.Listener</code>。 <code>PublisherCallbackChannel</code>实现包含将确认/返回路由到适当的侦听器的逻辑。</p>
<h4 id="（9）连接和-Channels-监听器"><a href="#（9）连接和-Channels-监听器" class="headerlink" title="（9）连接和 Channels 监听器"></a>（9）连接和 Channels 监听器</h4><p>连接工厂支持注册<code>ConnectionListener</code>和<code>ChannelListener</code>实现。这使您可以接收有关连接和通道相关事件的通知。 (构建连接时，<code>RabbitAdmin</code>使用<code>ConnectionListener</code>来执行声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> transactional)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（10）记录-Channels-关闭事件"><a href="#（10）记录-Channels-关闭事件" class="headerlink" title="（10）记录 Channels 关闭事件"></a>（10）记录 Channels 关闭事件</h4><p>在 1.5 版中引入了一种使用户能够控制日志记录级别的机制。</p>
<p><code>CachingConnectionFactory</code>使用默认策略记录通道关闭，如下所示：</p>
<ul>
<li>正常通道关闭(200 OK)不会被记录。</li>
<li>如果通道由于被动队列声明失败而关闭，那么它将在调试级别记录。</li>
<li>如果通道由于<code>basic.consume</code>由于特殊的使用者条件而被拒绝而关闭，则它将以 INFO 级别记录。</li>
<li>其他所有日志均以 ERROR 级别记录。</li>
</ul>
<p>若要修改此行为，请在其<code>closeExceptionLogger</code>属性中将自定义<code>ConditionalExceptionLogger</code>注入到<code>CachingConnectionFactory</code>中。</p>
<h4 id="（11）运行时缓存属性"><a href="#（11）运行时缓存属性" class="headerlink" title="（11）运行时缓存属性"></a>（11）运行时缓存属性</h4><p>从1.6开始，<code>CachingConnectionFactory</code> 通过<code>getCacheProperties()</code>方法提供了缓存统计信息。这些统计信息可用于调整缓存以在 Producing 对其进行优化。例如，高水位标记可用于确定是否应增加缓存大小。如果等于缓存大小，则可能要考虑进一步增加。</p>
<p><strong>表 3.1. CacheMode.CHANNEL 的缓存属性</strong></p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><code>connectionName</code></td>
<td><code>ConnectionNameStrategy</code>生成的连接的名称。</td>
</tr>
<tr>
<td><code>channelCacheSize</code></td>
<td>当前配置的允许空闲的最大通道数。</td>
</tr>
<tr>
<td><code>localPort</code></td>
<td>连接的本地端口(如果有)。这可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td>
</tr>
<tr>
<td><code>idleChannelsTx</code></td>
<td>当前空闲(缓存)的事务通道的数量。</td>
</tr>
<tr>
<td><code>idleChannelsNotTx</code></td>
<td>当前空闲(缓存)的非事务通道的数量。</td>
</tr>
<tr>
<td><code>idleChannelsTxHighWater</code></td>
<td>已同时空闲(缓存)的最大事务通道数。</td>
</tr>
<tr>
<td><code>idleChannelsNotTxHighWater</code></td>
<td>非事务通道的最大数量已被同时空闲(缓存)。</td>
</tr>
</tbody></table>
<p><strong>表 3.2. CacheMode.CONNECTION</strong> 的缓存属性</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><code>connectionName:&lt;localPort&gt;</code></td>
<td><code>ConnectionNameStrategy</code>生成的连接的名称。</td>
</tr>
<tr>
<td><code>openConnections</code></td>
<td>表示与代理的连接的连接对象的数量。</td>
</tr>
<tr>
<td><code>channelCacheSize</code></td>
<td>当前配置的允许空闲的最大通道数。</td>
</tr>
<tr>
<td><code>connectionCacheSize</code></td>
<td>当前配置的允许空闲的最大连接数。</td>
</tr>
<tr>
<td><code>idleConnections</code></td>
<td>当前空闲的连接数。</td>
</tr>
<tr>
<td><code>idleConnectionsHighWater</code></td>
<td>并发空闲的最大连接数。</td>
</tr>
<tr>
<td><code>idleChannelsTx:&lt;localPort&gt;</code></td>
<td>该连接当前空闲(缓存)的事务通道的数量。属性名称的 localPort 部分可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td>
</tr>
<tr>
<td><code>idleChannelsNotTx:&lt;localPort&gt;</code></td>
<td>该连接当前空闲(缓存)的非事务通道的数量。属性名称的 localPort 部分可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td>
</tr>
<tr>
<td>idleChannelsTxHighWater:</td>
<td></td>
</tr>
<tr>
<td>&lt;localPort&gt;</td>
<td>同时空闲(缓存)的最大事务通道数。属性名称的 localPort 部分可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td>
</tr>
<tr>
<td>idleChannelsNotTxHighWater: &lt;localPort&gt;</td>
<td>已同时空闲(缓存)的非事务通道的最大数量。属性名称的 localPort 部分可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td>
</tr>
</tbody></table>
<p><code>cacheMode</code>属性(还包括<code>CHANNEL</code>或<code>CONNECTION</code>)。</p>
<p><strong>图 3.1. JVisualVM 示例</strong></p>
<p><img src="https://www.docs4dev.com/images/spring-amqp/2.1.2.RELEASE/cacheStats.png" alt="cacheStats"></p>
<h4 id="（12）RabbitMQ-自动连接-拓扑恢复"><a href="#（12）RabbitMQ-自动连接-拓扑恢复" class="headerlink" title="（12）RabbitMQ 自动连接/拓扑恢复"></a>（12）RabbitMQ 自动连接/拓扑恢复</h4><p>从 Spring AMQP 的第一个版本开始，该框架在代理发生故障的情况下提供了自己的连接和通道恢复。另外，<code>RabbitAdmin</code> 将在重新构建连接时重新声明任何基础结构Bean(队列等)。因此，它不依赖<code>amqp-client</code>库现在提供的<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/api-guide.html#recovery">Auto Recovery</a>。 </p>
<p>Spring AMQP 现在使用<code>amqp-client</code>的<code>4.0.x</code>版本，默认情况下启用了自动恢复。如果愿意，Spring AMQP 仍可以使用其自己的恢复机制，在 Client 端中将其禁用(通过将基础<code>RabbitMQ connectionFactory</code>设置为<code>false</code>的<code>automaticRecoveryEnabled</code>属性)。</p>
<p>但是，该框架与启用的自动恢复完全兼容。这意味着您在代码中创建的所有使用者(可能通过<code>RabbitTemplate.execute()</code>)都可以自动恢复。</p>
<h3 id="3-4-添加自定义-Client-端连接属性"><a href="#3-4-添加自定义-Client-端连接属性" class="headerlink" title="3.4 添加自定义 Client 端连接属性"></a>3.4 添加自定义 Client 端连接属性</h3><p><code>CachingConnectionFactory</code> 允许访问基础连接工厂，以允许例如设置自定义 Client 端属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.getRabbitConnectionFactory().getClientProperties().put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>查看连接时，这些属性会显示在 RabbitMQ Management  UI 中。</p>
<h3 id="3-5-AmqpTemplate"><a href="#3-5-AmqpTemplate" class="headerlink" title="3.5 AmqpTemplate"></a>3.5 AmqpTemplate</h3><p><code>AmqpTemplate</code>接口定义了用于发送和接收消息的所有基本操作。</p>
<p>未完待续。</p>
<h4 id="（1）添加重试功能"><a href="#（1）添加重试功能" class="headerlink" title="（1）添加重试功能"></a>（1）添加重试功能</h4><h4 id="（2）发布是异步的-如何检测成功和失败"><a href="#（2）发布是异步的-如何检测成功和失败" class="headerlink" title="（2）发布是异步的-如何检测成功和失败"></a>（2）发布是异步的-如何检测成功和失败</h4><h4 id="（3）发布者确认并return"><a href="#（3）发布者确认并return" class="headerlink" title="（3）发布者确认并return"></a>（3）发布者确认并return</h4><h4 id="（4）Scoped-Operations"><a href="#（4）Scoped-Operations" class="headerlink" title="（4）Scoped Operations"></a>（4）Scoped Operations</h4><h4 id="（5）Messaging-integration"><a href="#（5）Messaging-integration" class="headerlink" title="（5）Messaging integration"></a>（5）Messaging integration</h4><h4 id="（6）已验证的用户ID"><a href="#（6）已验证的用户ID" class="headerlink" title="（6）已验证的用户ID"></a>（6）已验证的用户ID</h4><h4 id="（7）使用单独的连接"><a href="#（7）使用单独的连接" class="headerlink" title="（7）使用单独的连接"></a>（7）使用单独的连接</h4><h3 id="3-6-发送消息"><a href="#3-6-发送消息" class="headerlink" title="3.6 发送消息"></a>3.6 发送消息</h3><h4 id="（1）Message-Builder"><a href="#（1）Message-Builder" class="headerlink" title="（1）Message Builder"></a>（1）Message Builder</h4><h4 id="（2）Publisher-Returns"><a href="#（2）Publisher-Returns" class="headerlink" title="（2）Publisher Returns"></a>（2）Publisher Returns</h4><h4 id="（3）Batching"><a href="#（3）Batching" class="headerlink" title="（3）Batching"></a>（3）Batching</h4><h3 id="3-7-接收消息"><a href="#3-7-接收消息" class="headerlink" title="3.7 接收消息"></a>3.7 接收消息</h3><h4 id="（1）Polling-Consumer"><a href="#（1）Polling-Consumer" class="headerlink" title="（1）Polling Consumer"></a>（1）Polling Consumer</h4><h4 id="（2）Asynchronous-Consumer"><a href="#（2）Asynchronous-Consumer" class="headerlink" title="（2）Asynchronous Consumer"></a>（2）Asynchronous Consumer</h4><h4 id="（3）Message-Listener"><a href="#（3）Message-Listener" class="headerlink" title="（3）Message Listener"></a>（3）Message Listener</h4><h4 id="（4）MessageListenerAdapter"><a href="#（4）MessageListenerAdapter" class="headerlink" title="（4）MessageListenerAdapter"></a>（4）MessageListenerAdapter</h4><h4 id="（5）Container"><a href="#（5）Container" class="headerlink" title="（5）Container"></a>（5）Container</h4><h4 id="（6）Consumer-Priority"><a href="#（6）Consumer-Priority" class="headerlink" title="（6）Consumer Priority"></a>（6）Consumer Priority</h4><h4 id="（7）auto-delete-Queues"><a href="#（7）auto-delete-Queues" class="headerlink" title="（7）auto-delete Queues"></a>（7）auto-delete Queues</h4><h4 id="（8）Batched-Messages"><a href="#（8）Batched-Messages" class="headerlink" title="（8）Batched Messages"></a>（8）Batched Messages</h4><h4 id="（9）Consumer-Events"><a href="#（9）Consumer-Events" class="headerlink" title="（9）Consumer Events"></a>（9）Consumer Events</h4><h4 id="（10）Consumer-Tags"><a href="#（10）Consumer-Tags" class="headerlink" title="（10）Consumer Tags"></a>（10）Consumer Tags</h4><h4 id="（11）注解驱动的监听器端点"><a href="#（11）注解驱动的监听器端点" class="headerlink" title="（11）注解驱动的监听器端点"></a>（11）注解驱动的监听器端点</h4><h2 id="四-源码剖析"><a href="#四-源码剖析" class="headerlink" title="四. 源码剖析"></a>四. 源码剖析</h2><h3 id="4-1-RabbitMQ消费流程"><a href="#4-1-RabbitMQ消费流程" class="headerlink" title="4.1 RabbitMQ消费流程"></a>4.1 RabbitMQ消费流程</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010120.png"></p>
<h4 id="（1）启动流程"><a href="#（1）启动流程" class="headerlink" title="（1）启动流程"></a>（1）启动流程</h4><ol>
<li><p>通过<strong>BeanPostProcessor</strong>扫描所有的Bean中存在的 <code>@RabbitListener</code> 注解及相应的Method；</p>
</li>
<li><p>由<strong>RabbitListenerContainerFactory</strong>根据配置为每一个 <code>@RabbitListener</code> 注解创建一个<strong>MessageListenerContainer</strong>，持有 <code>@RabbitListener</code> 注解及Method信息；</p>
</li>
<li><p>初始化MessageListenerContainer，主要是循环依次创建Consumer（<strong>AsyncMessageProcessingConsumer</strong>），并启动Consumer；</p>
<p>创建Consumer，过程包括：</p>
<ul>
<li>创建<strong>AMQConnection</strong>，仅第一次创建。</li>
<li>创建<strong>AMQChannel</strong>，每个Consumer都会创建。</li>
<li>发送消费queue的请求（basic.consume），接收并处理消息。</li>
</ul>
</li>
<li><p>AMQConnection持有连接到Rabbitmq Server的Socket，创建完成后启动MainLoop循环从Socket流中读取Frame，此时流中没有消息，因为Channel还没创建完成；</p>
</li>
<li><p>创建AMQChannel（一个AMQConnection中持有多个AMQChannel），并将创建完成的Channel注册到AMQConnection持有的<strong>ConsumerWorkService</strong>，实际就是添加到<strong>WorkPool</strong>的Map里面去，此时Socket流中也没有消息，因为Channel还没有与Queue绑定；<br>创建完成的AMQChannel的代理返回给Consumer，Consumer通过Channel发送消费Queue的请求到Rabbitmq Server（绑定成功），此时还没开始处理消息，但Socket流中已经有消息，并且已经被Connection读取到内存（即 <code>BlockingQueue&lt;Runnable&gt;</code> ）中，并且已经开始向 <code>BlockingQueue&lt;Delivery&gt;</code> 分发；</p>
</li>
<li><p>Consumer启动循环，从 <code>BlockingQueue&lt;Delivery&gt;</code> 中取消息，利用MessageListenerContainer中持有的Method反射调用 <code>@RabbitListener</code> 注解方法处理消息。</p>
</li>
</ol>
<h4 id="（2）消费流程"><a href="#（2）消费流程" class="headerlink" title="（2）消费流程"></a>（2）消费流程</h4><ol>
<li>Rabbitmq Server往Socket流中写入字节。</li>
<li>AMQConnection启动一个main loop thread来跑MainLoop，不断从Socket流中读取字节转换成Frame对象，这是每个connection唯一的数据来源。</li>
<li>Consumer启动后，Connection读取到Frame。从basic.deliver开始是消息的内容，每条消息分成三个Frame：<ul>
<li>第一个是method，basic.deliver代表这是一个消息，后面一定会再跟着两个Frame；</li>
<li>第二个是message header；</li>
<li>第三个是message body，body读取之后将三个Frame整合到一起转换成一条完整的deliver命令。</li>
</ul>
</li>
<li>AMQConnection根据读取到的Frame中的type决定要怎么处理这个Frame（ <code>heartbeat(8) do nothing</code> )其它的根据channel编号交给相应的AMQChannel去处理，（编号为0的是特殊的channel，消息相关的用的都是编号非0的channel），消息都会拿着这个编号到<strong>ChannelManager</strong>找对应的ChannelN处理。</li>
<li>ChannelN经过一系列中间过程由Frame（消息是三个Frame）得到了Runnable，将 <code>&lt;ChannelN, Runnable&gt;</code> put 到 <strong>ConsumerWorkService</strong> 持有的 WorkPool 里面的一个 <code>Map&lt;Channel, BlockingQueue&lt;Runnable&gt;&gt;</code> 里面去。这样这个Runnable就进入了与ChannelN对应的 <code>BlockingQueue&lt;Runnable&gt;</code>（写死的size=1000）里面了。</li>
<li>execute一个<strong>WorkPoolRunnable</strong>，执行的任务是：<ul>
<li>从WorkPool中找出一个<strong>ready</strong>状态的ChannelN，把这个ChannelN设为<strong>inProgress</strong>状态；</li>
<li>从对应的 <code>BlockingQueue&lt;Runnable&gt;</code> 中取最多16个Runnable（写死）在WorkPoolRunnable的线程里依次执行（注意：此处不再另开线程，所以可能会堵塞当前线程，导致这个ChannelN长时间处于inProgress状态），执行完后将当前ChannelN状态改为ready，并在当前线程execute另一个WorkPoolRunnable。</li>
</ul>
</li>
<li><code>BlockingQueue&lt;Runnable&gt;</code> 里面的Runnable执行的逻辑是：构造一个Delivery并put到与ChannelN对应的<strong>AsyncMessageProcessingConsumer</strong>持有的 <code>BlockingQueue&lt;Delivery&gt;</code>（size=prefetchCount可配置）里面去（如果消息处理速度太慢，<code>BlockingQueue&lt;Delivery&gt;</code> 已满，此处会堵塞）。</li>
<li>每个AsyncMessageProcessingConsumer都有一个独立的线程在循环从 <code>BlockingQueue&lt;Delivery&gt;</code> 一次读取一个Delivery转换成Message反射调用 <code>@RabbitListener</code> 注解方法来处理。</li>
</ol>
<p>Frame对象结构如下：</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010121.png"></p>
<ul>
<li><strong>type</strong>：指定当前Frame的类型，如 <code>method(1)</code> 、<code>message header(2)</code> 、<code>message body(3)</code> 、<code>heartbeat(8)</code> 等；</li>
<li><strong>channel</strong>：channel的编号，从0~n排列，指定当前Frame需要交给哪个channel处理。channel-0为一类，channel-n为一类。<ul>
<li>channel-0是一个匿名类，用来处理特殊Frame，如connection.start。</li>
<li>channel-n都是ChannelN类，由ChannelManager类统一管理。</li>
</ul>
</li>
<li><strong>payload</strong>：当前Frame的具体内容。</li>
</ul>
<h4 id="（3）ack消费模式"><a href="#（3）ack消费模式" class="headerlink" title="（3）ack消费模式"></a>（3）ack消费模式</h4><p>根据以上对消费过程的分析，将无ack模式与ack模式进行对比。</p>
<ul>
<li><p><strong>无ack模式（AcknowledgeMode.NONE）</strong></p>
<ul>
<li>Server端行为：<ul>
<li>Rabbitmq Server默认推送的所有消息都已经消费成功，会不断地向消费端推送消息。</li>
<li>因为Rabbitmq Server认为推送的消息已被成功消费，所以推送出去的消息不会暂存在server端。</li>
</ul>
</li>
<li>消息丢失的风险：<ul>
<li>当 <code>BlockingQueue&lt;Runnable&gt;</code> 堆满时（ <code>BlockingQueue&lt;Delivery&gt;</code> 一定会先满），server端推送消息会失败，然后断开Connection。消费端从Socket读取Frame将会抛出SocketException，触发异常处理，shutdown掉Connection和所有的Channel，Channel shutdown后WorkPool中的Channel信息（包括Channel inProgress、channel ready以及Map）全部清空，所以 <code>BlockingQueue&lt;Runnable&gt;</code> 中的数据会全部丢失。</li>
<li>此外，服务重启时也需对内存中未处理完的消息做必要的处理，以免丢失。而在Rabbitmq Server，Connection断掉后就没有消费者去消费这个queue，因此在server端会看到消息堆积的现象。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>有ack模式（AcknowledgeMode.AUTO，AcknowledgeMode.MANUAL）</strong>：AcknowledgeMode.MANUAL模式需要人为地获取到Channel之后调用方法向Server发送ack（或消费失败时的nack）信息。AcknowledgeMode.AUTO模式下，由spring-rabbit依据消息处理逻辑是否抛出异常自动发送ack（无异常）或nack（异常）到server端。</p>
<ul>
<li>server端行为：<ul>
<li>Rabbitmq Server推送给每个Channel的消息数量有限制，会保证每个Channel没有收到ack的消息数量不会超过prefetchCount。</li>
<li>Server端会暂存没有收到ack的消息，等消费端ack后才会丢掉；</li>
<li>如果收到消费端的nack（消费失败的标识）或Connection断开没收到反馈，会将消息放回到原队列头部。</li>
</ul>
</li>
<li>性能：这种模式不会丢消息，但效率较低，因为server端需要等收到消费端的答复之后才会继续推送消息，当然，推送消息和等待答复是异步的，可适当增大prefetchCount提高效率。</li>
</ul>
</li>
</ul>
<p>注意，有ack的模式下，需要考虑 <code>setDefaultRequeueRejected(false)</code> ，否则当消费消息抛出异常没有catch住时，这条消息会被rabbitmq放回到queue头部，再被推送过来，然后再抛异常再放回…死循环了。设置false的作用是抛异常时不放回，而是直接丢弃，所以可能需要对这条消息做处理，以免丢失。</p>
<p>对比：</p>
<ul>
<li>无ack模式：效率高，存在丢失大量消息的风险。</li>
<li>有ack模式：效率低，不会丢消息。</li>
</ul>
<h3 id="4-2-RabbitTemplate"><a href="#4-2-RabbitTemplate" class="headerlink" title="4.2 RabbitTemplate"></a>4.2 RabbitTemplate</h3><h4 id="（1）接收消息"><a href="#（1）接收消息" class="headerlink" title="（1）接收消息"></a>（1）接收消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">receive</span><span class="params">(String queueName)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// receiveTimeOut参数为0，直接获取消息，不等待，获取不到返回null；否则会等待一段时间。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.receiveTimeout == <span class="number">0L</span> ? <span class="keyword">this</span>.doReceiveNoWait(queueName) : <span class="keyword">this</span>.receive(queueName, <span class="keyword">this</span>.receiveTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">receive</span><span class="params">(<span class="keyword">final</span> String queueName, <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 通过execute传入Lambda表达式执行</span></span><br><span class="line">	Message message = execute(channel -&gt; &#123;</span><br><span class="line">           <span class="comment">// 初始化Delivery</span></span><br><span class="line">		Delivery delivery = consumeDelivery(channel, queueName, timeoutMillis);</span><br><span class="line">		<span class="keyword">if</span> (delivery == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isChannelLocallyTransacted(channel)) &#123;</span><br><span class="line">				channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">				channel.txCommit();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (isChannelTransacted()) &#123;</span><br><span class="line">				ConnectionFactoryUtils.registerDeliveryTag(getConnectionFactory(), channel,</span><br><span class="line">						delivery.getEnvelope().getDeliveryTag());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> buildMessageFromDelivery(delivery);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	logReceived(message);</span><br><span class="line">	<span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Message是通过调用execute方法得到的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(ChannelCallback&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> execute(action, getConnectionFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ChannelCallback&lt;T&gt; action, <span class="keyword">final</span> ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若启用RetryTemplate重试机制</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.retryTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.retryTemplate.execute(</span><br><span class="line">					(RetryCallback&lt;T, Exception&gt;) context -&gt; doExecute(action, connectionFactory),</span><br><span class="line">					(RecoveryCallback&lt;T&gt;) <span class="keyword">this</span>.recoveryCallback);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">				<span class="keyword">throw</span> (RuntimeException) e;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 否则执行doExecute</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> doExecute(action, connectionFactory);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了Connection和Channel，执行action.doInRabbit()方法得到Message，关闭Channel和Connection。当然，这里Connection和Channel的创建和关闭都不一定是真的创建和关闭，与具体的实现有关，比如CachingConnectionFactory，它的实现就是有缓存的</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(ChannelCallback&lt;T&gt; action, ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 初始化channel和connection</span></span><br><span class="line">		<span class="keyword">if</span> (isChannelTransacted()) &#123;</span><br><span class="line">			resourceHolder = ConnectionFactoryUtils.</span><br><span class="line">				getTransactionalResourceHolder(connectionFactory, <span class="keyword">true</span>, <span class="keyword">this</span>.usePublisherConnection);</span><br><span class="line">			channel = resourceHolder.getChannel();</span><br><span class="line">			<span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">				ConnectionFactoryUtils.releaseResources(resourceHolder);</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Resource holder returned a null channel&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			connection = ConnectionFactoryUtils.createConnection(connectionFactory,</span><br><span class="line">					<span class="keyword">this</span>.usePublisherConnection); <span class="comment">// NOSONAR - RabbitUtils closes</span></span><br><span class="line">			<span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Connection factory returned a null connection&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				channel = connection.createChannel(<span class="keyword">false</span>);</span><br><span class="line">				<span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Connection returned a null channel&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">				RabbitUtils.closeConnection(connection);</span><br><span class="line">				<span class="keyword">throw</span> e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		...</span><br><span class="line">           <span class="comment">// action.doInRabbit()方法的实现逻辑就要再回到上面的receive方法，这里的action就是在那个receive方法传入的一个ChannelCallback的匿名内部实现类。</span></span><br><span class="line">		<span class="keyword">return</span> action.doInRabbit(channel);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!invokeScope) &#123;</span><br><span class="line">			<span class="keyword">if</span> (resourceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">				ConnectionFactoryUtils.releaseResources(resourceHolder);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				RabbitUtils.closeChannel(channel);</span><br><span class="line">				RabbitUtils.closeConnection(connection);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到最后返回的消息是从Delivery中得到的，那么看下Delivery是怎么来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Delivery <span class="title">consumeDelivery</span><span class="params">(Channel channel, String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Delivery delivery = <span class="keyword">null</span>;</span><br><span class="line">	RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 异步执行</span></span><br><span class="line">	CompletableFuture&lt;Delivery&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">	DefaultConsumer consumer = createConsumer(queueName, channel, future,</span><br><span class="line">			timeoutMillis &lt; <span class="number">0</span> ? DEFAULT_CONSUME_TIMEOUT : timeoutMillis);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 阻塞式的等待返回结果，receive方法中传入的receiveTimeout参数也正是在这里用到的</span></span><br><span class="line">		<span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			delivery = future.get();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			delivery = future.get(timeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">		Throwable cause = e.getCause();</span><br><span class="line">		<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer failed to receive message: &quot;</span> + consumer, cause);</span><br><span class="line">		exception = RabbitExceptionTranslator.convertRabbitAccessException(cause);</span><br><span class="line">		<span class="keyword">throw</span> exception;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		Thread.currentThread().interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">		<span class="comment">// no result in time</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (exception == <span class="keyword">null</span> || !(exception <span class="keyword">instanceof</span> ConsumerCancelledException)) &#123;</span><br><span class="line">			cancelConsumerQuietly(channel, consumer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> delivery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步注册消费者</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> DefaultConsumer <span class="title">createConsumer</span><span class="params">(<span class="keyword">final</span> String queueName, Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">		CompletableFuture&lt;Delivery&gt; future, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 之前初始化的channel，控制流量为1</span></span><br><span class="line">	channel.basicQos(<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 等待其它线程完成</span></span><br><span class="line">	<span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 初始化消费者</span></span><br><span class="line">	DefaultConsumer consumer = <span class="keyword">new</span> TemplateConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCancel</span><span class="params">(String consumerTag)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">			future.completeExceptionally(<span class="keyword">new</span> ConsumerCancelledException());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 执行完basicConsume，消费者注册成功会回调该函数</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleConsumeOk</span><span class="params">(String consumerTag)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.handleConsumeOk(consumerTag);</span><br><span class="line">               <span class="comment">// latch-1</span></span><br><span class="line">			latch.countDown();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">				<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">			future.complete(<span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">       <span class="comment">// 推模式消费消息</span></span><br><span class="line">	channel.basicConsume(queueName, consumer);</span><br><span class="line">       <span class="comment">// 如果消费者注册超时</span></span><br><span class="line">	<span class="keyword">if</span> (!latch.await(timeoutMillis, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">           <span class="comment">// Cache模式关闭代理信道</span></span><br><span class="line">		<span class="keyword">if</span> (channel <span class="keyword">instanceof</span> ChannelProxy) &#123;</span><br><span class="line">			((ChannelProxy) channel).getTargetChannel().close();</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">// 将过程中的异常抛出</span></span><br><span class="line">		future.completeExceptionally(</span><br><span class="line">				<span class="keyword">new</span> ConsumeOkNotReceivedException(<span class="string">&quot;Blocking receive, consumer failed to consume: &quot;</span> + consumer));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-3-RabbitListener注解"><a href="#4-3-RabbitListener注解" class="headerlink" title="4.3 @RabbitListener注解"></a>4.3 @RabbitListener注解</h3><p>通过注解的方式方便地接收消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;test_queue_delay&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>进入@RabbitListener注解源码，有一段注释说明了这个注解是怎么被处理的，通过注册一个RabbitListenerAnnotationBeanPostProcessor：</p>
<blockquote>
<p>Processing of {@code @RabbitListener} annotations is performed by registering a<br>{@link RabbitListenerAnnotationBeanPostProcessor}. This can be done manually or, more<br>conveniently, through the {@code rabbit:annotation-driven/} element or<br>{@link EnableRabbit} annotation.</p>
</blockquote>
<p>找到RabbitListenerAnnotationBeanPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, <span class="keyword">final</span> String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	Class&lt;?&gt; targetClass = AopUtils.getTargetClass(bean);</span><br><span class="line">	<span class="keyword">final</span> TypeMetadata metadata = <span class="keyword">this</span>.typeCache.computeIfAbsent(targetClass, <span class="keyword">this</span>::buildMetadata);</span><br><span class="line">       <span class="comment">// 当bean初始化完成后，在这里会获取到这个bean的类用户自己定义的所有添加了@RabbitListener注解的方法</span></span><br><span class="line">	<span class="keyword">for</span> (ListenerMethod lm : metadata.listenerMethods) &#123;</span><br><span class="line">		<span class="keyword">for</span> (RabbitListener rabbitListener : lm.annotations) &#123;</span><br><span class="line">               <span class="comment">// 然后调用processAmqpListener()方法对这些方法进行处理，实际上是对方法上的@RabbitListener进行处理，一个方法上可以有多个@RabbitListener，会处理多次</span></span><br><span class="line">			processAmqpListener(rabbitListener, lm.method, bean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 类级别注释处理</span></span><br><span class="line">	<span class="keyword">if</span> (metadata.handlerMethods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		processMultiMethodListeners(metadata.classAnnotations, metadata.handlerMethods, bean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>获取 <code>@RabbitListener</code> 注解方法的具体过程看 <code>buildMetadata()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在这个方法里面，找出了所有加了@RabbitListener注解的方法</span></span><br><span class="line"><span class="comment">//可以在类上加@RabbitListener注解，然后在方法上加@RabbitHandler注解，如果采用这种方式会processMultiMethodListeners()方法来处理这些方法。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> TypeMetadata <span class="title">buildMetadata</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 先找到类级别注释</span></span><br><span class="line">	Collection&lt;RabbitListener&gt; classLevelListeners = findListenerAnnotations(targetClass);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> hasClassLevelListeners = classLevelListeners.size() &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> List&lt;ListenerMethod&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">final</span> List&lt;Method&gt; multiMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	ReflectionUtils.doWithMethods(targetClass, method -&gt; &#123;</span><br><span class="line">           <span class="comment">// 找到方法级别注释，记录对应方法</span></span><br><span class="line">		Collection&lt;RabbitListener&gt; listenerAnnotations = findListenerAnnotations(method);</span><br><span class="line">		<span class="keyword">if</span> (listenerAnnotations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			methods.add(<span class="keyword">new</span> ListenerMethod(method,</span><br><span class="line">					listenerAnnotations.toArray(<span class="keyword">new</span> RabbitListener[listenerAnnotations.size()])));</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">// 类级别注释找到对应方法</span></span><br><span class="line">		<span class="keyword">if</span> (hasClassLevelListeners) &#123;</span><br><span class="line">			RabbitHandler rabbitHandler = AnnotationUtils.findAnnotation(method, RabbitHandler.class);</span><br><span class="line">			<span class="keyword">if</span> (rabbitHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">				multiMethods.add(method);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line">	<span class="keyword">if</span> (methods.isEmpty() &amp;&amp; multiMethods.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> TypeMetadata.EMPTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> TypeMetadata(</span><br><span class="line">			methods.toArray(<span class="keyword">new</span> ListenerMethod[methods.size()]),</span><br><span class="line">			multiMethods.toArray(<span class="keyword">new</span> Method[multiMethods.size()]),</span><br><span class="line">			classLevelListeners.toArray(<span class="keyword">new</span> RabbitListener[classLevelListeners.size()]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们只看processAmqpListener()方法，看它是怎么处理上面找到的这些方法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAmqpListener</span><span class="params">(RabbitListener rabbitListener, Method method, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将每一个加@RabbitListener注解的方法构造一个MethodRabbitListenerEndpoint，然后调用processListener()</span></span><br><span class="line">      Method methodToUse = checkProxy(method, bean);</span><br><span class="line">      MethodRabbitListenerEndpoint endpoint = <span class="keyword">new</span> MethodRabbitListenerEndpoint();</span><br><span class="line">      endpoint.setMethod(methodToUse);</span><br><span class="line">      processListener(endpoint, rabbitListener, bean, methodToUse, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processListener</span><span class="params">(MethodRabbitListenerEndpoint endpoint, RabbitListener rabbitListener, Object bean,</span></span></span><br><span class="line"><span class="params"><span class="function">	    Object adminTarget, String beanName)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   	<span class="comment">// 省略的部分是读取@RabbitListener注解中的值，设置到endpoint中去</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">       <span class="comment">// endpoint的属性都设置完了之后，获取我们配置的RabbitListenerContainerFactory bean，然后调用RabbitListenerEndpointRegistrar类的registerEndpoint()方法</span></span><br><span class="line">	RabbitListenerContainerFactory&lt;?&gt; factory = <span class="keyword">null</span>;</span><br><span class="line">	String containerFactoryBeanName = resolve(rabbitListener.containerFactory());</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasText(containerFactoryBeanName)) &#123;</span><br><span class="line">		Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">&quot;BeanFactory must be set to obtain container factory by bean name&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			factory = <span class="keyword">this</span>.beanFactory.getBean(containerFactoryBeanName, RabbitListenerContainerFactory.class);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Could not register rabbit listener endpoint on [&quot;</span> +</span><br><span class="line">					adminTarget + <span class="string">&quot;] for bean &quot;</span> + beanName + <span class="string">&quot;, no &quot;</span> + RabbitListenerContainerFactory.class.getSimpleName() + <span class="string">&quot; with id &#x27;&quot;</span> +</span><br><span class="line">					containerFactoryBeanName + <span class="string">&quot;&#x27; was found in the application context&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.registrar.registerEndpoint(endpoint, factory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEndpoint</span><span class="params">(RabbitListenerEndpoint endpoint, RabbitListenerContainerFactory&lt;?&gt; factory)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(endpoint, <span class="string">&quot;Endpoint must be set&quot;</span>);</span><br><span class="line">	Assert.hasText(endpoint.getId(), <span class="string">&quot;Endpoint id must be set&quot;</span>);</span><br><span class="line">	<span class="comment">// Factory may be null, we defer the resolution right before actually creating the container</span></span><br><span class="line">	AmqpListenerEndpointDescriptor descriptor = <span class="keyword">new</span> AmqpListenerEndpointDescriptor(endpoint, factory);</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">           <span class="comment">// 根据startImmediately看是否需要立刻注册endpoint，或者先将其添加到一个List，稍后统一注册</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.startImmediately) &#123; <span class="comment">// Register and start immediately</span></span><br><span class="line">			<span class="keyword">this</span>.endpointRegistry.registerListenerContainer(descriptor.endpoint,</span><br><span class="line">					resolveContainerFactory(descriptor), <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.endpointDescriptors.add(descriptor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于统一注册的实现，RabbitListenerAnnotationBeanPostProcessor类除了实现BeanPostProcessor以外，还实现了SmartInitializingSingleton接口，所以当RabbitListenerAnnotationBeanPostProcessor这个bean实例化完成之后会调用它的 <code>afterSingletonsInstantiated()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Actually register all listeners</span></span><br><span class="line">       <span class="comment">// 因为之前已经将所有的endpoint添加到了RabbitListenerEndpointRegistrar类中的一个List中了，所以这里调用RabbitListenerEndpointRegistrar类的afterPropertiesSet()方法进行统一注册</span></span><br><span class="line">	<span class="keyword">this</span>.registrar.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 不管是单独注册endpoint还是统一注册，调用的是同样的方法registerAllEndpoints()</span></span><br><span class="line">	registerAllEndpoints();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerAllEndpoints</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">           <span class="comment">// for循环，一个一个注册</span></span><br><span class="line">		<span class="keyword">for</span> (AmqpListenerEndpointDescriptor descriptor : <span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">			<span class="keyword">this</span>.endpointRegistry.registerListenerContainer(</span><br><span class="line">					descriptor.endpoint, resolveContainerFactory(descriptor));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.startImmediately = <span class="keyword">true</span>;  <span class="comment">// trigger immediate startup</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>跟踪 <code>registerListenerContainer()</code> 方法查看具体是怎么注册的，直到进入下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListenerContainer</span><span class="params">(RabbitListenerEndpoint endpoint, RabbitListenerContainerFactory&lt;?&gt; factory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">boolean</span> startImmediately)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(endpoint, <span class="string">&quot;Endpoint must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(factory, <span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	String id = endpoint.getId();</span><br><span class="line">	Assert.hasText(id, <span class="string">&quot;Endpoint id must not be empty&quot;</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.listenerContainers) &#123;</span><br><span class="line">		Assert.state(!<span class="keyword">this</span>.listenerContainers.containsKey(id),</span><br><span class="line">				<span class="string">&quot;Another endpoint is already registered with id &#x27;&quot;</span> + id + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		MessageListenerContainer container = createListenerContainer(endpoint, factory);</span><br><span class="line">		<span class="keyword">this</span>.listenerContainers.put(id, container);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(endpoint.getGroup()) &amp;&amp; <span class="keyword">this</span>.applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">			List&lt;MessageListenerContainer&gt; containerGroup;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext.containsBean(endpoint.getGroup())) &#123;</span><br><span class="line">				containerGroup = <span class="keyword">this</span>.applicationContext.getBean(endpoint.getGroup(), List.class);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				containerGroup = <span class="keyword">new</span> ArrayList&lt;MessageListenerContainer&gt;();</span><br><span class="line">				<span class="keyword">this</span>.applicationContext.getBeanFactory().registerSingleton(endpoint.getGroup(), containerGroup);</span><br><span class="line">			&#125;</span><br><span class="line">			containerGroup.add(container);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (startImmediately) &#123;</span><br><span class="line">			startIfNecessary(container);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可见，注册endpoint，实际上就是RabbitListenerContainerFactory将每一个endpoint都创建成MessageListenerContainer（具体创建过程，由RabbitListenerContainerFactory类自己去完成），然后根据startImmediately参数判断是否调用startIfNecessary()方法立即启动MessageListenerContainer。</p>
<p>实际接收消息是由这个MessageListenerContainer来做的，而MessageListenerContainer接口中有一个接口方法来设置MessageListener：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Setup the message listener to use. Throws an &#123;<span class="doctag">@link</span> IllegalArgumentException&#125;</span></span><br><span class="line"><span class="comment"> * if that message listener type is not supported.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> messageListener the &#123;<span class="doctag">@code</span> object&#125; to wrapped to the &#123;<span class="doctag">@code</span> MessageListener&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupMessageListener</span><span class="params">(Object messageListener)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>MessageListener将会调用我们加了@RabbitListener注解的方法处理消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Listener interface to receive asynchronous delivery of Amqp Messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Pollack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gary Russell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>或者是ChannelAwareMessageListener接口类来调用我们的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A message listener that is aware of the Channel on which the message was received.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Pollack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gary Russell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Callback for processing a received Rabbit message.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Implementors are supposed to process the given Message,</span></span><br><span class="line"><span class="comment">	 * typically sending reply messages through the given Session.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> message the received AMQP message (never &lt;code&gt;null&lt;/code&gt;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> channel the underlying Rabbit Channel (never &lt;code&gt;null&lt;/code&gt;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception Any.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这样接收并处理消息的所有工作就完成了。</p>
<p>如果不立即启动MessageListenerContainer，RabbitListenerEndpointRegistry也实现了SmartLifecycle接口，所以在spring context refresh的最后一步会去调用start()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (MessageListenerContainer listenerContainer : getListenerContainers()) &#123;</span><br><span class="line">		startIfNecessary(listenerContainer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可以看到在这里统一启动了所有的MessageListenerContainer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startIfNecessary</span><span class="params">(MessageListenerContainer listenerContainer)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.contextRefreshed || listenerContainer.isAutoStartup()) &#123;</span><br><span class="line">		listenerContainer.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>所谓启动MessageListenerContainer其实就是调用MessageListenerContainer的start()方法。这也是SmartLifecycle的一个接口方法，它的实现必须保证调用了这个start()方法之后MessageListenerContainer将能够接受到消息。</p>
<p>所以对@RabbitListener注解的整个处理流程就是这样。</p>
<p>总结一下整个实现流程：</p>
<ul>
<li>@RabbitListener注解的方法所在的类首先是一个bean，因此，实现BeanPostProcessor接口对每一个初始化完成的bean进行处理。</li>
<li>遍历bean中由用户自己定义的所有的方法，找出其中添加了@RabbitListener注解的方法（也可以是@RabbitHandler注解，上面已经讲了，不再赘述）。</li>
<li>读取上面找出的所有方法上@RabbitListener注解中的值，并为每一个方法创建一个RabbitListenerEndpoint，保存在RabbitListenerEndpointRegistrar类中。</li>
<li>在所有的bean都初始化完成，即所有@RabbitListener注解的方法都创建了endpoint之后，由我们配置的RabbitListenerContainerFactory将每个endpoint创建MessageListenerContainer。</li>
<li>最后启动上面创建的MessageListenerContainer。</li>
<li>至此，全部完成，MessageListenerContainer启动后将能够接受到消息，再将消息交给它的MessageListener处理消息。</li>
</ul>
<p>下面还剩下几件事情才能真正实现上面的步骤：</p>
<ul>
<li>RabbitListenerContainerFactory只是个接口，它不会自己创建</li>
<li>MessageListenerContainer，所以需要一个RabbitListenerContainerFactory实现类，它必须能创建MessageListenerContainer。<br>MessageListenerContainer也只是一个接口，它不会自己接收消息，所以需要一个MessageListenerContainer实现类，它必须做到在启动后能够接收消息，同时它必须能设置MessageListener，用以处理消息。</li>
<li>MessageListener（或ChannelAwareMessageListener）也只是一个接口，所以还需要一个MessageListener实现类，它必须能调用我们加了@RabbitListener注解的方法。</li>
</ul>
<h3 id="4-5-SimpleMessageListenerContainer"><a href="#4-5-SimpleMessageListenerContainer" class="headerlink" title="4.5 SimpleMessageListenerContainer"></a>4.5 SimpleMessageListenerContainer</h3><h4 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h4><p><code>SimpleMessageListenerContainer</code>是<code>spring</code>在<code>rabbitmq</code>原生<code>api</code>基础上封装实现的一个消费工具类，该类非常强大，可以实现：</p>
<ul>
<li>监听单个或多个队列</li>
<li>自动启动</li>
<li>自动声明</li>
<li>还支持动态配置，如动态添加监听队列、动态调整并发数等等。</li>
</ul>
<p>基本上对<code>RabbitMQ</code>消费场景这个类都能满足。如<code>@RabbitListener</code>、cloud-stream中<code>StreamListener</code>中底层实现都是基于该类，所以理解<code>SimpleMessageListenerContainer</code>原理对理解<code>spring rabbitmq</code>中消费模型非常关键。</p>
<h4 id="（2）基本使用"><a href="#（2）基本使用" class="headerlink" title="（2）基本使用"></a>（2）基本使用</h4><p>运行时添加/移除监听队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串集合动态添加到queueNames中</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueueNames</span><span class="params">(String... queueName)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.addQueueNames(queueName);</span><br><span class="line">       <span class="keyword">this</span>.queuesChanged();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeQueueNames</span><span class="params">(String... queueName)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">super</span>.removeQueueNames(queueName)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.queuesChanged();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object consumersMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">   <span class="keyword">private</span> Set&lt;BlockingQueueConsumer&gt; consumers;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queuesChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.consumersMonitor) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.consumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">// 遍历消费者集合，依次取消订阅并移出集合</span></span><br><span class="line">               <span class="keyword">for</span>(Iterator consumerIterator = <span class="keyword">this</span>.consumers.iterator(); consumerIterator.hasNext(); ++count) &#123;</span><br><span class="line">                   BlockingQueueConsumer consumer = (BlockingQueueConsumer)consumerIterator.next();</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Queues changed; stopping consumer: &quot;</span> + consumer);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 取消订阅</span></span><br><span class="line">                   consumer.basicCancel(<span class="keyword">true</span>);</span><br><span class="line">                   consumerIterator.remove();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 再重新创建消费者</span></span><br><span class="line">               <span class="keyword">this</span>.addAndStartConsumers(count);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addAndStartConsumers</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.consumersMonitor) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.consumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 创建指定数目的消费者</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta &amp;&amp; (<span class="keyword">this</span>.maxConcurrentConsumers == <span class="keyword">null</span> || <span class="keyword">this</span>.consumers.size() &lt; <span class="keyword">this</span>.maxConcurrentConsumers); ++i) &#123;</span><br><span class="line">                   <span class="comment">// 使用该类默认值/创建模板时指定的参数来构建消费者</span></span><br><span class="line">                   BlockingQueueConsumer consumer = <span class="keyword">this</span>.createBlockingQueueConsumer();</span><br><span class="line">                   <span class="comment">// 加回集合</span></span><br><span class="line">                   <span class="keyword">this</span>.consumers.add(consumer);</span><br><span class="line">                   <span class="comment">// 异步启动消费者</span></span><br><span class="line">                   SimpleMessageListenerContainer.AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> SimpleMessageListenerContainer.AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Starting a new consumer: &quot;</span> + consumer);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.getTaskExecutor().execute(processor);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 发布事件</span></span><br><span class="line">                       <span class="keyword">this</span>.getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">// 若启动流程有异常（getStartupException阻塞等待结果），则从集合移出消费者，并终止消费者</span></span><br><span class="line">                       FatalListenerStartupException startupException = processor.getStartupException();</span><br><span class="line">                       <span class="keyword">if</span> (startupException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 多余的一行？</span></span><br><span class="line">                           <span class="keyword">this</span>.consumers.remove(consumer);</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIllegalStateException(<span class="string">&quot;Fatal exception on listener startup&quot;</span>, startupException);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException var8) &#123;</span><br><span class="line">                       Thread.currentThread().interrupt();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                       consumer.stop();</span><br><span class="line">                       <span class="keyword">this</span>.logger.error(<span class="string">&quot;Error starting new consumer&quot;</span>, var9);</span><br><span class="line">                       <span class="keyword">this</span>.cancellationLock.release(consumer);</span><br><span class="line">                       <span class="keyword">this</span>.consumers.remove(consumer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>后置处理器 <code>setAfterReceivePostProcessors()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置处理器，接收到的消息都添加了Header请求头</span></span><br><span class="line">container.setAfterReceivePostProcessors(message -&gt; &#123;</span><br><span class="line">       message.getMessageProperties().getHeaders().put(<span class="string">&quot;desc&quot;</span>, <span class="number">10</span>); </span><br><span class="line">       <span class="keyword">return</span> message;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">container.setMessageListener((MessageListener) message -&gt; &#123; </span><br><span class="line">       System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">       System.out.println(message.getMessageProperties()); </span><br><span class="line">       System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>



<p>设置消费者的tag和Arguments：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置消费者的Consumer tag</span></span><br><span class="line">container.setConsumerTagStrategy(queue -&gt; <span class="string">&quot;order_queue_&quot;</span>+(++count));</span><br><span class="line"><span class="comment">// 设置消费者的Arguments</span></span><br><span class="line">Map args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;module&quot;</span>,<span class="string">&quot;订单模块&quot;</span>);</span><br><span class="line">args.put(<span class="string">&quot;fun&quot;</span>,<span class="string">&quot;发送消息&quot;</span>);</span><br><span class="line">container.setConsumerArguments(args);</span><br></pre></td></tr></table></figure>



<p><img src="https://res-static.hc-cdn.cn/fms/img/e30c505f6dfcc7704eb104d6169c202c1612517532882" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析1"></p>
<p>设置并发消费者：</p>
<ul>
<li>setConcurrentConsumers设置多个并发消费者一起消费，并支持运行时动态修改。</li>
<li>setMaxConcurrentConsumers设置最多的并发消费者。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123; </span><br><span class="line">       SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">       container.setConnectionFactory(connectionFactory);</span><br><span class="line">       container.setQueueNames(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">       container.setConcurrentConsumers(<span class="number">5</span>); </span><br><span class="line">       container.setMaxConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">       container.setMessageListener((MessageListener) message -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">           System.out.println(message.getMessageProperties()); </span><br><span class="line">           System.out.println(<span class="keyword">new</span> String(message.getBody())); </span><br><span class="line">       &#125;); </span><br><span class="line">       <span class="keyword">return</span> container; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="（3）核心原理"><a href="#（3）核心原理" class="headerlink" title="（3）核心原理"></a>（3）核心原理</h4><p>API结构：</p>
<p><code>SimpleMessageListenerContainer</code>类结构如下：</p>
<p><img src="https://res-static.hc-cdn.cn/fms/img/7f0590fab310e55f8ae8dc0d28d7fd161612517532882" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析2"></p>
<p>方法入口：</p>
<p><code>SimpleMessageListenerContainer</code> 类启动的入口是 <code>start()</code> 方法，该方法位于父类 <code>AbstractMessageListenerContainer</code> 中：</p>
<h5 id="AbstractMessageListenerContainer-start"><a href="#AbstractMessageListenerContainer-start" class="headerlink" title="AbstractMessageListenerContainer#start"></a>AbstractMessageListenerContainer#start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已启动，则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isRunning()) &#123;</span><br><span class="line">        <span class="comment">// initialized未执行初始化，则执行afterPropertiesSet()方法进行初始化，执行完成后initialized设置成true</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.lifecycleMonitor) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.afterPropertiesSet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Starting Rabbit listener container.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 验证RabbitAdmin，mismatchedQueuesFatal=true时，spring context中RabbitAdmin数量不能大于1</span></span><br><span class="line">            <span class="keyword">this</span>.configureAdminIfNeeded();</span><br><span class="line">            <span class="comment">// 执行RabbitAdmin#initialize方法，spring context中注入的exchanges, queues and bindings执行声明式创建</span></span><br><span class="line">            <span class="keyword">this</span>.checkMismatchedQueues();</span><br><span class="line">            <span class="comment">// 启动核心</span></span><br><span class="line">            <span class="keyword">this</span>.doStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">this</span>.convertRabbitAccessException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="SimpleMessageListenerContainer-doStart"><a href="#SimpleMessageListenerContainer-doStart" class="headerlink" title="SimpleMessageListenerContainer#doStart"></a>SimpleMessageListenerContainer#doStart</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.lifecycleMonitor) &#123;</span><br><span class="line">           <span class="keyword">this</span>.active = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">this</span>.lifecycleMonitor.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 如果MessageListener是ListenerContainerAware，则进行expectedQueueNames校验</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListener() <span class="keyword">instanceof</span> ListenerContainerAware) &#123;</span><br><span class="line">           Collection&lt;String&gt; expectedQueueNames = ((ListenerContainerAware)<span class="keyword">this</span>.getMessageListener()).expectedQueueNames();</span><br><span class="line">           <span class="keyword">if</span> (expectedQueueNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">               String[] queueNames = <span class="keyword">this</span>.getQueueNames();</span><br><span class="line">               Assert.state(expectedQueueNames.size() == queueNames.length, <span class="string">&quot;Listener expects us to be listening on &#x27;&quot;</span> + expectedQueueNames + <span class="string">&quot;&#x27;; our queues: &quot;</span> + Arrays.asList(queueNames));</span><br><span class="line">               <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">               String[] var4 = queueNames;</span><br><span class="line">               <span class="keyword">int</span> var5 = queueNames.length;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> var6 = <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">                   String queueName = var4[var6];</span><br><span class="line">                   <span class="keyword">if</span> (!expectedQueueNames.contains(queueName)) &#123;</span><br><span class="line">                       found = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   found = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Assert.state(found, () -&gt; &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&quot;Listener expects us to be listening on &#x27;&quot;</span> + expectedQueueNames + <span class="string">&quot;&#x27;; our queues: &quot;</span> + Arrays.asList(queueNames);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调用父类doStart()方法，主要是active和running都设置成true</span></span><br><span class="line">       <span class="keyword">super</span>.doStart();</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.consumersMonitor) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.consumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;A stopped container should not have consumers&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 创建BlockingQueueConsumer类型consumer，每个concurrentConsumers并发对应创建一个对象，并存储到Set consumers集合中，返回值就是创建consumer对象个数</span></span><br><span class="line">               <span class="comment">// 具体创建逻辑见：SimpleMessageListenerContainer#createBlockingQueueConsumer</span></span><br><span class="line">               <span class="comment">// 主要注意下prefetchCount计算： int actualPrefetchCount = getPrefetchCount() &gt; this.batchSize ? getPrefetchCount() : this.batchSize;</span></span><br><span class="line">               <span class="comment">// 即如果prefetchCount大于batchSize，则其就是实际值，否则prefetchCount等于batchSize值</span></span><br><span class="line">               <span class="keyword">int</span> newConsumers = <span class="keyword">this</span>.initializeConsumers();</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.consumers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.logger.info(<span class="string">&quot;Consumers were initialized and then cleared (presumably the container was stopped concurrently)&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newConsumers &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.logger.info(<span class="string">&quot;Consumers are already running&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   Set&lt;SimpleMessageListenerContainer.AsyncMessageProcessingConsumer&gt; processors = <span class="keyword">new</span> HashSet();</span><br><span class="line">                   Iterator var12 = <span class="keyword">this</span>.consumers.iterator();</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">while</span>(var12.hasNext()) &#123;</span><br><span class="line">     					<span class="comment">// 将BlockingQueueConsumer对象封装成AsyncMessageProcessingConsumer进行异步执行 </span></span><br><span class="line">                       BlockingQueueConsumer consumer = (BlockingQueueConsumer)var12.next();</span><br><span class="line">                       SimpleMessageListenerContainer.AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> SimpleMessageListenerContainer.AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">                       <span class="comment">// 存储到processors集合中 </span></span><br><span class="line">                       processors.add(processor);</span><br><span class="line">                       <span class="comment">// 将AsyncMessageProcessingConsumer丢到线程池中执行</span></span><br><span class="line">                       <span class="keyword">this</span>.getTaskExecutor().execute(processor);</span><br><span class="line">                       <span class="comment">// 事件发送</span></span><br><span class="line">                       <span class="keyword">if</span> (<span class="keyword">this</span>.getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   var12 = processors.iterator();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 判断启动过程中是否存在异常</span></span><br><span class="line">                   FatalListenerStartupException startupException;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!var12.hasNext()) &#123;</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       SimpleMessageListenerContainer.AsyncMessageProcessingConsumer processor = (SimpleMessageListenerContainer.AsyncMessageProcessingConsumer)var12.next();</span><br><span class="line">                       startupException = processor.getStartupException();</span><br><span class="line">                   &#125; <span class="keyword">while</span>(startupException == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIllegalStateException(<span class="string">&quot;Fatal exception on listener startup&quot;</span>, startupException);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>上面代码大致逻辑：<code>BlockingQueueConsumer</code> 对象可以看成 <code>consumer</code> ，然后将其包装成 <code>AsyncMessageProcessingConsumer</code> 异步任务丢入到线程池中运行。</p>
<p>异步任务：主要接口为AsyncMessageProcessingConsumer#run。</p>
<h5 id="AsyncMessageProcessingConsumer-run"><a href="#AsyncMessageProcessingConsumer-run" class="headerlink" title="AsyncMessageProcessingConsumer#run"></a>AsyncMessageProcessingConsumer#run</h5><ol>
<li>若当前consumer没有设置任何监听队列，则没必要启动</li>
<li>初始化：<ul>
<li>通过AmqpAdmin重新声明创建交换器、队列、绑定。</li>
<li></li>
</ul>
</li>
<li>死循环</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 必须处于活跃状态</span></span><br><span class="line">         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive()) &#123;</span><br><span class="line">             <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">int</span> consecutiveIdles = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> consecutiveMessages = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">this</span>.consumer.setLocallyTransacted(SimpleMessageListenerContainer.<span class="keyword">this</span>.isChannelLocallyTransacted());</span><br><span class="line">             String routingLookupKey = SimpleMessageListenerContainer.<span class="keyword">this</span>.getRoutingLookupKey();</span><br><span class="line">             <span class="keyword">if</span> (routingLookupKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 SimpleResourceHolder.bind(SimpleMessageListenerContainer.<span class="keyword">this</span>.getRoutingConnectionFactory(), routingLookupKey);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表示当前consumer没有设置任何监听队列，则没必要启动</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.consumer.getQueueCount() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Consumer stopping; no queues for &quot;</span> + <span class="keyword">this</span>.consumer);</span><br><span class="line">                 &#125;</span><br><span class="line">                 SimpleMessageListenerContainer.<span class="keyword">this</span>.cancellationLock.release(<span class="keyword">this</span>.consumer);</span><br><span class="line">                 <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStoppedEvent(SimpleMessageListenerContainer.<span class="keyword">this</span>, <span class="keyword">this</span>.consumer));</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">this</span>.start.countDown();</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.初始化</span></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="comment">// 通过AmqpAdmin重新声明创建交换器、队列、绑定</span></span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.redeclareElementsIfNecessary();</span><br><span class="line">                         <span class="keyword">this</span>.consumer.start();</span><br><span class="line">                         <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (QueuesNotAvailableException var34) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isMissingQueuesFatal()) &#123;</span><br><span class="line">                             <span class="keyword">throw</span> var34;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.handleStartupFailure(<span class="keyword">this</span>.consumer.getBackOffExecution());</span><br><span class="line">                         <span class="keyword">throw</span> var34;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (FatalListenerStartupException var35) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isPossibleAuthenticationFailureFatal()) &#123;</span><br><span class="line">                             <span class="keyword">throw</span> var35;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         Throwable possibleAuthException = var35.getCause().getCause();</span><br><span class="line">                         <span class="keyword">if</span> (possibleAuthException != <span class="keyword">null</span> &amp;&amp; possibleAuthException <span class="keyword">instanceof</span> PossibleAuthenticationFailureException) &#123;</span><br><span class="line">                             <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                             SimpleMessageListenerContainer.<span class="keyword">this</span>.handleStartupFailure(<span class="keyword">this</span>.consumer.getBackOffExecution());</span><br><span class="line">                             <span class="keyword">throw</span> possibleAuthException;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">throw</span> var35;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Throwable var36) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.handleStartupFailure(<span class="keyword">this</span>.consumer.getBackOffExecution());</span><br><span class="line">                         <span class="keyword">throw</span> var36;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.getTransactionManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         ConsumerChannelRegistry.registerConsumerChannel(<span class="keyword">this</span>.consumer.getChannel(), SimpleMessageListenerContainer.<span class="keyword">this</span>.getConnectionFactory());</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 死循环</span></span><br><span class="line">                     <span class="keyword">while</span>(SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive(<span class="keyword">this</span>.consumer) || <span class="keyword">this</span>.consumer.hasDelivery() || !<span class="keyword">this</span>.consumer.cancelled()) &#123;</span><br><span class="line">                         <span class="keyword">try</span> &#123;</span><br><span class="line">                             <span class="keyword">boolean</span> receivedOk = SimpleMessageListenerContainer.<span class="keyword">this</span>.receiveAndExecute(<span class="keyword">this</span>.consumer);</span><br><span class="line">                             <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.maxConcurrentConsumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (receivedOk) &#123;</span><br><span class="line">                                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive(<span class="keyword">this</span>.consumer)) &#123;</span><br><span class="line">                                         consecutiveIdles = <span class="number">0</span>;</span><br><span class="line">                                         <span class="keyword">if</span> (consecutiveMessages++ &gt; SimpleMessageListenerContainer.<span class="keyword">this</span>.consecutiveActiveTrigger) &#123;</span><br><span class="line">                                             SimpleMessageListenerContainer.<span class="keyword">this</span>.considerAddingAConsumer();</span><br><span class="line">                                             consecutiveMessages = <span class="number">0</span>;</span><br><span class="line">                                         &#125;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                     consecutiveMessages = <span class="number">0</span>;</span><br><span class="line">                                     <span class="keyword">if</span> (consecutiveIdles++ &gt; SimpleMessageListenerContainer.<span class="keyword">this</span>.consecutiveIdleTrigger) &#123;</span><br><span class="line">                                         SimpleMessageListenerContainer.<span class="keyword">this</span>.considerStoppingAConsumer(<span class="keyword">this</span>.consumer);</span><br><span class="line">                                         consecutiveIdles = <span class="number">0</span>;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;</span><br><span class="line"></span><br><span class="line">                             <span class="keyword">long</span> idleEventInterval = SimpleMessageListenerContainer.<span class="keyword">this</span>.getIdleEventInterval();</span><br><span class="line">                             <span class="keyword">if</span> (idleEventInterval &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (receivedOk) &#123;</span><br><span class="line">                                     SimpleMessageListenerContainer.<span class="keyword">this</span>.updateLastReceive();</span><br><span class="line">                                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                     <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                                     <span class="keyword">long</span> lastAlertAt = SimpleMessageListenerContainer.<span class="keyword">this</span>.lastNoMessageAlert.get();</span><br><span class="line">                                     <span class="keyword">long</span> lastReceive = SimpleMessageListenerContainer.<span class="keyword">this</span>.getLastReceive();</span><br><span class="line">                                     <span class="keyword">if</span> (now &gt; lastReceive + idleEventInterval &amp;&amp; now &gt; lastAlertAt + idleEventInterval &amp;&amp; SimpleMessageListenerContainer.<span class="keyword">this</span>.lastNoMessageAlert.compareAndSet(lastAlertAt, now)) &#123;</span><br><span class="line">                                         SimpleMessageListenerContainer.<span class="keyword">this</span>.publishIdleContainerEvent(now - lastReceive);</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (ListenerExecutionFailedException var37) &#123;</span><br><span class="line">                             <span class="keyword">if</span> (var37.getCause() <span class="keyword">instanceof</span> NoSuchMethodException) &#123;</span><br><span class="line">                                 <span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerExecutionException(<span class="string">&quot;Invalid listener&quot;</span>, var37);</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (AmqpRejectAndDontRequeueException var38) &#123;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException var39) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Consumer thread interrupted, processing stopped.&quot;</span>);</span><br><span class="line">                     Thread.currentThread().interrupt();</span><br><span class="line">                     aborted = <span class="keyword">true</span>;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer thread interrupted, processing stopped&quot;</span>, <span class="keyword">true</span>, var39);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (QueuesNotAvailableException var40) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer received fatal=&quot;</span> + SimpleMessageListenerContainer.<span class="keyword">this</span>.isMismatchedQueuesFatal() + <span class="string">&quot; exception on startup&quot;</span>, var40);</span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isMissingQueuesFatal()) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.startupException = var40;</span><br><span class="line">                         aborted = <span class="keyword">true</span>;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer queue(s) not available&quot;</span>, aborted, var40);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (FatalListenerStartupException var41) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer received fatal exception on startup&quot;</span>, var41);</span><br><span class="line">                     <span class="keyword">this</span>.startupException = var41;</span><br><span class="line">                     aborted = <span class="keyword">true</span>;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer received fatal exception on startup&quot;</span>, <span class="keyword">true</span>, var41);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (FatalListenerExecutionException var42) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer received fatal exception during processing&quot;</span>, var42);</span><br><span class="line">                     aborted = <span class="keyword">true</span>;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer received fatal exception during processing&quot;</span>, <span class="keyword">true</span>, var42);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (PossibleAuthenticationFailureException var43) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer received fatal=&quot;</span> + SimpleMessageListenerContainer.<span class="keyword">this</span>.isPossibleAuthenticationFailureFatal() + <span class="string">&quot; exception during processing&quot;</span>, var43);</span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isPossibleAuthenticationFailureFatal()) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.startupException = <span class="keyword">new</span> FatalListenerStartupException(<span class="string">&quot;Authentication failure&quot;</span>, <span class="keyword">new</span> AmqpAuthenticationException(var43));</span><br><span class="line">                         aborted = <span class="keyword">true</span>;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer received PossibleAuthenticationFailure during startup&quot;</span>, aborted, var43);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (ShutdownSignalException var44) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (RabbitUtils.isNormalShutdown(var44)) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                             SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Consumer received Shutdown Signal, processing stopped: &quot;</span> + var44.getMessage());</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="keyword">this</span>.logConsumerException(var44);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (AmqpIOException var45) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (var45.getCause() <span class="keyword">instanceof</span> IOException &amp;&amp; var45.getCause().getCause() <span class="keyword">instanceof</span> ShutdownSignalException &amp;&amp; var45.getCause().getCause().getMessage().contains(<span class="string">&quot;in exclusive use&quot;</span>)) &#123;</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.getExclusiveConsumerExceptionLogger().log(SimpleMessageListenerContainer.<span class="keyword">this</span>.logger, <span class="string">&quot;Exclusive consumer failure&quot;</span>, var45.getCause().getCause());</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer raised exception, attempting restart&quot;</span>, <span class="keyword">false</span>, var45);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="keyword">this</span>.logConsumerException(var45);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Error var46) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer thread error, thread abort.&quot;</span>, var46);</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer threw an Error&quot;</span>, <span class="keyword">true</span>, var46);</span><br><span class="line">                     aborted = <span class="keyword">true</span>;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Throwable var47) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive()) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.logConsumerException(var47);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.getTransactionManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         ConsumerChannelRegistry.unRegisterConsumerChannel();</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                 <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive(<span class="keyword">this</span>.consumer) &amp;&amp; !aborted) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.info(<span class="string">&quot;Restarting &quot;</span> + <span class="keyword">this</span>.consumer);</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.restart(<span class="keyword">this</span>.consumer);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Cancelling &quot;</span> + <span class="keyword">this</span>.consumer);</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="keyword">this</span>.consumer.stop();</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.cancellationLock.release(<span class="keyword">this</span>.consumer);</span><br><span class="line">                         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             SimpleMessageListenerContainer.<span class="keyword">this</span>.getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStoppedEvent(SimpleMessageListenerContainer.<span class="keyword">this</span>, <span class="keyword">this</span>.consumer));</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (AmqpException var33) &#123;</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.info(<span class="string">&quot;Could not cancel message consumer&quot;</span>, var33);</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (aborted &amp;&amp; SimpleMessageListenerContainer.<span class="keyword">this</span>.containerStoppingForAbort.compareAndSet((Object)<span class="keyword">null</span>, Thread.currentThread())) &#123;</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Stopping container from aborted consumer&quot;</span>);</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.stop();</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.containerStoppingForAbort.set((Object)<span class="keyword">null</span>);</span><br><span class="line">                         ListenerContainerConsumerFailedEvent event = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">do</span> &#123;</span><br><span class="line">                             <span class="keyword">try</span> &#123;</span><br><span class="line">                                 event = (ListenerContainerConsumerFailedEvent)SimpleMessageListenerContainer.<span class="keyword">this</span>.abortEvents.poll(<span class="number">5L</span>, TimeUnit.SECONDS);</span><br><span class="line">                                 <span class="keyword">if</span> (event != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(event.getReason(), event.isFatal(), event.getThrowable());</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125; <span class="keyword">catch</span> (InterruptedException var32) &#123;</span><br><span class="line">                                 Thread.currentThread().interrupt();</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">while</span>(event != <span class="keyword">null</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (routingLookupKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     SimpleResourceHolder.unbind(SimpleMessageListenerContainer.<span class="keyword">this</span>.getRoutingConnectionFactory());</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>





<h5 id="BlockingQueueConsumer-start"><a href="#BlockingQueueConsumer-start" class="headerlink" title="BlockingQueueConsumer#start"></a>BlockingQueueConsumer#start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要完成与`Rabbit Broker`指令交互</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(<span class="string">&quot;Starting consumer &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.resourceHolder = ConnectionFactoryUtils.getTransactionalResourceHolder(<span class="keyword">this</span>.connectionFactory, <span class="keyword">this</span>.transactional);</span><br><span class="line">           <span class="keyword">this</span>.channel = <span class="keyword">this</span>.resourceHolder.getChannel();</span><br><span class="line">           ClosingRecoveryListener.addRecoveryListenerIfNecessary(<span class="keyword">this</span>.channel);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (AmqpAuthenticationException var8) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerStartupException(<span class="string">&quot;Authentication failure&quot;</span>, var8);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.deliveryTags.clear();</span><br><span class="line">       <span class="keyword">this</span>.activeObjectCounter.add(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">int</span> passiveDeclareRetries = <span class="keyword">this</span>.declarationRetries;</span><br><span class="line">       <span class="keyword">this</span>.declaring = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(!<span class="keyword">this</span>.cancelled()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 校验监听队列是否存在</span></span><br><span class="line">			<span class="comment">// `channel.queueDeclarePassive(queueName)`，最终会向`Rabbit Broker`发送`queue.declare`指令，并设置`passive=true`</span></span><br><span class="line">               <span class="keyword">this</span>.attemptPassiveDeclarations();</span><br><span class="line">               <span class="keyword">if</span> (passiveDeclareRetries &lt; <span class="keyword">this</span>.declarationRetries &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">                   logger.info(<span class="string">&quot;Queue declaration succeeded after retrying&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               passiveDeclareRetries = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (BlockingQueueConsumer.DeclarationException var10) &#123;</span><br><span class="line">               <span class="keyword">if</span> (passiveDeclareRetries &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.channel.isOpen()) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                       logger.warn(<span class="string">&quot;Queue declaration failed; retries left=&quot;</span> + passiveDeclareRetries, var10);</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           Thread.sleep(<span class="keyword">this</span>.failedDeclarationRetryInterval);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException var7) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.declaring = <span class="keyword">false</span>;</span><br><span class="line">                           Thread.currentThread().interrupt();</span><br><span class="line">                           <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">                           <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(var7);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (var10.getFailedQueues().size() &gt;= <span class="keyword">this</span>.queues.length) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.declaring = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> QueuesNotAvailableException(<span class="string">&quot;Cannot prepare queue for listener. Either the queue doesn&#x27;t exist or the broker will not allow us to use it.&quot;</span>, var10);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                       logger.warn(<span class="string">&quot;Not all queues are available; only listening on those that are - configured: &quot;</span> + Arrays.asList(<span class="keyword">this</span>.queues) + <span class="string">&quot;; not available: &quot;</span> + var10.getFailedQueues());</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.missingQueues.addAll(var10.getFailedQueues());</span><br><span class="line">                   <span class="keyword">this</span>.lastRetryDeclaration = System.currentTimeMillis();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (passiveDeclareRetries-- &lt;= <span class="number">0</span> || <span class="keyword">this</span>.cancelled()) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.declaring = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.acknowledgeMode.isAutoAck() &amp;&amp; !<span class="keyword">this</span>.cancelled()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 最终会向`Rabbit Broker`发送`basic.qos`指令，并将`prefetch-size`、`prefetch-count`和`global`参数设置过去</span></span><br><span class="line">               <span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">               <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIOException(var6);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.cancelled()) &#123;</span><br><span class="line">               String[] var2 = <span class="keyword">this</span>.queues;</span><br><span class="line">               <span class="keyword">int</span> var3 = var2.length;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                   String queueName = var2[var4];</span><br><span class="line">                   <span class="keyword">if</span> (!<span class="keyword">this</span>.missingQueues.contains(queueName)) &#123;</span><br><span class="line">					<span class="comment">// 会使用`channel.basicConsume`方法订阅消息，最终会向`Rabbit Broker`发送`basic.consume`指令，并指定订阅消息的`queue`名称等参数消息</span></span><br><span class="line">					<span class="comment">// 注意：`SimpleMessageListenerContainer`可能设置多个监听队列，则`BlockingQueueConsumer`这里会给每个监听队列都向Broker发送一个`basic.consume`订阅指令，并且是使用同一个`channel`：</span></span><br><span class="line">                       <span class="keyword">this</span>.consumeFromQueue(queueName);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">           <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(var9);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<p>响应处理：</p>
<p>上面分析</p>
<ul>
<li><p><code>initialize()</code>初始化操作，客户端向<code>Broker</code>发送<code>basic.qos</code>和<code>basic.consume</code>指令就相当于告诉了服务器：我都准备好了，如果监听队列有消息你就把它推送给我，下面就来分析下<code>Broker</code>消息推送流程。</p>
</li>
<li><p>死循环：<code>Rabbit Broker</code>接收到<code>Basic.consume</code>指令后，会向客户端反馈<code>Basic.consume-ok</code>指令，表示服务端一切就绪准备给客户端推送消息，然后就通过<code>Basic.Deliver</code>指令类型将消息推送给客户端，一条消息对应一个<code>Deliver</code>反馈，客户端接收到服务端返回过来的指令类型后，在<code>ChannelN#processAsync</code>方法进行判断处理，它是<code>amqp-client</code>依赖包中类：</p>
<p><img src="https://res-static.hc-cdn.cn/fms/img/1cea2b3e1b552149cc102993db8107b01612517532884" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析7"></p>
</li>
</ul>
<p>如果是Deliver类型指令，则调用 <code>processDelivery()</code> 方法进行处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> <span class="function"><span class="title">processDelivery</span>(<span class="params">Command command, Basic.Deliver method</span>)</span> &#123; Basic.Deliver m = method; <span class="comment">//根据Deliver的consumerTag获取到InternalConsumer对象，因为一个Channel上可能存在多个consumer，需要找到Broker是针对哪个consumer进行的响应 Consumer callback = _consumers.get(m.getConsumerTag()); if (callback == null) &#123; if (defaultConsumer == null) &#123; // No handler set. We should blow up as this message // needs acking, just dropping it is not enough. See bug // 22587 for discussion. throw new IllegalStateException(&quot;Unsolicited delivery -&quot; + &quot; see Channel.setDefaultConsumer to handle this&quot; + &quot; case.&quot;); &#125; else &#123; callback = defaultConsumer; &#125; &#125; Envelope envelope = new Envelope(m.getDeliveryTag(), m.getRedelivered(), m.getExchange(), m.getRoutingKey()); try &#123; // call metricsCollector before the dispatching (which is async anyway) // this way, the message is inside the stats before it is handled // in case a manual ack in the callback, the stats will be able to record the ack metricsCollector.consumedMessage(this, m.getDeliveryTag(), m.getConsumerTag()); this.dispatcher.handleDelivery(callback, m.getConsumerTag(), envelope, (BasicProperties) command.getContentHeader(), command.getContentBody()); &#125; catch (WorkPoolFullException e) &#123; // couldn&#x27;t enqueue in work pool, propagating throw e; &#125; catch (Throwable ex) &#123; getConnection().getExceptionHandler().handleConsumerException(this, ex, callback, m.getConsumerTag(), &quot;handleDelivery&quot;); &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processDelivery()</code>处理<code>Broker</code>返回的<code>Deliver</code>消息大致流程：</p>
<ul>
<li><p><code>Consumer callback = _consumers.get(m.getConsumerTag())</code>：根据<code>Deliver</code>的<code>consumerTag</code>获取到<code>InternalConsumer</code>对象，因为一个<code>Channel</code>上可能存在多个<code>consumer</code>，需要找到<code>Broker</code>是针对哪个<code>consumer</code>进行的响应</p>
</li>
<li><p>封装<code>Deliver</code>成<code>Envelope</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Envelope envelope = <span class="keyword">new</span> Envelope(m.getDeliveryTag(), m.getRedelivered(), m.getExchange(), m.getRoutingKey());</span><br></pre></td></tr></table></figure></li>
<li><p><code>metricsCollector.consumedMessage(this, m.getDeliveryTag(), m.getConsumerTag())</code>:统计数据处理</p>
</li>
<li><p>调用<code>ConsumerDispatcher#handleDelivery</code>，其会创建任务丢到线程池中执行，任务：将数据交由具体的<code>consumer</code>处理，即调用<code>InternalConsumer#handleDelivery</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.dispatcher.handleDelivery(callback, m.getConsumerTag(), envelope, (BasicProperties) command.getContentHeader(), command.getContentBody());</span><br></pre></td></tr></table></figure></li>
<li><p><code>InternalConsumer#handleDelivery()</code>方法：将<code>Broker</code>返回的<code>Deliver</code>数据放入到<code>BlockingQueueConsumer.queue</code>中：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueueConsumer.this.queue.put(<span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body, <span class="built_in">this</span>.queueName));</span><br></pre></td></tr></table></figure>

<p>所以，如果<code>ListenerContainer</code>监听多个队列，则<code>BlockingQueueConsumer</code>中则对应多个<code>InternalConsumer</code>，每个<code>InternalConsumer</code>映射<code>Broker</code>上的一个，<code>BlockingQueueConsumer</code>下所有<code>InternalConsumer</code>共享同一个<code>queue</code>。</p>
<p>业务处理：</p>
<p>上面分析了消息订阅以及Broker推送过来的消息数据会被缓存到<code>BlockingQueueConsumer</code>对象的<code>queue</code>队列中，下面就来分析下从<code>queue</code>中提取消息到传递给用户业务逻辑这个流程。这就需要分析<code>AsyncMessageProcessingConsumer#run</code>方法中另一个非常重要操作：无限循环<code>mainLoop</code>操作，它主要就是完成从<code>queue</code>中提取消息数据然后经过一系列操作最终传递给用户逻辑<code>MessageListener</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> mainLoop() throws Exception &#123; <span class="comment">// NOSONAR Exception</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  boolean receivedOk = receiveAndExecute(<span class="built_in">this</span>.consumer); <span class="comment">// At least one message received</span></span><br><span class="line">  <span class="keyword">if</span> (SimpleMessageListenerContainer.this.maxConcurrentConsumers != <span class="literal">null</span>) &#123; checkAdjust(receivedOk);</span><br><span class="line">  &#125;</span><br><span class="line">  long idleEventInterval = getIdleEventInterval();</span><br><span class="line">  <span class="keyword">if</span> (idleEventInterval &gt; <span class="number">0</span>) &#123; <span class="keyword">if</span> (receivedOk) &#123; updateLastReceive(); &#125; <span class="keyword">else</span> &#123; long now = System.currentTimeMillis(); long lastAlertAt = SimpleMessageListenerContainer.this.lastNoMessageAlert.get(); long lastReceive = getLastReceive(); <span class="keyword">if</span> (now &gt; lastReceive + idleEventInterval &amp;&amp; now &gt; lastAlertAt + idleEventInterval &amp;&amp; SimpleMessageListenerContainer.this.lastNoMessageAlert .compareAndSet(lastAlertAt, now)) &#123; publishIdleContainerEvent(now - lastReceive); &#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (ListenerExecutionFailedException ex) &#123;</span><br><span class="line">  <span class="comment">// Continue to process, otherwise re-throw</span></span><br><span class="line">  <span class="keyword">if</span> (ex.getCause() <span class="keyword">instanceof</span> NoSuchMethodException) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerExecutionException(<span class="string">&quot;Invalid listener&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (AmqpRejectAndDontRequeueException rejectEx) &#123;</span><br><span class="line">  <span class="comment">/* *  These will normally be wrapped by an LEFE if thrown by the *  listener, but we will also honor it if thrown by an</span></span><br><span class="line"><span class="comment">  *  error handler.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪下<code>doReceiveAndExecute()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private boolean doReceiveAndExecute(BlockingQueueConsumer consumer) throws Exception &#123; <span class="comment">//NOSONAR</span></span><br><span class="line"></span><br><span class="line"> Channel channel = consumer.getChannel();</span><br><span class="line"></span><br><span class="line"> List messages = <span class="literal">null</span>;</span><br><span class="line"> long deliveryTag = <span class="number">0</span>; <span class="comment">//batchSize默认是1，用于指定一次从queue中提取消息数量</span></span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.batchsize; i++) &#123;&gt; afterReceivePostProcessors = getAfterReceivePostProcessors(); <span class="keyword">if</span> (afterReceivePostProcessors != <span class="literal">null</span>) &#123; Message original = message; deliveryTag = message.getMessageProperties().getDeliveryTag(); <span class="keyword">for</span> (MessagePostProcessor processor : getAfterReceivePostProcessors()) &#123; message = processor.postProcessMessage(message); <span class="keyword">if</span> (message == <span class="literal">null</span>) &#123; channel.basicAck(deliveryTag, <span class="literal">false</span>); <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123; <span class="built_in">this</span>.logger.debug( <span class="string">&quot;Message Post Processor returned &#x27;null&#x27;, discarding message &quot;</span> + original); &#125; <span class="keyword">break</span>; &#125; &#125; &#125; <span class="keyword">if</span> (message != <span class="literal">null</span>) &#123; <span class="keyword">if</span> (messages == <span class="literal">null</span>) &#123; messages = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="built_in">this</span>.batchSize); &#125; <span class="keyword">if</span> (isDeBatchingEnabled() &amp;&amp; getBatchingStrategy().canDebatch(message.getMessageProperties())) &#123; final List messageList = messages; getBatchingStrategy().deBatch(message, fragment -&gt; messageList.add(fragment)); &#125; <span class="keyword">else</span> &#123; messages.add(message); &#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; messages = debatch(message); <span class="keyword">if</span> (messages != <span class="literal">null</span>) &#123; <span class="keyword">break</span>; &#125; <span class="keyword">try</span> &#123; <span class="comment">//执行MessageListener executeListener(channel, message); &#125; catch (ImmediateAcknowledgeAmqpException e) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;User requested ack for failed delivery &#x27;&quot; + e.getMessage() + &quot;&#x27;: &quot; + message.getMessageProperties().getDeliveryTag()); &#125; break; &#125; catch (Exception ex) &#123; if (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;User requested ack for failed delivery: &quot; + message.getMessageProperties().getDeliveryTag()); &#125; break; &#125; if (getTransactionManager() != null) &#123; if (getTransactionAttribute().rollbackOn(ex)) &#123; RabbitResourceHolder resourceHolder = (RabbitResourceHolder) TransactionSynchronizationManager .getResource(getConnectionFactory()); if (resourceHolder != null) &#123; consumer.clearDeliveryTags(); &#125; else &#123; /* * If we don&#x27;t actually have a transaction, we have to roll back * manually. See prepareHolderForRollback(). */ consumer.rollbackOnExceptionIfNecessary(ex); &#125; throw ex; // encompassing transaction will handle the rollback. &#125; else &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;No rollback for &quot; + ex); &#125; break; &#125; &#125; else &#123; consumer.rollbackOnExceptionIfNecessary(ex); throw ex; &#125; &#125; &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (messages != <span class="literal">null</span>) &#123; executeWithList(channel, messages, deliveryTag, consumer);</span><br><span class="line">  &#125; <span class="keyword">return</span> consumer.commitIfNecessary(isChannelLocallyTransacted());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>上面对<code>SimpleMessageListenerContainer</code>核心源码进行分析，比较枯燥不太直观，总结下其最核心就是位于<code>AsyncMessageProcessingConsumer#run</code>方法中两个操作：<code>initialize()</code>和无限循环<code>mainLoop()</code>。</p>
<p><code>initialize()</code>方法主要完成：通过指令方式将需要监听队列信息告诉<code>Rabbit Broker</code>，<code>Broker</code>在监听队列中有消息数据时通过<code>Deliver</code>指令将消息推送给客户端，客户端接收的<code>Deliver</code>指令后，根据<code>consumerTag</code>分发(<code>dispatcher</code>)给具体<code>consumer</code>，然后<code>consumer</code>将其放入到其所属<code>BlockingQueueConsumer</code>对象的队列<code>queue</code>中，其逻辑可见下图：</p>
<p><img src="https://res-static.hc-cdn.cn/fms/img/58afc4c9952d12a7f18af4c48a0530d61612517532884" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析8"></p>
<p><code>BlockingQueueConsumer</code>、<code>AsyncMessageProcessingConsumer</code>、监听队列等关系：</p>
<p>1、<code>BlockingQueueConsumer</code>相当于一个逻辑消费者，通过封装成<code>AsyncMessageProcessingConsumer</code>异步任务，然后丢到线程池中运行，线程池可以通过<code>SimpleMessageListenerContainer#setTaskExecutor</code>进行自定义配置，所以，<code>BlockingQueueConsumer</code>可以看成单独线程运行，且对应一个<code>Channel</code>；</p>
<p>2、<code>SimpleMessageListenerContainer</code>可以监听多个队列消息，每个队列又会创建一个<code>InternalConsumer</code>对象，用于映射<code>Broker</code>上的<code>consumer</code>概念，它们是共用同一个<code>channel</code>，即<code>channel</code>下存在多个<code>consumer</code>，它们之间通过<code>consumerTag</code>区分，另外，<code>Broker</code>推送消息也是根据<code>consumerTag</code>识别具体推送给哪个<code>consumer</code>进行处理；</p>
<p>案例，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">container.setQueueNames(<span class="string">&quot;test01&quot;</span>, <span class="string">&quot;test02&quot;</span>);</span><br><span class="line">container.setConcurrentConsumers(<span class="number">3</span>);</span><br><span class="line">container.setConsumerTagStrategy(queue -&gt; <span class="string">&quot;consumer idx:&quot;</span>+consumerIdx.getAndIncrement());</span><br></pre></td></tr></table></figure>

<p>a、根据并发数<code>concurrentConsumers</code>创建对应数量的<code>BlockingQueueConsumer</code>，然后封装成<code>AsyncMessageProcessingConsumer</code>，再分配一个线程进行执行，这里设置成3，所以会有3个线程运行<code>AsyncMessageProcessingConsumer</code>，每个<code>AsyncMessageProcessingConsumer</code>对应一个channel，所以会创建3个channel，在Web UI上可以看到对应channel：</p>
<p><img src="https://res-static.hc-cdn.cn/fms/img/13fe637438a9c721adc6711b97ec6e821612517532885" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析9"></p>
<p>b、每个监听队列创建一个<code>InternalConsumer</code>和Broker的consumer进行映射，这里有两个监听队列，所以每个channel下会存在2个consumer：</p>
<p><img src="https://res-static.hc-cdn.cn/fms/img/900030467c62c0b1f34878b69da926141612517532885" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析10"></p>
<p><code>AsyncMessageProcessingConsumer</code>如何订阅：</p>
<p>a、首先发送<code>Basic.Qos</code>指令约定消息推送速率问题；</p>
<p>b、然后发送<code>Basic.Consume</code>指令告诉<code>Broker</code>客户端要开始订阅什么队列上的消息，以及把<code>consumerTag</code>带上，因为可能存在多个监听队列，则同一个<code>channel</code>上可能会发送多次<code>Basic.Consume</code>指令，<code>Broker</code>向<code>channel</code>推送消息时需要根据<code>consumerTag</code>找到对应<code>consumer</code>处理；</p>
<p>c、Broker通过Deliver指令类型方式向客户端推送消息，客户端接收到消息后，根据consumerTag找到对应consumer交由其进行处理，即分发dispatcher；</p>
<p>d、这里的consumer对应的是<code>InternalConsumer</code>，它处理逻辑就是放入到它所在的<code>BlockingQueueConsumer</code>对象中消息队列<code>queue</code>中；</p>
<p>mainLoop</p>
<hr>
<p>Broker推送过来的消息放入到了BlockingQueueConsumer对象的消息队列queue中，后续就是从queue中提取消息进行业务处理，逻辑见下图：</p>
<p><img src="https://res-static.hc-cdn.cn/fms/img/22d4831ca9b00a68417829fadee786621612517532886" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析11"></p>
<p>a、<code>AsyncMessageProcessingConsumer</code>被丢入到线程池中执行，则其对应一个线程；</p>
<p>b、这个线程会一直循环执行<code>mainLoop()</code>方法；</p>
<p>c、<code>mainLoop()</code>方法中就会从<code>queue中</code>提取消息，根据<code>batchSize</code>确定每次提取消息数量，最后回调<code>MessageListener</code>，实现将消息传递到业务逻辑进行处理；</p>
<p>d、注意：所有的<code>AsyncMessageProcessingConsumer</code>共用同一个<code>MessageListener</code>对象，对象状态要注意线程安全问题；</p>
<p>总体流程</p>
<hr>
<p><img src="https://res-static.hc-cdn.cn/fms/img/57ad7c2ab6ba47794d532f6fca2a51201612517532886" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析12"></p>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/11961055.html">【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析 - 华为云 (huaweicloud.com)</a></p>
<h4 id="MessageListenerContainer的创建"><a href="#MessageListenerContainer的创建" class="headerlink" title="MessageListenerContainer的创建"></a>MessageListenerContainer的创建</h4><p>首先看AbstractRabbitListenerContainerFactory抽象类的下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> C <span class="title">createListenerContainer</span><span class="params">(RabbitListenerEndpoint endpoint)</span> </span>&#123;</span><br><span class="line">	C instance = createContainerInstance();</span><br><span class="line">       ...</span><br><span class="line">	</span><br><span class="line">	endpoint.setupListenerContainer(instance);</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	initializeContainer(instance, endpoint);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意里面两个方法，后面这个方法里面SimpleRabbitListenerContainerFactory会做一些它独有的属性设置，前一个方法执行结束，MessageListener就设置到MessageListenerContainer里面去了，可以跟踪这个方法，一直到AbstractRabbitListenerEndpoint类的下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupMessageListener</span><span class="params">(MessageListenerContainer container)</span> </span>&#123;</span><br><span class="line">	MessageListener messageListener = createMessageListener(container);</span><br><span class="line">	Assert.state(messageListener != <span class="keyword">null</span>, () -&gt; <span class="string">&quot;Endpoint [&quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;] must provide a non null message listener&quot;</span>);</span><br><span class="line">	container.setupMessageListener(messageListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到在这个方法里创建了MessageListener，并将其设置到MessageListenerContainer里面去。</p>
<p>createMessageListener()方法有两个实现，实际调用的是MethodRabbitListenerEndpoint类里面的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MessagingMessageListenerAdapter <span class="title">createMessageListener</span><span class="params">(MessageListenerContainer container)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	MessagingMessageListenerAdapter messageListener = createMessageListenerInstance();</span><br><span class="line">	messageListener.setHandlerMethod(configureListenerAdapter(messageListener));</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> messageListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>看到setHandlerMethod(configureListenerAdapter(messageListener))这一行，这里创建并设置了一个HandlerAdapter，这个HandlerAdapter能够调用我们加了@RabbitListener注解的方法。</p>
<h4 id="SimpleMessageListenerContainer接收消息的实现"><a href="#SimpleMessageListenerContainer接收消息的实现" class="headerlink" title="SimpleMessageListenerContainer接收消息的实现"></a>SimpleMessageListenerContainer接收消息的实现</h4><p>SimpleRabbitListenerContainerFactory创建的MessageListenerContainer是SimpleMessageListenerContainer类，下面看它是怎么在启动后就能接收消息的。</p>
<p>上面讲过RabbitListenerEndpointRegistry类通过调用MessageListenerContainer的start()方法类启动这个MessageListenerContainer。</p>
<p>SimpleMessageListenerContainer类本身并没有实现start()方法，在它继承的抽象父类里面。进入AbstractMessageListenerContainer抽象类找到start()方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isRunning()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.lifecycleMonitor) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">				afterPropertiesSet();</span><br><span class="line">				<span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Starting Rabbit listener container.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		configureAdminIfNeeded();</span><br><span class="line">		checkMismatchedQueues();</span><br><span class="line">		doStart();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> convertRabbitAccessException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>真正的启动方法是doStart()，所以去SimpleMessageListenerContainer类中找这个类的doStart()实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">int</span> newConsumers = initializeConsumers();</span><br><span class="line">       </span><br><span class="line">           ...</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">for</span> (BlockingQueueConsumer consumer : <span class="keyword">this</span>.consumers) &#123;</span><br><span class="line">			AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">			processors.add(processor);</span><br><span class="line">			getTaskExecutor().execute(processor);</span><br><span class="line">			<span class="keyword">if</span> (getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这个方法很长，细节就不去深究了，这里注意两个方法，一个是initializeConsumers()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">initializeConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.consumersMonitor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.consumers == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.cancellationLock.reset();</span><br><span class="line">			<span class="keyword">this</span>.consumers = <span class="keyword">new</span> HashSet&lt;BlockingQueueConsumer&gt;(<span class="keyword">this</span>.concurrentConsumers);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.concurrentConsumers; i++) &#123;</span><br><span class="line">				BlockingQueueConsumer consumer = createBlockingQueueConsumer();</span><br><span class="line">				<span class="keyword">this</span>.consumers.add(consumer);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这个方法创建了BlockingQueueConsumer，数量等于concurrentConsumers参数的配置。</p>
<p>另一个方法是getTaskExecutor().execute(processor)，前面用BlockingQueueConsumer创建了AsyncMessageProcessingConsumer（实现了Runnable接口），这里获取到Executor来执行，每一个MessageListenerContainer都有各自的Executor。</p>
<p>在AsyncMessageProcessingConsumer类的run()方法里面可以找到下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (isActive(<span class="keyword">this</span>.consumer) || <span class="keyword">this</span>.consumer.hasDelivery() || !<span class="keyword">this</span>.consumer.cancelled()) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> receivedOk = receiveAndExecute(<span class="keyword">this</span>.consumer); <span class="comment">// At least one message received</span></span><br><span class="line">		<span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.maxConcurrentConsumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (receivedOk) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isActive(<span class="keyword">this</span>.consumer)) &#123;</span><br><span class="line">					consecutiveIdles = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">if</span> (consecutiveMessages++ &gt; SimpleMessageListenerContainer.<span class="keyword">this</span>.consecutiveActiveTrigger) &#123;</span><br><span class="line">						considerAddingAConsumer();</span><br><span class="line">						consecutiveMessages = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这里有两个地方需要注意。</p>
<p>一个是<code>this.consumer.hasDelivery()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasDelivery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !<span class="keyword">this</span>.queue.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Delivery&gt; queue;</span><br></pre></td></tr></table></figure>



<p>另一个要注意的是<code>receiveAndExecute()</code>方法，跟踪进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doReceiveAndExecute</span><span class="params">(BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//NOSONAR</span></span><br><span class="line"></span><br><span class="line">		Channel channel = consumer.getChannel();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.txSize; i++) &#123;</span><br><span class="line"></span><br><span class="line">			logger.trace(<span class="string">&quot;Waiting for message from consumer.&quot;</span>);</span><br><span class="line">			Message message = consumer.nextMessage(<span class="keyword">this</span>.receiveTimeout);</span><br><span class="line">			<span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				executeListener(channel, message);</span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>consumer.nextMessage(this.receiveTimeout);会从上面那个BlockingQueue里面拿一条消息出来。</p>
<p>所以SimpleMessageListenerContainer接收消息的实现方案是：用一个BlockingQueue保存rabbitmq发过来还未来得及处理的消息，然后向Executor提交执行Runnable，Runnable中循环从BlockingQueue里面取消息。</p>
<p>至于这个BlockingQueue里面的消息是怎么从rabbitmq获取到的，此处暂不讨论。</p>
<h4 id="MessageListener调用-RabbitListener注解方法处理消息的实现"><a href="#MessageListener调用-RabbitListener注解方法处理消息的实现" class="headerlink" title="MessageListener调用@RabbitListener注解方法处理消息的实现"></a>MessageListener调用@RabbitListener注解方法处理消息的实现</h4><p>上面的receiveAndExecute()方法接收消息的同时也将其处理了，继续跟踪，直到进入下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeListener</span><span class="params">(Channel channel, Message messageIn)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    invokeListener(channel, message);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在这个方法里面可以看到invokeListener()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(Channel channel, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.proxy.invokeListener(channel, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里有个proxy，这个proxy是由下面这个方法创建的匿名类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">actualInvokeListener</span><span class="params">(Channel channel, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Object listener = getMessageListener();</span><br><span class="line">	<span class="keyword">if</span> (listener <span class="keyword">instanceof</span> ChannelAwareMessageListener) &#123;</span><br><span class="line">		doInvokeListener((ChannelAwareMessageListener) listener, channel, message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> MessageListener) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> bindChannel = isExposeListenerChannel() &amp;&amp; isChannelLocallyTransacted();</span><br><span class="line">		<span class="keyword">if</span> (bindChannel) &#123;</span><br><span class="line">			RabbitResourceHolder resourceHolder = <span class="keyword">new</span> RabbitResourceHolder(channel, <span class="keyword">false</span>);</span><br><span class="line">			resourceHolder.setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">			TransactionSynchronizationManager.bindResource(<span class="keyword">this</span>.getConnectionFactory(),</span><br><span class="line">					resourceHolder);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			doInvokeListener((MessageListener) listener, message);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (bindChannel) &#123;</span><br><span class="line">				<span class="comment">// unbind if we bound</span></span><br><span class="line">				TransactionSynchronizationManager.unbindResource(<span class="keyword">this</span>.getConnectionFactory());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerExecutionException(<span class="string">&quot;Only MessageListener and SessionAwareMessageListener supported: &quot;</span></span><br><span class="line">				+ listener);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerExecutionException(<span class="string">&quot;No message listener specified - see property &#x27;messageListener&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这个方法里可以看到doInvokeListener()方法，已经差不多接近我们的@RabbitListener注解的方法了，继续跟踪：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ChannelAwareMessageListener listener, Channel channel, Message message)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		listener.onMessage(message, channelToUse);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> wrapToListenerExecutionFailedExceptionIfNeeded(e, message);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>跟踪listener.onMessage()方法，直到进入MessagingMessageListenerAdapter类的onMessage()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(org.springframework.amqp.core.Message amqpMessage, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Message&lt;?&gt; message = toMessagingMessage(amqpMessage);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Processing [&quot;</span> + message + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object result = invokeHandler(amqpMessage, channel, message);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">			handleResult(result, amqpMessage, channel, message);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No result object given - no result to handle&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ListenerExecutionFailedException e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Object result = <span class="keyword">this</span>.errorHandler.handleError(amqpMessage, message, e);</span><br><span class="line">				<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">					handleResult(result, amqpMessage, channel, message);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Error handler returned no result&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				returnOrThrow(amqpMessage, channel, message, ex, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			returnOrThrow(amqpMessage, channel, message, e.getCause(), e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这里通过invokHandler()方法消费获取到的message，然后在catch里面处理异常，进入invokeHandler()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeHandler</span><span class="params">(org.springframework.amqp.core.Message amqpMessage, Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">			Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.handlerMethod.invoke(message, amqpMessage, channel);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (MessagingException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(createMessagingErrorMessage(<span class="string">&quot;Listener method could not &quot;</span> +</span><br><span class="line">					<span class="string">&quot;be invoked with the incoming message&quot;</span>, message.getPayload()), ex, amqpMessage);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(<span class="string">&quot;Listener method &#x27;&quot;</span> +</span><br><span class="line">					<span class="keyword">this</span>.handlerMethod.getMethodAsString(message.getPayload()) + <span class="string">&quot;&#x27; threw exception&quot;</span>, ex, amqpMessage);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在这里可以看到catch了所有的异常，也就是说只要是我们消费消息的方法里面抛出来的异常全都会被包装成ListenerExecutionFailedException，并且这个Exception里面把消息也放进去了。</p>
<p>这里的this.handlerMethod其实就是上面提到的HandlerAdapter，跟踪它的invoke()方法，看它是怎么调用我们@RabbitListener注解的方法的。</p>
<p>最后我们跟踪到InvocableHandlerMethod类的下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里通过getBridgedMethod()方法拿到的就是@RabbitListener注解的方法了，这是在刚开始处理@RabbitListener注解时就已经保存下来的，然后就可以利用反射来调用这个方法，这样就完成了接收并处理消息的整个流程。</p>
<h3 id="4-2-CachingConnectionFactory"><a href="#4-2-CachingConnectionFactory" class="headerlink" title="4.2 CachingConnectionFactory"></a>4.2 CachingConnectionFactory</h3><p>因为上一个项目中使用了RabbitMQ，但是当时没有考虑过性能的问题，今天觉得好像不对劲，大量的重复建立连接，造成了很大的性能浪费，于是我就找呀找，发现Spring提供了一种RabbitMQ连接池，所以今天我们来看一下它是如何设计的。</p>
<ul>
<li><p>CachingConnectionFactory</p>
<p>CachingConnectionFactory为我们提供了两种缓存的模式：</p>
<ul>
<li>CHANNEL模式：这也是CachingConnectionFactory的默认模式，在这种模式下，所有的createConnection（）方法实际上返回的都是同一个Connection，同样的Connection.close()方法是没用的，因为就一个，默认情况下，Connection中只缓存了一个Channel，在并发量不大的时候这种模式是完全够用的，当并发量较高的时候，我们可以setChannelCacheSize（）来增加Connection中缓存的Channel的数量。</li>
<li>CONNECTION模式：在CONNECTION模式下，每一次调用createConnection（）方法都会新建一个或者从缓存中获取，根据你设置的ConnectionCacheSize的大小，当小于的时候会采用新建的策略，当大于等于的时候会采用从缓存中获取的策略，与CHANNEL模式不同的是，CONNECTION模式对Connection和Channel都进行了缓存，最新版本的client中已经将Channel的缓存数量从1增加到了25，但是在并发量不是特别大的情况下，作用并不是特别明显。<br> <strong>使用CachingConnectionFactory需要注意的一点是：所有你获取的Channel对象必须要显式的关闭，所以finally中一定不要忘记释放资源，如果忘记释放，则可能造成连接池中没有资源可用</strong>。<br> 好了，我们来看一下创建Connection源码的实现：</li>
</ul>
</li>
<li><p>createConnection()</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    synchronized (<span class="keyword">this</span>.connectionMonitor) &#123;</span><br><span class="line"><span class="comment">// CHANNEL模式下，这里的connection是ChannelCachingConnectionProxy 代理对象</span></span><br><span class="line"><span class="comment">//这样做的目的是为Channel提供临时的存储空间（也就是缓存Channel），以便其他客户端调用 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cacheMode == CacheMode.CHANNEL) &#123;</span><br><span class="line"><span class="comment">//确保Connection对象不为null，target是真实的连接</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.connection.target == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//第一次调用 createConnection 方法时 connection.target 值为 null，因此会调用 createBareConnection 方法创建出 SimpleConnection 赋值给 connection.target</span></span><br><span class="line"><span class="comment">//SimpleConnection 中delegate属性是真正的RabbitMQ 连接（AMQConnection）</span></span><br><span class="line">                    <span class="keyword">this</span>.connection.target = <span class="keyword">super</span>.createBareConnection();</span><br><span class="line">                    <span class="comment">// invoke the listener *after* this.connection is assigned</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.checkoutPermits.containsKey(<span class="keyword">this</span>.connection)) &#123;</span><br><span class="line"><span class="comment">// Map&lt;Connection, Semaphore&gt; checkoutPermits 中存放了信道的许可数量，也就是默认的25，通过信号量来同步资源</span></span><br><span class="line">                        <span class="keyword">this</span>.checkoutPermits.put(<span class="keyword">this</span>.connection, new Semaphore(<span class="keyword">this</span>.channelCacheSize));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.connection.closeNotified.<span class="keyword">set</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//向所有 ConnectionListener 发布 onCreate 事件</span></span><br><span class="line">                    getConnectionListener().onCreate(<span class="keyword">this</span>.connection);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.connection;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.cacheMode == CacheMode.CONNECTION) &#123;</span><br><span class="line"><span class="comment">//直接从缓存中获取</span></span><br><span class="line">                <span class="keyword">return</span> connectionFromCache();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>创建Channel的源码实现：</p>
<ul>
<li>createChannel（）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">        Semaphore permits = null;</span><br><span class="line">//大于0的情况下才会通过 Semaphore 限制当前连接下可用的信道数量</span><br><span class="line">        if (this.channelCheckoutTimeout &gt; 0) &#123;</span><br><span class="line">//获取许可</span><br><span class="line">            permits = obtainPermits(connection);</span><br><span class="line">        &#125;</span><br><span class="line">//获取当前Connection的Channel代理集合</span><br><span class="line">        LinkedList&lt;ChannelProxy&gt; channelList = determineChannelList(connection, transactional);</span><br><span class="line">        ChannelProxy channel = null;</span><br><span class="line">        if (connection.isOpen()) &#123;</span><br><span class="line">//这里主要是从缓存中获取，在同步块中，先判断 channelList 是否为空，若不为空，则返回队列头部缓存的 ChannelProxy（要从队列中移除）。</span><br><span class="line">//如果没有可用的缓存信道，则通过 getCachedChannelProxy 方法创建新的 ChannelProxy。</span><br><span class="line">            channel = findOpenChannel(channelList, channel);</span><br><span class="line">            if (channel != null) &#123;</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Found cached Rabbit Channel: &quot; + channel.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (channel == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">//创建新Channel 的过程</span><br><span class="line">                channel = getCachedChannelProxy(connection, channelList, transactional);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (RuntimeException e) &#123;</span><br><span class="line">                if (permits != null) &#123;</span><br><span class="line">                    permits.release();</span><br><span class="line">                    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(&quot;Could not get channel; released permit for &quot; + connection + &quot;, remaining:&quot;</span><br><span class="line">                                + permits.availablePermits());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return channel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> ChannelProxy <span class="title">getCachedChannelProxy</span><span class="params">(ChannelCachingConnectionProxy connection,</span></span></span><br><span class="line"><span class="params"><span class="function">            LinkedList&lt;ChannelProxy&gt; channelList, <span class="keyword">boolean</span> transactional)</span> </span>&#123; <span class="comment">//NOSONAR LinkedList for addLast()</span></span><br><span class="line"><span class="comment">//通过Connection中delegate创建Channel对象</span></span><br><span class="line">        Channel targetChannel = createBareChannel(connection, transactional);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Creating cached Rabbit Channel from &quot;</span> + targetChannel);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//向所有 ChannelListener 发布 onCreate 事件</span></span><br><span class="line">        getChannelListener().onCreate(targetChannel, transactional);</span><br><span class="line">        Class&lt;?&gt;[] interfaces;</span><br><span class="line"><span class="comment">//通过 Proxy.newProxyInstance创建一个实现了ChannelProxy接口的动态代理对象。</span></span><br><span class="line"><span class="comment">//所有对该实例的方法调用都会转交给CachedChannelInvocationHandler 的 invoke 方法处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.publisherConfirms || <span class="keyword">this</span>.publisherReturns) &#123;</span><br><span class="line">            interfaces = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ChannelProxy.class, PublisherCallbackChannel.class &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            interfaces = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ChannelProxy.class &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ChannelProxy) Proxy.newProxyInstance(ChannelProxy.class.getClassLoader(),</span><br><span class="line">                interfaces, <span class="keyword">new</span> CachedChannelInvocationHandler(connection, targetChannel, channelList,</span><br><span class="line">                        transactional));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="五-案例"><a href="#五-案例" class="headerlink" title="五. 案例"></a>五. 案例</h2><h3 id="5-1-自动重连"><a href="#5-1-自动重连" class="headerlink" title="5.1 自动重连"></a>5.1 自动重连</h3><p>Spring AMQP提供了一些高级特性来解决协议错误或者代理失败发生时的恢复与自动重连：</p>
<ul>
<li>主要通过CachingConnectionFactory来实现；</li>
<li>使用RabbitAdmin进行自动声明也很有用处；</li>
<li>如果你比较在乎发送的质量，以也许会使用RabbitTemplate和SimpleMessageListenerContainer的channelTransacted属性，还有 SimpleMessageListenerContainer的Acknowledge.AUTO属性。</li>
</ul>
<p>自动声明交换器、队列和绑定：</p>
<ul>
<li>RabbitAdmin在启动的时候会声明exchange，queues和binding。它是延迟完成的，是在ConnectionListener中，所以如果在应用启动的时候消息代理不可用也没关系。</li>
<li>Connection被第一次使用的时候，监听器会被触发，admin这一特色会被应用。</li>
<li>监听器中的自动声明的另外一个好处是如果连接由于某种原因断了(代理挂掉，或者网络失灵)，下次连接时候它又会被启用。</li>
<li>注意：以这种方式启动队列必须要有固定的名称。要么显示声明，要么通过框架为AnonymousQueues自动生成。 AnonymousQueues不可以持久化，专属的，自动删除。</li>
<li>重点：自动声明只能在CachingConnectionFactory缓存模式是CHANNEL时候启用。这个限制的存在是因为专属的或者自动删除的队列和连接绑定。</li>
</ul>
<p>同步操作失败和重试选项：</p>
<ul>
<li>如果在使用RabbitTemplate同步操作的过程中丢失了到代理的连接，Spring AMQP会抛出AmqpException(通常是AmqpIOException)。</li>
<li>所以我们不会隐藏这一问题，所以你必须能够捕获并且响应这一异常。最简单处理方式是你认为连接断开，不是你这面的问题，重试这些操作。你可以手动的做这些，或者你可以使用Spring Retry来完成这些。</li>
<li>Spring Retry提供了一些AOP拦截器，重试的许多参数来简化重试。</li>
<li>Spring AMQP也提供了一些工厂来方便Spring Retry的创建。给你提供了强类型回调接口来实现定制的恢复逻辑。参看StatefulRetryOperationsInterceptor和StatelessRetryOperationsInterceptor获得更详细的说明。</li>
<li>如果没有事务或者事务在重试回调中，无状态重试就可以。</li>
<li>对于存在正在进行的事务或者要进行回滚，无状态重试并不适合。</li>
<li>在事务之间断开连接和事务回滚有着同样的效果，在这种情况下，有状态重试是最佳选择。</li>
</ul>
<p>从1.3版本开始，一个创建器API提供来用于装配拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatefulRetryOperationsInterceptor <span class="title">interceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RetryInterceptorBuilder.stateful()</span><br><span class="line">        .maxAttempts(<span class="number">5</span>)</span><br><span class="line">        .backOffOptions(<span class="number">1000</span>, <span class="number">2.0</span>, <span class="number">10000</span>) <span class="comment">// initialInterval, multiplier, maxInterval</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>只有重试的一部分功能可以通过这种方式来配置，如果需要更为高级的功能，你可以通过RetryTemplate来完成。</p>
<p>报文监听器和异步场景：</p>
<ul>
<li>如果MessageListener由于业务而失败而抛出异常，那么这个异常将会被消息监听器容器处理，接着它会处理另外一条消息。</li>
<li>如果这个错误是因为连接断开导致，那么接收消息的消费者必须必须取消并且重新启动。SimpleMessageListenerContainer无缝的处理了这些，并且记录了监听器被重新启动的日志。事实上，它会进行无限的反复尝试来启动这个消费者，如果消费者行为很糟糕否则它不会放弃。一个副作用是如果代理挂掉，它会不断尝试直到连接重新建立。</li>
<li>业务异常的处理和协议错误，连接断开的处理不一样，需要更多的考虑或者配置，尤其是在事务或者容器应答被启用的时候。在RabbitMQ2.8.x版本以前，对于dead letter没有明确的定义，所以因为业务处理异常而导致的拒绝或者回滚将导致消息被无限的发送下去。为了限制客户端重新发送的数目，以种选择是在监听器上使用 StatefulRetryOperationsInterceptor拦截器增强。这个监听器有一个恢复回调，这个回调中实现dead letter的行为。</li>
<li>另外一种处理方式，是设置rejectRqueued属性为false，这将导致所有的错误消息被丢弃。当RabbitMQ的版本是2.8.x或者是更高,这将使得消息转发到Dead Letter Exchange。</li>
<li>或者你可以抛出AmqpRejectAndDontRequeueException，这样阻止消息被重新塞入队列，不管defaultRequeueRejected是否设置。</li>
</ul>
<p>通常，两种技术可以结合使用。在增强链中使用StatefulRetryOperationsInterceptor，它的MessageRecover会抛出AmqpRejectAndDontRequeueException异常。如果尝试已经耗尽 MessageRecover将会被调用。默认的 MessageRecover简单的消费错误的消息，并且释放出警告信息。在这种情况下，消息得到了应答，但是不会被发送到Dead Letter Exchange。</p>
<p>从1.3版本开始，RepublishMessageRecoverer被提供在重试耗尽的情况下，来重新发布消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RetryOperationsInterceptor <span class="title">interceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RetryInterceptorBuilder.stateless()</span><br><span class="line">        .withMaxAttempts(<span class="number">5</span>)</span><br><span class="line">        .setRecoverer(newRepublishMessageRecoverer(amqpTemplate(), <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重试异常分类： </p>
<ul>
<li>Spring Retry拥有很大的灵活性来决定什么样的异常可以出发重试。默认的情况下，所有的异常都会出发重试。在用户异常被包装在ListenerExecutionFailedException里面的情况下，我们需要分类器检测到异常起因。默认情况下，分类器只查看顶级异常。</li>
<li>自从Spring1.0.3开始，分类器BinaryExceptionClassifier有一个traverseCauses属性。当设置为true时，它将横向查找匹配的异常源。</li>
<li>为了使用这个分类器进行重试，使用SimpleRetryPolicy，它的构造函数中有最大尝试次数，异常Map，还有 traverseCauses选项。你需要将这个策略注入到RetryTemplate中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;consumerConnectionFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomCachingConnectionFactory <span class="title">consumerConnectionFactory</span><span class="params">(<span class="meta">@Value(&quot;$&#123;spring.rabbitmq.consumer.addresses&#125;&quot;)</span> String addresses,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.consumer.username&#125;&quot;)</span> String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.consumer.password&#125;&quot;)</span> String password,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.consumer.virtual-host&#125;&quot;)</span> String virtualHost)</span> </span>&#123;</span><br><span class="line">        CustomCachingConnectionFactory connectionFactory = <span class="keyword">new</span> CustomCachingConnectionFactory();</span><br><span class="line">        connectionFactory.setAddresses(addresses);</span><br><span class="line">        connectionFactory.setUsername(username);</span><br><span class="line">        connectionFactory.setPassword(password);</span><br><span class="line">        connectionFactory.setVirtualHost(virtualHost);</span><br><span class="line">        connectionFactory.setPublisherConfirms(<span class="keyword">true</span>);</span><br><span class="line">        connectionFactory.setConnectionListeners(Arrays.asList(<span class="keyword">new</span> ConnectionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;**********************创建rabbitmq链接:&#123;&#125;&quot;</span>, connectionFactory.getReBindings().size());</span><br><span class="line">                    Channel channel = connectionFactory.createConnection().createChannel(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">for</span> (CustomCachingConnectionFactory.ReBindingHandler reBinding : connectionFactory.getReBindings()) &#123;</span><br><span class="line">                        reBinding.reBinding(channel);</span><br><span class="line">                    &#125;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">                logger.info(<span class="string">&quot;----------------rabbitmq链接断开&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCachingConnectionFactory</span> <span class="keyword">extends</span> <span class="title">CachingConnectionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ReBindingHandler&gt; reBindings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ReBindingHandler&gt; <span class="title">getReBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reBindings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomCachingConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addReBindingHandler</span><span class="params">(ReBindingHandler reBindingHandler)</span></span>&#123;</span><br><span class="line">        reBindings.add(reBindingHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReBindingHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重新绑定队列，路由键绑定关系</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reBinding</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue1ConsumerConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者最小个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.minnum.task.consumers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minNumConsumers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者最大个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.maxnum.task.consumers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxNumConsumers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换器名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE = <span class="string">&quot;exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列路由键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY = <span class="string">&quot;routing1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queue1ConsumerRabbitTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">queue1ConsumerRabbitTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Qualifier(&quot;consumerConnectionFactory&quot;)</span> CustomCachingConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RabbitTemplate clientRabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRabbitTemplate.setExchange(FUND_TASK_EXCHANGE);</span><br><span class="line">            connection = clientRabbitTemplate.getConnectionFactory().createConnection();</span><br><span class="line">            channel = connection.createChannel(<span class="keyword">false</span>);</span><br><span class="line">            beding(channel);</span><br><span class="line">            connectionFactory.addReBindingHandler((newchannel) -&gt; beding(newchannel));</span><br><span class="line">            logger.info(<span class="string">&quot;RabbitMQ连接成功(queue1)： exchange:&#123;&#125; queue:&#123;&#125; routing:&#123;&#125;&quot;</span>, EXCHANGE, ROUTING_KEY, ROUTING_KEY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AmqpException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;RabbitMQ连接异常(queue1)&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;RabbitMQ关闭异常(queue1)&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clientRabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beding</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE, <span class="string">&quot;topic&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">            channel.queueDeclare(QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            channel.queueBind(QUEUE, EXCHANGE, ROUTING_KEY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;RabbitMQ操作错误(queue1)&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queue1ConsumerListenerContainerFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">queue1ConsumerListenerContainerFactory</span><span class="params">(SimpleRabbitListenerContainerFactoryConfigurer configurer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                                        <span class="meta">@Qualifier(&quot;consumerConnectionFactory&quot;)</span> ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConcurrentConsumers(minNumConsumers);</span><br><span class="line">        factory.setMaxConcurrentConsumers(maxNumConsumers);</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue1Consumer <span class="title">queue1Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue1Consumer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-解决消息幂等性问题"><a href="#5-2-解决消息幂等性问题" class="headerlink" title="5.2 解决消息幂等性问题"></a>5.2 解决消息幂等性问题</h3><p>MQ消费者的幂等性问题，在于MQ的重试机制，因为网络原因或客户端延迟消费导致重复消费。</p>
<h4 id="5-2-1-RabbitMQ自动重试机制"><a href="#5-2-1-RabbitMQ自动重试机制" class="headerlink" title="5.2.1 RabbitMQ自动重试机制"></a>5.2.1 RabbitMQ自动重试机制</h4><p>消费者在消费消息的时候，如果消费者业务逻辑出现程序异常，这个时候我们如何处理？</p>
<ul>
<li>使用重试机制，RabbitMQ默认开启重试机制。</li>
</ul>
<p>实现原理：</p>
<ul>
<li><code>@RabbitHandler</code> 注解底层使用Aop拦截，如果程序（消费者）没有抛出异常，自动提交事务。</li>
<li>如果Aop使用异常通知拦截获取到异常后，自动实现补偿机制，消息缓存在RabbitMQ服务器端。</li>
</ul>
<p>注意：</p>
<ul>
<li>默认会一直重试到消费者不抛异常为止，这样显然不好。我们需要修改重试机制策略，如间隔3s重试一次)</li>
</ul>
<p>配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment"># 端口号</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment"># 账号</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># 地址(类似于数据库的概念)</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/admin_vhost</span></span><br><span class="line">    <span class="comment"># 消费者监听相关配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="comment"># 开启消费者(程序出现异常)重试机制，默认开启并一直重试</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="comment"># 重试间隔时间(毫秒)</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>



<h4 id="5-2-2-如何合理选择重试机制？"><a href="#5-2-2-如何合理选择重试机制？" class="headerlink" title="5.2.2 如何合理选择重试机制？"></a>5.2.2 如何合理选择重试机制？</h4><ul>
<li>情况1：消费者获取到消息后，调用第三方接口，但接口暂时无法访问，是否需要重试？<ul>
<li>需要重试，可能是因为网络原因短暂不能访问。</li>
</ul>
</li>
<li>情况2：消费者获取到消息后，抛出数据转换异常，是否需要重试？<ul>
<li>不需要重试，因为属于程序bug，需要重新发布版本。</li>
</ul>
</li>
</ul>
<p>对于情况2，如果消费者代码抛出异常是需要发布新版本才能解决的问题，那么不需要重试，重试也无济于事。应该采用<strong>日志记录 + 定时任务job进行健康检查 + 人工进行补偿</strong>。</p>
<h4 id="5-2-3-调用第三方接口自动实现补偿机制"><a href="#5-2-3-调用第三方接口自动实现补偿机制" class="headerlink" title="5.2.3 调用第三方接口自动实现补偿机制"></a>5.2.3 调用第三方接口自动实现补偿机制</h4><p>我们知道RabbitMQ在消费者消费发生异常时，会自动进行补偿机制，所以我们（消费者）在调用第三方接口时，可以根据返回结果判断是否成功：</p>
<ul>
<li>成功：正常消费</li>
<li>失败：手动抛处一个异常，这时RabbitMQ自动给我们做重试 (补偿)。</li>
</ul>
<h4 id="5-2-4-如何解决消费者幂等性问题，防止重复消费"><a href="#5-2-4-如何解决消费者幂等性问题，防止重复消费" class="headerlink" title="5.2.4 如何解决消费者幂等性问题，防止重复消费"></a>5.2.4 如何解决消费者幂等性问题，防止重复消费</h4><ul>
<li>产生原因：网络延迟传输中，消费者出现异常或者消费者延迟消费，会造成进行MQ重试补偿，在重试过程中，可能会造成重复消费。</li>
<li>解决方案：<ol>
<li>使用全局MessageID判断消费者是否消费过，解决幂等性。</li>
<li>通过业务逻辑保证唯一，如订单编号。</li>
</ol>
</li>
</ul>
<p>生产者核心代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProducer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String queueName)</span> </span>&#123;</span><br><span class="line">		String msg = <span class="string">&quot;my_fanout_msg:&quot;</span> + System.currentTimeMillis();</span><br><span class="line">		<span class="comment">//请求头设置消息id（messageId）</span></span><br><span class="line">		Message message = MessageBuilder.withBody(msg.getBytes()).setContentType(MessageProperties.CONTENT_TYPE_JSON)</span><br><span class="line">				.setContentEncoding(<span class="string">&quot;utf-8&quot;</span>).setMessageId(UUID.randomUUID() + <span class="string">&quot;&quot;</span>).build();</span><br><span class="line">		System.out.println(msg + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">		amqpTemplate.convertAndSend(queueName, message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>消费者核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout_email_queue&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 获取消息Id</span></span><br><span class="line">		String messageId = message.getMessageProperties().getMessageId();</span><br><span class="line">		String msg = <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		<span class="comment">//② 判断唯一Id是否被消费，消息消费成功后将id和状态保存在日志表中，我们从（①步骤）表中获取并判断messageId的状态即可</span></span><br><span class="line">		<span class="comment">//从redis中获取messageId的value</span></span><br><span class="line">		String value = redisUtils.get(messageId)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(value.equals(<span class="string">&quot;1&quot;</span>) )&#123; <span class="comment">//表示已经消费</span></span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">//结束</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;邮件消费者获取生产者消息&quot;</span> + <span class="string">&quot;messageId:&quot;</span> + messageId + <span class="string">&quot;,消息内容:&quot;</span> + msg);</span><br><span class="line">		JSONObject jsonObject = JSONObject.parseObject(msg);</span><br><span class="line">		<span class="comment">// 获取email参数</span></span><br><span class="line">		String email = jsonObject.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">		<span class="comment">// 请求地址</span></span><br><span class="line">		String emailUrl = <span class="string">&quot;http://127.0.0.1:8083/sendEmail?email=&quot;</span> + email;</span><br><span class="line">		JSONObject result = HttpClientUtils.httpGet(emailUrl);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 因为网络原因,造成无法访问,继续重试</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;调用接口失败!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行结束....&quot;</span>);</span><br><span class="line">		<span class="comment">//① 执行到这里已经消费成功，我们可以修改messageId的状态，并存入日志表(可以存到redis中，key为消息Id、value为状态)</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-5-SpringBoot整合RabbitMQ应答模式-ACK"><a href="#5-2-5-SpringBoot整合RabbitMQ应答模式-ACK" class="headerlink" title="5.2.5 SpringBoot整合RabbitMQ应答模式(ACK)"></a>5.2.5 SpringBoot整合RabbitMQ应答模式(ACK)</h4><p>修改配置simple下添加 <code>acknowledge-mode: manual</code> ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment"># 端口号</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment"># 账号</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># 地址(类似于数据库的概念)</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/admin_vhost</span></span><br><span class="line">    <span class="comment"># 消费者监听相关配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="comment"># 开启消费者(程序出现异常)重试机制，默认开启并一直重试</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="comment"># 重试间隔时间(毫秒)</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">3000</span></span><br><span class="line">        <span class="comment"># 开启手动ack</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>



<p>消费者增加代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long deliveryTag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG); <span class="comment">// 手动ack</span></span><br><span class="line">channel.basicAck(deliveryTag, <span class="keyword">false</span>); <span class="comment">//手动签收</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邮件队列</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutEamilConsumer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;fanout_email_queue&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message, <span class="meta">@Headers</span> Map&lt;String, Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out</span><br><span class="line">				.println(Thread.currentThread().getName() + <span class="string">&quot;,邮件消费者获取生产者消息msg:&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">						+ <span class="string">&quot;,messageId:&quot;</span> + message.getMessageProperties().getMessageId());</span><br><span class="line">		<span class="comment">// 手动ack</span></span><br><span class="line">		Long deliveryTag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">		<span class="comment">// 手动签收</span></span><br><span class="line">		channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3-限流"><a href="#5-3-限流" class="headerlink" title="5.3 限流"></a>5.3 限流</h3><p><strong>应用场景</strong>：如电商系统的抢购，瞬间有巨大流量生成，通过消息队列先进先出的特性，对请求进行削峰，控制消费的速度（限流）避免系统被挤爆。</p>
<h4 id="（1）通过配置文件实现"><a href="#（1）通过配置文件实现" class="headerlink" title="（1）通过配置文件实现"></a>（1）通过配置文件实现</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">concurrency:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-concurrency:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>



<h4 id="（2）-RabbitListener"><a href="#（2）-RabbitListener" class="headerlink" title="（2）@RabbitListener"></a>（2）@RabbitListener</h4><p>利用 <code>@RabbitListener</code> 中的 <code>concurrency</code> 属性进行指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootMsqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;spring-boot-direct-queue&quot;,concurrency = &quot;5-10&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive message:&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最小5个，最大10个消费者。</p>
<p>单个消费者如果收到消息过多也可能存在风险，可以通过设置预取 <code>prefetch count</code> 来控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootMsqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;spring-boot-direct-queue&quot;,concurrency = &quot;5-10&quot;,containerFactory = &quot;mqConsumerlistenerContainer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive message:&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CachingConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;mqConsumerlistenerContainer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">mqConsumerlistenerContainer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        factory.setPrefetchCount(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>配置成功后，<code>consumer</code> 单位时间内接收到消息就是50条。</p>
<hr>
<p>参考：</p>
<p>🔗 《<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-amqp/2.1.2.RELEASE/reference/_reference.html">Spring AMQP 中文文档</a>》</p>
<p>🔗 《<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38380858/article/details/84258507">Spring整合rabbitmq实践（一）：基础使用配置</a>》</p>
<p>🔗 《<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38380858/article/details/84258658">Spring整合rabbitmq实践（二）：扩展功能</a>》</p>
<p>🔗 《<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38252039/article/details/91409955">RabbitMQ解决消息幂等性问题</a>》</p>
<p>🔗 《<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38380858/article/details/84963944">spring-rabbit消费过程解析及AcknowledgeMode选择</a>》</p>
<p>🔗 《<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2e90f9070995">RabbitMQ连接池——CachingConnectionFactory</a>》</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2021092501.html" rel="bookmark">RabbitMQ（十）扩展-消息追踪和负载均衡</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2021092201.html" rel="bookmark">RabbitMQ（九）网络分区</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020101301.html" rel="bookmark">RabbitMQ（八）高阶</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020101001.html" rel="bookmark">RabbitMQ（七）Federation与Shovel</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020100801.html" rel="bookmark">RabbitMQ（六）运维</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2021092601.html" title="Spring AMQP">http://linyishui.top/2021092601.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/spring/" rel="tag"><i class="fa fa-tag"></i> spring</a>
              <a href="/tags/distributed/" rel="tag"><i class="fa fa-tag"></i> distributed</a>
              <a href="/tags/mom/" rel="tag"><i class="fa fa-tag"></i> mom</a>
              <a href="/tags/rabbitmq/" rel="tag"><i class="fa fa-tag"></i> rabbitmq</a>
              <a href="/tags/amqp/" rel="tag"><i class="fa fa-tag"></i> amqp</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021092501.html" rel="prev" title="RabbitMQ（十）扩展-消息追踪和负载均衡">
                  <i class="fa fa-chevron-left"></i> RabbitMQ（十）扩展-消息追踪和负载均衡
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021101301.html" rel="next" title="Oracle锁 <转>">
                  Oracle锁 <转> <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
