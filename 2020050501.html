<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的Redis相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——Redis">
<meta property="og:url" content="http://linyishui.top/2020050501.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Redis相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010116.jpg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010116.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/lru%E5%AD%97%E6%AE%B5.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003180157.jpg">
<meta property="article:published_time" content="2020-05-05T03:44:21.000Z">
<meta property="article:modified_time" content="2025-02-16T07:58:42.978Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010116.jpg">


<link rel="canonical" href="http://linyishui.top/2020050501.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2020050501.html","path":"2020050501.html","title":"面试整理——Redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——Redis | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98"><span class="nav-text">一. 综合问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Redis%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%A2%EF%BC%9Fredis-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：你为什么要在项目中使用Redis，如何使用的呢？redis 使用场景？⭐⭐⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BC%93%E5%AD%98%E5%8A%A0%E9%80%9F%EF%BC%8C%E9%99%8D%E4%BD%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E5%8A%9B"><span class="nav-text">1. 缓存加速，降低数据库压力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Session%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E5%8C%96"><span class="nav-text">2. Session集中管理，实现服务无状态化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E5%8C%96%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-text">3. 原子操作实现无锁化并发控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8D%8F%E8%B0%83%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE"><span class="nav-text">4. 分布式锁协调资源访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%AE%9E%E6%97%B6%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%8E%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">5. 实时排行榜与计数器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%8B-Redis%EF%BC%9F%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：简单描述下 Redis？支持哪些数据结构？有什么优点？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis单线程为什么执行速度这么快？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9FRedis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9FRedis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%A4%9A%E6%A0%B8-CPU-%E7%9A%84%E5%88%A9%E7%94%A8%E7%8E%87%EF%BC%9FRedis-6-0%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%886-0%E5%8F%88%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis是单线程？Redis的单线程特性有什么优缺点？Redis 是单线程的，如何提高多核 CPU 的利用率？Redis 6.0之前为什么不使用多线程？为什么6.0又引入了多线程？⭐⭐⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9FRedis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">Redis是单线程？Redis的单线程特性有什么优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%A4%9A%E6%A0%B8CPU%E5%88%A9%E7%94%A8%E7%8E%87%EF%BC%9F"><span class="nav-text">Redis的单线程，如何提高多核CPU利用率？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-6-0%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">Redis 6.0之前为什么不使用多线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%886-0%E5%8F%88%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">为什么6.0又引入了多线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E4%B8%8EIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E3%80%81epoll%E3%80%81poll-%E5%92%8C-select-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">Redis的事件驱动模型与IO多路复用、epoll、poll 和 select 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E6%9C%89%E5%93%AA%E4%BA%9BJava%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9F%E5%85%B6%E4%B8%ADJedis-%E4%B8%8E-Redisson-%E5%AF%B9%E6%AF%94%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis有哪些Java客户端？其中Jedis 与 Redisson 对比优缺点？⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A1%E4%BA%BF%E4%B8%AAkey%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%8910w%E4%B8%AAkey%E6%98%AF%E4%BB%A5%E6%9F%90%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%89%8D%E7%BC%80%E5%BC%80%E5%A4%B4%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%AE%83%E4%BB%AC%E5%85%A8%E9%83%A8%E6%89%BE%E5%87%BA%E6%9D%A5%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%B9%B3%E6%97%B6%E4%BD%BF%E7%94%A8Redis%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9Ftododododod"><span class="nav-text">问：讲一下平时使用Redis遇到过哪些问题？如何解决的？tododododod</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">二. 底层数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9FRedis%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%81%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90%EF%BC%9F"><span class="nav-text">问：Redis支持哪些数据结构？Redis各种数据结构的使用场景、内部编码及底层实现、优缺点？⭐⭐⭐？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#String"><span class="nav-text">String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hash"><span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List"><span class="nav-text">List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ZSet"><span class="nav-text">ZSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9FRedis-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%B8%80%E4%B8%AA-String-%E7%9A%84%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90%EF%BC%9F"><span class="nav-text">问：Redis中的字符串类型是怎么实现的？Redis 如何存储一个 String 的？⭐⭐⭐？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASDS%E7%9B%B8%E6%AF%94%E5%8E%9F%E7%94%9F%E7%9A%84char-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F%E7%9F%A5%E9%81%93%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B9%88%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90%EF%BC%9F"><span class="nav-text">问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？⭐⭐⭐？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E7%9A%84hash%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9Frehash%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90%EF%BC%9F"><span class="nav-text">问：Redis的hash底层如何实现？rehash做了哪些优化？⭐⭐⭐？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%A7%A6%E5%8F%91Rehash%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">1. 触发Rehash的条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B8%90%E8%BF%9B%E5%BC%8FRehash%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 渐进式Rehash流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%93%8D%E4%BD%9C%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-text">3. 操作兼容性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Azset%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9Fzset%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8%E8%80%8C%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90%EF%BC%9F"><span class="nav-text">问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？⭐⭐⭐？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%80%E4%B8%AA-Redis-%E5%AE%9E%E4%BE%8B%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E7%9A%84keys%EF%BC%9FList%E3%80%81Set%E3%80%81Sorted-Set-%E4%BB%96%E4%BB%AC%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E5%85%83%E7%B4%A0%EF%BC%9F%E2%AD%90"><span class="nav-text">问：一个 Redis 实例最多能存放多少的keys？List、Set、Sorted Set 他们最多能存放多少元素？⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9FRedis-%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9FRedis%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9%E5%86%85%E5%AD%98%EF%BC%88%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%89%EF%BC%9F"><span class="nav-text">问：Redis 的内存占用情况怎么样？Redis 的内存用完了会发生什么？Redis如何压缩内存（内存优化）？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-text">Redis 的内存占用情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">Redis 的内存用完了会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9%E5%86%85%E5%AD%98%EF%BC%88%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%89%EF%BC%9F"><span class="nav-text">Redis如何压缩内存（内存优化）？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-Redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">三. Redis高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E6%85%A2%E6%9F%A5%E8%AF%A2%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis慢查询？⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-Pipeline%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis Pipeline？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-Lua%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis Lua？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aredis%E4%BA%8B%E5%8A%A1%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：redis事务？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aredis%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="nav-text">问：redis事务的实现特征？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E5%A4%A7%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis如何大批量插入数据？⭐⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="nav-text">四. 发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%EF%BC%9FPubSub%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis的发布订阅机制？PubSub有什么缺点？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-Stream%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis Stream？⭐⭐⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Redis-Stream-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1. Redis Stream 是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Redis-Stream-%E6%93%8D%E4%BD%9C"><span class="nav-text">2. Redis Stream 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3. 使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">4. 关键问题与解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Redis-Stream-vs-Kafka-%E5%AF%B9%E6%AF%94"><span class="nav-text">5. Redis Stream vs Kafka 对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Redis-%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%90%97%EF%BC%9F"><span class="nav-text">6. Redis 适合作为消息队列吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F%E8%83%BD%E4%B8%8D%E8%83%BD%E7%94%9F%E4%BA%A7%E4%B8%80%E6%AC%A1%E6%B6%88%E8%B4%B9%E5%A4%9A%E6%AC%A1%E5%91%A2%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis如何实现消息队列？能不能生产一次消费多次呢？⭐⭐⭐?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis如何实现延时队列？⭐⭐⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Sorted-Set%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="nav-text">Sorted Set（有序集合）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-text">List + 定时任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis-Stream%EF%BC%88%E6%B6%88%E6%81%AF%E6%B5%81%EF%BC%89"><span class="nav-text">Redis Stream（消息流）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pub-Sub%EF%BC%88%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%EF%BC%89%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">Pub&#x2F;Sub（发布&#x2F;订阅）模式（不推荐）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">五. 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%9F%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%AD%96%E7%95%A5%EF%BC%9FRedis%E5%A6%82%E4%BD%95%E5%81%9A%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Redis 持久化策略？如何选择合适的策略？Redis如何做持久化？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E7%AA%81%E7%84%B6%E6%9C%BA%E5%99%A8%E6%96%AD%E7%94%B5%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：如果突然机器断电会怎样？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Abgsave%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：bgsave的原理是什么？⭐⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARDB%E4%B8%8EAOF%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：RDB与AOF区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E5%92%8C%E7%BC%93%E5%AD%98%E6%80%8E%E4%B9%88%E5%81%9A%E6%89%A9%E5%AE%B9%EF%BC%9FTODODODODODO"><span class="nav-text">问：Redis 持久化数据和缓存怎么做扩容？TODODODODODO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-%E9%94%81"><span class="nav-text">六. 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BRedis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F%E8%AF%B4%E8%AF%B4%E6%80%8E%E4%B9%88%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8SETNX%EF%BC%9F"><span class="nav-text">问：讲一下Redis分布式锁？说说怎么用redis实现分布式锁？为什么使用SETNX？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedisson%EF%BC%9F"><span class="nav-text">问：Redisson？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedLock%EF%BC%9F"><span class="nav-text">问：RedLock？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aredis%E9%94%81%E7%BB%AD%E6%9C%9F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：redis锁续期问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E6%8F%90%E9%AB%98%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87%EF%BC%9F"><span class="nav-text">问：怎么提高缓存命中率？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Redis-%E7%9A%84Key%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%EF%BC%9F%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89-Key-%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：如何解决 Redis 的Key冲突问题？并发竞争 Key 问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%B8%B8%E8%A7%81%E6%96%B9%E6%A1%88"><span class="nav-text">Redis常见方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81%EF%BC%9F"><span class="nav-text">问：Redis如何实现限流？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88Fixed-Window%EF%BC%89"><span class="nav-text">1. 固定窗口计数器（Fixed Window）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88Sliding-Window%EF%BC%89"><span class="nav-text">2. 滑动窗口（Sliding Window）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%EF%BC%88Leaky-Bucket%EF%BC%89"><span class="nav-text">3. 漏桶算法（Leaky Bucket）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%EF%BC%88Token-Bucket%EF%BC%89"><span class="nav-text">4. 令牌桶算法（Token Bucket）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">Redis常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-text">问：Redis常见性能问题和解决方案？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BC%93%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E6%B7%98%E6%B1%B0%E7%9A%84%EF%BC%9FRedis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-text">问：缓存是如何淘汰的？Redis有哪些内存淘汰策略？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-text">淘汰策略触发条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E7%A7%8D%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3"><span class="nav-text">8种淘汰策略详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-text">核心算法原理与优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E9%80%89%E5%9E%8B%E6%8C%87%E5%8D%97"><span class="nav-text">策略选型指南</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="nav-text">配置与监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="nav-text">常见问题解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E8%BF%87%E6%9C%9Fkey%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%EF%BC%9F%E4%BB%A5%E5%8F%8A%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="nav-text">问：Redis过期key删除策略？以及惰性删除？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-text">Redis设置过期时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A-key-%E5%B7%B2%E8%BF%87%E6%9C%9F%E4%BA%86%EF%BC%9F"><span class="nav-text">如何判定 key 已过期了？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-text">三种过期删除策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85Redis%E9%87%87%E7%94%A8%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-text">实际Redis采用的删除策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%BA%93%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-text">从库的过期策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-text">问：Redis 回收进程如何工作的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%83%AD%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%86%B7%E6%95%B0%E6%8D%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Redis%E5%A4%84%E7%90%86%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F%E8%BF%9B%E8%A1%8C%E8%BF%87%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E5%90%97%EF%BC%9F"><span class="nav-text">问：热数据与冷数据？如何利用Redis处理热点数据？进行过缓存预热吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%83%AD%E7%82%B9Key%E9%97%AE%E9%A2%98%EF%BC%9Fhot-key%E5%87%BA%E7%8E%B0%E9%80%A0%E6%88%90%E9%9B%86%E7%BE%A4%E8%AE%BF%E9%97%AE%E9%87%8F%E5%80%BE%E6%96%9C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="nav-text">问：Redis怎么解决热点Key问题？hot key出现造成集群访问量倾斜解决办法？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="nav-text">1.本地缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AF%B7%E6%B1%82%E5%88%86%E6%91%8A"><span class="nav-text">2.请求分摊</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%99%90%E6%B5%81"><span class="nav-text">3.限流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%9B%91%E6%8E%A7%E5%92%8C%E6%8A%A5%E8%AD%A6"><span class="nav-text">4.监控和报警</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E7%83%AD%E7%82%B9Key"><span class="nav-text">备份热点Key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-text">缓存预热</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="nav-text">问：什么是缓存穿透、缓存击穿、缓存雪崩？如何避免？三者对比？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-text">1.缓存穿透</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-text">2.缓存击穿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-text">3.缓存雪崩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="nav-text">对比总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-AKF%E5%88%86%E6%B2%BB%EF%BC%9F"><span class="nav-text">问：Redis AKF分治？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？双写一致性问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E3%80%81%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E3%80%81%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">缓存与数据库的一致性问题、常见场景、双写一致性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%EF%BC%88%E6%9E%81%E5%B0%91%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-text">1. 强一致性方案（极少使用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%EF%BC%88%E4%B8%BB%E6%B5%81%E9%80%89%E6%8B%A9%EF%BC%89"><span class="nav-text">2. 最终一致性方案（主流选择）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%99%8D%E7%BA%A7%E8%A1%A5%E5%81%BF%E6%96%B9%E6%A1%88"><span class="nav-text">3. 降级补偿方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Canal-binlog-%E6%96%B9%E6%A1%88"><span class="nav-text">Canal + binlog 方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E7%9A%84%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：Redis的主从不一致问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E4%B9%9F%E6%89%9B%E4%B8%8D%E4%BD%8F%E4%BA%86%EF%BC%8C%E4%B8%87%E7%BA%A7%E7%9A%84%E6%B5%81%E9%87%8F%E6%89%93%E5%9C%A8DB%E4%B8%8A%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9Ftodododododododo"><span class="nav-text">问：Redis也扛不住了，万级的流量打在DB上，该怎么处理？todododododododo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-text">问：Redis 常见性能问题和解决方案？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81CPU-%E7%9B%B8%E5%85%B3"><span class="nav-text">一、CPU 相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="nav-text">二、内存相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="nav-text">三、网络与连接问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-text">四、持久化与数据安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%A4%8D%E5%88%B6%E9%97%AE%E9%A2%98"><span class="nav-text">五、集群与复制问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aredis%E9%98%BB%E5%A1%9E%E5%8E%9F%E5%9B%A0%EF%BC%9F%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%AD%89"><span class="nav-text">问：redis阻塞原因？以及解决方案等</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x-Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-text">x. Redis高并发高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F-Redis-%E6%98%AF%E5%89%8D%E6%9C%9F%E5%81%9A%E8%BF%98%E6%98%AF%E5%90%8E%E6%9C%9F%E8%A7%84%E6%A8%A1%E4%B8%8A%E6%9D%A5%E4%BA%86%E5%86%8D%E5%81%9A%E5%A5%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：分布式 Redis 是前期做还是后期规模上来了再做好？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">问：Redis的同步机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%B8%BB%E4%BB%8E%EF%BC%8C%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="nav-text">问：Redis 的部署方式了解么？主从，集群？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E4%B8%BB%E4%BB%8E%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-text">问：Redis主从机制了解么？怎么实现的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="nav-text">一、复制拓扑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%A4%8D%E5%88%B6%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-text">二、复制配置与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BB%BA%E7%AB%8B%E5%A4%8D%E5%88%B6"><span class="nav-text">1. 建立复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%96%AD%E5%BC%80%E5%A4%8D%E5%88%B6"><span class="nav-text">2. 断开复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8F%AA%E8%AF%BB%E6%A8%A1%E5%BC%8F"><span class="nav-text">3. 只读模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BC%A0%E8%BE%93%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96"><span class="nav-text">4. 传输延迟优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B5%81%E7%A8%8B"><span class="nav-text">三、主从复制原理与流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%85%AD%E6%AD%A5%E6%B5%81%E7%A8%8B"><span class="nav-text">1. 主从复制六步流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">四、数据同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%EF%BC%88Full-Sync%EF%BC%89"><span class="nav-text">1. 全量同步（Full Sync）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%83%A8%E5%88%86%E5%90%8C%E6%AD%A5%EF%BC%88Partial-Sync%EF%BC%89"><span class="nav-text">2. 部分同步（Partial Sync）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="nav-text">3. 心跳机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">4. 异步复制机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="nav-text">五、主从复制状态监控</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%85%B3%E9%94%AE%E5%91%BD%E4%BB%A4"><span class="nav-text">1. 关键命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">2. 异常处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">六、生产环境最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis-%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%9FReids-Sentinel%EF%BC%9F"><span class="nav-text">问：Redis 的哨兵模式？Reids Sentinel？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">1. 主从复制的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Redis-Sentinel-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">2. Redis Sentinel 哨兵模式是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA-Redis-Sentinel"><span class="nav-text">3. 如何搭建 Redis Sentinel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Sentinel-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">4. Sentinel 的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Sentinel-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">5. Sentinel 客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E9%9B%86%E7%BE%A4%E4%B8%ADKey%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="nav-text">Redis集群中Key的定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0-key"><span class="nav-text">Redis 哨兵模式下如何找到 key</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E9%9B%86%E7%BE%A4%EF%BC%9F%E6%A8%A1%E5%BC%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E6%A7%BD%EF%BC%9F%E4%B8%80%E4%B8%AA-key-%E5%80%BC%E5%A6%82%E4%BD%95%E5%9C%A8-redis-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%89%BE%E5%88%B0%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="nav-text">问：Redis集群？模式性能优化？什么是哈希槽？一个 key 值如何在 redis 集群中找到存储在哪？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%9B%86%E7%BE%A4%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">一、集群前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E7%90%86%E8%AE%BA"><span class="nav-text">1. 数据分布理论</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Redis-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><span class="nav-text">2. Redis 数据分区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="nav-text">二、搭建集群</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE"><span class="nav-text">1. 节点配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%9B%86%E7%BE%A4%E5%88%9B%E5%BB%BA%EF%BC%88redis-trib-rb%EF%BC%89"><span class="nav-text">2. 集群创建（redis-trib.rb）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%EF%BC%88%E9%9A%8F%E6%9C%BA%E4%B8%BB%E4%BB%8E%EF%BC%89"><span class="nav-text">2.1 创建集群（随机主从）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-%E6%8C%87%E5%AE%9A%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="nav-text">2.2 指定主从节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="nav-text">3. 集群管理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="nav-text">三、集群伸缩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9"><span class="nav-text">1. 集群扩容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%9B%86%E7%BE%A4%E7%BC%A9%E5%AE%B9"><span class="nav-text">2. 集群缩容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%BF%81%E7%A7%BB%E7%9B%B8%E5%85%B3"><span class="nav-text">3. 迁移相关</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1"><span class="nav-text">四、请求路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E3%80%81Smart-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">五、Smart 客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86"><span class="nav-text">六、集群原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1"><span class="nav-text">1. 节点通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-text">2. 故障转移</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%EF%BC%88redis-cli-%E2%80%93cluster%EF%BC%89"><span class="nav-text">七、集群管理命令（redis-cli –cluster）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E7%BB%BC%E8%BF%B0"><span class="nav-text">集群原理综述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%9B%86%E7%BE%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9FRedis%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%9B%86%E7%BE%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="nav-text">问：集群不可用场景？Redis如何判断集群不可用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E9%9B%86%E7%BE%A4%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%99%E6%93%8D%E4%BD%9C%E4%B8%A2%E5%A4%B1%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：Redis集群会发生写操作丢失吗？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E8%B0%88Redis%E5%93%A8%E5%85%B5%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="nav-text">问：谈谈Redis哨兵、复制、集群？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHystrix%E7%9A%84%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FHystrix%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARedis%E5%88%86%E5%8C%BA%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9F%E5%88%86%E5%8C%BA%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">问：Redis分区场景？实现方案？分区的缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFCanal%EF%BC%9F"><span class="nav-text">问：什么是Canal？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BA%BF%E7%BA%A7%E7%94%A8%E6%88%B7%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">问：亿级用户热点数据更新如何优化？</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2020050501.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——Redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-05 11:44:21" itemprop="dateCreated datePublished" datetime="2020-05-05T11:44:21+08:00">2020-05-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-02-16 15:58:42" itemprop="dateModified" datetime="2025-02-16T15:58:42+08:00">2025-02-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>156k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:22</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的Redis相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一-综合问题"><a href="#一-综合问题" class="headerlink" title="一. 综合问题"></a>一. 综合问题</h2><p>位于速度相差较大的两种硬件之间，<strong>用于协调两者数据传输速度差异的结构，可称之为缓存</strong>。比如做一次内存寻址大概需要 100ns，而做一次磁盘的查找则需要 10ms，差了万倍。缓冲区则是一块临时存储数据的区域，用以弥补高速和低速设备通信时的速度差。</p>
<ul>
<li><strong>缓存比较适合于读多写少的业务场景，并且数据最好带有一定的热点属性。</strong> </li>
<li><strong>缓存会给整体系统带来复杂度，并且会有数据不一致的风险。</strong></li>
<li><strong>缓存通常使用内存作为存储介质，但是内存并不是无限的。</strong> </li>
<li><strong>缓存会给运维也带来一定的成本。</strong></li>
</ul>
<h3 id="问：你为什么要在项目中使用Redis，如何使用的呢？redis-使用场景？⭐⭐⭐"><a href="#问：你为什么要在项目中使用Redis，如何使用的呢？redis-使用场景？⭐⭐⭐" class="headerlink" title="问：你为什么要在项目中使用Redis，如何使用的呢？redis 使用场景？⭐⭐⭐"></a>问：你为什么要在项目中使用Redis，如何使用的呢？redis 使用场景？⭐⭐⭐</h3><p>你为什么要在项目中使用Redis？</p>
<ol>
<li>高性能：磁盘读取通常在几毫秒，而内存则在几十微秒，速度可能差10倍100倍。</li>
<li>高并发：MySQL的并发量差不多在1000次/s，而Redis可以轻松达到10W级别，超过10W后，通过分片集群来扩展。</li>
<li>高可用：主节点挂掉从节点代替。</li>
</ol>
<p>选择Redis的核心原因在于：</p>
<ul>
<li><strong>性能</strong>：内存操作，单节点10万+ QPS，满足高并发场景。</li>
<li><strong>数据结构</strong>：String、Hash、Set等丰富结构，适配多样业务需求。</li>
<li><strong>原子性</strong>：单命令或Lua脚本保障操作原子性，简化并发控制。</li>
<li><strong>高可用</strong>：Cluster模式、持久化策略保障数据可靠性。</li>
</ul>
<p>在项目中使用 <strong>Redis</strong> 通常是为了提高系统性能、降低延迟，并简化一些高并发场景下的数据存储和访问问题。Redis 是一个基于内存的高性能键值存储系统，能够提供非常快速的读写操作，适合用作缓存、消息队列、分布式锁、计数器等多种场景。</p>
<p><strong>为什么要使用 Redis？</strong></p>
<ol>
<li><strong>提高性能和降低延迟</strong>：<ul>
<li><strong>内存存储</strong>：Redis 是一个内存数据库，数据存储在 RAM 中，读写速度极快。这使得 Redis 特别适合缓存频繁访问的热点数据，减少数据库压力，提高整个系统的响应速度。</li>
<li><strong>适用于高并发</strong>：Redis 能够处理每秒数百万的请求，因此它是高并发场景中的理想选择。</li>
</ul>
</li>
<li><strong>缓存常用数据，减轻数据库负载</strong>：<ul>
<li>使用 Redis 缓存数据库中的热点数据，可以减少数据库的读取压力，提升响应速度，尤其在高并发的应用中尤为重要。</li>
<li>例如，对于用户信息、商品详情、统计数据等常用数据，可以通过 Redis 存储并定期更新。</li>
</ul>
</li>
<li><strong>支持持久化</strong>：<ul>
<li>Redis 提供了 <strong>RDB</strong> 和 <strong>AOF</strong> 两种持久化方式，可以确保数据在发生故障时不会丢失，适用于需要可靠数据存储的场景。</li>
</ul>
</li>
<li><strong>提供数据结构支持</strong>：<ul>
<li>Redis 支持丰富的数据结构，如 <strong>String</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>Sorted Set</strong>、<strong>Hash</strong> 等，可以满足多种不同的业务需求。</li>
<li>比如，使用 <strong>List</strong> 来实现队列，使用 <strong>Set</strong> 来去重，使用 <strong>Sorted Set</strong> 来实现排行榜等。</li>
</ul>
</li>
<li><strong>分布式特性</strong>：<ul>
<li>Redis 支持分布式部署，通过 <strong>Redis Cluster</strong> 和 <strong>主从复制</strong> 提供水平扩展性和高可用性。</li>
<li>适合大规模系统使用，支持分片和故障恢复，保证系统的稳定性和高可用性。</li>
</ul>
</li>
<li><strong>支持发布/订阅</strong>：<ul>
<li>Redis 支持 <strong>Pub/Sub</strong> 模式，允许系统之间进行实时的消息通知，适用于聊天系统、通知推送、日志收集等场景。</li>
</ul>
</li>
<li><strong>分布式锁和计数器</strong>：<ul>
<li>Redis 可以作为分布式锁的实现，确保在分布式环境下多个节点之间的互斥访问。</li>
<li>还可以用于实现分布式计数器（如统计访问次数、计数器等）。</li>
</ul>
</li>
</ol>
<p>使用场景：</p>
<ol>
<li>缓存：加速数据访问，降低数据库压力。</li>
<li>Session存储：实现服务无状态化，支持水平扩展。</li>
<li>分布式锁：协调分布式系统，处理并发问题，但可能这里提到的是无锁化设计，即用原子操作代替锁。</li>
<li>原子操作实现无锁化：例如库存扣减，使用DECR原子操作，避免使用锁，提升性能。</li>
</ol>
<p>详细：</p>
<ol>
<li><p><strong>缓存</strong>：常用于大型网站来加速数据访问和缓解后端数据库压力。Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。</p>
<p>再想想，可能项目中还用到了Redis做缓存，比如商品详情页的信息，用户频繁访问，使用Redis缓存减轻数据库压力，同时设置过期时间，保证数据一致性。或者用Redis的List结构实现异步队列，处理订单创建后的后续操作，比如发送通知，这样解耦系统组件，提高响应速度。缓存热点数据，减少数据库的压力</p>
<ul>
<li>会话缓存（session cache），Redis提供持久化。</li>
<li>全页缓存（FPC），即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC</li>
</ul>
</li>
<li><p><strong>排行榜</strong>：几乎所有网站都需要各种规则的排行榜，或是依据热度排行，或是发布时间，或是结合各种复杂维度计算。Redis提供了列表和有序集合数据结构，合理的使用这些结构可以很方便的构建各种排行榜系统。如 <code>ZRANGE user_scores 0 10 WITHSCORES</code> 。用Sorted Set做排行榜之类的</p>
</li>
<li><p><strong>计数器</strong>：如一些视频网站的播放数，电商网站的浏览数，对于数据的实时性有较高的要求，如果并发量很大时，传统关系型数据库很难做好这一工作。Redis天然支持计数功能，且性能优越。</p>
</li>
<li><p><strong>社交网络</strong>：比如赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等常见功能，由于社交网站访问量通常较大，且传统关系型数据库不太适合存储这种类型的数据，而Redis提供的数据结构比较容易实现这些功能。</p>
</li>
<li><p><strong>消息队列</strong>：大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列功能，虽然相比专业的消息队列还有所欠缺，但可以满足大部分基础需求。</p>
<p>或者用Redis的发布订阅功能实现消息通知；</p>
</li>
<li><p><strong>分布式锁</strong>：</p>
<p>无锁化，可能是指利用Redis的特性避免使用锁机制，比如使用原子操作或者Lua脚本来保证操作的原子性。例如，使用Redis的INCR命令实现计数器，或者用SETNX实现分布式锁，避免竞态条件。</p>
<p>还有，分布式锁的具体实现，比如用SET命令配合NX和PX参数，确保只有一个客户端能获得锁，处理完后再释放锁，避免并发问题。这可能是在分布式环境下协调不同服务实例的一种方式，但需要处理锁超时、误删锁等问题，通常用Lua脚本保证原子性。</p>
</li>
<li><p><strong>Session存储</strong>：</p>
<ul>
<li>服务无状态指的是服务实例不保存客户端的会话信息，每个请求都包含处理所需的所有信息。这样在水平扩展时，可以方便地增加或减少实例，而不需要担心会话数据的问题。这时候，通常会使用外部存储（如Redis）来保存Session，这样服务实例就可以无状态化。</li>
<li>在Session管理方面，用户登录后生成一个token，将用户信息存入Redis，并设置过期时间，每次请求携带token，服务端从Redis获取用户信息，这样服务实例不需要保存Session，实现了无状态。这样在扩容时，新增的实例可以直接处理请求，无需同步Session数据。</li>
</ul>
</li>
</ol>
<h4 id="1-缓存加速，降低数据库压力"><a href="#1-缓存加速，降低数据库压力" class="headerlink" title="1. 缓存加速，降低数据库压力"></a>1. 缓存加速，降低数据库压力</h4><p><strong>目的与优势：</strong><br>利用 Redis 高速的内存存储特性，将数据库中频繁访问的数据（如热门文章、用户信息、商品详情等）缓存起来，可以大幅降低数据库的压力，提高响应速度和系统吞吐量。</p>
<p><strong>实现方式：</strong><br>一般通过 <code>SET/GET</code>、<code>MSET/MGET</code> 等命令进行数据的读写；同时会结合过期策略（EXPIRE、TTL）来保证缓存数据的时效性。</p>
<p><strong>场景</strong>：商品详情页、热点数据查询</p>
<ul>
<li><strong>问题</strong>：高频访问的数据库查询（如商品信息）导致响应延迟，数据库负载过高。</li>
<li><strong>解决方案</strong>：使用Redis缓存查询结果，设置合理过期时间（如30分钟）。</li>
<li><strong>效果</strong>：缓存命中率超90%，数据库QPS下降70%，接口响应时间从200ms降至20ms。</li>
<li><strong>技术细节</strong>：采用缓存穿透（空值缓存）、雪崩（随机过期）防护策略，结合旁路缓存模式更新数据。</li>
</ul>
<hr>
<h4 id="2-Session集中管理，实现服务无状态化"><a href="#2-Session集中管理，实现服务无状态化" class="headerlink" title="2. Session集中管理，实现服务无状态化"></a>2. Session集中管理，实现服务无状态化</h4><p><strong>背景：</strong><br>在分布式系统中，为了实现各个服务节点之间的会话共享，传统的将 Session 存储在单台服务器内的方式难以满足扩展性需求。</p>
<p><strong>解决方案：</strong><br>将用户登录时产生的 Session 数据存储在 Redis 中，所有应用节点都从同一个 Redis 读取 Session 信息，从而使各个服务节点本身保持无状态（Stateless）。这种方式不仅便于横向扩展，还能保证用户在多节点之间的无缝切换。</p>
<p><strong>典型命令：</strong><br>使用 Spring Session 结合 Redis，即只需配置 <code>spring.session.store-type=redis</code>，系统便会将 HTTP Session 数据自动存储到 Redis 中。</p>
<p><strong>场景</strong>：用户登录态管理</p>
<ul>
<li><strong>问题</strong>：传统Tomcat Session存储在实例内存中，导致扩容时需Session粘滞或同步，扩展性差。</li>
<li><strong>解决方案</strong>：将Session序列化为JSON存入Redis，设置TTL（如30分钟），以Token（如JWT）为Key。</li>
<li><strong>效果</strong>：服务实例完全无状态，轻松扩容至数十节点，登录态查询时间稳定在5ms内。</li>
<li><strong>技术细节</strong>：采用Redis Cluster保障高可用，双写校验防止Session异常丢失。</li>
</ul>
<hr>
<h4 id="3-原子操作实现无锁化并发控制"><a href="#3-原子操作实现无锁化并发控制" class="headerlink" title="3. 原子操作实现无锁化并发控制"></a>3. 原子操作实现无锁化并发控制</h4><p><strong>场景</strong>：秒杀库存扣减</p>
<ul>
<li><strong>问题</strong>：高并发下数据库行锁导致性能瓶颈，事务竞争激烈。</li>
<li><strong>解决方案</strong>：库存预热至Redis，通过<code>DECR</code>原子操作扣减，结果≥0方允许下单。</li>
<li><strong>效果</strong>：秒杀接口支撑10万+ QPS，扣减操作耗时&lt;2ms，避免锁竞争及超卖问题。</li>
<li><strong>技术细节</strong>：Lua脚本封装“查询-扣减-返回结果”逻辑，保证原子性，异步同步库存至数据库。</li>
</ul>
<hr>
<h4 id="4-分布式锁协调资源访问"><a href="#4-分布式锁协调资源访问" class="headerlink" title="4. 分布式锁协调资源访问"></a>4. 分布式锁协调资源访问</h4><p><strong>挑战：</strong><br>在高并发环境下，对共享资源（例如订单生成、库存扣减）的访问必须保证原子性，传统的线程锁可能会带来阻塞和性能瓶颈。</p>
<p><strong>Redis 分布式锁：</strong><br>利用 Redis 的原子命令（例如 <code>SETNX</code> 或者带有过期时间的 <code>SET key value NX EX seconds</code>），可以实现跨节点的锁机制。</p>
<ul>
<li>这种锁的获取和释放可以通过 Lua 脚本来保证原子性，避免因锁释放不当而导致的误删或死锁问题。</li>
<li>使用分布式锁后，即使是多台服务器同时发起并发操作，也能保证只有一个实例能对共享资源进行修改，从而达到“无锁化”设计中希望减少竞争与阻塞的效果。</li>
</ul>
<p><strong>扩展应用：</strong><br>除了用于订单扣减等业务场景，还可用于业务中的其他需要同步控制的场合。</p>
<p><strong>场景</strong>：定时任务防重复执行</p>
<ul>
<li><strong>问题</strong>：多实例部署时，定时任务可能被多个节点触发，导致数据重复处理。</li>
<li><strong>解决方案</strong>：Redis的<code>SET key uuid NX EX 30</code>实现非阻塞锁，任务结束前通过Lua脚本验证释放。</li>
<li><strong>效果</strong>：任务精准单节点执行，锁操作耗时1ms，避免数据库唯一索引等悲观锁开销。</li>
</ul>
<hr>
<h4 id="5-实时排行榜与计数器"><a href="#5-实时排行榜与计数器" class="headerlink" title="5. 实时排行榜与计数器"></a>5. 实时排行榜与计数器</h4><p><strong>场景</strong>：直播打赏榜单</p>
<ul>
<li><strong>问题</strong>：实时更新用户积分并排序，数据库<code>ORDER BY</code>效率低。</li>
<li><strong>解决方案</strong>：Redis Sorted Set存储用户ID及积分，<code>ZINCRBY</code>更新分数，<code>ZREVRANGE</code>获取Top N。</li>
<li><strong>效果</strong>：榜单更新延迟&lt;10ms，支持百万级用户实时排名，接口响应时间稳定。</li>
</ul>
<hr>
<p><strong>消息队列：</strong><br>利用 Redis 的发布/订阅模式或基于 List/Stream 的消息队列机制，实现异步任务调度和服务解耦。</p>
<p><strong>限流与计数器：</strong><br>通过 Redis 的原子自增（INCR）等操作，可以轻松实现用户请求限流（例如根据 IP 或用户ID进行统计）以及计数器（如 PV、点赞数等）的功能。</p>
<p><strong>排行榜和排序：</strong><br>利用 Sorted Set 数据结构，可以高效构建游戏积分排行榜、文章点赞排行榜等应用场景，实现快速排序和分页查询。</p>
<h3 id="问：简单描述下-Redis？支持哪些数据结构？有什么优点？⭐⭐⭐"><a href="#问：简单描述下-Redis？支持哪些数据结构？有什么优点？⭐⭐⭐" class="headerlink" title="问：简单描述下 Redis？支持哪些数据结构？有什么优点？⭐⭐⭐"></a>问：简单描述下 Redis？支持哪些数据结构？有什么优点？⭐⭐⭐</h3><ul>
<li><p>什么是Redis？</p>
<ul>
<li>由<strong>C语言</strong>开发的一个<strong>基于高性能键值对</strong>的<strong>开源</strong>的<strong>内存数据库</strong>，是一个<strong>非关系型数据库</strong>（NoSQL）。因为是纯内存操作，所以性能非常出色，每秒可以处理10W次读写操作。支持持久化存储，支持多种数据结构，能够满足不同场景下的需求，且在分布式环境中具备高可用性和高扩展性。</li>
<li><strong>协议</strong>：Redis 使用 TCP 协议，并且客户端和服务器之间的通信是通过 RESP（REdis Serialization Protocol）协议进行的。</li>
</ul>
</li>
<li><p>支持哪些数据结构？</p>
<p>支持八种数据结构：字符串String，哈希Hash，数组List，集合Set，有序集合ZSet，位图BitMaps，基数统计HyperLogLig，地理信息定位GEO。</p>
<ol>
<li><strong>String（字符串）</strong>：<ul>
<li>最简单的数据类型，值可以是任意的字符串（如文本、数字等）。</li>
<li>支持操作：<code>SET</code>、<code>GET</code>、<code>INCR</code>、<code>DECR</code>、<code>MGET</code> 等。</li>
</ul>
</li>
<li><strong>List（列表）</strong>：<ul>
<li>支持双向链表，按照插入顺序保存元素。</li>
<li>支持操作：<code>LPUSH</code>、<code>RPUSH</code>、<code>LPOP</code>、<code>RPOP</code>、<code>LRANGE</code>、<code>LSET</code> 等。</li>
</ul>
</li>
<li><strong>Set（集合）</strong>：<ul>
<li>无序集合，不允许重复元素。</li>
<li>支持操作：<code>SADD</code>、<code>SREM</code>、<code>SMEMBERS</code>、<code>SINTER</code>、<code>SUNION</code>、<code>SDIFF</code> 等。</li>
</ul>
</li>
<li><strong>Sorted Set（有序集合）</strong>：<ul>
<li>和 Set 类似，但每个元素都会关联一个权重（分数），可以根据分数进行排序。</li>
<li>支持操作：<code>ZADD</code>、<code>ZREM</code>、<code>ZRANGE</code>、<code>ZREVRANGE</code>、<code>ZINCRBY</code> 等。</li>
</ul>
</li>
<li><strong>Hash（哈希）</strong>：<ul>
<li>用于存储键值对的集合，适合用于存储对象。</li>
<li>支持操作：<code>HSET</code>、<code>HGET</code>、<code>HGETALL</code>、<code>HDEL</code> 等。</li>
</ul>
</li>
<li><strong>Bitmap（位图）</strong>：<ul>
<li>用于高效存储和操作大规模的二进制位数据，常用于计数器、标志位等场景。</li>
<li>支持操作：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code> 等。</li>
</ul>
</li>
<li><strong>HyperLogLog</strong>：<ul>
<li>用于做基数统计（即统计不同元素的数量），适合用于大规模的数据去重、唯一计数等。</li>
<li>支持操作：<code>PFADD</code>、<code>PFCOUNT</code>、<code>PFMERGE</code> 等。</li>
</ul>
</li>
<li><strong>Geo（地理空间）</strong>：<ul>
<li>用于存储和处理地理位置信息，如经纬度。</li>
<li>支持操作：<code>GEOADD</code>、<code>GEODIST</code>、<code>GEORADIUS</code> 等。</li>
</ul>
</li>
<li><strong>Streams（流）</strong>：<ul>
<li>用于消息队列和日志的场景，支持持久化消息、消费者组等功能。</li>
<li>支持操作：<code>XADD</code>、<code>XREAD</code>、<code>XGROUP</code>、<code>XACK</code> 等。</li>
</ul>
</li>
</ol>
<p>2</p>
</li>
<li><p>优点？</p>
<ul>
<li><strong>支持数据结构</strong>：Redis 支持丰富的数据类型（如字符串、列表、哈希、集合、有序集合等）。支持多种数据结构和算法，所以<strong>应用面广</strong>。例如，可以使用 <code>Sorted Set</code> 来实现排行榜，使用 <code>List</code> 来实现队列，使用 <code>Hash</code> 来存储对象等。</li>
<li><strong>高性能</strong>：将数据存放在内存，所以有<strong>高效的读写性能</strong>。Redis 可以处理每秒上百万次的请求，适合用作缓存、会话存储等高频访问的数据存储。</li>
<li><strong>支持持久化</strong>：通过快照（RDB）和日志（AOF）两种方式支持数据持久化。内存中的数据通过快照和日志的方式保存在硬盘，所以<strong>不易丢失</strong>。<ul>
<li><strong>RDB</strong>（快照方式）：定期将内存中的数据快照保存到磁盘上。</li>
<li><strong>AOF</strong>（追加文件方式）：通过记录每次写操作的日志，确保数据的持久化。</li>
</ul>
</li>
<li><strong>原子性操作</strong>：Redis 支持原子性的操作，确保操作的原子性和一致性。</li>
<li><strong>支持发布/订阅</strong>：支持 Pub/Sub 模式，允许客户端间的消息通信。允许客户端订阅某些频道，并接收发布到这些频道的消息，适用于消息队列、通知推送等应用场景。</li>
<li><strong>支持事务</strong>：支持多命令的事务操作。<ul>
<li>Redis 支持简单的事务操作，允许多个命令一次性执行，保证原子性。</li>
<li>支持的命令包括：<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code> 等。</li>
</ul>
</li>
<li><strong>轻量级与易用性</strong>：<ul>
<li>Redis 是一个轻量级的系统，配置和使用非常简单，且客户端支持多种编程语言（如 Java、Python、C++、Go 等）。</li>
<li>Redis 还具有简单的命令行客户端，可以直接通过命令进行交互，便于开发和调试。</li>
</ul>
</li>
<li><strong>高可用性</strong>：通过主从复制、哨兵（Sentinel）和分片（Cluster）提供高可用性和扩展性。<ul>
<li><strong>主从复制</strong>：支持数据的主从复制，提供高可用性。</li>
<li><strong>Redis Sentinel</strong>：提供故障自动恢复和监控。</li>
<li><strong>Redis Cluster</strong>：支持水平扩展，允许将数据分片到多个节点上，提高系统的处理能力。</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="问：Redis单线程为什么执行速度这么快？⭐⭐⭐"><a href="#问：Redis单线程为什么执行速度这么快？⭐⭐⭐" class="headerlink" title="问：Redis单线程为什么执行速度这么快？⭐⭐⭐"></a>问：Redis单线程为什么执行速度这么快？⭐⭐⭐</h3><p>常见操作的响应时间：1秒=10^3毫秒=10^6微秒=10^9纳秒</p>
<ol>
<li><p>打开一个站点：几秒。</p>
</li>
<li><p>数据库查询一条记录（有索引）：十几毫秒。</p>
</li>
<li><p>从机械磁盘顺序读取1M数据：2~10毫秒。 对于 7200 转的机械硬盘，顺序读1MB数据的时间一般在这个范围内；随机读取则通常在 8～12 毫秒甚至更高。</p>
</li>
<li><p>从SSD磁盘顺序读取1M数据：0.3毫秒。由于 SSD 随机读取不需要移动磁头，随机和顺序读取相差不大。</p>
<ul>
<li><p><strong>NVMe SSD：</strong> 大约 0.1~0.5 毫秒</p>
<p><strong>SATA SSD：</strong> 可能在 1~2 毫秒左右</p>
</li>
</ul>
</li>
<li><p>从内存连续读取1M数据：通常在 40~100 微秒之间。</p>
<ul>
<li>现代 DDR4 内存带宽很高（例如 25~50 GB/s），因此1MB数据的拷贝时间理想情况下可能在几十微秒内完成。</li>
</ul>
</li>
<li><p>1.6G的CPU执行一条指令：0.6纳秒。</p>
</li>
<li><p>CPU读取一次内存：100纳秒。</p>
</li>
<li><p>1G网卡，网络传输2Kb数据：20微秒。</p>
</li>
</ol>
<ol>
<li>纯内存操作，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快。</li>
<li>单线程操作，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</li>
<li>采用了非阻塞I/O多路复用机制，从而支撑起大量的网络请求，减少了线程切换时上下文切换和竞争。</li>
</ol>
<p>总结：</p>
<p>Redis 的高性能来源于其单线程设计和高效的内存存储，同时避免了多线程的复杂性、锁的竞争和上下文切换的开销。通过事件驱动模型和非阻塞 I/O，Redis 能够在单线程中高效地处理大量请求，而内存存储和简洁的网络协议进一步提升了其执行速度。在高并发和低延迟场景下，Redis 仍能保持较高的性能表现。</p>
<ol>
<li><p><strong>避免了线程上下文切换的开销</strong></p>
<ul>
<li>在多线程环境中，操作系统需要在多个线程之间切换，这个过程称为线程上下文切换。线程切换会带来性能损耗，因为需要保存和恢复线程的状态，包括寄存器、程序计数器和内存页的切换等。每次上下文切换都需要消耗一定的 CPU 时间。</li>
<li>Redis 采用单线程模型，所有操作在同一个线程中顺序执行，不需要进行上下文切换，因此避免了多线程竞争和上下文切换的开销。这使得 Redis 的执行速度非常快，尤其在高并发环境下，减少了线程切换的延迟。</li>
</ul>
</li>
<li><p><strong>避免了锁的竞争</strong></p>
<ul>
<li>在多线程环境中，多个线程可能会并发地访问共享资源，为了保证数据的一致性和线程安全，常常需要使用锁（如互斥锁、读写锁等）。锁的竞争和管理会带来性能损耗。</li>
<li>由于 Redis 使用单线程模型，不会发生线程间的资源竞争，也就不需要使用锁。因此，避免了锁带来的开销和复杂性，提升了执行效率。</li>
</ul>
</li>
<li><p><strong>事件驱动和非阻塞 I/O 模型</strong></p>
<ul>
<li>Redis 采用了 <strong>事件驱动</strong> 的模型，使用了 <strong>非阻塞 I/O</strong>（比如通过 <code>epoll</code>、<code>select</code> 等高效的 I/O 多路复用机制）。在 Redis 中，所有 I/O 操作（如网络通信）都是非阻塞的，并且 Redis 使用一个单一的线程来处理所有的请求。</li>
<li>事件驱动模型意味着 Redis 可以同时处理多个客户端的请求，但每个请求在单线程中依次执行，这避免了复杂的多线程管理。</li>
<li>例如，多个客户端发送的请求会被放入一个事件循环队列中，Redis 会按顺序处理这些请求，执行 I/O 操作时不会阻塞其它请求，因此能高效地利用 CPU 时间。</li>
</ul>
</li>
<li><p><strong>操作是原子性的，简化了实现</strong></p>
<ul>
<li>Redis 的操作通常是非常简单和高效的，且每个命令都保证原子性。例如，命令如 <code>SET</code>、<code>GET</code>、<code>INCR</code> 等都是单一操作，它们在执行时不会被其他命令打断，操作的粒度非常小，能够高效完成。</li>
<li>对 Redis 来说，命令的执行没有复杂的事务管理或者多线程的上下文切换问题，因此可以确保每个操作非常快速。</li>
</ul>
</li>
<li><p><strong>内存存储，减少 I/O 和磁盘操作</strong></p>
<ul>
<li>Redis 作为内存数据库，其数据存储在内存中，而不是磁盘。相比于传统的磁盘存储，内存的读写速度要快得多。</li>
<li>由于 Redis 中大部分操作只涉及内存，不会频繁访问磁盘，减少了磁盘 I/O 操作，这进一步提升了性能。</li>
</ul>
</li>
<li><p><strong>高效的数据结构和算法</strong></p>
<ul>
<li>Redis 的数据结构设计非常高效，采用了多种优化算法，能够快速处理各种类型的数据请求。例如，哈希表、跳表（用于 Sorted Set）、链表等结构都经过优化，能够在常数时间复杂度（O(1)）或者对数时间复杂度（O(logN)）内完成操作，确保操作速度快。</li>
<li>Redis 内部的数据结构优化能够有效减少内存占用和提高数据访问速度，使得它在高并发的情况下仍然能够保持较高的性能。</li>
</ul>
</li>
<li><p><strong>高效的内存管理</strong></p>
<ul>
<li>Redis 使用自定义的内存分配器（基于 jemalloc），能高效地管理内存，减少内存碎片。这种内存分配器是专为高性能环境设计的，可以提供更好的内存访问速度和性能。</li>
<li>由于 Redis 的数据结构存储在内存中，访问速度比传统数据库更快，极大地提升了响应速度。</li>
</ul>
</li>
<li><p><strong>简化的网络协议</strong></p>
<ul>
<li>Redis 使用的是 <strong>RESP（REdis Serialization Protocol）</strong> 协议，它比传统的 HTTP 或其他协议要简洁得多。由于协议本身非常轻量，Redis 可以更快速地解析和响应客户端请求。</li>
<li>简单的协议格式也减少了网络带宽和延迟的消耗，有助于提升 Redis 的响应速度。</li>
</ul>
</li>
</ol>
<h3 id="问：Redis是单线程？Redis的单线程特性有什么优缺点？Redis-是单线程的，如何提高多核-CPU-的利用率？Redis-6-0之前为什么不使用多线程？为什么6-0又引入了多线程？⭐⭐⭐"><a href="#问：Redis是单线程？Redis的单线程特性有什么优缺点？Redis-是单线程的，如何提高多核-CPU-的利用率？Redis-6-0之前为什么不使用多线程？为什么6-0又引入了多线程？⭐⭐⭐" class="headerlink" title="问：Redis是单线程？Redis的单线程特性有什么优缺点？Redis 是单线程的，如何提高多核 CPU 的利用率？Redis 6.0之前为什么不使用多线程？为什么6.0又引入了多线程？⭐⭐⭐"></a>问：Redis是单线程？Redis的单线程特性有什么优缺点？Redis 是单线程的，如何提高多核 CPU 的利用率？Redis 6.0之前为什么不使用多线程？为什么6.0又引入了多线程？⭐⭐⭐</h3><h4 id="Redis是单线程？Redis的单线程特性有什么优缺点？"><a href="#Redis是单线程？Redis的单线程特性有什么优缺点？" class="headerlink" title="Redis是单线程？Redis的单线程特性有什么优缺点？"></a>Redis是单线程？Redis的单线程特性有什么优缺点？</h4><p>Redis 在大多数情况下执行命令时采用单线程模型。也就是说，所有客户端命令的执行都是在一个线程中顺序处理的，这使得它避免了线程间竞争、加锁、上下文切换等开销，从而实现了非常高的响应速度。</p>
<p>优点</p>
<ul>
<li><strong>简单高效</strong><br>单线程模型使得 Redis 的内部数据结构操作不需要复杂的锁机制，从而避免了并发竞争带来的额外开销和死锁问题。</li>
<li><strong>原子性和一致性</strong><br>因为所有操作在同一线程中顺序执行，每个命令都是原子的，不需要担心中间状态被其他线程看到，这极大简化了开发和调试。</li>
<li><strong>低延迟</strong><br><strong>避免多线程上下文切换和同步开销（无锁）</strong>，能够在极低延迟下处理大量请求。</li>
</ul>
<p>缺点</p>
<ul>
<li><p><strong>不能利用多核 CPU</strong><br>单线程意味着在单个 Redis 实例中，命令的处理只能在一个 CPU 核心上执行。当遇到 CPU 密集型命令时，可能无法充分利用多核机器的优势。</p>
</li>
<li><p><strong>某些操作成为瓶颈</strong></p>
<p>如果某些命令（例如复杂的 Lua 脚本、大量数据遍历）耗时较长，可能会阻塞其他请求，影响整体响应能力。导致请求队列积压。这可能引发系统响应时间的抖动或延迟。</p>
</li>
<li><p><strong>不适合 CPU 密集型任务</strong></p>
<p>Redis 本身是为低延迟、高吞吐量的内存数据库设计的，因此对于 CPU 密集型任务，它可能表现不如其他多线程处理模型，特别是在复杂计算的场景下。</p>
</li>
</ul>
<h4 id="Redis的单线程，如何提高多核CPU利用率？"><a href="#Redis的单线程，如何提高多核CPU利用率？" class="headerlink" title="Redis的单线程，如何提高多核CPU利用率？"></a>Redis的单线程，如何提高多核CPU利用率？</h4><ol>
<li>运行多个 Redis 实例：在多核服务器上，可以启动多个 Redis 实例（每个实例绑定一个 CPU 核心），然后通过分片或集群方式将数据分散到这些实例上，从而充分利用多核性能。</li>
<li>Redis Cluster（分片）：通过将数据分布到多个节点上，每个节点运行在不同的 CPU 核心上，从而达到多核并行处理的效果。</li>
<li>Redis 6.0 多线程 I/O 模型：在 Redis 6.0 之前，<strong>命令执行始终是单线程的</strong>，但网络 I/O（读写 socket）部分是<strong>通过 I/O 多路复用实现的，也只能在单个线程中处理</strong>。Redis 6.0 引入了多线程 I/O 支持，专门用于处理客户端的网络读写，减少网络 I/O 成为瓶颈，从而提高整体吞吐量。注意：命令执行依然保持单线程设计，以确保数据结构操作的原子性和一致性。<ul>
<li>允许将 I/O 操作（如网络请求和响应的读取、写入）分配给多个线程，这样可以让 Redis 在多核 CPU 上更好地利用资源。</li>
</ul>
</li>
</ol>
<p><strong>配置方式</strong>：</p>
<ul>
<li><p>在 Redis 6.0 及以上版本中，您可以通过 <code>io-threads</code> 配置参数来启用 I/O 线程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4</span><br><span class="line">io-threads-do-reads yes</span><br></pre></td></tr></table></figure></li>
<li><p>这使得 Redis 可以将网络请求的读写操作分配到 4 个线程上，从而在多核 CPU 上分担负载。</p>
</li>
</ul>
<h4 id="Redis-6-0之前为什么不使用多线程？"><a href="#Redis-6-0之前为什么不使用多线程？" class="headerlink" title="Redis 6.0之前为什么不使用多线程？"></a>Redis 6.0之前为什么不使用多线程？</h4><ol>
<li><strong>设计初衷</strong>：Redis 设计初期采用单线程模型是为了保证简单性、原子性和高效性。单线程可以避免加锁、上下文切换和并发控制复杂性，从而使得代码更简单、更稳定。</li>
<li><strong>性能足够</strong>：对于大多数场景，单线程模型结合高效的数据结构和 I/O 多路复用（epoll 等）已经能提供足够的吞吐量（百万级请求每秒），所以没有迫切需要多线程来分担命令执行的压力。<ul>
<li>首先使用Redis时，CPU不是瓶颈，而是受制于内存和网络。</li>
<li>Redis为了提高性能，使用Pipeline（批量命令）每秒100万请求，CPU开销也并不高。</li>
<li>单线程时，Redis内部维护成本低，不需考虑多线程安全性，并发读写增加了系统复杂度。多线程涉及到线程切换、加锁和解锁的开销、以及死锁的问题。</li>
<li>惰性Rehash（渐进式Rehash）使Redis阻塞情况很少。</li>
<li>一般的应用单线程Redis性能已能满足。</li>
</ul>
</li>
</ol>
<h4 id="为什么6-0又引入了多线程？"><a href="#为什么6-0又引入了多线程？" class="headerlink" title="为什么6.0又引入了多线程？"></a>为什么6.0又引入了多线程？</h4><ol>
<li>瓶颈转移：<ul>
<li><strong>性能仍有上限</strong>：单线程Redis，把数据放入内存，响应时间在100纳秒，对于比较小的数据包，比如8~10W qps（极限值）。对于超出极限的大项目，需要更大的QPS，则需要IO多线程（内部执行命令仍是单线程）。</li>
<li><strong>网络IO成为瓶颈</strong>：随着硬件性能提升和业务场景的发展，网络 I/O 部分开始成为瓶颈，尤其是在高并发情况下，处理成千上万的客户端连接会让单线程的 I/O 处理能力受到限制。</li>
</ul>
</li>
<li>Redis 6.0 引入了多线程 I/O 模型，用于处理网络读写操作（而非命令执行本身），这样可以更充分地利用多核 CPU，提高连接读写的并发性能，降低网络延迟。<ul>
<li><strong>目的</strong>：解决在极高并发场景下，由于网络 I/O 阻塞导致的性能瓶颈；</li>
<li><strong>设计</strong>：保持命令执行的单线程特性以确保原子性，同时采用多线程来分担网络数据的读取和写入任务。</li>
</ul>
</li>
</ol>
<p>为什么不采用分布式架构Redis？</p>
<ul>
<li>缺点：服务数量多维护成本太高、Redis命令不适用于数据分区、数据分区无法解决热点的读写问题、数据倾斜问题、重新分配、扩容、缩容等问题。</li>
<li>多线程任务分摊到Redis，同步IO读写负载，抗住更大的并发，利用CPU多核。</li>
</ul>
<h4 id="Redis的事件驱动模型与IO多路复用、epoll、poll-和-select-的区别"><a href="#Redis的事件驱动模型与IO多路复用、epoll、poll-和-select-的区别" class="headerlink" title="Redis的事件驱动模型与IO多路复用、epoll、poll 和 select 的区别"></a>Redis的事件驱动模型与IO多路复用、<code>epoll</code>、<code>poll</code> 和 <code>select</code> 的区别</h4><p>Redis 采用<strong>单线程事件驱动模型</strong>，通过 <strong>I/O 多路复用</strong> 技术实现高并发处理。尽管单线程，却能高效处理数万级 QPS，其核心在于：</p>
<ol>
<li><strong>纯内存操作</strong>：数据存储在内存，无磁盘 I/O 瓶颈。</li>
<li><strong>非阻塞 I/O</strong>：避免线程阻塞，最大化 CPU 利用率。</li>
<li><strong>事件驱动</strong>：通过事件循环（Event Loop）监听并分发事件。</li>
<li><strong>多路复用器</strong>：使用 <code>epoll</code>（Linux）或 <code>kqueue</code>（BSD）高效管理大量连接。</li>
</ol>
<p><code>epoll</code>、<code>poll</code> 和 <code>select</code> 都是 <strong>I/O 多路复用</strong> 的技术，它们的作用是能够在单线程中同时处理多个 I/O 事件（例如多个网络连接），这些技术常用于提高 I/O 操作的效率，减少阻塞和等待的时间。它们的主要区别在于使用的数据结构和工作原理。</p>
<ul>
<li>**<code>select</code>**：简单、老旧，限制文件描述符数量（通常为 1024），性能随着文件描述符数量增加而下降。</li>
<li>**<code>poll</code>**：克服了 <code>select</code> 的文件描述符数量限制，仍然是轮询式的，性能会随着文件描述符数量增多而下降。</li>
<li>**<code>epoll</code>**：现代的高效 I/O 多路复用技术，基于内核事件通知，适合高并发应用，性能最佳，支持大量并发连接。</li>
</ul>
<p>Redis 使用 <code>epoll</code> 的原因</p>
<p>Redis 使用 <code>epoll</code> 来处理多个客户端请求，因为 <code>epoll</code> 相较于 <code>select</code> 和 <code>poll</code> 在高并发环境下具有更高的性能，尤其是在连接数非常大的情况下。<code>epoll</code> 的内核事件通知机制和高效的 I/O 多路复用使 Redis 在高并发请求下能够保持低延迟和高吞吐量。</p>
<p><strong>关键区别解析</strong></p>
<ul>
<li><strong>水平触发（LT）</strong>：只要 FD 就绪，每次调用都会通知（可能重复触发）。</li>
<li><strong>边缘触发（ET）</strong>：仅在 FD 状态变化时通知一次，需一次处理完所有数据。</li>
<li><strong>epoll 优势</strong>：<ol>
<li><strong>高效事件通知</strong>：仅返回就绪的 FD，无需遍历所有连接。</li>
<li><strong>无 FD 数量限制</strong>：支持百万级并发连接（如 C10K 问题）。</li>
<li><strong>零拷贝</strong>：通过 <code>mmap</code> 减少内核与用户空间数据拷贝。</li>
</ol>
</li>
</ul>
<p>多路复用技术允许单个线程监听多个<strong>文件描述符（File Descriptor, FD，就是内核为了高效管理打开的文件创建的索引）</strong>的就绪状态，核心实现包括 <code>select</code>、<code>poll</code>、<code>epoll</code>：</p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>select</strong></th>
<th align="left"><strong>poll</strong></th>
<th align="left"><strong>epoll</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据结构</strong></td>
<td align="left">位数组（fd_set）固定大小</td>
<td align="left">链表（pollfd数组）可以动态增加</td>
<td align="left"><strong>红黑树+就绪链表</strong>。使用一个内核事件表（内核级别的事件通知机制），采用红黑树和双向链表来存储FD和它们的状态。基于事件驱动的机制，性能较好，尤其在大量连接的情况下</td>
</tr>
<tr>
<td align="left"><strong>最大FD数</strong></td>
<td align="left">1024（受 FD_SETSIZE 限制）</td>
<td align="left">无限制</td>
<td align="left">无限制</td>
</tr>
<tr>
<td align="left"><strong>原理</strong></td>
<td align="left"><code>select</code> 会检查所有FD的状态，如果有FD准备好（可读、可写、异常），则返回。它是阻塞的，直到至少一个FD准备好。它通过轮询检查每个FD来判断其状态。</td>
<td align="left">检查FD的状态，如果某个FD准备好，就会返回，并且不会像 <code>select</code> 那样限制最大FD的数量。<code>poll</code> 本身的工作原理与 <code>select</code> 类似，都是轮询检查每个文件描述符。</td>
<td align="left"><code>epoll</code> 提供了 <strong>水平触发（Level Triggered）</strong> 和 <strong>边缘触发（Edge Triggered）</strong> 两种工作模式。与 <code>select</code> 和 <code>poll</code> 不同，<code>epoll</code> 是基于内核通知的，当文件描述符的状态发生变化时，内核会通知用户程序，而无需在用户空间进行轮询。</td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td align="left">O(n) 轮询</td>
<td align="left">O(n) 轮询</td>
<td align="left">O(1) 事件通知</td>
</tr>
<tr>
<td align="left"><strong>触发方式</strong></td>
<td align="left">水平触发（LT）</td>
<td align="left">水平触发（LT）</td>
<td align="left">支持 LT/ET（边缘触发）</td>
</tr>
<tr>
<td align="left"><strong>内存拷贝</strong></td>
<td align="left">每次调用需全量拷贝 fd_set</td>
<td align="left">需拷贝 pollfd 数组</td>
<td align="left">内核与用户空间共享内存（mmap）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">跨平台兼容，小并发</td>
<td align="left">稍高并发，FD数较多</td>
<td align="left">高并发，Linux 专属</td>
</tr>
<tr>
<td align="left"><strong>缺点</strong></td>
<td align="left"><strong>性能瓶颈</strong>：<code>select</code> 需要每次调用时扫描所有的FD，这意味着当FD数量较多时，性能会迅速下降。 <strong>文件描述符限制</strong>：<code>select</code> 的最大FD数量通常是固定的（在 Linux 上默认是 1024），这限制了 <code>select</code> 可以监视的连接数。</td>
<td align="left"><strong>性能瓶颈</strong>：尽管 <code>poll</code> 没有 <code>select</code> 的FD限制，但当FD数量增加时，性能仍然会退化。每次调用时都需要检查所有FD。 <strong>依然是线性扫描</strong>：<code>poll</code> 仍然需要轮询所有FD，导致处理效率较低。</td>
<td align="left"><strong>内存消耗较大</strong>：由于需要维护红黑树和链表等数据结构，<code>epoll</code> 相比 <code>select</code> 和 <code>poll</code> 的内存消耗要大一些。 <strong>使用较复杂</strong>：<code>epoll</code> 的接口较为复杂，需要开发者理解事件的触发机制和如何管理事件，编程模型相比 <code>select</code> 和 <code>poll</code> 更加复杂。</td>
</tr>
</tbody></table>
<p><strong>Redis 事件驱动模型</strong></p>
<p>Redis 采用 <strong>Reactor 模式</strong>，核心组件包括：</p>
<ol>
<li><strong>事件分发器（Dispatcher）</strong>：通过多路复用器（如 <code>epoll</code>）监听 FD 事件。</li>
<li><strong>事件处理器（Handler）</strong>：处理就绪事件（如读、写、异常）。</li>
</ol>
<p><strong>Reactor 工作流程</strong></p>
<ol>
<li><p><strong>注册事件</strong>：将客户端 Socket 注册到多路复用器，监听读事件。</p>
</li>
<li><p><strong>事件循环</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    events = epoll_wait();  <span class="comment">// 阻塞等待事件就绪</span></span><br><span class="line">    <span class="keyword">for</span> (event in events) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.isReadable()) &#123;</span><br><span class="line">            readData();    <span class="comment">// 读取请求数据</span></span><br><span class="line">            process();     <span class="comment">// 执行 Redis 命令</span></span><br><span class="line">            addWriteEvent(); <span class="comment">// 注册写事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (event.isWritable()) &#123;</span><br><span class="line">            sendResponse(); <span class="comment">// 发送响应</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>非阻塞处理</strong>：每次事件处理快速完成，避免阻塞事件循环。</p>
</li>
</ol>
<p><strong>Proactor 模式对比</strong></p>
<ul>
<li><strong>Reactor</strong>：通知应用何时可读写，由应用完成 I/O 操作。</li>
<li><strong>Proactor</strong>：由内核完成 I/O 操作，通知应用直接处理结果。</li>
<li><strong>Redis 选择 Reactor 的原因</strong>：<ul>
<li>实现简单，适配现有 I/O 多路复用 API。</li>
<li>更精细控制 I/O 过程，避免内核异步操作的复杂性。</li>
</ul>
</li>
</ul>
<p><strong>Java NIO 实现机制</strong></p>
<p>Java NIO 基于类似的 Reactor 模式，核心组件包括：</p>
<ol>
<li><strong>Selector</strong>：多路复用器，对应 <code>epoll</code>/<code>kqueue</code>。</li>
<li><strong>Channel</strong>：双向数据通道（如 <code>SocketChannel</code>、<code>FileChannel</code>）。</li>
<li><strong>Buffer</strong>：数据缓冲区，支持非阻塞读写。</li>
</ol>
<p><strong>Java NIO 示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    selector.select(); <span class="comment">// 阻塞等待就绪事件</span></span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iter.next();</span><br><span class="line">        iter.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 处理新连接</span></span><br><span class="line">            SocketChannel client = serverChannel.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 读取数据并处理</span></span><br><span class="line">            SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            client.read(buffer);</span><br><span class="line">            process(buffer);</span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 写入响应</span></span><br><span class="line">            SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer response = ByteBuffer.wrap(<span class="string">&quot;OK&quot;</span>.getBytes());</span><br><span class="line">            client.write(response);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Java NIO 与 Redis 的异同</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>Redis</strong></th>
<th align="left"><strong>Java NIO</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>线程模型</strong></td>
<td align="left">单线程 Reactor</td>
<td align="left">多线程 Reactor（如 Netty）</td>
</tr>
<tr>
<td align="left"><strong>多路复用器</strong></td>
<td align="left">epoll/kqueue</td>
<td align="left">Selector（依赖 OS 实现）</td>
</tr>
<tr>
<td align="left"><strong>事件处理</strong></td>
<td align="left">单线程顺序执行所有命令</td>
<td align="left">通常使用线程池处理业务逻辑</td>
</tr>
<tr>
<td align="left"><strong>性能优化</strong></td>
<td align="left">无锁设计，纯内存操作</td>
<td align="left">需避免 Buffer 拷贝与线程竞争</td>
</tr>
</tbody></table>
<p><strong>生产环境优化实践</strong></p>
<ol>
<li><p><strong>Redis 配置调优</strong>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 epoll（Linux）</span></span><br><span class="line"><span class="attribute">io</span>-threads <span class="number">4</span>  # Redis <span class="number">6</span>.<span class="number">0</span>+ 支持多线程处理 I/O（非命令执行）</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Java NIO 优化</strong>：</p>
<ul>
<li>使用 Direct Buffer 减少内存拷贝。</li>
<li>分离 I/O 线程与业务线程（如 Netty 的 Boss/Worker 线程组）。</li>
</ul>
</li>
<li><p><strong>边缘触发注意事项</strong>：</p>
<ul>
<li>必须一次读取全部数据，否则可能丢失事件通知。</li>
<li>结合非阻塞 I/O 循环读取，直到 <code>EAGAIN</code> 错误。</li>
</ul>
</li>
</ol>
<h3 id="问：Redis有哪些Java客户端？其中Jedis-与-Redisson-对比优缺点？⭐⭐"><a href="#问：Redis有哪些Java客户端？其中Jedis-与-Redisson-对比优缺点？⭐⭐" class="headerlink" title="问：Redis有哪些Java客户端？其中Jedis 与 Redisson 对比优缺点？⭐⭐"></a>问：Redis有哪些Java客户端？其中Jedis 与 Redisson 对比优缺点？⭐⭐</h3><p>客户端包括：Redisson、Jedis、lettuce 等，官方推荐使用 Redisson。</p>
<ul>
<li>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；</li>
<li>Redisson实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li>
</ul>
<ol>
<li><strong>Jedis</strong>：<ul>
<li>Jedis 是最常用的 Redis 客户端之一，基于 <strong>阻塞 I/O</strong> 模型，使用较为简单，支持 Redis 提供的大部分命令。</li>
</ul>
</li>
<li><strong>Lettuce</strong>：<ul>
<li>Lettuce 是一个基于 <strong>非阻塞 I/O</strong> 的 Redis 客户端，支持同步和异步操作，适合高并发和异步应用场景。</li>
</ul>
</li>
<li><strong>Redisson</strong>：<ul>
<li>Redisson 是一个功能强大的 Redis 客户端，基于 Lettuce，提供了很多高级功能，比如分布式锁、分布式集合、分布式队列等，适合对 Redis 的高级特性有需求的应用。</li>
</ul>
</li>
<li><strong>Spring Data Redis</strong>：<ul>
<li>作为 Spring 框架的一部分，Spring Data Redis 提供了对 Redis 的集成，支持通过 Spring 管理 Redis 客户端，并提供模板式的 API 以便与 Spring 生态系统兼容。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li><strong>Jedis</strong>：适用于简单、高性能的应用场景，尤其在低并发和对 Redis 的使用需求较简单时，Jedis 作为经典客户端是一个非常不错的选择。它简单易用，性能优秀，但它使用的是阻塞 I/O，不适合高并发或需要异步操作的场景。</li>
<li><strong>Redisson</strong>：适用于需要 Redis 高级特性或分布式架构的场景，如分布式锁、分布式集合等。Redisson 提供了更多的功能和灵活性，特别适合处理高并发、分布式系统中的复杂任务，但它的学习曲线较陡，性能相对略逊于 Jedis。</li>
</ul>
<p>Jedis 与 Redisson 的对比</p>
<ol>
<li><strong>Jedis</strong></li>
</ol>
<ul>
<li><strong>特性</strong>：<ul>
<li>Jedis 是最经典的 Redis Java 客户端之一，主要基于 <strong>阻塞 I/O</strong> 模型，简单且易于使用，适合大部分 Redis 基本功能的应用。</li>
<li>它提供了同步的 API，操作简单直观，且支持大部分 Redis 命令。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>简单易用</strong>：Jedis 提供了非常简单的 API，开发者可以快速上手，适合需要快速集成 Redis 的应用。</li>
<li><strong>广泛使用</strong>：Jedis 已经被广泛使用，在社区中有大量的支持和资源，遇到问题容易找到解决方案。</li>
<li><strong>高性能</strong>：Jedis 在单线程场景下性能表现非常好，特别适合低延迟、高吞吐量的场景。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>阻塞 I/O 模型</strong>：Jedis 默认使用阻塞 I/O 模型，因此它的性能会受到线程阻塞的影响，在高并发的场景下可能出现性能瓶颈。每个连接在同一时刻只能处理一个请求，这可能导致资源利用率低。</li>
<li><strong>不支持异步操作</strong>：Jedis 本身没有内建异步的支持，虽然可以通过多线程或连接池来实现，但没有原生的异步支持。</li>
<li><strong>线程安全问题</strong>：Jedis 不是线程安全的，需要小心管理连接池，避免多个线程共享同一个 Jedis 实例。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>适合应用规模较小，连接请求量不太大的应用，特别是需要快速集成 Redis 的项目。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Redisson</strong></li>
</ol>
<ul>
<li><strong>特性</strong>：<ul>
<li>Redisson 是基于 <strong>Lettuce</strong> 的 Redis 客户端，支持 <strong>非阻塞 I/O</strong> 和异步操作。它提供了比 Jedis 更强大的功能，支持分布式数据结构（如分布式锁、队列、集合等）、分布式服务（如分布式 Executor）、缓存等高级特性。</li>
<li>Redisson 的 API 设计相对较复杂，但提供了更多的功能，可以处理更复杂的分布式任务。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>支持异步操作</strong>：Redisson 提供了丰富的异步 API，支持在高并发场景下异步执行 Redis 命令，适合异步编程模型。</li>
<li><strong>丰富的分布式功能</strong>：Redisson 提供了分布式锁（<code>RLock</code>）、分布式集合（<code>RSet</code>）、分布式队列（<code>RQueue</code>）、分布式 Map（<code>RMap</code>）等分布式数据结构，非常适合用于构建分布式应用。</li>
<li><strong>高层次抽象</strong>：Redisson 提供了比 Jedis 更高层次的抽象，例如它可以轻松地实现分布式锁、分布式延迟队列等复杂的分布式操作。</li>
<li><strong>支持同步、异步、反应式编程</strong>：Redisson 支持多种编程模型，包括同步、异步和基于响应式编程（Reactor）的编程模式，能够灵活应对不同场景。</li>
<li><strong>支持多种客户端类型</strong>：Redisson 支持 Redis 集群、哨兵模式以及单机模式，并且支持连接池。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>功能较多，学习成本高</strong>：由于 Redisson 提供了丰富的功能，可能对不需要这些高级特性的开发者来说，使用起来会有一定的学习成本。</li>
<li><strong>性能开销</strong>：由于 Redisson 提供了大量的分布式数据结构和服务，它的性能可能略逊色于 Jedis，尤其是在没有使用到这些高级功能时。</li>
<li><strong>较大的依赖</strong>：Redisson 引入了更多的依赖，导致包体积较大，可能在一些轻量级应用中不适用。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>适合需要 Redis 高级特性（如分布式锁、分布式集合等）的应用，尤其是需要分布式解决方案或异步操作的场景。</li>
<li>在高并发、大规模分布式系统中非常有用，特别是需要 Redis 实现分布式协调任务的场景。</li>
</ul>
</li>
</ul>
<p>对比表格</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Jedis</th>
<th>Redisson</th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接池支持</strong></td>
<td>支持连接池</td>
<td>支持连接池</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>需要显式使用连接池，非线程安全</td>
<td>线程安全</td>
</tr>
<tr>
<td><strong>I/O 模型</strong></td>
<td>阻塞 I/O</td>
<td>非阻塞 I/O</td>
</tr>
<tr>
<td><strong>异步支持</strong></td>
<td>不原生支持</td>
<td>支持异步操作，提供异步 API</td>
</tr>
<tr>
<td><strong>分布式特性</strong></td>
<td>无</td>
<td>支持分布式锁、分布式数据结构等高级特性</td>
</tr>
<tr>
<td><strong>学习曲线</strong></td>
<td>低，使用简单</td>
<td>高，功能丰富</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高效（适合简单的应用）</td>
<td>相对较慢（功能多，性能略逊）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适合简单、高性能、低并发的场景</td>
<td>适合分布式系统，特别是需要高级特性的场景</td>
</tr>
</tbody></table>
<h3 id="问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？⭐⭐⭐"><a href="#问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？⭐⭐⭐" class="headerlink" title="问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？⭐⭐⭐"></a>问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？⭐⭐⭐</h3><p>使用keys指令可以扫出指定模式的key列表。 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了 ，但是整体所花费的时间会比直接用keys指令长。</p>
<ul>
<li><strong>推荐使用 <code>SCAN</code> 命令</strong>，因为它是增量式扫描，能够避免 Redis 阻塞，性能更好，适合大规模的 key 查找。相比 <code>KEYS</code>，<code>SCAN</code> 更加高效，尤其在高并发环境中。</li>
<li><strong>避免使用 <code>KEYS</code> 命令</strong>，除非是在开发环境中对少量数据进行调试。</li>
<li>如果你有 Redis 集群，并且需要跨节点查询，可以使用 Redis 集群的 <code>SCAN</code> 来实现并行查询。</li>
</ul>
<ol>
<li><p><strong>使用 <code>KEYS</code> 命令</strong>（不推荐）</p>
<p><code>KEYS</code> 命令会一次性返回所有匹配的 key，假如你的数据库中有 1 亿个 key，那么使用 <code>KEYS</code> 命令会导致 Redis 阻塞，直到返回所有结果。这种做法非常低效，尤其是在生产环境中不推荐使用，因为它会对 Redis 性能产生严重影响，可能导致应用卡死。</p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys = r.keys(<span class="string">&#x27;prefix:*&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Found <span class="subst">&#123;<span class="built_in">len</span>(keys)&#125;</span> keys with prefix &#x27;prefix:&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li><strong>性能差</strong>：对于 1 亿个 key，<code>KEYS</code> 命令会一次性将所有 key 加载到内存，可能导致 Redis 性能下降甚至阻塞。</li>
<li><strong>阻塞 Redis</strong>：<code>KEYS</code> 命令会阻塞 Redis，直到命令完成，这可能会影响到其他操作。</li>
</ul>
</li>
<li><p><strong>使用 <code>SCAN</code> 命令</strong></p>
<p><code>SCAN</code> 命令是 Redis 提供的用于遍历 key 的命令。与 <code>KEYS</code> 命令相比，<code>SCAN</code> 更加高效，因为它是增量迭代的方式，不会一次性阻塞 Redis 服务。</p>
<ul>
<li>SCAN 命令不会一次性返回所有结果，而是以游标方式增量遍历整个 keyspace，不会阻塞 Redis 实例。</li>
<li>利用 <code>MATCH</code> 参数可以只匹配特定前缀的 key，如 <code>MATCH prefix*</code>。</li>
</ul>
<p><strong>循环遍历</strong></p>
<ul>
<li>从初始游标 0 开始，每次调用 SCAN 命令，获取部分匹配的 key 以及新的游标。</li>
<li>当 SCAN 命令返回的游标再次为 0 时，说明遍历完成。</li>
</ul>
<p><strong>收集结果</strong></p>
<ul>
<li>将每次返回的匹配 key 收集起来，直到得到所需的 10 万个 key（或者遍历完所有 key）。</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li>使用 Pipeline 技术（在支持的客户端中），减少网络往返次数，提高 SCAN 的遍历效率。</li>
<li>如果 key 数量非常多，可以考虑将收集到的 key 存入其他存储系统中做后续处理。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanParams;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisScanExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">scanKeys</span><span class="params">(Jedis jedis, String prefix, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        String cursor = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ScanParams params = <span class="keyword">new</span> ScanParams().match(prefix + <span class="string">&quot;*&quot;</span>).count(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ScanResult&lt;String&gt; scanResult = jedis.scan(cursor, params);</span><br><span class="line">            keys.addAll(scanResult.getResult());</span><br><span class="line">            cursor = scanResult.getCursor();</span><br><span class="line">        &#125; <span class="keyword">while</span> (!cursor.equals(<span class="string">&quot;0&quot;</span>) &amp;&amp; keys.size() &lt; count);</span><br><span class="line">        <span class="keyword">return</span> keys.subList(<span class="number">0</span>, Math.min(keys.size(), count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        List&lt;String&gt; keys = scanKeys(jedis, <span class="string">&quot;prefix:&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配到的 key 数量：&quot;</span> + keys.size());</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>SCAN</code> 命令的参数：<ul>
<li><code>cursor</code>：游标，用来标识当前遍历的进度。初次调用时，游标设置为 <code>0</code>。</li>
<li><code>match</code>：用于匹配 key 的模式，支持通配符 <code>*</code>。</li>
<li><code>count</code>：每次返回的结果数量，可以调整批次大小来控制内存使用和遍历速度。</li>
</ul>
</li>
<li><code>SCAN</code> 会返回两部分内容：<ul>
<li>新的游标 <code>cursor</code>，你将其传递给下次的 <code>SCAN</code> 调用。</li>
<li><code>partial_keys</code>，这次返回的匹配的 key。</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li><strong>非阻塞</strong>：<code>SCAN</code> 是增量遍历，不会一次性阻塞 Redis。</li>
<li><strong>内存友好</strong>：<code>SCAN</code> 会分批返回，不会消耗过多的内存。</li>
<li><strong>高效</strong>：对于大规模数据，<code>SCAN</code> 比 <code>KEYS</code> 更高效。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>不保证顺序</strong>：<code>SCAN</code> 是增量扫描，不能保证返回结果的顺序，如果需要保证顺序，你可能需要手动排序。</li>
<li><strong>可能重复扫描</strong>：<code>SCAN</code> 是增量式的，可能会在不同的迭代中扫描到相同的 key。为了避免这种情况，需要去重（可以通过集合 <code>set</code> 来存储）。</li>
</ul>
</li>
<li><p>使用 Redis 集群</p>
<p>如果你的 Redis 数据量很大，并且分布在多个 Redis 实例中，可以考虑使用 <strong>Redis 集群</strong> 来分布式存储 key。这种方法的优势是将数据分散到多个节点，减少单个节点的负担。然而，Redis 集群并不支持全局的 <code>SCAN</code> 命令，需要在多个节点上分别进行扫描。你需要通过集群的方式并行查询各个节点，找到匹配的 key。</p>
<p>代码示例：</p>
<ol>
<li><strong>获取所有节点</strong>：通过 <code>jedisCluster.getClusterNodes()</code> 得到集群中所有节点的连接池，然后遍历这些节点。为避免重复扫描（因为从节点的数据和主节点一致），只对主节点进行扫描。可通过 <code>jedis.info(&quot;replication&quot;)</code> 判断节点角色。</li>
<li><strong>SCAN 操作</strong>：在每个 master 节点上，使用 SCAN 命令（通过 Jedis 的 <code>scan</code> 方法）增量遍历 keyspace，利用 <code>MATCH</code> 参数只匹配特定前缀的 key。由于 SCAN 返回的游标不为 “0” 时表示未遍历完，故需要循环直到游标返回 “0”。</li>
<li><strong>合并结果</strong>：将所有 master 节点扫描到的 key 合并到一个 List 中返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterScanExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 Redis 集群中所有 master 节点执行 SCAN，并返回匹配指定前缀的 key 列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedisCluster JedisCluster 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix       要匹配的 key 前缀，例如 &quot;prefix:&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count        每次 SCAN 时返回的数量提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 匹配的 key 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">scanClusterKeys</span><span class="params">(JedisCluster jedisCluster, String prefix, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; allKeys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String matchPattern = prefix + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">        ScanParams scanParams = <span class="keyword">new</span> ScanParams().match(matchPattern).count(count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 JedisCluster 获取所有节点的连接</span></span><br><span class="line">        Map&lt;String, JedisPool&gt; nodeMap = jedisCluster.getClusterNodes();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : nodeMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 只扫描 master 节点，避免重复扫描从节点</span></span><br><span class="line">            <span class="keyword">try</span> (Jedis jedis = entry.getValue().getResource()) &#123;</span><br><span class="line">                String info = jedis.info(<span class="string">&quot;replication&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (info.contains(<span class="string">&quot;role:slave&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;  <span class="comment">// 如果当前节点是从节点，则跳过</span></span><br><span class="line">                &#125;</span><br><span class="line">                String cursor = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    ScanResult&lt;String&gt; scanResult = jedis.scan(cursor, scanParams);</span><br><span class="line">                    allKeys.addAll(scanResult.getResult());</span><br><span class="line">                    cursor = scanResult.getCursor();</span><br><span class="line">                &#125; <span class="keyword">while</span> (!cursor.equals(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 处理个别节点异常，不影响整体扫描</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allKeys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置 Redis 集群节点地址</span></span><br><span class="line">        Set&lt;HostAndPort&gt; clusterNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        clusterNodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        clusterNodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        clusterNodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7002</span>));</span><br><span class="line">        <span class="comment">// 可根据实际情况添加更多节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 JedisCluster 实例</span></span><br><span class="line">        JedisCluster jedisCluster = <span class="keyword">new</span> JedisCluster(clusterNodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 scanClusterKeys 方法，查找以 &quot;prefix:&quot; 开头的 key</span></span><br><span class="line">        List&lt;String&gt; keys = scanClusterKeys(jedisCluster, <span class="string">&quot;prefix:&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配到的 key 数量：&quot;</span> + keys.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(<span class="number">10</span>, keys.size()); i++) &#123;</span><br><span class="line">            System.out.println(keys.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>优点：</p>
<ul>
<li><strong>分布式</strong>：可以将数据分散到多个节点上，减少单个节点的压力。</li>
<li><strong>高可用性</strong>：Redis 集群通过分片保证了高可用性。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>复杂性</strong>：需要配置 Redis 集群，并通过客户端执行多节点的 <code>SCAN</code>。</li>
<li><strong>开发成本</strong>：使用 Redis 集群会增加开发和维护的复杂性。</li>
</ul>
</li>
<li><p>通过 Redis 分片和前缀方案优化</p>
<p>在一些极端的场景下，可以考虑将 key 设计成多前缀的方式（例如，基于用户 ID 或其他分片键），这样可以减少每次查询时的 key 数量，从而提高查询效率。这种方法适用于你在设计时就有考虑到如何分布 key 的情况。</p>
</li>
</ol>
<h3 id="问：讲一下平时使用Redis遇到过哪些问题？如何解决的？tododododod"><a href="#问：讲一下平时使用Redis遇到过哪些问题？如何解决的？tododododod" class="headerlink" title="问：讲一下平时使用Redis遇到过哪些问题？如何解决的？tododododod"></a>问：讲一下平时使用Redis遇到过哪些问题？如何解决的？tododododod</h3><hr>
<h2 id="二-底层数据结构"><a href="#二-底层数据结构" class="headerlink" title="二. 底层数据结构"></a>二. 底层数据结构</h2><h3 id="问：Redis支持哪些数据结构？Redis各种数据结构的使用场景、内部编码及底层实现、优缺点？⭐⭐⭐？"><a href="#问：Redis支持哪些数据结构？Redis各种数据结构的使用场景、内部编码及底层实现、优缺点？⭐⭐⭐？" class="headerlink" title="问：Redis支持哪些数据结构？Redis各种数据结构的使用场景、内部编码及底层实现、优缺点？⭐⭐⭐？"></a>问：Redis支持哪些数据结构？Redis各种数据结构的使用场景、内部编码及底层实现、优缺点？⭐⭐⭐？</h3><p>Redis支持：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog（做基数统计）、GEO（地理信息定位）等多种数据结构和算法。</p>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><ul>
<li><p>【应用场景】： </p>
<ul>
<li><p><strong>缓存</strong>：Redis作为缓存层，MySql作为存储层，绝大部分数据都是从缓存中获取。缓存能起到加速读写和降低后端压力的作用。首先从Redis获取用户信息，若没有从Redis获取到用户信息，则需要从MySql中获取，并将结果写入Redis，并添加1小时过期时间。</p>
</li>
<li><p><strong>计数器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户观看后增加一次视频播放数，当然计数系统还有防作弊、不同维度计数、数据持久化到底层数据源等</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">incrVideoCounter</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">       key = <span class="string">&quot;video:playCount:&quot;</span> + id;</span><br><span class="line">       <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>共享Session</strong>：一个分布式Web服务将用户的Session信息保存在各自的服务器中，这样会造成一个问题，出于负载均衡的考虑，分布式服务器会将用户的访问均衡到不同的服务器上，用户每刷新一次访问可能会发现要重新登录，这是用户无法容忍的。为了解决这个问题，可以使用Redis将Session进行集中管理，每次用户更新或查询登录信息都直接从Redis获取。</p>
</li>
<li><p><strong>限速</strong>：很多应用出于安全的考虑，会在每次登录时让用户输入手机验证码，以确认是否本人操作。但为了使短信接口不被频繁访问，会限制用户每分钟获取验证码的频率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phoneNum = <span class="string">&quot;138xxxxxxxx&quot;</span>;</span><br><span class="line">key = <span class="string">&quot;shortMsg:limit:&quot;</span> + phoneNum;</span><br><span class="line"><span class="comment">// SET key value EX 60 NX 过期时间60秒+NX只做新增</span></span><br><span class="line">isExists = redis.set(key<span class="number">.1</span>, <span class="string">&quot;EX 60&quot;</span>, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isExists != <span class="keyword">null</span> || redis.incr(key) &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">          <span class="comment">// 通过</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 限速</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>分布式锁</strong></p>
</li>
<li><p><strong>分布式ID</strong></p>
</li>
</ul>
</li>
<li><p>【内部编码】：最大512M</p>
<ul>
<li><strong>int</strong>：8个字节的长整型。</li>
<li><strong>embstr</strong>：小于等于39个字节的字符串。</li>
<li><strong>raw</strong>：大于39个字节的字符串。</li>
</ul>
</li>
<li><p>【底层实现】：<code>Simple dynamic string</code>（SDS）的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">  <span class="comment">//等于SDS保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len；</span><br><span class="line">  <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>；</span><br><span class="line">  <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[]；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>优点（都是C字符串的缺点弥补）：</p>
<ul>
<li>不会出现字符串变更造成的内存溢出问题。</li>
<li>获取字符串长度时间复杂度为1，C字符串没有长度信息（以 <code>\0</code> 来明确表示结尾），必须遍历字符串，时间复杂度为O(n)。</li>
<li>空间预分配， 惰性空间释放free字段，会默认留够一定的空间防止多次重分配内存。</li>
</ul>
</li>
</ul>
<h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010116.jpg"></p>
<ul>
<li>【应用场景】： <ul>
<li><strong>保存结构体信息</strong>，可部分获取不用序列化所有字段。如保存用户类，原生字符串每个属性都要对应一个键，序列化字符串需要序列与反序列的开销，而哈希类型只须一个键即可存放一个用户信息。</li>
<li>保存一些键值对。</li>
</ul>
</li>
<li>【内部编码】：<ul>
<li><strong>ziplist</strong>（压缩列表）：当哈希类型元素个数小于 <code>hash-max-ziplist-entries</code> 配置（默认为512个），同时所有值都小于 <code>hash-max-ziplist-value</code> 配置（默认为64字节）时，Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以相比hashtable会更节省空间。</li>
<li><strong>hashtable</strong>（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，这种情况ziplist的读写效率会下降，而hashtable读写时间复杂度为 <code>O(1)</code> 。</li>
</ul>
</li>
<li>【底层实现】：在数组+链表的基础上，进行了一些rehash优化。<ul>
<li>Reids的Hash采用<strong>链地址法</strong>来处理冲突，然后它<strong>没有使用红黑树优化</strong>。</li>
<li>哈希表节点采用<strong>单链表结构</strong>。</li>
<li><strong>rehash优化</strong> （采用分而治之的思想，将庞大的迁移工作量划分到每一次CURD中，避免了服务繁忙）</li>
</ul>
</li>
</ul>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul>
<li><p>【应用场景】： </p>
<ul>
<li><p><strong>消息队列</strong>：<code>lpush</code> + <code>brpop</code> 命令组合即可实现<strong>阻塞队列</strong></p>
</li>
<li><p><strong>文章列表</strong>：缓存比如twitter的关注列表，粉丝列表等</p>
</li>
<li><p>经典口诀：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush + <span class="attr">lpop</span> = Stack（栈）</span><br><span class="line">lpush + <span class="attr">rpop</span> = Queue（队列）</span><br><span class="line">lpush + <span class="attr">ltrim</span> = Capped Collection（有限集合）</span><br><span class="line">lpush + <span class="attr">brpop</span> = Message Queue（消息队列）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>【内部编码】：</p>
<ul>
<li><strong>ziplist</strong>：当列表的元素个数小于 <code>list-max-ziplist-entries</code> 配置（默认512个），同时列表中每个元素的值都小于 <code>list-max-ziplist-value</code> 配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li>
<li><strong>linkedlist</strong>（链表）：当列表类型无法满足ziplist的条件时，Redis会使用链表实现。</li>
</ul>
</li>
<li><p>【底层实现】：list的实现为一个<strong>双向链表</strong>，即可以支持反向查找和遍历。</p>
</li>
</ul>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul>
<li>【应用场景】： <ul>
<li><p><strong>去重的场景</strong></p>
</li>
<li><p><strong>求交集</strong>（sinter）、<strong>并集</strong>（sunion）、<strong>差集</strong>（sdiff）</p>
</li>
<li><p><strong>标签</strong>：实现如共同关注、共同喜好、二度好友等功能。</p>
</li>
<li><p>集合类型一般有这几种应用场景：</p>
<ul>
<li><p>sadd = Tagging（标签）</p>
</li>
<li><p>spop/srandmember = Random item（队列）</p>
</li>
<li><p>sadd + sinter = Social Graph（社交需求）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>【内部编码】：<ul>
<li><strong>intset</strong>（整数集合）：当集合中的元素都是整数且元素个数小于 <code>set-max-intset-entries</code> 配置（默认512个）时，Redis会选用intset来作为集合内部实现，从而减少内存的使用。</li>
<li><strong>hashtable</strong>（哈希表）：集合无法满足intset的条件时，选用hashtable作为集合内部实现。</li>
</ul>
</li>
<li>【底层实现】：是一个<strong>value为null的HashMap</strong>，实际就是<strong>通过计算hash的方式来快速排重</strong>的，这也是set能提供判断一个成员是否在集合内的原因。 </li>
</ul>
<h5 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h5><ul>
<li>【应用场景】：<ul>
<li><strong>排行榜</strong></li>
<li><strong>实现延时队列</strong></li>
</ul>
</li>
<li>【内部编码】：<ul>
<li><strong>ziplist</strong>（压缩列表）：当有序集合的元素个数小于 <code>zset-max-ziplist-entries</code> 配置（默认128个），同时列表中每个元素的值都小于 <code>zset-max-ziplist-value</code> 配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li>
<li><strong>skiplist</strong>（跳跃表）：当无法满足ziplist的条件时，Redis选用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li>
</ul>
</li>
<li>【底层实现】：内部使用<strong>HashMap</strong>和<strong>跳跃表</strong>（SkipList）来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 <ul>
<li>跳表：每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>Bitmap（位图）</strong>  布隆过滤器</li>
</ol>
<p>应用场景：</p>
<ul>
<li>用于统计某些事件的发生情况（如每天是否登录、在线状态统计）。</li>
<li>用于处理大规模的布尔数据，如检测某个值是否存在。</li>
</ul>
<p>内部编码及底层实现：</p>
<ul>
<li><strong>位数组（Bit Array）</strong>：Redis 使用一个 bit 数组来存储每个元素的布尔状态。</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>内存占用极小，适用于存储大量布尔值。</li>
<li>可以通过位运算（如 <code>BITSET</code>、<code>BITCOUNT</code>）高效地处理布尔数据。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>只适合存储布尔类型的数据，灵活性较低。</li>
</ul>
</li>
</ul>
<ol start="7">
<li><strong>HyperLogLog（超日志）</strong></li>
</ol>
<p>应用场景：</p>
<ul>
<li>用于近似计算基数（如统计网站访问的唯一用户数量、计算商品的独立购买人数等）。</li>
<li>在需要处理大规模去重数据时，节省内存。</li>
</ul>
<p>内部编码及底层实现：</p>
<ul>
<li><strong>概率算法</strong>：HyperLogLog 使用概率算法来估算基数，它通过哈希函数对输入进行映射，并计算最大的前导零位数来近似估计基数。</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>内存占用极小，通常只需要 12 KB 存储上百万个元素的基数估计。</li>
<li>对于大规模的数据集，能够提供较为准确的基数估算。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>返回的结果是近似值，精度无法保证。</li>
</ul>
</li>
<li><p>不支持具体的元素值，只能估算数量。</p>
</li>
</ul>
<ol start="8">
<li><strong>Geospatial（地理空间）</strong></li>
</ol>
<p>应用场景：</p>
<ul>
<li>实现基于位置的服务（例如，查找附近的商店、用户等）。</li>
<li>用于计算地理位置的距离、排序等操作。</li>
</ul>
<p>内部编码及底层实现：</p>
<ul>
<li><strong>有序集合（Sorted Set）</strong>：Redis 使用有序集合来存储地理位置信息，元素的分数表示经纬度的哈希值。</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>支持高效的地理位置查询和计算，如查找某个位置附近的其他位置。</li>
<li>支持范围查询、距离计算等常见地理信息处理操作。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>只能存储坐标点，适合用于位置查询，其他类型的空间查询不适用。</li>
</ul>
</li>
</ul>
<h3 id="问：Redis中的字符串类型是怎么实现的？Redis-如何存储一个-String-的？⭐⭐⭐？"><a href="#问：Redis中的字符串类型是怎么实现的？Redis-如何存储一个-String-的？⭐⭐⭐？" class="headerlink" title="问：Redis中的字符串类型是怎么实现的？Redis 如何存储一个 String 的？⭐⭐⭐？"></a>问：Redis中的字符串类型是怎么实现的？Redis 如何存储一个 String 的？⭐⭐⭐？</h3><p>通过一个抽象数据结构<strong>SDS</strong>来实现，包含三个重要属性：<strong>已使用字节数量，未使用字节数量，字节数组</strong>。存储时保留了C语言以 <code>\0</code> 为结尾的习惯以便能兼容C语言的函数。分配空间时，当长度小于1MB，会根据已使用空间分配相等大小的未使用空间以备扩展，大于1MB时只会分配1MB。</p>
<ul>
<li>假设要存储一个字符串 <code>hello</code> ，SDS会记录已使用字节长度为5，并分配相同大小的未使用字节空间（长度小于1MB时）所以也为5，并保留 <code>\0</code> 作为字符串结尾但不计入空间占用，所以此时SDS分配空间为11。</li>
</ul>
<p><code>Simple dynamic string</code>（SDS）的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">  <span class="comment">//等于SDS保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len；</span><br><span class="line">  <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>；</span><br><span class="line">  <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[]；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>优点（都是C字符串的缺点弥补）：</p>
<ul>
<li>不会出现字符串变更造成的内存溢出问题。</li>
<li>获取字符串长度时间复杂度为1，C字符串没有长度信息（以 <code>\0</code> 来明确表示结尾），必须遍历字符串，时间复杂度为O(n)。</li>
<li>空间预分配， 惰性空间释放free字段，会默认留够一定的空间防止多次重分配内存。</li>
</ul>
<p><strong>Redis 字符串的底层实现：SDS（Simple Dynamic String）</strong></p>
<p>Redis 使用 <strong>SDS（Simple Dynamic String）</strong> 作为字符串类型的底层数据结构。SDS 是一个自定义的数据结构，它比传统的 C 字符串更高效，具有以下优势：</p>
<ul>
<li><strong>O(1) 的长度计算</strong>：传统的 C 字符串需要每次计算字符串的长度，Redis 的 SDS 结构直接存储了字符串的长度，能够 O(1) 获取字符串的长度。</li>
<li><strong>自动扩展</strong>：SDS 在动态扩展时，会预留一定的空间，避免每次增长时都进行内存重新分配，减少了内存碎片。</li>
<li><strong>更高效的内存管理</strong>：SDS 还维护了额外的信息（如已使用的空间和剩余的空间），使得内存的分配和释放更加高效。<strong>避免内存碎片</strong>：SDS 预留一定的空间，减少了内存碎片问题。</li>
<li><strong>支持二进制安全</strong>：SDS 支持二进制数据，因此不仅支持文本字符串，也能存储任何二进制数据（例如图片、音频等）。</li>
</ul>
<p><strong>SDS 数据结构</strong>，包含了以下几个部分：</p>
<ul>
<li><strong>len</strong>：当前字符串的实际长度。当前使用的字符数（不包含结束符）。</li>
<li><strong>alloc</strong>：分配的内存大小（即 SDS 的总大小）。通常会比实际使用的内存大，以优化内存扩展</li>
<li><strong>flags</strong>：标识符，表示该字符串的数据类型。例如，<code>STRING</code> 表示普通字符串，<code>RAW</code> 表示原始数据等。</li>
<li><strong>buf</strong>：实际存储字符串内容的字符数组（或二进制数据）。</li>
</ul>
<p>SDS 结构的简化示意图：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+</span><br><span class="line">| len | alloc | flags |   buf   |</span><br><span class="line">+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+</span><br></pre></td></tr></table></figure>



<p>SDS 的优势：</p>
<p>Redis 根据字符串的长度选择不同的编码方式来优化内存使用。</p>
<ul>
<li><p>INT（整数编码）：如果存储的是一个数字（如整数），Redis 会将其存储为整数值，并使用 INT 类型进行优化，避免使用额外的内存开销。</p>
<ul>
<li>对于一个小的整数（例如 10、20 等），Redis 会直接将其作为整数存储，而不使用 SDS 编码。</li>
<li>整数编码通常用于存储小于 512 字节的整数，采用内存节省的方式。</li>
</ul>
</li>
<li><p><strong>embstr</strong>：小于等于39个字节的字符串。</p>
</li>
<li><p><strong>RAW（原始编码）</strong>：对于其他类型的字符串，Redis 会使用 RAW 编码，表示数据是一个普通的字符串类型。这个编码会使用 SDS 数据结构。</p>
</li>
</ul>
<p><strong>字符串类型的常见操作</strong></p>
<ul>
<li><strong>SET</strong>：用于设置字符串值。</li>
<li><strong>GET</strong>：获取字符串值。</li>
<li><strong>INCR</strong> / <strong>DECR</strong>：对数字类型的字符串进行自增或自减操作。</li>
<li><strong>MGET</strong>：同时获取多个键的值。</li>
<li><strong>APPEND</strong>：将字符串追加到现有的值上。</li>
<li><strong>DEL</strong>：删除指定的字符串。</li>
</ul>
<h3 id="问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？⭐⭐⭐？"><a href="#问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？⭐⭐⭐？" class="headerlink" title="问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？⭐⭐⭐？"></a>问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？⭐⭐⭐？</h3><ul>
<li>原生C字符串获取字符串长度需要遍历整个字符串，复杂度为O(n)，而SDS则为O(1)。</li>
<li>因为有预分配的空间以及惰性释放空间，所以可以<strong>避免重复内存分配</strong>。</li>
<li>因为有了长度控制，所以避免了C字符串常见的<strong>内存溢出问题</strong>。</li>
</ul>
<p>C字符串对于字符编码有要求，对于一些如图片、音频等格式的二进制编码未必能支持，而SDS虽然保留了空字符结尾但并不以它来判断字符串结尾，所以可以安全的存储一些特殊格式要求的二进制数据。</p>
<p>SDS（Simple Dynamic String）相比于原生的 <code>char[]</code> 的优点</p>
<p>Redis 使用的 <strong>SDS</strong> 是一种比传统的 <code>char[]</code> 更高效的动态字符串表示方式。以下是 SDS 相对于原生的 <code>char[]</code> 的一些优点：</p>
<ol>
<li><strong>O(1) 的字符串长度计算</strong></li>
</ol>
<ul>
<li>**原生 <code>char[]</code>**：在 C 语言中，字符串是由 <code>char[]</code> 数组表示的，通常以空字符 <code>&#39;\0&#39;</code> 结束。每次获取字符串的长度时，必须遍历整个数组，计算字符串的字符数，时间复杂度是 O(n)，其中 n 是字符串的长度。</li>
<li><strong>SDS</strong>：在 SDS 中，长度信息被直接存储在结构体的 <code>len</code> 字段中，因此每次获取字符串长度时，时间复杂度是 O(1)，直接返回 <code>len</code> 的值。</li>
</ul>
<ol start="2">
<li><strong>更好的内存管理</strong></li>
</ol>
<ul>
<li>**原生 <code>char[]</code>**：在 C 语言中，<code>char[]</code> 数组的大小是固定的，无法灵活扩展。如果需要调整数组的大小（如插入字符或删除字符），可能需要分配一个新的更大的数组，并进行拷贝，造成性能损失。而且，如果字符串长度大于分配的大小，通常需要重新分配并拷贝数据。</li>
<li><strong>SDS</strong>：SDS 采用了动态扩展机制，当字符串长度增加时，会自动分配更大的空间，并且会预留一定的额外空间，以减少频繁的内存重新分配。当字符串长度减少时，SDS 可以缩小内存，避免内存浪费。此外，SDS 内部还记录了实际使用的内存大小和剩余的空间，避免了内存碎片的产生。</li>
</ul>
<ol start="3">
<li><strong>支持二进制安全</strong></li>
</ol>
<ul>
<li>**原生 <code>char[]</code>**：传统的 C 字符串是基于 <code>null</code> 结束符（<code>\0</code>）的，因此不能正确处理包含空字符的二进制数据。<code>char[]</code> 只能处理文本数据。</li>
<li><strong>SDS</strong>：SDS 允许存储任意类型的数据，包括文本和二进制数据。SDS 可以支持包含空字节（<code>0x00</code>）的数据，因为它并不依赖于终止符，而是通过长度来标记字符串的结束。</li>
</ul>
<ol start="4">
<li><strong>避免内存碎片</strong></li>
</ol>
<ul>
<li>**原生 <code>char[]</code>**：如果在动态扩展字符串时没有适当的内存管理，可能会产生内存碎片。每次调整大小时，原生数组可能会经历内存的多次分配和释放，造成内存碎片。</li>
<li><strong>SDS</strong>：SDS 在内存分配时，会预留一些空间，减少了频繁扩展时的内存分配开销。这样做不仅减少了内存碎片，还提高了内存使用效率。</li>
</ul>
<ol start="5">
<li><strong>提高了性能</strong></li>
</ol>
<ul>
<li>**原生 <code>char[]</code>**：传统 <code>char[]</code> 数组没有预留空间，因此每次进行扩展时都需要重新分配内存，并将数据复制到新的内存区域。这会增加额外的性能开销。</li>
<li><strong>SDS</strong>：SDS 通过预分配空间，减少了扩展时的性能开销。SDS 还使用了增量扩展的策略（通常是原大小的两倍），避免了频繁的内存分配和数据复制，从而提高了性能。</li>
</ul>
<p>缺点：</p>
<ol>
<li><strong>内存额外开销</strong>：<ul>
<li>每个 SDS 对象除了存储字符串本身外，还需要存储一些额外的元数据（如 <code>len</code>、<code>alloc</code>、<code>flags</code> 等），这些元数据会带来一定的内存开销。对于短小的字符串，这些开销可能会显得比较大。</li>
<li>比如，一个简单的字符串需要在原有的字符数组外再多存储 4 字节的长度、4 字节的内存分配大小和一些标志位，这对于非常小的字符串来说，可能不是很划算。</li>
</ul>
</li>
<li><strong>动态扩展的复杂性</strong>：<ul>
<li>当字符串的长度发生变化时，SDS 需要进行内存分配和数据拷贝，尽管这个过程已经优化为按需扩展，但在极端情况下（如大规模的字符串操作），仍然可能影响性能。</li>
</ul>
</li>
<li><strong>内存碎片问题</strong>：<ul>
<li>虽然 SDS 使用了预留空间的方式来减少内存碎片，但仍然有可能在长期操作中产生一定的内存碎片，特别是在内存需求频繁波动的情况下。</li>
</ul>
</li>
<li><strong>适用于特定场景</strong>：<ul>
<li>对于一些非常小的数据，SDS 可能带来的内存开销比直接使用 C 字符串（<code>char[]</code>）更大，因此在某些小型、资源紧张的嵌入式系统中，可能不如传统的 <code>char[]</code> 更合适。</li>
</ul>
</li>
</ol>
<h3 id="问：Redis的hash底层如何实现？rehash做了哪些优化？⭐⭐⭐？"><a href="#问：Redis的hash底层如何实现？rehash做了哪些优化？⭐⭐⭐？" class="headerlink" title="问：Redis的hash底层如何实现？rehash做了哪些优化？⭐⭐⭐？"></a>问：Redis的hash底层如何实现？rehash做了哪些优化？⭐⭐⭐？</h3><p>Redis 的 hash 数据有两种底层编码实现：ziplist和hashtable。</p>
<p>字典由 <code>dict.h</code> 文件定义，其中ht是哈希表结构，0是正常使用的表，1则是渐进rehash时用来转移0的节点。</p>
<p>rehashidx用来在rehash过程记录正在转移的键，平时为-1。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010116.png"></p>
<p>dictht即哈希表结构，内部包含一个 <code>dictEntry **table</code> table即dictEntry二维数组，为了哈希冲突时能够串联所有冲突的节点。size即哈希表最大可寻址大小，即一维数组最大长度。dictEntry则是一个键值对结构。</p>
<p>在数组+链表的基础上，进行了一些rehash优化。</p>
<ul>
<li>Redis的Hash采用<strong>链地址法</strong>来处理冲突，然后它<strong>没有使用红黑树优化</strong>。</li>
<li>哈希表节点采用<strong>单链表结构</strong>。</li>
<li><strong>rehash优化</strong> （采用分而治之的思想，将庞大的迁移工作量划分到每一次CURD中，避免了服务繁忙）</li>
</ul>
<p><strong>一、Hash底层结构</strong></p>
<p>Redis的Hash类型有两种底层编码，根据数据量动态切换以平衡内存与性能：  </p>
<ol>
<li><p><strong>ziplist（压缩列表）</strong>  </p>
<ul>
<li><strong>触发条件</strong>：同时满足以下两个条件时使用ziplist：  <ul>
<li>Hash中所有键值对的键和值的字符串长度 **均小于 <code>hash-max-ziplist-value</code>**（默认64字节）。  </li>
<li>Hash中的键值对数量 **小于 <code>hash-max-ziplist-entries</code>**（默认512个）。  </li>
</ul>
</li>
<li><strong>特点</strong>：内存紧凑，通过连续内存块存储键值对，适合小数据量场景。</li>
</ul>
</li>
<li><p><strong>hashtable（哈希表）</strong>  </p>
<ul>
<li><strong>触发条件</strong>：不满足ziplist条件时自动转换为hashtable。  </li>
<li><strong>结构定义</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表结构（dict.h）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">// 哈希桶数组（二维数组）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;     <span class="comment">// 哈希表容量（数组长度，总为2^n）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 哈希掩码（= size-1，用于计算索引）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;     <span class="comment">// 已存储的键值对数量</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表节点（链地址法解决冲突）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;              <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> <span class="keyword">void</span> *val; ... &#125; v; <span class="comment">// 值（支持多种类型）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 单链表下一节点指针</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典（封装哈希表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];           <span class="comment">// 两个哈希表（ht[0]主表，ht[1]用于rehash）</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;         <span class="comment">// rehash进度（-1表示未进行）</span></span><br><span class="line">    <span class="comment">// ... 其他字段（如类型特定函数）</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></li>
<li><strong>核心机制</strong>：  <ul>
<li><strong>链地址法</strong>：哈希冲突时，通过<code>dictEntry-&gt;next</code>形成单链表（Redis未采用红黑树优化，因单链表在内存操作中更高效）。  </li>
<li><strong>哈希函数</strong>：基于MurmurHash2算法，确保键分布均匀。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>二、Rehash优化：渐进式迁移</strong></p>
<p>传统哈希表扩容时需一次性迁移所有数据，可能因数据量大导致长时间阻塞。Redis采用<strong>渐进式Rehash</strong>优化：将迁移分摊到每次CURD操作中，避免集中式迁移的性能抖动。</p>
<p><strong>渐进式 rehash：</strong><br>Redis 不会一次性完成所有数据的迁移，而是采用“分步 rehash”的方式。每次对字典的操作（如添加、查找、删除）时，都会顺带执行少量的 rehash 工作（比如迁移一到几个槽(bucket)的数据）。这样可以将 rehash 的开销分摊到每次普通操作中，避免长时间阻塞主线程。</p>
<p><strong>双表机制：</strong><br>在 rehash 期间，字典中同时存在两个哈希表（ht[0] 和 ht[1]）。查询时，Redis 会同时在两个表中查找数据。这样既保证了数据的正确性，又允许 rehash 工作在后台逐步进行。</p>
<p><strong>平滑迁移：</strong><br>渐进式 rehash 保证了在系统高并发的情况下，rehash 操作不会造成明显的延迟波动，从而提高系统整体响应性能。</p>
<h5 id="1-触发Rehash的条件"><a href="#1-触发Rehash的条件" class="headerlink" title="1. 触发Rehash的条件"></a><strong>1. 触发Rehash的条件</strong></h5><ul>
<li><strong>扩容</strong>：当负载因子 <code>used/size ≥ 1</code> 且允许扩容（<code>dict_can_resize=1</code>，或<code>used/size &gt; 5</code>强制扩容）。  </li>
<li><strong>缩容</strong>：当负载因子 <code>used/size &lt; 0.1</code>，触发缩容以减少内存占用。</li>
</ul>
<h5 id="2-渐进式Rehash流程"><a href="#2-渐进式Rehash流程" class="headerlink" title="2. 渐进式Rehash流程"></a><strong>2. 渐进式Rehash流程</strong></h5><ol>
<li><p><strong>准备阶段</strong>：  </p>
<ul>
<li>分配<code>ht[1]</code>，容量为第一个大于等于<code>ht[0].used*2</code>的2^n（扩容）或第一个大于等于<code>ht[0].used</code>的2^n（缩容）。  </li>
<li>设置<code>rehashidx=0</code>，标志开始迁移。</li>
</ul>
</li>
<li><p><strong>数据迁移阶段</strong>：  </p>
<ul>
<li><strong>每次操作触发迁移</strong>：在客户端执行增删改查操作时，Redis额外迁移<code>ht[0].table[rehashidx]</code>对应的哈希桶（即该索引下的所有链表节点）。  </li>
<li><strong>定时任务辅助迁移</strong>：若客户端长时间无请求，Redis通过定时任务迁移少量数据（每毫秒迁移1个桶）。  </li>
<li>迁移完成后，<code>rehashidx++</code>，直至所有桶迁移完毕。</li>
</ul>
</li>
<li><p><strong>完成阶段</strong>：  </p>
<ul>
<li>释放<code>ht[0]</code>，将<code>ht[1]</code>设为新的<code>ht[0]</code>。  </li>
<li>重置<code>ht[1]</code>为空白表，<code>rehashidx=-1</code>。</li>
</ul>
</li>
</ol>
<h5 id="3-操作兼容性"><a href="#3-操作兼容性" class="headerlink" title="3. 操作兼容性"></a><strong>3. 操作兼容性</strong></h5><ul>
<li><strong>写操作</strong>：新数据直接写入<code>ht[1]</code>。  </li>
<li><strong>读操作</strong>：同时查询<code>ht[0]</code>和<code>ht[1]</code>，优先返回<code>ht[0]</code>中的数据。  </li>
<li><strong>删除/更新</strong>：需同时在<code>ht[0]</code>和<code>ht[1]</code>中处理。</li>
</ul>
<p><strong>对比传统Rehash</strong>  </p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>传统Rehash</strong></th>
<th><strong>Redis渐进式Rehash</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>迁移方式</strong></td>
<td>一次性迁移所有数据</td>
<td>分批次迁移，每次迁移一个哈希桶</td>
</tr>
<tr>
<td><strong>阻塞时间</strong></td>
<td>长（数据量越大阻塞越久）</td>
<td>极短（每次迁移耗时可控）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>临时需要双倍内存</td>
<td>逐步释放旧表内存，内存压力平滑过渡</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>低并发、小数据量</td>
<td>高并发、大数据量，要求低延迟和高可用性</td>
</tr>
</tbody></table>
<h3 id="问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？⭐⭐⭐？"><a href="#问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？⭐⭐⭐？" class="headerlink" title="问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？⭐⭐⭐？"></a>问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？⭐⭐⭐？</h3><ol>
<li>skiplist的复杂度和红黑树一样，而且实现起来更简单。</li>
<li>在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。</li>
</ol>
<ul>
<li>【内部编码】：<ul>
<li><strong>intset</strong>（整数集合）：当集合中的元素都是整数且元素个数小于 <code>set-max-intset-entries</code> 配置（默认512个）时，Redis会选用intset来作为集合内部实现，从而减少内存的使用。</li>
<li><strong>hashtable</strong>（哈希表）：集合无法满足intset的条件时，选用hashtable作为集合内部实现。</li>
</ul>
</li>
<li>【底层实现】：是一个<strong>value为null的HashMap</strong>，实际就是<strong>通过计算hash的方式来快速排重</strong>的，这也是set能提供判断一个成员是否在集合内的原因。 </li>
</ul>
<p><strong>1. Set 底层实现原理</strong></p>
<p>在 Redis 中，<code>Set</code> 是一个 <strong>无序集合</strong>，不允许元素重复。其底层实现依赖两种数据结构：</p>
<p><strong>1.1 散列表（Hash Table）</strong></p>
<ul>
<li>当集合中的元素较少时，Redis 使用哈希表（dict）来实现 <code>Set</code>。</li>
<li>特点：<ul>
<li>平均时间复杂度：**O(1)**。</li>
<li>支持快速插入、删除和查找。</li>
<li>需要解决哈希冲突，Redis 使用 <strong>链地址法</strong>。</li>
</ul>
</li>
</ul>
<p><strong>1.2 整数集合（IntSet）</strong></p>
<ul>
<li>如果 <code>Set</code> 中的元素都是整数，且数量较少时，Redis 使用 <strong>整数集合（IntSet）</strong>。</li>
<li>特点：<ul>
<li>数据结构是一个 <strong>有序数组</strong>，用于存储整型数据。</li>
<li>支持二分查找，插入时按序插入。</li>
<li>空间占用小，非常高效。</li>
</ul>
</li>
</ul>
<p><strong>底层切换策略：</strong></p>
<ul>
<li>默认情况下，<code>Set</code> 使用 <strong>IntSet</strong>。</li>
<li>当：<ul>
<li>元素数量超过一定阈值。</li>
<li>元素中包含非整数类型。</li>
<li>发生冲突时。</li>
<li>切换为 <strong>Hash Table</strong>。</li>
</ul>
</li>
</ul>
<p><strong>2. ZSet 底层实现原理</strong></p>
<p><code>ZSet</code> 是一个 <strong>有序集合</strong>，支持按分值排序。其底层数据结构是：</p>
<p><strong>2.1 跳跃表（SkipList）</strong></p>
<ul>
<li>跳跃表是一种多层链表，支持 <strong>快速查找、插入和删除</strong>，平均时间复杂度为 **O(log N)**。</li>
<li>结构：<ul>
<li>每个节点包含两个属性：<ul>
<li><code>score</code>：排序依据。</li>
<li><code>value</code>：实际值。</li>
</ul>
</li>
<li>不同层级的链表节点通过指针连接。</li>
</ul>
</li>
</ul>
<p><strong>2.2 哈希表（Hash Table）</strong></p>
<ul>
<li>Redis 还维护一个 <strong>哈希表</strong>，以实现通过值快速查找分数。</li>
<li>哈希表和跳跃表共同维护数据，保证 <code>ZSet</code> 的有序性与查找效率。</li>
</ul>
<p><strong>3. 为什么 ZSet 使用跳跃表而不是红黑树？</strong></p>
<p><strong>3.1 跳跃表的优点</strong></p>
<ol>
<li>实现简单<ul>
<li>跳跃表的实现代码比红黑树简单，维护成本低。</li>
</ul>
</li>
<li>范围查找效率高<ul>
<li>跳跃表支持范围查询（如 <code>ZRANGE</code>、<code>ZRANK</code>），在跳跃表中从上层链表向下查找，效率高于红黑树。</li>
</ul>
</li>
<li>内存分配更灵活<ul>
<li>跳跃表的节点分布在内存中，结构分散，支持链表扩展，而红黑树的节点结构固定，内存分配可能产生碎片。</li>
</ul>
</li>
<li>插入、删除时旋转成本低<ul>
<li>红黑树在插入和删除时，频繁执行节点旋转和重新平衡，性能开销较大，而跳跃表只需调整链表指针。</li>
</ul>
</li>
</ol>
<p><strong>3.2 跳跃表的劣势</strong></p>
<ul>
<li>跳跃表的内存占用相对较高，因为需要维护多个链表结构。</li>
<li>在极端情况下，跳跃表的查找性能可能退化到 **O(N)**，但通过随机层数分配，平均复杂度为 **O(log N)**，与红黑树相当。</li>
</ul>
<p><strong>总结：为什么 Redis 选择跳跃表？</strong></p>
<ul>
<li>在 Redis 中，<code>ZSet</code> 的典型操作包括范围查询、排名查询等。跳跃表比红黑树更适合这些场景。</li>
<li>跳跃表结构简单，实现成本低。</li>
<li>内存分配更加灵活，支持分布式环境。</li>
<li>Redis 优先考虑高性能与简单实现，因此跳跃表成为理想选择。</li>
</ul>
<p>Redis 的 <code>zset</code>（有序集合）是通过 <strong>跳跃表（skiplist）</strong> 和 <strong>哈希表</strong> 结合实现的，而不是使用红黑树。</p>
<p><strong>1. 跳跃表的简单性与效率</strong></p>
<ul>
<li><strong>实现简单</strong>：跳跃表的代码实现比红黑树简单很多。红黑树的插入、删除和调整操作需要维护复杂的平衡规则，而跳跃表只需要通过随机化索引来保持结构的平均效率。</li>
<li><strong>时间复杂度相似</strong>：跳跃表的时间复杂度为 O(log⁡n，与红黑树相同。Redis 追求极高的性能，跳跃表能够提供足够快的操作效率，而无需引入复杂的红黑树实现。在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。</li>
</ul>
<p><strong>2. 跳跃表更适合范围查询</strong></p>
<ul>
<li>跳跃表支持高效的 <strong>范围查询</strong>，例如 <code>ZRANGEBYSCORE</code> 和 <code>ZRANGEBYLEX</code> 操作。由于跳跃表是基于链表的结构，查找起点后，<strong>范围内的元素可以通过链表的线性遍历快速获取</strong>，逻辑简单高效。</li>
<li>红黑树虽然也支持范围查询，但由于它是一种树结构，<strong>范围内的遍历需要进行中序遍历</strong>，指针跳转复杂，效率相对较低。</li>
</ul>
<p><strong>3. 内存使用与存储结构</strong></p>
<ul>
<li>跳跃表的节点通过链表方式组织，存储紧凑，内存布局相对连续。相比之下，红黑树的节点是分散的，指针管理较多，可能带来额外的内存开销。</li>
<li>跳跃表还允许通过随机级别分布来平衡性能和内存使用，使得结构在大规模数据场景下更加灵活。</li>
</ul>
<p><strong>4. 易于实现持久化和数据转储</strong></p>
<ul>
<li>跳跃表的结构非常适合 Redis 的 <strong>RDB 持久化</strong> 和 <strong>AOF（Append Only File）日志</strong>。其数据结构序列化简单，可以直接遍历链表输出所有节点。</li>
<li>红黑树由于复杂的平衡逻辑和多指针结构，实现序列化和反序列化的成本更高。</li>
</ul>
<p><strong>5. 工程上的灵活性与扩展性</strong></p>
<ul>
<li>跳跃表易于实现水平扩展，例如<strong>通过增加跳表层数来支持更大的数据规模</strong>。</li>
<li>Redis 的 <code>zset</code> 不仅使用跳跃表存储数据，还结合了哈希表，用于快速定位特定元素。这种结合方式在跳跃表中实现相对简单，但在红黑树中实现则需要更复杂的设计。</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳跃表</th>
<th>红黑树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时间复杂度</strong></td>
<td>O(log⁡n)</td>
<td>O(log⁡n)</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>简单，基于链表</td>
<td>较复杂，需维护平衡规则</td>
</tr>
<tr>
<td><strong>范围查询效率</strong></td>
<td>高效，链表结构遍历性能优越</td>
<td>较低，需通过中序遍历实现</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>内存利用率较高</td>
<td>节点分散，指针管理开销大</td>
</tr>
<tr>
<td><strong>序列化与持久化</strong></td>
<td>简单，链表遍历即可</td>
<td>复杂，需要特殊处理指针和结构</td>
</tr>
</tbody></table>
<p>Redis 选择跳跃表，是在满足性能需求的基础上，追求实现简单、代码可维护性高的结果。在 Redis 的使用场景中，跳跃表的性能完全足够，并且更适合于 Redis 的整体架构和设计理念。</p>
<h3 id="问：一个-Redis-实例最多能存放多少的keys？List、Set、Sorted-Set-他们最多能存放多少元素？⭐"><a href="#问：一个-Redis-实例最多能存放多少的keys？List、Set、Sorted-Set-他们最多能存放多少元素？⭐" class="headerlink" title="问：一个 Redis 实例最多能存放多少的keys？List、Set、Sorted Set 他们最多能存放多少元素？⭐"></a>问：一个 Redis 实例最多能存放多少的keys？List、Set、Sorted Set 他们最多能存放多少元素？⭐</h3><p><strong>Redis 最大键值对数量与数据结构容量限制</strong></p>
<p><strong>1. Redis 实例最多能存放多少 Keys？</strong></p>
<ul>
<li><strong>理论上限：</strong> Redis 的键数量上限是 <strong>2^32 - 1 = 4,294,967,295</strong>（约 42 亿个键）。</li>
<li><strong>配置参数：</strong> <code>maxmemory</code> 限制了 Redis 能使用的内存量，达到内存上限时 Redis 会根据 <code>maxmemory-policy</code> 进行数据淘汰。</li>
</ul>
<p><strong>实际影响因素：</strong></p>
<ul>
<li>可用内存：Redis 使用的内存受物理内存和系统限制。</li>
<li>Key 长度与 Value 大小：键值的长度直接影响内存使用。</li>
<li>服务器性能：大量键会增大操作延迟和内存消耗。</li>
</ul>
<p><strong>2. 数据结构容量限制</strong></p>
<ol>
<li>List（列表）<ul>
<li><strong>最大元素数量：</strong> <strong>2^32 - 1 = 4,294,967,295</strong>。</li>
<li>Redis 列表是基于 <strong>双向链表（quicklist）</strong> 实现的。</li>
<li>实际影响因素：<ul>
<li>元素长度：单个元素不能超过 512MB。</li>
<li>内存：受内存和 <code>maxmemory</code> 限制。</li>
</ul>
</li>
</ul>
</li>
<li>Set（集合）<ul>
<li><strong>最大元素数量：</strong> <strong>2^32 - 1 = 4,294,967,295</strong>。</li>
<li>Redis 的集合是基于 <strong>哈希表</strong> 或 <strong>整数集合（intset）</strong> 实现的。</li>
<li>实际影响因素：<ul>
<li>元素唯一性：Set 中不能有重复元素。</li>
<li>内存使用：大量小元素占用内存大。</li>
</ul>
</li>
</ul>
</li>
<li>Sorted Set（有序集合，ZSet）<ul>
<li><strong>最大元素数量：</strong> <strong>2^32 - 1 = 4,294,967,295</strong>。</li>
<li>Sorted Set 基于 <strong>跳跃表（SkipList）</strong> 和 <strong>哈希表（dict）</strong>。</li>
<li>实际影响因素：<ul>
<li>成员的 <code>score</code> 唯一，必须是浮点数。</li>
<li>元素数量大时，插入和查找的性能为 **O(log N)**。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Redis 数据结构容量对比表</strong></p>
<table>
<thead>
<tr>
<th><strong>数据结构</strong></th>
<th><strong>最大容量（理论值）</strong></th>
<th><strong>实现机制</strong></th>
<th><strong>注意事项</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Keys</td>
<td>4,294,967,295</td>
<td>全局哈希表</td>
<td>内存消耗与管理复杂</td>
</tr>
<tr>
<td>List</td>
<td>4,294,967,295</td>
<td>双向链表（quicklist）</td>
<td>单元素 ≤ 512MB</td>
</tr>
<tr>
<td>Set</td>
<td>4,294,967,295</td>
<td>哈希表 / IntSet</td>
<td>无重复元素</td>
</tr>
<tr>
<td>Sorted Set</td>
<td>4,294,967,295</td>
<td>跳跃表 + 哈希表</td>
<td>支持分数排序</td>
</tr>
<tr>
<td>Hash</td>
<td>4,294,967,295</td>
<td>哈希表</td>
<td>键值对存储</td>
</tr>
</tbody></table>
<h3 id="问：Redis-的内存占用情况怎么样？Redis-的内存用完了会发生什么？Redis如何压缩内存（内存优化）？"><a href="#问：Redis-的内存占用情况怎么样？Redis-的内存用完了会发生什么？Redis如何压缩内存（内存优化）？" class="headerlink" title="问：Redis 的内存占用情况怎么样？Redis 的内存用完了会发生什么？Redis如何压缩内存（内存优化）？"></a>问：Redis 的内存占用情况怎么样？Redis 的内存用完了会发生什么？Redis如何压缩内存（内存优化）？</h3><h4 id="Redis-的内存占用情况"><a href="#Redis-的内存占用情况" class="headerlink" title="Redis 的内存占用情况"></a>Redis 的内存占用情况</h4><ul>
<li><strong>对象开销：</strong>Redis 中存储的数据（键和值）不仅包括实际的数据内容，还包含对象元数据（如类型、编码、引用计数、LRU 信息等）。每个 Redis 对象都有固定的额外内存开销。<ul>
<li>举个例子：在 32 位系统上，如果存储 100 万个键值对，其中键为“0”到“999999”，值为字符串 “hello world”，实际占用内存可能达到 100MB。而如果将这些数据合并到一个 key 内（比如用一个 Hash 存储 100 万个字段），内存开销可能只需 16MB。这主要是因为每个单独的 key 都有相对较高的元数据开销，而将多个小数据项放入同一个数据结构中可以大幅减少这种重复开销。</li>
<li>在 Memcached 上执行也是类似的结果，但是相对 Redis的开销要小一点点，因为 Redis 会记录类型信息引用计数等等。</li>
</ul>
</li>
<li><strong>32 位 vs 64 位：</strong>在 64 位系统上，由于指针占用 8 个字节（而 32 位系统中只占 4 个字节），所以每个对象的元数据会更多；因此，同样的数据在 64 位系统上可能会消耗更多内存。不过，64 位系统能够支持更大的内存空间，这也是运行大型 Redis 服务器的必要条件。</li>
<li><strong>内存分配与碎片：</strong>Redis 默认使用 Jemalloc 作为内存分配器，虽然 Jemalloc 对碎片有较好的控制，但在高并发和频繁创建删除对象的场景下，仍可能产生内存碎片。可以通过命令 <code>INFO MEMORY</code> 来查看 Redis 的内存使用情况和碎片率。</li>
</ul>
<h4 id="Redis-的内存用完了会发生什么？"><a href="#Redis-的内存用完了会发生什么？" class="headerlink" title="Redis 的内存用完了会发生什么？"></a>Redis 的内存用完了会发生什么？</h4><ul>
<li><strong>写命令失败：</strong>当 Redis 使用的内存达到 <code>maxmemory</code> 配置的上限时，如果内存淘汰策略没有生效或者配置为 <code>noeviction</code>（默认情况下），所有写操作（例如 SET、LPUSH、XADD 等）都会返回错误信息，提示 “OOM command not allowed”。（但是读命令还可以正常返回）</li>
<li><strong>内存淘汰（Eviction）：</strong>如果配置了合适的内存淘汰策略（如 <code>allkeys-lru</code>、<code>volatile-lru</code>、<code>allkeys-random</code> 等），当内存使用达到上限时，Redis 会自动淘汰（驱逐）部分数据以释放空间。读操作则不受影响。淘汰策略的选择应根据具体业务需求决定：<ul>
<li><strong>allkeys-lru：</strong> 淘汰所有 key 中最近最少使用的。</li>
<li><strong>volatile-lru：</strong> 仅淘汰设置了过期时间的 key。</li>
<li><strong>volatile-ttl：</strong> 淘汰即将过期的 key。</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="Redis如何压缩内存（内存优化）？"><a href="#Redis如何压缩内存（内存优化）？" class="headerlink" title="Redis如何压缩内存（内存优化）？"></a>Redis如何压缩内存（内存优化）？</h4><ul>
<li><strong>合并小数据到一个数据结构中：</strong>尽可能<strong>使用散列表</strong>（hashes）。由于每个 key 都有较大的元数据开销，尽量将多个小数据存储到同一个 key 里能显著节省内存。例如，在 web 系统中，将用户的多个属性（名称、邮箱、密码等）存储到同一个 Hash 内，而不是为每个属性创建单独的 key。这种方式利用 Hash 的紧凑编码（当字段数量和字段大小在阈值以下时，使用 ziplist/listpack 编码）能大幅降低内存占用。</li>
<li><strong>使用紧凑编码：</strong>Redis 对于 Hash、List、Sorted Set 等数据结构会根据实际数据量采用不同的内部编码：<ul>
<li><strong>Hash 类型：</strong> 当存储的数据较少且每个字段较短时，会使用 ziplist（或新版中的 listpack）编码，空间利用率更高。</li>
<li>可通过配置参数（如 <code>hash-max-ziplist-entries</code>、<code>hash-max-ziplist-value</code>）来控制何时从紧凑编码转换为普通字典编码。</li>
</ul>
</li>
<li><strong>精简键名和值：</strong>设计数据模型时，尽量使用简短的键名和值，减少不必要的字符串长度，从而降低整体内存开销。</li>
<li><strong>合理配置内存淘汰和过期策略：</strong>为不需要长期保存的数据设置合理的 TTL，并根据业务需求选择适当的淘汰策略，使得内存不断被释放、更新。</li>
<li><strong>内存碎片管理：</strong>Redis 提供命令 <code>MEMORY PURGE</code> 来尝试释放 jemalloc 内部碎片；同时，可以使用 <code>MEMORY DOCTOR</code> 分析内存使用情况，针对性调整配置。</li>
<li><strong>集群分片扩展：</strong>如果单个 Redis 实例的内存始终紧张，可考虑使用 Redis Cluster 等水平扩展方案，将数据分布在多台服务器上，降低单实例内存压力。</li>
</ul>
<p><strong>Redis 内存优化与压缩方法</strong></p>
<ol>
<li><strong>数据结构优化</strong><ul>
<li><strong>字符串优化：</strong> 使用更短的键和值。</li>
<li><strong>哈希结构优化：</strong> 使用小字段组合在哈希表中存储对象。</li>
<li>编码优化：<code>list-max-ziplist-entries</code>、<code>hash-max-ziplist-entries</code> 等参数控制小数据量时使用紧凑编码。</li>
</ul>
</li>
<li><strong>减少内存碎片</strong><ul>
<li>定期运行 <code>MEMORY PURGE</code> 手动释放内存。</li>
<li>调整 <code>jemalloc</code> 配置优化内存分配。</li>
</ul>
</li>
<li><strong>持久化优化</strong>：合理配置 RDB/AOF，避免内存占用过多。</li>
<li><strong>淘汰策略与过期管理</strong><ul>
<li>设置合理的过期时间和内存淘汰策略。</li>
<li>避免使用大批量的无过期键。</li>
</ul>
</li>
<li><strong>压缩存储</strong><ul>
<li>使用 <code>MEMORY DOCTOR</code> 诊断内存问题。</li>
<li>使用 <code>MEMORY USAGE &lt;key&gt;</code> 查看具体键的内存消耗。</li>
</ul>
</li>
<li><strong>集群分片与扩展</strong><ul>
<li>使用 Redis Cluster 进行水平扩展，分散内存负载。</li>
</ul>
</li>
</ol>
<p><strong>Redis 内存管理命令示例</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看内存使用情况</span></span><br><span class="line">INFO MEMORY</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看键的内存占用大小</span></span><br><span class="line">MEMORY USAGE mykey</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动释放内存碎片</span></span><br><span class="line">MEMORY PURGE</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 诊断内存问题</span></span><br><span class="line">MEMORY DOCTOR</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="三-Redis高级特性"><a href="#三-Redis高级特性" class="headerlink" title="三. Redis高级特性"></a>三. Redis高级特性</h2><p>包括：慢查询、Pipeline、事务、Lua</p>
<h3 id="问：Redis慢查询？⭐⭐"><a href="#问：Redis慢查询？⭐⭐" class="headerlink" title="问：Redis慢查询？⭐⭐"></a>问：Redis慢查询？⭐⭐</h3><ul>
<li>Redis客户端执行命令：<ol>
<li>发送命令：1+4为Round Trip Time即RTT往返时间</li>
<li>排队</li>
<li>执行命令</li>
<li>返回结果</li>
</ol>
</li>
<li>批量操作，如mget、mset可以节约RTT，但大部分命令不支持批量操作，如执行n次hgetall命令。</li>
</ul>
<p><strong>作用</strong>：记录执行时间超过指定阈值的 Redis 命令，用于性能分析与优化。<br><strong>核心机制</strong>：</p>
<ul>
<li><strong>配置参数</strong>：<ul>
<li><code>slowlog-log-slower-than</code>：阈值（单位：微秒），默认 10 毫秒（10000 微秒）。</li>
<li><code>slowlog-max-len</code>：日志最大长度（队列长度），默认 128，超出时删除旧记录。</li>
</ul>
</li>
<li><strong>记录内容</strong>：仅记录命令执行时间（服务端耗时），不包含网络传输或排队时间。</li>
<li><strong>查看日志</strong>：通过 <code>SLOWLOG GET [n]</code> 命令查看最近的 <code>n</code> 条记录。</li>
<li><strong>使用场景</strong>：定位执行缓慢的命令（如复杂度高的 <code>KEYS *</code>、大范围 <code>HGETALL</code> 等）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置阈值（1毫秒）和最大日志数（1000）</span></span><br><span class="line">CONFIG SET slowlog-log-slower-than 1000</span><br><span class="line">CONFIG SET slowlog-max-len 1000</span><br><span class="line"><span class="comment"># 查看最近2条慢查询</span></span><br><span class="line">SLOWLOG GET 2</span><br></pre></td></tr></table></figure>



<h3 id="问：Redis-Pipeline？⭐⭐⭐"><a href="#问：Redis-Pipeline？⭐⭐⭐" class="headerlink" title="问：Redis Pipeline？⭐⭐⭐"></a>问：Redis Pipeline？⭐⭐⭐</h3><p><strong>作用</strong>：将多个命令打包发送，减少网络往返时间（RTT），提升吞吐量。<br><strong>核心机制</strong>：</p>
<ul>
<li><strong>非原子性</strong>：命令按顺序执行，但执行期间可能被其他客户端命令插入。</li>
<li><strong>服务端处理</strong>：将命令缓存到内存队列，依次执行后一次性返回结果。</li>
<li><strong>性能提升场景</strong>：适合批量写入（如 <code>MSET</code> 的替代）、高网络延迟环境。</li>
<li><strong>注意事项</strong>：<ul>
<li>单次 Pipeline 命令数量不宜过多，避免服务端内存压力。</li>
<li>与事务（<code>MULTI/EXEC</code>）结合可实现原子性批量操作。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 示例（使用 redis-py）</span></span><br><span class="line">pipe = r.pipeline()</span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>)</span><br><span class="line">pipe.get(<span class="string">&quot;key1&quot;</span>)</span><br><span class="line">pipe.incr(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">results = pipe.execute()  <span class="comment"># 返回 [True, &quot;value1&quot;, 1]</span></span><br></pre></td></tr></table></figure>



<ul>
<li>Pipeline一般比逐条执行命令快，且网络延时越大越明显。</li>
<li>原生批量操作是原子的，Pipeline则非原子。</li>
<li>原生批量是一个命令对应多个key，Pipeline则可以多个命令。</li>
<li>原生批量是Redis服务端实现，Pipeline则需要服务端和客户端共同实现。</li>
</ul>
<h3 id="问：Redis-Lua？⭐⭐⭐"><a href="#问：Redis-Lua？⭐⭐⭐" class="headerlink" title="问：Redis Lua？⭐⭐⭐"></a>问：Redis Lua？⭐⭐⭐</h3><ul>
<li>Lua是一种脚本语言，Redis 2.6版本后内嵌Lua环境，不需要单独安装Lua。</li>
<li>使用Lua脚本的优点：<ol>
<li>减少网络开销：可以把多个命令放在一个脚本中执行。</li>
<li>原子操作：整个脚本会当作一个整体执行，中间不会被其它命令插入。</li>
<li>复用性：客户端发送的脚本会永远存储在Redis，其它客户端也可以复用同一脚本完成相同逻辑。</li>
</ol>
</li>
<li>如使用Redis+Lua实现限流。</li>
</ul>
<p><strong>作用</strong>：在 Redis 服务端原子执行复杂逻辑，避免竞态条件。<br><strong>核心机制</strong>：</p>
<ul>
<li><strong>原子性</strong>：脚本执行期间独占服务器，不会被其他命令打断。</li>
<li><strong>命令执行</strong>：通过 <code>EVAL &quot;script&quot; numkeys key... arg...</code> 或预加载后使用 <code>EVALSHA</code>。</li>
<li><strong>错误处理</strong>：<ul>
<li><code>redis.call()</code>：命令执行错误会抛出异常，中断脚本。</li>
<li><code>redis.pcall()</code>：捕获错误并返回错误表，脚本继续执行。</li>
</ul>
</li>
<li><strong>超时控制</strong>：默认 5 秒，可通过 <code>lua-time-limit</code> 调整（过长会阻塞其他客户端）。</li>
<li><strong>使用场景</strong>：实现 CAS（如秒杀扣库存）、复杂事务（组合多个命令）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原子性递增并返回新值</span></span><br><span class="line"><span class="keyword">local</span> current = redis.call(<span class="string">&quot;GET&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> current <span class="keyword">then</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> new = current + <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line">redis.call(<span class="string">&quot;SET&quot;</span>, KEYS[<span class="number">1</span>], new)</span><br><span class="line"><span class="keyword">return</span> new</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">EVAL <span class="string">&quot;上述脚本内容&quot;</span> 1 <span class="string">&quot;counter&quot;</span> 5</span><br></pre></td></tr></table></figure>



<h3 id="问：redis事务？⭐⭐⭐"><a href="#问：redis事务？⭐⭐⭐" class="headerlink" title="问：redis事务？⭐⭐⭐"></a>问：redis事务？⭐⭐⭐</h3><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>Redis 事务提供了一种轻量级的命令队列机制，通过 <code>MULTI/EXEC</code> 实现命令批量执行和乐观锁功能，适用于简单业务场景。为实现更高的事务可靠性与分布式支持，推荐使用 Redis 配合其他分布式事务框架，如 Seata、TCC 等。</p>
<p>Redis 支持事务机制，通过命令队列的方式实现原子操作。事务中的命令按照先后顺序依次执行，避免了复杂的分布式事务模型。</p>
<p><strong>Redis 事务的三个阶段</strong></p>
<ol>
<li><strong>开始事务：<code>MULTI</code></strong><ul>
<li>使用 <code>MULTI</code> 命令开启一个事务，后续的命令将被入队，直到执行 <code>EXEC</code>。</li>
</ul>
</li>
<li><strong>命令入队：执行多个命令</strong><ul>
<li>在 <code>MULTI</code> 和 <code>EXEC</code> 之间的命令被按顺序入队。</li>
<li>不会立即执行，而是等待事务提交。</li>
</ul>
</li>
<li><strong>执行事务：<code>EXEC</code></strong><ul>
<li>提交事务，将入队的命令按顺序依次执行。</li>
</ul>
</li>
</ol>
<p><strong>Redis 事务命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>MULTI</code></td>
<td>开启事务</td>
</tr>
<tr>
<td><code>EXEC</code></td>
<td>提交事务，执行命令，执行事务块内命令</td>
</tr>
<tr>
<td><code>DISCARD</code></td>
<td>放弃事务，清空队列</td>
</tr>
<tr>
<td><code>WATCH key [key ...]</code></td>
<td>乐观锁监视键，监视一个或多个key，如果事务执行前key被改动，事务将打断</td>
</tr>
<tr>
<td><code>UNWATCH</code></td>
<td>取消监视键</td>
</tr>
</tbody></table>
<p><strong>示例：简单事务操作</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行多条命令</span></span><br><span class="line">127.0.0.1:6379&gt; SET key1 value1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR counter</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>事务特性</strong></p>
<ol>
<li><strong>批量执行</strong>：事务中的命令会一次性提交执行，减少了客户端与 Redis 服务器的通信成本。</li>
<li><strong>单独执行</strong>：事务中的命令按队列顺序依次执行，执行期间不会被其他命令插入。</li>
<li><strong>隔离性与原子性（部分保障）</strong>：事务中的每个命令都会执行，但 Redis 不支持回滚机制。</li>
</ol>
<p><strong>事务中的错误处理</strong></p>
<ol>
<li><p><strong>语法错误（在命令入队阶段）</strong></p>
<ul>
<li>如果命令在入队时有语法错误，整个事务在提交时会执行失败。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET key1 value1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; BADCOMMAND key2</span><br><span class="line">(error) ERR unknown command &#x27;BADCOMMAND&#x27;</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure></li>
<li><p><strong>运行时错误（执行时）</strong></p>
<ul>
<li><p>如果事务中的某条命令在执行时发生错误，Redis 仍然会执行其他命令。</p>
</li>
<li><p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET key1 value1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR key1  # 错误，key1 是字符串类型</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>Redis 乐观锁机制 (<code>WATCH</code>)</strong></p>
<p>Redis 通过 <code>WATCH</code> 实现乐观锁，确保在事务提交前，监视的键未被修改。</p>
<p><strong>示例：<code>WATCH</code> 锁的使用</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; WATCH balance</span><br><span class="line">OK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 balance</span></span><br><span class="line">127.0.0.1:6379&gt; DECR balance</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br></pre></td></tr></table></figure>



<p>如果 <code>balance</code> 在事务提交前被其他客户端修改，则 <code>EXEC</code> 提交将失败，返回 <code>nil</code>。</p>
<p><strong>Redis 事务的局限性与不足</strong></p>
<ol>
<li><strong>无回滚机制</strong>：<ul>
<li>如果事务中的某条命令执行失败，Redis 不会回滚整个事务，已执行的命令依然生效。</li>
</ul>
</li>
<li><strong>无隔离级别支持</strong>：<ul>
<li>Redis 不支持隔离级别，如 <code>READ COMMITTED</code>、<code>SERIALIZABLE</code> 等。</li>
</ul>
</li>
<li><strong>单线程限制</strong>：<ul>
<li>Redis 是单线程模型，事务操作可能被其他命令阻塞。</li>
</ul>
</li>
<li><strong>锁粒度粗</strong>：<ul>
<li>Redis 事务的 <code>WATCH</code> 锁是基于键的，粒度较粗，适用于简单应用场景。</li>
</ul>
</li>
</ol>
<p><strong>Redis 事务的应用场景</strong></p>
<ul>
<li><strong>计数器与库存扣减</strong></li>
<li><strong>银行转账与账户结算</strong></li>
<li><strong>分布式锁实现（结合 <code>WATCH</code>）</strong></li>
<li><strong>任务队列的原子操作</strong></li>
</ul>
<h3 id="问：redis事务的实现特征？"><a href="#问：redis事务的实现特征？" class="headerlink" title="问：redis事务的实现特征？"></a>问：redis事务的实现特征？</h3><ol>
<li>所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行</li>
<li>Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</li>
<li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行</li>
<li>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。</li>
</ol>
<p>然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</p>
<p>Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了</p>
<h3 id="问：Redis如何大批量插入数据？⭐⭐"><a href="#问：Redis如何大批量插入数据？⭐⭐" class="headerlink" title="问：Redis如何大批量插入数据？⭐⭐"></a>问：Redis如何大批量插入数据？⭐⭐</h3><ol>
<li><p>使用 <code>MSET</code> 命令（多键插入）：<code>MSET</code> 命令支持同时设置多个键值对，适用于批量插入小规模数据。</p>
<p><strong>优点：</strong></p>
<ul>
<li>原子性操作，多个键值对一次性插入。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不支持复杂数据结构。</li>
</ul>
<p><strong>示例：批量插入字符串</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET key1 value1 key2 value2 key3 value3</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>pipeline</code> 命令：Redis <code>pipeline</code> 支持一次性发送多个命令，减少客户端与 Redis 服务器之间的网络延迟。</p>
<p><strong>优点：</strong></p>
<ul>
<li>降低网络通信次数，提高写入效率。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>批量大小控制在 1000~5000 条之间，避免占用过多内存。</li>
</ul>
<p><strong>示例：批量插入字符串键值对</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Redis 连接</span></span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量插入</span></span><br><span class="line">pipe = r.pipeline()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100001</span>):</span><br><span class="line">    pipe.<span class="built_in">set</span>(<span class="string">f&quot;key<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">f&quot;value<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Lua 脚本批量插入，避免多次网络请求</p>
<p><strong>优点：</strong></p>
<ul>
<li>批量执行，事务性保障，避免网络延迟。</li>
</ul>
<p><strong>示例：批量插入哈希表数据</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> data = &#123;</span><br><span class="line">    &#123;key=<span class="string">&quot;user:1&quot;</span>, field=<span class="string">&quot;name&quot;</span>, value=<span class="string">&quot;Alice&quot;</span>&#125;,</span><br><span class="line">    &#123;key=<span class="string">&quot;user:2&quot;</span>, field=<span class="string">&quot;name&quot;</span>, value=<span class="string">&quot;Bob&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, item <span class="keyword">in</span> <span class="built_in">ipairs</span>(data) <span class="keyword">do</span></span><br><span class="line">    redis.call(<span class="string">&quot;HSET&quot;</span>, item.key, item.field, item.value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 Redis <code>RDB</code> 文件导入：适用于超大规模数据导入场景，提前生成 Redis 数据库快照文件，直接加载。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>在离线环境中准备 RDB 文件。</li>
<li>将 RDB 文件上传到 Redis 服务器 <code>dump.rdb</code>。</li>
<li>重启 Redis 自动加载数据。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>超大规模数据一次性导入，极高性能。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要服务器权限，数据导入期间 Redis 不可用。</li>
</ul>
</li>
<li><p>Redis Mass Insert 工具导入</p>
<ul>
<li>使用 Redis 官方推荐的工具，如 <code>redis-benchmark</code> 或 <code>redis-cli --pipe</code>。</li>
</ul>
<p><strong>示例：<code>redis-cli --pipe</code> 批量插入</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | redis-cli --pipe</span><br></pre></td></tr></table></figure>

<p><strong>示例：<code>redis-benchmark</code> 插入性能测试</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -t set -n 100000</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>高效插入，适用于测试和真实环境。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="四-发布订阅"><a href="#四-发布订阅" class="headerlink" title="四. 发布订阅"></a>四. 发布订阅</h2><h3 id="问：Redis的发布订阅机制？PubSub有什么缺点？⭐⭐⭐"><a href="#问：Redis的发布订阅机制？PubSub有什么缺点？⭐⭐⭐" class="headerlink" title="问：Redis的发布订阅机制？PubSub有什么缺点？⭐⭐⭐"></a>问：Redis的发布订阅机制？PubSub有什么缺点？⭐⭐⭐</h3><p>使用pub/sub主题订阅者模式，可以实现1：N的消息队列。</p>
<p>发布者和订阅者不直接通信</p>
<p>命令：</p>
<ol>
<li>发布消息：<code>publish channel message</code> 返回订阅者个数。</li>
<li>订阅消息：<code>subscribe channel [channel...]</code> 订阅一个或多个频道。<ul>
<li>客户端执行订阅命令后进入订阅状态，只能接收subscribe、psubscribe、unsubscribe、punsubscribe这四个命令。</li>
<li>新开启的订阅客户端不会接收到该频道之前的消息，因为Redis不会对消息持久化。</li>
</ul>
</li>
<li>取消订阅：<code>unsubscribe [channel [channel...]]</code> </li>
<li>按照模式订阅和取消订阅：<ul>
<li><code>psubscribe pattern [pattern...]</code> 支持glob风格的订阅，如it*表示以it开头的所有频道。</li>
<li><code>punsubscribe pattern [pattern...]</code> </li>
</ul>
</li>
<li>查询订阅：<ul>
<li>查看活跃的频道：<code>pubsub channels [pattern]</code>  频道至少有一个订阅者。</li>
<li>查看频道订阅数：<code>pubsub numsub [channel ...]</code></li>
<li>查看模式订阅数：<code>pubsub numpat</code></li>
</ul>
</li>
</ol>
<p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p>
<p><strong>Redis <code>Pub/Sub</code> 模式的缺点？</strong></p>
<p>Redis 的 <code>Pub/Sub</code> 是一种轻量级消息发布与订阅机制，适用于简单的消息广播和实时通知。但由于其实现机制的局限性，存在一些显著缺点：</p>
<p><strong>主要缺点分析</strong></p>
<ol>
<li>无消息持久化（数据丢失风险）<ul>
<li>Redis <code>Pub/Sub</code> 不会持久化消息，消息仅存储在内存中。</li>
<li>如果消费者在消息发布时未在线或掉线，将错过该消息，导致消息丢失。<br> <strong>解决方案：</strong> 考虑使用 Redis <code>Stream</code> 或引入消息队列系统（如 Kafka、RabbitMQ）。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>无消费确认机制<ul>
<li><code>Pub/Sub</code> 没有消息确认机制，生产者无法确认消息是否被消费者成功接收。</li>
<li>消费失败时，消息不会被重发。<br> <strong>解决方案：</strong> 使用 Redis <code>Stream</code> 提供的手动确认机制。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>无消息排队（实时性要求高）<ul>
<li><code>Pub/Sub</code> 仅支持实时消息推送，消费者必须始终在线才能接收消息。</li>
<li>没有内置队列功能，无法存储历史消息。<br> <strong>解决方案：</strong> 使用 Redis <code>Stream</code> 或其他消息队列中间件，支持消息排队和延迟处理。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>不支持水平扩展（单点瓶颈）<ul>
<li>在分布式环境中，<code>Pub/Sub</code> 只能在单个 Redis 节点上工作，无法跨节点扩展。</li>
<li>集群环境中不同节点之间无法共享订阅消息。<br> <strong>解决方案：</strong> 使用 Redis 集群或引入专业的分布式消息中间件。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>高并发下性能下降<ul>
<li>在高并发场景下，订阅和发布数量过多时，Redis <code>Pub/Sub</code> 性能可能受到影响。<br> <strong>解决方案：</strong> 优化 Redis 配置、使用多 Redis 实例或引入消息中间件。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>无消费分组和负载均衡<ul>
<li>Redis <code>Pub/Sub</code> 不支持消费分组，无法实现多消费者之间的负载均衡。</li>
<li>所有订阅者都收到相同消息，无法分摊消费压力。<br> <strong>解决方案：</strong> 使用 Redis <code>Stream</code> 消费组，自动分配和负载均衡。</li>
</ul>
</li>
</ol>
<p><strong>何时适合使用 Redis <code>Pub/Sub</code>？</strong></p>
<p>尽管存在上述缺点，Redis <code>Pub/Sub</code> 仍然适用于以下场景：</p>
<ul>
<li><strong>实时通知与广播消息</strong>：如聊天室消息、在线推送通知。</li>
<li><strong>轻量级消息传递</strong>：对可靠性要求不高的临时通知。</li>
<li><strong>简单应用监控与告警</strong>：实时状态和日志通知。</li>
</ul>
<p><strong>总结：选择建议</strong></p>
<ul>
<li><strong>对可靠性和持久化要求高：</strong> 使用 Redis <code>Stream</code> 或专业消息队列（如 Kafka）。</li>
<li><strong>需要消费确认和重发机制：</strong> 使用 Redis <code>Stream</code> 的消息确认和消费组功能。</li>
<li><strong>需要轻量级消息广播：</strong> 使用 Redis <code>Pub/Sub</code>，适合实时性要求高但可靠性要求低的场景。</li>
</ul>
<h3 id="问：Redis-Stream？⭐⭐⭐"><a href="#问：Redis-Stream？⭐⭐⭐" class="headerlink" title="问：Redis Stream？⭐⭐⭐"></a>问：Redis Stream？⭐⭐⭐</h3><h4 id="1-Redis-Stream-是什么？"><a href="#1-Redis-Stream-是什么？" class="headerlink" title="1. Redis Stream 是什么？"></a>1. Redis Stream 是什么？</h4><p><strong>定义</strong>：Redis Stream 是 Redis 5.0 引入的数据结构，旨在实现<strong>持久化、多播、多消费者组的消息队列</strong>，弥补了 Pub/Sub 无法持久化消息的缺陷。Stream 具备消息队列的基本要素，包括生产者 API、消费者 API、消息 Broker、消息确认机制等。</p>
<p><strong>核心特性</strong>：</p>
<ul>
<li><strong>消息持久化</strong>：默认持久存储（结合 AOF/RDB），支持回溯消费。</li>
<li><strong>多消费者组</strong>：多个消费者组独立消费同一 Stream，互不影响，借鉴 Kafka 消费组概念。</li>
<li><strong>消息确认机制</strong>：通过 <code>XACK</code> 确认消息处理完成，避免消息丢失。</li>
<li><strong>消息追溯</strong>：消费者可通过 Pending List（PEL）查找未确认的消息，实现消息重试和故障恢复。</li>
<li><strong>阻塞式消费</strong>：支持 <code>XREAD/XREADGROUP</code> 阻塞模式，消费者可等待新消息，减少轮询开销。</li>
</ul>
<h4 id="2-Redis-Stream-操作"><a href="#2-Redis-Stream-操作" class="headerlink" title="2. Redis Stream 操作"></a>2. Redis Stream 操作</h4><table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>命令</strong></th>
<th><strong>功能说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>生产者</strong></td>
<td><code>XADD stream * key value</code></td>
<td>添加消息到 Stream，<code>*</code> 表示自动生成消息 ID，可用 <code>MAXLEN</code> 控制长度。</td>
</tr>
<tr>
<td><strong>独立消费者</strong></td>
<td><code>XREAD COUNT n STREAMS stream 0</code></td>
<td>读取最新的 <code>n</code> 条消息。</td>
</tr>
<tr>
<td><strong>阻塞读取</strong></td>
<td><code>XREAD BLOCK 0 STREAMS mystream 0</code></td>
<td>阻塞直到有新消息，从 ID 为 0 开始读取。</td>
</tr>
<tr>
<td><strong>消费者组</strong></td>
<td><code>XGROUP CREATE stream group $</code></td>
<td>创建消费者组，<code>$</code> 表示从最新消息开始消费。</td>
</tr>
<tr>
<td><strong>组内消费</strong></td>
<td><code>XREADGROUP GROUP group consumer COUNT n STREAMS stream &gt;</code></td>
<td>组内消费者读取未处理的消息，<code>&gt;</code> 表示获取新消息。</td>
</tr>
<tr>
<td><strong>消息确认</strong></td>
<td><code>XACK stream group message-id</code></td>
<td>确认消息处理完成，从 PEL 中移除。</td>
</tr>
<tr>
<td><strong>查看未确认消息</strong></td>
<td><code>XPENDING stream group</code></td>
<td>查看消费者组内未确认的消息列表及重试次数。</td>
</tr>
<tr>
<td><strong>范围查询</strong></td>
<td><code>XRANGE stream start-id end-id</code></td>
<td>根据消息 ID 范围查询历史消息。</td>
</tr>
<tr>
<td><strong>删除消息</strong></td>
<td><code>XDEL message-id</code></td>
<td>仅做标记删除，消息仍在 PEL 中可见。</td>
</tr>
</tbody></table>
<h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><ul>
<li><strong>消息队列/任务调度</strong>：订单处理、任务分发，多个消费者共同处理消息并 <code>XACK</code> 确认。</li>
<li><strong>日志收集与监控</strong>：应用日志写入 Stream，消费组实时分析监控。</li>
<li><strong>事件溯源与数据同步</strong>：微服务之间事件传递，保证数据一致性。</li>
<li><strong>高并发场景</strong>：通过 <code>MAXLEN</code> 限制流长度，PEL 确保消息不丢失。</li>
</ul>
<p>示例：</p>
<ol>
<li><strong>订单异步处理</strong><ul>
<li>订单事件写入 Stream，库存、物流等服务消费处理。</li>
<li>提升吞吐量，避免同步阻塞。</li>
</ul>
</li>
<li><strong>实时日志收集</strong><ul>
<li>微服务日志写入 Stream，消费组并行处理。</li>
<li>支持实时报警、日志存储。</li>
</ul>
</li>
<li><strong>实时通知推送</strong><ul>
<li>消息写入 Stream，在线用户通过 <code>XREAD</code> 拉取。</li>
<li>低延迟，支持历史消息回溯。</li>
</ul>
</li>
</ol>
<h4 id="4-关键问题与解决方案"><a href="#4-关键问题与解决方案" class="headerlink" title="4. 关键问题与解决方案"></a>4. 关键问题与解决方案</h4><p><strong>1. 消息积累与内存控制</strong></p>
<ul>
<li><strong>问题</strong>：消息过多导致内存压力。</li>
<li><strong>解决方案</strong>：<ul>
<li><code>XADD stream MAXLEN 1000 * key value</code> 限制 Stream 长度。</li>
<li><code>XDEL</code> 标记删除消息，结合 <code>MAXLEN</code> 进行物理删除。</li>
</ul>
</li>
</ul>
<p><strong>2. 未确认消息（PEL）</strong></p>
<ul>
<li><strong>问题</strong>：消费者未 <code>XACK</code>，PEL 过大。</li>
<li><strong>解决方案</strong>：<ul>
<li>业务处理完成后立即 <code>XACK</code>。</li>
<li><code>XPENDING</code> 查询未确认消息，进行重试。</li>
<li>客户端断连后使用 <code>XREADGROUP ... 0-0</code> 重新获取 PEL 中的消息。</li>
</ul>
</li>
</ul>
<p><strong>3. 死信（Dead Letter）处理</strong></p>
<ul>
<li><strong>问题</strong>：某些消息无法消费，反复重试。</li>
<li><strong>解决方案</strong>：<ul>
<li><code>XPENDING</code> 监控 <code>delivery counter</code>，超过阈值标记为死信。</li>
<li><code>XDEL</code> 删除消息，并 <code>XACK</code> 处理完成。</li>
</ul>
</li>
</ul>
<p><strong>4. 高可用与数据持久化</strong></p>
<ul>
<li><strong>高可用</strong>：基于 Redis 主从复制，Sentinel 监控，但故障切换可能丢失部分数据。</li>
<li><strong>持久化</strong>：依赖 AOF/RDB，需平衡性能与可靠性。</li>
</ul>
<p><strong>5. 分区（Partitioning）支持</strong></p>
<ul>
<li><p><strong>Redis 不支持原生分区</strong>，可在客户端按哈希策略分片。</p>
</li>
<li><p>示例：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream_name = <span class="string">&quot;chat_stream_&#123;user_id % 4&#125;&quot;</span></span><br><span class="line"><span class="class">XADD </span>&#123;stream_name&#125; * content <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-Redis-Stream-vs-Kafka-对比"><a href="#5-Redis-Stream-vs-Kafka-对比" class="headerlink" title="5. Redis Stream vs Kafka 对比"></a>5. Redis Stream vs Kafka 对比</h4><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Redis Stream</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>持久化</strong></td>
<td>依赖 Redis 内存与持久化策略</td>
<td>基于磁盘存储，数据可靠性更高</td>
</tr>
<tr>
<td><strong>吞吐量</strong></td>
<td>10万+/秒（内存操作）</td>
<td>百万+/秒（批处理与磁盘顺序写优化）</td>
</tr>
<tr>
<td><strong>消费者组</strong></td>
<td>支持多组，但无原生分区</td>
<td>支持多组且分区，天然支持水平扩展</td>
</tr>
<tr>
<td><strong>消息回溯</strong></td>
<td>支持，通过消息 ID 查询</td>
<td>支持，基于 offset 灵活控制</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>轻量级、低延迟、简单消息队列</td>
<td>大数据量、高吞吐、复杂业务场景</td>
</tr>
</tbody></table>
<h4 id="6-Redis-适合作为消息队列吗？"><a href="#6-Redis-适合作为消息队列吗？" class="headerlink" title="6. Redis 适合作为消息队列吗？"></a>6. Redis 适合作为消息队列吗？</h4><p><strong>适合场景</strong>：</p>
<ul>
<li>消息量适中（日均百万级以下）。</li>
<li>低延迟（毫秒级响应）。</li>
<li>无需复杂功能（如分区、事务消息）。</li>
</ul>
<p><strong>不适合场景</strong>：</p>
<ul>
<li>海量消息（日均千万级以上），内存成本高。</li>
<li>需要严格顺序性、分区扩展性。</li>
</ul>
<p><strong>选型建议</strong>：</p>
<ul>
<li><strong>轻量级任务</strong>：Redis Stream（如实时通知、日志收集）。</li>
<li><strong>复杂业务</strong>：Kafka、RocketMQ 更适合大规模消息处理。</li>
</ul>
<p><strong>PEL（Pending Entries List，待处理消息列表）</strong>如何避免消息丢失？</p>
<ul>
<li>当消费者从 <strong>Redis Stream</strong> 读取消息时，Redis 会将该消息标记为「已投递」并存入 <strong>PEL（待处理消息列表）</strong>，以防止消息丢失。</li>
<li>如果 <strong>消费者在读取后宕机或断开连接</strong>，这些消息不会丢失，因为 Redis <strong>不会自动从 Stream 删除消息</strong>。</li>
<li>该消费者重连后，可以通过 <code>XPENDING</code> 命令查看哪些消息尚未被 <code>XACK</code>（即未确认处理）。</li>
<li>重新读取 PEL 中的消息时，<code>XREADGROUP</code> 需要指定一个起始消息 ID，通常设置为 **<code>0-0</code>**，表示获取 PEL 里的所有未确认消息，并继续消费 <code>last_delivered_id</code> 之后的新消息。</li>
</ul>
<p>✅ <strong>关键点</strong>：</p>
<ul>
<li><strong>消息不会因为消费者宕机而丢失</strong>，因为它们存储在 PEL 中，直到被 <code>XACK</code> 确认处理。</li>
<li><strong>断线重连的消费者需要手动重新消费 PEL 里的消息</strong>，而不是用默认的 <code>&gt;</code> 读取最新消息。</li>
</ul>
<p>死信问题？</p>
<ul>
<li><p><strong>死信（Dead Letter）</strong> 指的是 <strong>长时间无法被消费者成功处理的消息</strong>，通常是因为：</p>
<ol>
<li>代码异常导致消费失败。</li>
<li>消息格式错误，消费者无法解析。</li>
<li>业务逻辑导致消息无法被处理。</li>
</ol>
</li>
<li><p>在 Redis Stream 中，<strong>每次消息被投递但未 <code>XACK</code> 时，<code>deliverycounter</code> 计数都会增加</strong>（可以通过 <code>XPENDING</code> 查看）。</p>
</li>
<li><p><strong>如何处理死信？</strong></p>
<ol>
<li><p><strong>设定 <code>deliverycounter</code> 阈值</strong>，例如超过 5 次投递仍未 <code>XACK</code>，认为是死信。</p>
</li>
<li><p>手动删除死信：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XDEL mystream message-id</span><br></pre></td></tr></table></figure></li>
<li><p>注意：<code>XDEL</code> 只是删除 Stream 里的消息，PEL 仍然会保留该消息，因此还需要 XACK：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XACK mystream mygroup message-<span class="built_in">id</span></span><br></pre></td></tr></table></figure></li>
<li><p>也可以将死信转移到另一个 Stream（死信队列）进行后续处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XADD dead_letter_stream * original_message_id &lt;message_data&gt;</span><br><span class="line">XACK mystream mygroup original_message_id</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>✅ <strong>关键点</strong>：</p>
<ul>
<li><strong>使用 <code>XPENDING</code> 监控消息的 <code>deliverycounter</code>，判断是否变成死信</strong>。</li>
<li><strong>死信可以删除、转移到死信队列，或者进行人工干预</strong>。</li>
</ul>
<p>Stream 的高可用？</p>
<ul>
<li>Redis Stream <strong>本身不具备高可用性</strong>，但可以通过 <strong>Redis 主从复制（Replication）</strong> 和 <strong>Sentinel 监控</strong> 来实现高可用。</li>
<li>在 <strong>Redis Cluster</strong> 或 <strong>Sentinel 模式</strong> 下，Stream 的数据会在多个节点间复制，从而保证故障转移（failover）。</li>
<li>但需要注意：<ul>
<li>Redis <strong>复制是异步的</strong>，如果主节点故障，可能会丢失一小部分最近写入的数据。</li>
<li>这种情况适用于大多数 Redis 数据结构，不仅限于 Stream。</li>
</ul>
</li>
</ul>
<p>✅ <strong>关键点</strong>：</p>
<ul>
<li><strong>高可用依赖于 Redis 的主从复制，而不是 Stream 本身的机制</strong>。</li>
<li><strong>可能会因为异步复制导致极少量数据丢失</strong>，但大部分情况下可以接受。</li>
</ul>
<p>分区 Partition</p>
<ul>
<li><strong>Redis Stream 不支持像 Kafka 那样的分区（Partition）机制</strong>，即多个消费者并行消费不同的分区。</li>
<li>如果需要类似的分区能力，可以手动实现：<ul>
<li><strong>创建多个 Stream</strong>（如 <code>mystream-1</code>、<code>mystream-2</code>）。</li>
<li><strong>根据消息内容进行哈希分片</strong>，让不同的消息进入不同的 Stream。</li>
<li><strong>客户端决定从哪个 Stream 读取</strong>，实现类似 Kafka 的分区消费模式。</li>
</ul>
</li>
</ul>
<p>✅ <strong>关键点</strong>：</p>
<ul>
<li><strong>Redis Stream 没有原生的分区功能，需要手动实现多个 Stream 进行消息分片</strong>。</li>
<li><strong>相比 Kafka，Redis Stream 更适合轻量级消息队列场景</strong>。</li>
</ul>
<p>Stream小结</p>
<ul>
<li>Stream 的消费模型借鉴了Kafka 的消费分组的概念，它弥补了 Redis Pub/Sub 不能持久化消息的缺陷。但是它又不同于 kafka，Kafka的消息可以分 partition，而 Stream 不行。如果非要分 parition 的话，得在客户端做提供不同的 Stream 名称，对消息进行 hash 取模来选择往哪个 Stream 里塞。<br>关于 Redis 是否适合做消息队列，业界一直是有争论的。很多人认为，要使用消息队列，就应该采用 Kafka.</li>
</ul>
<ul>
<li><strong>Redis Stream = Kafka-like 消费模型 + Redis 的高性能数据存储</strong></li>
<li>相比于 Redis Pub/Sub，Stream <strong>可以持久化消息，并支持消费者组（Consumer Group）</strong>。</li>
<li>与 Kafka 的不同点：<ul>
<li><strong>Kafka 有原生的分区机制，Stream 没有</strong>。</li>
<li><strong>Redis Stream 适用于轻量级、低延迟场景</strong>，如实时日志、在线聊天。</li>
<li><strong>Kafka 更适合大规模数据流处理</strong>，如日志分析、事件流。</li>
</ul>
</li>
</ul>
<p>✅ <strong>关键点</strong>：</p>
<ul>
<li><strong>Redis Stream 适用于小规模、高吞吐、低延迟的消息队列</strong>。</li>
<li><strong>如果需要大规模分布式处理，Kafka 是更好的选择</strong>。</li>
</ul>
<h3 id="问：Redis如何实现消息队列？能不能生产一次消费多次呢？⭐⭐⭐"><a href="#问：Redis如何实现消息队列？能不能生产一次消费多次呢？⭐⭐⭐" class="headerlink" title="问：Redis如何实现消息队列？能不能生产一次消费多次呢？⭐⭐⭐?"></a>问：Redis如何实现消息队列？能不能生产一次消费多次呢？⭐⭐⭐?</h3><ul>
<li><p> <strong>基于List的LPUSH+BRPOP</strong>：</p>
</li>
<li><p>实现：</p>
<ul>
<li><strong>生产者端：</strong>使用 <code>LPUSH</code> 命令将消息推入一个列表（队列）的左侧。例如：<code>LPUSH my_queue &quot;message1&quot;</code> </li>
<li><strong>消费者端：</strong>使用 <code>BRPOP</code> 命令从队列右侧阻塞式地弹出消息。例如：<code>BRPOP my_queue 0</code> 这里的 <code>0</code> 表示无限期阻塞，直到有新消息到达。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>简单实现，消息延迟几乎为0。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>空闲连接问题：</strong>如果消费者线程长时间阻塞在 <code>BRPOP</code> 上，会导致 Redis 客户端连接处于闲置状态；长时间的空闲可能被服务器断开连接，从而在执行阻塞命令时抛出异常。实现时需要捕捉异常并设计重连或重试机制。</li>
<li><strong>确认机制（ACK）不友好：</strong>使用 List 作为队列时，消息一旦被弹出即从队列中删除，无法内置确认（ACK）机制保证消费者处理成功。如果消费者在处理消息期间宕机或发生异常，消息可能丢失。为了弥补这一点，通常需要开发者在应用层额外实现 Pending 列表来跟踪未确认的消息。</li>
<li><strong>广播和重复消费支持不足：</strong>这种模式只适合点对点消费（即一条消息只能被一个消费者消费），不支持广播模式；消息一旦被消费即删除，不允许重复消费，也不支持消费者分组模式。</li>
</ul>
</li>
<li><p><strong>基于Sorted Set</strong>：多用来实现延迟队列，也可以实现有序的普通消息队列。</p>
<ul>
<li><p>实现：</p>
<ul>
<li><p>延迟队列场景：消息存储时使用 <code>ZADD</code> 命令将消息放入有序集合中，score 一般设置为消息的时间戳（或期望的触发时间）。例如：<code>ZADD delay_queue 1672531200 &quot;message1&quot;</code></p>
</li>
<li><p>消费过程：消费者定期使用 <code>ZRANGEBYSCORE</code> 命令查询 score 小于当前时间的消息（即已到期的消息），并处理后再用 <code>ZREM</code> 删除。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE delay_queue -inf 1672531200 LIMIT 0 1</span><br><span class="line">ZREM delay_queue <span class="string">&quot;message1&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li><strong>延迟队列：</strong>非常适合实现延迟或定时任务，能够根据消息时间顺序有序消费。</li>
<li><strong>有序性：</strong>自然具备排序功能，可以根据 score 来精确控制消息的顺序。</li>
</ul>
</li>
<li><p>缺点：消费者无法阻塞的获取消息，只能轮询，不允许重复消费。</p>
<ul>
<li><strong>轮询方式：</strong>消费者无法通过阻塞等待方式获取消息，只能定期轮询当前时间范围内的消息，这会带来一定的资源浪费和不确定的延迟。</li>
<li><strong>重复消费问题：</strong>消息处理后一般需要手动删除，且不支持内置的消息重复消费机制（因为消息一旦删除，就无法再次消费）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于PUB/SUB发布订阅模式</strong>：不适合做消息存储和积压类的业务，而是擅长做即时通讯、即时反馈的业务。</p>
<ul>
<li>实现：<ul>
<li><strong>生产者端：</strong>使用 <code>PUBLISH</code> 命令将消息发送到一个或多个频道。例如：<code>PUBLISH my_channel &quot;message1&quot;</code></li>
<li><strong>消费者端：</strong>使用 <code>SUBSCRIBE</code> 命令订阅相应频道，消费者实时接收该频道中发布的消息。例如：<code>SUBSCRIBE my_channel</code> </li>
</ul>
</li>
<li>优点：<ul>
<li><strong>广播模式：</strong>一个消息可以被多个订阅者同时接收，实现天然的广播效果；同时支持多信道订阅。</li>
<li><strong>即时性：</strong>消息一经发布，所有在线订阅者都会立即收到，无需轮询。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>消息不可持久化：</strong>消息发布后不会存储到 Redis 中。如果消费者不在线，则无法接收到历史消息，消息会丢失。</li>
<li><strong>消费者离线问题：</strong>发布时如果消费者不在线，消息就丢失；此外，当消费者处理不过来或出现消息积压时，可能会被服务器断开连接。</li>
<li><strong>缺乏确认机制：</strong>没有消息确认（ACK）机制，不能保证每条消息都被处理成功。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于Stream类型的实现</strong>：基本上已经有了消息中间件的雏形，可以考虑在生产中使用。</p>
<ul>
<li><p>实现：</p>
<ul>
<li><p><strong>生产者端：</strong>使用 <code>XADD</code> 命令向 Stream 中添加消息，Redis 会自动为每条消息生成全局唯一的 ID。例如：<code>XADD mystream * field1 value1 field2 value2</code> </p>
</li>
<li><p><strong>消费者端：</strong>消费者可以使用 <code>XREAD</code> 或 <code>XREADGROUP</code> 命令来读取消息。<code>XREAD</code> 支持阻塞读取模式：<code>XREAD BLOCK 0 STREAMS mystream 0</code> </p>
<p><code>XREADGROUP</code> 则支持消费组模式，实现负载均衡和消息确认（ACK），保证消息可靠消费：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 1 BLOCK 0 STREAMS mystream &gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>确认机制：</strong>消费者在处理完成消息后，使用 <code>XACK</code> 命令确认消息，确保消息从 Pending 列表中移除，保证消息不丢失。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li><strong>持久化与可靠性：</strong>Stream 支持消息持久化，且内置了消费组、消息确认等机制，能保证消息至少被消费一次。</li>
<li><strong>阻塞与批量读取：</strong>支持阻塞读取和批量获取，有助于构建高吞吐量的消息处理系统。</li>
<li><strong>消费组支持：</strong>可实现多个消费者对同一消息流的协同消费，既避免重复消费，也能分散消费压力。</li>
<li><strong>功能丰富：</strong>除了基本的消息队列功能，Stream 还支持消息追溯、消费者组管理、消息重新分配等高级功能，使其接近专业消息中间件的能力。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>实现复杂：</strong>相对于 List 和 Pub/Sub，Stream 的使用和管理（如消费组、Pending 列表、重试机制）更复杂，需要开发者设计好消息处理流程。</li>
<li><strong>资源管理：</strong>如果消息处理不及时或消费组配置不当，Pending 消息可能积压，导致内存占用增加，需要定期清理或自动管理。</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<p><strong>选择方案的考虑因素</strong></p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>Pub/Sub</strong></th>
<th><strong>Stream</strong></th>
<th><strong>List 自定义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>消息持久化</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>低</td>
<td>高</td>
<td>取决于实现</td>
</tr>
<tr>
<td>多消费者支持</td>
<td>是（广播）</td>
<td>是（消费组）</td>
<td>手动实现</td>
</tr>
<tr>
<td>消费失败重试</td>
<td>否</td>
<td>是</td>
<td>手动实现</td>
</tr>
<tr>
<td>实时通知</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>消息顺序保障</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>总结：生产一次消费多次选型建议</strong></p>
<ol>
<li><strong>实时广播消息：</strong> 使用 <code>Pub/Sub</code>，但需注意消息持久化和丢失问题。</li>
<li><strong>可靠持久化、多消费者消费：</strong> 使用 Redis <code>Stream</code>。</li>
<li><strong>简单队列模型：</strong> 使用 Redis <code>List</code>，但需额外管理消费状态。</li>
</ol>
<h3 id="问：Redis如何实现延时队列？⭐⭐⭐"><a href="#问：Redis如何实现延时队列？⭐⭐⭐" class="headerlink" title="问：Redis如何实现延时队列？⭐⭐⭐"></a>问：Redis如何实现延时队列？⭐⭐⭐</h3><p>使用sortedset，想要执行时间的时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p>
<h5 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h5><p><strong>核心思想：</strong></p>
<ul>
<li>使用 Redis 的 <strong>Sorted Set（有序集合）</strong>，其成员按分值（<code>score</code>）排序。</li>
<li>将消息的执行时间作为 <code>score</code>，消息内容作为 <code>value</code>。</li>
<li>定期轮询 Sorted Set，获取到期消息。</li>
</ul>
<p><strong>实现步骤：</strong></p>
<ol>
<li><p>生产者：消息入队</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD delay_queue &lt;timestamp&gt; &lt;message&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>timestamp</code>：当前时间 + 延时时间（Unix 时间戳）。</li>
<li><code>message</code>：消息内容。</li>
</ul>
</li>
<li><p>消费者：消息出队（轮询）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    now = current_timestamp()</span><br><span class="line">    messages = ZRANGEBYSCORE delay_queue -inf now LIMIT 0 1</span><br><span class="line">    </span><br><span class="line">    if messages:</span><br><span class="line">        # 获取到期消息</span><br><span class="line">        message = messages[0]</span><br><span class="line">        </span><br><span class="line">        # 消费消息</span><br><span class="line">        process(message)</span><br><span class="line">        </span><br><span class="line">        # 从队列中删除</span><br><span class="line">        ZREM delay_queue message</span><br><span class="line">    else:</span><br><span class="line">        # 无可消费消息时，等待一段时间</span><br><span class="line">        sleep(interval)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><strong>精准延时</strong>：按分值排序，精确到毫秒级。</li>
<li><strong>持久存储</strong>：消息不会丢失，支持重启恢复。</li>
<li><strong>灵活性高</strong>：支持任意延时和批量获取。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>轮询开销大</strong>：如果消息量巨大且延时精确度高，频繁轮询会增加 Redis 的压力。</li>
<li><strong>单点瓶颈</strong>：Redis 需要高可用部署，否则数据易丢失。</li>
</ul>
<h5 id="List-定时任务"><a href="#List-定时任务" class="headerlink" title="List + 定时任务"></a>List + 定时任务</h5><p><strong>核心思想：</strong></p>
<ul>
<li>将消息推入 List。</li>
<li>使用定时任务（如 <code>cron</code>、<code>TimerTask</code>）定期检查消息并消费。</li>
</ul>
<p><strong>生产者：消息入队</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH delay_queue &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p><strong>消费者：定时消费任务</strong></p>
<ul>
<li>定时任务轮询队列，检查消息是否到期。</li>
<li>适用于简单场景，但延时精度较低。</li>
</ul>
<h5 id="Redis-Stream（消息流）"><a href="#Redis-Stream（消息流）" class="headerlink" title="Redis Stream（消息流）"></a>Redis Stream（消息流）</h5><p><strong>核心思想：</strong></p>
<ul>
<li>Redis Stream 是天然的消息队列，可以带有时间戳。</li>
<li>消息按时间顺序存储，支持持久化和消费组。</li>
</ul>
<p><strong>步骤：</strong></p>
<ol>
<li><p><strong>生产者：添加消息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD delay_queue * message &quot;Hello World&quot; delay &lt;timestamp&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>消费者：轮询消息流</strong></p>
<ul>
<li>定期检查消息 <code>delay</code> 字段是否到期，进行消费。</li>
</ul>
</li>
</ol>
<p><strong>适用场景：</strong></p>
<ul>
<li>高可靠性分布式系统。</li>
<li>消息有序、延时精度高的场景。</li>
</ul>
<h5 id="Pub-Sub（发布-订阅）模式（不推荐）"><a href="#Pub-Sub（发布-订阅）模式（不推荐）" class="headerlink" title="Pub/Sub（发布/订阅）模式（不推荐）"></a>Pub/Sub（发布/订阅）模式（不推荐）</h5><p><strong>说明：</strong></p>
<ul>
<li>使用 Redis 的发布/订阅模式实现延时消息。</li>
<li>生产者延迟发布消息。</li>
<li>消费者订阅频道实时接收消息。</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li>无法持久化，消费者未订阅时消息丢失。</li>
<li>不适合延时精度高的场景。</li>
</ul>
<p><strong>总结：如何选择 Redis 延时队列方案？</strong></p>
<table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Sorted Set</td>
<td>精确延时、持久化、灵活性高</td>
<td>轮询开销大</td>
<td>精确延时任务</td>
</tr>
<tr>
<td>List + 定时任务</td>
<td>简单易用</td>
<td>精度低、不可持久化</td>
<td>轻量级延时队列</td>
</tr>
<tr>
<td>Redis Stream</td>
<td>高可靠、持久化、分布式支持</td>
<td>实现复杂，开销较大</td>
<td>分布式任务调度</td>
</tr>
<tr>
<td>Pub/Sub</td>
<td>实时推送，延迟小</td>
<td>消息丢失，不支持重试</td>
<td>简单消息通知</td>
</tr>
</tbody></table>
<hr>
<p>在高并发、精确延时的场景中，推荐使用 <strong>Sorted Set</strong> 或 <strong>Redis Stream</strong>。若对精度要求不高且实现简单，可以选择 <strong>List + 定时任务</strong>。</p>
<hr>
<h2 id="五-持久化"><a href="#五-持久化" class="headerlink" title="五. 持久化"></a>五. 持久化</h2><h3 id="问：Redis-持久化策略？如何选择合适的策略？Redis如何做持久化？⭐⭐⭐"><a href="#问：Redis-持久化策略？如何选择合适的策略？Redis如何做持久化？⭐⭐⭐" class="headerlink" title="问：Redis 持久化策略？如何选择合适的策略？Redis如何做持久化？⭐⭐⭐"></a>问：Redis 持久化策略？如何选择合适的策略？Redis如何做持久化？⭐⭐⭐</h3><p>Redis 提供两种主要的持久化方式，分别是：</p>
<ol>
<li><strong>RDB（Redis Database Snapshot）</strong>全量持久化<ul>
<li><strong>原理</strong>：在指定的时间间隔内通过 fork 子进程，将当前内存数据生成一个全量快照（snapshot）并保存到磁盘上，文件名通常是 <code>dump.rdb</code>。</li>
<li><strong>触发机制</strong><ul>
<li>自动触发：根据 <code>save</code> 配置（如 <code>save 900 1</code> 表示 900 秒内有 1 次更改时触发）。</li>
<li>手动触发：执行命令 <code>SAVE</code>（阻塞） 或 <code>BGSAVE</code>（后台保存）。</li>
<li>Redis 退出时自动执行。</li>
</ul>
</li>
<li>优点：<ul>
<li>快照文件体积小，适合备份、迁移；</li>
<li>重启恢复速度较快；</li>
<li>对性能影响较小，因为子进程生成快照是异步进行的。</li>
</ul>
</li>
<li>缺点：<ul>
<li>如果 Redis 崩溃，可能会丢失最后一次快照之后的数据；</li>
<li>快照过程（fork）在数据量非常大时可能会消耗较多资源，短时间内影响主进程性能。</li>
</ul>
</li>
</ul>
</li>
<li><strong>AOF（Append Only File）</strong>增量持久化<ul>
<li><strong>原理</strong>：将所有写操作记录（<code>SET</code>、<code>INCR</code> 等）以 Redis 协议格式追加到一个日志文件中，默认文件名为 <code>appendonly.aof</code>。服务器重启时通过重放这些命令恢复数据。随着文件增大还会进行文件重写。</li>
<li><strong>同步策略（<code>appendfsync</code> 配置）</strong><ul>
<li><strong>always：</strong> 每次操作都刷盘（最安全，但性能最差）。</li>
<li><strong>everysec（默认）：</strong> 每秒刷盘（高效，数据丢失在 1 秒内）。</li>
<li><strong>no：</strong> 不主动刷盘（完全依赖操作系统，可能丢失数据）。</li>
</ul>
</li>
<li>优点：<ul>
<li>数据恢复更完整，理论上可以做到每次写操作都持久化；</li>
<li>配置灵活，支持每次写操作同步、每秒同步或异步同步。</li>
</ul>
</li>
<li>缺点：<ul>
<li>AOF 文件通常比 RDB 文件大；</li>
<li>需定期重写（rewrite）文件，重写也会消耗系统资源；</li>
<li>写操作频繁时性能受影响。</li>
<li>恢复速度相对 RDB 较慢（日志回放时间长）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>此外，<strong>主从同步</strong>在一定程度上也能作为一种持久化手段（数据复制），但主要用于高可用性和读写分离，不完全算持久化。</p>
<p>AOF的工作流程：</p>
<ol>
<li><p><strong>命令写入</strong></p>
<ul>
<li>客户端每次对 Redis 执行写操作，都会将该命令以追加方式写入 AOF 缓冲区，并根据 AOF 策略（always、everysec 或 no）同步到磁盘。例如：<ul>
<li><strong>always</strong>：每次写操作后立即 fsync，同步到磁盘（性能较低，数据安全性最高）。</li>
<li><strong>everysec</strong>：每秒 fsync 一次（默认），在高并发时可以降低磁盘 I/O 压力，但可能丢失最多 1 秒的数据。</li>
<li><strong>no</strong>：完全异步，不主动 fsync，由操作系统决定，性能最高但风险也最大。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>重写机制</strong></p>
<ul>
<li>随着写操作不断追加，AOF 文件会逐渐变大，同时可能包含大量重复或无效的命令。为此，Redis 会在后台启动 AOF 重写（rewrite）进程，将当前内存中的数据转换为一组最小化的、可以完整重构数据集的命令，并写入一个新的 AOF 文件，然后用新的文件替换旧的。</li>
<li>Redis 4.x 及更高版本还提供了“混合持久化”模式，即在 AOF 文件开头追加一个 RDB 快照，然后继续追加写命令，这样可以提高重写效率和恢复速度。</li>
</ul>
</li>
<li><p><strong>重启加载</strong></p>
<ul>
<li>当 Redis 重启时，会首先尝试加载 AOF 文件（如果同时开启了 RDB 和 AOF，则默认加载 AOF），重放文件中的命令来恢复数据状态。</li>
</ul>
</li>
<li><p><strong>文件校验</strong></p>
<ul>
<li>Redis 在加载 AOF 文件时，会对文件进行校验，确保文件格式正确。如果发现损坏，会尝试修复或截断到最后一个有效位置。</li>
</ul>
</li>
</ol>
<p><strong><code>appendfsync everysec</code> 模式的工作原理</strong></p>
<ol>
<li><strong>写入流程</strong><ul>
<li>当客户端执行写操作时（如 <code>SET</code>、<code>INCR</code>），Redis 首先将数据写入内存和 AOF 缓冲区（操作日志）。</li>
<li>Redis 采用后台线程每秒执行一次磁盘同步（<code>fsync</code>），将 AOF 缓冲区中的数据写入磁盘。</li>
</ul>
</li>
<li><strong>安全保证</strong><ul>
<li>Redis 使用操作系统的磁盘缓存机制（<code>fsync</code>），该操作是异步的，每秒执行一次。</li>
<li>如果 Redis 或操作系统崩溃，尚未刷盘的操作将丢失。</li>
</ul>
</li>
</ol>
<p>RDB 的工作流程：</p>
<ol>
<li>全量快照<ul>
<li>通过 fork 子进程，主进程继续处理请求，而子进程将当前内存中的数据快照写入磁盘文件。</li>
</ul>
</li>
<li>触发条件<ul>
<li>可通过配置文件中的 save 规则（如 “save 900 1”, “save 300 10”）定时触发快照生成。</li>
</ul>
</li>
<li>恢复速度<ul>
<li>由于 RDB 文件是全量数据快照，恢复速度较快，但可能会丢失最近一次快照之后的数据。</li>
</ul>
</li>
</ol>
<p>如何选择合适的持久化策略？</p>
<p>自 Redis 4.0 起，支持 RDB 与 AOF 混合持久化：</p>
<ul>
<li>在 Redis 重启时，先加载最新的 RDB 快照，再回放未落盘的 AOF 日志。</li>
<li>启用方式：<code>aof-use-rdb-preamble yes</code>。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>使用场景</strong></th>
<th><strong>推荐策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td>高可靠性、数据不能丢失</td>
<td>AOF（<code>everysec</code>）</td>
</tr>
<tr>
<td>快速备份与灾难恢复</td>
<td>RDB（定期备份）</td>
</tr>
<tr>
<td>数据量大，写操作频繁</td>
<td>RDB（减少磁盘 IO）</td>
</tr>
<tr>
<td>高性能与高可用混合需求</td>
<td>RDB + AOF 混合持久化</td>
</tr>
</tbody></table>
<p><strong>如何选择合适的策略？</strong></p>
<ol>
<li><strong>高性能优先（读多写少）</strong>：<ul>
<li>使用 RDB，备份频率配置合理，减少磁盘 IO。</li>
</ul>
</li>
<li><strong>高可靠性优先（写多、实时性强）</strong>：<ul>
<li>使用 AOF（<code>everysec</code> 模式），或结合 RDB 进行混合持久化。</li>
</ul>
</li>
<li><strong>企业级场景（高可用、数据不可丢）</strong>：<ul>
<li>启用 AOF + RDB，确保数据持久化与恢复速度平衡。</li>
</ul>
</li>
</ol>
<p><strong>Redis 持久化的注意事项</strong></p>
<ol>
<li><strong>文件管理与存储监控</strong>：<ul>
<li>定期检查磁盘使用情况，防止存储空间耗尽。</li>
</ul>
</li>
<li><strong>定期快照与备份</strong>：<ul>
<li>配置定期 RDB 快照，做异地备份。</li>
</ul>
</li>
<li><strong>日志重写与优化</strong>：<ul>
<li>开启 AOF 日志重写，配置合适的重写阈值，避免文件过大。</li>
</ul>
</li>
<li><strong>分布式环境中的持久化</strong>：<ul>
<li>在 Redis 集群环境中，考虑多主多从架构，借助 Redis Sentinel 或 Redis Cluster 实现高可用。</li>
</ul>
</li>
</ol>
<h3 id="问：如果突然机器断电会怎样？⭐⭐⭐"><a href="#问：如果突然机器断电会怎样？⭐⭐⭐" class="headerlink" title="问：如果突然机器断电会怎样？⭐⭐⭐"></a>问：如果突然机器断电会怎样？⭐⭐⭐</h3><p>一般会选择everysec模式，即每秒执行一次fsync同步文件，所以只会丢失1s的数据（同步时主线程会判断最近2s是否有进行同步，有则直接返回，否则阻塞等同步线程执行完毕，所以最多可能丢失2s的数据）。</p>
<p>一、断电对 Redis 的影响</p>
<p>Redis 是内存数据库，所有数据主要存储在内存中，因此在断电或系统崩溃时，未持久化的数据会丢失。为了降低断电带来的数据风险，Redis 提供了两种主要持久化方式：</p>
<ul>
<li><strong>RDB</strong>：全量快照，定时保存内存中的数据到磁盘</li>
<li><strong>AOF</strong>：记录每次写操作的日志，通过日志重放恢复数据</li>
</ul>
<p>此外，主从复制也能起到一定的数据冗余作用，但它主要用于高可用而非严格持久化。</p>
<p>二、持久化策略对断电数据丢失的影响</p>
<p>不同的持久化配置下，断电后的数据恢复情况不同，下面给出一个对比表：</p>
<table>
<thead>
<tr>
<th><strong>持久化配置</strong></th>
<th><strong>断电后数据状态</strong></th>
<th><strong>数据丢失情况</strong></th>
</tr>
</thead>
<tbody><tr>
<td>无持久化（默认关闭）</td>
<td>内存数据全部丢失</td>
<td>丢失全部数据</td>
</tr>
<tr>
<td>仅启用 RDB</td>
<td>恢复到最近一次 RDB 快照</td>
<td>丢失 RDB 快照后产生的数据</td>
</tr>
<tr>
<td>仅启用 AOF</td>
<td>恢复到最近的 AOF 日志</td>
<td>丢失 appendfsync 配置后（如 everysec）的数据</td>
</tr>
<tr>
<td>RDB + AOF 混合持久化</td>
<td>恢复到 RDB 快照 + AOF 最新状态</td>
<td>丢失 AOF 刷盘前（可能1秒或最多2秒内）的数据</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong><br>在 <code>appendfsync everysec</code> 模式下，Redis 会每秒将 AOF 缓冲区数据同步到磁盘，理论上最多丢失 1 秒的数据，但由于主线程在同步时可能会检测到最近2秒内是否已进行 fsync，极端情况下可能丢失 2 秒数据。</p>
</blockquote>
<p>三、如何减少断电带来的数据丢失？</p>
<ol>
<li><p>启用合适的持久化策略</p>
<ul>
<li>同时启用 RDB 和 AOF：<ul>
<li>RDB 快照便于备份和快速恢复，AOF 提供更高的数据完整性。</li>
<li>推荐混合持久化模式：Redis 启动时先加载 RDB 快照，再重放 AOF 日志，确保数据更完整。</li>
</ul>
</li>
</ul>
<p><strong>示例配置（redis.conf）：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> RDB 快照配置</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用 AOF，并设置每秒同步</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启混合持久化，使用 RDB 快照作为 AOF 文件头</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure></li>
<li><p>设置合理的 AOF 刷盘策略</p>
<ul>
<li><p>使用 <code>appendfsync everysec</code> 模式</p>
<p>每秒 fsync 一次，在性能和数据安全之间取得平衡。</p>
<p>可通过命令：<code>CONFIG SET appendfsync everysec</code></p>
</li>
</ul>
</li>
<li><p>部署主从复制与高可用架构</p>
<ul>
<li><strong>主从复制</strong>：当主节点断电时，从节点可以接管服务，降低数据丢失风险。</li>
<li><strong>高可用集群</strong>：部署 Redis Sentinel 或 Redis Cluster，确保故障转移时数据冗余。</li>
</ul>
</li>
<li><p>硬件与系统保障</p>
<ul>
<li><strong>稳定的硬盘</strong>：使用 SSD，并配置 RAID，确保写入过程中硬件故障风险降低。</li>
<li><strong>UPS 电源</strong>：采用不间断电源（UPS）防止突发断电。</li>
</ul>
</li>
<li><p>定期备份与异地灾备</p>
<ul>
<li><strong>定期备份</strong>：定期备份 RDB 和 AOF 文件，异地存储，确保即使本地数据丢失也能恢复。</li>
</ul>
</li>
</ol>
<p>四、断电后的恢复步骤</p>
<ol>
<li><p><strong>检查持久化文件与日志</strong></p>
<ul>
<li>查看 <code>dump.rdb</code> 和 <code>appendonly.aof</code> 文件是否存在并完整。</li>
<li>查看 Redis 日志确认是否成功加载持久化数据。</li>
</ul>
</li>
<li><p><strong>文件校验与修复</strong></p>
<ul>
<li>若 AOF 文件损坏，可使用以下命令尝试修复：<code> redis-check-aof --fix appendonly.aof</code></li>
</ul>
</li>
<li><p><strong>手动恢复（如必要）</strong></p>
<ul>
<li>从备份文件中恢复数据，或手动执行重放操作，确保系统恢复到断电前状态。</li>
</ul>
</li>
</ol>
<p>五、总结</p>
<ul>
<li><strong>断电风险</strong>：<br>Redis 断电时，由于数据主要存储在内存，未持久化的数据会丢失。</li>
<li><strong>持久化策略</strong>：<br>通过合理配置 RDB、AOF（或混合持久化）以及主从复制，高可用架构，可以有效降低数据丢失风险。</li>
<li><strong>配置与恢复</strong>：<br>采用 <code>appendfsync everysec</code> 模式能在性能与数据安全间取得平衡；断电后，通过日志检查、AOF 修复和备份恢复确保数据尽可能完整。</li>
</ul>
<h3 id="问：bgsave的原理是什么？⭐⭐⭐"><a href="#问：bgsave的原理是什么？⭐⭐⭐" class="headerlink" title="问：bgsave的原理是什么？⭐⭐⭐"></a>问：bgsave的原理是什么？⭐⭐⭐</h3><p>bgsave相比于已废弃的save，后者阻塞服务器直到RDB过程结束，前者则通过fork创建子进程，持久化过程由子进程来完成，减少了主进程的阻塞时间。通过copy-on-write机制，父子进程共享内存，父进程继续提供读写服务，子进程根据父进程内存生成快照文件，并替换到RDB文件。</p>
<p><code>BGSAVE</code> 是 Redis 的一种持久化机制，用于创建数据库的 <strong>RDB 快照（dump.rdb 文件）</strong>，将内存中的数据异步保存到磁盘中。</p>
<p><strong><code>BGSAVE</code> 的工作流程</strong></p>
<ol>
<li><strong>主线程发送持久化请求</strong><ul>
<li>当客户端执行 <code>BGSAVE</code> 命令时，Redis 主线程会派生一个 <strong>子进程</strong>（<code>fork</code> 操作）。</li>
</ul>
</li>
<li><strong>子进程创建 RDB 文件</strong><ul>
<li>子进程将内存中的数据库快照序列化到临时 RDB 文件。</li>
<li>持久化过程中，Redis 主线程继续处理客户端请求，不受影响。</li>
</ul>
</li>
<li><strong>文件替换与完成</strong><ul>
<li>持久化完成后，临时 RDB 文件会原子地替换现有的 <code>dump.rdb</code> 文件。</li>
</ul>
</li>
</ol>
<p><strong>关键技术点分析</strong></p>
<table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>操作描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>fork()</code> 操作</td>
<td>主线程创建子进程，复制内存页（COW）。</td>
</tr>
<tr>
<td>数据序列化</td>
<td>子进程将数据序列化成 RDB 格式。</td>
</tr>
<tr>
<td>原子替换与完成</td>
<td>临时文件替换 <code>dump.rdb</code>。</td>
</tr>
</tbody></table>
<p><strong>优点：</strong></p>
<ol>
<li><strong>异步执行</strong>：主线程不阻塞，Redis 可继续处理请求。</li>
<li><strong>完整快照</strong>：适用于全量数据备份。</li>
<li><strong>文件安全性高</strong>：通过临时文件原子替换，确保文件完整性。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>内存开销大</strong>：<code>fork</code> 会占用与主进程相同大小的内存，数据量大时内存占用翻倍。</li>
<li><strong>性能影响</strong>：<code>fork</code> 操作会阻塞主线程短暂时间，大内存环境中影响更明显。</li>
<li><strong>数据丢失风险</strong>：仅保留快照时，最后一次 RDB 持久化后的数据修改可能丢失。</li>
</ol>
<p><strong>Redis 配置中的 <code>BGSAVE</code> 自动触发规则</strong></p>
<p>Redis 配置文件中的 <code>save</code> 指令会自动触发 <code>BGSAVE</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1   # 900 秒内至少发生 1 次写操作</span><br><span class="line">save 300 10  # 300 秒内至少发生 10 次写操作</span><br><span class="line">save 60 10000 # 60 秒内至少发生 10000 次写操作</span><br></pre></td></tr></table></figure>



<p><strong>常见应用场景</strong></p>
<ol>
<li><strong>定期全量备份</strong>：用于手动或自动创建数据库快照。</li>
<li><strong>灾备方案的一部分</strong>：结合 AOF 提供数据持久化保障。</li>
<li><strong>内存占用小的环境</strong>：适用于小型 Redis 数据集。</li>
</ol>
<p><strong>潜在问题与优化方案</strong></p>
<ol>
<li><strong>大内存时 <code>fork()</code> 慢</strong><ul>
<li>优化：使用高性能 SSD，确保操作系统 <code>fork()</code> 性能更好。</li>
</ul>
</li>
<li><strong>数据丢失风险</strong><ul>
<li>优化：结合 AOF 日志，配置 <code>appendfsync always/everysec</code>。</li>
</ul>
</li>
<li><strong>性能影响</strong><ul>
<li>优化：减小 Redis 实例的内存占用，分片部署。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><code>BGSAVE</code> 是 Redis 中的重要持久化机制，适用于全量数据备份。</li>
<li>结合 AOF 持久化与高可用方案（如主从复制、Redis Cluster），可构建高可靠性的数据存储系统。</li>
<li>在生产环境中，应根据业务数据量与写入频率，调整 <code>BGSAVE</code> 配置策略，避免持久化过程中资源耗尽或服务中断。</li>
</ul>
<h3 id="问：RDB与AOF区别？"><a href="#问：RDB与AOF区别？" class="headerlink" title="问：RDB与AOF区别？"></a>问：RDB与AOF区别？</h3><ol>
<li><p>RDB压缩文件格式紧凑，适合备份和全量复制，数据恢复快。但没法实时持久化，且有不同版本多个格式问题。</p>
</li>
<li><p>AOF则不断的追加命令到文件（文本协议RESP），因此文件会不断变大，需要重写机制来压缩体积。重写时通过重写缓冲区保存此期间主进程响应的命令。</p>
</li>
</ol>
<p><strong>RDB 与 AOF 的区别详解</strong></p>
<p>Redis 提供了两种数据持久化方式：<strong>RDB（Redis Database File）</strong> 和 <strong>AOF（Append Only File）</strong>。它们在数据保存方式、性能表现、恢复速度等方面各有特点。</p>
<p><strong>1. 持久化机制对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>RDB</strong></th>
<th><strong>AOF</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>触发方式</strong></td>
<td>定期快照（手动或自动触发）</td>
<td>日志记录（追加式）</td>
</tr>
<tr>
<td><strong>保存内容</strong></td>
<td>全量快照，内存数据的完整镜像</td>
<td>每个写命令的执行日志</td>
</tr>
<tr>
<td><strong>数据丢失风险</strong></td>
<td>最多丢失最后一次快照后的数据</td>
<td>最多丢失 1 秒内数据（<code>everysec</code>）</td>
</tr>
<tr>
<td><strong>文件体积</strong></td>
<td>相对小，存储压缩后的数据</td>
<td>相对大，记录每个命令日志</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td><code>fork</code> 可能占用大量内存和 CPU</td>
<td>写命令附带磁盘 I/O 操作</td>
</tr>
<tr>
<td><strong>数据恢复速度</strong></td>
<td>恢复速度快，直接加载内存镜像</td>
<td>重放日志，恢复速度较慢</td>
</tr>
<tr>
<td><strong>持久化文件名</strong></td>
<td><code>dump.rdb</code></td>
<td><code>appendonly.aof</code></td>
</tr>
</tbody></table>
<p><strong>2. 工作原理对比</strong></p>
<p><strong>RDB（Redis Database File）</strong></p>
<ul>
<li>通过创建内存快照保存数据到磁盘。</li>
<li>支持手动执行命令：<code>SAVE</code>（同步） 或 <code>BGSAVE</code>（异步）。</li>
<li>配置文件触发规则：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1     # 900 秒内至少发生 1 次写操作时触发</span><br><span class="line">save 300 10    # 300 秒内至少发生 10 次写操作时触发</span><br><span class="line">save 60 10000  # 60 秒内至少发生 10000 次写操作时触发</span><br></pre></td></tr></table></figure>

<p><strong>AOF（Append Only File）</strong></p>
<ul>
<li>将每个写操作追加到日志文件。</li>
<li>刷盘模式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfsync always     # 每次写入操作都同步到磁盘，最安全但性能差</span><br><span class="line">appendfsync everysec   # 每秒同步一次，推荐，性能与安全性折中</span><br><span class="line">appendfsync no         # 由操作系统自行决定同步时机，风险较高</span><br></pre></td></tr></table></figure>

<p><strong>3. 优缺点对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>RDB 优点</strong></th>
<th><strong>RDB 缺点</strong></th>
<th><strong>AOF 优点</strong></th>
<th><strong>AOF 缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据完整性</strong></td>
<td>文件小，恢复快</td>
<td>可能丢失大量数据</td>
<td>数据更完整</td>
<td>恢复较慢，文件大</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>最小性能影响</td>
<td><code>fork</code> 占用内存</td>
<td>实时持久化更安全</td>
<td>写频繁时性能受限</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>全量备份、冷备</td>
<td>不适合高频数据变化场景</td>
<td>实时持久化，重要数据保存</td>
<td>磁盘 I/O 成本高</td>
</tr>
<tr>
<td><strong>灾难恢复能力</strong></td>
<td>快速加载</td>
<td>数据可能较旧</td>
<td>最多丢失 1 秒内数据</td>
<td>重放日志速度慢</td>
</tr>
</tbody></table>
<p><strong>4. 推荐使用场景</strong></p>
<ol>
<li><strong>仅使用 RDB（全量快照）</strong><ul>
<li>数据变化不频繁，允许一定程度的数据丢失。</li>
<li>定期做全量备份，适用于离线批处理服务。</li>
</ul>
</li>
<li><strong>仅使用 AOF（日志持久化）</strong><ul>
<li>数据变化频繁，不能容忍数据丢失。</li>
<li>日志文件需要定期重写，适用于重要数据存储服务。</li>
</ul>
</li>
<li><strong>混合使用 RDB 与 AOF（推荐）</strong><ul>
<li>Redis 提供了混合持久化选项：</li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes  # 混合持久化：先写 RDB 快照，再附加 AOF 日志</span><br></pre></td></tr></table></figure>

<p><strong>总结：选择策略</strong></p>
<ul>
<li><strong>高性能要求（内存占用敏感）</strong>：使用 RDB，减少磁盘 I/O。</li>
<li><strong>高可靠性要求（数据丢失敏感）</strong>：使用 AOF，<code>appendfsync everysec</code>。</li>
<li><strong>数据安全与恢复速度兼顾</strong>：启用 <strong>RDB + AOF 混合持久化</strong>。</li>
</ul>
<p>通过灵活配置，Redis 可以满足不同业务场景的数据持久化与容灾需求。</p>
<h3 id="问：Redis-持久化数据和缓存怎么做扩容？TODODODODODO"><a href="#问：Redis-持久化数据和缓存怎么做扩容？TODODODODODO" class="headerlink" title="问：Redis 持久化数据和缓存怎么做扩容？TODODODODODO"></a>问：Redis 持久化数据和缓存怎么做扩容？TODODODODODO</h3><p>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p>
<p>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</p>
<p><strong>Redis 持久化数据与缓存的扩容方案</strong></p>
<p>Redis 的扩容分为 <strong>持久化数据扩容</strong> 和 <strong>缓存扩容</strong>，需要根据业务需求、数据量和访问模式选择合适的扩展策略。</p>
<p><strong>一、Redis 持久化数据扩容方案</strong></p>
<ol>
<li><strong>垂直扩展（Scale-up）</strong></li>
</ol>
<ul>
<li><p><strong>方案描述</strong>：升级 Redis 节点硬件，提升单机性能。</p>
</li>
<li><p><strong>适用场景</strong>：数据量和请求量增长不大时。</p>
</li>
<li><p>操作步骤：</p>
<ul>
<li>选择内存更大的服务器。</li>
<li>配置更高的 CPU、磁盘 I/O。</li>
<li>迁移 Redis 实例数据。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>简单快速，易于操作。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>存在单点瓶颈，硬件扩展上限受限。</li>
</ul>
<ol start="2">
<li><strong>水平扩展（Scale-out）</strong></li>
</ol>
<ul>
<li><strong>方案描述</strong>：部署多台 Redis 实例，分散存储与请求负载。</li>
</ul>
<p><strong>扩展方案 1：主从复制（Master-Slave）</strong></p>
<ul>
<li>将 Redis 主节点的数据复制到多个从节点。</li>
<li>读操作分摊到从节点，主节点负责写入。</li>
<li>提升 <strong>读性能</strong>，但 <strong>写性能</strong> 无法扩展。</li>
</ul>
<p><strong>扩展方案 2：Redis 哨兵模式（Sentinel）</strong></p>
<ul>
<li>在主从复制基础上引入 Redis Sentinel，自动完成主从切换。</li>
<li>增强了高可用性与自动故障转移。</li>
</ul>
<p><strong>扩展方案 3：Redis Cluster（官方推荐）</strong></p>
<ul>
<li>Redis 原生分布式集群，数据自动分片。</li>
<li>支持 <strong>高可用</strong> 和 <strong>高扩展性</strong>。</li>
</ul>
<p><strong>操作步骤</strong>：</p>
<ol>
<li>配置 <code>redis.conf</code> 文件，启用集群模式：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<ol>
<li>启动 Redis 节点：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

<ol>
<li>使用命令行工具创建集群：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.0.1:7000 192.168.0.2:7001 ... --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<p><strong>二、Redis 缓存扩容方案</strong></p>
<ol>
<li><strong>垂直扩展（Scale-up）</strong></li>
</ol>
<ul>
<li>增加单个 Redis 节点的内存容量。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>数据量不大，单节点性能足够。</li>
</ul>
<ol start="2">
<li><strong>水平扩展（Scale-out）</strong></li>
</ol>
<p><strong>方案 1：客户端分片（Client Sharding）</strong></p>
<ul>
<li>客户端根据一致性哈希或分片算法，将请求分配到多个 Redis 节点。</li>
<li><strong>示例框架</strong>：Jedis Sharded API、Spring Cache。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>简单高效，支持不同 Redis 版本。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要客户端管理分片逻辑，客户端开发复杂。</li>
</ul>
<p><strong>方案 2：代理分片（Proxy Sharding）</strong></p>
<ul>
<li>使用 Redis 中间件（如 Twemproxy、Codis）管理分片逻辑。</li>
<li><strong>适用场景</strong>：高并发、高吞吐应用。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>开发透明，无需修改业务代码。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>中间件本身需要维护，存在额外延迟。</li>
</ul>
<p><strong>方案 3：Redis Cluster 模式（推荐）</strong></p>
<ul>
<li>Redis 自带集群管理功能，客户端透明分片。</li>
</ul>
<p><strong>三、数据迁移方案（扩容迁移注意点）</strong></p>
<ol>
<li><strong>冷迁移（停机维护）</strong><ul>
<li>在非高峰期停机，进行 Redis 数据全量迁移。</li>
</ul>
</li>
<li><strong>热迁移（在线迁移）</strong><ul>
<li>使用 Redis 数据迁移工具，如：<ul>
<li><code>redis-cli --pipe</code> 批量导入导出。</li>
<li><code>redis-shake</code> 等开源迁移工具。</li>
</ul>
</li>
</ul>
</li>
<li><strong>双写与数据同步</strong><ul>
<li>部署新 Redis 集群后，应用程序写入旧集群和新集群，完成数据同步。</li>
</ul>
</li>
</ol>
<p><strong>四、扩容注意事项</strong></p>
<ol>
<li><strong>监控与预警</strong>：<ul>
<li>使用 Redis 监控工具（如 Prometheus、Grafana）监控内存、CPU、网络带宽等。</li>
</ul>
</li>
<li><strong>数据预分片与规划</strong>：<ul>
<li>预估数据增长量，合理规划 Redis 集群节点数和分片策略。</li>
</ul>
</li>
<li><strong>节点冗余与备份</strong>：<ul>
<li>配置主从复制或 Redis Cluster，确保节点冗余与高可用。</li>
</ul>
</li>
<li><strong>持久化策略与配置优化</strong>：<ul>
<li>根据业务需求调整 RDB 与 AOF 的频率，减少磁盘 I/O 开销。</li>
</ul>
</li>
</ol>
<p><strong>总结：选择扩容方案时的决策参考</strong></p>
<table>
<thead>
<tr>
<th><strong>需求场景</strong></th>
<th><strong>扩容方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据量小，增长有限</td>
<td>垂直扩展（Scale-up）</td>
</tr>
<tr>
<td>数据量大，增长迅速</td>
<td>水平扩展（Scale-out）</td>
</tr>
<tr>
<td>读请求远多于写请求</td>
<td>主从复制（Master-Slave）</td>
</tr>
<tr>
<td>数据高可靠性、持久化需求</td>
<td>Redis Cluster + AOF</td>
</tr>
<tr>
<td>纯缓存应用，高吞吐量</td>
<td>客户端分片 / 代理分片</td>
</tr>
<tr>
<td>高可用与自动故障恢复</td>
<td>Redis 哨兵模式 / Cluster</td>
</tr>
</tbody></table>
<hr>
<p>选择合适的扩容方案，结合 Redis 自带的分片与复制机制，能够构建高性能、可扩展和高可用的 Redis 架构，满足不同规模和业务需求的分布式缓存与持久化数据存储场景。</p>
<hr>
<h2 id="六-锁"><a href="#六-锁" class="headerlink" title="六. 锁"></a>六. 锁</h2><h3 id="问：讲一下Redis分布式锁？说说怎么用redis实现分布式锁？为什么使用SETNX？"><a href="#问：讲一下Redis分布式锁？说说怎么用redis实现分布式锁？为什么使用SETNX？" class="headerlink" title="问：讲一下Redis分布式锁？说说怎么用redis实现分布式锁？为什么使用SETNX？"></a>问：讲一下Redis分布式锁？说说怎么用redis实现分布式锁？为什么使用SETNX？</h3><p>2.6版本以后lua脚本保证setnx跟setex进行原子性（setnx之后，未setex，服务挂了，锁不释放） a获取锁，超过过期时间，自动释放锁，b获取到锁执行，a代码执行完remove锁，a和b是一样的key，导致a释放了b的锁。 解决办法：remove之前判断value（高并发下value可能被修改，应该用lua来保证原子性）</p>
<p>SETNX：</p>
<ol>
<li>原子操作，锁不存在的情况下完成创建</li>
<li>如果要做分布式锁，要用set k v nx ex，不存在和过期时间，避免死锁。</li>
</ol>
<p>锁过期时间不好评估怎么办？</p>
<ul>
<li>比如设置过期时间10s，但业务逻辑执行超过10s。那么其释放锁之前，锁其实已经失效，别的线程已经可以拿锁。</li>
<li>尽量冗余过期时间，但不能完美解决问题。过长就相当于死锁，影响性能，过低又有概率失效。</li>
<li>增加看门狗：先设置过期时间，开启一个守护线程，定时检测锁的失效时间，若快过期了但操作还没结束，就自动对锁进行续期。</li>
</ul>
<p><strong>Redis 分布式锁的实现方式</strong></p>
<p><strong>1. 单节点实现（最简单方式）</strong></p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>使用 <code>SET key value NX EX seconds</code> 原子操作。</p>
<ul>
<li><code>NX</code>：键不存在时才能成功设置，确保锁的独占性。</li>
<li><code>EX seconds</code>：自动过期时间，防止死锁。</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line">String lockValue = UUID.randomUUID().toString();</span><br><span class="line"><span class="keyword">boolean</span> isLocked = redisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p><strong>解锁：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lockValue.equals(redisTemplate.opsForValue().get(lockKey))) &#123;</span><br><span class="line">    redisTemplate.delete(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2. Lua 脚本保证原子性解锁</strong></p>
<p>为防止解锁时误删其他线程的锁，使用 Lua 脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>Redis 分布式锁的特性分析</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>实现方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>互斥性</strong></td>
<td><code>SET NX</code> 原子操作</td>
</tr>
<tr>
<td><strong>死锁预防</strong></td>
<td>锁自动过期 <code>EX seconds</code></td>
</tr>
<tr>
<td><strong>高可用性</strong></td>
<td>Redis 高可用模式（主从、哨兵）</td>
</tr>
<tr>
<td><strong>容错性</strong></td>
<td>Redis 集群或 RedLock 算法</td>
</tr>
</tbody></table>
<p><strong>Redis 分布式锁的典型问题与解决方案</strong></p>
<ol>
<li><strong>锁误删（安全性问题）</strong><ul>
<li>解决方案：解锁时比对锁的唯一标识，使用 Lua 脚本保证原子操作。</li>
</ul>
</li>
<li><strong>锁续期（防止锁过期）</strong><ul>
<li>解决方案：<ul>
<li>使用锁续期机制（如 <code>Redisson</code>）。</li>
<li>后台任务定期续期。</li>
</ul>
</li>
</ul>
</li>
<li><strong>锁失效（Redis 故障）</strong><ul>
<li>解决方案：<ul>
<li>部署 Redis 高可用架构（如主从复制、哨兵模式）。</li>
<li>使用 <code>RedLock</code> 算法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Redis 分布式锁高级实现 - RedLock 算法</strong></p>
<p><code>RedLock</code> 是 Redis 作者提出的分布式锁算法，适用于 Redis 集群环境。</p>
<p><strong>RedLock 的核心步骤：</strong></p>
<ol>
<li>客户端依次向多个 Redis 节点请求获取锁，使用相同的键和唯一标识。</li>
<li>成功获取大多数节点的锁后，视为成功获取分布式锁。</li>
<li>若获取锁失败或超时，释放已获取的锁。</li>
</ol>
<p><strong>应用场景与示例</strong></p>
<p><strong>应用场景：</strong></p>
<ul>
<li>分布式任务调度</li>
<li>库存扣减（秒杀场景）</li>
<li>电商订单唯一性校验</li>
<li>限制高并发操作</li>
</ul>
<p><strong>示例：库存扣减场景</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = <span class="string">&quot;product_stock_123&quot;</span>;</span><br><span class="line">String requestId = UUID.randomUUID().toString();</span><br><span class="line"><span class="keyword">boolean</span> isLocked = redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑（扣减库存）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lua 脚本原子释放锁</span></span><br><span class="line">        String luaScript = </span><br><span class="line">            <span class="string">&quot;if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return redis.call(&#x27;DEL&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;else return 0 end&quot;</span>;</span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> DefaultRedisScript&lt;&gt;(luaScript, Long.class), Collections.singletonList(lockKey), requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Redis 分布式锁总结</strong></p>
<p>Redis 分布式锁实现简单高效，但需要注意锁误删、死锁与 Redis 故障等问题。对高并发和高可用要求较高的场景，推荐使用 <code>Redisson</code> 或 <code>RedLock</code> 算法来增强分布式锁的可靠性和容错能力。</p>
<p>Jedis获取分布式锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDistributedLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisDistributedLock</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁的 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 当前请求的唯一标识，通常用 UUID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTimeInSeconds 锁的过期时间（秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示加锁成功；false 表示加锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquireLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTimeInSeconds)</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTimeInSeconds);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁的 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 当前请求的唯一标识，用于验证是否为锁持有者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示释放成功；false 表示释放失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        Object result = jedis.eval(luaScript, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span> == (Long) result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 示例：连接本地Redis服务器</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        RedisDistributedLock lock = <span class="keyword">new</span> RedisDistributedLock(jedis);</span><br><span class="line">        String lockKey = <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line">        String requestId = java.util.UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> expireTime = <span class="number">10</span>; <span class="comment">// 10秒超时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试加锁</span></span><br><span class="line">        <span class="keyword">if</span> (lock.acquireLock(lockKey, requestId, expireTime)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加锁成功，执行业务逻辑...&quot;</span>);</span><br><span class="line">                <span class="comment">// 业务逻辑处理</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                <span class="keyword">if</span> (lock.releaseLock(lockKey, requestId)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁成功&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加锁失败，稍后重试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Redisson 是一个功能丰富的 Java 客户端，封装了 Redis 的分布式数据结构和锁等功能，并提供了基于 Redlock 算法的分布式锁实现。使用 Redisson 可以大大简化开发过程，同时内置了看门狗续期机制，确保锁在业务执行过程中不会因超时被误释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonLockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置 Redisson（单机模式示例）</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">        <span class="comment">// 若使用密码：.setPassword(&quot;yourPassword&quot;);</span></span><br><span class="line">        RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取分布式锁对象，锁名称为 &quot;myLock&quot;</span></span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取锁，最多等待10秒，锁租期30秒</span></span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Redisson 加锁成功，执行业务逻辑...&quot;</span>);</span><br><span class="line">                    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Redisson 释放锁成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Redisson 获取锁失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redissonClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>tryLock 参数说明</strong>：</p>
<ul>
<li>第一个参数表示获取锁的等待时间（最多等待10秒）；</li>
<li>第二个参数表示锁的持有时间（30秒）；</li>
<li>如果在等待时间内成功获取锁，则进入业务逻辑；否则返回获取失败。</li>
</ul>
<p><strong>看门狗机制</strong>：<br>Redisson 的分布式锁内部会启动看门狗自动续期，确保在业务执行时间超过锁租期时自动延长锁的有效期（除非主动释放锁）。</p>
<h3 id="问：Redisson？"><a href="#问：Redisson？" class="headerlink" title="问：Redisson？"></a>问：Redisson？</h3><ul>
<li><strong>定义与特点</strong><br>Redisson 是基于 Redis 协议实现的 Java 客户端，不仅支持 Redis 的基本操作，还提供了分布式对象、分布式集合、分布式锁、分布式队列、远程服务调用等高层 API。例如，Redisson 提供的 <code>RLock</code>、<code>RMap</code>、<code>RQueue</code> 等接口，使得开发者可以像操作本地 Java 集合一样操作 Redis 中的分布式数据。</li>
<li>优势<ul>
<li><strong>易用性</strong>：Redisson 封装了底层的 Redis 操作，支持同步、异步以及反应式编程模式，并且与 Spring Boot 集成非常方便。</li>
<li><strong>分布式锁及扩展特性</strong>：内置了多种锁实现（例如可重入锁、读写锁、红锁等），并提供了看门狗续期机制，避免因执行时间过长而导致锁自动失效。</li>
<li><strong>分布式数据结构</strong>：除了锁之外，Redisson 还提供了分布式集合、列表、队列、信号量、布隆过滤器等数据结构，方便构建分布式应用。</li>
</ul>
</li>
</ul>
<h3 id="问：RedLock？"><a href="#问：RedLock？" class="headerlink" title="问：RedLock？"></a>问：RedLock？</h3><p><strong>定义与原理</strong><br>Redlock 是由 Redis 的作者 Salvatore Sanfilippo（antirez）提出的一种分布式锁算法。它的核心思想是：</p>
<ul>
<li>在多个（建议至少 5 个）独立的 Redis 实例上同时尝试获取锁；</li>
<li>只有在大多数（例如 3 个或更多）实例上成功获取锁时，才认为锁被成功获得；</li>
<li>每个 Redis 实例中的锁都有一个唯一的值和超时时间，防止因客户端崩溃而导致死锁。<br>这样，即使部分 Redis 实例出现故障或延迟，也可以保证整体锁机制的安全性和可用性。</li>
</ul>
<p><strong>使用场景与争议</strong><br>Redlock 主要用于要求较高强一致性的场景，如分布式锁。但在实际生产中，关于 Redlock 的安全性和正确性也存在一定争议，具体是否采用需要结合业务场景评估。</p>
<p><strong>Redisson 中的实现</strong><br>Redisson 内置的分布式锁（例如 RLock）可以基于 Redlock 算法来实现分布式锁功能，同时内置了续期（看门狗）等机制来保证锁的持有时间足够长，从而降低锁误释放的风险。</p>
<h3 id="问：redis锁续期问题？"><a href="#问：redis锁续期问题？" class="headerlink" title="问：redis锁续期问题？"></a>问：redis锁续期问题？</h3><p>Redisson 分布式锁与看门狗机制</p>
<ul>
<li><strong>Redisson 的分布式锁（RLock）</strong>：Redisson 封装了 Redis 分布式锁的实现，使其支持可重入锁。它内部会启动一个看门狗线程，在锁持有期间不断检测锁的 TTL，并自动延长（续期）锁的有效期。默认情况下，这个看门狗会每隔一定时间（通常约为锁超时时间的一半或更短，例如 30 秒）执行一次续期操作。</li>
<li><strong>续期的目的</strong>：当业务逻辑执行时间超过初始锁的 TTL 时，看门狗可以防止锁意外过期，从而确保锁在整个业务过程中保持有效。</li>
</ul>
<p>主从复制下的潜在问题：</p>
<ul>
<li><p>异步复制与主备切换</p>
<p>Redis 的主从复制是异步的。即便 Redisson 的看门狗机制在主节点上正常延长锁的 TTL，但当主节点发生故障，由从节点提升为新的主节点时，存在以下问题：</p>
<ul>
<li><strong>数据延迟或丢失</strong>：由于复制延迟，新主节点可能没有完全更新之前的锁状态。</li>
<li><strong>锁冲突</strong>：在主节点故障后，新主节点可能允许其他客户端（比如客户端2）获取锁，而原来持有锁的客户端（客户端1）依然认为自己持有锁，导致同一锁被多个客户端同时“拥有”。</li>
</ul>
</li>
</ul>
<p>解决办法</p>
<p>为了避免在主节点故障、主从切换时导致分布式锁混乱，可以考虑以下策略：</p>
<ul>
<li><strong>故障转移期间保护锁</strong>：在主节点发生故障、从节点提升为新主节点的过程中，可以设置一个保护期（TTL），使得在这段时间内所有原有的锁自动失效或不再响应客户端的锁操作。这样，即使新主节点允许新的客户端加锁，也不会和旧锁冲突。</li>
<li><strong>锁失效机制</strong>：可在应用层设计，确保在主从切换发生时，通过特殊的机制（比如通过监控或内部逻辑）将旧锁强制失效或提前释放，确保只有一个客户端持有锁。</li>
<li><strong>Redisson 内部改进</strong>：一些场景下，可以通过 Redisson 配置参数来调整看门狗续期和锁失效策略，使其对主从切换更为容错，例如缩短锁的续期周期或者在故障转移后重置锁状态。</li>
</ul>
<p>总结</p>
<ul>
<li><strong>Redisson 的看门狗机制</strong>在正常情况下能自动延长锁的 TTL，确保锁在业务执行过程中不会过期；</li>
<li><strong>问题场景</strong>：由于 Redis 主从复制采用异步机制，当主节点宕机并由从节点提升为新主节点时，可能导致锁状态不一致，从而使得多个客户端误认为自己持有锁；</li>
<li><strong>解决策略</strong>：需要在主从切换期间设计一个保护期，使得旧锁在转移过程中自动失效，或者通过应用逻辑确保在故障转移后锁状态重置，从而避免多个客户端同时持有同一分布式锁。</li>
</ul>
<p>这种设计要求在高可用架构中，除了依赖 Redisson 内部机制外，还需要在系统架构层面做好主从切换、故障检测和锁状态保护，才能确保分布式锁的一致性和正确性。</p>
<ol>
<li></li>
<li><strong>问题背景</strong></li>
</ol>
<p>Redis 主从复制是异步的，若主节点宕机，可能导致以下问题：</p>
<ul>
<li><strong>锁丢失</strong>：锁在主节点写入成功，但未同步到从节点，主备切换后锁信息丢失。</li>
<li><strong>锁冲突</strong>：其他客户端在新主节点重新获取同一把锁，导致多个客户端同时持有锁。</li>
</ul>
<ol start="2">
<li><strong>Redisson 解决方案：联锁（MultiLock）</strong></li>
</ol>
<p>Redisson 提供 <code>RedissonMultiLock</code>（基于 Redis 的 RedLock 算法思想，但实现更简化），通过 <strong>多节点独立加锁</strong> 降低主从锁冲突风险。</p>
<ul>
<li><p><strong>加锁流程</strong>：<br>向多个独立的 Redis 节点（非主从关系）发起加锁请求，当多数节点（<code>N/2 + 1</code>）加锁成功时，视为整体加锁成功。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">RLock</span> lock<span class="number">1</span> = redisson<span class="number">1</span>.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"><span class="attribute">RLock</span> lock<span class="number">2</span> = redisson<span class="number">2</span>.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"><span class="attribute">RLock</span> lock<span class="number">3</span> = redisson<span class="number">3</span>.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"><span class="attribute">RedissonMultiLock</span> multiLock = new RedissonMultiLock(lock<span class="number">1</span>, lock<span class="number">2</span>, lock<span class="number">3</span>);</span><br><span class="line"><span class="attribute">multiLock</span>.lock();  // 在多个独立节点上加锁</span><br></pre></td></tr></table></figure></li>
<li><p><strong>锁续期</strong>：<br>联锁的每个子锁会单独启动看门狗任务续期。</p>
</li>
<li><p><strong>释放锁</strong>：<br>无论是否加锁成功，均向所有节点发起释放锁请求。</p>
</li>
</ul>
<p><strong>设计目标</strong></p>
<ul>
<li><strong>容错性</strong>：允许少数节点故障，只要多数节点存活即可保证锁有效性。</li>
<li><strong>安全性</strong>：即使某个节点主从切换后锁丢失，其他节点仍持有锁，整体锁仍有效。</li>
</ul>
<p><strong>局限性</strong></p>
<ul>
<li><strong>性能开销</strong>：需操作多个节点，网络交互次数增加。</li>
<li><strong>部署成本</strong>：需维护多个独立 Redis 实例（非主从或集群模式）。</li>
<li><strong>非绝对安全</strong>：极端情况下（如多数节点同时崩溃），仍可能发生锁冲突。</li>
</ul>
<h3 id="问：怎么提高缓存命中率？"><a href="#问：怎么提高缓存命中率？" class="headerlink" title="问：怎么提高缓存命中率？"></a>问：怎么提高缓存命中率？</h3><ol>
<li>提前加载。</li>
<li>增加Redis内存空间。</li>
<li>调整缓存的存储类型，使用更优的数据类型。</li>
<li>提高缓存的更新频次。</li>
</ol>
<h3 id="问：如何解决-Redis-的Key冲突问题？并发竞争-Key-问题？"><a href="#问：如何解决-Redis-的Key冲突问题？并发竞争-Key-问题？" class="headerlink" title="问：如何解决 Redis 的Key冲突问题？并发竞争 Key 问题？"></a>问：如何解决 Redis 的Key冲突问题？并发竞争 Key 问题？</h3><p>Key的冲突问题？</p>
<ul>
<li>业务隔离：比如通过业务模块+系统名称+主键。</li>
<li>分布式锁：解决并发竞争Key问题。</li>
</ul>
<p><strong>Redis 并发竞争 Key 问题</strong>：指的是多个客户端在高并发环境下同时对同一个 Key 执行读写操作，可能导致以下问题：</p>
<ol>
<li><strong>数据不一致</strong>：多个客户端并发修改相同的 Key，导致最终存储的值不确定，出现数据覆盖。</li>
<li><strong>超卖/超扣</strong>：常见于库存扣减等场景，在没有正确加锁的情况下，多个客户端同时扣减库存，导致商品被超卖。</li>
<li><strong>脏读/脏写</strong>：由于并发操作，客户端读取到未更新或已过期的数据，导致业务错误。</li>
</ol>
<p><strong>并发竞争 Key 的主要原因</strong></p>
<ol>
<li><strong>高并发环境</strong>：大量客户端同时对 Redis 发起读写请求。</li>
<li><strong>无锁操作</strong>：未使用分布式锁保护关键业务操作。</li>
<li><strong>原子性缺失</strong>：多步操作没有原子性保障，如 <code>GET</code> 后 <code>SET</code>。</li>
<li><strong>缓存不一致</strong>：缓存与数据库的数据不一致。</li>
<li><strong>网络延迟与失败</strong>：客户端重试机制未正确设计。</li>
</ol>
<p><strong>Redis 并发竞争 Key 典型场景</strong></p>
<ol>
<li><strong>电商抢购秒杀</strong>：库存扣减、订单生成。</li>
<li><strong>分布式 ID 生成</strong>：多个客户端请求分布式唯一 ID。</li>
<li><strong>分布式锁竞争</strong>：多节点服务竞争分布式锁。</li>
<li><strong>分布式计数器</strong>：高并发访问计数器，如点击量、访问量统计。</li>
<li><strong>排行榜与计分板</strong>：更新排行榜分数时的并发竞争。</li>
</ol>
<p><strong>示例</strong></p>
<ul>
<li><p><strong>示例 1：库存扣减超卖问题</strong></p>
<p>多个客户端同时执行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stock = Integer.parseInt(redisTemplate.opsForValue().get(<span class="string">&quot;product_stock&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;product_stock&quot;</span>, String.valueOf(stock - <span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;扣减成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题分析：</strong></p>
<ul>
<li>多个客户端在 <code>get(&quot;product_stock&quot;)</code> 后同时获取了相同的库存值。</li>
<li>检查 <code>stock &gt; 0</code> 通过后，同时执行了 <code>set(&quot;product_stock&quot;, stock - 1)</code>，导致库存被重复扣减。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>示例 2：缓存击穿（重建缓存）</strong></p>
<p>假设一个热点 Key 被大量请求，并且该 Key 恰好在某一时刻过期。<br> 多个客户端会同时尝试重建缓存，导致缓存重建多次，出现请求风暴。</p>
</li>
<li><p><strong>示例 3：分布式锁失效问题</strong>Redis 锁如果没有正确设置过期时间，或者 Redis 故障，可能导致分布式锁失效，引发并发竞争。</p>
</li>
</ul>
<p><strong>如何解决 Redis 并发竞争 Key 问题？</strong></p>
<ol>
<li><p><strong>使用分布式锁</strong>：如 Redisson、Lua 脚本实现原子加锁与解锁。</p>
<p>使用 Redis 分布式锁来确保对某个 Key 的操作是原子的，避免多个客户端并发修改同一 Key。</p>
<p><strong>示例：手动实现分布式锁（SET + Lua 脚本）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">boolean</span> isLocked = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lockKey&quot;</span>, <span class="string">&quot;lockValue&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获得锁，处理业务&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁（Lua 脚本原子性）</span></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;</span><br><span class="line">                connection.eval(script.getBytes(), ReturnType.INTEGER, <span class="number">1</span>, <span class="string">&quot;lockKey&quot;</span>.getBytes(), <span class="string">&quot;lockValue&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进：使用 Redisson</strong></p>
<p>推荐使用 Redisson 内置分布式锁，支持自动续租与容错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redissonClient.getLock(<span class="string">&quot;lockKey&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">&quot;获得锁，处理业务&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用 Lua 脚本</strong>：通过 Lua 脚本执行多步骤操作，保证操作的原子性。</p>
<p>Redis 多个命令在事务中可能存在中断风险，使用 Lua 脚本执行多命令操作，确保操作的原子性。</p>
<p><strong>示例：库存扣减（原子操作）</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lua 脚本：原子扣减库存</span></span><br><span class="line"><span class="keyword">local</span> stock = redis.call(<span class="string">&quot;GET&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(stock) &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&quot;DECR&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;fail&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>数据分片与分区</strong>：将热点 Key 拆分为多个子 Key，分散竞争。</p>
<p>将热点 Key 拆分成多个小 Key，分散请求压力，避免竞争：</p>
<p><strong>示例：分片 Key 设计</strong></p>
<ul>
<li><code>user_score_1</code>、<code>user_score_2</code>、…、<code>user_score_n</code></li>
<li>请求时，哈希分片：<code>hash(userId) % N</code></li>
</ul>
</li>
<li><p><strong>热点 Key 预防与缓存策略优化</strong>：如设置合理的缓存过期策略和预加载机制。</p>
<ol>
<li><strong>缓存穿透解决方案</strong>：<ul>
<li>使用布隆过滤器（Bloom Filter）提前过滤无效请求。</li>
</ul>
</li>
<li><strong>缓存雪崩解决方案</strong>：<ul>
<li>设置 Key 的过期时间时加上随机时间，防止大规模 Key 同时失效。</li>
</ul>
</li>
<li><strong>缓存击穿解决方案</strong>：<ul>
<li>使用分布式锁或双重检查机制，避免并发请求同时重建缓存。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>消息队列削峰</strong>：使用消息队列异步处理请求，避免 Redis 直接竞争。对于高并发写操作，可以将请求存入消息队列，后端异步处理，减少对 Redis 的直接竞争。</p>
</li>
<li><p><strong>使用 Redis 事务和乐观锁（CAS）</strong>：如 <code>WATCH</code> 命令，监控 Key 的变化。</p>
<p>Redis 提供 <code>WATCH</code> 命令，可以在事务提交前检查 Key 是否被其他客户端修改。</p>
<p><strong>示例：乐观锁事务操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line">    connection.watch(<span class="string">&quot;balance&quot;</span>.getBytes());</span><br><span class="line">    <span class="keyword">byte</span>[] balance = connection.get(<span class="string">&quot;balance&quot;</span>.getBytes());</span><br><span class="line">    <span class="keyword">int</span> newBalance = Integer.parseInt(<span class="keyword">new</span> String(balance)) - <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (newBalance &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        connection.multi();  <span class="comment">// 开启事务</span></span><br><span class="line">        connection.set(<span class="string">&quot;balance&quot;</span>.getBytes(), String.valueOf(newBalance).getBytes());</span><br><span class="line">        List&lt;Object&gt; exec = connection.exec();  <span class="comment">// 提交事务</span></span><br><span class="line">        <span class="keyword">if</span> (exec == <span class="keyword">null</span> || exec.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务失败，重试...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣款成功，余额：&quot;</span> + newBalance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>解决方案</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>分布式锁（Redisson）</td>
<td>数据唯一性与原子操作控制</td>
<td>简单易用，可靠性高</td>
<td>多线程环境可能死锁</td>
</tr>
<tr>
<td>Lua 脚本</td>
<td>高并发原子操作</td>
<td>原子性强，性能高</td>
<td>学习成本高</td>
</tr>
<tr>
<td>数据分片（Sharding）</td>
<td>热点 Key 拆分与分散压力</td>
<td>扩展性强，性能高</td>
<td>复杂度高</td>
</tr>
<tr>
<td>缓存策略优化</td>
<td>缓存高并发场景</td>
<td>缓解压力，成本低</td>
<td>设计难度较大</td>
</tr>
<tr>
<td>消息队列削峰</td>
<td>高并发写操作削峰</td>
<td>异步化，抗压强</td>
<td>数据时效性延迟</td>
</tr>
<tr>
<td>乐观锁事务（CAS）</td>
<td>更新敏感场景</td>
<td>数据一致性高</td>
<td>容易失败需重试</td>
</tr>
</tbody></table>
<h2 id="Redis常见方案"><a href="#Redis常见方案" class="headerlink" title="Redis常见方案"></a>Redis常见方案</h2><h3 id="问：Redis如何实现限流？"><a href="#问：Redis如何实现限流？" class="headerlink" title="问：Redis如何实现限流？"></a>问：Redis如何实现限流？</h3><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>原理</strong></th>
<th><strong>性能</strong></th>
<th>内存消耗</th>
<th>精度</th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优化技巧</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>固定窗口</strong>（计数器算法）</td>
<td>统计固定时间窗口内的请求总数，超过阈值则拒绝。</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>实现简单，内存消耗低</td>
<td>存在窗口临界突发流量问题</td>
<td>低频限流，对精度要求不高</td>
<td>结合Pipeline批量操作减少网络往返</td>
</tr>
<tr>
<td><strong>滑动窗口</strong></td>
<td>将时间划分为多个小窗口，统计连续滑动窗口内的总请求数。</td>
<td>中</td>
<td>中</td>
<td>高</td>
<td>精度高于固定窗口</td>
<td>内存占用较高</td>
<td>中等精度要求的API限流，API网关</td>
<td>使用ZSET的SCORE存储微秒时间戳提升精度</td>
</tr>
<tr>
<td><strong>漏桶算法</strong></td>
<td>以恒定速率处理请求，桶满则拒绝新请求。</td>
<td>中</td>
<td>低</td>
<td>高</td>
<td>平滑流量，防止突发压力</td>
<td>无法应对突发流量</td>
<td>流量整形，保护下游系统（如短信发送）</td>
<td>预生成令牌减少实时计算开销</td>
</tr>
<tr>
<td><strong>令牌桶算法</strong></td>
<td>以固定速率生成令牌，请求需获取令牌，无令牌则拒绝。</td>
<td>中</td>
<td>低</td>
<td>高</td>
<td>允许突发流量，弹性限流</td>
<td>实现复杂度较高</td>
<td>高并发允许突发的场景（如秒杀）</td>
<td>本地缓存部分令牌减少Redis访问频率</td>
</tr>
</tbody></table>
<h4 id="1-固定窗口计数器（Fixed-Window）"><a href="#1-固定窗口计数器（Fixed-Window）" class="headerlink" title="1. 固定窗口计数器（Fixed Window）"></a>1. 固定窗口计数器（Fixed Window）</h4><p><strong>实现原理</strong>：利用<code>INCR</code>和<code>EXPIRE</code>命令统计时间窗口内的请求总数。  </p>
<ul>
<li>将时间划分为固定窗口（如 1 分钟），每个窗口内允许固定数量的请求。</li>
<li>使用 Redis 的 <code>INCR</code> 和 <code>EXPIRE</code> 命令实现计数和窗口重置。</li>
</ul>
<p><strong>Java代码（Spring Data Redis）</strong>：</p>
<ul>
<li>API 每分钟允许 100 次请求。每个请求调用 <code>allowRequest()</code>，Redis 计数并自动过期。</li>
<li><strong>临界时间问题</strong>：窗口切换时可能出现双倍流量（如 59s 和 1s 的请求合并）。</li>
<li><strong>不精确控制</strong>：无法限制窗口内的请求均匀分布。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedWindowRateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRequests;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> windowSec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedWindowRateLimiter</span><span class="params">(Jedis jedis, String key, <span class="keyword">int</span> maxRequests, <span class="keyword">int</span> windowSec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.maxRequests = maxRequests;</span><br><span class="line">        <span class="keyword">this</span>.windowSec = windowSec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long currentCount = jedis.incr(key);</span><br><span class="line">        <span class="keyword">if</span> (currentCount == <span class="number">1</span>) &#123;</span><br><span class="line">            jedis.expire(key, windowSec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentCount &lt;= maxRequests;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowedFixedWindow</span><span class="params">(String key, <span class="keyword">int</span> limit, <span class="keyword">int</span> windowSec)</span> </span>&#123;</span><br><span class="line">    String redisKey = <span class="string">&quot;rate_limit:fixed:&quot;</span> + key;</span><br><span class="line">    <span class="comment">// 原子操作：计数+设置过期时间</span></span><br><span class="line">    Long count = redisTemplate.execute(</span><br><span class="line">        <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(</span><br><span class="line">            <span class="string">&quot;local current = redis.call(&#x27;incr&#x27;, KEYS[1])\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if current == 1 then\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1])\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;return current&quot;</span>,</span><br><span class="line">            Long.class</span><br><span class="line">        ),</span><br><span class="line">        Collections.singletonList(redisKey),</span><br><span class="line">        String.valueOf(windowSec)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> count != <span class="keyword">null</span> &amp;&amp; count &lt;= limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-滑动窗口（Sliding-Window）"><a href="#2-滑动窗口（Sliding-Window）" class="headerlink" title="2. 滑动窗口（Sliding Window）"></a>2. 滑动窗口（Sliding Window）</h4><p><strong>实现原理</strong>：使用有序集合（ZSET）记录每次请求的时间戳，通过<code>ZREMRANGEBYSCORE</code>清理旧数据并统计窗口内请求数。  </p>
<ul>
<li>记录每个请求的时间戳，统计最近时间窗口内的总请求数。</li>
<li>使用 Redis 的有序集合（ZSet）存储时间戳。</li>
</ul>
<p><strong>Java代码</strong>：</p>
<ul>
<li>用户每秒最多发送 10 条消息。每次发送消息时，清理旧时间戳并统计当前窗口内数量。</li>
<li><strong>内存消耗高</strong>：需存储所有时间戳，高并发时占用内存。</li>
<li><strong>性能开销</strong>：频繁的 ZSet 操作可能影响 Redis 性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlidingWindowRateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRequests;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> windowSec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SlidingWindowRateLimiter</span><span class="params">(Jedis jedis, String key, <span class="keyword">int</span> maxRequests, <span class="keyword">int</span> windowSec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.maxRequests = maxRequests;</span><br><span class="line">        <span class="keyword">this</span>.windowSec = windowSec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">long</span> windowStart = now - windowSec;</span><br><span class="line"></span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        pipeline.multi();</span><br><span class="line">        pipeline.zremrangeByScore(key, <span class="number">0</span>, windowStart);</span><br><span class="line">        pipeline.zadd(key, now, userId + <span class="string">&quot;:&quot;</span> + now); <span class="comment">// 使用唯一标识避免重复</span></span><br><span class="line">        pipeline.zcard(key);</span><br><span class="line">        pipeline.expire(key, windowSec + <span class="number">1</span>);</span><br><span class="line">        Response&lt;Long&gt; count = pipeline.zcard(key);</span><br><span class="line">        pipeline.exec();</span><br><span class="line">        pipeline.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count.get() &lt;= maxRequests;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowedSlidingWindow</span><span class="params">(String key, <span class="keyword">int</span> limit, <span class="keyword">int</span> windowSec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> windowMillis = windowSec * <span class="number">1000L</span>;</span><br><span class="line">    String redisKey = <span class="string">&quot;rate_limit:sliding:&quot;</span> + key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除窗口外的数据</span></span><br><span class="line">    redisTemplate.opsForZSet().removeRangeByScore(redisKey, <span class="number">0</span>, now - windowMillis);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计当前窗口请求数</span></span><br><span class="line">    Long count = redisTemplate.opsForZSet().zCard(redisKey);</span><br><span class="line">    <span class="keyword">if</span> (count != <span class="keyword">null</span> &amp;&amp; count &gt;= limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加当前请求</span></span><br><span class="line">    redisTemplate.opsForZSet().add(redisKey, UUID.randomUUID().toString(), now);</span><br><span class="line">    <span class="comment">// 设置过期时间避免内存泄漏</span></span><br><span class="line">    redisTemplate.expire(redisKey, windowSec + <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-漏桶算法（Leaky-Bucket）"><a href="#3-漏桶算法（Leaky-Bucket）" class="headerlink" title="3. 漏桶算法（Leaky Bucket）"></a>3. 漏桶算法（Leaky Bucket）</h4><p>漏桶算法将请求（或数据包）看作“水滴”，每个请求进入桶中，桶的漏水速度是固定的。每当一个请求进入桶中，如果桶没有满，那么它就会被处理。桶满了，则该请求会被丢弃或拒绝。</p>
<ul>
<li><strong>桶大小</strong>：表示可以存储的请求数量。</li>
<li><strong>漏水速度</strong>：表示请求被处理的速率，通常是一个固定的速率。</li>
</ul>
<p>如果桶已经满了，即已经有足够的请求被放入桶中，那么新到达的请求将被丢弃。</p>
<p>特点：</p>
<ul>
<li><strong>稳定性</strong>：漏桶算法产生一个平稳的请求流量（固定的处理速率），即使有很多请求在短时间内到达，处理速度仍然是恒定的。</li>
<li><strong>丢弃策略</strong>：一旦桶满，新的请求会被丢弃（通常不允许任何超速请求）。</li>
</ul>
<p>优缺点：</p>
<ul>
<li><strong>优点</strong>：算法简单且直观。能够有效防止瞬时流量的冲击，保证请求以恒定速率处理。</li>
<li><strong>缺点</strong>：无法处理突发流量。它对流量的波动非常敏感，当突发请求超出桶的容量时，所有的请求都会被丢弃，甚至是合理的请求。</li>
</ul>
<p>应用场景：</p>
<p>漏桶算法适用于那些需要平滑处理流量的场景，例如流量整形或网络带宽控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakyBucketRateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> leakRate; <span class="comment">// 漏出速率（请求/秒）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeakyBucketRateLimiter</span><span class="params">(Jedis jedis, String key, <span class="keyword">int</span> capacity, <span class="keyword">double</span> leakRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.leakRate = leakRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        String luaScript =</span><br><span class="line">            <span class="string">&quot;local key = KEYS[1] &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local now = tonumber(ARGV[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local capacity = tonumber(ARGV[2]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local leakRate = tonumber(ARGV[3]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local lastTime = tonumber(redis.call(&#x27;get&#x27;, key) or 0) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local water = math.max(0, capacity - (now - lastTime) * leakRate) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;if water &lt; capacity then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(&#x27;set&#x27;, key, now, &#x27;PX&#x27;, 10000) &quot;</span> + <span class="comment">// 设置过期时间</span></span><br><span class="line">            <span class="string">&quot;   return 1 &quot;</span> + <span class="comment">// 允许请求</span></span><br><span class="line">            <span class="string">&quot;else &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 0 &quot;</span> + <span class="comment">// 拒绝请求</span></span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        Object result = jedis.eval(luaScript, <span class="number">1</span>, key, String.valueOf(now), String.valueOf(capacity), String.valueOf(leakRate));</span><br><span class="line">        <span class="keyword">return</span> (Long) result == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Lua脚本（原子操作）</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])  <span class="comment">-- 桶容量</span></span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])     <span class="comment">-- 漏水速率（单位：请求/秒）</span></span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])      <span class="comment">-- 当前时间戳（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> bucket = redis.call(<span class="string">&#x27;HMGET&#x27;</span>, key, <span class="string">&#x27;water&#x27;</span>, <span class="string">&#x27;last_time&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> water = <span class="built_in">tonumber</span>(bucket[<span class="number">1</span>]) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> last_time = <span class="built_in">tonumber</span>(bucket[<span class="number">2</span>]) <span class="keyword">or</span> now</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算漏水量：时间差 * 速率</span></span><br><span class="line"><span class="keyword">local</span> leaked = <span class="built_in">math</span>.<span class="built_in">floor</span>((now - last_time) * rate)</span><br><span class="line">water = <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">0</span>, water - leaked)</span><br><span class="line">last_time = now</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断是否允许新请求</span></span><br><span class="line"><span class="keyword">local</span> allowed = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> water + <span class="number">1</span> &lt;= capacity <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;HMSET&#x27;</span>, key, <span class="string">&#x27;water&#x27;</span>, water + <span class="number">1</span>, <span class="string">&#x27;last_time&#x27;</span>, last_time)</span><br><span class="line">    allowed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置过期时间（避免长期不用的key占用内存）</span></span><br><span class="line">redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, <span class="built_in">math</span>.<span class="built_in">ceil</span>(capacity / rate) + <span class="number">10</span>)</span><br><span class="line"><span class="keyword">return</span> allowed</span><br></pre></td></tr></table></figure>

<p><strong>Java调用代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowedLeakyBucket</span><span class="params">(String key, <span class="keyword">int</span> capacity, <span class="keyword">int</span> ratePerSec)</span> </span>&#123;</span><br><span class="line">    String script = <span class="string">&quot;...&quot;</span>; <span class="comment">// 上述Lua脚本内容</span></span><br><span class="line">    <span class="keyword">long</span> now = Instant.now().getEpochSecond();</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(redisTemplate.execute(</span><br><span class="line">        <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(script, Boolean.class),</span><br><span class="line">        Collections.singletonList(<span class="string">&quot;rate_limit:leaky:&quot;</span> + key),</span><br><span class="line">        String.valueOf(capacity),</span><br><span class="line">        String.valueOf(ratePerSec),</span><br><span class="line">        String.valueOf(now)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-令牌桶算法（Token-Bucket）"><a href="#4-令牌桶算法（Token-Bucket）" class="headerlink" title="4. 令牌桶算法（Token Bucket）"></a>4. 令牌桶算法（Token Bucket）</h4><p>令牌桶算法与漏桶算法的不同之处在于，它允许在一定时间内积累请求，但仍然会以一个固定的速率处理请求。令牌桶由一个桶和令牌组成，桶中有令牌，处理请求需要从桶中获取令牌。</p>
<ul>
<li><strong>桶大小</strong>：表示可以存储的令牌数量，决定了突发流量的上限。</li>
<li><strong>令牌生成速率</strong>：表示每秒生成一定数量的令牌。</li>
<li><strong>请求处理</strong>：每个请求需要消耗一个令牌，如果桶中没有令牌，请求将被拒绝。如果桶中有令牌，则请求可以继续处理。</li>
</ul>
<p>特点：</p>
<ul>
<li><strong>灵活性</strong>：令牌桶算法允许突发流量的出现，桶中的令牌可以积累，允许一定数量的突发请求。系统能够在流量短时间内增大后，逐渐恢复到常态。</li>
<li><strong>突发流量控制</strong>：突发请求可以迅速被处理，前提是令牌桶中有足够的令牌。并且，在没有令牌的情况下，新请求会被阻塞或丢弃。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：<ul>
<li>令牌桶能够平滑处理突发流量，并能在突发流量过后的时间里逐渐恢复。</li>
<li>允许一定的请求积压，灵活性更强。</li>
</ul>
</li>
<li>缺点：<ul>
<li>不像漏桶那样严格限制速率，可能会造成流量的过多积累，导致短时间内的处理压力。</li>
</ul>
</li>
</ul>
<p>应用场景：</p>
<p>令牌桶算法更适用于那些需要处理突发请求的场景，比如网络流量控制、API 接口限流等。</p>
<p><strong>缺点</strong></p>
<ul>
<li><strong>实现复杂</strong>：需维护令牌数量和时间戳。</li>
<li><strong>依赖时钟同步</strong>：分布式环境下需注意时间一致性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucketRateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> refillRate; <span class="comment">// 令牌填充速率（令牌/秒）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TokenBucketRateLimiter</span><span class="params">(Jedis jedis, String key, <span class="keyword">int</span> capacity, <span class="keyword">double</span> refillRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.refillRate = refillRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">(<span class="keyword">int</span> tokensRequested)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        String luaScript =</span><br><span class="line">            <span class="string">&quot;local key = KEYS[1] &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local now = tonumber(ARGV[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local capacity = tonumber(ARGV[2]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local refillRate = tonumber(ARGV[3]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local tokensRequested = tonumber(ARGV[4]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local data = redis.call(&#x27;hmget&#x27;, key, &#x27;tokens&#x27;, &#x27;lastRefillTime&#x27;) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local tokens = tonumber(data[1]) or capacity &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local lastRefillTime = tonumber(data[2]) or now &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local delta = math.max(0, now - lastRefillTime) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;local newTokens = delta * refillRate &quot;</span> +</span><br><span class="line">            <span class="string">&quot;tokens = math.min(capacity, tokens + newTokens) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;if tokens &gt;= tokensRequested then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   tokens = tokens - tokensRequested &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(&#x27;hmset&#x27;, key, &#x27;tokens&#x27;, tokens, &#x27;lastRefillTime&#x27;, now) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(&#x27;expire&#x27;, key, 10) &quot;</span> + <span class="comment">// 设置过期时间</span></span><br><span class="line">            <span class="string">&quot;   return 1 &quot;</span> +</span><br><span class="line">            <span class="string">&quot;else &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        Object result = jedis.eval(luaScript, <span class="number">1</span>, key, String.valueOf(now), String.valueOf(capacity), String.valueOf(refillRate), String.valueOf(tokensRequested));</span><br><span class="line">        <span class="keyword">return</span> (Long) result == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Lua脚本实现</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])  <span class="comment">-- 桶容量</span></span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])     <span class="comment">-- 令牌生成速率（单位：令牌/秒）</span></span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])      <span class="comment">-- 当前时间戳（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> bucket = redis.call(<span class="string">&#x27;HMGET&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>, <span class="string">&#x27;last_time&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> tokens = <span class="built_in">tonumber</span>(bucket[<span class="number">1</span>]) <span class="keyword">or</span> capacity</span><br><span class="line"><span class="keyword">local</span> last_time = <span class="built_in">tonumber</span>(bucket[<span class="number">2</span>]) <span class="keyword">or</span> now</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算生成的令牌数：时间差 * 速率</span></span><br><span class="line"><span class="keyword">local</span> generated = <span class="built_in">math</span>.<span class="built_in">floor</span>((now - last_time) * rate)</span><br><span class="line">tokens = <span class="built_in">math</span>.<span class="built_in">min</span>(capacity, tokens + generated)</span><br><span class="line">last_time = now</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断是否允许请求（消耗1个令牌）</span></span><br><span class="line"><span class="keyword">local</span> allowed = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> tokens &gt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    tokens = tokens - <span class="number">1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;HMSET&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>, tokens, <span class="string">&#x27;last_time&#x27;</span>, last_time)</span><br><span class="line">    allowed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置过期时间</span></span><br><span class="line">redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, <span class="built_in">math</span>.<span class="built_in">ceil</span>(capacity / rate) + <span class="number">10</span>)</span><br><span class="line"><span class="keyword">return</span> allowed</span><br></pre></td></tr></table></figure>



<p>生产环境注意事项</p>
<ol>
<li><strong>时钟同步</strong>：使用Redis的<code>TIME</code>命令获取时间，避免服务器间时钟差异。  </li>
<li><strong>集群模式</strong>：在Redis Cluster中，需确保限流Key通过<code>&#123;&#125;</code>强制路由到同一节点（如<code>rate_limit:&#123;user123&#125;</code>）。  </li>
<li><strong>限流维度</strong>：按用户ID、IP、接口等多维度设计Key（如<code>rate_limit:api_login:ip_192.168.1.1</code>）。  </li>
<li><strong>降级策略</strong>：限流触发后返回特制响应（如HTTP 429），并记录日志供后续分析。  </li>
</ol>
<p>完整示例：Spring AOP + Redis限流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(rateLimit)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint, RateLimit rateLimit)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String key = rateLimit.key();</span><br><span class="line">        <span class="keyword">int</span> limit = rateLimit.limit();</span><br><span class="line">        <span class="keyword">int</span> window = rateLimit.window();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!isAllowedSlidingWindow(key, limit, window)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RateLimitExceededException(<span class="string">&quot;请求过于频繁，请稍后再试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAllowedSlidingWindow</span><span class="params">(String key, <span class="keyword">int</span> limit, <span class="keyword">int</span> windowSec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 滑动窗口实现代码（见上文）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用注解控制接口限流</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@RateLimit(key = &quot;api_index&quot;, limit = 100, window = 60)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>通过以上方案，可灵活应对不同场景的限流需求，结合Redis的高性能与原子性操作，构建高可靠的分布式限流系统。</p>
<h2 id="Redis常见问题"><a href="#Redis常见问题" class="headerlink" title="Redis常见问题"></a>Redis常见问题</h2><h3 id="问：Redis常见性能问题和解决方案？"><a href="#问：Redis常见性能问题和解决方案？" class="headerlink" title="问：Redis常见性能问题和解决方案？"></a>问：Redis常见性能问题和解决方案？</h3><ol>
<li>持久化：早期只支持全量复制，后面又支持了部分复制。主节点不做持久化，从节点来做持久化。一般写操作在主节点进行。若是数据比较重要，开启了AOF持久化，策略为每秒同步一次。为了确保主从复制的流畅，一般会让主从服务器在同一个局域网，避免网路堵塞。</li>
<li>尽量避免主节点压力很大，而增加从库数量，会让主库压力更大。<ul>
<li>增加从库数量虽然能提高数据冗余和读取能力，但主节点的写入负载并不会因为从库增多而降低，反而需要额外的网络带宽和 CPU 资源来同步数据到更多的从库。</li>
</ul>
</li>
<li>主从尽量不要采用网状结构，使用线性结构。主-&gt;从-&gt;从。对主节点的压力小。</li>
</ol>
<h3 id="问：缓存是如何淘汰的？Redis有哪些内存淘汰策略？"><a href="#问：缓存是如何淘汰的？Redis有哪些内存淘汰策略？" class="headerlink" title="问：缓存是如何淘汰的？Redis有哪些内存淘汰策略？"></a>问：缓存是如何淘汰的？Redis有哪些内存淘汰策略？</h3><p>过期Key删除策略针对设置了过期时间的Key，而内存淘汰策略则针对当前运行内存超过Redis设置的最大内存。</p>
<h4 id="淘汰策略触发条件"><a href="#淘汰策略触发条件" class="headerlink" title="淘汰策略触发条件"></a>淘汰策略触发条件</h4><ul>
<li>当Redis内存使用量达到 <code>maxmemory &lt;bytes&gt;</code> 配置阈值时，所有新增数据的写操作将触发淘汰机制，根据预设策略释放内存空间。若未配置策略或选择<code>noeviction</code>，写操作将直接报错。</li>
<li>在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。</li>
<li>在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。</li>
</ul>
<h4 id="8种淘汰策略详解"><a href="#8种淘汰策略详解" class="headerlink" title="8种淘汰策略详解"></a>8种淘汰策略详解</h4><table>
<thead>
<tr>
<th><strong>策略名称</strong></th>
<th><strong>作用范围</strong></th>
<th><strong>淘汰规则</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>noeviction</strong></td>
<td>不淘汰</td>
<td>拒绝所有写操作，仅允许删除和读操作</td>
<td>金融订单、配置数据等不可丢失场景</td>
</tr>
<tr>
<td><strong>allkeys-lru</strong></td>
<td>全部Key</td>
<td>淘汰<strong>最近最少访问</strong>的Key（近似LRU算法）</td>
<td>存在明显热点数据，需保留高频访问内容</td>
</tr>
<tr>
<td><strong>allkeys-lfu</strong></td>
<td>全部Key</td>
<td>淘汰<strong>访问频率最低</strong>的Key（Redis 4.0+支持）</td>
<td>访问模式波动大，需识别长期冷门数据</td>
</tr>
<tr>
<td><strong>volatile-lru</strong></td>
<td>带过期时间的Key</td>
<td>在过期Key中淘汰最近最少访问的</td>
<td>混合持久化与缓存数据，需保护持久化Key</td>
</tr>
<tr>
<td><strong>volatile-lfu</strong></td>
<td>带过期时间的Key</td>
<td>在过期Key中淘汰访问频率最低的</td>
<td>短期缓存场景，需自动清理低频过期数据</td>
</tr>
<tr>
<td><strong>allkeys-random</strong></td>
<td>全部Key</td>
<td>随机淘汰任意Key</td>
<td>数据访问无规律，内存压力需快速释放</td>
</tr>
<tr>
<td><strong>volatile-random</strong></td>
<td>带过期时间的Key</td>
<td>随机淘汰过期Key</td>
<td>过期Key数量多，且淘汰顺序无关紧要</td>
</tr>
<tr>
<td><strong>volatile-ttl</strong></td>
<td>带过期时间的Key</td>
<td>优先淘汰<strong>剩余存活时间最短</strong>的Key</td>
<td>短期缓存（如验证码），依赖TTL自动失效</td>
</tr>
</tbody></table>
<p>当触发淘汰时，Redis 会按照当前配置的策略，从候选集合中选取一个或多个键删除，以便为新数据腾出足够的内存。</p>
<ul>
<li>对于 LRU 和 LFU（Redis 4.0 以后支持 LFU 淘汰模式）的策略，Redis 并不会精确记录每个键的访问顺序或频次，而是通过采样算法（例如随机抽取多个键，选取其中最不活跃的一个）来近似实现，既能保持 O(log⁡N) 的时间复杂度，也能减少开销。</li>
<li>随机淘汰（random）则直接随机选取键进行删除；</li>
<li>volatile-ttl 则会选择那些剩余 TTL 最短的键。</li>
</ul>
<h4 id="核心算法原理与优化"><a href="#核心算法原理与优化" class="headerlink" title="核心算法原理与优化"></a>核心算法原理与优化</h4><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<ul>
<li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li>
</ul>
<p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p>
<p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p>
<p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用</strong>，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p>
<p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 24 bits，用于记录对象的访问信息</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">24</span>;  </span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/lru%E5%AD%97%E6%AE%B5.png" alt="img"></p>
<ul>
<li>ldt 是用来记录 key 的访问时间戳；</li>
<li>logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。</li>
</ul>
<p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 <strong>logc 会随时间推移而衰减的</strong>。</p>
<p>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p>
<p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p>
<p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p>
<ol>
<li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li>
<li>然后，再按照一定概率增加 logc 的值</li>
</ol>
<p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</p>
<ul>
<li><code>lfu-decay-time</code> 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，lfu-decay-time 值越大，衰减越慢；</li>
<li><code>lfu-log-factor</code> 用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。</li>
</ul>
<p><strong>1. LRU（最近最少使用）</strong></p>
<ul>
<li><strong>传统实现</strong>：维护链表，移动访问节点至头部，淘汰尾部节点。</li>
<li><strong>Redis优化</strong>：采用<strong>概率性LRU</strong>，随机采样5个Key，淘汰最久未访问的。</li>
<li><strong>优势</strong>：内存开销从O(n)降至O(1)，性能稳定。</li>
<li><strong>缺陷</strong>：周期性批量操作可能导致热点数据误删。</li>
</ul>
<p><strong>2. LFU（最不经常使用）</strong></p>
<ul>
<li><strong>Redis实现</strong>：每个Key记录访问计数器，随时间衰减计数器值。</li>
<li><strong>淘汰逻辑</strong>：优先淘汰计数器值最小的Key。</li>
<li><strong>优势</strong>：更好应对突发流量，识别长期冷门数据。</li>
<li><strong>配置项</strong>：<code>lfu-log-factor</code>（计数器增长速率）、<code>lfu-decay-time</code>（衰减周期）。</li>
</ul>
<p><strong>3. TTL淘汰</strong></p>
<ul>
<li><strong>逻辑</strong>：仅针对设置过期时间的Key，按剩余时间升序淘汰。</li>
<li><strong>陷阱</strong>：若大量Key同时过期，可能引发缓存雪崩，需搭配随机过期时间使用。</li>
</ul>
<h4 id="策略选型指南"><a href="#策略选型指南" class="headerlink" title="策略选型指南"></a>策略选型指南</h4><table>
<thead>
<tr>
<th><strong>场景特征</strong></th>
<th><strong>推荐策略</strong></th>
<th><strong>原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据不可丢失</td>
<td>noeviction</td>
<td>避免业务中断，依赖外部扩容或清理机制</td>
</tr>
<tr>
<td>存在明显热点数据</td>
<td>allkeys-lru</td>
<td>保留高频访问数据，提升缓存命中率</td>
</tr>
<tr>
<td>访问分布均匀，无规律</td>
<td>allkeys-random</td>
<td>快速释放内存，避免算法开销</td>
</tr>
<tr>
<td>混合持久化与缓存数据</td>
<td>volatile-lru</td>
<td>保护持久化Key，仅淘汰缓存类数据</td>
</tr>
<tr>
<td>短期缓存（如会话数据）</td>
<td>volatile-ttl</td>
<td>自动清理过期数据，减少手动维护成本</td>
</tr>
<tr>
<td>需要识别长期冷数据</td>
<td>allkeys-lfu</td>
<td>精确捕获低频率访问Key，优化内存利用率</td>
</tr>
</tbody></table>
<h4 id="配置与监控"><a href="#配置与监控" class="headerlink" title="配置与监控"></a>配置与监控</h4><p>设置内存淘汰策略有两种方法：</p>
<ul>
<li>方式一：通过“<code>config set maxmemory-policy &lt;策略&gt;</code>”命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li>
<li>方式二：通过修改 Redis 配置文件修改，设置“<code>maxmemory-policy &lt;策略&gt;</code>”，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</li>
</ul>
<p><strong>1. 设置内存阈值与策略</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置最大内存为2GB</span></span><br><span class="line">CONFIG SET maxmemory 2gb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用LFU策略淘汰所有Key</span></span><br><span class="line">CONFIG SET maxmemory-policy allkeys-lfu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前内存策略</span></span><br><span class="line">CONFIG GET maxmemory-policy</span><br></pre></td></tr></table></figure>

<p><strong>2. 关键监控指标</strong></p>
<ul>
<li><strong>内存使用量</strong>：<code>used_memory</code>、<code>maxmemory</code></li>
<li><strong>淘汰Key数量</strong>：<code>evicted_keys</code></li>
<li><strong>缓存命中率</strong>：通过<code>keyspace_hits</code>和<code>keyspace_misses</code>计算</li>
<li><strong>LFU计数器分布</strong>：使用<code>redis-cli --hotkeys</code>识别低频Key</li>
</ul>
<p><strong>3. 调优建议</strong></p>
<ul>
<li><strong>预防雪崩</strong>：为过期时间添加随机值，避免集中失效。</li>
<li><strong>容量规划</strong>：预留20%内存缓冲，避免频繁触发淘汰。</li>
<li><strong>混合存储</strong>：对持久化数据关闭淘汰（<code>volatile-*</code>策略），对缓存数据启用淘汰。</li>
</ul>
<h4 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h4><p><strong>1. 缓存污染（大量冷数据挤占热点）</strong></p>
<ul>
<li><strong>现象</strong>：批量读取历史数据导致热点数据被LRU淘汰。</li>
<li><strong>方案</strong>：切换为LFU策略，或使用<code>volatile-*</code>限定淘汰范围。</li>
</ul>
<p><strong>2. 淘汰性能瓶颈</strong></p>
<ul>
<li><strong>现象</strong>：内存触顶后，写入延迟陡增。</li>
<li><strong>方案</strong>：升级至Redis 4.0+使用LFU算法，或扩容集群分片。</li>
</ul>
<p><strong>3. 策略误配置导致数据丢失</strong></p>
<ul>
<li><strong>现象</strong>：误设<code>allkeys-*</code>策略删除持久化Key。</li>
<li><strong>方案</strong>：通过<code>CONFIG REWRITE</code>持久化配置，区分业务Key类型。</li>
</ul>
<h3 id="问：Redis过期key删除策略？以及惰性删除？"><a href="#问：Redis过期key删除策略？以及惰性删除？" class="headerlink" title="问：Redis过期key删除策略？以及惰性删除？"></a>问：Redis过期key删除策略？以及惰性删除？</h3><p>Redis所有数据结构都可以设置过期时间，一旦过期就会自动删除。</p>
<ul>
<li>会不会同一时间过多的Key过期，导致忙不过来？</li>
<li>Redis单线程，删除时间也占用线程，会不会删除过于频繁导致线上的读写指令出现卡顿？<ul>
<li>会，扫描过期字典会循环直到过期占比稀疏，而且内存管理器要频繁回收内存页，造成CPU消耗。</li>
<li>所有要尽量避免大批量Key同时到期，给定随机范围。</li>
</ul>
</li>
<li></li>
</ul>
<p>过期的Key集合</p>
<ul>
<li>Redis将每个设置了过期时间的Key放到一个独立的字典中，定时遍历该字典来删除到期的Key。</li>
<li>除了定时遍历外，还会通过惰性删除来删除过期Key。</li>
<li>即集中处理+零散处理。</li>
</ul>
<h4 id="Redis设置过期时间"><a href="#Redis设置过期时间" class="headerlink" title="Redis设置过期时间"></a>Redis设置过期时间</h4><p>设置过期时间和永久有效：EXPIRE 和 PERSIST 命令。</p>
<ul>
<li><code>expire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 秒后过期，比如 expire key 100 表示设置 key 在 100 秒后过期；</li>
<li><code>pexpire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 毫秒后过期，比如 pexpire key2 100000 表示设置 key2 在 100000 毫秒（100 秒）后过期。</li>
<li><code>expireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到秒）之后过期，比如 expireat key3 1655654400 表示 key3 在时间戳 1655654400 后过期（精确到秒）；</li>
<li><code>pexpireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到毫秒）之后过期，比如 pexpireat key4 1655654400000 表示 key4 在时间戳 1655654400000 后过期（精确到毫秒）</li>
</ul>
<p>当然，在设置字符串时，也可以同时对 key 设置过期时间，共有 3 种命令：</p>
<ul>
<li><code>set &lt;key&gt; &lt;value&gt; ex &lt;n&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到秒）；</li>
<li><code>set &lt;key&gt; &lt;value&gt; px &lt;n&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到毫秒）；</li>
<li><code>setex &lt;key&gt; &lt;n&gt; &lt;valule&gt;</code> ：设置键值对的时候，同时指定过期时间（精确到秒）。</li>
</ul>
<p>查看某个 key 剩余的存活时间，可以使用 <code>TTL &lt;key&gt;</code> 命令。取消 key 的过期时间，则可以使用 <code>PERSIST &lt;key&gt;</code> 命令。</p>
<h4 id="如何判定-key-已过期了？"><a href="#如何判定-key-已过期了？" class="headerlink" title="如何判定 key 已过期了？"></a>如何判定 key 已过期了？</h4><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。字典实际上是哈希表，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p>
<ul>
<li>如果不在，则正常读取键值；</li>
<li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li>
</ul>
<h4 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h4><p>Redis 中的键可以设置过期时间，超时的键会被删除。为保证内存高效利用，Redis 提供了三种过期键删除策略：</p>
<ol>
<li>定时删除（主动删除）不常用<ul>
<li><strong>机制：</strong>在设置键的过期时间时，Redis 内部会创建一个定时器，键到期时自动删除。</li>
<li><strong>优点：</strong>内存释放及时，避免内存占用。定时删除对内存是最友好的。</li>
<li><strong>缺点：</strong>高并发场景下频繁检查过期键，可能影响 Redis 性能。在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</li>
</ul>
</li>
<li>惰性删除（被动删除）<ul>
<li><strong>机制：</strong>每次访问键时，Redis 会检查该键是否过期，过期则删除。</li>
<li><strong>优点：</strong>不主动扫描，降低系统性能开销。惰性删除策略对 CPU 时间最友好。</li>
<li><strong>缺点：</strong>如果过期键长期未被访问，可能导致大量内存占用，产生 <strong>内存泄漏</strong> 风险。惰性删除策略对内存不友好。</li>
</ul>
</li>
<li>定期删除（主动删除）<ul>
<li><strong>机制：</strong>Redis 定期运行后台任务，扫描一定数量的键，删除其中的过期键。不会扫描字典中所有的Key，而是采用了贪心策略：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong>如果删除占比超过1/4，就再重复选择一定数量的Key。</li>
<li><strong>配置参数：</strong><ul>
<li><strong><code>hz</code> 参数：</strong> Redis 配置文件中的 <code>hz</code> 值（默认 10）控制检查频率。即每秒10次过期扫描。</li>
<li><strong><code>active-expire-cycle-max-burst</code>：</strong> 限制一次扫描的最大键数。</li>
</ul>
</li>
<li><strong>优点：</strong>在后台异步执行，降低实时性要求。通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li>
<li><strong>缺点：</strong>扫描频率与负载成正比，可能漏掉一些过期键。内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li>
</ul>
</li>
</ol>
<h4 id="实际Redis采用的删除策略"><a href="#实际Redis采用的删除策略" class="headerlink" title="实际Redis采用的删除策略"></a>实际Redis采用的删除策略</h4><p><strong>Redis 删除策略的实际应用与优化</strong></p>
<ul>
<li><strong>策略组合：</strong>Redis 同时使用 <strong>惰性删除</strong> 和 <strong>定期删除</strong>，并不使用性能开销较大的 <strong>定时删除</strong>。</li>
</ul>
<ul>
<li><strong>优化策略：</strong><ol>
<li><strong>设置合理的过期时间：</strong> 确保缓存数据不过期太快或积压太久。</li>
<li><strong>分批设置过期时间：</strong> 避免大量键同时过期引发缓存雪崩。</li>
<li><strong>监控与诊断：</strong> 使用 <code>INFO STATS</code> 查看 <code>expired_keys</code> 指标，监控过期键删除情况。</li>
</ol>
</li>
</ul>
<p><strong>常用命令示例</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置键的过期时间</span></span><br><span class="line">SET mykey &quot;value&quot; EX 60        # 60 秒后过期</span><br><span class="line">EXPIRE mykey 120               # 重设过期时间为 120 秒</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看键的过期时间</span></span><br><span class="line">TTL mykey                     # 查看剩余时间（秒）</span><br><span class="line">PTTL mykey                    # 查看剩余时间（毫秒）</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除键</span></span><br><span class="line">DEL mykey                     # 手动删除键</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Redis 过期统计信息</span></span><br><span class="line">INFO STATS</span><br></pre></td></tr></table></figure>



<h4 id="从库的过期策略"><a href="#从库的过期策略" class="headerlink" title="从库的过期策略"></a>从库的过期策略</h4><ul>
<li>Redis从库不会进行定期扫描，而是被动的。主库的Key到期时，会在AOF文件中添加一条del指令，同步到从库后删除过期的key。</li>
<li>因为数据同步是异步进行的，所以若del指令没有及时到从库执行的话，就会主从不一致。</li>
</ul>
<h3 id="问：Redis-回收进程如何工作的？"><a href="#问：Redis-回收进程如何工作的？" class="headerlink" title="问：Redis 回收进程如何工作的？"></a>问：Redis 回收进程如何工作的？</h3><p>Redis 检查内存使用情况，如果大于 maxmemory 的限制,  则根据设定好的策略进行回收。一个新的命令被执行，等等。所以不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<ul>
<li>Redis 回收进程的主要目标是管理内存，防止内存耗尽。当内存达到配置的 <code>maxmemory</code> 限制时，Redis 会启动内存回收机制，根据配置的淘汰策略删除部分键。</li>
</ul>
<p><strong>Redis 回收内存的触发条件</strong></p>
<ol>
<li><p>写入新数据时触发：</p>
<ul>
<li>当 Redis 内存使用量达到 <code>maxmemory</code> 限制时，写操作会触发内存回收。</li>
</ul>
</li>
<li><p>Redis 淘汰策略启用：</p>
<ul>
<li>Redis 根据 <code>maxmemory-policy</code> 参数决定如何回收键。</li>
</ul>
</li>
</ol>
<p><strong>Redis 回收内存的执行步骤</strong></p>
<ol>
<li><strong>命中检测：</strong><ul>
<li>Redis 在每次写操作时检查是否超过内存限制。</li>
</ul>
</li>
<li><strong>键筛选：</strong><ul>
<li>根据淘汰策略，选择合适的键进行删除。</li>
</ul>
</li>
<li><strong>删除键：</strong><ul>
<li>删除符合策略的键，释放内存。</li>
</ul>
</li>
<li><strong>重试写入：</strong><ul>
<li>在内存释放后，重新尝试写入新数据。</li>
</ul>
</li>
</ol>
<h3 id="问：热数据与冷数据？如何利用Redis处理热点数据？进行过缓存预热吗？"><a href="#问：热数据与冷数据？如何利用Redis处理热点数据？进行过缓存预热吗？" class="headerlink" title="问：热数据与冷数据？如何利用Redis处理热点数据？进行过缓存预热吗？"></a>问：热数据与冷数据？如何利用Redis处理热点数据？进行过缓存预热吗？</h3><p>进行过缓存预热吗？缓存预热容易出现缓存击穿/雪崩。</p>
<ul>
<li><p>什么是热数据和冷数据？</p>
<ul>
<li>热数据：在较短时间内频繁访问、读写请求密集的数据。数据更新之前最少读两次。</li>
<li>冷数据：指那些访问频率低、不常更新但需要长期保存的数据。数据更新之前没被读过，或是只被读过一次。</li>
</ul>
</li>
<li><p>如何利用Redis处理热点数据？</p>
<p><strong>1. 提前缓存热点数据</strong></p>
<ul>
<li><strong>预加载数据：</strong> 在 Redis 中预热热点数据，避免高并发场景下数据库负载过重。</li>
<li><strong>示例：</strong> 项目启动时批量加载热门商品、文章等。</li>
</ul>
<p><strong>2. 利用 Redis 数据结构</strong></p>
<ul>
<li><strong>Sorted Set (ZSet)：</strong> 排序存储，按访问次数统计热门数据。</li>
<li><strong>HyperLogLog：</strong> 近似去重计数，快速统计数据访问量。</li>
</ul>
<p><strong>3. 热点缓存分片（拆分）</strong></p>
<ul>
<li><strong>缓存分片：</strong> 针对热点 Key，手动将其拆分为多个 Key，分散压力。</li>
<li><strong>示例：</strong> <code>hotkey_1</code>, <code>hotkey_2</code> 等。</li>
</ul>
<p><strong>4. 利用 Redis 分布式锁</strong></p>
<ul>
<li><strong>互斥锁：</strong> 热点数据更新时加锁，防止缓存击穿。</li>
<li><strong>示例：</strong> 使用 <code>SET key value NX EX</code> 实现分布式锁。</li>
</ul>
<p><strong>5. 缓存雪崩和击穿保护</strong></p>
<ul>
<li><strong>缓存雪崩：</strong> 设置缓存过期时间的随机值，避免批量过期。</li>
<li><strong>缓存击穿：</strong> 对热门数据设置较长的过期时间，防止数据库超负载。</li>
</ul>
<p><strong>6. 使用多级缓存架构</strong></p>
<ul>
<li><strong>内存 + Redis + 数据库：</strong> 在内存中缓存最常用数据，Redis 存储次常用数据，数据库存储冷数据。</li>
</ul>
<p><strong>设置合理的过期时间和内存淘汰策略</strong></p>
<ul>
<li>针对热点数据，可以设置较长或永不过期的 TTL，以避免频繁过期导致缓存重建（缓存击穿）。</li>
<li>同时，通过配置 Redis 的内存淘汰策略（如 <code>allkeys-lru</code>、<code>volatile-lru</code> 或 LFU 策略），确保内存有限时，保留访问频率最高的数据，淘汰冷数据。</li>
</ul>
<p><strong>分布式锁防止缓存击穿</strong></p>
<ul>
<li>当热点数据失效时，为防止大量并发请求直接访问数据库，可以在缓存未命中时利用 Redis 的分布式锁（如使用 SETNX+EX）确保只有一个线程或实例负责重建缓存，其它请求等待重建完成后再读取缓存数据。</li>
</ul>
<p><strong>缓存预热和本地缓存</strong></p>
<ul>
<li><strong>缓存预热：</strong> 在系统启动或低峰期时提前加载热点数据到 Redis 中，减少冷启动时数据库的压力。</li>
<li><strong>本地缓存：</strong> 将热点数据加载到应用服务器的本地缓存（例如JVM内存、Ehcache），从而分散 Redis 集群的压力，避免单个 Redis 节点成为瓶颈。</li>
</ul>
<p><strong>分布式部署和数据分片</strong></p>
<ul>
<li>通过搭建 Redis 集群，将数据分布到多个节点上，避免某个节点因热点数据请求过多而过载。</li>
<li>同时，在应用层面可以对热点数据进行备份，即在多个节点上保存一份副本，从而实现负载均衡。</li>
</ul>
<p>2</p>
</li>
<li></li>
</ul>
<h3 id="问：Redis怎么解决热点Key问题？hot-key出现造成集群访问量倾斜解决办法？"><a href="#问：Redis怎么解决热点Key问题？hot-key出现造成集群访问量倾斜解决办法？" class="headerlink" title="问：Redis怎么解决热点Key问题？hot key出现造成集群访问量倾斜解决办法？"></a>问：Redis怎么解决热点Key问题？hot key出现造成集群访问量倾斜解决办法？</h3><ul>
<li>什么是热点Key问题？会导致什么后果？<ul>
<li>热点Key问题指的是某个或少数几个key在短时间内被大量并发访问，导致单个Redis实例或节点承受过高压力，进而出现响应延迟增大、内存或CPU资源耗尽，甚至可能导致节点宕机，从而影响整个系统的稳定性和可用性。</li>
<li>什么是Hot Key热键？<ul>
<li>在 <strong>Redis 集群</strong> 中，<strong>hot key</strong>（热键）是指某些键的访问频率远高于其他键。由于 Redis 是基于哈希槽来分片的，如果某些键所在的哈希槽被频繁访问，而其他哈希槽的负载较轻，就会导致 <strong>集群访问量倾斜</strong>，即某些节点负载过高，其他节点空闲或负载较低。这种情况可能会影响 Redis 集群的性能，增加响应延迟，甚至可能导致节点过载崩溃。</li>
</ul>
</li>
</ul>
</li>
<li>解决办法：</li>
</ul>
<p>总结：</p>
<p>在 Redis 集群中出现 <strong>hot key</strong> 造成集群访问量倾斜的原因通常是因为某些键频繁访问，导致集群某些节点负载过重。为了缓解这一问题，可以采用以下措施：</p>
<ol>
<li><strong>通过应用层调整热点数据的分布</strong>：使用哈希槽分布优化或前缀/加盐方式来打散热键。</li>
<li><strong>通过 Redis 集群的重新分片（Resharding）实现负载均衡</strong>：手动或自动迁移哈希槽。</li>
<li><strong>优化分片键选择</strong>：选择合理的分片键来避免单个哈希槽过载。</li>
<li><strong>通过限流策略控制访问频率</strong>：在应用层实施限流机制来减少热点数据的访问。</li>
<li><strong>合理配置 Redis 缓存淘汰策略</strong>：使用 LRU 或 LFU 等策略淘汰不常用数据，释放资源。</li>
</ol>
<p>这些措施可以有效地减少 <strong>hot key</strong> 对 Redis 集群的负载倾斜，提升集群的稳定性和性能。</p>
<h4 id="1-本地缓存"><a href="#1-本地缓存" class="headerlink" title="1.本地缓存"></a>1.本地缓存</h4><p>缓解Redis压力，减少对热Key的直接访问。（例如使用Ehcache、Guava Cache或简单的HashMap）</p>
<ul>
<li>应用启动时预热本地缓存，将热点数据加载到本地内存中。</li>
<li>使用Cache-Aside模式：请求数据时先查询本地缓存；若命中，则直接返回；若未命中，再查询Redis（或数据库），然后更新本地缓存。</li>
<li>当数据更新时，通过发布订阅、回调或主动刷新机制同步更新本地缓存，保证数据一致性。</li>
</ul>
<h4 id="2-请求分摊"><a href="#2-请求分摊" class="headerlink" title="2.请求分摊"></a>2.请求分摊</h4><p>把热Key拆分为多个子Key，将读请求分摊到多个Key上，降低单Key的压力。利用分片算法的特性，对key进行打散处理（给hot key加上前缀或者后缀，把一个hotkey 的数量变成 redis 实例个数N的倍数M，从而由访问一个 redis key 变成访问 N * M 个redis key）</p>
<ul>
<li>在应用层，对原有热点Key进行逻辑拆分，生成多个子Key，每个子Key缓存数据的一个副本。</li>
<li>在写更新时，同步更新所有子Key或采用异步批量更新。</li>
<li>在读时，通过hash算法或随机策略选择其中一个子Key进行查询，从而平摊流量。</li>
</ul>
<p>通过应用层进行热点数据分布调整</p>
<p>通过改变访问热点数据的 <strong>键</strong> 或 <strong>访问模式</strong>，将热点数据分散到不同的哈希槽，从而缓解集群的负载倾斜。</p>
<p>解决办法：</p>
<ul>
<li><strong>改变热点键的命名规则</strong>：在 Redis 中，键是通过哈希槽来分配的。哈希槽是通过计算键的 CRC16 值来分配的，因此不同的键被分配到不同的哈希槽。如果多个热键在同一个哈希槽，容易导致该哈希槽的负载过重。可以通过改变键的命名规则，使用不同的前缀或加盐的方式，避免多个热键分布到同一个哈希槽。比如，在对某些热点数据进行访问时，可以在键名上添加前缀或者随机字符进行哈希槽的分配，分散热键的压力：<ul>
<li>键名 <code>user:1234</code> → <code>user:abc1234</code></li>
<li>键名 <code>session:1234</code> → <code>session:xyz1234</code></li>
</ul>
</li>
<li><strong>改变应用访问模式</strong>：如果某个操作频繁访问某个特定的键，可以将热点数据分散到多个不同的键或哈希槽中。例如，可以通过将某个热点数据拆分成多个小块并分别存储在多个键中（例如，分页存储），从而避免单个键成为集群的瓶颈。</li>
</ul>
<p>通过选择合适的 <strong>分片键（sharding key）</strong>，可以在 Redis 集群中实现更合理的负载分布，减少热点键的影响。</p>
<p>解决办法：</p>
<ul>
<li><strong>选择合适的分片键</strong>：为了避免热点数据集中在单个哈希槽上，可以选择一个能均匀分布数据的分片键。例如，在电商应用中，如果数据按商品 ID 分片，而某些商品的访问量极高（例如热销商品），那么就会导致该哈希槽成为热点。可以考虑将商品 ID 与其他维度（如商家 ID、类别 ID）结合使用作为分片键，从而实现更均匀的分布。</li>
<li><strong>使用多层级分片键</strong>：可以考虑使用 <strong>复合分片键</strong>，即组合多个字段来构造键名，避免单一字段的热度集中。例如，<code>&quot;user:&lt;user_id&gt;:data:&lt;data_id&gt;&quot;</code> 而不是单独使用 <code>&quot;user:&lt;user_id&gt;&quot;</code> 作为分片键。这样可以将数据更均匀地分配到不同的哈希槽。</li>
</ul>
<h4 id="3-限流"><a href="#3-限流" class="headerlink" title="3.限流"></a>3.限流</h4><p>​    </p>
<p>对热Key访问进行限流，防止过多请求进入。</p>
<ul>
<li>利用Redis的原子计数器（如使用INCR命令）结合过期时间（EXPIRE）来实现简单的限流。例如，为每个请求来源（IP或用户）在特定时间窗口内累计请求数，超过阈值则拒绝或延迟处理。</li>
<li>也可以在应用层引入限流组件（如令牌桶或漏斗算法）对热点Key的请求进行限流，从而降低Redis压力。</li>
</ul>
<p>通过限流的方式，控制对某些热点数据的访问频率，避免单个键被过度访问，减轻集群的负载。</p>
<p>解决办法：</p>
<ul>
<li><p><strong>限流策略</strong>：在应用层实现限流机制，控制某个热点数据的访问频率。可以使用如 <strong>令牌桶算法</strong>、<strong>漏桶算法</strong> 或 <strong>滑动窗口算法</strong> 来进行限流，从而减少热点数据的访问请求，避免热点数据导致的负载倾斜。</p>
<p>例如，可以使用 Redis 自身的 <strong>Lua 脚本</strong>来实现限流，或者在应用层进行限流，减少对 Redis 的频繁访问。</p>
</li>
</ul>
<h4 id="4-监控和报警"><a href="#4-监控和报警" class="headerlink" title="4.监控和报警"></a>4.监控和报警</h4><p>通过Redis的INFO命令或监控工具，对于不可预知的热Key场景，接入热点探测系统，定期上报key的调用次数，热点探测系统检测是否热Key，通过SDK通知各个应用节点快速构建本地缓存。</p>
<ul>
<li>利用Redis的INFO命令、MONITOR命令或第三方监控工具（如Redis-faina、Redis-Stat）收集各Key的访问统计数据。</li>
<li>配置热点探测系统或SDK，当某个Key的访问频次超过预设阈值时，自动上报并通知相关应用节点。</li>
<li>结合日志、报警平台，实现自动告警和人工干预流程，以便及时采取应急措施。</li>
</ul>
<h4 id="备份热点Key"><a href="#备份热点Key" class="headerlink" title="备份热点Key"></a>备份热点Key</h4><p>对于极为热点的Key，可以在多个Redis节点上冗余存储（例如手动复制多份Key，或通过客户端进行数据分布），从而分散单节点的访问压力。</p>
<h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>当检测到热点趋势时，通过预热机制提前将数据加载到缓存中，减少因初次请求引发的缓存击穿问题。</p>
<h3 id="问：什么是缓存穿透、缓存击穿、缓存雪崩？如何避免？三者对比？"><a href="#问：什么是缓存穿透、缓存击穿、缓存雪崩？如何避免？三者对比？" class="headerlink" title="问：什么是缓存穿透、缓存击穿、缓存雪崩？如何避免？三者对比？"></a>问：什么是缓存穿透、缓存击穿、缓存雪崩？如何避免？三者对比？</h3><p>什么是缓存穿透、缓存击穿、缓存雪崩？</p>
<ul>
<li><strong>缓存穿透</strong>：解决的是请求的数据从一开始就不存在，需要防止无效请求查询数据库。<ul>
<li>频繁请求查询系统中不存在的数据；即数据库和Redis都不存在的数据。</li>
</ul>
</li>
<li><strong>缓存击穿</strong>：解决的是缓存中热点数据失效，多个请求同时访问数据库，通常通过分布式锁和异步加载来防止。<ul>
<li>Redis的缓存热点Key失效（或是不存在），但数据库存在数据，大量并发请求访问数据库。</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>：解决的是大量缓存同时过期，导致数据库压力陡增，通常通过设置随机过期时间和提前预热缓存来避免。</li>
</ul>
<h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h4><p>解决方案总结：</p>
<ol>
<li><strong>Cache Null 策略</strong>：缓存 <code>null</code> 值，在数据库查询不到数据时，将 <code>null</code> 存入缓存，避免后续重复查询数据库。适用于数据不存在的情况。</li>
<li><strong>布隆过滤器</strong>：在访问数据库前，使用布隆过滤器判断数据是否存在，从而避免不必要的数据库查询，减少数据库压力。适用于防止缓存穿透。</li>
<li><strong>Hystrix</strong>：使用断路器模式处理高并发请求，避免缓存击穿时直接访问数据库，通过降级和隔离策略保障系统稳定性。适用于分布式系统中的容错处理。</li>
</ol>
<p>详细：</p>
<ul>
<li><p><strong>定义：</strong></p>
<ul>
<li>缓存穿透是<strong>指请求的数据在缓存和数据库中都不存在</strong>，即缓存中没有数据，数据库也没有该数据，<strong>导致每次请求都需要查询数据库</strong>，从而给数据库带来极大的压力。缓存无法起到加速的作用，直接查询数据库，导致性能下降。</li>
</ul>
</li>
<li><p><strong>发生场景：</strong></p>
<ul>
<li>请求的数据根本不存在，例如非法的请求或者恶意攻击。</li>
<li>没有使用合理的过滤机制进行数据验证。</li>
</ul>
</li>
<li><p><strong>解决方案：</strong></p>
<ol>
<li><p><strong>空值缓存策略（Cache Null）</strong>：又叫 null key 策略</p>
<p><strong>方案</strong>：</p>
<ul>
<li>当查询到某个数据不存在时，缓存一个空值，防止每次请求都访问数据库。当缓存未命中时，如果后端查询没有数据返回（例如数据库没有该数据），可以将 <code>null</code> 存入缓存（<strong>设置5分钟过期时间</strong>），以避免每次查询时都去访问数据库。浪费时间，一般不使用。</li>
</ul>
<p><strong>如何阻止并发查询到数据库</strong>：</p>
<ol>
<li>通过setnx key value给hot key上锁</li>
<li>setnx成功，访问数据库</li>
<li>setnx失败，sleep（sleep的线程不占用CPU和内核调度、而且一般也不会命中到同一个Redis，做好线程池的扩容缩容就可以）</li>
</ol>
<p><strong>优缺点</strong>：</p>
<ul>
<li><strong>优点：</strong> 避免了高并发的请求同时访问数据库的问题，减少了数据库压力。</li>
<li><strong>缺点：</strong> 如果没有进行过期控制，可能会在缓存中存储 <code>null</code> 值，导致缓存的有效性降低。因此需要合理设置 <code>null</code> 值的缓存时间。</li>
</ul>
</li>
<li><p><strong>布隆过滤器（Bloom Filter）</strong>：</p>
<p><strong>方案</strong>：</p>
<ul>
<li><p>在查缓存以及数据库之前，首先使用布隆过滤器判断该数据是否存在。如果判断该数据不在集合中，则直接返回空值或错误提示，从而避免不必要的查询。</p>
</li>
<li><p>布隆过滤器有一个特点：<strong>可能会误判</strong>（即判断某个元素是集合成员时，实际上它不在集合中）。但它的<strong>误判率</strong>可以控制，通过适当的设计来降低误判的可能性。</p>
</li>
<li><p>Google布隆过滤器：基于内存，重启失效不支持大数据量，无法在分布式场景。</p>
</li>
<li><p>Redis布隆过滤器：可扩展性，不存在重启失效问题，需要网络io，性能低于google。</p>
</li>
</ul>
<p><strong>原理</strong>：</p>
<ul>
<li>通过二进制数组+Hash算法来实现，Redis中由Bitmaps来实现。</li>
<li>比如UserId的Set集合，通过Hash算法散列到二进制数组上，判断UserId是否存在，只需查找Hash后的散列坐标是否为1。</li>
<li>误判问题：<ul>
<li>哈希冲突：Hash计算后在数组上，结果为1，但其实不在Set集合。</li>
<li>但Hash计算后不在数组上，就一定不在集合里。</li>
</ul>
</li>
<li>优化：减少哈希冲突的方案。</li>
</ul>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 可以有效地避免 <strong>缓存穿透</strong>，避免无意义的查询数据库，提高系统性能，减少数据库的压力。</li>
<li><strong>缺点：</strong> 布隆过滤器本身可能会出现误判（假阳性），但通过合理设计误判率可以在一定程度上降低影响；同时布隆过滤器本身需要消耗内存和存储空间。</li>
</ul>
</li>
<li><p><strong>Hystrix</strong>：</p>
<p><strong>方案</strong>：</p>
<ul>
<li>由 Netflix 提供的一个用于处理分布式系统中服务调用的容错框架。Hystrix 的核心目标是通过 <strong>断路器模式</strong>、<strong>降级策略</strong>和<strong>隔离策略</strong>，来应对和解决高并发情况下的服务调用问题，提高系统的稳定性。</li>
<li>用于避免缓存击穿引发的数据库压力过大。尤其是当缓存系统宕机或某些缓存请求没有命中时，Hystrix 能够通过断路器和降级机制来避免直接访问数据库。</li>
<li>使用 Hystrix 进行容错处理，在缓存查询失败或缓存不可用时，能够快速响应并返回默认值或做降级处理，避免请求直接访问数据库，导致数据库压力过大。</li>
</ul>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 可以有效隔离故障，避免一个请求的失败导致整个系统崩溃。通过 Hystrix，系统可以在高并发情况下保证一定的容错能力。</li>
<li><strong>缺点：</strong> 引入了额外的复杂性，增加了系统的维护成本和监控成本，需要配置合适的参数和规则以达到理想的效果。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>实现代码：</p>
<p>空值策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存没有数据，查询数据库</span></span><br><span class="line">        value = databaseQuery(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数据库中也没有数据，缓存空值（null）</span></span><br><span class="line">            redis.set(key, <span class="string">&quot;null&quot;</span>, expirationTime);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果数据库有数据，将数据缓存</span></span><br><span class="line">            redis.set(key, value, expirationTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布隆过滤器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 key 是否存在于布隆过滤器中</span></span><br><span class="line">    <span class="keyword">if</span> (!bloomFilter.mightContain(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// 如果不存在，直接返回空值或默认值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存没有数据，查询数据库</span></span><br><span class="line">        value = databaseQuery(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数据库有数据，将数据缓存</span></span><br><span class="line">            redis.set(key, value, expirationTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hystrix</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 Hystrix 封装的缓存查询操作</span></span><br><span class="line">        <span class="keyword">return</span> hystrixCommand.execute(() -&gt; redis.get(key));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 发生错误时执行降级策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default value&quot;</span>;  <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2.缓存击穿"></a>2.缓存击穿</h4><p><strong>缓存击穿</strong>的问题通常发生在缓存中的热点数据失效时，多个请求并发访问数据库，导致数据库的压力急剧增大。为了解决这个问题，常用的策略包括：</p>
<ol>
<li><strong>使用缓存互斥锁</strong>：通过分布式锁保证只有一个请求能访问数据库并更新缓存，避免重复查询。</li>
<li><strong>设置永不过期或较长的过期时间</strong>：避免热点数据频繁失效。</li>
<li><strong>设置随机过期时间</strong>：避免缓存中的数据同时过期，造成大量请求访问数据库。</li>
<li><strong>异步更新缓存</strong>：当缓存失效时，返回默认值，后台异步加载数据并更新缓存。</li>
<li><strong>降级策略</strong>：缓存失效时返回默认值或静态缓存数据，避免数据库压力过大。</li>
<li><strong>合理缓存粒度</strong>：将缓存粒度拆分，避免热点数据缓存击穿影响其他数据。</li>
<li><strong>使用本地缓存结合 Redis</strong>：通过本地缓存减轻缓存击穿对 Redis 和数据库的影响。</li>
</ol>
<p>详细：</p>
<ul>
<li><p><strong>定义：</strong></p>
<ul>
<li>缓存击穿是指缓存中的<strong>热点数据</strong>在<strong>过期</strong>后（或者没有被缓存过的），同时有多个请求并发访问数据库，导致多个请求直接访问数据库，造成数据库压力过大。通常发生在缓存中的某些热点数据过期时，并且没有有效的同步机制防止多个请求同时访问数据库。</li>
</ul>
</li>
<li><p><strong>发生场景：</strong></p>
<ul>
<li><strong>热点数据过期或失效</strong>：如果缓存中的某些热点数据过期，并且多个并发请求同时访问这些数据，缓存会被击穿，所有请求都访问数据库，从而造成数据库压力过大。</li>
<li><strong>缓存失效时间较短：</strong> 如果缓存设置的过期时间较短，尤其是对于某些热点数据，可能会导致频繁的缓存失效，进而引发缓存击穿问题。</li>
<li><strong>缓存清除操作不当：</strong> 如果使用了定期清理缓存（如定时任务清理），某些热点数据可能在清理时失效，导致并发请求同时查询数据库。</li>
<li><strong>缓存没有更新：</strong> 如果缓存中的数据没有及时更新，或者由于网络问题或其他原因导致缓存没有更新，那么请求会直接访问数据库，造成缓存击穿。</li>
</ul>
</li>
<li><p><strong>解决方案：</strong></p>
<ol>
<li><p>预防缓存击穿的发生：</p>
<ul>
<li><strong>热点数据永不过期</strong>：<ul>
<li>对于一些热点数据，可以设置 <strong>永不过期</strong>（不设置过期时间）或非常长的过期时间，避免这些数据频繁失效，减小缓存击穿的风险。然后，使用后台线程定时异步刷新这些缓存的数据，确保数据的时效性。</li>
<li><strong>具体做法：</strong> 设置一个较长的缓存过期时间，或者使用异步更新缓存的策略。后台线程定期从数据库更新缓存，避免每次请求都去访问数据库。<code>redis.set(key, value, Long.MAX_VALUE);  // 设置永不过期</code> </li>
</ul>
</li>
<li>很难预测，所以只能尽量。这些方法都有局限性和不适用性。</li>
</ul>
</li>
<li><p><strong>互斥锁</strong>：</p>
<p>方案：</p>
<ul>
<li>使用<strong>分布式锁</strong>（如 Redis 的 <code>SETNX</code> 或 Redisson）保证只有一个请求能查询数据库并更新缓存，其余请求等到缓存更新后再获取数据。</li>
<li>当缓存中的数据失效时，多个请求可能会同时去查询数据库，这时可以使用 <strong>互斥锁</strong> 来避免多个请求同时访问数据库。只有第一个请求会去查询数据库并更新缓存，后续请求则可以直接从缓存中获取数据。</li>
</ul>
<p><strong>如何阻止并发查询到数据库</strong>：</p>
<ol>
<li>通过setnx key value给hot key上锁</li>
<li>setnx成功，访问数据库</li>
<li>setnx失败，sleep（sleep的线程不占用CPU和内核调度、而且一般也不会命中到同一个Redis，做好线程池的扩容缩容就可以）</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line"><span class="keyword">if</span> (redis.setnx(lockKey, <span class="string">&quot;locked&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// nx ex获取分布式锁，查询数据库并更新缓存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = databaseQuery();</span><br><span class="line">        redis.set(key, value, expirationTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redis.del(lockKey); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有获得锁，等待一段时间后重试</span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> getCache(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>异步加载</strong>：没有处理并发请求问题。</p>
<p>方案：</p>
<ul>
<li>当缓存失效时，不直接访问数据库，而是返回一个默认值（如空值或过期数据），并且在后台异步去查询数据库并更新缓存。这样，前端用户能够快速收到响应，避免对数据库造成大量压力。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回默认值</span></span><br><span class="line">        value = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        <span class="comment">// 异步刷新缓存</span></span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            String dbValue = databaseQuery(key);</span><br><span class="line">            redis.set(key, dbValue, expirationTime);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>延时双删</strong>：对于缓存的更新，采用双重删除策略，先删除缓存，再等待一定时间后再次删除缓存，以避免并发的更新请求。</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h4><ul>
<li><p><strong>定义：</strong>缓存雪崩是指缓存中存储的数据在<strong>同一时间大规模失效或过期</strong>，导致大量请求同时访问数据库，从而使得数据库承受极大的压力，甚至崩溃。通常发生在缓存的过期时间设置一致，或者缓存刷新失败时。</p>
</li>
<li><p><strong>发生场景：</strong></p>
<ul>
<li>多个缓存的过期时间相同，导致大量缓存同时失效。</li>
<li>在高并发场景下，大量请求同时访问数据库，造成数据库的雪崩式压力。</li>
<li>缓存过期策略不合理，未做有效的错峰操作。</li>
</ul>
</li>
<li><p><strong>解决方案：</strong></p>
<ul>
<li><strong>设置随机过期时间</strong>：避免缓存中的数据在同一时刻全部过期，可以为每个缓存项设置不同的过期时间，增加随机性，防止集中的过期时刻。</li>
<li><strong>缓存数据提前预热</strong>：定时刷新缓存或者提前加载缓存，避免缓存失效时大量请求打到数据库。</li>
<li><strong>异步更新缓存</strong>：当缓存失效时，异步去加载新的缓存，保证不会大量并发访问数据库。</li>
<li><strong>分布式限流</strong>：对于高并发的请求，可以通过限流机制减少请求压力，避免数据库承受过大的负载。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<p>为缓存设置不同的过期时间，避免缓存同时过期：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置过期时间时加入随机数</span></span><br><span class="line"><span class="keyword">long</span> expirationTime = <span class="number">60</span> * <span class="number">60</span> + (Math.random() * <span class="number">60</span>);  <span class="comment">// 随机时间</span></span><br><span class="line">redis.set(key, value, expirationTime);</span><br></pre></td></tr></table></figure>


<p>什么是缓存雪崩？</p>
<ul>
<li>同一时刻大量缓存失效；</li>
<li><strong>缓存雪崩</strong>是指在分布式缓存系统中，某一时刻大量的缓存失效，导致大量请求直接访问后端数据库，造成数据库压力过大，从而可能导致数据库崩溃，进而引发整个系统不可用的现象。这种情况通常发生在缓存中的大量数据在同一时刻过期，或者某些缓存系统宕机后，所有请求都转发到后端数据库。</li>
</ul>
<p><strong>缓存雪崩的原因：</strong></p>
<ol>
<li><strong>大量缓存失效：</strong> 如果缓存中的大量数据在同一时间过期（例如所有的缓存都设置了相同的过期时间），当缓存失效时，所有的请求将直接去访问数据库，导致数据库瞬间压力增大，甚至崩溃。</li>
<li><strong>缓存集群宕机：</strong> 如果缓存服务器或缓存集群发生故障，所有的缓存请求都会直接访问后端数据库，增加数据库的压力。</li>
<li><strong>大规模的缓存更新失败：</strong> 如果缓存更新失败，导致大量的缓存失效，瞬间对后端数据库的访问量急剧增加。</li>
</ol>
<p>因为数据库是系统架构的瓶颈，所以要尽量控制有效请求到达数据库，即使要放大前置环节的复杂度和成本。</p>
<p>处理方法：</p>
<ol>
<li>缓存数据增加过期标记</li>
<li>设置不同的缓存失效时间</li>
<li>双层缓存策略C1为短期，C2为长期</li>
<li>定时更新策略</li>
</ol>
<p>问题：</p>
<ol>
<li>Redis故障，并发数据库扛不住：<ul>
<li>Redis分片集群</li>
<li>引入EHCache</li>
<li>引入限流组件：hystrix</li>
</ul>
</li>
<li>Redis大量Key的TTL过期：把TTL岔开，随机设置过期时间。比如10W条数据分散到10s，平均1s1W条，1万条也分散到1s的各个节点。</li>
</ol>
<ul>
<li>AKF分治：AKF立方体包括三个维度：X轴（水平复制）、Y轴（功能分解）、Z轴（数据分片）。</li>
<li>每一个key对应的锁隔离</li>
<li>第三方提供的锁可以分片</li>
</ul>
<p><strong>如何解决缓存雪崩问题：</strong></p>
<ol>
<li><strong>缓存过期时间设置为不同的值（加随机值）</strong></li>
</ol>
<p>为了避免所有缓存的过期时间集中在同一时刻，可以给每个缓存设置一个随机的过期时间，使得缓存失效的时间错开。</p>
<ul>
<li><p><strong>具体做法：</strong> 对于每个缓存项，设置一个基础的过期时间，再加上一个随机值。例如，如果基础过期时间是 10 分钟，可以在每个缓存项的过期时间上加一个 0 到 60 秒之间的随机数。这样即使有大量的缓存失效，也不会在同一时间失效，能有效避免雪崩效应。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> expirationTime = <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span> + (Math.random() * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">redis.set(key, value, expirationTime);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>使用缓存预热</strong></li>
</ol>
<p>在缓存系统启动或缓存数据即将过期时，可以通过提前加载缓存的方式，避免缓存失效导致的高并发请求直接访问数据库。缓存预热通常是指将一些关键数据在应用启动时预先加载到缓存中，或者在数据即将过期时提前重新加载。</p>
<ul>
<li><strong>具体做法：</strong> 在缓存失效之前，后台可以定期刷新缓存，或者通过定时任务（如定时查询数据库）来更新缓存中的数据。</li>
</ul>
<ol start="3">
<li><strong>缓存互斥锁（防止击穿）</strong></li>
</ol>
<p>当缓存中的数据失效时，可能会有大量请求同时去数据库获取数据，导致数据库压力过大。为了避免这种情况，可以使用 <strong>互斥锁</strong> 来确保只有一个请求能够查询数据库并重新缓存数据。</p>
<ul>
<li><p><strong>具体做法：</strong> 当缓存数据失效时，多个请求可能同时访问数据库。为避免多个请求重复访问数据库，可以在请求中使用 Redis 锁机制（例如使用 <code>SETNX</code> 或 Redisson 的分布式锁）来实现互斥锁。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line"><span class="keyword">if</span> (redis.setnx(lockKey, <span class="string">&quot;locked&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 获取锁，查询数据库并更新缓存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = databaseQuery();</span><br><span class="line">        redis.set(key, value, expirationTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redis.del(lockKey); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有获得锁，等待一段时间后重试</span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> getCache(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><strong>使用本地缓存与远程缓存结合</strong></li>
</ol>
<p>本地缓存（如 <code>Guava</code> 或 <code>Caffeine</code>）可以用来缓存热点数据，这样即使远程缓存（如 Redis）出现雪崩问题，本地缓存也能继续工作，避免直接访问数据库。</p>
<ul>
<li><strong>具体做法：</strong> 本地缓存用于存储最常用的数据，而 Redis 用于存储大部分的数据。这样即使 Redis 崩溃，仍然可以从本地缓存中获取部分数据，减少数据库压力。</li>
</ul>
<ol start="5">
<li><strong>合理设置缓存更新策略（异步更新）</strong></li>
</ol>
<p>对于一些不频繁更新的数据，可以采用 <strong>异步更新策略</strong>，即缓存失效后，不立即从数据库中加载数据，而是先返回一个默认值（如空值或过期数据），并在后台异步从数据库中获取数据并更新缓存。</p>
<ul>
<li><p><strong>具体做法：</strong> 当缓存失效时，返回一个空值或过期值，异步线程从数据库加载并更新缓存。这样可以避免瞬间的大量数据库请求。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回默认值</span></span><br><span class="line">        value = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        <span class="comment">// 异步刷新缓存</span></span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            String dbValue = databaseQuery(key);</span><br><span class="line">            redis.set(key, dbValue, expirationTime);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><strong>降级策略</strong></li>
</ol>
<p>当缓存失效或出现异常时，可以设计 <strong>降级策略</strong>，例如将缓存中的数据暂时置为过期状态并进行异步加载，或者直接从数据库中加载数据并进行限流，避免对数据库造成过大压力。</p>
<ul>
<li><strong>具体做法：</strong> 当 Redis 崩溃或者出现访问延迟时，可以设计应用级的降级策略，将部分请求直接转到数据库中，或返回一个静态缓存的版本，避免影响整体的服务质量。</li>
</ul>
<ol start="7">
<li><strong>监控和报警机制</strong></li>
</ol>
<p>建立监控机制，监控缓存的命中率、缓存容量、缓存服务器的负载等。当发现缓存命中率低或者缓存集群出现异常时，可以及时预警，防止问题扩大。</p>
<ul>
<li><strong>具体做法：</strong> 使用 <code>Redis</code> 自带的 <code>INFO</code> 命令或其他监控工具，如 Prometheus 和 Grafana，来实时监控 Redis 的运行状态。一旦检测到异常，及时报警，并采取应急措施。</li>
</ul>
<p><strong>总结：</strong></p>
<p><strong>缓存雪崩</strong>是指在缓存大量数据同时过期或缓存服务宕机时，导致请求集中涌向数据库，造成数据库压力过大，最终可能引发系统崩溃。为了避免缓存雪崩，可以采取以下措施：</p>
<ul>
<li>设置不同的缓存过期时间并加随机值；</li>
<li>使用缓存预热策略；</li>
<li>使用缓存互斥锁避免缓存击穿；</li>
<li>配置本地缓存和远程缓存结合；</li>
<li>采用异步缓存更新策略；</li>
<li>设置合理的降级策略；</li>
<li>实时监控并设置报警机制。</li>
</ul>
<p>通过这些策略，可以有效避免缓存雪崩对系统性能和稳定性的影响。</p>
<h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table>
<thead>
<tr>
<th><strong>问题类型</strong></th>
<th><strong>定义</strong></th>
<th><strong>主要原因</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>缓存穿透</strong></td>
<td>请求的数据在缓存和数据库中都不存在，导致每次都查询数据库。</td>
<td>缓存未命中，且数据库中也没有数据，可能是恶意请求或非法请求。</td>
<td>使用布隆过滤器、空值缓存策略、前端校验。</td>
</tr>
<tr>
<td><strong>缓存击穿</strong></td>
<td>热点数据缓存失效后，但数据库有数据，多个请求同时查询数据库，导致数据库压力过大。</td>
<td>热点数据过期，多个请求同时访问数据库，造成数据库压力过大。</td>
<td>使用分布式锁、异步加载、延时双删。</td>
</tr>
<tr>
<td><strong>缓存雪崩</strong></td>
<td>大量缓存同时失效，导致大量请求访问数据库，给数据库带来巨大的压力。</td>
<td>缓存的过期时间设置一致，或者缓存刷新失败。</td>
<td>设置随机过期时间、缓存预热、异步更新缓存、分布式限流。</td>
</tr>
</tbody></table>
<h3 id="问：Redis-AKF分治？"><a href="#问：Redis-AKF分治？" class="headerlink" title="问：Redis AKF分治？"></a>问：Redis AKF分治？</h3><p><strong>一、X轴扩展：水平复制（Replication）</strong></p>
<p><strong>核心思想</strong>：通过<strong>数据副本</strong>提升系统可用性和读吞吐量，<strong>一主多从</strong>架构。<br><strong>Redis实现</strong>：</p>
<ol>
<li><strong>主从复制（Master-Slave）</strong><ul>
<li>主节点（Master）处理写请求，异步复制数据到从节点（Slave）。</li>
<li>从节点提供读服务，分担主节点压力，支持故障切换（需Sentinel或Cluster配合）。</li>
</ul>
</li>
<li><strong>哨兵模式（Sentinel）</strong><ul>
<li>监控主从节点健康状态，自动故障转移（Failover），实现高可用。</li>
<li>客户端通过Sentinel获取最新主节点地址，实现透明切换。</li>
</ul>
</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>读多写少</strong>：通过多副本提升读并发能力（如热点数据查询）。</li>
<li><strong>容灾恢复</strong>：主节点宕机时，从节点快速接管服务。</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li><strong>写性能瓶颈</strong>：主节点单点写入，无法横向扩展写能力。</li>
<li><strong>数据延迟</strong>：异步复制导致从节点数据短暂不一致。</li>
</ul>
<p><strong>二、Y轴扩展：功能拆分（Functional Decomposition）</strong></p>
<p><strong>核心思想</strong>：按<strong>业务功能</strong>拆分Redis实例，隔离不同类型数据。<br><strong>Redis实现</strong>：</p>
<ol>
<li><p><strong>业务维度拆分</strong></p>
<ul>
<li><p>不同业务线使用独立Redis集群（如订单缓存、用户会话、商品库存）。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订单服务使用独立Redis</span></span><br><span class="line"><span class="builtin-name">SET</span> order:1001 <span class="string">&quot;&#123;...&#125;&quot;</span></span><br><span class="line"><span class="comment"># 用户服务使用另一Redis集群</span></span><br><span class="line"><span class="builtin-name">SET</span> user:2001 <span class="string">&quot;&#123;...&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据类型拆分</strong></p>
<ul>
<li>按数据结构特性分配实例（如String存储简单缓存，Sorted Set处理排行榜）。</li>
</ul>
</li>
<li><p><strong>读写分离架构</strong></p>
<ul>
<li>写请求集中到主节点，读请求分散到多个从节点或专用读集群。</li>
</ul>
</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>复杂业务系统</strong>：避免不同业务竞争资源，降低耦合性。</li>
<li><strong>性能隔离</strong>：防止某类数据操作（如大Key扫描）影响全局性能。</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li><strong>运维成本</strong>：多实例增加部署、监控复杂度。</li>
<li><strong>数据一致性</strong>：跨实例事务需额外协调（如分布式锁）。</li>
</ul>
<p><strong>三、Z轴扩展：数据分片（Sharding）</strong></p>
<p><strong>核心思想</strong>：按<strong>数据特征</strong>（如Key哈希值）将数据集拆分到多个节点，实现水平扩展。<br><strong>Redis实现</strong>：</p>
<ol>
<li><strong>客户端分片</strong><ul>
<li>应用层计算分片路由（如<code>CRC32(key) % N</code>），直连多个Redis实例。</li>
<li><strong>缺点</strong>：需业务代码维护分片逻辑，扩容需数据迁移。</li>
</ul>
</li>
<li><strong>代理分片</strong><ul>
<li>使用中间件（如Twemproxy、Codis）代理请求，自动路由到后端节点。</li>
<li><strong>优点</strong>：业务无感知，支持动态扩缩容。</li>
</ul>
</li>
<li><strong>Redis Cluster</strong><ul>
<li>官方分片方案，将数据划分为16384个哈希槽（Slot），每个节点负责部分槽。</li>
<li><strong>特性</strong>：<ul>
<li>自动槽迁移：支持在线扩容、缩容。</li>
<li>高可用：主从节点组内复制，主宕机时从节点提升为新主。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>大数据量</strong>：单机内存无法容纳全量数据（如社交平台用户关系链）。</li>
<li><strong>高并发写入</strong>：分散写压力到多节点（如秒杀库存扣减）。</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li><strong>跨节点操作</strong>：不支持多Key事务（除非在同Slot）。</li>
<li><strong>迁移开销</strong>：槽迁移期间可能影响性能。</li>
</ul>
<p><strong>四、AKF分治组合应用</strong></p>
<p>实际生产环境中，常结合多个维度构建立体化扩展架构：</p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>扩展策略</strong></th>
<th align="left"><strong>架构示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">电商平台核心缓存</td>
<td align="left"><strong>Y+Z轴</strong></td>
<td align="left">按业务拆分订单、用户、商品缓存（Y轴），每类缓存按哈希分片（Z轴）。</td>
</tr>
<tr>
<td align="left">实时排行榜系统</td>
<td align="left"><strong>X+Z轴</strong></td>
<td align="left">每个分片（Z轴）部署主从集群（X轴），支撑高并发读写。</td>
</tr>
<tr>
<td align="left">全局会话管理</td>
<td align="left"><strong>X+Y轴</strong></td>
<td align="left">独立会话Redis集群（Y轴），主从复制（X轴）保障高可用。</td>
</tr>
<tr>
<td align="left">海量日志存储</td>
<td align="left"><strong>Z轴（Cluster）</strong></td>
<td align="left">使用Redis Cluster分片存储日志ID与内容，按时间范围分片。</td>
</tr>
</tbody></table>
<p><strong>五、选型建议与注意事项</strong></p>
<ol>
<li><strong>优先X轴</strong>：若读压力大且数据量可控，优先通过主从复制扩展。</li>
<li><strong>慎用Y轴</strong>：业务拆分需评估运维成本，避免过度碎片化。</li>
<li><strong>Z轴标配</strong>：数据量超单机内存时，必须采用Cluster或代理分片。</li>
<li><strong>监控告警</strong>：集群状态下，需监控槽分布、节点负载及迁移状态。</li>
<li><strong>客户端适配</strong>：使用Cluster时，确保客户端支持重定向（MOVED/ASK）与智能路由。</li>
</ol>
<p><strong>六、总结</strong></p>
<p>Redis通过AKF分治的三维扩展，完美适配不同规模的业务需求：</p>
<ul>
<li><strong>X轴</strong>：简单复制，快速提升读能力与可用性。</li>
<li><strong>Y轴</strong>：业务解耦，实现资源与性能隔离。</li>
<li><strong>Z轴</strong>：数据分片，突破单机容量与性能极限。</li>
</ul>
<h3 id="问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？双写一致性问题？"><a href="#问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？双写一致性问题？" class="headerlink" title="问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？双写一致性问题？"></a>问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？双写一致性问题？</h3><h4 id="缓存与数据库的一致性问题、常见场景、双写一致性问题"><a href="#缓存与数据库的一致性问题、常见场景、双写一致性问题" class="headerlink" title="缓存与数据库的一致性问题、常见场景、双写一致性问题"></a>缓存与数据库的一致性问题、常见场景、双写一致性问题</h4><ol>
<li><p>什么是缓存与数据库的一致性问题？</p>
<ul>
<li>缓存与数据库的<strong>一致性</strong>指缓存中数据与底层数据库的数据在任意时刻处于相同状态。然而，由于<strong>缓存与数据库的读写操作存在时序差异</strong>，在高并发场景下极易出现数据不一致。</li>
</ul>
</li>
<li><p>常见的不一致场景？</p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>原因</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>缓存穿透后延迟更新</strong></td>
<td align="left">缓存失效瞬间大量请求直接查询数据库，未及时回填缓存导致后续请求继续穿透。</td>
<td align="left">商品详情页缓存过期后，瞬间被10万请求击穿数据库。</td>
</tr>
<tr>
<td align="left"><strong>并发写操作时序错乱</strong></td>
<td align="left">多线程/分布式环境下，写操作顺序无法保证，导致最终状态不一致。</td>
<td align="left">用户A修改余额为100，用户B同时修改为200，缓存与数据库更新顺序错乱。</td>
</tr>
<tr>
<td align="left"><strong>缓存更新失败</strong></td>
<td align="left">缓存服务异常或网络抖动，导致数据库更新成功但缓存未更新。</td>
<td align="left">订单支付成功后更新数据库，但Redis因超时未更新，后续查询显示未支付。</td>
</tr>
<tr>
<td align="left"><strong>异步复制延迟</strong></td>
<td align="left">主从数据库同步存在延迟，缓存读取从库旧数据。</td>
<td align="left">用户注册后主库写入成功，但缓存从从库读取到未注册状态。</td>
</tr>
</tbody></table>
</li>
<li><p>双写一致性问题？</p>
<p>双写操作的顺序方案：</p>
<ol>
<li>先更新缓存，再更新数据库。</li>
<li>先更新数据库，再更新缓存。</li>
<li>先删除缓存，后更新数据库。</li>
<li>先更新数据库，后删除缓存。</li>
</ol>
<p>1和2，第一步更新成功、第二步更新失败，就会不一致。而且第一种因为缓存数据在，很难发觉数据库数据丢失。第二种还会有并发问题。</p>
<p>如果我们是写数据库场景频繁、读数据场景较少的需求，数据可能还未读到，缓存就已经被频繁的更新了。</p>
<p>当同时更新缓存和数据库时，任何一步失败都可能引发数据不一致。典型问题包括：</p>
<ol>
<li><strong>写后读不一致</strong>：A线程更新数据库后未更新缓存，B线程读取到旧缓存数据。</li>
<li><strong>并发写覆盖</strong>：多线程并发更新导致最终缓存与数据库状态不一致。</li>
</ol>
</li>
<li><p>当更新缓存的代价很小时，最好是更新缓存，以保证较高的缓存命中率。若更新缓存的代价很大，就最好选择删除缓存。</p>
<p>第三种也会有问题，比如A、B同时请求，A先删除缓存、再去数据库更新数据；此时B看到缓存中为空，会去数据库进行查询、甚至补录到Redis；此时A还未更新成功，请求B查到的是旧值；就产生了缓存与数据库不一致的问题。最简单的解决方案就是延迟双删。</p>
<p>第四种就是Cache Aside Pattern即旁路缓存。</p>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>方案对比与选型建议</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方案</strong></th>
<th align="left"><strong>一致性强度</strong></th>
<th align="left"><strong>性能影响</strong></th>
<th align="left"><strong>复杂度</strong></th>
<th align="left"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Cache Aside</strong></td>
<td align="left">最终一致</td>
<td align="left">低</td>
<td align="left">低</td>
<td align="left">读多写少，允许短暂不一致</td>
</tr>
<tr>
<td align="left"><strong>延迟双删</strong></td>
<td align="left">最终一致</td>
<td align="left">中</td>
<td align="left">中</td>
<td align="left">高并发写入，需降低脏数据概率</td>
</tr>
<tr>
<td align="left"><strong>Binlog监听</strong></td>
<td align="left">最终一致</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">系统重构，需解耦业务与缓存</td>
</tr>
<tr>
<td align="left"><strong>分布式事务</strong></td>
<td align="left">强一致</td>
<td align="left">极差</td>
<td align="left">高</td>
<td align="left">金融交易，容忍低吞吐量</td>
</tr>
</tbody></table>
<ul>
<li>可以使用分布式事务来解决，但意义不大。最多读多写稀有场景下可以尝试。</li>
<li>读写尽量发生在Redis上，性能高一些。再去更新数据库就会遇到丢失数据、数据不一致的情况。看业务对数据不一致的容忍度。</li>
<li>若先动数据库，后更新缓存，数据时效性就差，数据更新有时差。Redis可能数据更新失败，数据仍有不一致。</li>
</ul>
<p>缓存与数据库一致性需根据业务容忍度选择策略：</p>
<ul>
<li><strong>容忍短暂不一致</strong>：优先使用Cache Aside + 延迟双删。</li>
<li><strong>要求最终一致</strong>：引入Binlog监听 + 消息队列。</li>
<li><strong>强一致性需求</strong>：仅限金融场景，牺牲性能换取强一致。</li>
</ul>
<ol>
<li><strong>为什么推荐“删缓存”而非“更新缓存”？</strong><ul>
<li><strong>避免无效更新</strong>：并发写时可能覆盖其他线程已更新的数据。</li>
<li><strong>减少计算开销</strong>：直接删除比序列化新值更高效。</li>
</ul>
</li>
<li><strong>如何处理缓存删除失败？</strong><ul>
<li><strong>重试机制</strong>：结合MQ实现异步重试（至少3次）。</li>
<li><strong>设置缓存过期时间</strong>：作为兜底，即使删除失败，旧数据也会自动失效。</li>
</ul>
</li>
<li><strong>Binlog方案如何保证顺序性？</strong><ul>
<li><strong>Kafka分区有序</strong>：同一主键的Binlog事件路由到同一分区，确保顺序消费。</li>
<li><strong>本地队列排序</strong>：在消费者内部按事件时间戳排序处理。</li>
</ul>
</li>
</ol>
<p><strong>具体实现示例</strong></p>
<p>假设你有一个商品信息，需要缓存到 Redis 中：</p>
<ol>
<li><p>更新商品信息：</p>
<ul>
<li>首先删除 Redis 中商品的缓存。</li>
<li>更新数据库中的商品信息。</li>
<li>使用延迟双删策略，等待几百毫秒后，重新检查 Redis 中该商品信息是否存在，如果存在则删除。</li>
</ul>
</li>
<li><p>读取商品信息：</p>
<ul>
<li>从 Redis 中读取商品信息。</li>
<li>如果 Redis 中没有该商品信息，去数据库中查询，并更新缓存。</li>
</ul>
</li>
</ol>
<h5 id="1-强一致性方案（极少使用）"><a href="#1-强一致性方案（极少使用）" class="headerlink" title="1. 强一致性方案（极少使用）"></a><strong>1. 强一致性方案（极少使用）</strong></h5><ul>
<li><p><strong>分布式事务（2PC/3PC）</strong></p>
<ul>
<li><p><strong>实现</strong>：通过XA协议保证缓存与数据库操作的原子性。</p>
</li>
<li><p><strong>缺点</strong>：性能极差（吞吐量下降80%+），仅适合金融级强一致场景。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line"><span class="keyword">public</span> <span class="literal">void</span> updateData(<span class="built_in">Data</span> <span class="built_in">data</span>) &#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;UPDATE table SET ...&quot;</span>);  <span class="comment">// 数据库操作</span></span><br><span class="line">    redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="built_in">data</span>.getId(), <span class="built_in">data</span>);  <span class="comment">// 缓存操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="2-最终一致性方案（主流选择）"><a href="#2-最终一致性方案（主流选择）" class="headerlink" title="2. 最终一致性方案（主流选择）"></a><strong>2. 最终一致性方案（主流选择）</strong></h5><ul>
<li><p><strong>策略一：Cache Aside Pattern（旁路缓存）</strong></p>
<ul>
<li><p><strong>思路：</strong> 在写操作时，先更新数据库，再删除缓存。读操作时，先读缓存，未命中再查询数据库并重建缓存。</p>
</li>
<li><p><strong>优点：</strong> 简单且广泛应用，适用于大部分读多写少的场景。一般线上删除再更新缓存的速度比DB快，一般只有查询比删除慢的情况下才会出现偶尔的不一致。</p>
<p><strong>缺点：</strong> 如果删除缓存操作失败，可能会产生短暂的不一致；并且并发更新时仍需注意竞态问题。</p>
</li>
<li><p><strong>写操作</strong>：先更新数据库，<strong>后删除缓存</strong>（非更新）。</p>
</li>
<li><p><strong>读操作</strong>：缓存命中直接返回；未命中则查询数据库并回填缓存。</p>
</li>
<li><p><strong>优势</strong>：避免并发写导致的缓存与数据库不一致。</p>
</li>
<li><p><strong>改进措施：</strong></p>
<ul>
<li>可以在删除缓存后，进行异步重建缓存；</li>
<li>利用分布式锁确保同一数据更新时只有一个线程去重建缓存。</li>
</ul>
</li>
<li><p><strong>代码逻辑</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(Data data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    jdbc.update(data);</span><br><span class="line">    <span class="comment">// 2. 删除缓存</span></span><br><span class="line">    redis.delete(data.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Data <span class="title">getData</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    Data data = redis.get(id);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">        data = jdbc.query(id);</span><br><span class="line">        redis.set(id, data, <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>策略二：延迟双删（Delayed Double Deletion）（针对高并发场景）</strong></p>
<ul>
<li><p><strong>概念</strong>：当你更新数据库时，不直接更新缓存，而是先删除缓存中的相关数据，然后更新数据库。接着，异步等待一定时间后，再次检查缓存中是否还有旧数据，如果有则重新删除。</p>
</li>
<li><p><strong>原因</strong>：数据库更新时，可能会有多个请求并发更新同一数据，删除缓存时会有竞争情况，可能导致缓存和数据库不一致。因此，通过延迟的方式再次删除缓存，可以避免这种竞争。</p>
</li>
<li><p>优缺点：</p>
<ul>
<li><strong>优点</strong>：可以保证缓存删除后，数据库中的数据一定是最新的。</li>
<li><strong>缺点</strong>：可能会存在短时间内缓存和数据库不一致的情况，但通常这个时间较短，且通过过期策略来解决。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>删除缓存</li>
<li>更新数据库</li>
<li>延迟数百毫秒后再次删除缓存（清除可能的脏数据）</li>
</ol>
</li>
<li><p>补充：</p>
<ul>
<li>休眠时间根据项目读数据的耗时再加上几百毫秒作为写数据的耗时，确保读请求结束，写请求可以删除掉读请求造成的缓存脏数据。</li>
<li>主从库的同步也有可能比较耗时，休眠时间可能还要加上主从同步的延时时间。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：应对“先更新数据库，再删缓存”期间出现的并发读脏数据。</p>
</li>
<li><p><strong>实现示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(Data data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次删除缓存</span></span><br><span class="line">    redis.delete(data.getId());</span><br><span class="line">    <span class="comment">// 更新数据库</span></span><br><span class="line">    jdbc.update(data);</span><br><span class="line">    <span class="comment">// 延迟500ms后二次删除</span></span><br><span class="line">    executor.schedule(() -&gt; redis.delete(data.getId()), <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>策略三：异步监听数据库变更（无侵入方案）</strong></p>
<ul>
<li><p><strong>思路：</strong> 更新数据库后，不直接操作缓存，而是利用数据库的 binlog 进行变更捕捉（如 Canal），再由后台任务异步同步更新缓存。</p>
<p><strong>优点：</strong> 实现了最终一致性，降低了双写操作中的网络延迟和失败风险；</p>
<p><strong>缺点：</strong> 具有一定的延迟，不适用于对数据强一致性要求极高的场景。</p>
</li>
<li><p><strong>实现</strong>：通过数据库Binlog（如MySQL）监听数据变更，由中间件（Canal、Debezium）捕获变更事件后更新缓存。</p>
</li>
<li><p><strong>流程</strong>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL → Binlog → Canal <span class="built_in">Server</span> → Kafka → 缓存更新服务 → Redis</span><br></pre></td></tr></table></figure></li>
<li><p><strong>优势</strong>：业务代码无侵入，保证最终一致性。</p>
</li>
<li><p><strong>部署步骤</strong>：</p>
<ol>
<li>部署Canal Server并配置同步MySQL Binlog。</li>
<li>编写消费者监听Binlog事件，解析后更新Redis。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="3-降级补偿方案"><a href="#3-降级补偿方案" class="headerlink" title="3. 降级补偿方案"></a><strong>3. 降级补偿方案</strong></h5><ul>
<li><p><strong>消息队列重试</strong>：将缓存更新操作发送至MQ，失败时自动重试。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">updateData</span>(<span class="params">Data data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新数据库</span></span><br><span class="line">    jdbc.update(data);</span><br><span class="line">    <span class="comment">// 发送缓存删除消息至MQ</span></span><br><span class="line">    kafkaTemplate.send(<span class="string">&quot;cache-update-topic&quot;</span>, data.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">&quot;cache-update-topic&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">handleCacheUpdate</span>(<span class="params"><span class="built_in">String</span> id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redis.delete(id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 记录日志并重试</span></span><br><span class="line">        kafkaTemplate.send(<span class="string">&quot;cache-retry-topic&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Canal-binlog-方案"><a href="#Canal-binlog-方案" class="headerlink" title="Canal + binlog 方案"></a>Canal + binlog 方案</h4><p>➤ <strong>Binlog 是什么？</strong></p>
<p><code>binlog</code>（Binary Log，二进制日志）是 MySQL 提供的一种<strong>逻辑日志</strong>，记录了 MySQL 中的 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等数据变更操作，主要用于数据恢复、主从复制、数据同步等场景。</p>
<p>MySQL binlog 记录了：</p>
<ul>
<li>数据的变更（DML：插入、更新、删除）。</li>
<li>事务的开始和结束（Commit、Rollback）。</li>
<li>数据库结构的变化（DDL）。</li>
</ul>
<p>➤ <strong>Canal 是什么？</strong></p>
<p><code>Canal</code> 是阿里巴巴开源的**数据库变更捕获（CDC，Change Data Capture）**工具，基于 MySQL 主从复制协议，模拟 MySQL 从库，解析 MySQL 主库的 binlog，并以**实时订阅**的方式将数据变化发送给下游（如 Redis、Elasticsearch、Kafka）。</p>
<p><strong>Canal + binlog 方案工作原理</strong></p>
<ol>
<li><strong>数据变更</strong>：MySQL 数据库发生 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作，产生 binlog。</li>
<li><strong>日志解析</strong>：Canal 作为模拟的 MySQL slave，实时读取 MySQL 主库 binlog 日志。</li>
<li><strong>数据消费</strong>：Canal 解析 binlog 并生成数据变更事件（Data Change Event，DCE），输出到 Kafka、RocketMQ、Redis 等下游。</li>
<li><strong>更新缓存</strong>：应用服务监听 Canal 推送的变更事件，及时更新 Redis 缓存，确保缓存与数据库一致。</li>
</ol>
<p>📊 <strong>数据流示意图</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">scssCopyEditMySQL</span> <span class="params">(主库)</span></span></span><br><span class="line"><span class="function">    ↓ <span class="title">binlog</span></span></span><br><span class="line"><span class="function">C<span class="title">anal</span> <span class="params">(模拟从库)</span></span></span><br><span class="line"><span class="function">    ↓</span></span><br><span class="line"><span class="function">R<span class="title">edis</span> <span class="params">(缓存)</span></span></span><br></pre></td></tr></table></figure>



<p><strong>Canal + binlog 方案实现流程</strong></p>
<p>① MySQL 配置 binlog</p>
<p>确保 MySQL 开启 binlog 日志功能，编辑 MySQL 配置文件 <code>my.cnf</code>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bashCopyEdit[mysqld]</span><br><span class="line"><span class="attribute">server-id</span>=1</span><br><span class="line"><span class="attribute">log-bin</span>=mysql-bin</span><br><span class="line"><span class="attribute">binlog-format</span>=ROW  # 使用 ROW 模式，能记录数据的每行变化</span><br></pre></td></tr></table></figure>

<p>重启 MySQL 服务：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bash</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">CopyEdit</span></span><br><span class="line"><span class="attribute">systemctl restart mysqld</span></span><br></pre></td></tr></table></figure>

<p>② 安装和配置 Canal</p>
<ol>
<li>下载 Canal：<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">Canal GitHub 仓库</a></li>
</ul>
</li>
<li>修改 Canal 配置文件： <code>conf/example/instance.properties</code></li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bashCopyEditcanal.instance.master.address</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3306</span>  <span class="comment"># MySQL 地址</span></span><br><span class="line"><span class="attr">canal.instance.dbUsername</span>=root               <span class="comment"># MySQL 用户名</span></span><br><span class="line"><span class="attr">canal.instance.dbPassword</span>=your_password      <span class="comment"># MySQL 密码</span></span><br><span class="line"><span class="attr">canal.instance.filter.regex</span>=mydb\\.mytable  <span class="comment"># 监听的数据库和表</span></span><br></pre></td></tr></table></figure>

<ol>
<li>启动 Canal：</li>
</ol>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> bin/startup.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>

<p>③ 监听 binlog 并更新 Redis</p>
<p>示例代码（Java）：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditpublic void process<span class="constructor">CanalMessage(Message <span class="params">message</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry entry : message.get<span class="constructor">Entries()</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.get<span class="constructor">EntryType()</span><span class="operator"> == </span>EntryType.ROWDATA) &#123;</span><br><span class="line">            RowChange rowChange = <span class="module-access"><span class="module"><span class="identifier">RowChange</span>.</span></span>parse<span class="constructor">From(<span class="params">entry</span>.<span class="params">getStoreValue</span>()</span>);</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowChange.get<span class="constructor">RowDatasList()</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rowChange.get<span class="constructor">EventType()</span><span class="operator"> == </span>EventType.INSERT) &#123;</span><br><span class="line">                    update<span class="constructor">Cache(<span class="params">rowData</span>.<span class="params">getAfterColumnsList</span>()</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowChange.get<span class="constructor">EventType()</span><span class="operator"> == </span>EventType.UPDATE) &#123;</span><br><span class="line">                    update<span class="constructor">Cache(<span class="params">rowData</span>.<span class="params">getAfterColumnsList</span>()</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowChange.get<span class="constructor">EventType()</span><span class="operator"> == </span>EventType.DELETE) &#123;</span><br><span class="line">                    delete<span class="constructor">Cache(<span class="params">rowData</span>.<span class="params">getBeforeColumnsList</span>()</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Canal + binlog 方案的优缺点</strong></p>
<p>✅ <strong>优点</strong></p>
<ol>
<li><strong>实时性强</strong>：通过监听 binlog，能以毫秒级的延迟实时更新 Redis 缓存。</li>
<li><strong>解耦</strong>：数据库与缓存更新分离，业务代码无需关心缓存更新逻辑。</li>
<li><strong>适用复杂场景</strong>：支持多表多库同步，能满足大规模分布式系统需求。</li>
<li><strong>容灾性好</strong>：基于 MySQL 主从复制协议，具有良好的容错性，Canal 宕机时可恢复消费位置。</li>
</ol>
<p>❌ <strong>缺点</strong></p>
<ol>
<li><strong>一致性延迟</strong>：存在微小的时间窗口，在 binlog 解析和 Redis 更新之间，缓存与数据库可能短暂不一致。</li>
<li><strong>复杂度高</strong>：需要维护 Canal 服务、监控 binlog 消费状态，系统复杂度增加。</li>
<li><strong>多数据源</strong>：只适用于 MySQL 数据库，其他数据库需要实现类似 CDC（如 Debezium）。</li>
<li><strong>扩展性问题</strong>：高并发场景下需要对 Canal 消费和 Redis 更新进行优化，防止缓存击穿。</li>
</ol>
<p><strong>Canal + binlog 解决 Redis 缓存一致性问题</strong></p>
<ol>
<li><p><strong>缓存更新策略</strong></p>
<ul>
<li><strong>更新缓存</strong>：捕获 <code>INSERT</code> 和 <code>UPDATE</code> 事件，及时更新 Redis。</li>
<li><strong>删除缓存</strong>：捕获 <code>DELETE</code> 事件，删除 Redis 中的缓存，防止数据脏读。</li>
</ul>
</li>
<li><p><strong>双写不一致的解决</strong></p>
<ul>
<li><strong>异步更新</strong>：通过 Canal 异步更新缓存，避免业务代码直接操作 Redis，减少双写不一致问题。</li>
<li><strong>延迟双删</strong>：在更新数据库前后进行两次缓存删除，确保缓存最终一致性。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEdit<span class="regexp">//</span> 数据库更新前删除缓存</span><br><span class="line">redisTemplate.<span class="keyword">delete</span>(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line"><span class="regexp">//</span> 更新数据库</span><br><span class="line">userMapper.updateUser(user);</span><br><span class="line"><span class="regexp">//</span> 数据库更新后再次删除缓存</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">redisTemplate.<span class="keyword">delete</span>(<span class="string">&quot;user:&quot;</span> + userId);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>适用场景分析</strong></p>
<ol>
<li>高并发读写场景<ul>
<li>适用于订单系统、社交平台、推荐系统等对一致性要求较高的业务。</li>
</ul>
</li>
<li>复杂数据同步<ul>
<li>多个数据源需要缓存同步，如 MySQL + Redis + Elasticsearch。</li>
</ul>
</li>
<li>异步处理任务<ul>
<li>适用于数据变更后需触发异步任务的场景，如日志审计、数据清洗。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Canal + binlog 方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>一致性</strong></td>
<td>99.9% 准实时一致性，适用于高要求场景</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>毫秒级延迟，能满足大多数业务实时性需求</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>支持多表多库，适配大规模分布式系统</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>需要维护 Canal 服务，系统架构复杂度提升</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>订单、支付、库存、推荐系统等强一致性场景</td>
</tr>
</tbody></table>
<p>Canal + binlog 是一种可靠的数据库与缓存同步方案，虽然存在一定的实现复杂度，但凭借其高实时性与解耦特性，在企业级分布式系统中得到了广泛应用。</p>
<h3 id="问：Redis的主从不一致问题？"><a href="#问：Redis的主从不一致问题？" class="headerlink" title="问：Redis的主从不一致问题？"></a>问：Redis的主从不一致问题？</h3><p>Redis默认是弱一致性。锁不能用主从、要么单实例、要么分片集群、RedLock，或者直接Redisson。配置中要提供有多个Client连接能同步，配置同步因子，趋向于强一致性。wait 2 5000 或 wait 2 0；</p>
<p>Redis 默认采用异步主从复制模型，这意味着写操作完成后，数据会先写入主节点，然后异步复制到从节点，存在复制延迟，从而导致主从数据不一致，即“弱一致性”。在这种模型下，如果读请求落到从节点上，可能读到旧数据；此外，对于依赖数据一致性的分布式锁，如果使用主从数据可能会出现问题。</p>
<p>为了解决主从不一致的问题，可以考虑以下几种方案：</p>
<ol>
<li><strong>单实例模式</strong><br>将所有操作集中在单个 Redis 实例上，从而避免主从复制带来的不一致问题。但这会牺牲高可用性和扩展性。</li>
<li><strong>Redis 分片集群</strong><br>使用 Redis Cluster，数据按照槽（slot）分布在多个节点上，每个槽内的数据在主节点写入后再复制给从节点。集群模式下可以配置较严格的复制策略，但复制仍然是异步的，理论上仍然存在短暂的不一致。<br>如果对一致性要求较高，可以借助 <strong>WAIT 命令</strong>，例如：<ul>
<li><code>WAIT 2 5000</code>：主节点在返回写操作结果前，会等待至少 2 个从节点确认写入，最多等待 5000 毫秒。这样可以提高写入的强一致性，但会增加响应延迟。</li>
<li><code>WAIT 2 0</code>：等待 2 个从节点确认写入，但不设超时（实际上等于同步复制）。</li>
</ul>
</li>
<li><strong>分布式锁解决方案</strong><br>由于锁操作要求较高的强一致性，不能简单依赖于主从复制。常见的做法有：<ul>
<li>使用 <strong>RedLock</strong> 算法，它基于多个独立的 Redis 实例（通常分布在不同节点上）来实现分布式锁，能在一定程度上保证锁的安全性。</li>
<li>直接使用 <strong>Redisson</strong> 客户端，它封装了分布式锁的实现，并内置了超时、看门狗续期等机制，可以大大简化分布式锁的使用。</li>
</ul>
</li>
<li><strong>同步复制参数与客户端配置</strong><br>对于写入操作，可以通过配置同步因子和使用 <code>WAIT</code> 命令，强制主节点等待足够多的从节点同步后再返回。这样可以趋向于较高的一致性，但可能会牺牲部分写入性能。</li>
</ol>
<p>综上所述，Redis 主从复制存在弱一致性问题，这在分布式锁或数据敏感场景下可能引起问题。通常的解决方案包括：</p>
<ul>
<li>如果业务允许，可以采用单实例或者 Redis Cluster 并结合 <code>WAIT</code> 命令来提高一致性；</li>
<li>对于分布式锁，推荐使用 RedLock 或 Redisson 等成熟方案，避免直接依赖主从复制的数据一致性。</li>
</ul>
<p>例如，在使用 WAIT 命令时，可以这样写：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bashCopyEdit</span># 写入操作后等待至少<span class="number">2</span>个从节点确认写入，最多等待<span class="number">5000</span>毫秒</span><br><span class="line"><span class="attribute">SET</span> mykey <span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="attribute">WAIT</span> <span class="number">2</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>通过这种方式，可以在一定程度上保证写入操作在多个节点同步后再返回结果，从而提高数据一致性，但同时也要权衡性能和延迟问题。</p>
<h3 id="问：Redis也扛不住了，万级的流量打在DB上，该怎么处理？todododododododo"><a href="#问：Redis也扛不住了，万级的流量打在DB上，该怎么处理？todododododododo" class="headerlink" title="问：Redis也扛不住了，万级的流量打在DB上，该怎么处理？todododododododo"></a>问：Redis也扛不住了，万级的流量打在DB上，该怎么处理？todododododododo</h3><p>当 Redis 无法承受高并发流量，导致大量请求直接打到数据库时，可能会引发数据库性能瓶颈，影响系统稳定性。为了解决这一问题，可以考虑以下策略：</p>
<ol>
<li><strong>限流与降级</strong>：<ul>
<li><strong>限流</strong>：通过在应用层或 API 网关实现限流策略，限制单位时间内对数据库的请求数量，防止瞬时流量冲击数据库。</li>
<li><strong>降级</strong>：在高负载情况下，部分非核心功能可以暂时关闭或提供简化服务，减轻数据库压力。</li>
</ul>
</li>
<li><strong>数据库优化</strong>：<ul>
<li><strong>索引优化</strong>：确保数据库查询使用了适当的索引，以提高查询效率。</li>
<li><strong>读写分离</strong>：将读请求和写请求分发到不同的数据库实例，减轻主数据库的负担。</li>
<li><strong>数据库分片</strong>：将数据库水平拆分，分散数据存储，提升并发处理能力。</li>
</ul>
</li>
<li><strong>异步处理与消息队列</strong>：<ul>
<li><strong>异步处理</strong>：对于非实时性要求高的操作，采用异步处理方式，将任务放入消息队列，后台处理，避免同步操作阻塞主流程。</li>
<li><strong>消息队列</strong>：使用消息队列（如 Kafka、RabbitMQ）缓冲请求，平滑流量，避免瞬时高并发直接冲击数据库。</li>
</ul>
</li>
<li><strong>缓存预热与降级</strong>：<ul>
<li><strong>缓存预热</strong>：在系统启动或流量高峰前，预先将热点数据加载到缓存中，减少高并发时对数据库的访问。</li>
<li><strong>缓存降级</strong>：当缓存不可用或过期时，提供降级策略，如直接访问数据库或返回默认值，避免缓存穿透。</li>
</ul>
</li>
<li><strong>监控与报警</strong>：<ul>
<li><strong>实时监控</strong>：部署监控系统，实时监测数据库性能指标，如 QPS、响应时间、连接数等，及时发现性能瓶颈。</li>
<li><strong>自动扩容</strong>：根据监控数据，自动调整数据库资源，如增加读写实例，提升处理能力。</li>
</ul>
</li>
</ol>
<p><strong>应对万级流量冲击数据库的解决方案</strong></p>
<p>当Redis无法承载流量，导致大量请求直接穿透到数据库时，需系统性优化架构，从缓存、数据库、业务逻辑等多个层面入手。以下为分阶段解决方案：</p>
<p><strong>一、紧急止血：快速降低数据库压力</strong></p>
<ol>
<li><p><strong>限流降级</strong>  </p>
<ul>
<li><strong>接入层限流</strong>：在Nginx或API网关设置请求速率限制（如每秒5000次），拒绝超量请求，返回友好提示（如“系统繁忙，请稍后重试”）。  </li>
<li><strong>服务降级</strong>：关闭非核心功能（如排行榜更新、日志记录），优先保障核心交易链路（如下单、支付）。  </li>
<li><strong>代码示例（Sentinel限流）</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义资源名</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;queryProduct&quot;, blockHandler = &quot;handleBlock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">queryProduct</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限流处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">handleBlock</span><span class="params">(String id, BlockException ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServiceBusyException(<span class="string">&quot;系统繁忙，请稍后重试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>静态化兜底</strong>  </p>
<ul>
<li>对热点数据（如商品详情页）提前生成静态HTML页面，通过CDN分发，直接绕过动态查询。  </li>
<li><strong>实现方式</strong>：商品信息变更时，触发静态页生成并推送至CDN。</li>
</ul>
</li>
</ol>
<p><strong>二、缓存层深度优化</strong></p>
<ol>
<li><p><strong>缓存架构升级</strong>  </p>
<ul>
<li><strong>Redis Cluster分片</strong>：将数据分散到多节点，提升整体吞吐量（单Cluster可支持10万+ QPS）。  </li>
<li><strong>多级缓存体系</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → CDN → Nginx本地缓存 → Redis集群 → 数据库</span><br></pre></td></tr></table></figure></li>
<li><strong>本地缓存</strong>：在应用层使用Caffeine/Guava Cache，缓存极热点数据（如秒杀商品库存）。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, Product&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>缓存策略强化</strong>  </p>
<ul>
<li><strong>防穿透</strong>：对空值设置短TTL缓存（如<code>SET key-null &quot;&quot; EX 30</code>）。  </li>
<li><strong>防雪崩</strong>：缓存过期时间添加随机值（如基础30分钟±5分钟随机）。  </li>
<li><strong>防击穿</strong>：使用Redis分布式锁控制单请求回源，其他请求等待。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">&quot;product:&quot;</span> + id;</span><br><span class="line">    Product product = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (product == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (redis.lock(key, <span class="number">3</span>)) &#123; <span class="comment">// 获取分布式锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                product = db.query(id);</span><br><span class="line">                redis.setex(key, <span class="number">3600</span>, product);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                redis.unlock(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 等待重试</span></span><br><span class="line">            <span class="keyword">return</span> getProduct(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>三、数据库层优化</strong></p>
<ol>
<li><p><strong>读写分离</strong>  </p>
<ul>
<li><strong>主从架构</strong>：写操作走主库，读操作分流至多个从库（1主3从支撑5万+ QPS）。  </li>
<li><strong>数据库代理</strong>：使用MyCat/ShardingSphere自动路由读请求到从库。</li>
</ul>
</li>
<li><p><strong>异步写入</strong>  </p>
<ul>
<li><strong>消息队列削峰</strong>：将写操作异步化，通过Kafka/RocketMQ暂存请求，消费者批量写入。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下单请求异步处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    kafkaTemplate.send(<span class="string">&quot;order-topic&quot;</span>, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者批量写入</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &quot;order-topic&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchInsert</span><span class="params">(List&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line">    jdbc.batchUpdate(orders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分库分表</strong>  </p>
<ul>
<li><strong>垂直拆分</strong>：按业务拆分订单库、用户库、商品库。  </li>
<li><strong>水平拆分</strong>：对订单表按用户ID哈希分16个库，每个库分64张表。  </li>
<li><strong>工具支持</strong>：使用ShardingSphere实现透明分片。</li>
</ul>
</li>
</ol>
<p><strong>四、业务逻辑重构</strong></p>
<ol>
<li><p><strong>请求合并</strong>  </p>
<ul>
<li><strong>批量查询</strong>：将多个单品查询合并为批量接口（如<code>GET /products?ids=1001,1002,1003</code>）。  </li>
<li><strong>前端优化</strong>：增加请求间隔（如用户连续点击按钮时，500ms内只发送一次请求）。</li>
</ul>
</li>
<li><p><strong>计算分离</strong>  </p>
<ul>
<li><strong>离线计算</strong>：将排行榜、统计类数据通过Flink/Spark离线计算后写入缓存。  </li>
<li><strong>示例流程</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户行为日志 → Kafka → Flink实时计算 → 更新Redis排行榜</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>热点探测</strong>  </p>
<ul>
<li><strong>动态发现</strong>：通过Redis监控识别热点Key（如使用<code>redis-cli --hotkeys</code>）。  </li>
<li><strong>专项处理</strong>：对热点数据（如明星直播）提前预热到各级缓存，甚至做本地内存缓存。</li>
</ul>
</li>
</ol>
<p><strong>五、架构升级路线</strong></p>
<table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>目标</strong></th>
<th><strong>具体措施</strong></th>
</tr>
</thead>
<tbody><tr>
<td>应急响应</td>
<td>快速止血</td>
<td>限流降级、静态化兜底、扩容Redis连接数</td>
</tr>
<tr>
<td>短期优化</td>
<td>提升系统吞吐量</td>
<td>多级缓存、读写分离、异步写队列</td>
</tr>
<tr>
<td>中期改造</td>
<td>彻底解决容量瓶颈</td>
<td>Redis Cluster分片、数据库分库分表、引入OLAP分析库</td>
</tr>
<tr>
<td>长期规划</td>
<td>构建弹性云原生架构</td>
<td>容器化部署（K8s）、自动扩缩容（HPA）、Serverless化（如AWS Lambda+DAX）</td>
</tr>
</tbody></table>
<p><strong>六、监控与预案</strong></p>
<ol>
<li><p><strong>核心监控指标</strong>  </p>
<ul>
<li><strong>Redis</strong>：CPU使用率、内存碎片率、命中率、慢查询  </li>
<li><strong>数据库</strong>：QPS、连接数、慢SQL、锁等待时间  </li>
<li><strong>系统层</strong>：网络带宽、磁盘IO、线程池队列  </li>
</ul>
</li>
<li><p><strong>故障演练</strong>  </p>
<ul>
<li>定期模拟缓存宕机、数据库主从切换，验证降级策略有效性。  </li>
<li>使用ChaosBlade注入网络延迟、节点故障等异常。</li>
</ul>
</li>
<li><p><strong>容量规划</strong>  </p>
<ul>
<li>按每日峰值流量的3倍预留资源（如Redis Cluster节点数、数据库连接池大小）。  </li>
<li>建立自动化扩容机制（如阿里云弹性伸缩组）。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>应对高流量冲击需采取分层防御策略：  </p>
<ol>
<li><strong>前端限流</strong>：阻挡过量请求进入系统。  </li>
<li><strong>缓存扛压</strong>：通过多级缓存吸收99%以上读请求。  </li>
<li><strong>数据库保护</strong>：异步化+分库分表保障写操作不崩溃。  </li>
<li><strong>业务柔性</strong>：核心链路优先，非关键功能可降级。  </li>
</ol>
<p>通过上述组合拳，可将万级QPS对数据库的冲击降至百级以下，同时为后续架构演进赢得时间窗口。</p>
<h3 id="问：Redis-常见性能问题和解决方案？"><a href="#问：Redis-常见性能问题和解决方案？" class="headerlink" title="问：Redis 常见性能问题和解决方案？"></a>问：Redis 常见性能问题和解决方案？</h3><ul>
<li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</li>
<li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内</li>
<li>尽量避免在压力很大的主库上增加从库</li>
<li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</li>
</ul>
<p>这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。</p>
<h4 id="一、CPU-相关"><a href="#一、CPU-相关" class="headerlink" title="一、CPU 相关"></a>一、CPU 相关</h4><p><strong>1. CPU 使用率过高</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>复杂命令执行时间长，如 <code>SORT</code>、<code>ZUNIONSTORE</code>。</li>
<li>大量写入请求。</li>
<li>Lua 脚本运行时间过长。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>优化命令使用，避免阻塞型操作。</li>
<li>拆分大任务为小任务，使用批处理操作。</li>
<li>使用 <code>MONITOR</code> 或 <code>SLOWLOG</code> 命令排查慢命令。</li>
</ul>
<h4 id="二、内存相关"><a href="#二、内存相关" class="headerlink" title="二、内存相关"></a>二、内存相关</h4><p><strong>2. 内存占用过高</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>数据量过大，无限制写入。</li>
<li>键值未设置过期时间。</li>
<li>内存碎片导致占用增长。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>配置 <code>maxmemory</code> 限制最大内存。</li>
<li>设置键过期时间 (<code>EXPIRE</code>)。</li>
<li>使用 <code>MEMORY PURGE</code> 清理内存碎片。</li>
<li>使用 <code>INFO MEMORY</code> 命令监控内存使用情况。</li>
</ul>
<p><strong>3. 内存淘汰失败（OOM 错误）</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>没有配置内存淘汰策略，内存用尽时 Redis 报错。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>配置 <code>maxmemory-policy</code>，推荐 <code>allkeys-lru</code> 或 <code>volatile-lru</code>。</li>
<li>确保键设置合理的过期时间。</li>
</ul>
<p><strong>4. 内存泄漏</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>键未删除或未设置 TTL。</li>
<li>长时间运行导致数据积累。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>使用 <code>SCAN</code> 命令排查大量无用数据。</li>
<li>定期清理过期键。</li>
</ul>
<h4 id="三、网络与连接问题"><a href="#三、网络与连接问题" class="headerlink" title="三、网络与连接问题"></a>三、网络与连接问题</h4><p><strong>5. Redis 阻塞与响应延迟</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>Redis 单线程执行阻塞命令。</li>
<li>客户端连接过多，服务器负载高。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>避免使用 <code>KEYS</code>、<code>FLUSHALL</code> 等阻塞命令。</li>
<li>使用 <code>客户端连接池</code> 优化连接管理。</li>
<li>配置 <code>maxclients</code> 限制最大连接数。</li>
</ul>
<p><strong>6. 网络超时与连接断开</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>网络波动或服务器负载过高。</li>
<li>Redis 配置 <code>timeout</code> 值过短。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>配置合理的 <code>timeout</code> 值。</li>
<li>使用客户端重试机制。</li>
<li>检查服务器硬件与网络链路。</li>
</ul>
<h4 id="四、持久化与数据安全问题"><a href="#四、持久化与数据安全问题" class="headerlink" title="四、持久化与数据安全问题"></a>四、持久化与数据安全问题</h4><p><strong>7. RDB/AOF 持久化导致性能下降</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>大量写操作时，RDB 快照或 AOF 重写占用 CPU 和 IO。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>调整 <code>save</code> 配置，减少 RDB 生成频率。</li>
<li>配置 AOF 重写阈值，优化磁盘 IO。</li>
<li>在高并发场景使用异步持久化。</li>
</ul>
<p><strong>8. 数据丢失问题</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>Redis 崩溃或服务器断电。</li>
<li>AOF 未启用或刷盘不及时。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>开启 AOF，配置 <code>appendfsync</code> 为 <code>always</code> 或 <code>everysec</code>。</li>
<li>部署 Redis 哨兵（Sentinel）或集群模式。</li>
</ul>
<h4 id="五、集群与复制问题"><a href="#五、集群与复制问题" class="headerlink" title="五、集群与复制问题"></a>五、集群与复制问题</h4><p><strong>9. 主从同步延迟</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>从节点 IO 性能差，数据同步过慢。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>提高从节点硬件配置。</li>
<li>配置 <code>repl-backlog-size</code>，减少主从重同步。</li>
</ul>
<p><strong>10. Redis 集群数据分布不均</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>键分片算法导致数据倾斜。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>使用哈希标签，优化键分布策略。</li>
<li>检查节点负载均衡情况。</li>
</ul>
<p><strong>11. 主节点故障，服务中断</strong></p>
<p><strong>原因：</strong></p>
<ul>
<li>主节点单点故障。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>使用 Redis Sentinel 自动故障转移。</li>
<li>配置多主从节点，启用高可用。</li>
</ul>
<p><strong>常用排查与优化命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看慢查询日志</span></span><br><span class="line">redis-cli SLOWLOG GET</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看内存使用情况</span></span><br><span class="line">redis-cli INFO MEMORY</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看连接数与请求量</span></span><br><span class="line">redis-cli INFO STATS</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 CPU 与持久化配置</span></span><br><span class="line">redis-cli INFO PERSISTENCE</span><br></pre></td></tr></table></figure>



<h3 id="问：redis阻塞原因？以及解决方案等"><a href="#问：redis阻塞原因？以及解决方案等" class="headerlink" title="问：redis阻塞原因？以及解决方案等"></a>问：redis阻塞原因？以及解决方案等</h3><p><strong>Redis 阻塞的常见原因及解决方案</strong></p>
<ol>
<li>数据结构使用不合理（BigKey 问题）<ul>
<li><strong>原因：</strong> 如果存储的 key 对应的数据结构过大（例如超大列表、超大哈希或集合），在执行遍历、更新或序列化操作时，会消耗较长时间，阻塞主线程。<ul>
<li>单个键值过大（如超大字符串、List、Set、Hash、ZSet）。</li>
<li>执行 <code>DEL</code>、<code>LRANGE</code>、<code>HGETALL</code> 等命令时阻塞。</li>
</ul>
</li>
<li><strong>解决方案：</strong><ul>
<li><strong>拆分 BigKey</strong>：将大键拆分成小键。避免存储过大的 key，将大数据拆分成更小的子数据结构；</li>
<li>使用适合的编码（如 ziplist/listpack）存储小型数据；</li>
<li>通过应用层逻辑对大 key 进行分页或分片处理，降低单次操作的数据量。</li>
<li><strong>异步删除</strong>：使用 <code>UNLINK</code> 而不是 <code>DEL</code>。</li>
</ul>
</li>
</ul>
</li>
<li>CPU饱和：<ul>
<li><strong>原因：</strong> Redis 是单线程处理请求，如果遇到 CPU 密集型操作（如复杂的 Lua 脚本、排序、重计算等），会使 CPU 使用率飙升，导致响应变慢，从而阻塞后续请求。<ul>
<li>慢查询、过多复杂操作。</li>
<li>数据结构操作不当，频繁执行 Lua 脚本。</li>
</ul>
</li>
<li><strong>解决方案：</strong><ul>
<li>优化 Lua 脚本和数据处理逻辑，尽量避免长时间运行的命令；</li>
<li>分析和优化慢查询，使用 <code>SLOWLOG</code> 检查问题命令；</li>
<li>在 Redis 6 及以后版本中，可以启用 I/O 多线程（只针对网络 I/O 部分）来缓解部分压力。</li>
<li><strong>水平扩展</strong>：部署 Redis 集群，分片存储。</li>
<li><strong>多实例部署</strong>：在多核服务器上运行多个 Redis 实例，充分利用 CPU。</li>
<li>使用 <strong>监控工具</strong>（如 Redis Insight、Prometheus）。</li>
</ul>
</li>
</ul>
</li>
<li>持久化阻塞：<ul>
<li>RDB 快照：<ul>
<li><strong>原因：</strong> 在执行 RDB 快照时，Redis 会 fork 一个子进程复制数据，这个过程会导致写操作受到影响，特别是在数据量大时可能引起较长阻塞。<ul>
<li>RDB 触发 <code>BGSAVE</code>，子进程 <code>fork()</code> 时阻塞主线程。</li>
</ul>
</li>
<li><strong>解决方案：</strong><ul>
<li>选择合适的 RDB 触发时机（例如低峰时段）；</li>
<li><strong>禁用 RDB 持久化</strong>（适用于缓存场景）。使用 AOF 模式代替或配合 RDB；</li>
<li>调整 fork 时的系统参数，或考虑硬件升级（如 SSD）。</li>
</ul>
</li>
</ul>
</li>
<li>AOF 持久化：<ul>
<li><strong>原因：</strong> 如果 AOF 配置为 <code>always</code> 模式（每次写操作都 fsync），会因磁盘 I/O 慢而阻塞命令执行；即使采用 <code>everysec</code> 模式，也可能在高并发下受到影响。<ul>
<li>AOF 持久化使用 <code>fsync always</code>，导致频繁磁盘 IO 阻塞。</li>
</ul>
</li>
<li><strong>解决方案：</strong><ul>
<li><strong>调整 AOF 策略</strong>：推荐 <code>appendfsync everysec</code>。建议使用 <code>appendfsync everysec</code> 模式，平衡数据安全性和性能；</li>
<li>使用更快的磁盘（SSD）降低 fsync 延迟；</li>
<li><strong>优化配置</strong>：调整 <code>no-appendfsync-on-rewrite</code>，减少持久化频率。</li>
<li>考虑 AOF 重写优化，降低 AOF 文件体积。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>命令执行耗时过长：<ul>
<li><strong>原因：</strong>执行复杂或耗时的命令，如 <code>KEYS *</code>、<code>FLUSHALL</code>、<code>SAVE</code>、<code>SORT</code>、<code>LRANGE</code>（大范围）。遍历全量数据的命令在数据量大时会阻塞 Redis 主线程。</li>
<li><strong>解决方案：</strong><ul>
<li><strong>避免使用阻塞命令</strong>，使用 <code>SCAN</code> 代替 <code>KEYS</code>。</li>
<li>禁用 <code>SAVE</code>，使用异步 <code>BGSAVE</code>。</li>
<li>对于大数据集，<strong>分批处理</strong>，避免一次性操作大量数据。</li>
</ul>
</li>
</ul>
</li>
<li>大量客户端连接：<ul>
<li><strong>原因：</strong>客户端连接数过多，达到 Redis 配置的 <code>maxclients</code> 限制。Redis 无法及时响应所有请求，阻塞主线程。</li>
<li><strong>解决方案：</strong><ul>
<li>增加 <code>maxclients</code> 配置，调优连接池。</li>
<li>使用 <strong>连接池框架</strong>（如 Jedis、Redisson）。</li>
<li>部署 <strong>Redis 集群</strong>，实现负载均衡。</li>
</ul>
</li>
</ul>
</li>
<li>网络延迟与阻塞 I/O：<ul>
<li>原因：Redis 使用 TCP 套接字进行通信，网络延迟和阻塞 I/O 会导致请求堆积。</li>
<li><strong>解决方案：</strong><ul>
<li>检查网络延迟与带宽，优化 <strong>网络环境</strong>。</li>
<li>调整 Redis 的 <code>tcp-keepalive</code> 配置。</li>
<li>开启 <strong>持久连接</strong>，减少 TCP 建立成本。</li>
</ul>
</li>
</ul>
</li>
<li>内存耗尽或垃圾回收：<ul>
<li><strong>原因：</strong>Redis 达到内存上限，执行内存清理或数据淘汰时阻塞。内存分配与释放频繁，触发系统的垃圾回收。</li>
<li><strong>解决方案：</strong><ul>
<li>设置 <strong>内存上限</strong> (<code>maxmemory</code>)，启用淘汰策略。</li>
<li>优化 <strong>数据模型</strong>，避免存储过大的键。</li>
<li>使用 <strong>更高性能的内存硬件</strong>（如 SSD）。</li>
</ul>
</li>
</ul>
</li>
<li>大批量数据插入与导入：<ul>
<li><strong>原因：</strong>一次性导入大量数据，超过 Redis 处理能力，导致阻塞。</li>
<li><strong>解决方案：</strong><ul>
<li>使用 <strong>批量插入工具</strong>（如 <code>redis-cli --pipe</code>）。</li>
<li>分批处理数据，<strong>限流控制</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>锁与阻塞命令：<ul>
<li><strong>原因：</strong>使用 Redis 的阻塞命令（如 <code>BLPOP</code>、<code>BRPOP</code>）处理队列时，等待超时。</li>
<li><strong>解决方案：</strong><ul>
<li>降低阻塞命令使用频率，设置 <strong>超时时间</strong>。</li>
<li>使用 <strong>消息队列替代方案</strong>（如 Kafka、RabbitMQ）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>4. Redis 主从复制阻塞</strong></p>
<ul>
<li><p><strong>现象</strong>：主节点在全量同步时阻塞，导致读写卡顿。</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>开启 <strong>无磁盘复制</strong> (<code>repl-diskless-sync</code>)。</li>
</ul>
</li>
<li><p>减少主从同步频率，优先启用增量复制。</p>
</li>
</ul>
<p><strong>5. Redis 数据迁移与重分片</strong></p>
<ul>
<li><p><strong>现象</strong>：在 Redis 集群中重分片或迁移大数据时阻塞。</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>使用 Redis 集群管理工具，控制迁移速度。</li>
</ul>
</li>
<li><p>优化迁移策略，避免大批量数据一次性迁移。</p>
</li>
</ul>
<p><strong>6. 锁争用与阻塞命令</strong></p>
<ul>
<li><p><strong>现象</strong>：使用 <code>BLPOP</code>、<code>BRPOP</code>、<code>WAIT</code> 等阻塞命令时等待超时。</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>优化队列模型，减少阻塞操作。</li>
</ul>
</li>
<li><p>使用分布式锁方案（如 Redisson、Redis 分布式锁）。</p>
</li>
</ul>
<p><strong>7. 内存不足与垃圾回收</strong></p>
<ul>
<li><p><strong>现象</strong>：内存使用率超过 <code>maxmemory</code> 限制，Redis 执行数据清理时阻塞。</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>配置 <strong>内存淘汰策略</strong>（如 <code>volatile-lru</code>、<code>allkeys-lru</code>）。</li>
</ul>
</li>
<li><p>使用高性能内存硬件，监控和优化数据模型。</p>
</li>
</ul>
<p><strong>8. Redis Lua 脚本执行超时</strong></p>
<ul>
<li><p><strong>现象</strong>：Lua 脚本执行时间过长，导致主线程阻塞。</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>限制 Lua 脚本的执行时间 (<code>lua-time-limit</code>)。</li>
</ul>
</li>
<li><p>避免复杂逻辑和大规模数据操作。</p>
</li>
</ul>
<p><strong>9. 网络故障与客户端过多</strong></p>
<ul>
<li><p><strong>现象</strong>：客户端连接数超出 <code>maxclients</code> 限制，Redis 无法及时响应。</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>优化客户端连接池，减少长连接。</li>
</ul>
</li>
<li><p>增加 Redis 服务器节点，分摊负载。</p>
</li>
</ul>
<p><strong>总结：Redis 阻塞的全面预防措施</strong></p>
<ul>
<li>优化数据结构，避免使用 BigKey。</li>
<li>合理配置 RDB 和 AOF 策略，防止磁盘 IO 过载。</li>
<li>水平扩展 Redis 集群，部署多实例。</li>
<li>优化网络与持久化配置，启用无磁盘复制。</li>
<li>使用监控工具，及时发现与修复潜在问题。</li>
</ul>
<hr>
<h2 id="x-Redis高并发高可用"><a href="#x-Redis高并发高可用" class="headerlink" title="x. Redis高并发高可用"></a>x. Redis高并发高可用</h2><h3 id="问：分布式-Redis-是前期做还是后期规模上来了再做好？为什么？"><a href="#问：分布式-Redis-是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="问：分布式 Redis 是前期做还是后期规模上来了再做好？为什么？"></a>问：分布式 Redis 是前期做还是后期规模上来了再做好？为什么？</h3><p>既然 Redis 是如此的轻量（单实例只使用 1M 内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便只有一台服务器，也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。一开始就多设置几个 Redis 实例，例如 32或者 64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。这样的话，当数据不断增长，需要更多的 Redis 服务器时，需要做的就是仅仅将 Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦添加了另一台服务器，需要将一半的 Redis 实例从第一台机器迁移到第二台机器。</p>
<p><strong>分布式 Redis：前期 vs. 后期实施分析</strong></p>
<p>选择在 <strong>前期</strong> 还是 <strong>后期</strong> 引入分布式 Redis，取决于项目的业务特性、数据规模、预期增长速度和团队的开发维护能力。以下是详细的对比与推荐：</p>
<p><strong>一、前期部署分布式 Redis（业务初期）</strong></p>
<p><strong>适用场景</strong></p>
<ul>
<li>业务启动时预计数据规模增长快，用户量潜力大（如电商、社交、视频直播）。</li>
<li>业务对高可用性、容灾与故障恢复要求高。</li>
<li>系统架构规划有明确的分布式需求，且团队具备 Redis 集群部署和维护经验。</li>
</ul>
<p><strong>优势</strong></p>
<ul>
<li><strong>弹性扩展</strong>：随业务增长平滑扩展节点。</li>
<li><strong>高可用性</strong>：支持主从复制与自动故障转移。</li>
<li><strong>数据可靠性</strong>：具备数据分片与持久化支持。</li>
<li><strong>性能优化提前介入</strong>：减少后期大规模改造的技术债务。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li><strong>复杂性增加</strong>：系统设计更复杂，部署与运维成本提升。</li>
<li><strong>资源浪费风险</strong>：业务初期数据量小，资源利用率低。</li>
</ul>
<p><strong>二、后期扩展分布式 Redis（业务规模增长后）</strong></p>
<p><strong>适用场景</strong></p>
<ul>
<li>初期业务数据规模小，访问量有限，Redis 单机部署能满足需求。</li>
<li>系统架构相对简单，初期专注于核心功能开发，节省早期开发成本。</li>
<li>团队 Redis 集群维护经验不足，需要积累运维经验。</li>
</ul>
<p><strong>优势</strong></p>
<ul>
<li><strong>开发与运维成本低</strong>：无需初期引入复杂的分布式方案。</li>
<li><strong>资源节省</strong>：单机 Redis 内存资源可用到极限。</li>
<li><strong>渐进式扩展</strong>：根据业务增长逐步扩展，降低初期资源浪费。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li><strong>迁移与改造成本高</strong>：后期引入分布式 Redis 需要大量重构。</li>
<li><strong>服务中断风险</strong>：迁移期间可能导致业务停机和服务不可用。</li>
<li><strong>不可预测的瓶颈</strong>：单机性能和存储限制可能导致服务性能突然下降。</li>
</ul>
<p><strong>三、决策因素对比表</strong></p>
<table>
<thead>
<tr>
<th><strong>决策因素</strong></th>
<th><strong>前期部署分布式 Redis</strong></th>
<th><strong>后期扩展分布式 Redis</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>用户规模预测</strong></td>
<td>用户增长潜力大，峰值高</td>
<td>用户增长逐步扩展</td>
</tr>
<tr>
<td><strong>数据存储容量要求</strong></td>
<td>数据量预期大，增长迅速</td>
<td>数据量初期较小</td>
</tr>
<tr>
<td><strong>高可用与容灾需求</strong></td>
<td>高可用要求高，需故障转移</td>
<td>容灾需求低，数据非关键</td>
</tr>
<tr>
<td><strong>资源利用率与成本</strong></td>
<td>初期资源成本高，分片预留</td>
<td>初期资源成本低，按需扩展</td>
</tr>
<tr>
<td><strong>架构复杂度与维护成本</strong></td>
<td>部署、维护与开发复杂</td>
<td>初期简单，后期迁移成本高</td>
</tr>
</tbody></table>
<p><strong>最佳实践与推荐</strong></p>
<ol>
<li><strong>初期推荐方案（小规模系统）</strong>：<ul>
<li>使用 <strong>单机 Redis 部署</strong>，支持持久化（AOF/RDB）配置。</li>
<li>结合 <strong>主从复制</strong> 提高高可用性。</li>
<li>使用 <strong>哨兵模式（Sentinel）</strong> 提供自动故障切换。</li>
</ul>
</li>
<li><strong>成长中期方案（中等规模系统）</strong>：<ul>
<li>引入 <strong>Redis Cluster</strong> 或 <strong>代理分片（如 Codis/Twemproxy）</strong>。</li>
<li>确保数据持久化和节点高可用配置，支持平滑扩展与负载均衡。</li>
</ul>
</li>
<li><strong>长期方案（大规模系统）</strong>：<ul>
<li>使用 <strong>Redis Cluster</strong>，数据自动分片，主从复制与高可用。</li>
<li>结合 <strong>监控系统（Prometheus/Grafana）</strong>，自动化管理与告警。</li>
</ul>
</li>
</ol>
<p><strong>结论：如何选择？</strong></p>
<ul>
<li>如果 <strong>业务增长可预期，数据敏感，架构团队有 Redis 集群维护经验</strong>，建议 <strong>前期部署分布式 Redis</strong>。</li>
<li>如果 <strong>业务初期不确定，用户规模和数据量小，需降低运营成本</strong>，建议先采用 <strong>单机 Redis</strong>，在增长期引入 <strong>Redis Cluster</strong>。</li>
</ul>
<p>这是一种在功能开发和架构复杂度之间的权衡，最终需要结合业务需求、团队经验与预算做出最佳决策。</p>
<h3 id="问：Redis的同步机制？"><a href="#问：Redis的同步机制？" class="headerlink" title="问：Redis的同步机制？"></a>问：Redis的同步机制？</h3><ul>
<li>全量拷贝：<ol>
<li>slave第一次启动时，连接Master，发送PSYNC命令，</li>
<li>master会执行bgsave命令来生成rdb文件，期间的所有写命令将被写入缓冲区。</li>
<li>master bgsave执行完毕，向slave发送rdb文件</li>
<li>slave收到rdb文件，丢弃所有旧数据，开始载入rdb文件</li>
<li>rdb文件同步结束之后，slave执行从master缓冲区发送过来的所以写命令。此后 master 每执行一个写命令，就向slave发送相同的写命令。</li>
</ol>
</li>
<li>增量拷贝：如果出现网络闪断或者命令丢失等异常情况，从节点之前保存了自身已复制的偏移量和主节点的运行ID。主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li>
</ul>
<p>Redis 的同步机制确保主从服务器之间的数据一致性，主要包括 <strong>主从复制（Replication）</strong> 和 <strong>持久化同步</strong>。Redis 的同步机制主要通过主从复制与持久化策略实现数据一致性与高可用。主从复制确保高并发读写能力，持久化机制防止数据丢失。在实际生产环境中，结合哨兵模式与集群模式可以实现稳定可靠的 Redis 部署。</p>
<p><strong>一、主从复制（Replication）</strong></p>
<p>主从复制是 Redis 的核心同步机制。主服务器（Master）负责处理写请求，从服务器（Slave）复制主服务器的数据，提供读请求服务，实现读写分离与高可用。</p>
<p><strong>1. 主从复制过程</strong></p>
<p><strong>初次复制（全量同步 - RDB 快照）</strong></p>
<ol>
<li>从服务器启动时，向主服务器发送 <code>SYNC</code> 或 <code>PSYNC</code> 命令。</li>
<li>主服务器生成一个 RDB 快照，将快照数据和命令缓存发送给从服务器。</li>
<li>从服务器加载 RDB 文件并重放命令缓存，完成同步。</li>
</ol>
<p><strong>增量复制（命令流同步）</strong></p>
<ul>
<li>在完成全量同步后，主服务器将执行的写命令通过命令流（Replicas Buffer）发送给从服务器，从服务器实时应用这些命令。</li>
</ul>
<p><strong>2. 主从复制机制中的关键点</strong></p>
<table>
<thead>
<tr>
<th>机制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>复制偏移量</strong></td>
<td>主从间的复制进度，标识数据同步位置。</td>
</tr>
<tr>
<td><strong>复制 ID</strong></td>
<td>标识主服务器实例，用于主从连接恢复。</td>
</tr>
<tr>
<td><strong>命令缓冲区（Backlog）</strong></td>
<td>存储主服务器未同步的命令，用于断线恢复。</td>
</tr>
<tr>
<td><strong>PSYNC</strong></td>
<td>Redis 2.8 引入，支持部分同步。</td>
</tr>
<tr>
<td><strong>SYNC</strong></td>
<td>Redis 旧版的全量同步命令。</td>
</tr>
</tbody></table>
<p><strong>3. 主从复制的触发条件</strong></p>
<ul>
<li>新的从服务器上线。</li>
<li>主从服务器断开连接后恢复。</li>
<li>主服务器重启。</li>
</ul>
<p><strong>4. Redis 主从复制的高可用实现</strong></p>
<ul>
<li><strong>哨兵模式（Sentinel）</strong>：自动主从切换，主服务器故障时从服务器晋升为主服务器。</li>
<li><strong>Redis 集群模式</strong>：多主多从架构，分片管理与故障转移。</li>
</ul>
<p><strong>5. 主从复制的注意事项与优化</strong></p>
<table>
<thead>
<tr>
<th>优化点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>异步复制</strong></td>
<td>Redis 复制是异步的，可能导致数据延迟。</td>
</tr>
<tr>
<td><strong>复制压缩</strong></td>
<td>使用 <code>repl-diskless-sync</code> 减少磁盘 IO。</td>
</tr>
<tr>
<td><strong>复制积压缓冲区大小</strong></td>
<td>调整 <code>repl-backlog-size</code> 优化同步恢复。</td>
</tr>
<tr>
<td><strong>网络优化</strong></td>
<td>配置 <code>tcp-keepalive</code> 保持连接稳定。</td>
</tr>
</tbody></table>
<p><strong>二、持久化同步机制</strong></p>
<p>Redis 提供两种持久化方式，通过 RDB 快照和 AOF 日志将数据保存到磁盘，防止数据丢失。</p>
<p><strong>1. RDB（Redis DataBase）快照</strong></p>
<ul>
<li>定期将内存数据生成快照，保存到磁盘。</li>
<li>恢复时加载 RDB 文件。</li>
</ul>
<p><strong>优点：</strong> 启动恢复快，适合灾难恢复。<br> <strong>缺点：</strong> 数据可能丢失，适合冷备。</p>
<p><strong>2. AOF（Append Only File）日志</strong></p>
<ul>
<li>记录所有写命令，以日志形式存储。</li>
<li>Redis 重启时通过重放日志恢复数据。</li>
</ul>
<p><strong>优点：</strong> 数据安全，几乎无数据丢失。<br> <strong>缺点：</strong> 恢复速度较慢，文件体积较大。</p>
<p><strong>3. 持久化同步策略配置</strong></p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>save</code></td>
<td>RDB 自动保存策略。</td>
</tr>
<tr>
<td><code>appendonly</code></td>
<td>启用 AOF。</td>
</tr>
<tr>
<td><code>appendfsync</code></td>
<td>AOF 持久化策略（always/everysec/no）。</td>
</tr>
<tr>
<td><code>auto-aof-rewrite-min-size</code></td>
<td>自动重写 AOF 文件的最小体积。</td>
</tr>
<tr>
<td><code>repl-diskless-sync</code></td>
<td>启用无磁盘复制（减少 IO 负载）。</td>
</tr>
</tbody></table>
<p><strong>三、Redis 集群同步机制</strong></p>
<p>Redis 集群通过分片（Sharding）管理数据，使用异步复制机制同步主从节点数据：</p>
<ul>
<li>每个分片都有主服务器和多个从服务器。</li>
<li>集群间通过 Gossip 协议交换数据节点信息。</li>
<li>主节点故障时，集群自动触发故障转移。</li>
</ul>
<p><strong>四、Redis 数据同步机制的优势与挑战</strong></p>
<table>
<thead>
<tr>
<th>优势</th>
<th>挑战</th>
</tr>
</thead>
<tbody><tr>
<td>数据同步实时，读写分离支持</td>
<td>异步复制，可能出现数据丢失</td>
</tr>
<tr>
<td>支持高可用主从切换与容灾备份</td>
<td>主从同步时 CPU 与内存负载高</td>
</tr>
<tr>
<td>可配置的持久化与备份策略</td>
<td>磁盘 IO 成为性能瓶颈</td>
</tr>
<tr>
<td>多分片数据分布与负载均衡支持</td>
<td>网络抖动导致同步延迟</td>
</tr>
</tbody></table>
<h3 id="问：Redis-的部署方式了解么？主从，集群？"><a href="#问：Redis-的部署方式了解么？主从，集群？" class="headerlink" title="问：Redis 的部署方式了解么？主从，集群？"></a>问：Redis 的部署方式了解么？主从，集群？</h3><p><strong>Redis 的部署方式：主从复制与集群模式</strong></p>
<p>Redis 提供了多种部署方式，其中最常见的是 <strong>主从复制</strong> 和 <strong>Redis 集群</strong>。这两种部署方式在高可用性、性能优化、容错等方面具有不同的特性和应用场景。下面详细介绍这两种部署方式及其特点。</p>
<p><strong>1. Redis 主从复制（Master-Slave）</strong></p>
<p><strong>1.1 主从复制概念</strong></p>
<ul>
<li><strong>主节点（Master）</strong>：负责接收客户端的写请求（写操作）。</li>
<li><strong>从节点（Slave）</strong>：通过复制主节点的数据来进行数据同步，主要用于处理读请求，减轻主节点的压力。</li>
</ul>
<p><strong>1.2 主从复制工作原理</strong></p>
<ul>
<li>在 Redis 中，主从复制是通过异步复制实现的：当主节点数据发生变化时，会将这些变化同步到从节点。</li>
<li>从节点会定期向主节点发送 <code>SYNC</code> 命令以获得最新的数据快照，之后保持同步更新。</li>
<li>每个从节点只能与一个主节点连接，但一个主节点可以有多个从节点。</li>
</ul>
<p><strong>1.3 优缺点</strong></p>
<p><strong>优点</strong></p>
<ul>
<li><strong>读写分离</strong>：主节点负责写操作，从节点负责读操作，能够减轻主节点的负担，提高系统的读性能。</li>
<li><strong>高可用性</strong>：通过设置多个从节点，保证在主节点故障时可以快速切换到从节点。</li>
<li><strong>数据冗余</strong>：从节点存有主节点的完整数据，可以在主节点故障时提供数据恢复。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>主节点瓶颈</strong>：所有的写操作都集中在主节点进行，随着业务增长可能导致主节点性能瓶颈。</li>
<li><strong>异步复制延迟</strong>：主从复制采用的是异步复制，数据可能在主节点和从节点之间有延迟。</li>
</ul>
<p><strong>1.4 主从复制的应用场景</strong></p>
<ul>
<li><strong>读操作占比大于写操作</strong>：典型的电商、广告系统等。</li>
<li><strong>高可用要求</strong>：通过增加从节点，提高可用性。</li>
<li><strong>数据冗余要求</strong>：从节点可以作为备份，提高容灾能力。</li>
</ul>
<p><strong>2. Redis 集群（Redis Cluster）</strong></p>
<p><strong>2.1 Redis 集群概念</strong></p>
<p>Redis 集群是 Redis 官方支持的分布式部署方式，它通过分片机制将数据分布到多个节点上，从而实现高可用和高性能的 Redis 集群。</p>
<p><strong>2.2 集群架构</strong></p>
<ul>
<li><strong>节点分片</strong>：Redis 集群将数据分布到多个节点（主节点）上，每个节点负责存储数据的一部分。数据通过 <strong>哈希槽（hash slot）</strong> 分配到不同的节点。Redis 集群有 16384 个哈希槽，数据通过哈希算法分配到这些槽中。</li>
<li><strong>复制与高可用性</strong>：每个主节点都可以有一个或多个从节点，从节点用来备份主节点的数据，并且可以在主节点故障时接管工作。</li>
<li><strong>无中心节点</strong>：Redis 集群是一个去中心化的架构，节点之间是平等的。没有单点的 Master-Slave 结构，集群中每个节点都是独立的。</li>
</ul>
<p><strong>2.3 Redis 集群工作原理</strong></p>
<ul>
<li><strong>数据分片</strong>：每个 Redis 集群的节点都负责管理一定范围的哈希槽（从 0 到 16383）。客户端请求 Redis 集群时，会根据请求的键计算哈希槽，并将请求转发到对应的节点。</li>
<li><strong>故障转移</strong>：如果主节点不可用，Redis 集群会自动将一个从节点提升为主节点。集群内部有一套选举机制来保证高可用性。</li>
</ul>
<p><strong>2.4 优缺点</strong></p>
<p><strong>优点</strong></p>
<ul>
<li><strong>水平扩展</strong>：通过增加更多节点来扩展存储和处理能力。集群支持自动数据分片，增加节点可以方便地提升性能和容量。</li>
<li><strong>高可用性</strong>：Redis 集群自带故障转移功能，如果主节点故障，集群会自动将从节点升级为主节点，确保服务持续运行。</li>
<li><strong>高性能</strong>：集群通过分片技术减少了单个节点的负载，可以分摊请求，提高系统的整体性能。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>复杂性增加</strong>：集群模式比单机模式和主从模式要复杂得多，配置和维护需要更高的技术能力。</li>
<li><strong>数据迁移</strong>：当节点添加或删除时，需要进行数据迁移，这会带来一定的性能开销。</li>
<li><strong>一致性问题</strong>：虽然 Redis 集群提供高可用性，但在一些情况下，它可能不提供严格的一致性。由于节点的故障转移和数据分片，可能会出现短时间的数据不一致。</li>
</ul>
<p><strong>2.5 Redis 集群的应用场景</strong></p>
<ul>
<li><strong>大规模分布式应用</strong>：当业务量增长到单机 Redis 无法承载时，Redis 集群提供了水平扩展的能力。</li>
<li><strong>高并发、高吞吐量应用</strong>：如大规模电商网站、社交网络、搜索引擎等需要处理大量数据和请求的系统。</li>
<li><strong>高可用性和容错性要求</strong>：对于一些需要高可用且对数据不丢失有严格要求的系统，Redis 集群提供了高可用性。</li>
</ul>
<p><strong>3. Redis 部署方式的对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>主从复制</strong></th>
<th><strong>Redis 集群</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>架构类型</strong></td>
<td>主节点与从节点（Master-Slave）</td>
<td>数据分片（Sharding）</td>
</tr>
<tr>
<td><strong>数据分布</strong></td>
<td>同步复制，所有数据存储在主节点</td>
<td>数据通过哈希槽分布在多个节点</td>
</tr>
<tr>
<td><strong>读写分离</strong></td>
<td>主节点负责写操作，从节点负责读</td>
<td>读写都可以分布到多个主节点</td>
</tr>
<tr>
<td><strong>高可用性</strong></td>
<td>从节点备份主节点数据，支持主从切换</td>
<td>自动故障转移，节点间复制</td>
</tr>
<tr>
<td><strong>水平扩展</strong></td>
<td>不支持自动分片，增加节点需手动分配</td>
<td>支持自动水平扩展，数据分片</td>
</tr>
<tr>
<td><strong>复杂性</strong></td>
<td>相对简单，配置和维护较容易</td>
<td>配置复杂，需要更多的运维管理</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适合小型中型应用，读多写少</td>
<td>适合大规模应用，需要分布式存储和高并发处理</td>
</tr>
</tbody></table>
<p><strong>4. 总结</strong></p>
<ul>
<li><strong>主从复制</strong>适合数据量较小，读多写少的场景，配置简单，容易维护，适合业务规模较小的应用。</li>
<li><strong>Redis 集群</strong>适用于大规模、高并发的分布式系统，支持数据分片和水平扩展，具有更高的可用性和容错能力，适合高并发和大数据量场景。</li>
</ul>
<p>选择哪种部署方式应根据业务需求、数据量、集群的规模和维护能力来决定。对于大部分中小型业务，<strong>主从复制</strong>可能就足够了；而对于大规模、高可用、高性能的需求，<strong>Redis 集群</strong>是更合适的选择。</p>
<h3 id="问：Redis主从机制了解么？怎么实现的？"><a href="#问：Redis主从机制了解么？怎么实现的？" class="headerlink" title="问：Redis主从机制了解么？怎么实现的？"></a>问：Redis主从机制了解么？怎么实现的？</h3><hr>
<h4 id="一、复制拓扑结构"><a href="#一、复制拓扑结构" class="headerlink" title="一、复制拓扑结构"></a><strong>一、复制拓扑结构</strong></h4><p>Redis主从复制支持多种拓扑结构，适应不同场景下的数据同步与高可用需求：</p>
<table>
<thead>
<tr>
<th align="left"><strong>拓扑类型</strong></th>
<th align="left"><strong>架构描述</strong></th>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
<th align="left"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>一主一从</strong></td>
<td align="left">单个主节点（Master）与单个从节点（Slave）组成。</td>
<td align="left">架构简单，适合数据备份与故障转移。</td>
<td align="left">读扩展能力有限，主节点故障需手动切换。</td>
<td align="left">小型系统、数据冷备场景。</td>
</tr>
<tr>
<td align="left"><strong>一主多从</strong></td>
<td align="left">单个主节点连接多个从节点（如1主3从）。</td>
<td align="left">显著提升读吞吐量，支持读写分离。</td>
<td align="left">主节点写压力集中，网络带宽可能成为瓶颈。</td>
<td align="left">高并发读场景（如电商商品详情页）。</td>
</tr>
<tr>
<td align="left"><strong>树状主从</strong></td>
<td align="left">从节点作为其他从节点的主节点，形成层级结构（如主 → 从1 → 从2）。</td>
<td align="left">减轻主节点同步压力，优化网络带宽使用。</td>
<td align="left">数据同步延迟层级叠加，故障排查复杂度增加。</td>
<td align="left">跨地域多机房部署（如主在中心机房，从节点分布边缘节点）。</td>
</tr>
</tbody></table>
<hr>
<h4 id="二、复制配置与管理"><a href="#二、复制配置与管理" class="headerlink" title="二、复制配置与管理"></a><strong>二、复制配置与管理</strong></h4><h5 id="1-建立复制"><a href="#1-建立复制" class="headerlink" title="1. 建立复制"></a><strong>1. 建立复制</strong></h5><ul>
<li><p><strong>命令方式</strong>：通过<code>SLAVEOF</code>或<code>REPLICAOF</code>（Redis 5.0+）配置从节点连接主节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在从节点执行</span></span><br><span class="line">127.0.0.1:6380&gt; REPLICAOF 192.168.1.100 6379</span><br></pre></td></tr></table></figure></li>
<li><p><strong>配置文件</strong>：在从节点<code>redis.conf</code>中设置主节点信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicaof 192.168.1.100 6379</span><br><span class="line">masterauth &lt;password&gt;  <span class="comment"># 若主节点有密码</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-断开复制"><a href="#2-断开复制" class="headerlink" title="2. 断开复制"></a><strong>2. 断开复制</strong></h5><ul>
<li><strong>临时断开</strong>：从节点执行<code>REPLICAOF NO ONE</code>，保留现有数据，停止同步。</li>
<li><strong>永久断开</strong>：移除配置文件中的<code>replicaof</code>并重启。</li>
</ul>
<h5 id="3-只读模式"><a href="#3-只读模式" class="headerlink" title="3. 只读模式"></a><strong>3. 只读模式</strong></h5><ul>
<li><strong>默认行为</strong>：从节点为只读模式（<code>replica-read-only yes</code>），拒绝所有写操作。</li>
<li><strong>风险操作</strong>：可通过<code>CONFIG SET replica-read-only no</code>临时允许写入，但数据会被主从同步覆盖。</li>
</ul>
<h5 id="4-传输延迟优化"><a href="#4-传输延迟优化" class="headerlink" title="4. 传输延迟优化"></a><strong>4. 传输延迟优化</strong></h5><ul>
<li><p><strong>网络优化</strong>：主从节点部署在同一机房或使用高速内网。</p>
</li>
<li><p><strong>参数调优</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主节点配置（减少全量同步频率）</span></span><br><span class="line">repl-backlog-size 1GB     <span class="comment"># 增大复制积压缓冲区</span></span><br><span class="line">repl-diskless-sync yes    <span class="comment"># 无盘复制（适用于磁盘IO慢的场景）</span></span><br><span class="line"><span class="comment"># 从节点配置</span></span><br><span class="line">repl-ping-replica-period 10  <span class="comment"># 从节点心跳间隔（默认10秒）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="三、主从复制原理与流程"><a href="#三、主从复制原理与流程" class="headerlink" title="三、主从复制原理与流程"></a><strong>三、主从复制原理与流程</strong></h4><h5 id="1-主从复制六步流程"><a href="#1-主从复制六步流程" class="headerlink" title="1. 主从复制六步流程"></a><strong>1. 主从复制六步流程</strong></h5><ol>
<li><strong>保存主节点信息</strong><ul>
<li>从节点持久化主节点的IP、端口、认证密码到本地，重启后自动重连。</li>
</ul>
</li>
<li><strong>建立Socket连接</strong><ul>
<li>从节点向主节点发起Socket连接，默认端口6379。若主节点防火墙限制，需开放端口。</li>
</ul>
</li>
<li><strong>发送PING命令</strong><ul>
<li>连接建立后，从节点发送PING检测主节点是否可用。若收到<code>PONG</code>则继续，否则重试。</li>
</ul>
</li>
<li><strong>权限验证</strong><ul>
<li>若主节点配置<code>requirepass</code>，从节点需通过<code>masterauth</code>配置正确密码，否则复制终止。</li>
</ul>
</li>
<li><strong>数据同步</strong><ul>
<li><strong>全量同步</strong>：从节点首次连接或复制中断后无法部分同步时触发。</li>
<li><strong>部分同步</strong>：复制中断后，从节点偏移量仍在主节点积压缓冲区内时触发。</li>
</ul>
</li>
<li><strong>命令持续复制</strong><ul>
<li>全量同步完成后，主节点将新写入命令异步发送给从节点（基于长连接）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="四、数据同步机制"><a href="#四、数据同步机制" class="headerlink" title="四、数据同步机制"></a><strong>四、数据同步机制</strong></h4><h5 id="1-全量同步（Full-Sync）"><a href="#1-全量同步（Full-Sync）" class="headerlink" title="1. 全量同步（Full Sync）"></a><strong>1. 全量同步（Full Sync）</strong></h5><p><strong>流程说明</strong>：</p>
<ol>
<li>从节点发送<code>PSYNC ? -1</code>请求全量同步。</li>
<li>主节点执行<code>BGSAVE</code>生成RDB快照，同时缓存新写入命令至<strong>复制缓冲区</strong>。</li>
<li>RDB文件生成后，主节点将其发送给从节点。</li>
<li>从节点清空旧数据，加载RDB文件。</li>
<li>主节点发送复制缓冲区的增量命令，从节点执行以保持数据最新。</li>
</ol>
<p><strong>问题与优化</strong>：</p>
<ul>
<li><strong>主节点性能压力</strong>：<code>BGSAVE</code>可能导致CPU/内存飙升，建议低峰期操作或使用无盘复制。</li>
<li><strong>网络带宽占用</strong>：大数据量时RDB传输耗时，可升级网络或分片集群。</li>
</ul>
<h5 id="2-部分同步（Partial-Sync）"><a href="#2-部分同步（Partial-Sync）" class="headerlink" title="2. 部分同步（Partial Sync）"></a><strong>2. 部分同步（Partial Sync）</strong></h5><p><strong>流程说明</strong>：</p>
<ol>
<li>从节点发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>，其中<code>runid</code>为主节点ID，<code>offset</code>为当前复制偏移量。</li>
<li>主节点检查<code>offset</code>是否在<strong>复制积压缓冲区</strong>（<code>repl_backlog</code>）范围内。</li>
<li>若存在，主节点发送缓冲区中从<code>offset</code>到最新的所有命令，从节点执行。</li>
<li>若不存在（缓冲区被覆盖），触发全量同步。</li>
</ol>
<p><strong>关键参数</strong>：</p>
<ul>
<li><code>repl-backlog-size</code>：缓冲区大小（建议设置为平均网络中断时间 * 主节点写入QPS）。</li>
<li><code>repl-backlog-ttl</code>：缓冲区保留时长（默认1小时）。</li>
</ul>
<h5 id="3-心跳机制"><a href="#3-心跳机制" class="headerlink" title="3. 心跳机制"></a><strong>3. 心跳机制</strong></h5><ul>
<li><strong>主 → 从心跳</strong>：每10秒发送<code>PING</code>，检测从节点存活状态。</li>
<li><strong>从 → 主心跳</strong>：每秒发送<code>REPLCONF ACK &lt;offset&gt;</code>，上报自身复制偏移量，主节点据此计算延迟。</li>
</ul>
<h5 id="4-异步复制机制"><a href="#4-异步复制机制" class="headerlink" title="4. 异步复制机制"></a><strong>4. 异步复制机制</strong></h5><ul>
<li><strong>流程</strong>：主节点处理写命令后，立即返回客户端，随后异步将命令发送给从节点。</li>
<li><strong>风险</strong>：主节点宕机可能导致未同步数据丢失（可通过<code>WAIT</code>命令实现半同步，但影响性能）。</li>
</ul>
<hr>
<h4 id="五、主从复制状态监控"><a href="#五、主从复制状态监控" class="headerlink" title="五、主从复制状态监控"></a><strong>五、主从复制状态监控</strong></h4><h5 id="1-关键命令"><a href="#1-关键命令" class="headerlink" title="1. 关键命令"></a><strong>1. 关键命令</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主节点复制信息</span></span><br><span class="line">127.0.0.1:6379&gt; INFO replication</span><br><span class="line"><span class="comment"># 查看从节点列表及状态</span></span><br><span class="line">Connected slaves: 2</span><br><span class="line">slave0: ip=192.168.1.101,port=6380,state=online,offset=123456,lag=0</span><br><span class="line">slave1: ip=192.168.1.102,port=6381,state=online,offset=123456,lag=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看主从延迟（lag单位为秒）</span></span><br></pre></td></tr></table></figure>

<h5 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2. 异常处理"></a><strong>2. 异常处理</strong></h5><ul>
<li><strong>从节点延迟过高</strong>：<ul>
<li>排查主节点写入压力，优化大Key或批量操作。</li>
<li>升级从节点硬件或调整<code>repl-backlog-size</code>。</li>
</ul>
</li>
<li><strong>主从断连</strong>：<ul>
<li>检查网络连通性（<code>telnet</code>、<code>ping</code>）。</li>
<li>查看主节点日志，确认是否因认证失败或缓冲区不足触发全量同步。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="六、生产环境最佳实践"><a href="#六、生产环境最佳实践" class="headerlink" title="六、生产环境最佳实践"></a><strong>六、生产环境最佳实践</strong></h4><ol>
<li><strong>读写分离</strong>：<ul>
<li>写请求仅发送到主节点，读请求分散到多个从节点。</li>
<li>使用代理中间件（如Predixy）自动路由请求。</li>
</ul>
</li>
<li><strong>高可用架构</strong>：<ul>
<li>结合Sentinel实现自动故障转移，避免手动切换主从。</li>
<li>跨机房部署时，优先选择树状拓扑减少主节点出口带宽压力。</li>
</ul>
</li>
<li><strong>监控告警</strong>：<ul>
<li>监控<code>master_link_status</code>（up/down）、<code>master_last_io_seconds_ago</code>（心跳延迟）。</li>
<li>配置报警规则（如从节点延迟超过10秒触发告警）。</li>
</ul>
</li>
<li><strong>安全加固</strong>：<ul>
<li>主节点开启<code>requirepass</code>，从节点配置<code>masterauth</code>。</li>
<li>使用SSL加密主从通信（Redis 6.0+支持TLS）。</li>
</ul>
</li>
</ol>
<p>全量复制的各个场景进行避免：</p>
<ul>
<li><strong>首次建立复制</strong>：该情况无法避免。<ul>
<li>在对数据量较大且流量较高的主节点添加从节点时，建议在低峰进行操作，或者干脆规避使用大数量的节点。</li>
</ul>
</li>
<li><strong>节点运行ID不匹配</strong>：当主节点故障重启，其运行ID会改变，从节点发现主节点运行ID不匹配会认为自己复制的是一个新节点导致进行全量复制。<ul>
<li>避免这种情况需要在架构上规避，如提供故障转移功能，在主节点发生故障后，手动提升从节点为主节点，或采用支持自动故障转移的哨兵或集群方案。</li>
</ul>
</li>
<li><strong>复制积压缓冲区不足</strong>：当主从节点网络中断后，从节点再次连接上主节点时会发送 psync 请求部分复制，如果请求的偏移量不在主节点的缓冲区内，则无法提供给从节点数据，导致部分复制退化为全量复制。<ul>
<li>避免这种情况需要根据网络中断时长，写命令数据量分析出合理的积压缓冲区大小。</li>
<li>网络中断一般有闪断、机房割接、网络分区等情况。中断时长一般在分钟级别。</li>
<li>写命令数据量可以统计高峰期主节点每秒的master_repl_offset差值获取。</li>
<li>积压缓冲区默认为1MB，对于大流量场景明显不够，加大缓冲区，保证 repl_backlog_size &gt; net_break_time * write_size_per_minute。</li>
</ul>
</li>
</ul>
<p>复制风暴指大量从节点对同一主节点或同台机器的多个主节点短时间内发起全量复制的场景。会导致相应主节点所在机器造成CPU、内存、带宽等大量开销。</p>
<p>复制风暴的场景：</p>
<ul>
<li><p>单主节点复制风暴：</p>
<p>一般发生在主节点挂载多个从节点的场景。主节点重启恢复后，从节点发起全量复制流程，主节点创建RDB快照，在创建完毕前若有多个从节点都尝试进行全量复制，它们会共享这份RDB。但同时向多个从节点发送RDB文件会使带宽消耗严重，导致主节点延迟变大，极端时使主从节点断开连接。</p>
<ul>
<li>解决方案：首先减少主节点挂载的从节点数量，或采用树状的复制结构，加入中间层从节点保护主节点。网络开销分摊给了中间层，但带来了运维的复杂性，增加了手动和自动处理故障转移的难度。</li>
</ul>
</li>
<li><p>单机器复制风暴：</p>
<p>Redis单线程，所以单台机器常常会部署多个实例。如果这台机器出现故障或网络长时间中断，重启恢复后会有大量从节点对其发起全量复制，导致当前机器带宽耗尽。</p>
<p>解决方案：</p>
<ul>
<li>应该把主节点尽量分散到多台机器上，避免在单台机器上部署过多的节点。</li>
<li>当主节点所在机器发生故障后，提供故障转移机制。</li>
</ul>
</li>
</ul>
<h3 id="问：Redis-的哨兵模式？Reids-Sentinel？"><a href="#问：Redis-的哨兵模式？Reids-Sentinel？" class="headerlink" title="问：Redis 的哨兵模式？Reids Sentinel？"></a>问：Redis 的哨兵模式？Reids Sentinel？</h3><h4 id="1-主从复制的问题"><a href="#1-主从复制的问题" class="headerlink" title="1. 主从复制的问题"></a>1. 主从复制的问题</h4><ol>
<li><strong>手动故障转移</strong>：主节点宕机需人工介入切换从节点，导致服务中断。</li>
<li><strong>单点写压力</strong>：写操作集中在主节点，可能成为性能瓶颈。</li>
<li><strong>数据同步延迟</strong>：从节点同步存在延迟，可能读到旧数据。Redis 主从复制采用异步复制模型，主节点写入数据后，再异步将数据同步到从节点。这种设计存在复制延迟，可能导致在故障发生时，从节点数据落后，造成读取不一致。</li>
</ol>
<hr>
<h4 id="2-Redis-Sentinel-哨兵模式是什么？"><a href="#2-Redis-Sentinel-哨兵模式是什么？" class="headerlink" title="2. Redis Sentinel 哨兵模式是什么？"></a>2. Redis Sentinel 哨兵模式是什么？</h4><p><strong>定义</strong>：分布式监控系统，用于实现Redis主从架构的<strong>高可用</strong>，核心功能包括：</p>
<ul>
<li><strong>监控</strong>：持续检查主从节点状态。哨兵进程持续监控所有被管理的 Redis 实例（包括主节点和从节点）的运行状态和健康状况，通过定期发送 PING/PONG 命令检测节点是否响应。</li>
<li><strong>通知</strong>：向客户端推送新主节点地址。当监控到某个节点宕机或异常时，Sentinel 会通知管理员或其他系统组件。</li>
<li><strong>自动故障转移</strong>：主节点故障时，自动选举新主。当主节点被判定为故障（下线）后，哨兵会在经过一致性判断（达到 quorum 数量的 Sentinel 认为该主节点不可用）后，自动发起故障转移，将一个合适的从节点升级为新的主节点，并更新其他从节点的复制配置。</li>
<li><strong>服务发现</strong><br>客户端可以通过 Sentinel 查询当前的 master 地址，从而实现自动切换到新的 master。</li>
</ul>
<hr>
<h4 id="3-如何搭建-Redis-Sentinel"><a href="#3-如何搭建-Redis-Sentinel" class="headerlink" title="3. 如何搭建 Redis Sentinel"></a>3. 如何搭建 Redis Sentinel</h4><p><strong>3.1 Sentinel 配置文件</strong></p>
<p>在 Redis Sentinel 配置文件（通常名为 <code>sentinel.conf</code>）中，最关键的配置项是 <code>sentinel monitor</code>，其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br><span class="line"># sentinel.conf</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2  # 监控主节点，法定人数为2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000  # 5秒无响应判定主观下线</span><br></pre></td></tr></table></figure>

<p>这表示 Sentinel 将监控名为 <code>mymaster</code> 的主节点，地址是 <code>127.0.0.1:6379</code>，当至少 2 个 Sentinel 实例同时报告该主节点故障时，认为该主节点已经不可用。</p>
<p><strong>3.2 启动 Sentinel 节点</strong></p>
<p>启动 Sentinel 时，指定配置文件即可，例如在命令行中运行：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server <span class="regexp">/path/</span>to/sentinel.conf --sentinel</span><br><span class="line"><span class="regexp">//</span> 或</span><br><span class="line">redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>

<p>如果搭建多个 Sentinel 节点（建议至少 3 个以保证可靠性），分别启动并指定相同的监控配置。</p>
<p><strong>3.3 确认 Sentinel 状态</strong></p>
<p>向主从节点发<code>INFO</code>，获取拓扑信息。使用 Redis 命令行工具可以查询 Sentinel 的状态，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有被 Sentinel 监控的主节点信息</span></span><br><span class="line">redis-cli -p &lt;sentinel_port&gt; SENTINEL masters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个主节点的从节点信息</span></span><br><span class="line">redis-cli -p &lt;sentinel_port&gt; SENTINEL slaves mymaster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Sentinel 自身的状态（包括投票、故障信息等）</span></span><br><span class="line">redis-cli -p &lt;sentinel_port&gt; SENTINEL sentinels mymaster</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-Sentinel-的实现原理"><a href="#4-Sentinel-的实现原理" class="headerlink" title="4. Sentinel 的实现原理"></a>4. Sentinel 的实现原理</h4><p>Redis Sentinel 的核心工作原理可以分为以下几个阶段：</p>
<p><strong>4.1 三个定时监控任务</strong></p>
<ul>
<li><p>周期性监控任务</p>
<p>Sentinel 内部启动多个定时任务来监控 Redis 节点的状态，常见的任务包括：</p>
<ol>
<li><strong>每隔10秒的监控任务</strong>：向主从节点发<code>INFO</code>，获取拓扑信息。负责周期性检查各个节点的整体状态、内存、负载等指标，进行健康评估。</li>
<li><strong>每隔2秒的监控任务</strong>：通过<code>__sentinel__:hello</code>频道交换节点状态。更频繁地发送 PING 命令，检测节点是否响应，从而及时捕捉节点故障情况。</li>
<li><strong>每隔1秒的监控任务</strong>：向所有节点发<code>PING</code>，检测存活状态。对故障节点进行密集检测，保证在发生网络抖动或临界故障时迅速作出反应。</li>
</ol>
</li>
</ul>
<p><strong>4.2 主观下线与客观下线</strong></p>
<ul>
<li><strong>主观下线（Subjective Down，SDOWN）</strong><br>单个Sentinel判定节点不可达。当某个 Sentinel 自己检测到某个 Redis 节点连续未响应（或响应时间异常），会将该节点标记为主观下线，但还不代表整个系统都认为该节点不可用。</li>
<li><strong>客观下线（Objective Down，ODOWN）</strong><br>超过<code>quorum</code>数量的Sentinel确认主节点下线。当达到 quorum 要求，即足够多的 Sentinel 都报告该节点出现问题时，该节点会被正式标记为客观下线，此时就会触发故障转移流程。</li>
</ul>
<p><strong>4.3 领导者 Sentinel 节点选举与故障转移</strong></p>
<p>基于Raft算法选举出领导者Sentinel执行故障转移。</p>
<ul>
<li>当主节点被客观下线后，所有 Sentinel 会进行一次领导者选举，由其中一个 Sentinel 负责协调故障转移。</li>
<li>领导者 Sentinel 选出一个从节点升级为新的主节点，并通知其他 Sentinel 更新复制关系，完成整个故障转移过程。</li>
</ul>
<p><strong>故障转移步骤</strong>：</p>
<ul>
<li>选择数据最新的从节点作为新主。</li>
<li>向其他从节点发送<code>SLAVEOF</code>命令，指向新主。</li>
<li>更新客户端配置，旧主恢复后成为从节点。</li>
</ul>
<p><strong>4.4 数据同步</strong></p>
<ul>
<li>故障转移后，新主节点会通过重新复制（全量或部分同步）的方式与其他从节点保持数据一致。</li>
<li>Sentinel 会确保所有客户端得知新的主节点地址，以便后续的请求能够正确路由。</li>
</ul>
<hr>
<h4 id="5-Sentinel-客户端"><a href="#5-Sentinel-客户端" class="headerlink" title="5. Sentinel 客户端"></a>5. Sentinel 客户端</h4><p>Redis Sentinel 同时为客户端提供服务发现功能。客户端库（如 Jedis、Lettuce、Redisson）通常内置对 Sentinel 模式的支持，能够自动从 Sentinel 获取当前的主节点地址，实现故障转移后的自动切换。使用 Sentinel 客户端的基本流程是：</p>
<ul>
<li>连接Sentinel获取主节点地址。</li>
<li>订阅Sentinel通知，感知主节点切换。</li>
<li>故障时自动重连到新主节点。</li>
</ul>
<p>例如，使用 Jedis Sentinel 模式的示例代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelExample</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Sentinel节点地址</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinels.<span class="built_in">add</span>(<span class="string">&quot;127.0.0.1:26379&quot;</span>);</span><br><span class="line">        sentinels.<span class="built_in">add</span>(<span class="string">&quot;127.0.0.1:26380&quot;</span>);</span><br><span class="line">        sentinels.<span class="built_in">add</span>(<span class="string">&quot;127.0.0.1:26381&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定监控的主节点名称（与sentinel.conf中配置一致）</span></span><br><span class="line">        JedisSentinelPool sentinelPool = <span class="keyword">new</span> <span class="built_in">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>, sentinels);</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">try</span></span> (Jedis jedis = sentinelPool.<span class="built_in">getResource</span>()) &#123;</span><br><span class="line">            <span class="comment">// 执行Redis操作</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;当前主节点：&quot;</span> + jedis.<span class="built_in">info</span>(<span class="string">&quot;server&quot;</span>));</span><br><span class="line">            jedis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;key=&quot;</span> + jedis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sentinelPool.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Redis集群中Key的定位"><a href="#Redis集群中Key的定位" class="headerlink" title="Redis集群中Key的定位"></a><strong>Redis集群中Key的定位</strong></h4><ol>
<li><p><strong>分片机制</strong>：</p>
<ul>
<li>Key通过<code>CRC16(key) % 16384</code>计算哈希槽（Slot）。</li>
<li>每个节点负责一部分槽位。</li>
</ul>
</li>
<li><p><strong>定位步骤</strong>：</p>
<ul>
<li><p><strong>客户端计算槽位</strong>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CLUSTER</span> KEYSLOT <span class="string">&quot;your_key&quot;</span>  <span class="comment"># 返回槽位编号</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>查找槽位所在节点</strong>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CLUSTER</span> NODES  <span class="comment"># 查看所有节点及其负责的槽位范围</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>直接重定向</strong>：客户端访问错误节点时，会收到<code>MOVED</code>响应，包含正确节点地址。</p>
</li>
</ul>
</li>
<li><p><strong>智能客户端</strong>：缓存槽位与节点映射关系，直接路由请求，减少重定向。</p>
</li>
</ol>
<p>在 Redis 哨兵模式下，实际上并没有涉及到 <strong>数据分片</strong>（即将数据分布在多个 Redis 实例上）。哨兵模式本质上是一个高可用方案，它的主要功能是监控 Redis 实例的健康状态，并在主节点（Master）发生故障时，自动将一个从节点（Slave）提升为新的主节点，实现故障转移（Failover）。</p>
<p>哨兵模式并不支持水平扩展，也就是说，所有的 Redis 节点仍然是单点存储，所有的 <strong>key</strong> 都保存在单个 Redis 实例的内存中。如果数据量较大，仍然是单个 Redis 实例来存储，无法像 Redis 集群那样自动分片。</p>
<h4 id="Redis-哨兵模式下如何找到-key"><a href="#Redis-哨兵模式下如何找到-key" class="headerlink" title="Redis 哨兵模式下如何找到 key"></a><strong>Redis 哨兵模式下如何找到 key</strong></h4><ol>
<li><strong>单节点存储</strong>：在没有开启 Redis 集群的情况下，所有的 key 都存在 <strong>Master</strong> 节点中。客户端直接连接主节点（Master），并请求该节点存取对应的 key。哨兵只是用来保证 Redis 的高可用性，确保如果 Master 节点宕机，能够自动将一个 Slave 节点升级为新的 Master，继续提供服务。客户端连接的目标节点会根据当前的主节点变化而变化。</li>
<li><strong>哨兵的作用</strong>：<ul>
<li><strong>监控</strong>：哨兵定期监控主节点的状态。</li>
<li><strong>故障转移</strong>：如果检测到主节点故障，哨兵会自动提升一个从节点为新的主节点，并更新相关配置。</li>
<li><strong>通知</strong>：当主节点变更时，哨兵会通知客户端，客户端根据新的配置连接到新的主节点。</li>
</ul>
</li>
<li><strong>客户端与 Redis 哨兵的交互</strong>： 客户端通过 Redis 哨兵获取 <strong>主节点地址</strong>，然后通过该主节点来进行数据操作。当发生故障转移时，哨兵会通知客户端进行主节点切换。</li>
</ol>
<p><strong>Redis 哨兵模式的工作流程简述</strong>：</p>
<ul>
<li>客户端请求数据时，通过连接到 Redis 哨兵获取当前主节点的 IP 和端口。</li>
<li>哨兵持续监控 Redis 主节点和从节点。</li>
<li>如果检测到主节点宕机，哨兵会发起故障转移，并将一个从节点提升为新的主节点。</li>
<li>故障转移完成后，哨兵会通知客户端和集群中的其他节点更新主节点信息。</li>
</ul>
<p><strong>与 Redis 集群模式的区别</strong></p>
<ul>
<li><strong>Redis 集群模式</strong>：在 Redis 集群模式下，数据会被 <strong>分片</strong> 存储在不同的节点上，每个 Redis 节点负责一部分的哈希槽（16384个槽）。每个 <strong>key</strong> 会通过计算其哈希值来确定存储在哪个节点。Redis 集群支持水平扩展，可以将数据分散到多个节点中，支持自动故障转移和数据重分布。</li>
<li><strong>Redis 哨兵模式</strong>：哨兵模式主要是用来管理单一的 Redis 实例，保证高可用性。它不支持数据的分片，所有数据仍然存储在主节点上，哨兵负责监控主从节点的状态，自动进行故障转移。</li>
</ul>
<p><strong>总结</strong></p>
<p>在 Redis 哨兵模式下，<strong>key</strong> 的存储位置通常就是主节点（Master）所在的 Redis 实例，因为哨兵模式本身不支持分片。如果主节点故障，哨兵会将一个从节点提升为主节点，并通知客户端更新连接地址。Redis 哨兵只是解决高可用问题，不涉及数据的分布和水平扩展。如果需要数据分片和扩展性，应该使用 <strong>Redis 集群</strong> 模式。</p>
<h3 id="问：Redis集群？模式性能优化？什么是哈希槽？一个-key-值如何在-redis-集群中找到存储在哪？"><a href="#问：Redis集群？模式性能优化？什么是哈希槽？一个-key-值如何在-redis-集群中找到存储在哪？" class="headerlink" title="问：Redis集群？模式性能优化？什么是哈希槽？一个 key 值如何在 redis 集群中找到存储在哪？"></a>问：Redis集群？模式性能优化？什么是哈希槽？一个 key 值如何在 redis 集群中找到存储在哪？</h3><h4 id="一、集群前置知识"><a href="#一、集群前置知识" class="headerlink" title="一、集群前置知识"></a>一、集群前置知识</h4><h5 id="1-数据分布理论"><a href="#1-数据分布理论" class="headerlink" title="1. 数据分布理论"></a>1. 数据分布理论</h5><p>分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题。重点就是分区规则，常见有哈希和顺序两种。哈希离散度好、数据分区与业务无关、无法顺序访问。顺序则离散度低易倾斜、数据分布与业务相关、可顺序访问。</p>
<ul>
<li><p><strong>节点取余分区</strong>：传统简单的分区方法，哈希分区。</p>
<p>根据 key 的哈希值对节点数N取余 <code>hash(key)%N</code> ，将数据均匀分配到各个节点上。</p>
<ul>
<li>缺点：当节点数量发生变化时，数据迁移量大。Rehash操作的损耗。</li>
</ul>
</li>
<li><p><strong>一致性哈希分区</strong>：利用一致性哈希算法，将 key 映射到一个哈希环上，再将节点散列到该环上。这样，节点增加或减少时，只需要迁移少量数据。</p>
<p>为系统每一个节点分配一个token，范围一般在0~23之间，这些token构成一个哈希环。先根据key计算hash，然后顺时针找到第一个大于等于此hash的token节点。加入和删除节点只影响哈希环中相邻的节点。</p>
<ul>
<li>优点：数据迁移量小；</li>
<li>缺点：可能出现数据分布不均衡的问题。<ul>
<li>不适合少量节点，节点变化会大范围影响哈希环中数据映射。</li>
<li>增加节点只能对下一个相邻节点有比较好的负载分担效果。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>虚拟一致性哈希分区</strong>：在一致性哈希基础上引入虚拟节点，每个实际节点对应多个虚拟节点，从而更均衡地分布 key。</p>
<p>为了使增删节点时，各个节点保持动态的平衡，将每个真实节点虚拟出若干虚拟节点，再将这些虚拟节点随机映射到环上，真实节点则不映射到环而只是用来存储键值对，负责接应各自的一组环上虚拟节点。对键值对进行存取路由时，首先路由到虚拟节点，再找到真实节点。</p>
<ul>
<li>例如，每个物理节点映射 100 个虚拟节点，这100个虚拟节点随机分散在环上，减小单个节点负载波动。</li>
</ul>
</li>
<li><p><strong>虚拟槽分区</strong><br>Redis Cluster 并非直接使用一致性哈希，而是将整个 keyspace 分为 16384 个虚拟槽（slot）。每个 key 根据 CRC16 算法取模后得到对应的槽号，再将槽分配给具体的节点。</p>
<p>使用分散度良好的哈希函数将所有数据映射到一个固定范围的整数集合中，整数被定义为槽（slot）。这个范围一般远远大于节点数（0~16383）。槽是集群内数据管理和迁移的基本单位，大范围槽方便数据拆分和集群扩展，每个节点都会负责一定数量的槽。</p>
<ul>
<li><strong>为什么槽的范围是 0~16383？</strong>这是一个历史设计和经验值。16384 槽提供了足够的划分粒度，可以较均衡地分布数据，同时当集群节点发生变动时，只需要迁移部分槽的数据。若槽为65536，发送心跳信息的消息头将达到8k，非常浪费带宽。集群节点数量一般也不建议超过1000个，否则会导致网络拥挤。对于1000以内的节点，16384个槽足够使用。</li>
<li>比如集群有3个节点，则每个节点平均大概负责5460个槽</li>
<li>虚拟槽方式既简化了实现，也使得节点扩容、收缩时的数据迁移变得更简单、可控。</li>
</ul>
</li>
</ul>
<h5 id="2-Redis-数据分区"><a href="#2-Redis-数据分区" class="headerlink" title="2. Redis 数据分区"></a>2. Redis 数据分区</h5><ul>
<li>Redis 虚拟槽分区的特点<ul>
<li>每个 key 都映射到 0～16383 范围内的一个槽。</li>
<li>集群中的每个节点负责一部分连续或不连续的槽。</li>
<li>当节点变动（扩容、缩容、故障转移）时，迁移的是槽的所有数据，而不是单个 key。</li>
<li>计算公式：<code>slot=CRC16(key)&amp;16383</code> </li>
</ul>
</li>
<li>集群功能限制<ul>
<li>集群模式下，不支持单个 multi/exec 事务跨多个节点；</li>
<li>脚本（Lua）也受限于单个槽；</li>
<li>某些命令（如 keys）受到分片限制，需要通过客户端聚合处理。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="二、搭建集群"><a href="#二、搭建集群" class="headerlink" title="二、搭建集群"></a>二、搭建集群</h4><h5 id="1-节点配置"><a href="#1-节点配置" class="headerlink" title="1. 节点配置"></a>1. 节点配置</h5><ul>
<li><p>每个 Redis 实例配置 <code>cluster-enabled yes</code>、<code>cluster-config-file nodes.conf</code>、<code>cluster-node-timeout</code> 等参数。</p>
</li>
<li><p>配置文件示例（redis.conf）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 节点端口</span><br><span class="line">port 6379</span><br><span class="line"># 开启集群模式</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 节点超时时间，单位毫秒</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"># 集群内部配置文件，命名规则redis-&#123;port&#125;.conf</span><br><span class="line">cluster-config-file &quot;nodes-6379.conf&quot;</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></li>
<li><p>对于多节点部署，确保不同实例使用不同端口，且实例间网络互通。</p>
</li>
<li><p>依次启动所有节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server conf/redis-6379.conf</span><br><span class="line">......</span><br><span class="line">$ redis-server conf/redis-6384.conf</span><br><span class="line"><span class="comment"># 检测节点日志是否正确</span></span><br><span class="line">$ cat <span class="built_in">log</span>/redis-6379.log</span><br></pre></td></tr></table></figure></li>
<li><p>首次启动若没有集群配置文件，会根据cluster-config-file自动创建，通过端口区分不同节点防止同一机器下多个节点彼此覆盖。当集群内节点信息发生变化，如添加节点、节点下线、故障转移等。节点会自动保存集群状态到配置文件中。Redis会自动维持集群配置文件，不需要手动修改。文件中记录的文件ID，是一个40位16进制字符串，用于唯一标识集群内一个节点，不同于运行ID的是只在集群初始化创建一次，后者则每次重启都会变化。</p>
</li>
<li><p>节点之间不知道彼此存在，只能通过<strong>节点握手</strong>才能建立联系。由客户端发起命令：<code>cluster meet &#123;ip&#125; &#123;port&#125;</code> 。异步命令，执行后立即返回。主要作用是交换节点状态信息。</p>
<ol>
<li>节点6379本地创建6380的节点对象，发送meet消息。</li>
<li>节点6380收到消息后，保存并回复pong消息。</li>
<li>之后二者定期通过ping/pong消息进行通信。</li>
</ol>
</li>
<li><p>全部节点建立握手后，集群并不能立即工作，此时处于下线状态，禁止所有的数据读写。被分配的槽是0，因为没有映射的节点，只有所有槽都分配给节点后才进入在线状态。</p>
</li>
<li><p><strong>分配槽</strong>：将所有数据映射到16384个槽中，每个key会映射到固定的槽，之后才能响应和槽相关的命令。通过命令 <code>cluster addslots</code> 为节点分配槽，通过bash批量设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;10923...16383&#125;</span></span><br></pre></td></tr></table></figure>

<p>分配后，集群进入在线状态。</p>
<p>每个节点还需要一个从节点来保证故障时进行转移。首次启动的节点和被分配槽的都是主节点，从节点负责负责主节点槽信息和数据。通过命令 <code>cluster replicate &#123;nodeId&#125;</code> 使节点变为从节点（nodeId为主节点Id）。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6382</span>&gt;cluster replicate cb.......</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6383</span>&gt;cluster replicate 8e.......</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6384</span>&gt;cluster replicate 4b.......</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<h5 id="2-集群创建（redis-trib-rb）"><a href="#2-集群创建（redis-trib-rb）" class="headerlink" title="2. 集群创建（redis-trib.rb）"></a>2. 集群创建（redis-trib.rb）</h5><h6 id="2-1-创建集群（随机主从）"><a href="#2-1-创建集群（随机主从）" class="headerlink" title="2.1 创建集群（随机主从）"></a>2.1 创建集群（随机主从）</h6><ul>
<li><p>使用 Redis 提供的集群创建工具，如 <code>redis-cli --cluster create</code> 命令自动选主选从。</p>
</li>
<li><p>示例命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<p>这里集群中 6 个节点，其中每个主节点配 1 个从节点。</p>
</li>
</ul>
<h5 id="2-2-指定主从节点"><a href="#2-2-指定主从节点" class="headerlink" title="2.2 指定主从节点"></a>2.2 指定主从节点</h5><ul>
<li><p><strong>创建集群主节点</strong>：通过上述命令可以创建主节点，也可以手动配置指定哪些节点作为主。</p>
</li>
<li><p>添加从节点：使用 <code>redis-cli --cluster add-node</code>命令将新节点加入集群，并用 <code>--cluster-slave</code> 指定为从节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-集群管理"><a href="#3-集群管理" class="headerlink" title="3. 集群管理"></a>3. 集群管理</h5><ul>
<li><p>检查集群状态，使用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 cluster info</span><br></pre></td></tr></table></figure></li>
<li><p>查看集群节点信息，使用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 cluster nodes</span><br></pre></td></tr></table></figure></li>
<li><p><strong>修复集群</strong>：如果集群出现不一致或节点故障，可使用 <code>--cluster fix</code> 参数修复集群。</p>
</li>
<li><p><strong>设置集群超时时间</strong>：配置文件中通过 <code>cluster-node-timeout</code> 设置节点超时时间。</p>
</li>
<li><p><strong>集群配置</strong>：使用 <code>redis-cli --cluster</code> 命令行工具管理集群参数、迁移槽等操作。</p>
</li>
</ul>
<hr>
<h4 id="三、集群伸缩"><a href="#三、集群伸缩" class="headerlink" title="三、集群伸缩"></a>三、集群伸缩</h4><h5 id="1-集群扩容"><a href="#1-集群扩容" class="headerlink" title="1. 集群扩容"></a>1. 集群扩容</h5><ul>
<li><p>扩容有三个步骤：</p>
<ol>
<li><p><strong>准备新节点</strong>：启动新的 Redis 实例并启用集群模式。此时新节点为孤儿节点。</p>
</li>
<li><p><strong>加入集群</strong>：新节点在任意节点通过 cluster meet 命令加入到集群。集群间一段时间的交换信息后统一发现新节点。</p>
<p>或者使用工具：</p>
<ul>
<li><strong>主节点扩容</strong>：使用 <code>redis-cli --cluster add-node</code> 将新节点加入为主节点。</li>
<li><strong>从节点扩容</strong>：同理使用 <code>--cluster-slave</code> 参数加入新从节点。</li>
</ul>
</li>
<li><p><strong>迁移槽和数据</strong>：迁移槽的过程集群可以正常提供读写服务。槽是Redis集群数据管理的基本单位，首先要为新节点制定槽的迁移计划，确认原节点有哪些槽要迁移到新节点。迁移计划要确保最终每个节点负责相似数量的槽，从而保证各个节点的数据均匀。</p>
<p>使用  <code>redis-cli --cluster reshard</code> 命令迁移部分槽数据到新节点，平衡数据分布。例如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">cli</span> --<span class="keyword">cluster</span> reshard 127.0.0.1:7000</span><br></pre></td></tr></table></figure>

<p>根据提示输入目标槽范围和目标节点信息。</p>
</li>
</ol>
</li>
<li><p><strong>槽和数据迁移流程</strong>：</p>
<ol>
<li>对目标节点发送 cluster setslot {slot} importing {sourceNodeId} 命令，<strong>让目标节点准备导入槽的数据</strong>。</li>
<li>对源节点发送 cluster setslot {slot} migrating {targetNodeId} 命令，<strong>让源节点准备迁出槽的数据</strong>。</li>
<li>源节点循环执行 cluster getkeysinslot {slot} {count} 命令，<strong>获取count个属于槽 {slot} 的值</strong>。</li>
<li>在源节点执行 migrate {targetIp} {targetPort} “” 0 {timeout} keys {key…} 命令，<strong>把获取的键通过流水线机制批量迁移到目标节点</strong>（该命令在3.0.6版本前只能单个执行，批量可以极大降低网络IO次数）。‘</li>
<li>重复执行步骤3和4直到槽下所有的键值数据迁移到目标节点。</li>
<li>向集群内所有主节点发送 cluster setslot {slot} node {targetNodeId} 命令，<strong>通知槽分配给目标节点</strong>。为了保证槽节点映射及时传播，需要遍历发送给所有主节点更新被迁移的槽执行新节点。</li>
</ol>
</li>
<li></li>
</ul>
<h5 id="2-集群缩容"><a href="#2-集群缩容" class="headerlink" title="2. 集群缩容"></a>2. 集群缩容</h5><ul>
<li><strong>迁移槽和数据</strong>：将要下线节点上的槽数据迁移到其他节点。收缩与扩容迁移方向相反，直接使用 <code>reshard</code> 命令完成槽迁移。</li>
<li><strong>下线节点</strong>：下线节点的槽迁移完毕，剩下就是让集群忘记该节点。使用 <code>redis-cli --cluster del-node</code> 命令将节点移出集群。Redis提供 <code>cluster forget &#123;downNodeId&#125;</code> 命令来实现该功能。节点收到命令后把nodeId指定的节点加入到禁用列表中，有效期为60秒，超过后会再次参加消息交换。线上不建议直接使用该命令下线节点，需要跟大量节点交互，实际操作繁琐且容易遗漏节点。建议使用 <code>redis-trib.rb del-node &#123;host:port&#125; &#123;downNodeId&#125;</code> 命令。</li>
<li>流程：<ul>
<li>首先确定是否有槽，有则需要先迁移到其他节点。</li>
<li>下线节点不再负责槽或是从节点时，可以通知集群其他节点忘记下线的节点，所有节点都忘记后可以关闭。</li>
</ul>
</li>
</ul>
<h5 id="3-迁移相关"><a href="#3-迁移相关" class="headerlink" title="3. 迁移相关"></a>3. 迁移相关</h5><ul>
<li><strong>在线迁移 slot</strong>：利用 <code>reshard</code> 工具进行在线槽迁移。</li>
<li><strong>平衡（rebalance）slot</strong>：使用 <code>redis-cli --cluster rebalance</code> 命令自动平衡集群中各节点的槽分布。</li>
</ul>
<hr>
<h4 id="四、请求路由"><a href="#四、请求路由" class="headerlink" title="四、请求路由"></a>四、请求路由</h4><ul>
<li><strong>请求重定向</strong>：<ul>
<li>集群模式下，Redis接收任何键相关命令时首先要计算对应的槽，再根据槽找到对应节点，若节点是自身则处理键命令；否则回复MOVED重定向错误，通知客户端请求正确的节点。</li>
<li>命令 <code>cluster keyslot &#123;key&#125;</code> 返回key对应的槽。重定向的信息包含键对应的槽以及对应节点地址，方便客户端再向正确节点发送。使用redis-cli命令可以添加 -c 参数支持自动重定向。</li>
<li><strong>计算槽</strong>：客户端通过计算 key 的 CRC16 值对 16384 取模，确定 key 对应的槽，然后查找该槽所在的节点。如果请求落到错误的节点，节点会返回 <code>MOVED</code> 或 <code>ASK</code> 错误，客户端根据错误信息重新定位到正确的节点。</li>
<li><strong>槽节点查找</strong>：集群内通过消息交换，每个节点都知道所有节点的槽信息，保存在clusterState结构中。</li>
</ul>
</li>
<li><strong>call 命令</strong>：部分客户端实现了智能调用，自动处理 <code>MOVED</code> 和 <code>ASK</code> 重定向。</li>
</ul>
<hr>
<h4 id="五、Smart-客户端"><a href="#五、Smart-客户端" class="headerlink" title="五、Smart 客户端"></a>五、Smart 客户端</h4><ul>
<li><strong>Smart 客户端原理</strong>：Smart 客户端（例如 JedisCluster、Redisson）内置了对集群模式的支持，可以自动从 Sentinel 或集群管理节点获取槽映射，自动处理重定向错误。</li>
<li><strong>ASK 重定向</strong>：当槽迁移过程中，新节点尚未接管所有数据时，Redis 会返回 <code>ASK</code> 错误。客户端收到后，会临时向指定节点发送 ASKING 命令，再重试请求。</li>
<li><strong>集群下的 Jedis 客户端：Hash tags</strong>：JedisCluster 支持通过使用 hash tag（例如 <code>&#123;user:1001&#125;</code> 部分），确保同一组 key 被映射到同一个槽，方便事务和批量操作。</li>
</ul>
<hr>
<h4 id="六、集群原理"><a href="#六、集群原理" class="headerlink" title="六、集群原理"></a>六、集群原理</h4><h5 id="1-节点通信"><a href="#1-节点通信" class="headerlink" title="1. 节点通信"></a>1. 节点通信</h5><ul>
<li><strong>通信流程</strong><br>每个 Redis 集群节点之间通过 TCP 进行通信，采用 Gossip 协议定期互相交换状态信息。</li>
<li><strong>Gossip 消息</strong><br>节点通过 Gossip 消息了解其他节点的健康状态、槽分布、复制关系等信息。</li>
<li><strong>节点选择</strong><br>Gossip 协议帮助节点选择故障节点和协调故障转移过程。</li>
</ul>
<h5 id="2-故障转移"><a href="#2-故障转移" class="headerlink" title="2. 故障转移"></a>2. 故障转移</h5><ul>
<li><p><strong>故障发现</strong>：当集群内某个节点出现问题时，需要一种健壮的方式保证识别出节点是否发生故障。故障发现也通过消息传播机制ping/pong来实现。</p>
<ul>
<li><p><strong>主观下线（SDOWN）</strong>：某个节点被单个节点检测为不可用。指某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点意见，可能存在误判情况。</p>
<ul>
<li>每个节点都会定期向其他节点发送ping消息，接收节点回复pong消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。</li>
<li>主观下线流程：<ol>
<li>节点a发送ping消息给节点b，如果通信正常将接收到pong消息，节点a更新最近一次与节点b的通信时间。</li>
<li>如果节点a与节点b通信出现问题则断开连接，下次会进行重连。如果一直通信失败，则节点a记录的与节点b最后通信时间将无法更新。</li>
<li>节点a内的定时任务检测到与节点b最后通信时间超高cluster-node-timeout时，更新本地对节点b的状态为主观下线（pfail）。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>客观下线（ODOWN）</strong>：当超过一定数量的节点确认某节点故障时，该节点被标记为不可用。指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。</p>
<ul>
<li><p>当某个节点判断另个节点主观下线后，相应节点状态会跟随消息在集群内传播。</p>
</li>
<li><p>通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当半数以上持有槽的主节点都标记某个节点是主观下线时，触发客观下线流程。存在两个问题：</p>
<ol>
<li>为什么必须是负责槽的主节点参与故障发现决策？<strong>因为集群模式下只有处理槽的主节点才负责读写请求和集群槽等关键信息维护，而从节点只进行主节点数据和状态信息的复制。</strong></li>
<li>为什么半数以上处理槽的主节点<strong>？必须半数以上是为了应对网络分区，等原因造成的集群分割情况，被分割的小集群因为无法完成从主观下线到客观下线这一关键过程，从而防止小集群完成故障转移之后继续对外提供服务。</strong></li>
</ol>
</li>
<li><p>客观下线流程：</p>
<ol>
<li>当消息体内含有其他节点的pfail状态会判断发送节点的状态，如果发送节点是主节点则对报告的pfail状态处理，从节点则忽略。</li>
<li>找到pfail对应的节点结构，更新clusterNode内部下线报告链表。</li>
<li>根据更新后的下线报告链表尝试进行客观下线。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>故障恢复</strong>：下线节点是持有槽的主节点，需要从它的从节点选一个代替。从节点通过内部定时任务发现其所属主节点进入客观下线，就会触发故障恢复流程。</p>
<ul>
<li><p><strong>资格检查</strong>：判断从节点是否满足提升为主节点的条件。每个从节点检查最后与主节点断开时间，如果超过 cluster-node-time * cluster-slave-validity-factor（默认为10），则该从节点不具备资格。</p>
</li>
<li><p><strong>准备选举</strong>：故障主节点达到 ODOWN 后，集群中的 Sentinel 开始准备选举。从节点具有资格则更新触发故障选举的时间，到达该才继续流程。采用延迟触发机制的原因：通过对多个从节点使用不同选举时间来支持优先级问题，复制偏移量越大说明从节点延迟越低，则其就应该有更高的优先级替代主节点。越高优先级的从节点越早触发故障选举流程。</p>
</li>
<li><p><strong>发起选举</strong>：从节点定时任务检测到达故障选举时间（failover_auth_time），发起选举流程：</p>
<ol>
<li><p>更新配置纪元：</p>
<p>是一个只增不减的整数，每个主节点用其标识自身版本，从节点会复制此纪元。整个集群会维护一个全局的配置纪元（clusterState.currentEpoch），用来记录集群内最大版本。可以通过 <code>cluster ingo</code> 查看配置。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster_current_epoch <span class="regexp">//</span> 集群最大配置纪元</span><br><span class="line">cluster_my_epoch <span class="regexp">//</span> 当前主节点配置纪元</span><br></pre></td></tr></table></figure>

<p>配置纪元随着ping/pong消息在集群内传播，当发送和接收都是主节点且纪元相等表示出现冲突，nodeId更大的一方会递增全局纪元并赋值给当前节点来区分冲突。</p>
<p>作用：</p>
<ul>
<li>标识集群内每个主节点的不同版本和集群最大版本。</li>
<li>每次集群发生重要事件时（指出现新的主节点），从节点竞争选举，都会递增全局配置纪元并赋值给相关主节点，用来记录这一事件。</li>
<li>主节点具有更大配置纪元代表更新的集群状态，当节点间进行ping/pong消息交换时，如出现slots等关键信息不一致时，以配置纪元更大的一方为准，防止过时的消息状态污染集群。</li>
</ul>
<p>应用场景：</p>
<ul>
<li>新节点加入。</li>
<li>槽节点映射冲突检测。</li>
<li>从节点投票选举冲突检测。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>广播选举消息：集群内广播选举消息（FAILOVER_AUTH_REQUEST），并记录已发送过消息的状态，保证该从节点在一个配置纪元内只能发起一次选举。消息内容如同ping消息只是将type类型变为FAILOVER_AUTH_REQUEST。</li>
</ol>
<ul>
<li><p><strong>选举投票</strong>：只有持有槽的主节点才会处理故障选举消息（FAILOVER_AUTH_REQUEST），其在一个配置纪元内都有唯一的选票，接到一个请求投票的从节点消息时回复FAILOVER_AUTH_ACK消息作为投票，相同配置纪元内其他从节点的选举消息将忽略。</p>
<p>投票过程其实是一个领导者选举的过程，每个配置纪元内持有槽的主节点只能投票给一个从节点，只有一个从节点会获得N/2+1的选票。Redis不使用从节点进行领导者选举，因为从节点数必须大于等于3个才能保证凑够N/2+1个节点，将导致从节点资源浪费。使用主节点的方案即使只有一个从节点也可以完成选举。</p>
<p>从节点收集到N/2+1个持有槽的主节点投票时，从节点执行替换主节点操作：</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003180157.jpg"></p>
<p>故障主节点也算在投票数内，所以容易因选票不足导致故障转移失败，部署时需要部署3台物理机以上避免单点问题。</p>
<p><strong>投票作废</strong>：每个配置纪元代表了一次选举周期，如果在开始投票后的cluster-node-time*2时间内从节点没有获取足够数量的投票，则本次选举作废。从节点对配置纪元自增并发起下一轮投票，直到选举成功为止。</p>
</li>
<li><p><strong>替换主节点</strong>：领导者通知所有节点，将一个合适的从节点升级为新的主节点，更新复制关系。</p>
<ol>
<li>当前从节点取消复制变为主节点。</li>
<li>执行clusterDelSlot操作撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽委派给自己。</li>
<li>向集群广播自己的pong消息，通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>故障转移时间</strong>：整个故障转移过程通常在几秒钟内完成，但具体时间取决于集群规模和网络延迟。</p>
<p>估算故障转移时间：</p>
<ol>
<li>主观下线（pfail）识别时间=cluster-node-timeout。</li>
<li>主观下线状态消息传播时间&lt;=cluster-node-timeout/2。消息通信机制对超过cluster-node-timeout/2未通信节点会发起ping消息，消息体在选择包含哪些节点时会优先选取下线状态节点，通常这段时间内能够收集到半数以上主节点的pfail报告从而完成故障发现。</li>
<li>从节点转移时间&lt;=1000毫秒。由于存在延迟发起选举机制，偏移量最大的从节点会最多延迟1秒发起选举。通常第一次选举就会成功，所以从节点执行转移时间在1秒以内。</li>
</ol>
<p>公式：failover-time(毫秒) &lt;= cluster-node-timeout + cluster-node-timeout/2 + 1000 。故障转移时间跟cluster-node-timeout参数息息相关，默认15秒。</p>
</li>
</ul>
<hr>
<h4 id="七、集群管理命令（redis-cli-–cluster）"><a href="#七、集群管理命令（redis-cli-–cluster）" class="headerlink" title="七、集群管理命令（redis-cli –cluster）"></a>七、集群管理命令（redis-cli –cluster）</h4><p>常用命令包括：</p>
<ul>
<li><p>创建集群：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">redis</span>-cli --cluster create &lt;node<span class="number">1</span>&gt; &lt;node<span class="number">2</span>&gt; ... --cluster-replicas <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加节点：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster<span class="built_in"> add-node </span>&lt;newNode&gt; &lt;existingNode&gt; [--cluster-slave]</span><br></pre></td></tr></table></figure></li>
<li><p>迁移槽（reshard）：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">cli</span> --<span class="keyword">cluster</span> reshard &lt;node&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>平衡槽（rebalance）：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">cli</span> --<span class="keyword">cluster</span> rebalance &lt;node&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>删除节点：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-<span class="keyword">node</span> <span class="title">&lt;node</span>&gt; <span class="tag">&lt;nodeId&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="集群原理综述"><a href="#集群原理综述" class="headerlink" title="集群原理综述"></a>集群原理综述</h4><ul>
<li><strong>节点通信</strong><br>通过 Gossip 协议定期交换状态信息，确保每个节点知道集群整体的健康状态和槽分布。</li>
<li><strong>故障转移</strong><br>采用主观下线和客观下线机制进行故障检测，并通过 Sentinel 类似的投票机制完成从节点提升为主节点的过程。</li>
<li><strong>数据迁移</strong><br>当节点增加或减少时，使用 reshard 命令在线迁移槽数据，保证数据均衡分布。</li>
</ul>
<ol>
<li><strong>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</strong></li>
<li><strong>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</strong></li>
<li><strong>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</strong></li>
<li><strong>尽量避免在压力很大的主库上增加从库</strong></li>
<li><strong>主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master - Slave1 - Slave2 - Slave3…</code> 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</strong></li>
</ol>
<h3 id="问：集群不可用场景？Redis如何判断集群不可用？"><a href="#问：集群不可用场景？Redis如何判断集群不可用？" class="headerlink" title="问：集群不可用场景？Redis如何判断集群不可用？"></a>问：集群不可用场景？Redis如何判断集群不可用？</h3><ol>
<li>master挂掉，且当前master没有slave，没有替代方案，则整个集群不可用。</li>
<li>默认集群有16384个槽，任意一个没有指派到节点时，集群都不可用。执行任何键命令都会返回ERROR CLUSTERDOWN Hash slot not served。当持有槽的主节点下线，从故障发现到自动完成转移的期间整个集群都不可用，对于大部分业务都无法容忍，所以会把cluster-require-full-coverage配置为no，主节点故障只影响它负责槽的相关命令执行，而不影响其它主节点可用性。</li>
<li>当访问一个Master和Slave节点都挂掉时，且cluster-require-full-coverage=yes，会提示槽无法获取。</li>
<li>集群超过半数以上master挂掉，无论是否有slave集群进入fail状态。fail掉一个主节点需要一半以上主节点投票通过才可以。</li>
<li>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</li>
</ol>
<p>集群不可用的场景</p>
<ol>
<li><strong>单个 Master 无法替代</strong><ul>
<li><strong>情况描述：</strong> 如果某个 master 节点挂掉，而该 master 没有对应的 slave 或者其 slave 也处于故障状态，则负责该节点槽（slot）的数据将没有备份，导致这部分数据不可用。</li>
<li><strong>后果：</strong> 任何针对这部分槽的命令都会返回错误，整个业务可能因为关键数据不可访问而中断。</li>
</ul>
</li>
<li><strong>槽缺失问题</strong><ul>
<li><strong>情况描述：</strong> Redis 集群要求所有 16384 个槽都必须被某个节点负责。如果任意一个槽未被分配（例如，在故障转移过程中或配置不当时），则对该槽上 key 的任何操作都会返回错误，提示“CLUSTERDOWN Hash slot not served”。</li>
<li>配置影响：<ul>
<li>如果配置项 <code>cluster-require-full-coverage</code> 为 <strong>yes</strong>，那么一旦有任一槽缺失，整个集群都被视为不可用，所有命令都会返回 CLUSTERDOWN 错误。</li>
<li>如果设置为 <strong>no</strong>，则缺槽只会影响对应槽的数据访问，其它槽依然可用，从而降低整体业务中断的风险。</li>
</ul>
</li>
</ul>
</li>
<li><strong>超过半数 Master 节点挂掉</strong><ul>
<li><strong>情况描述：</strong> Redis 集群在进行故障检测时，会根据一定的 quorum 规则判定一个 master 节点是否失效。如果集群中超过半数的 master 节点同时挂掉（无论 slave 状态如何），集群将无法正常提供服务。</li>
<li><strong>后果：</strong> 集群进入 FAIL 状态，所有操作均返回 CLUSTERDOWN。</li>
</ul>
</li>
<li><strong>无复制模式下的节点故障</strong><ul>
<li><strong>情况描述：</strong> 在没有复制（master-slave）模型的简单集群中，如果某个节点挂掉，那么该节点负责的槽区间（例如假设 B 节点负责槽 5501-11000）就会缺失，导致整个集群认为数据不完整。</li>
<li><strong>后果：</strong> 即使其它节点正常，针对缺失槽区间的任何键操作都会报错，集群整体也会被判定为不可用。</li>
</ul>
</li>
</ol>
<p>Redis 如何判断集群不可用</p>
<p>Redis 集群的不可用判断主要依赖以下几个方面：</p>
<ol>
<li><strong>槽完整性检查</strong><ul>
<li>集群模式下，所有 16384 个槽必须都被某个节点负责。</li>
<li>如果任意一个槽没有分配到节点，Redis 在处理请求时会返回错误信息，如 “ERROR CLUSTERDOWN Hash slot not served”，这表明集群处于不完整状态，从而被判定为不可用。</li>
</ul>
</li>
<li><strong>节点故障检测与 quorum 投票机制</strong><ul>
<li><strong>主观下线（SDOWN）：</strong> 每个节点周期性地对其他节点进行健康检测，如果连续几次检测发现某节点无响应，该节点被标记为主观下线。</li>
<li><strong>客观下线（ODOWN）：</strong> 当超过预设数量（quorum）的节点都认为某个 master 节点处于不可用状态时，该 master 将被正式标记为客观下线。</li>
<li>如果故障 master 无法及时转移，且超过半数 master 节点失效，则集群整体将进入不可用状态。</li>
</ul>
</li>
<li><strong>配置参数 <code>cluster-require-full-coverage</code> 的影响</strong><ul>
<li>如果该参数设置为 <strong>yes</strong>，只要有任意槽缺失，整个集群都会报错，判断为不可用。</li>
<li>如果设置为 <strong>no</strong>，集群允许部分槽缺失，只有访问缺失槽数据时才返回错误，整体集群仍然可以处理其它槽的数据请求。</li>
</ul>
</li>
<li><strong>主从同步状态</strong><ul>
<li>当对某个 master 节点及其所有从节点均无法访问时，集群会认为该节点故障，即使其它 master 正常，也会影响到该槽上的数据可用性。</li>
</ul>
</li>
</ol>
<p>总结</p>
<ul>
<li><strong>集群不可用场景</strong>：<ol>
<li>某个 master 节点挂掉且没有可用的从节点替代；</li>
<li>集群中任一槽（0～16383）未被分配，或在故障转移过程中存在空缺；</li>
<li>超过半数的 master 节点挂掉；</li>
<li>无复制模式下单个节点故障导致对应槽缺失。</li>
</ol>
</li>
<li><strong>判断依据</strong>：<br>Redis 集群通过检查槽分配完整性、利用 Gossip 协议和 quorum 投票机制监控节点健康状态，并依赖配置参数 <code>cluster-require-full-coverage</code> 来决定是否因部分槽缺失而将集群判为不可用。只要有关键部分（如多数 master 节点或部分槽数据）不可用，Redis 就会返回 “CLUSTERDOWN” 错误。</li>
</ul>
<h3 id="问：Redis集群会发生写操作丢失吗？为什么？"><a href="#问：Redis集群会发生写操作丢失吗？为什么？" class="headerlink" title="问：Redis集群会发生写操作丢失吗？为什么？"></a>问：Redis集群会发生写操作丢失吗？为什么？</h3><p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。一般写操作只往主节点中写入，通过异步方式同步到从节点，若主节点宕机，数据还未到从节点就导致了丢失。</p>
<p>在 <strong>Redis 集群</strong> 中，写操作丢失是可能发生的，尽管 Redis 本身提供了强一致性保障，但由于一些特定场景和配置问题，仍然可能导致写操作丢失。以下是几种可能导致 Redis 集群中写操作丢失的原因：</p>
<ol>
<li><strong>节点故障导致的写操作丢失</strong></li>
</ol>
<p>在 Redis 集群中，写操作是通过 <strong>主节点</strong> 执行的，主节点的故障会导致写操作丢失，特别是在 <strong>主节点与从节点同步尚未完成</strong> 的情况下。</p>
<ul>
<li><strong>主节点故障</strong>：如果主节点故障发生在写操作之后、从节点同步数据之前，且该操作没有持久化到 AOF 或 RDB 文件，那么该写操作将丢失。</li>
<li><strong>从节点同步延迟</strong>：如果主节点和从节点之间的同步延迟较大，主节点宕机时，从节点可能没有及时接收到最新的写操作。</li>
</ul>
<p>解决方案：</p>
<ul>
<li><strong>启用 AOF 持久化</strong>：通过 AOF（Append-Only File）持久化，Redis 能够记录所有写操作，这样即使发生主节点故障，也可以通过 AOF 文件恢复数据。</li>
<li><strong>增加从节点数量</strong>：保证每个主节点有多个从节点，以减少主节点故障时的影响。如果主节点故障，集群可以通过选举新的主节点，避免数据丢失。</li>
<li><strong>采用同步机制加强一致性</strong>：使用 <code>wait</code> 命令进行等待确认，确保写操作被多个从节点确认后再认为写成功。</li>
</ul>
<ol start="2">
<li><strong>网络分区问题（脑裂）</strong></li>
</ol>
<p>网络分区（split-brain）会导致集群中的部分节点无法与其他节点通信，进而影响集群的正常工作。在此情况下，部分节点可能会继续接受写操作，而这些写操作不会被同步到集群中的其他节点。当网络恢复后，这些分区节点的数据会发生冲突，导致数据不一致，甚至丢失。</p>
<ul>
<li><strong>网络分区导致的脑裂</strong>：如果集群分为两个子集且每个子集都有写操作，可能导致两个子集的数据不同步，从而丢失其中一个子集的写操作。</li>
</ul>
<p>解决方案：</p>
<ul>
<li><strong>启用 Redis 哨兵（Sentinel）</strong>：哨兵可以通过检测集群中的节点故障，并进行故障转移，尽量减少脑裂问题的发生。</li>
<li><strong>保证大多数节点可用</strong>：配置 Redis 集群时，使用合理的故障转移策略，确保集群中的大多数节点可用，防止脑裂问题。</li>
</ul>
<ol start="3">
<li><strong>集群模式下的主从同步配置问题</strong></li>
</ol>
<p>在 Redis 集群中，<strong>数据的分布</strong>是基于哈希槽（hash slots）来进行的，每个主节点管理一部分哈希槽。主节点的写操作需要通过同步机制传播到从节点，但在某些情况下，从节点的同步可能会失败，导致数据丢失。</p>
<ul>
<li><strong>同步超时</strong>：如果从节点长时间无法与主节点同步，可能导致主节点的数据没有及时同步到从节点。</li>
<li><strong>单向同步</strong>：在一些配置中，如果从节点处于某些不稳定的状态（比如网络问题或者硬件故障），它无法及时从主节点同步数据，这会导致数据丢失。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>**配置 <code>min-slaves-to-write</code>**：通过配置 <code>min-slaves-to-write</code>，可以确保至少有足够的从节点成功同步数据之后才允许执行写操作，这样可以减少写操作丢失的风险。</li>
<li>**设置 <code>min-slaves-max-lag</code>**：通过设置 <code>min-slaves-max-lag</code>，可以确保只有延迟较小的从节点才被认为是有效的，从而避免写操作丢失。</li>
</ul>
<ol start="4">
<li><strong>AOF 持久化策略导致的丢失</strong></li>
</ol>
<p>Redis 的 AOF 持久化通过追加日志的方式记录每一条写操作。当使用 AOF 时，<strong>如果 AOF 配置为每秒刷新一次（<code>appendfsync everysec</code>）</strong>，在极端情况下，某些操作可能未及时刷盘，这就可能导致写操作丢失。</p>
<ul>
<li><strong>AOF 持久化未及时刷新</strong>：如果 Redis 在写操作之后突然宕机，并且写操作尚未被 AOF 文件刷新到磁盘，则可能会丢失这些操作。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>**配置为 <code>appendfsync always</code>**：配置 AOF 持久化为每次写操作都同步到磁盘，虽然会影响性能，但可以保证数据不丢失。</li>
<li><strong>合理选择 AOF 刷新策略</strong>：如果写操作频繁且性能要求高，建议使用 <code>appendfsync everysec</code>，并配合合理的持久化策略，保证数据的可靠性。</li>
</ul>
<ol start="5">
<li><strong>集群扩容/缩容期间的写操作丢失</strong></li>
</ol>
<p>在进行集群扩容或缩容时，如果迁移操作没有完全同步，可能导致某些哈希槽的数据丢失或未完全同步。</p>
<ul>
<li><strong>迁移过程中的写操作丢失</strong>：在扩容或缩容时，某些写操作可能会到达正在迁移的节点，导致写操作丢失。</li>
</ul>
<p>解决方案：</p>
<ul>
<li><strong>谨慎操作集群扩容和缩容</strong>：在扩容或缩容期间，确保迁移过程中的每一步都被正确同步，避免数据丢失。</li>
<li><strong>利用<code>wait</code>命令确保数据同步</strong>：可以使用 <code>wait</code> 命令确保某些写操作在指定的从节点上成功。</li>
</ul>
<p><strong>总结</strong></p>
<p>虽然 Redis 集群在正常情况下是非常高效的，但在特定的场景下，写操作丢失是可能发生的。常见原因包括：</p>
<ul>
<li>主节点故障与从节点同步延迟</li>
<li>网络分区导致的脑裂</li>
<li>AOF 持久化策略导致的数据丢失</li>
<li>集群扩容或缩容期间的数据迁移问题</li>
</ul>
<p>为减少写操作丢失的风险，通常可以通过以下方式进行保障：</p>
<ul>
<li>配置 AOF 持久化</li>
<li>增加从节点数量，保证高可用性</li>
<li>配置合理的同步机制</li>
<li>启用 Redis 哨兵进行故障转移</li>
<li>优化网络和集群配置，防止脑裂</li>
</ul>
<p>这些措施能够确保 Redis 集群的高可用性和数据一致性，减少写操作丢失的可能性。</p>
<h3 id="问：谈谈Redis哨兵、复制、集群？"><a href="#问：谈谈Redis哨兵、复制、集群？" class="headerlink" title="问：谈谈Redis哨兵、复制、集群？"></a>问：谈谈Redis哨兵、复制、集群？</h3><p>主从复制的作用：</p>
<ol>
<li>数据一致性：在主节点故障时顶上，并保证数据不丢失。</li>
<li>读写分离：扩展主节点的读能力，分摊并发读压力。</li>
</ol>
<p>主从复制的问题：</p>
<ul>
<li>主节点故障，从节点需要手动晋升，还要修改应用方的主节点地址，还要命令其他从节点复制新的主节点。</li>
<li>主节点的写能力受到单机限制。</li>
<li>主节点的存储能力受到单机限制。</li>
</ul>
<p>主从复制模式下，一旦主节点故障，需要手动晋升从节点，还要通知应用更新主节点地址。Redis 2.8版本提供Sentinel（哨兵）架构来解决该问题。</p>
<p>Redis提供了三种集群策略：</p>
<ol>
<li>主从模式：主库可以读写，会和从库进行数据同步。该模式下，客户端直连主库或从库，当有节点宕机后，客户端需要手动修改IP，该模式较难扩容，集群所有存储数据受限于单个节点的内存容量，无法支持较大数据量。</li>
<li>哨兵模式：该模式在主从模式上新增了哨兵节点，当主库宕机后，哨兵发现该情况并在从库中选择一个库作为新的主库。也可以对哨兵做集群，避免哨兵的单点问题。该模式能较好的保证Redis的高可用，但无法解决容量上限的问题。</li>
<li>cluster模式：支持多主多从，按照key进行槽位的分配，可以使不同的key分散到不同的主节点上。该模式可以使集群能支持更大的数据容量，同时每个主节点有多个从节点保证高可用。</li>
</ol>
<p>Sentinel哨兵模式</p>
<ul>
<li>Sentinel能够自动完成故障发现和故障转移，并通知应用方来实现高可用。</li>
<li>Sentinel是一个分布式架构，包含若干Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其它Sentinel节点进行监控，当发现节点不可达时，会标记下线标识。如果被标识的是主节点，还会和其它Sentinel节点协商，当大部分Sentinel节点都认为主节点不可达时，会选举出一个Sentinel节点来完成自动故障转移工作，同时将变化通知给应用。</li>
</ul>
<p>Sentinel相比主从复制从结构上只是多了若干Sentinel节点，并没有对Redis节点做特殊处理。</p>
<p>当数据量不大时选择哨兵模式，数据量大时选择cluster模式。</p>
<ol>
<li>twemproxy，它类似于一个代理方式，使用方法和普通Redis 无任何区别，设置好它下属的多个 Redis 实例后，使用时在本需要连接 Redis 的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 Redis，将结果再返回twemproxy。使用方式简便(相对 Redis 只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy 自身单端口实例的压力，使用一致性 hash后，对Redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</li>
<li>codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在节点数量改变情况下，旧节点数据可恢复到新 hash 节点。</li>
<li>Redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</li>
<li>在业务代码层实现，起几个毫无关联的Redis 实例，在代码层，对 key进行 hash 计算，然后去对应的 Redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</li>
</ol>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>复制（Replication）</strong></th>
<th><strong>哨兵（Sentinel）</strong></th>
<th><strong>集群（Cluster）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据分布</strong></td>
<td>无分片，所有数据存储在主节点</td>
<td>无分片，依赖主从结构</td>
<td>自动分片，数据分布在多个节点</td>
</tr>
<tr>
<td><strong>读写分离</strong></td>
<td>支持，读操作可以分发到从节点</td>
<td>支持，读操作可以分发到从节点</td>
<td>支持，读操作可以从多个节点读取</td>
</tr>
<tr>
<td><strong>高可用性</strong></td>
<td>有，依赖于从节点备份和手动故障转移</td>
<td>自动故障转移</td>
<td>内置自动故障转移机制</td>
</tr>
<tr>
<td><strong>水平扩展</strong></td>
<td>不支持自动分片，依赖垂直扩展</td>
<td>不支持自动分片，依赖垂直扩展</td>
<td>支持水平扩展，自动分片</td>
</tr>
<tr>
<td><strong>配置复杂度</strong></td>
<td>简单，容易配置</td>
<td>复杂，需要多个哨兵节点</td>
<td>配置相对复杂，需要运维管理</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>中小型应用，读写分离需求</td>
<td>需要高可用，且无法采用集群的场景</td>
<td>大规模、高并发、高可用、高性能应用</td>
</tr>
</tbody></table>
<p><strong>1. 主从复制（Replication）</strong></p>
<p><strong>解决的问题</strong>：</p>
<ul>
<li><strong>数据冗余与备份</strong>：从节点复制主节点数据，提供数据副本。</li>
<li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求，分担主节点负载。</li>
<li><strong>高可用基础</strong>：为后续的哨兵和集群提供数据同步的基础能力。</li>
</ul>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><strong>手动故障转移</strong>：主节点故障时，需人工介入将从节点提升为主节点，导致服务中断。</li>
<li><strong>写性能瓶颈</strong>：所有写操作仍集中在单主节点，无法扩展写能力。</li>
<li><strong>数据一致性问题</strong>：异步复制可能导致从节点数据短暂落后（复制延迟）。</li>
</ul>
<p><strong>2. 哨兵（Sentinel）</strong></p>
<p><strong>解决的问题</strong>：</p>
<ul>
<li><strong>自动故障转移</strong>：监控主节点状态，主节点故障时自动选举新主节点，实现高可用。</li>
<li><strong>服务发现</strong>：客户端通过哨兵获取当前主节点地址，无需硬编码配置。</li>
</ul>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><strong>写能力未扩展</strong>：仍为单主节点架构，写性能受限于单个主节点。</li>
<li><strong>存储容量限制</strong>：数据存储在单主节点，无法水平扩展数据量。</li>
<li><strong>复杂度增加</strong>：需部署多个哨兵实例以避免自身单点故障，管理成本上升。</li>
</ul>
<p><strong>3. 集群（Cluster）</strong></p>
<p><strong>解决的问题</strong>：</p>
<ul>
<li><strong>水平扩展</strong>：通过数据分片（16384个哈希槽）将数据分布到多个主节点，支持更高的写并发和更大的数据量。</li>
<li><strong>高可用集成</strong>：每个分片由主节点和从节点组成，主节点故障时，从节点自动提升为新主节点（无需额外哨兵）。</li>
<li><strong>去中心化架构</strong>：集群节点通过Gossip协议通信，自主管理故障转移与数据迁移。</li>
</ul>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><strong>功能限制</strong>：跨节点操作（如事务、多键命令）受限，需使用哈希标签（Hash Tag）保证键在同一节点。</li>
<li><strong>运维复杂度</strong>：节点扩缩容需手动迁移数据或使用工具（如<code>redis-cli --cluster reshard</code>）。</li>
<li><strong>客户端适配</strong>：客户端需支持集群协议，直连节点并处理重定向（MOVED/ASK响应）。</li>
</ul>
<h3 id="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"><a href="#问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？" class="headerlink" title="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"></a>问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？</h3><p><strong>Hystrix 的隔离机制</strong></p>
<p>Hystrix 是一个用于处理分布式系统中故障的容错框架，它的核心目标是通过 <strong>断路器模式</strong>、<strong>隔离策略</strong>、<strong>降级策略</strong>等机制来确保系统的高可用性和稳定性。在 <strong>隔离机制</strong> 方面，Hystrix 主要有以下几种：</p>
<ol>
<li><strong>线程隔离（Thread Isolation）</strong></li>
</ol>
<ul>
<li><p><strong>定义</strong>：Hystrix 会为每一个请求创建一个新的线程（线程池），从而将各个请求的处理隔离开来。即使某个请求在执行过程中阻塞或超时，也不会影响其他请求的执行。</p>
</li>
<li><p><strong>适用场景</strong>：适用于需要进行独立处理的任务，如外部系统的调用、数据库操作等，能够隔离各个请求之间的资源竞争。</p>
</li>
<li><p>优势</p>
<p>：</p>
<ul>
<li>资源隔离：可以控制每个请求的最大并发数，防止某个服务因为高并发导致整个系统性能下降。</li>
<li>错误隔离：一个请求的失败不会影响到其他请求，避免了“雪崩效应”。</li>
</ul>
</li>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>线程池管理成本较高，需要精心设置线程池的大小。</li>
<li>如果线程池设置得不合理，可能导致线程池耗尽，从而影响系统性能。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>信号量隔离（Semaphore Isolation）</strong></li>
</ol>
<ul>
<li><p><strong>定义</strong>：信号量隔离是通过一个信号量（Semaphore）来限制对资源的访问。每次请求获取一个信号量，如果信号量耗尽（即所有的信号量都被占用），则请求会被拒绝。</p>
</li>
<li><p><strong>适用场景</strong>：适用于不需要为每个请求创建独立线程的场景，例如对一些轻量级任务的控制，减少线程的上下文切换开销。</p>
</li>
<li><p>优势</p>
<p>：</p>
<ul>
<li>更轻量级：相比于线程池隔离，信号量隔离不需要创建新的线程，适合处理轻量级的任务。</li>
<li>降低资源消耗：避免了线程池管理带来的额外开销。</li>
</ul>
</li>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>没有线程隔离那么强的资源隔离效果，容易受到共享资源的影响。</li>
<li>如果任务执行时间过长，可能会占用信号量，导致系统其他请求无法获得信号量。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>不隔离（No Isolation）</strong></li>
</ol>
<ul>
<li><p><strong>定义</strong>：没有隔离措施，所有的请求都在主线程中执行。</p>
</li>
<li><p><strong>适用场景</strong>：一般情况下，不推荐使用这种模式，但在某些轻量级任务中，可能会选择不进行隔离。</p>
</li>
<li><p>优势</p>
<p>：</p>
<ul>
<li>没有额外的线程和资源管理开销。</li>
</ul>
</li>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>无法避免不同请求之间的干扰，可能导致性能下降，影响系统的可扩展性。</li>
</ul>
</li>
</ul>
<p><strong>Hystrix 常见配置</strong></p>
<p>Hystrix 提供了多种配置项来控制断路器的行为、线程池的大小、请求超时等，下面是一些常用的配置项。</p>
<ol>
<li><strong>断路器相关配置</strong></li>
</ol>
<ul>
<li><p>hystrix.command.default.circuitBreaker.enabled</p>
<p>：启用或禁用断路器，默认为 </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>，表示启用。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.circuitBreaker.enabled=true</code></li>
</ul>
</li>
<li><p>hystrix.command.default.circuitBreaker.requestVolumeThreshold</p>
<p>：断路器切换到“打开”状态的请求数量阈值，默认是 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>

<p>。当超过该阈值的请求失败时，断路器会触发。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.circuitBreaker.requestVolumeThreshold=10</code></li>
</ul>
</li>
<li><p>hystrix.command.default.circuitBreaker.errorThresholdPercentage</p>
<p>：断路器在请求中失败的比例阈值，超过该阈值时，断路器会打开。默认值为 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure>

<p>，即 50% 的失败请求时触发。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.circuitBreaker.errorThresholdPercentage=50</code></li>
</ul>
</li>
<li><p>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds</p>
<p>：断路器在“打开”状态后多久尝试切换到“半打开”状态（即允许一定量的请求通过进行恢复检查）。默认是 </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>（即 5 秒）。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds=5000</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>超时配置</strong></li>
</ol>
<ul>
<li><p>hystrix.command.default.execution.timeout.enabled</p>
<p>：是否启用超时功能，默认值为 </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.execution.timeout.enabled=true</code></li>
</ul>
</li>
<li><p>hystrix.command.default.execution.timeoutInMilliseconds</p>
<p>：请求超时的时间，单位毫秒，默认值是 </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>（即 1 秒）。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.execution.timeoutInMilliseconds=1000</code></li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>线程池配置</strong></li>
</ol>
<ul>
<li><p>hystrix.threadpool.default.coreSize</p>
<p>：线程池的核心线程数，默认为 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<p>。表示 Hystrix 执行请求时能够同时处理的最小并发量。</p>
<ul>
<li>配置例子：<code>hystrix.threadpool.default.coreSize=20</code></li>
</ul>
</li>
<li><p>hystrix.threadpool.default.maximumSize</p>
<p>：线程池的最大线程数，默认为 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<p>。表示当有大量并发请求时，线程池能够容纳的最大线程数。</p>
<ul>
<li>配置例子：<code>hystrix.threadpool.default.maximumSize=50</code></li>
</ul>
</li>
<li><p>hystrix.threadpool.default.keepAliveTimeMinutes</p>
<p>：线程池的线程空闲时长，默认为 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>，单位是分钟。</p>
<ul>
<li>配置例子：<code>hystrix.threadpool.default.keepAliveTimeMinutes=2</code></li>
</ul>
</li>
<li><p>hystrix.threadpool.default.queueSizeRejectionThreshold</p>
<p>：队列拒绝的最大请求数，当队列中的请求数超过该值时，新的请求会被拒绝并触发回退机制。默认值是 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>。</p>
<ul>
<li>配置例子：<code>hystrix.threadpool.default.queueSizeRejectionThreshold=5</code></li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>请求缓存与请求合并</strong></li>
</ol>
<ul>
<li><p>hystrix.command.default.requestCache.enabled</p>
<p>：是否启用请求缓存，默认为 </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>。启用后，相同的请求会直接返回缓存值，而不会重复执行。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.requestCache.enabled=true</code></li>
</ul>
</li>
<li><p>hystrix.command.default.requestLog.enabled</p>
<p>：是否启用请求日志，默认为 </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.requestLog.enabled=true</code></li>
</ul>
</li>
<li><p>hystrix.command.default.execution.isolation.strategy</p>
<p>：设置请求隔离策略。可以是 </p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">THREAD</span></span><br></pre></td></tr></table></figure>

<p>（线程隔离）或 </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SEMAPHORE</span></span><br></pre></td></tr></table></figure>

<p>（信号量隔离）。默认值是 </p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">THREAD</span></span><br></pre></td></tr></table></figure>

<p>。</p>
<ul>
<li>配置例子：<code>hystrix.command.default.execution.isolation.strategy=SEMAPHORE</code></li>
</ul>
</li>
</ul>
<p><strong>常见配置总结</strong></p>
<ul>
<li><strong>断路器相关配置</strong>：控制何时打开断路器、何时恢复、失败请求的阈值等。</li>
<li><strong>超时配置</strong>：控制请求的超时设置。</li>
<li><strong>线程池配置</strong>：控制每个命令的线程池大小和线程的生命周期。</li>
<li><strong>请求缓存与请求合并</strong>：控制请求缓存和请求合并的行为，以优化系统性能。</li>
</ul>
<p><strong>总结</strong></p>
<p>Hystrix 提供了多种配置选项，可以帮助开发者控制服务的容错能力、超时策略、线程池的大小等。根据不同的业务场景，可以调整这些配置，以确保服务的高可用性。常见的隔离机制包括 <strong>线程隔离</strong>、<strong>信号量隔离</strong> 和 <strong>无隔离</strong>。对于分布式系统，合理配置 Hystrix 的各项参数是非常重要的，可以有效降低系统故障的影响。</p>
<h3 id="问：Redis分区场景？实现方案？分区的缺点？"><a href="#问：Redis分区场景？实现方案？分区的缺点？" class="headerlink" title="问：Redis分区场景？实现方案？分区的缺点？"></a>问：Redis分区场景？实现方案？分区的缺点？</h3><p>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<p>客户端分区就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。代理分区意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis 实例，然后根据 Redis 的响应结果返回给客户端。Redis 和 memcached 的一种代理实现就是 Twemproxy查询路由(Query routing) 的意思是客户端随机地请求任意一个 Redis实例，然后由 Redis将请求转发给正确的 Redis 节点。RedisCluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接redirected 到正确的Redis 节点。</p>
<ul>
<li>涉及多个 key 的操作通常不会被支持。例如不能对两个集合求交集，因为他们可能被存储到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个 key,则不能使用 Redis 事务。</li>
<li>分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge keylike a very big sorted set）。</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份必须从不同的 Redis 实例和主机同时收集RDB / AOF 文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除 Redis 节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<p><strong>Redis 分区（Sharding）场景</strong></p>
<p><strong>分区</strong>（Sharding）是指将数据拆分成多个部分，分布到不同的 Redis 实例或集群节点中。Redis 分区常用于水平扩展，尤其是当单个 Redis 实例无法处理大量数据或并发时，通过分区可以将负载分散到多个 Redis 实例上，提高系统的可伸缩性和性能。</p>
<p><strong>Redis 分区的应用场景：</strong></p>
<ol>
<li><strong>数据量大</strong>：<ul>
<li>当单个 Redis 实例的内存容量达到上限时，使用分区可以将数据拆分到多个实例中，避免单个实例内存溢出。</li>
</ul>
</li>
<li><strong>高并发</strong>：<ul>
<li>如果一个 Redis 实例的并发请求量过高，可能导致性能瓶颈。通过将请求分布到多个实例中，可以分散负载，避免单个 Redis 实例的资源耗尽。</li>
</ul>
</li>
<li><strong>高可用性和容错性</strong>：<ul>
<li>分区可以与复制和高可用性（如 Redis Sentinel 或 Redis Cluster）结合使用，提高系统的可靠性和容错能力。</li>
</ul>
</li>
<li><strong>业务需求分割</strong>：<ul>
<li>某些业务场景可能需要将数据按照某些维度进行划分（例如，按用户 ID、商品 ID 等），分区能够根据业务逻辑将数据拆分到多个实例上。</li>
</ul>
</li>
</ol>
<p><strong>Redis 分区实现方案</strong></p>
<ol>
<li><strong>客户端分区（Client-Side Sharding）</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：客户端直接根据分区规则计算出数据应存储在哪个 Redis 实例中，从而将请求发送到相应的实例。这种方式客户端需要知道所有 Redis 节点的地址，并且根据特定规则（如哈希算法）来确定数据存储的节点。</p>
</li>
<li><p>实现方式</p>
<p>：</p>
<ul>
<li>常见的是使用 <strong>一致性哈希</strong> 或 <strong>取模哈希</strong> 算法，计算出键值应该存储的 Redis 实例。</li>
</ul>
</li>
<li><p>优缺点</p>
<p>：</p>
<ul>
<li><p>优点</p>
<p>：</p>
<ul>
<li>客户端控制分区，灵活度高，能够应对不同的分区策略。</li>
<li>无需修改 Redis 服务端的架构。</li>
</ul>
</li>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>客户端需要有更多的逻辑，代码复杂。</li>
<li>扩容时，可能需要重新计算和迁移数据，涉及较高的开销。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Redis Cluster</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：Redis Cluster 是 Redis 官方提供的分区解决方案，通过将数据分布在多个节点上，实现数据的分区存储。每个 Redis 节点管理一部分数据（使用 <strong>槽</strong> 进行划分），客户端通过哈希槽算法将请求路由到正确的 Redis 节点。</p>
</li>
<li><p>实现方式</p>
<p>：</p>
<ul>
<li>Redis Cluster 采用了 <strong>哈希槽</strong>（Hash Slots）机制，将键空间划分为 16384 个槽（slots），每个键根据哈希值映射到一个槽。然后，这些槽会分配到不同的 Redis 节点。</li>
<li>每个 Redis 节点负责一部分槽的数据。客户端根据哈希槽将请求发送到正确的节点。</li>
<li>通过 <strong>复制</strong> 和 <strong>故障转移</strong> 保证高可用性。</li>
</ul>
</li>
<li><p>优缺点</p>
<p>：</p>
<ul>
<li><p>优点</p>
<p>：</p>
<ul>
<li>自动分配和管理数据分区，简化了分区管理。</li>
<li>集群自动处理节点扩容、故障转移等，保证高可用。</li>
</ul>
</li>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>存在数据迁移和 rebalancing 的复杂性。</li>
<li>由于采用的是一致性哈希，集群扩容时会涉及较大的数据迁移，可能会带来性能影响。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>Redis Sentinel + 手动分区</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：使用 Redis Sentinel 来实现主从复制和故障转移，结合手动分区，将数据分散到不同的 Redis 节点。分区策略可以使用哈希、业务划分等方法。</p>
</li>
<li><p>实现方式</p>
<p>：</p>
<ul>
<li>在 Redis Sentinel 的支持下，配置多个 Redis 节点，手动将数据分布到不同的 Redis 实例上。</li>
<li>需要通过客户端进行数据路由，客户端需要根据分区策略选择正确的 Redis 节点。</li>
</ul>
</li>
<li><p>优缺点</p>
<p>：</p>
<ul>
<li><p>优点</p>
<p>：</p>
<ul>
<li>通过 Sentinel 实现高可用和故障转移。</li>
<li>可以根据业务需要进行灵活的分区设计。</li>
</ul>
</li>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>扩展性不如 Redis Cluster，手动管理的复杂度较高。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Redis 分区的缺点</strong></p>
<ol>
<li><strong>数据迁移的复杂性</strong>：<ul>
<li>当 Redis 实例的数量增加或减少时，需要重新分配数据。尤其是使用一致性哈希算法时，数据迁移的代价较高，可能会对系统性能产生影响。尤其是 Redis 集群扩容时，数据需要从旧节点迁移到新节点，可能会导致性能波动。</li>
</ul>
</li>
<li><strong>单节点瓶颈问题</strong>：<ul>
<li>分区的目的是通过水平扩展来避免单节点瓶颈，但如果某个 Redis 节点的负载过高，仍然可能成为系统的瓶颈。特别是当某些键的访问量非常大（即热键），可能会导致单个节点的压力过大。</li>
</ul>
</li>
<li><strong>跨分区查询复杂</strong>：<ul>
<li>如果需要跨多个 Redis 节点进行查询，可能需要多个网络请求，增加了查询的延迟。比如，需要从多个 Redis 节点获取不同的键值，再汇总结果，增加了查询的复杂度。</li>
</ul>
</li>
<li><strong>一致性问题</strong>：<ul>
<li>分区后，可能会面临数据一致性的问题，特别是在网络分区或节点故障时。Redis 集群通过复制来保证高可用性，但在分区环境下，跨节点的操作可能会引发数据一致性问题，需要通过合适的设计和协议来解决。</li>
</ul>
</li>
<li><strong>扩容难度</strong>：<ul>
<li>在进行水平扩展时（如增加 Redis 节点），可能需要重新计算和迁移大量的数据，增加了系统的复杂度和运维成本。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>Redis 分区的主要目的是解决数据量大、并发高时的性能瓶颈问题。常见的分区方案有客户端分区、Redis Cluster 和 Redis Sentinel + 手动分区。不同的分区方案有不同的优缺点，需要根据具体业务场景来选择。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据迁移复杂性</li>
<li>单节点瓶颈问题</li>
<li>跨分区查询的复杂性</li>
<li>一致性问题</li>
<li>扩容难度</li>
</ul>
<p>因此，在实施 Redis 分区时，需要合理选择分区策略，并考虑如何处理扩容、数据迁移、热键等问题。</p>
<h3 id="问：什么是Canal？"><a href="#问：什么是Canal？" class="headerlink" title="问：什么是Canal？"></a>问：什么是Canal？</h3><h3 id="问：亿级用户热点数据更新如何优化？"><a href="#问：亿级用户热点数据更新如何优化？" class="headerlink" title="问：亿级用户热点数据更新如何优化？"></a>问：亿级用户热点数据更新如何优化？</h3><p>什么是热点数据？</p>
<ul>
<li>指访问频率很高、更新频繁的数据，如：并发量高的接口、查询用户信息、优惠券信息等</li>
</ul>
<p>热点数据带来的问题？</p>
<ol>
<li>数据库连接被耗尽，无法处理新的请求</li>
<li>行锁冲突、锁等待、线程阻塞、降低数据处理性能</li>
<li>CPU被打满</li>
<li>频繁更新数据，慢SQL，主从同步延迟更严重</li>
</ol>
<p>假设一个业务场景：某物流公司（数亿用户）小程序收到大量反馈：系统无法下单，影响巨大。</p>
<p>现象分析：</p>
<ul>
<li>第一时间，首先确认除问题外其它系统功能是否正常，缩小排查范围。</li>
<li>验证步骤：<ol>
<li>验证小程序中与订单无关的其它核心功能，如会员信息、营销活动、优惠券购买等。结果：正常。</li>
<li>验证小程序中与订单相关的功能，如下单、查询订单等。结果：异常。</li>
</ol>
</li>
<li>结论：订单模块功能异常，未影响到全部系统功能。</li>
</ul>
<p>问题定位：</p>
<ol>
<li>初步判断：根据经验+工具。有经验的架构师、经理等根据自身经验，确定一个大概出问题的方向。<ul>
<li>架构：该系统非单体，而是微服务，根据业务进行拆分，所以订单系统没有影响到别的模块。</li>
<li>方向：<ul>
<li>应用线程被打挂：活跃线程超过配置最大值，导致新的请求都无法被处理。基于K8s部署的应用通过请求探活接口，发现没响应后会不断重启应用，导致C端小程序是不是出现异常。</li>
<li>数据库CPU被打挂：<ul>
<li>数据库出现大量SQL，业务请求量太大，导致大量线程阻塞，CPU很快飙升到100%。</li>
<li>并发请求太高，超过数据库能承受的最大线程数（业务请求TPS：2w/s，数据库单节点TPS：2k/s），CPU很快飙升到100%。</li>
</ul>
</li>
<li>Redis被打挂：<ul>
<li>CPU被打爆，接近100%。可能原因：出现热key。</li>
<li>内存满了，接近100%。可能原因：key短时间内增长很快，超过内存最大值。设计不合理或者过期时间设置较长。</li>
<li>网络IO太大，如1.8G/s。可能原因：出现大key</li>
</ul>
</li>
</ul>
</li>
<li>监控工具：<ul>
<li>优先查看报警信息，找到有用信息。如：数据库告警-&gt;慢接口告警-&gt;应用程序打满告警</li>
<li>如果没有订阅中间件、数据库的告警监控，通过监控系统（promethus+grafana）依次检查：应用（cpu、活跃线程数）-&gt;数据库（cpu、并发查询QPS/写入TPS）-&gt;Redis（CPU、内存、网络IO）</li>
</ul>
</li>
</ul>
</li>
<li>初步分析：假设我们发现了数据库的某个分片库CPU达到100%，导致订单应用线程被打满，应用频繁重启。即数据库被打挂。<ul>
<li>通过数据库监控，进一步查看是否有慢SQL，发现有大量insert语句。</li>
<li>根据SQL去检查代码，发现有ToC的公司用户在某个时间批量推送的大批订单更新，TPS接近2w/s。然后通过kafka消费模块进入MySQL的某单一分片，造成了高并发Update，从而打爆了某个分片库。因为MyCat架构的原因，集群的单节点挂掉后无法自动进行故障转移，从而引起了大面积请求失败。</li>
</ul>
</li>
<li>临时解决方案：<ul>
<li>重启出问题的MySQL分片库。</li>
<li>流量快速切到容灾。</li>
<li>关闭大客户Kafka数据消费。但会导致消息积压，待问题处理完成后要尽快恢复。</li>
<li>限制带宽、查单功能。等待数据库、MyCat恢复。</li>
<li>逐步开放业务功能。</li>
</ul>
</li>
<li>长期解决方案：<ul>
<li>原架构痛点分析：<ul>
<li>流量突增时，系统没有限流，数据库容易被打挂。</li>
<li>大客户消费订单时没有限速，流量突增，负载过高。</li>
<li>大客户消费和散户下订单在同个应用，共用数据库，任一出问题相互影响。</li>
</ul>
</li>
<li>优化方案：<ul>
<li>流量控制：<ul>
<li>在流量突增的源头增加限速限流：大客户kafka消费入口增加一个kafka分流服务来限速，应对突发流量动态配置消息优先级、消息处理时间。</li>
<li>大客户C端查单限流：大客户查单存在瞬时并发风暴的性能风险。识别大客户（根据最近90天下单量），查询订单功能部分限流，应用层网关增加限流（基于单节点或集群，可以接入sentinel或基于redis的各种实现限流）</li>
</ul>
</li>
<li>热点隔离：<ul>
<li>热点业务的应用独立部署：将出现问题的运单业务从原订单业务中拆出独立部署，对接外部第三方的大客户运单也从运单业务中剥离出独立部署。</li>
<li>热点数据垂直拆分为独立的数据库：运单业务独立后，相关的表拆分到独立的运单库。</li>
<li>热点业务的中间件隔离（如Redis、MQ等）：考虑到成本，可以进行拆分，一般Redis和MQ性能较高，可以在线无损扩容。</li>
</ul>
</li>
<li>存储层优化：<ul>
<li>分库分表中间件切换：mycat中间件替换为shardingsphere，因为mycat架构应用到数据库只有一个连接池，在一个库异常的情况下，会导致JDBC池满，缺少隔离。</li>
<li>数据分批次提交：自定义mybatis拦截器，拦截执行SQL，动态配置一个阈值。当insert或update记录数超过阈值时，改为分批次提交事务（参考：mybatis-plus批量提交）。</li>
<li>存储架构升级：C端查询运单数据架构升级，查询mycat分片库升级为es+hbase架构。es支持各种查询条件，如全模糊查询。明细数据放入hbase，从es中查询运单ID，再根据运单ID批量从hbase查询运单明细。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>总结与拓展：<ul>
<li>面试提问的回答：从3个层面分析，流量控制、热点隔离、存储层优化。</li>
<li>热点更新的其它解决方案：<ul>
<li>数据合并后更新。适合异步更新的场景，比如：秒杀系统设计时，针对秒杀商品库存的扣减，可以在内存合并为一个商品的记录，计算商品扣减的总库存后，批量更新热点表，减少锁冲突。</li>
<li>update转insert。采用类似流水表的设计方式。因为insert性能要高于update，可以基于流水记录做各种统计，采用定时任务异步更新热点表，减少锁冲突。</li>
</ul>
</li>
<li>压力提问：你给出的方案比较复杂，有没有更好的热点数据处理方案？<strong>改造底层数据库</strong>。基于数据库层面做统一改造，通过改写mysql的执行层，提供自动探测热点行更新开关。当检测到单行有大量热点更新，在执行层引入排队机制，减少行锁冲突，提高并发性能。</li>
</ul>
</li>
</ol>
<p><strong>什么是热点数据？</strong></p>
<p><strong>热点数据</strong>（Hot Data）指的是在系统中频繁访问、操作的数据，通常是用户最关注、最常请求的内容。对于亿级用户的场景，热点数据通常是指在短时间内被大量用户频繁访问或更新的数据。例如：</p>
<ul>
<li>电商平台中，某个热销商品的库存信息、价格信息。</li>
<li>社交平台中，热门文章、用户的最新动态。</li>
<li>互联网金融平台中的热门股票、理财产品等。</li>
</ul>
<p><strong>热点数据带来的问题</strong></p>
<p>在大规模系统中，热点数据如果没有正确优化，会带来一系列问题：</p>
<ol>
<li><strong>数据库压力</strong>：<ul>
<li>热点数据会被大量请求，导致数据库频繁访问并产生高并发。这会造成数据库性能瓶颈，甚至导致数据库崩溃。</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>：<ul>
<li>热点数据通常会被缓存，若缓存的热点数据在同一时间过期，所有请求会同时访问数据库，可能导致数据库压力急剧增加，出现雪崩效应。</li>
</ul>
</li>
<li><strong>缓存穿透</strong>：<ul>
<li>如果没有有效的缓存策略，热点数据的请求可能会频繁查询数据库，造成数据库负担过重。比如，热点数据更新后缓存未及时更新，或者缓存数据不存在。</li>
</ul>
</li>
<li><strong>缓存击穿</strong>：<ul>
<li>如果某个热点数据的缓存因某种原因被清除，接下来的请求可能直接访问数据库，导致缓存击穿现象。</li>
</ul>
</li>
<li><strong>负载不均衡</strong>：<ul>
<li>热点数据的集中访问会使得请求分布不均，可能导致某些节点的负载过高，造成服务器压力不均，影响系统整体的稳定性和响应速度。</li>
</ul>
</li>
</ol>
<p><strong>热点数据带来的问题分析</strong></p>
<ol>
<li><strong>性能瓶颈</strong>：<ul>
<li>热点数据的频繁访问可能导致缓存和数据库同时承受很大的读请求负载，导致性能瓶颈。</li>
</ul>
</li>
<li><strong>系统不稳定</strong>：<ul>
<li>在并发量非常高的情况下，如果没有合理的负载均衡和缓存管理策略，可能导致某些节点或服务超载，进而影响整个系统的稳定性。</li>
</ul>
</li>
<li><strong>数据一致性问题</strong>：<ul>
<li>热点数据在缓存和数据库中保持一致性较为困难，尤其是在高并发更新场景中，如果没有合适的缓存更新策略，可能会出现数据不一致的情况。</li>
</ul>
</li>
<li><strong>延迟和响应时间</strong>：<ul>
<li>热点数据被频繁访问时，数据库的延迟会逐渐增大，尤其是在数据库负载过高时，响应时间会显著上升，影响用户体验。</li>
</ul>
</li>
</ol>
<p><strong>如何优化解决热点数据问题？</strong></p>
<p>优化热点数据的访问与更新策略，需要从多个方面入手。以下是几种常见的优化方案：</p>
<ol>
<li><strong>数据缓存优化</strong></li>
</ol>
<ul>
<li><strong>缓存热点数据</strong>：<ul>
<li>将热点数据缓存到 <strong>Redis</strong>、<strong>Memcached</strong> 等内存数据库中。因为内存读取速度远远高于磁盘，可以显著提高数据访问速度。</li>
<li>使用合理的 <strong>过期策略</strong>（例如：根据数据更新频率设置过期时间）和 <strong>LRU（Least Recently Used）算法</strong>，来保证缓存有效性。</li>
</ul>
</li>
<li><strong>热点数据预热</strong>：<ul>
<li>对于一些已知的热点数据，可以在系统启动时，提前将其加载到缓存中，这样在用户第一次请求时，可以直接从缓存中获取数据。</li>
</ul>
</li>
<li><strong>避免缓存雪崩</strong>：<ul>
<li>设置 <strong>不同的缓存过期时间</strong>。避免所有热点数据在同一时刻过期，造成数据库压力暴增。</li>
<li>通过 <strong>加随机过期时间</strong>，使得多个缓存的过期时间错开，避免短时间内大量请求访问数据库。</li>
</ul>
</li>
<li><strong>双层缓存机制</strong>：<ul>
<li>使用 <strong>本地缓存 + 分布式缓存</strong>，例如，使用本地缓存（如 <code>guava cache</code>）存储热点数据，同时使用 Redis 作为分布式缓存。通过减少访问 Redis 的次数，进一步提升性能。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>读写分离和负载均衡</strong></li>
</ol>
<ul>
<li><strong>读写分离</strong>：<ul>
<li>使用 <strong>主从复制</strong>（如 Redis 和 MySQL），将数据库的写操作发送到主节点，而读操作发送到从节点。通过分散读请求，可以减少热点数据对主数据库的压力。</li>
</ul>
</li>
<li><strong>负载均衡</strong>：<ul>
<li>使用负载均衡策略，避免对某些节点的请求压力过大。通过 <strong>请求路由</strong>（如使用一致性哈希、分布式缓存等）来确保负载的均衡分布。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>热点数据隔离</strong></li>
</ol>
<ul>
<li><strong>热点数据分离</strong>：<ul>
<li>对热点数据和普通数据进行分离，采用不同的缓存和存储策略。可以将热点数据缓存并单独存储，而对冷数据使用传统数据库进行存储和处理。</li>
</ul>
</li>
<li><strong>分库分表</strong>：<ul>
<li>在数据库层面上，通过 <strong>分库分表</strong> 对不同类型的数据进行分区处理。例如，可以将热点数据与普通数据放到不同的数据库中，或将热点数据拆分到不同的数据库实例中，减少压力集中。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>异步更新和队列机制</strong></li>
</ol>
<ul>
<li><strong>异步更新</strong>：<ul>
<li>使用 <strong>异步队列</strong> 或 <strong>消息队列</strong>（如 Kafka、RabbitMQ），将热点数据的更新操作异步化。这样，更新操作不会阻塞业务流程，同时避免过高的并发请求直接访问数据库。</li>
</ul>
</li>
<li><strong>延迟队列</strong>：<ul>
<li>对热点数据的缓存更新，可以通过延迟队列来实现，定期批量更新缓存，避免高并发时直接写入数据库。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>优化数据库</strong></li>
</ol>
<ul>
<li><strong>数据库索引优化</strong>：<ul>
<li>对热点数据相关的字段创建合理的数据库索引，提升查询效率。</li>
</ul>
</li>
<li><strong>数据库分区和分片</strong>：<ul>
<li>使用 <strong>分区（partitioning）</strong> 或 <strong>分片（sharding）</strong> 将热点数据存储到多个数据库实例上，分担负载。</li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>利用布隆过滤器</strong></li>
</ol>
<ul>
<li><p>布隆过滤器</p>
<p>：</p>
<ul>
<li>对于热点数据的查询，可以在缓存之前先通过布隆过滤器判断数据是否存在。如果布隆过滤器判断数据不存在，就可以避免直接查询数据库，减少不必要的数据库请求。</li>
</ul>
</li>
</ul>
<ol start="7">
<li><strong>热数据热备和异步同步</strong></li>
</ol>
<ul>
<li><strong>热备</strong>：<ul>
<li>对热点数据进行热备，即在多个 Redis 节点间进行数据复制，确保热点数据能够快速访问。可以在多个节点部署 Redis 主从集群，避免单点故障。</li>
</ul>
</li>
<li><strong>异步同步</strong>：<ul>
<li>对于热数据，可以通过异步的方式同步更新缓存和数据库。比如，使用定时任务或者后台服务，定期将数据库中的数据同步到缓存，避免高并发时直接操作数据库。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p><strong>热点数据</strong>是指在短时间内被大量用户频繁访问的数据。它带来的问题主要包括数据库压力增大、缓存雪崩、缓存穿透、负载不均衡等。</p>
<p>为了解决这些问题，可以通过以下策略进行优化：</p>
<ul>
<li><strong>数据缓存优化</strong>：合理利用缓存策略、双层缓存机制和热点数据预热。</li>
<li><strong>读写分离和负载均衡</strong>：使用数据库读写分离，结合负载均衡来分散请求压力。</li>
<li><strong>热点数据隔离</strong>：将热点数据和普通数据分开处理，使用分库分表技术。</li>
<li><strong>异步更新和队列机制</strong>：异步化热点数据更新，减少数据库的直接访问。</li>
<li><strong>优化数据库性能</strong>：通过优化数据库索引和使用分区或分片来处理热点数据。</li>
<li><strong>布隆过滤器</strong>：避免无效的查询，减少数据库负担。</li>
</ul>
<p>通过这些优化措施，可以有效缓解热点数据带来的问题，提高系统的性能和可扩展性。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050401.html" rel="bookmark">面试整理——Dubbo</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050301.html" rel="bookmark">面试整理——Mybatis</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050201.html" rel="bookmark">面试整理——MQ</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050101.html" rel="bookmark">面试整理——Spring Cloud</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020021101.html" rel="bookmark">面试整理——其它</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2020050501.html" title="面试整理——Redis">http://linyishui.top/2020050501.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
              <a href="/tags/redis/" rel="tag"><i class="fa fa-tag"></i> redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020050401.html" rel="prev" title="面试整理——Dubbo">
                  <i class="fa fa-chevron-left"></i> 面试整理——Dubbo
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020050701.html" rel="next" title="HTTP会话（未完成）">
                  HTTP会话（未完成） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
