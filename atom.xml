<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-06-30T08:39:08.163Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Speciosity</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法笔记</title>
    <link href="http://linyishui.top/2020060101.html"/>
    <id>http://linyishui.top/2020060101.html</id>
    <published>2020-06-01T09:06:15.000Z</published>
    <updated>2020-06-30T08:39:08.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a><strong>算法笔记</strong></h1><h2 id="第一节-递归"><a href="#第一节-递归" class="headerlink" title="第一节 递归"></a><strong>第一节 递归</strong></h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a><strong>1.1 概述</strong></h3><p>什么是递归？简单的说，一个方法自己调用自己即递归。递归实质上是把一个大问题分解为一个个小问题，然后通过一个个解决小问题最终解决大问题。</p><h3 id="1-2-斐波那契数列"><a href="#1-2-斐波那契数列" class="headerlink" title="1.2 斐波那契数列"></a><strong>1.2 斐波那契数列</strong></h3><h4 id="1-2-1-问题"><a href="#1-2-1-问题" class="headerlink" title="1.2.1 问题"></a><strong>1.2.1 问题</strong></h4><p>斐波那契数列是典型的递归案例：</p><ul><li>F(0) = 0（初始值）</li><li>F(1) = 1（初始值）</li><li>对于所有大于1的整数n：f(n) = f(n-1) + f(n-2)（递归定义）</li></ul><p>除了开头0和1，每个数字都刚好等于前两个数字之和：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……</p><h4 id="1-2-2-实现"><a href="#1-2-2-实现" class="headerlink" title="1.2.2 实现"></a><strong>1.2.2 实现</strong></h4><p>用代码来表示斐波那契数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-运行轨迹"><a href="#1-2-3-运行轨迹" class="headerlink" title="1.2.3 运行轨迹"></a><strong>1.2.3 运行轨迹</strong></h4><p>但递归的时间开销实在是太高了，如下图所示，求F(n)要沿树走下去并依次执行返回上来，即4-3-2-1-2-0-3-1-4-2-1-2-0-2-4。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt></p><h4 id="1-2-4-时间复杂度"><a href="#1-2-4-时间复杂度" class="headerlink" title="1.2.4 时间复杂度"></a><strong>1.2.4 时间复杂度</strong></h4><p>递归过程即遍历二叉树的流程，所以所有节点耗时相加即总耗时。每个节点只做了求和操作即 <code>O(1)</code> ，所以总时间为 <code>2^n</code> 。</p><h4 id="1-2-5-额外内存空间"><a href="#1-2-5-额外内存空间" class="headerlink" title="1.2.5 额外内存空间"></a><strong>1.2.5 额外内存空间</strong></h4><p>空间复杂度是指算法运行期间所需占用的所有内存空间，而我们分析算法时更常用的是额外内存空间，两者区别：长度为 <code>n</code> 的数组排序， <code>O(n)</code> 的空间不会算在额外内存空间，因为这个空间是必要的，不是取决于你的算法的。</p><p>对于递归算法来说，每个节点所需空间为 <code>O(1)</code> ，总共需要 <code>O(n)</code> 的空间。</p><h4 id="1-2-6-优化"><a href="#1-2-6-优化" class="headerlink" title="1.2.6 优化"></a><strong>1.2.6 优化</strong></h4><p>可以明显的看出递归算法的低效主要是因为进行了大量的<strong>重复操作</strong>，只要减少不必要的重复操作就可以提高算法效率。</p><p>首先我们可以想到用一个数据结构来记录已经进行过的操作，每次操作前判断一下是否进行过来避免重复。</p><p>选用一个数组来存放对应下标的值，通过游标遍历到n求得对应值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] notes = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    notes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    notes[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        notes[i] = notes[i-<span class="number">1</span>] + notes[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> notes[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时时间复杂度降低到了 <code>O(n)</code> 。</p><p>接着还可以继续优化空间，求第n个数的值最终并不需要我们记录之前的每个元素，所以可以继续优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样时间复杂度仍为 <code>O(n)</code> ，而空间也降到了 <code>O(1)</code> 。</p><p>这种解法其实就是<strong>动态规划</strong>。</p>]]></content>
    
    <summary type="html">
    
      暂时记录一些基础内容，持续更新。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>HTTP会话（未完成）</title>
    <link href="http://linyishui.top/2020050701.html"/>
    <id>http://linyishui.top/2020050701.html</id>
    <published>2020-05-07T11:21:21.000Z</published>
    <updated>2020-07-01T14:21:03.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP会话"><a href="#HTTP会话" class="headerlink" title="HTTP会话"></a><strong>HTTP会话</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-为什么需要会话？"><a href="#1-1-为什么需要会话？" class="headerlink" title="1.1 为什么需要会话？"></a><strong>1.1 为什么需要会话？</strong></h3><p>服务器接收请求时需要<strong>标识用户身份</strong>，当然首先可以想到<strong>IP地址</strong>可以作为<strong>唯一标识符</strong>，即某个时间段内来自同一IP地址的所有请求一定属于相同客户端。但是<strong>网络地址转换（NAT）并不可靠</strong>，比如大学校园或大型企业，可能有数千人使用相同的IP地址，其真实IP则隐藏在NAT路由之后。我们<strong>需要一个维护用户状态的机制</strong>，而HTTP协议本身是无状态的，所以所有的HTTP服务器都普遍采用了HTTP会话的概念。</p><h3 id="1-2-什么是会话？"><a href="#1-2-什么是会话？" class="headerlink" title="1.2 什么是会话？"></a><strong>1.2 什么是会话？</strong></h3><p>在网络领域，会话（session）是一种持久网络协议，在用户端（或用户代理）和服务器端间创建关联，从而起到交换数据包的作用机制。<strong>在不包含会话层（UDP）或无法长时间驻留会话层（HTTP）的传输协议中，会话的维持需要依靠在传输数据中的高级版程序</strong>。例如HTTP中使用Cookie存放一些如 <code>Session ID</code> 、参数和权限信息等。</p><p>会话是由服务器或Web应用程序管理的某些文件、内存片段、对象或容器，它包含了应用分配给它的各种数据。容器和用户浏览器直接通过某种方式连接起来，通常是赋予一个随机生成的字符串 <code>Session ID</code> 也叫会话ID。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010139.jpg" alt></p><h3 id="1-3-会话的作用"><a href="#1-3-会话的作用" class="headerlink" title="1.3 会话的作用"></a><strong>1.3 会话的作用</strong></h3><h4 id="1-3-1-维持状态"><a href="#1-3-1-维持状态" class="headerlink" title="1.3.1 维持状态"></a><strong>1.3.1 维持状态</strong></h4><p><strong>会话用于维持请求和请求之间的状态，HTTP请求自身是完全无状态的</strong>。在无状态的方式下，大部分应用程序无法正常工作，比如购物网站，所有的行为和功能都要基于用户身份，如购物车、收藏夹、支付等，可以想象没有状态的话所有的功能都必须一次成功走完，会话是维持请求状态的引擎。</p><h4 id="1-3-2-记住用户"><a href="#1-3-2-记住用户" class="headerlink" title="1.3.2 记住用户"></a><strong>1.3.2 记住用户</strong></h4><p><strong>会话的机制让系统能够记住用户</strong>：如论坛等网站，用户都要有用户名或“匿名”，用户登录后可以添加主题、回复主题、参与此人讨论等，所有流程中用户只须登录一次，系统需要记住此用户。</p><h4 id="1-3-3-启动应用程序工作流"><a href="#1-3-3-启动应用程序工作流" class="headerlink" title="1.3.3 启动应用程序工作流"></a><strong>1.3.3 启动应用程序工作流</strong></h4><p>通常用户在使用一些高级功能时，需要使用某种形式的<strong>工作流</strong>，比如新闻网站中发布新闻时，首先要进入编写标题、标语和正文的页面，然后下个页面选择相关图片，最后还可能要选择一些类似文章或关键字。以上三个步骤完成后，新闻被发布出去，这样的<strong>工作流通常包含多个步骤，每个步骤是单个任务，共同构成了整个工作流</strong>，所以请求之间需要维持一个状态。</p><hr><h2 id="第二节-简单使用"><a href="#第二节-简单使用" class="headerlink" title="第二节 简单使用"></a><strong>第二节 简单使用</strong></h2><h3 id="2-1-Cookie、Session、Token"><a href="#2-1-Cookie、Session、Token" class="headerlink" title="2.1 Cookie、Session、Token"></a><strong>2.1 Cookie、Session、Token</strong></h3><p>相关内容：<a href="../2019052101.html" title="Title">Cookie，Session，Token</a>。</p><h3 id="2-2-传输会话ID"><a href="#2-2-传输会话ID" class="headerlink" title="2.2 传输会话ID"></a><strong>2.2 传输会话ID</strong></h3><p>有两种流行的方式来传输会话ID：</p><ul><li>通过Set-Cookie头将JSESSIONID发送给浏览器。</li><li>通过URL直接拼接JSESSIONID。</li></ul><p>第二种方式可以避免使用Cookie，但所有请求URL都会嵌入会话ID。</p><h3 id="2-3-会话常见漏洞"><a href="#2-3-会话常见漏洞" class="headerlink" title="2.3 会话常见漏洞"></a><strong>2.3 会话常见漏洞</strong></h3><p>可以通过一些漏洞检测工具或如Open Web Application Security Project(OWASP)网站来进行检查。</p><h4 id="2-3-1-复制并粘贴错误"><a href="#2-3-1-复制并粘贴错误" class="headerlink" title="2.3.1 复制并粘贴错误"></a><strong>2.3.1 复制并粘贴错误</strong></h4><p>使用URL拼接的方式传输SessionID会面临一个问题：用户可能会不小心把URL复制到互联网上，如果一些人在会话结束前访问此URL，那么自然也会变当作此用户。</p><p>解决此问题的方法就是<strong>不要使用URL拼接这种方式</strong>，这并不奇怪，大部分网站都采用Cookie来作为通用的解决方案。</p><h4 id="2-3-2-会话固定"><a href="#2-3-2-会话固定" class="headerlink" title="2.3.2 会话固定"></a><strong>2.3.2 会话固定</strong></h4><p>会话固定攻击类似于复制粘贴错误，攻击者首先获得一个拼接SessionID的URL，然后将此URL传播出去，不知情的用户通过此URL在会话期间登录网站，那么攻击者也能够登录成功并访问被攻击用户的账户。</p><p>解决方法有：</p><ul><li>禁止在URL中嵌入会话ID，同时也需要在应用程序中禁止接受通过URL传递的会话ID。</li><li>在登录后采用会话迁移。即用户登录后，修改会话ID并将之前会话ID无效。</li></ul><h4 id="2-3-3-跨站脚本和会话劫持"><a href="#2-3-3-跨站脚本和会话劫持" class="headerlink" title="2.3.3 跨站脚本和会话劫持"></a><strong>2.3.3 跨站脚本和会话劫持</strong></h4><p><strong>跨站脚本攻击</strong>（CSRF）：攻击者会通过将JS注入某个页面，通过DOM属性 <code>document.cookie</code> 读取会话Cookie的内容，攻击者获得会话ID后，可以通过创建Cookie/或URL嵌入来模拟会话，直接使用被攻击用户的身份。</p><p>大致的触发流程是：</p><ol><li>用户登录了站点A，并且在Cookie中留下了A站点的认证信息</li><li>用户进入了站点B，而站点B用一些方式（比如一个提交行为是到A站点某关键接口的表单）引诱用户去点击。当用户点击时，会发出到A站点的请求。而浏览器会给这个请求附带上A站点的认证信息，从而让这个请求能够执行。这种行为可能是，但不限于，给某个A站点的某个其他用户提权/转账/发文辱骂等等。</li></ol><p>解决方法：</p><ol><li>编码和过滤，将HTML字符转换为 <code>HTML Entities</code> 编码，对js代码进行转义。</li><li>避免使用 <code>Cookie</code> ，而使用 <code>Local Storage</code> ，但会使XSS攻击更容易。</li><li>使用 <code>CSRF Token</code> 作表单验证。</li><li>给所有接口都添加一个请求 <code>secret</code> ，来标记其来自于合法的客户端。</li><li>用 <code>Same-Site Cookie</code> 限制站点必须同域名才能携带cookie。</li><li>总是用 <code>json</code> 格式提交，禁止允许跨域的 <code>application/x-www-form-urlencoded</code> 格式，而使用<code>application/json</code> 。</li><li>双认证，认证信息同时存放在 <code>HttpOnly Cookie</code> 和 <code>Authorization Header</code> ，并在服务器对比。</li><li>使用HTTPS，将Cookie设置为Secure，浏览器就可以只在访问https网址时才会携带Cookie。</li></ol><h4 id="2-3-4-不安全的Cookie"><a href="#2-3-4-不安全的Cookie" class="headerlink" title="2.3.4 不安全的Cookie"></a><strong>2.3.4 不安全的Cookie</strong></h4><p><strong>中间人攻击</strong>（MitM）：是一种典型的数据截获攻击，攻击者通过观察客户端和服务端交互的请求或响应，从中获取信息。</p><p>这种类型的攻击促进了<strong>安全套接字层</strong>和<strong>传输层安全</strong>（SSL/TLS）的发展，是HTTPS协议的基础。</p><p>解决方案是<strong>使用HTTPS协议</strong>，但仍存在的问题是<strong>应用可能同时支持HTTP和HTTPS</strong>，那么在HTTP请求重定向到HTTPS时攻击可能已经发生了（在用户浏览器通过未加密的方式发送会话ID cookie时，观察者已经窃取到此ID）。这种情况需要使用Cookie的 <code>Secure</code> 特性，此标志告诉浏览器只能通过HTTPS传输Cookie，即<strong>一直使用HTTPS</strong>。</p><h4 id="2-3-5-安全的会话"><a href="#2-3-5-安全的会话" class="headerlink" title="2.3.5 安全的会话"></a><strong>2.3.5 安全的会话</strong></h4><p><code>SSL/TLS 会话 ID</code> 通过去除必须在每次请求中都执行SSL握手的需求，改善了SSL协议的效率。<code>SSL/TLS 会话 ID</code> 在SSL握手期间建立，然后使用在后续请求中，将请求绑定在一起，决定加密和界面所使用的密钥。它与 <code>HTTP 会话 ID</code> 的区别在于其并不通过URL或Cookie来传输或存储，而是需要认证授权才能获取。</p><p>使用 <code>SSL/TLS 会话 ID</code> 需要一直使用HTTPS协议，并且SSL通信必须由Web容器完成，如果使用了Web服务器或负载均衡器管理SSL通信，Web容器将无法获得通信中的 <code>SSL/TLS 会话 ID</code> 值。在集群环境中，用户的请求必须要一直发生到同一服务器（多机不会备份会话信息）。服务端存储 <code>SSL/TLS 会话 ID</code> 对应的信息不太容易控制失效时间，太短起不到作用，太长又占用服务端大量资源。</p><hr><h2 id="第三节-在会话中存储数据"><a href="#第三节-在会话中存储数据" class="headerlink" title="第三节 在会话中存储数据"></a><strong>第三节 在会话中存储数据</strong></h2><hr><h2 id="第四节-使用会话"><a href="#第四节-使用会话" class="headerlink" title="第四节 使用会话"></a><strong>第四节 使用会话</strong></h2><hr><h2 id="第五节-将使用会话的应用集群化"><a href="#第五节-将使用会话的应用集群化" class="headerlink" title="第五节 将使用会话的应用集群化"></a><strong>第五节 将使用会话的应用集群化</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《JavaWeb高级编程——涵盖WebSockets、Spring Framework、JPA Hibernate和Spring Security》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="session" scheme="http://linyishui.top/tags/session/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="web" scheme="http://linyishui.top/tags/web/"/>
    
      <category term="java web" scheme="http://linyishui.top/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Redis</title>
    <link href="http://linyishui.top/2020050501.html"/>
    <id>http://linyishui.top/2020050501.html</id>
    <published>2020-05-05T03:44:21.000Z</published>
    <updated>2020-05-20T05:29:33.644Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h1><h2 id="第一节-综合"><a href="#第一节-综合" class="headerlink" title="第一节 综合"></a><strong>第一节 综合</strong></h2><h3 id="问：简单描述下-Redis？"><a href="#问：简单描述下-Redis？" class="headerlink" title="问：简单描述下 Redis？"></a><strong>问：简单描述下 Redis？</strong></h3><details><br><br>&emsp;&emsp;由C语言开发的一个开源的基于高性能键值对的内存数据库。是一个非关系型数据库。<br><br>&emsp;&emsp;<a href="https://zhuanlan.zhihu.com/p/118561398" target="_blank" rel="noopener">我和面试官的博弈：Redis 篇</a><br><br></details><h3 id="问：redis-最适合的场景？"><a href="#问：redis-最适合的场景？" class="headerlink" title="问：redis 最适合的场景？"></a><strong>问：redis 最适合的场景？</strong></h3><details><br><br>1. 会话缓存session cache<br>1. 排行榜/计数器ZRANGE<br>1. 发布/订阅<br><br></details><h3 id="问：redis支持哪些数据类型？"><a href="#问：redis支持哪些数据类型？" class="headerlink" title="问：redis支持哪些数据类型？"></a><strong>问：redis支持哪些数据类型？</strong></h3><details><br><br>&emsp;&emsp;string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog（做基数统计）、GEO（地理信息定位）等多种数据结构和算法<br><br></details><h3 id="问：Redis数据结构使用场景及底层实现？"><a href="#问：Redis数据结构使用场景及底层实现？" class="headerlink" title="问：Redis数据结构使用场景及底层实现？"></a><strong>问：Redis数据结构使用场景及底层实现？</strong></h3><details><br><br>&gt; <em> <strong>String</strong>：<br>&gt;<br>&gt; </em> <em> Simple dynamic string（SDS）的数据结构:<br>&gt;<br>&gt;     <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">&gt;      <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">&gt;      <span class="comment">//等于 SDS 保存字符串的长度</span></span><br><span class="line">&gt;      <span class="keyword">int</span> len；</span><br><span class="line">&gt;      <span class="comment">//记录 buf 数组中未使用字节的数量</span></span><br><span class="line">&gt;      <span class="keyword">int</span> <span class="built_in">free</span>；</span><br><span class="line">&gt;      <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">&gt;      <span class="keyword">char</span> buf[]；</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><br><br>&gt;<br>&gt;   </em> 优点：<br>&gt;<br>&gt;   <em> </em> 不会出现字符串变更造成的内存溢出问题<br>&gt;     <em> 获取字符串长度时间复杂度为1<br>&gt;     </em> 空间预分配， 惰性空间释放free字段，会默认留够一定的空间防止多次重分配内存<br>&gt;<br>&gt;   <em> 应用场景： String 缓存结构体用户信息，计数<br>&gt;<br>&gt; </em> <strong>Hash</strong>：<br>&gt;<br>&gt; <em> </em> 结构：数组+链表的基础上，进行了一些rehash优化<br>&gt;   <em> </em> Reids的Hash采用链地址法来处理冲突，然后它没有使用红黑树优化。<br>&gt;     <em> 哈希表节点采用单链表结构。<br>&gt;     </em> rehash优化 （采用分而治之的思想，将庞大的迁移工作量划分到每一次CURD中，避免了服务繁忙）<br>&gt;   <em> 应用场景： 保存结构体信息可部分获取不用序列化所有字段。<br>&gt;<br>&gt; </em> <strong>List</strong>：<br>&gt;<br>&gt; <em> </em> 应用场景：<br>&gt;   <em> </em> 比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现<br>&gt;     <em> list的实现为一个双向链表，即可以支持反向查找和遍历<br>&gt;<br>&gt; </em> <strong>Set</strong>：内部实现是一个 value为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员 是否在集合内的原因。<br>&gt;<br>&gt; <em> </em> 应用场景： 去重的场景，交集（sinter）、并集（sunion）、差集（sdiff），实现如共同关注、共同喜好、二度好友等功能。<br>&gt;<br>&gt; * <strong>Zset</strong>：内部使用HashMap和跳跃表（SkipList）来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 跳表：每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的 应用场景： 实现延时队列<br>&gt;<br><br></details><h3 id="问：redis-如何存储一个-String-的？"><a href="#问：redis-如何存储一个-String-的？" class="headerlink" title="问：redis 如何存储一个 String 的？"></a><strong>问：redis 如何存储一个 String 的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis单线程为什么执行速度这么快？"><a href="#问：redis单线程为什么执行速度这么快？" class="headerlink" title="问：redis单线程为什么执行速度这么快？"></a><strong>问：redis单线程为什么执行速度这么快？</strong></h3><details><br><br>1. 纯内存操作，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快<br>2. 单线程操作，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗<br>3. 采用了非阻塞I/O多路复用机制<br><br></details><h3 id="问：Redis高并发快的原因？"><a href="#问：Redis高并发快的原因？" class="headerlink" title="问：Redis高并发快的原因？"></a><strong>问：Redis高并发快的原因？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis事务？"><a href="#问：redis事务？" class="headerlink" title="问：redis事务？"></a><strong>问：redis事务？</strong></h3><details><br>1. Multi开启事务<br>1. Exec执行事务块内命令<br>1. Discard 取消事务<br>1. Watch 监视一个或多个key，如果事务执行前key被改动，事务将打断<br><br></details><h3 id="问：redis事务的实现特征？"><a href="#问：redis事务的实现特征？" class="headerlink" title="问：redis事务的实现特征？"></a><strong>问：redis事务的实现特征？</strong></h3><details><br><br>1. 所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行<br>1. Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行<br>1. 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行<br>1. 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。<br><br>&emsp;&emsp;然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。<br><br>&emsp;&emsp;Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了<br><br></details><h3 id="问：Redis的同步机制？"><a href="#问：Redis的同步机制？" class="headerlink" title="问：Redis的同步机制？"></a><strong>问：Redis的同步机制？</strong></h3><details><br><br>&gt; <em> 全量拷贝：<br>&gt; </em> 1. slave第一次启动时，连接Master，发送PSYNC命令，<br>&gt;   2. master会执行bgsave命令来生成rdb文件，期间的所有写命令将被写入缓冲区。<br>&gt;   3. master bgsave执行完毕，向slave发送rdb文件<br>&gt;   4. slave收到rdb文件，丢弃所有旧数据，开始载入rdb文件<br>&gt;   5. rdb文件同步结束之后，slave执行从master缓冲区发送过来的所以写命令。此后 master 每执行一个写命令，就向slave发送相同的写命令。<br>&gt; <em> 增量拷贝：<br>&gt; </em> <em> 如果出现网络闪断或者命令丢失等异常情况，从节点之前保存了自身已复制的偏移量和主节点的运行ID<br>&gt;      </em> 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。<br><br></details><br>### <strong>问：redis集群模式性能优化？</strong><br><br><details><br><br>1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件<br>1. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次<br>1. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内<br>1. 尽量避免在压力很大的主库上增加从库<br>1. 主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master - Slave1 - Slave2 - Slave3…</code> 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。<br><br></details><h3 id="问：Redis集群方案？"><a href="#问：Redis集群方案？" class="headerlink" title="问：Redis集群方案？"></a><strong>问：Redis集群方案？</strong></h3><details><br><br>&emsp;&emsp;<br>1. 官方cluster方案<br>1. twemproxy：代理方案twemproxy是一个单点，很容易对其造成很大的压力，所以通常会结合keepalived来实twemproy的高可用<br>1. codis 基于客户端来进行分片<br><br></details><br>### <strong>问：集群不可用场景？</strong><br><br><details><br><br>1. master挂掉，且当前master没有slave<br>1. 集群超过半数以上master挂掉，无论是否有slave集群进入fail状态<br><br></details><h3 id="问：缓存淘汰策略？"><a href="#问：缓存淘汰策略？" class="headerlink" title="问：缓存淘汰策略？"></a><strong>问：缓存淘汰策略？</strong></h3><details><br><br>1. 先进先出算法（FIFO）<br><br>1. 最近使用最少Least Frequently Used（LFU）<br><br>1. 最长时间未被使用的Least Recently Used（LRU）<br><br>&emsp;&emsp;当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重<br><br></details><h3 id="问：redis过期key删除策略？"><a href="#问：redis过期key删除策略？" class="headerlink" title="问：redis过期key删除策略？"></a><strong>问：redis过期key删除策略？</strong></h3><details><br><br>1. 惰性删除，cpu友好，但是浪费cpu资源<br><br>1. 定时删除（不常用）<br><br>1. 定期删除，cpu友好，节省空间<br><br></details><h3 id="问：缓存雪崩以及处理办法？"><a href="#问：缓存雪崩以及处理办法？" class="headerlink" title="问：缓存雪崩以及处理办法？"></a><strong>问：缓存雪崩以及处理办法？</strong></h3><details><br><br>&emsp;&emsp;同一时刻大量缓存失效；<br><br>&gt;处理方法：<br>&gt; 1. 缓存数据增加过期标记<br>&gt; 1. 设置不同的缓存失效时间<br>&gt; 1. 双层缓存策略C1为短期，C2为长期<br>&gt; 1. 定时更新策略<br><br></details><h3 id="问：缓存击穿原因以及处理办法？"><a href="#问：缓存击穿原因以及处理办法？" class="headerlink" title="问：缓存击穿原因以及处理办法？"></a><strong>问：缓存击穿原因以及处理办法？</strong></h3><details><br>&emsp;&emsp;频繁请求查询系统中不存在的数据导致；<br><br>&gt;处理方法：<br>&gt; 1. cache null策略，查询反馈结果为null仍然缓存这个null结果，设置不超过5分钟过期时间<br>&gt; 1. 布隆过滤器，所有可能存在的数据映射到足够大的bitmap中 google布隆过滤器：基于内存，重启失效不支持大数据量，无法在分布式场景 redis布隆过滤器：可扩展性，不存在重启失效问题，需要网络io，性能低于google<br><br></details><h3 id="问：redis阻塞原因？"><a href="#问：redis阻塞原因？" class="headerlink" title="问：redis阻塞原因？"></a><strong>问：redis阻塞原因？</strong></h3><details><br><br>1. 数据结构使用不合理bigkey<br>1. CPU饱和<br>1. 持久化阻塞，rdb fork子线程，aof每秒刷盘等<br><br></details><h3 id="问：hot-key出现造成集群访问量倾斜解决办法？"><a href="#问：hot-key出现造成集群访问量倾斜解决办法？" class="headerlink" title="问：hot key出现造成集群访问量倾斜解决办法？"></a><strong>问：hot key出现造成集群访问量倾斜解决办法？</strong></h3><details><br><br>1. 使用本地缓存<br>1. 利用分片算法的特性，对key进行打散处理（给hot key加上前缀或者后缀，把一个hotkey 的数量变成 redis 实例个数N的倍数M，从而由访问一个 redis key 变成访问 N * M 个redis key）<br><br></details><h3 id="问：Redis分布式锁？"><a href="#问：Redis分布式锁？" class="headerlink" title="问：Redis分布式锁？"></a><strong>问：Redis分布式锁？</strong></h3><details><br><br>&emsp;&emsp;2.6版本以后lua脚本保证setnx跟setex进行原子性（setnx之后，未setex，服务挂了，锁不释放） a获取锁，超过过期时间，自动释放锁，b获取到锁执行，a代码执行完remove锁，a和b是一样的key，导致a释放了b的锁。 解决办法：remove之前判断value（高并发下value可能被修改，应该用lua来保证原子性）<br><br></details><h3 id="问：Redis如何做持久化？"><a href="#问：Redis如何做持久化？" class="headerlink" title="问：Redis如何做持久化？"></a><strong>问：Redis如何做持久化？</strong></h3><details><br><br>&emsp;&emsp;bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据 ，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来 实 现完整恢复重启之前的状态。<br><br></details><h3 id="问：对方追问那如果突然机器掉电会怎样？"><a href="#问：对方追问那如果突然机器掉电会怎样？" class="headerlink" title="问：对方追问那如果突然机器掉电会怎样？"></a><strong>问：对方追问那如果突然机器掉电会怎样？</strong></h3><details><br><br>&emsp;&emsp;取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据.<br><br></details><h3 id="问：redis锁续租问题？"><a href="#问：redis锁续租问题？" class="headerlink" title="问：redis锁续租问题？"></a><strong>问：redis锁续租问题？</strong></h3><details><br><br><br>1. 基于redis的redission分布式可重入锁RLock，以及配合java集合中lock；<br><br>1. Redission 内部提供了一个监控锁的看门狗，不断延长锁的有效期，默认检查锁的超时时间是30秒<br><br>1. 此方案的问题：如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master ，slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。<br><br>&emsp;&emsp;接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。 此时就会导致多个客户端对一个分布式锁完成了加锁 解决办法：只需要将新的redis实例，在一个TTL时间内，对客户端不可用即可，在这个时间内，所有客户端锁将被失效或者自动释放.<br><br></details><h3 id="问：bgsave的原理是什么？"><a href="#问：bgsave的原理是什么？" class="headerlink" title="问：bgsave的原理是什么？"></a><strong>问：bgsave的原理是什么？</strong></h3><details><br><br>&emsp;&emsp;fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写进的页面数据会逐渐和子进程分离开来。<br><br></details><h3 id="问：RDB与AOF区别？"><a href="#问：RDB与AOF区别？" class="headerlink" title="问：RDB与AOF区别？"></a><strong>问：RDB与AOF区别？</strong></h3><details><br><br>1. R文件格式紧凑，方便数据恢复，保存rdb文件时父进程会fork出子进程由其完成具体持久化工作，最大化redis性能，恢复大数据集速度更快，只有手动提交save命令或关闭命令时才触发备份操作；<br><br>1. A记录对服务器的每次写操作（默认1s写入一次），保存数据更完整，在redis重启是会重放这些命令来恢复数据，操作效率高，故障丢失数据更少，但是文件体积更大；<br><br></details><h3 id="问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a><strong>问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></h3><details><br><br>&emsp;&emsp;使用keys指令可以扫出指定模式的key列表。 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了 ，但是整体所花费的时间会比直接用keys指令长。<br><br></details><h3 id="问：如何使用Redis做异步队列？"><a href="#问：如何使用Redis做异步队列？" class="headerlink" title="问：如何使用Redis做异步队列？"></a><strong>问：如何使用Redis做异步队列？</strong></h3><details><br><br>&emsp;&emsp;一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。<br><br></details><h3 id="问：可不可以不用sleep呢？"><a href="#问：可不可以不用sleep呢？" class="headerlink" title="问：可不可以不用sleep呢？"></a><strong>问：可不可以不用sleep呢？</strong></h3><details><br><br>&emsp;&emsp;list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。<br><br></details><h3 id="问：能不能生产一次消费多次呢？"><a href="#问：能不能生产一次消费多次呢？" class="headerlink" title="问：能不能生产一次消费多次呢？"></a><strong>问：能不能生产一次消费多次呢？</strong></h3><details><br><br>&emsp;&emsp;使用pub/sub主题订阅者模式，可以实现1：N的消息队列。<br><br></details><h3 id="问：pub-sub有什么缺点？"><a href="#问：pub-sub有什么缺点？" class="headerlink" title="问：pub/sub有什么缺点？"></a><strong>问：pub/sub有什么缺点？</strong></h3><details><br><br>&emsp;&emsp;在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。<br><br></details><h3 id="问：redis如何实现延时队列？"><a href="#问：redis如何实现延时队列？" class="headerlink" title="问：redis如何实现延时队列？"></a><strong>问：redis如何实现延时队列？</strong></h3><details><br><br>&emsp;&emsp;使用sortedset，想要执行时间的时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。<br><br></details><h3 id="问：为啥redis-zset使用跳跃链表而不用红黑树实现？"><a href="#问：为啥redis-zset使用跳跃链表而不用红黑树实现？" class="headerlink" title="问：为啥redis zset使用跳跃链表而不用红黑树实现？"></a><strong>问：为啥redis zset使用跳跃链表而不用红黑树实现？</strong></h3><details><br><br>1. skiplist的复杂度和红黑树一样，而且实现起来更简单。<br>1. 在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。<br><br></details><h3 id="问：redis-的过期策略？"><a href="#问：redis-的过期策略？" class="headerlink" title="问：redis 的过期策略？"></a><strong>问：redis 的过期策略？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis-持久化策略？"><a href="#问：redis-持久化策略？" class="headerlink" title="问：redis 持久化策略？"></a><strong>问：redis 持久化策略？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？"><a href="#问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？"></a><strong>问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis了解吗？你说说怎么用redis实现分布式锁？"><a href="#问：redis了解吗？你说说怎么用redis实现分布式锁？" class="headerlink" title="问：redis了解吗？你说说怎么用redis实现分布式锁？"></a><strong>问：redis了解吗？你说说怎么用redis实现分布式锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构-分别用在什么场景-zset底层怎么实现的"><a href="#问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构-分别用在什么场景-zset底层怎么实现的" class="headerlink" title="问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构? 分别用在什么场景? zset底层怎么实现的?"></a><strong>问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构? 分别用在什么场景? zset底层怎么实现的?</strong></h3><details><br><br>&emsp;&emsp;既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树。你们用了redis，redis的底层数据结构了解多少？<br><br></details><h3 id="问：如何解决-Redis-的并发竞争-Key-问题？"><a href="#问：如何解决-Redis-的并发竞争-Key-问题？" class="headerlink" title="问：如何解决 Redis 的并发竞争 Key 问题？"></a><strong>问：如何解决 Redis 的并发竞争 Key 问题？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：项目用到了redis，讲讲你项目用到了redis的哪些特性？"><a href="#问：项目用到了redis，讲讲你项目用到了redis的哪些特性？" class="headerlink" title="问：项目用到了redis，讲讲你项目用到了redis的哪些特性？"></a><strong>问：项目用到了redis，讲讲你项目用到了redis的哪些特性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；"><a href="#问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；" class="headerlink" title="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；"></a><strong>问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis中的字符串类型是怎么实现的？"><a href="#问：redis中的字符串类型是怎么实现的？" class="headerlink" title="问：redis中的字符串类型是怎么实现的？"></a><strong>问：redis中的字符串类型是怎么实现的？</strong></h3><details><br><br>&emsp;&emsp;(SDS)注:sds为redis底层数据结构之一<br><br></details><h3 id="问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？"><a href="#问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？" class="headerlink" title="问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？"></a><strong>问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？</strong></h3><details><br><br>&emsp;&emsp;（共有4个优点，前不久刚看过，当时只回忆起1个优点。。）<br><br></details><h3 id="问：关于redis对象系统的一个问题？"><a href="#问：关于redis对象系统的一个问题？" class="headerlink" title="问：关于redis对象系统的一个问题？"></a><strong>问：关于redis对象系统的一个问题？</strong></h3><details><br><br>&emsp;&emsp;（我说忘记了，记得redis设计与实现有写，面试小哥：忘记了那就不问了）<br><br></details><h3 id="问：redis主从机制了解么？怎么实现的？"><a href="#问：redis主从机制了解么？怎么实现的？" class="headerlink" title="问：redis主从机制了解么？怎么实现的？"></a><strong>问：redis主从机制了解么？怎么实现的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何利用Redis处理热点数据？"><a href="#问：如何利用Redis处理热点数据？" class="headerlink" title="问：如何利用Redis处理热点数据？"></a><strong>问：如何利用Redis处理热点数据？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈Redis哨兵、复制、集群？"><a href="#问：谈谈Redis哨兵、复制、集群？" class="headerlink" title="问：谈谈Redis哨兵、复制、集群？"></a><strong>问：谈谈Redis哨兵、复制、集群？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis-的部署方式，主从，集群？"><a href="#问：redis-的部署方式，主从，集群？" class="headerlink" title="问：redis 的部署方式，主从，集群？"></a><strong>问：redis 的部署方式，主从，集群？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis-的哨兵模式，一个-key-值如何在-redis-集群中找到存储在哪？"><a href="#问：redis-的哨兵模式，一个-key-值如何在-redis-集群中找到存储在哪？" class="headerlink" title="问：redis 的哨兵模式，一个 key 值如何在 redis 集群中找到存储在哪？"></a><strong>问：redis 的哨兵模式，一个 key 值如何在 redis 集群中找到存储在哪？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：你们怎么解决缓存击穿问题的？"><a href="#问：你们怎么解决缓存击穿问题的？" class="headerlink" title="问：你们怎么解决缓存击穿问题的？"></a><strong>问：你们怎么解决缓存击穿问题的？</strong></h3><details><br><br>&emsp;&emsp;注:估计答了Hystrix<br><br></details><h3 id="问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？"><a href="#问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？" class="headerlink" title="问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？"></a><strong>问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"><a href="#问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？" class="headerlink" title="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"></a><strong>问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？</strong></h3><details><br><br>&emsp;&emsp;注:估计答了Hystrix<br><br></details><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Redis相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Dubbo</title>
    <link href="http://linyishui.top/2020050401.html"/>
    <id>http://linyishui.top/2020050401.html</id>
    <published>2020-05-04T03:42:50.000Z</published>
    <updated>2020-05-12T07:49:18.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><strong>Dubbo</strong></h1><h2 id="第一节-待整理"><a href="#第一节-待整理" class="headerlink" title="第一节 待整理"></a><strong>第一节 待整理</strong></h2><h4 id="问：dubbo流程？"><a href="#问：dubbo流程？" class="headerlink" title="问：dubbo流程？"></a><strong>问：dubbo流程？</strong></h4><details><br><br>&emsp;&emsp;（1）：生产者（Provider）启动，向注册中心（Register）注册<br><br>（2）：消费者（Consumer）订阅，而后注册中心通知消费者<br><br>（3）：消费者从生产者进行消费<br><br>（4）：监控中心（Monitor）统计生产者和消费者<br><br></details><h4 id="问：Dubbo推荐使用什么序列化框架，还有哪些？"><a href="#问：Dubbo推荐使用什么序列化框架，还有哪些？" class="headerlink" title="问：Dubbo推荐使用什么序列化框架，还有哪些？"></a><strong>问：Dubbo推荐使用什么序列化框架，还有哪些？</strong></h4><details><br><br>&emsp;&emsp;推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化<br><br></details><h4 id="问：Dubbo默认使用的是什么通信框架，还有哪些？"><a href="#问：Dubbo默认使用的是什么通信框架，还有哪些？" class="headerlink" title="问：Dubbo默认使用的是什么通信框架，还有哪些？"></a><strong>问：Dubbo默认使用的是什么通信框架，还有哪些？</strong></h4><details><br><br>&emsp;&emsp;默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。<br><br></details><h4 id="问：Dubbo有哪几种负载均衡策略，默认是哪种？"><a href="#问：Dubbo有哪几种负载均衡策略，默认是哪种？" class="headerlink" title="问：Dubbo有哪几种负载均衡策略，默认是哪种？"></a><strong>问：Dubbo有哪几种负载均衡策略，默认是哪种？</strong></h4><details><br><br>&emsp;&emsp;<br>（1）：随机调用{默认}<br><br>（2）：权重轮询<br><br>（3）：最少活跃数<br><br>（4）：一致性Hash<br><br></details><h4 id="问：RPC流程？"><a href="#问：RPC流程？" class="headerlink" title="问：RPC流程？"></a><strong>问：RPC流程？</strong></h4><details><br><br>&emsp;&emsp;（1）消费者调用需要消费的服务，<br><br>（2）：客户端存根将方法、入参等信息序列化发送给服务端存根<br><br>（3）：服务端存根反序列化操作根据解码结果调用本地的服务进行相关处理<br><br>（4）：本地服务执行具体业务逻辑并将处理结果返回给服务端存根<br><br>（5）：服务端存根序列化<br><br>（6）：客户端存根反序列化<br><br>（7）：服务消费方得到最终结果<br><br>RPC框架的实现目标PC框架的实现目标是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务<br><br></details><h4 id="问：服务暴露、服务引用、服务调用（TODO）？"><a href="#问：服务暴露、服务引用、服务调用（TODO）？" class="headerlink" title="问：服务暴露、服务引用、服务调用（TODO）？"></a><strong>问：服务暴露、服务引用、服务调用（TODO）？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Dubbo相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Mybatis</title>
    <link href="http://linyishui.top/2020050301.html"/>
    <id>http://linyishui.top/2020050301.html</id>
    <published>2020-05-03T10:44:58.000Z</published>
    <updated>2020-05-20T04:56:29.179Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a><strong>Mybatis</strong></h1><h2 id="第一节-综合"><a href="#第一节-综合" class="headerlink" title="第一节 综合"></a><strong>第一节 综合</strong></h2><h4 id="问：Mybatis原理？"><a href="#问：Mybatis原理？" class="headerlink" title="问：Mybatis原理？"></a><strong>问：Mybatis原理？</strong></h4><details><br><br>&gt; <em> sqlsessionFactoryBuilder生成sqlsessionFactory（单例）<br>&gt; </em> 工厂模式生成sqlsession执行sql以及控制事务<br>&gt; * Mybatis通过动态代理使Mapper（sql映射器）接口能运行起来即为接口生成代理对象将sql查询到结果映射成pojo<br><br></details><h4 id="问：sqlSessionFactory构建过程？"><a href="#问：sqlSessionFactory构建过程？" class="headerlink" title="问：sqlSessionFactory构建过程？"></a><strong>问：sqlSessionFactory构建过程？</strong></h4><details><br><br>&gt; <em> 解析并读取配置中的xml创建Configuration对象 （单例）<br>&gt; </em> 使用Configruation类去创建sqlSessionFactory（builder模式）<br><br></details><h4 id="问：Mybatis一级缓存与二级缓存？"><a href="#问：Mybatis一级缓存与二级缓存？" class="headerlink" title="问：Mybatis一级缓存与二级缓存？"></a><strong>问：Mybatis一级缓存与二级缓存？</strong></h4><details><br><br>&emsp;&emsp;默认情况下一级缓存是开启的，而且是不能关闭的。<br><br>&gt; <em> 一级缓存是指 SqlSession 级别的缓存 原理：使用的数据结构是一个 map，如果两次中间出现 commit 操作 （修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空<br>&gt; </em> 二级缓存是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存； 原理： 是通过 CacheExecutor 实现的。CacheExecutor其实是 Executor 的代理对象<br><br></details><h3 id="问：讲一下Mybatis基于接口完成查询的过程及原理？"><a href="#问：讲一下Mybatis基于接口完成查询的过程及原理？" class="headerlink" title="问：讲一下Mybatis基于接口完成查询的过程及原理？"></a><strong>问：讲一下Mybatis基于接口完成查询的过程及原理？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Mybatis的一级缓存和二级缓存？"><a href="#问：讲一下Mybatis的一级缓存和二级缓存？" class="headerlink" title="问：讲一下Mybatis的一级缓存和二级缓存？"></a><strong>问：讲一下Mybatis的一级缓存和二级缓存？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Mybatis相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——分布式</title>
    <link href="http://linyishui.top/2020050201.html"/>
    <id>http://linyishui.top/2020050201.html</id>
    <published>2020-05-02T10:45:03.000Z</published>
    <updated>2020-05-20T05:20:37.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h1><h2 id="第一节-待整理"><a href="#第一节-待整理" class="headerlink" title="第一节 待整理"></a><strong>第一节 待整理</strong></h2><h4 id="问：分布式事务的控制？"><a href="#问：分布式事务的控制？" class="headerlink" title="问：分布式事务的控制？"></a><strong>问：分布式事务的控制？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：分布式锁如何设计？"><a href="#问：分布式锁如何设计？" class="headerlink" title="问：分布式锁如何设计？"></a><strong>问：分布式锁如何设计？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：分布式-session-如何设计？"><a href="#问：分布式-session-如何设计？" class="headerlink" title="问：分布式 session 如何设计？"></a><strong>问：分布式 session 如何设计？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：dubbo-的组件有哪些，及其作用？"><a href="#问：dubbo-的组件有哪些，及其作用？" class="headerlink" title="问：dubbo 的组件有哪些，及其作用？"></a><strong>问：dubbo 的组件有哪些，及其作用？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：dubbo-SPI-机制；远程接口调用过程？"><a href="#问：dubbo-SPI-机制；远程接口调用过程？" class="headerlink" title="问：dubbo SPI 机制；远程接口调用过程？"></a><strong>问：dubbo SPI 机制；远程接口调用过程？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：dubbo-支持的协议及序列化方式？"><a href="#问：dubbo-支持的协议及序列化方式？" class="headerlink" title="问：dubbo 支持的协议及序列化方式？"></a><strong>问：dubbo 支持的协议及序列化方式？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：dubbo-的负载均衡和容错策略？"><a href="#问：dubbo-的负载均衡和容错策略？" class="headerlink" title="问：dubbo 的负载均衡和容错策略？"></a><strong>问：dubbo 的负载均衡和容错策略？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：zookeeper-的-ZAB-协议工作原理？"><a href="#问：zookeeper-的-ZAB-协议工作原理？" class="headerlink" title="问：zookeeper 的 ZAB 协议工作原理？"></a><strong>问：zookeeper 的 ZAB 协议工作原理？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：zookeeper-的-Watcher-机制？"><a href="#问：zookeeper-的-Watcher-机制？" class="headerlink" title="问：zookeeper 的 Watcher 机制？"></a><strong>问：zookeeper 的 Watcher 机制？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：zookeeper-的数据存储？"><a href="#问：zookeeper-的数据存储？" class="headerlink" title="问：zookeeper 的数据存储？"></a><strong>问：zookeeper 的数据存储？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：zookeeper-的负载均衡算法？"><a href="#问：zookeeper-的负载均衡算法？" class="headerlink" title="问：zookeeper 的负载均衡算法？"></a><strong>问：zookeeper 的负载均衡算法？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：rocketmq-的模块功能？"><a href="#问：rocketmq-的模块功能？" class="headerlink" title="问：rocketmq 的模块功能？"></a><strong>问：rocketmq 的模块功能？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：rocketmq-的高可用及高性能？"><a href="#问：rocketmq-的高可用及高性能？" class="headerlink" title="问：rocketmq 的高可用及高性能？"></a><strong>问：rocketmq 的高可用及高性能？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：elasticsearch-的系统架构及读写过程？"><a href="#问：elasticsearch-的系统架构及读写过程？" class="headerlink" title="问：elasticsearch 的系统架构及读写过程？"></a><strong>问：elasticsearch 的系统架构及读写过程？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：elasticsearch-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"><a href="#问：elasticsearch-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？" class="headerlink" title="问：elasticsearch 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"></a><strong>问：elasticsearch 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：eureka-的相关原理，和-zookeeper-的比较？"><a href="#问：eureka-的相关原理，和-zookeeper-的比较？" class="headerlink" title="问：eureka 的相关原理，和 zookeeper 的比较？"></a><strong>问：eureka 的相关原理，和 zookeeper 的比较？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><h4 id="问：LVS（4层与7层）原理？"><a href="#问：LVS（4层与7层）原理？" class="headerlink" title="问：LVS（4层与7层）原理？"></a><strong>问：LVS（4层与7层）原理？</strong></h4><details><br><br>&gt; <em> 由前端虚拟负载均衡器和后端真实服务器群组成；<br>&gt; </em> 请求发送给虚拟服务器后其根据包转发策略以及负载均衡调度算法转发给真实服务器<br>&gt; * 所谓四层（lvs，f5）就是基于IP+端口的负载均衡；七层（nginx）就是基于URL等应用层信息的负载均衡<br><br></details><h4 id="问：zookeeper实现分布式锁？"><a href="#问：zookeeper实现分布式锁？" class="headerlink" title="问：zookeeper实现分布式锁？"></a><strong>问：zookeeper实现分布式锁？</strong></h4><details><br><br>&emsp;&emsp;<br>（1）：利用节点名称唯一性来实现，加锁时所有客户端一起创建节点，只有一个创建成功者获得锁，解锁时删除节点。<br><br>（2）：利用临时顺序节点实现，加锁时所有客户端都创建临时顺序节点，创建节点序列号最小的获得锁，否则监视比自己序列号次小的节点进行等待<br><br>（3）：方案2比1好处是当zookeeper宕机后，临时顺序节点会自动删除释放锁，不会造成锁等待；<br><br>（4）：方案1会产生惊群效应（当有很多进程在等待锁的时候，在释放锁的时候会有很多进程就过来争夺锁）。<br><br>（5）：由于需要频繁创建和删除节点，性能上不如redis锁<br><br></details><h4 id="问：分布式ID？"><a href="#问：分布式ID？" class="headerlink" title="问：分布式ID？"></a><strong>问：分布式ID？</strong></h4><details><br><br>&emsp;&emsp;<a href="https://zhuanlan.zhihu.com/p/107420326" target="_blank" rel="noopener">9种 分布式ID生成方式</a><br><br></details>]]></content>
    
    <summary type="html">
    
      整理面试中常问的分布式相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Spring Cloud</title>
    <link href="http://linyishui.top/2020050101.html"/>
    <id>http://linyishui.top/2020050101.html</id>
    <published>2020-05-01T10:44:28.000Z</published>
    <updated>2020-05-12T07:33:08.027Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a><strong>Java并发编程</strong></h1><h2 id="第一节-待整理"><a href="#第一节-待整理" class="headerlink" title="第一节 待整理"></a><strong>第一节 待整理</strong></h2><h4 id="问：Zuul与Gateway区别？"><a href="#问：Zuul与Gateway区别？" class="headerlink" title="问：Zuul与Gateway区别？"></a><strong>问：Zuul与Gateway区别？</strong></h4><details><br><br>（1）：zuul则是netflix公司的项目集成在spring-cloud中使用而已， Gateway是spring-cloud的 一个子项目；<br><br>（2）：zuul不提供异步支持流控等均由hystrix支持， gateway提供了异步支持，提供了抽象负载均衡，提供了抽象流控； 理论上gateway则更适合于提高系统吞吐量（但不一定能有更好的性能），最终性能还需要通过严密的压测来决定<br><br>（3）：两者底层实现都是servlet，但是gateway多嵌套了一层webflux框架<br><br>（4）： zuul可用至其他微服务框架中，内部没有实现限流、负载均衡；gateway只能用在springcloud中；<br><br></details><h4 id="问：Zuul原理分析？"><a href="#问：Zuul原理分析？" class="headerlink" title="问：Zuul原理分析？"></a><strong>问：Zuul原理分析？</strong></h4><details><br><br>（1）：请求给zuulservlet处理（HttpServlet子类） zuulservlet中有一个zuulRunner对象，该对象中初始化了RequestContext（存储请求的数据），RequestContext被所有的zuulfilter共享；<br><br>（2）： zuulRunner中有 FilterProcessor（zuulfilter的管理器），其从filterloader 中获取zuulfilter；<br><br>（3）：有了这些filter之后， zuulservelet执行的Pre-&gt; route-&gt; post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行error类型的过滤器，执行完后把结果返回给客户端.<br><br></details><h4 id="问：Gateway原理分析？"><a href="#问：Gateway原理分析？" class="headerlink" title="问：Gateway原理分析？"></a><strong>问：Gateway原理分析？</strong></h4><details><br><br>（1）：请求到达DispatcherHandler， DispatchHandler在IOC容器初始化时会在容器中实例化HandlerMapping接口<br><br>（2）：用handlerMapping根据请求URL匹配到对应的Route，然后有对应的filter做对应的请求转发最终response返回去<br><br></details><h4 id="问：Zookeeper-工作原理（待查）？"><a href="#问：Zookeeper-工作原理（待查）？" class="headerlink" title="问：Zookeeper 工作原理（待查）？"></a><strong>问：Zookeeper 工作原理（待查）？</strong></h4><details><br><br>&emsp;&emsp;Zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。<br><br></details><h4 id="问：zoo与eur区别？"><a href="#问：zoo与eur区别？" class="headerlink" title="问：zoo与eur区别？"></a><strong>问：zoo与eur区别？</strong></h4><details><br><br>&gt; <em> zookeeper保证cp（一致性）<br>&gt; </em> eureka保证ap（可用性）<br>&gt; <em> zoo在选举期间注册服务瘫痪，期间不可用<br>&gt; </em> eur各个节点平等关系，只要有一台就可保证服务可用，而查询到的数据可能不是最新的，可以很好应对网络故障导致部分节点失联情况<br>&gt; <em> zoo有leader和follower角色，eur各个节点平等<br>&gt; </em> zoo采用半数存活原则（避免脑裂），eur采用自我保护机制来解决分区问题<br>&gt; * eur本质是个工程，zoo只是一个进程 ZooKeeper基于CP，不保证高可用，如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。 Eureka基于AP，能保证高可用，即使所有机器都挂了，也能拿到本地缓存的数据。作为注册中心，其实配置是不经常变动的，只有发版（发布新的版本）和机器出故障时会变。对于不经常变动的配置来说，CP是不合适的，而AP在遇到问题时可以用牺牲一致性来保证可用性，既返回旧数据，缓存数据。 所以理论上Eureka是更适合做注册中心。而现实环境中大部分项目可能会使用ZooKeeper，那是因为集群不够大，并且基本不会遇到用做注册中心的机器一半以上都挂了的情况。所以实际上也没什么大问题。<br><br></details><h4 id="问：Hystrix原理（待查）？"><a href="#问：Hystrix原理（待查）？" class="headerlink" title="问：Hystrix原理（待查）？"></a><strong>问：Hystrix原理（待查）？</strong></h4><details><br><br>&emsp;&emsp;通过维护一个自己的线程池，当线程池达到阈值的时候，就启动服务降级，返回fallback默认值<br><br></details><h4 id="问：为什么需要hystrix熔断？"><a href="#问：为什么需要hystrix熔断？" class="headerlink" title="问：为什么需要hystrix熔断？"></a><strong>问：为什么需要hystrix熔断？</strong></h4><details><br><br>&emsp;&emsp;防止雪崩，及时释放资源，防止系统发生更多的额级联故障，需要对故障和延迟进行隔离，防止单个依赖关系的失败影响整个应用程序；<br><br></details><h4 id="问：微服务优缺点？"><a href="#问：微服务优缺点？" class="headerlink" title="问：微服务优缺点？"></a><strong>问：微服务优缺点？</strong></h4><details><br><br>&gt; <em> 每个服务高内聚，松耦合，面向接口编程；<br>&gt; </em> 服务间通信成本，数据一致性，多服务运维难度增加，http传输效率不如rpc<br><br></details><h4 id="问：eureka自我保护机制？"><a href="#问：eureka自我保护机制？" class="headerlink" title="问：eureka自我保护机制？"></a><strong>问：eureka自我保护机制？</strong></h4><details><br><br>&gt; <em> eur不移除长时间没收到心跳而应该过期的服务<br>&gt; </em> 仍然接受新服务注册和查询请求，但是不会同步到其它节点（高可用）<br>&gt; * 当网络稳定后，当前实例新注册信息会同步到其它节点（最终一致性）<br><br></details><h4 id="问：MQ对比？"><a href="#问：MQ对比？" class="headerlink" title="问：MQ对比？"></a><strong>问：MQ对比？</strong></h4><details><br><br>&gt; <em> ActiveMQ：Apache出品，最早使用的消息队列产品，时间比较长了，最近版本更新比较缓慢。 RabbitMQ：erlang语言开发，支持很多的协议，非常重量级，更适合于企业级的开发。性能较好，但是不利于做二次开发和维护。<br>&gt; </em> RocketMQ：阿里开源的消息中间件，纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点，分布式事务。 ZeroMQ：号称最快的消息队列系统，尤其针对大吞吐量的需求场景，采用 C 语言实现。 消息队列的选型需要根据具体应用需求而定，ZeroMQ 小而美，RabbitMQ 大而稳，Kakfa 和 RocketMQ 快而强劲<br><br></details><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Spring Cloud相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>对象序列化</title>
    <link href="http://linyishui.top/2020042501.html"/>
    <id>http://linyishui.top/2020042501.html</id>
    <published>2020-04-25T10:21:08.000Z</published>
    <updated>2020-06-29T08:41:51.921Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是序列化？"><a href="#1-1-什么是序列化？" class="headerlink" title="1.1 什么是序列化？"></a><strong>1.1 什么是序列化？</strong></h3><p>&emsp;&emsp;序列化指<strong>将一个Java对象转化为二进制序列</strong>，可以看作一个 <code>byte[]</code> 字节数组。</p><h3 id="1-2-为什么要序列化？"><a href="#1-2-为什么要序列化？" class="headerlink" title="1.2 为什么要序列化？"></a><strong>1.2 为什么要序列化？</strong></h3><p>&emsp;&emsp;需要<strong>把对象等数据转为字节序列进行传输</strong>。序列化后方便把对象<strong>存入文件</strong>或是通过<strong>网络传输</strong>到远程服务器。</p><h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a><strong>1.3 使用场景</strong></h3><blockquote><ul><li><strong>持久保存</strong>：保存对象的字节序列到本地文件或数据库</li><li><strong>网络传输</strong>：序列化后写入字节流使对象得以在网络中传输</li><li><strong>传递对象</strong>：通过序列化在进程间传递对象</li></ul></blockquote><h3 id="1-4-序列化与反序列化"><a href="#1-4-序列化与反序列化" class="headerlink" title="1.4 序列化与反序列化"></a><strong>1.4 序列化与反序列化</strong></h3><p>&emsp;&emsp;把对象等数据转为字节序列的这个过程就是序列化，还原的过程就是反序列化。</p><p>&emsp;&emsp;注意：<strong>反序列化时，由JVM直接构造出Java对象，不调用构造方法</strong>，构造方法内部的代码，在反序列化时根本不可能执行。</p><hr><h2 id="第二节-Java序列化"><a href="#第二节-Java序列化" class="headerlink" title="第二节 Java序列化"></a><strong>第二节 Java序列化</strong></h2><p>&emsp;&emsp;Java支持<strong>对象序列化</strong>机制可以将任何对象写出到流中，并在之后读回。其实现机制主要基于两个接口 <code>Serializable</code> 和 <code>Externalizable</code> 。</p><p>&emsp;&emsp;实现 <code>Serializable</code> 接口表示此类的对象是可序列化的。如果类中的成员变量是引用类型，那么它也必须实现<code>Serializable</code> 接口才能保证序列化成功。</p><h3 id="2-1-ObjectInputStream与ObjectOutputStream"><a href="#2-1-ObjectInputStream与ObjectOutputStream" class="headerlink" title="2.1 ObjectInputStream与ObjectOutputStream"></a><strong>2.1 ObjectInputStream与ObjectOutputStream</strong></h3><p>&emsp;&emsp;可以通过库提供的 <code>ObjectInputStream</code> ，<code>ObjectOutputStream</code> 类来进行对象的序列化。</p><p>&emsp;&emsp;以下示例通过 <code>ObjectOutputStream</code> 保存对象数据，<code>ObjectInputStream</code> 读回对象数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">3000</span>,<span class="number">1995</span>,<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">Manager manager = <span class="keyword">new</span> Manager(<span class="string">"李四"</span>,<span class="number">8000</span>,<span class="number">1986</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">oos.writeObject(employee);</span><br><span class="line">oos.writeObject(manager);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.dat"</span>));</span><br><span class="line">Employee e1 = (Employee)in.readObject();</span><br><span class="line">Employee e2 = (Employee)in.readObject();</span><br><span class="line">System.out.println(e1.toString());</span><br><span class="line">System.out.println(e2.toString());</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果如下。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name<span class="string">[张三]</span> pay<span class="string">[3000]</span> year<span class="string">[1995]</span> month<span class="string">[8]</span> day<span class="string">[1]</span></span><br><span class="line">name<span class="string">[李四]</span> pay<span class="string">[8000]</span> year<span class="string">[1986]</span> month<span class="string">[12]</span> day<span class="string">[15]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <code>writeObject()</code> 和 <code>readObject()</code> 方法只能写出对象，如果想使用基本数据类型需要实现 <code>DataInput</code> 和 <code>DataOutput</code> 定义的相对方法，对象流已经都实现了所需方法：<code>readXX()</code> 和 <code>writeXX()</code> 系列方法支持各种数据类型的字节读写（包括各种基本类型、UTF-8编码的String和实现了Serializable接口的Object等）。</p><p>&emsp;&emsp;<code>ObjectOutputStream</code>（序列化）可以把一个Java对象变为 <code>byte[]</code> 数组，它负责把一个Java对象写入一个字节流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span>, <span class="title">ObjectStreamConstants</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">            writeObjectOverride(obj);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">                writeFatalException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Underlying writeObject/writeUnshared implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check for replacement object</span></span><br><span class="line">            Object orig = obj;</span><br><span class="line">            Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">            ObjectStreamClass desc;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">                Class&lt;?&gt; repCl;</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                    (repCl = obj.getClass()) == cl)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = repCl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">                Object rep = replaceObject(obj);</span><br><span class="line">                <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cl = rep.getClass();</span><br><span class="line">                    desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                obj = rep;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line">            <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">                subs.assign(orig, obj);</span><br><span class="line">                <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    writeNull();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    writeHandle(h);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                    writeClass((Class) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remaining cases 当对象非字符串、数组、枚举类以及Serializable时会抛出NotSerializableException</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                writeString((String) obj, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                writeArray(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">                writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            bout.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> val)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        bout.writeInt(val);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos + <span class="number">4</span> &lt;= MAX_BLOCK_SIZE) &#123;</span><br><span class="line">            Bits.putInt(buf, pos, v);</span><br><span class="line">            pos += <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dout.writeInt(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>ObjectInputStream</code>（反序列化）则负责从一个字节流读取Java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span>, <span class="title">ObjectStreamConstants</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">            <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">        <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">            handles.markDependency(outerHandle, passHandle);</span><br><span class="line">            ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">                vlist.doCallbacks();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            passHandle = outerHandle;</span><br><span class="line">            <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">                clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bin.readBoolean();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = read();</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (v != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ObjectInputStream</code> 可能抛出的异常包括：</p><ul><li><code>ClassNotFoundException</code> ：没有找到对应的Class，如Person对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义Person类，所以无法反序列化。</li><li><code>InvalidClassException</code> ：Class不匹配，如序列化的Person对象定义了一个int类型的age字段，但是反序列化时，Person类定义的age字段被改成了long类型，所以导致class不兼容。</li></ul></blockquote><p>&emsp;&emsp;为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的 <code>serialVersionUID</code> 静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。</p><h3 id="2-2-序列化ID"><a href="#2-2-序列化ID" class="headerlink" title="2.2 序列化ID"></a><strong>2.2 序列化ID</strong></h3><p>&emsp;&emsp;<strong>序列化ID</strong>（serialVersionUID）可以看作版本号，序列化对象的唯一标识，如果序列化ID不同（比如新版本不兼容旧版本）或修改了对象的信息，反序列化时就会抛出 <code>InvalidClassException</code> 异常。</p><p>&emsp;&emsp;序列化ID可以通过以下两种方式生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认1L</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// 根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = xxxL;</span><br></pre></td></tr></table></figure><h3 id="2-3-安全性"><a href="#2-3-安全性" class="headerlink" title="2.3 安全性"></a><strong>2.3 安全性</strong></h3><p>&emsp;&emsp;因为Java的序列化机制可以导致一个实例能直接从 <code>byte[]</code> 数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的 <code>byte[]</code> 数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>&emsp;&emsp;实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h3 id="2-4-Transient"><a href="#2-4-Transient" class="headerlink" title="2.4 Transient"></a><strong>2.4 Transient</strong></h3><p>&emsp;&emsp;某些域是不可被序列化的或着说没有序列化的意义，Java可以通过transient关键字来标记这类域，详细可看这篇<a href="../2019010901.html" title="Title">static,final,transient,volatile等关键字原理作用</a>。</p><h3 id="2-5-自定义序列化"><a href="#2-5-自定义序列化" class="headerlink" title="2.5 自定义序列化"></a><strong>2.5 自定义序列化</strong></h3><p>&emsp;&emsp;对于一个对象只要实现 <code>Serializable</code> 接口，就会可以对 <code>非transient</code> 以及 <code>非static</code> 修饰属性进行序列化工作（静态属性属于类信息，所以不会被序列化）。</p><p>&emsp;&emsp;如果想要<strong>自定义序列化的属性</strong>，除了transient也可以通过重写 <code>readObject()</code> 和 <code>writeObject()</code> 方法来代替默认的自动序列化或通过实现Externalizable接口。</p><blockquote><p>部分属性序列化（自定义序列化）的方法：</p><ul><li><strong>transient</strong></li><li><strong>重写</strong> <code>readObject()</code> 和 <code>writeObject()</code></li><li><strong>实现</strong> <code>Externalizable</code> 接口</li></ul></blockquote><h3 id="2-6-writeReplace-和readResolve"><a href="#2-6-writeReplace-和readResolve" class="headerlink" title="2.6 writeReplace()和readResolve()"></a><strong>2.6 writeReplace()和readResolve()</strong></h3><p>&emsp;&emsp;<code>writeReplace()</code> 在序列化时，会先调用此方法，再调用 <code>writeObject()</code> ，此方法可将任意对象代替目标序列化对象。</p><p>&emsp;&emsp;<code>readResolve()</code> 反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃，此方法在 <code>readObject()</code> 后调用。</p><p>&emsp;&emsp;readResolve常用来反序列单例类，保证单例类的唯一性。</p><p>&emsp;&emsp;注意：<code>readResolve()</code> 与 <code>writeReplace()</code> 的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于final修饰的类重写 <code>readResolve()</code> 方法没有问题；否则，重写 <code>readResolve()</code> 使用private修饰。</p><h3 id="2-7-Externalizable"><a href="#2-7-Externalizable" class="headerlink" title="2.7 Externalizable"></a><strong>2.7 Externalizable</strong></h3><p>&emsp;&emsp;<code>Externalizable</code> 接口继承自 <code>Serializable</code> ，声明了两个方法 <code>writeExternal()</code> 和 <code>readExternal()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两个方法可以<strong>对包含超类在内的对象所有数据的存储和恢复进行管理</strong>，序列化机制在流中仅仅记录对象所属的类。在读入可外部化的类时，对象流将调用无参构造器创建一个新的对象（所以实现Externalizable接口一定要声明无参构造器），然后调用 <code>readExternal()</code> 方法，将字段值分别填充到新的对象中。</p><p>&emsp;&emsp;<code>readObject()</code> 和 <code>writeObject()</code> 是<strong>私有</strong>的，只能被序列化机制调用，而 <code>readExternal()</code> 和 <code>writeExternal()</code> 是<strong>公共</strong>的。</p><blockquote><p>Serializable和Externalizable的区别：</p><ul><li>Serializable没有声明方法，只是一个标识接口。</li><li>Serializable实现时不需要重写 <code>readObject()</code> 和 <code>writeObject()</code>，有默认实现。</li><li>实现Externalizable接口必须声明无参构造器，Serializable则采用反射机制完成内容恢复，没有这个限制。</li><li>Externalizable方式不需要序列化ID，而Serializable接口则需要。</li><li>相比Serializable, Externalizable序列化、反序列更加快速，占用相比较小的内存。</li></ul></blockquote><p>&emsp;&emsp;虽然Externalizable接口带来了一定的性能提升，但相应的复杂度也提高了，所以一般还是会通过实现Serializable接口进行序列化。</p><hr><h2 id="第三节-原理"><a href="#第三节-原理" class="headerlink" title="第三节 原理"></a><strong>第三节 原理</strong></h2><h3 id="3-1-序列化流程"><a href="#3-1-序列化流程" class="headerlink" title="3.1 序列化流程"></a><strong>3.1 序列化流程</strong></h3><p>&emsp;&emsp;Java序列化同一对象，多次的序列化只会得到相同的结果。可以编程试验一下，原因就在于序列化时会对是否序列化过进行检测。</p><blockquote><p>Java序列化算法简单描述：</p><ol><li>所有保存到磁盘的对象都有一个序列化编码号。</li><li>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</li><li>如果此对象已经序列化过，则直接输出编号即可。</li></ol></blockquote><h3 id="3-2-序列化后内容改变"><a href="#3-2-序列化后内容改变" class="headerlink" title="3.2 序列化后内容改变"></a><strong>3.2 序列化后内容改变</strong></h3><p>&emsp;&emsp;当一个对象在序列化后，内容发生了修改，再次序列化会如何？</p><p>&emsp;&emsp;答案是仍然不会再次进行序列化转换，只是保存一下序列化编号。</p><blockquote><p>什么情况下会导致serialVersionUID修改呢？</p><ul><li>如果只是修改了方法，反序列化不容影响，则无需修改版本号。</li><li>如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号。</li><li>如果修改了非瞬态变量，则可能导致反序列化失败。</li><li>如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。</li><li>如果只是新增了实例变量，则反序列化回来新增的是默认值；</li><li>如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li></ul></blockquote><h3 id="3-3-被多个对象共享"><a href="#3-3-被多个对象共享" class="headerlink" title="3.3 被多个对象共享"></a><strong>3.3 被多个对象共享</strong></h3><p>&emsp;&emsp;当一个对象被多个对象共享时，序列化过程是怎么样的呢？</p><p>&emsp;&emsp;每个对象都是用一个序列号保存，第一次调用时，将对象数据保存到流中，如果此对象已被保存过，则只写出”与以保存序列号x对象相同”。</p><p>&emsp;&emsp;对于流中的对象，第一次遇到其序列号时，构建对象，并使用流中的数据来初始化，再记录此序号和新对象之间的关联，当遇到”与以保存序列号x对象相同”此标记时，获取与序号关联的对象引用。</p><p>&emsp;&emsp;对象序列化以特殊的文件格式来存储对象数据，通过对类的域进行排序，然后通过 <code>SHA安全散列算法</code> 得到SHA码，只取前8个字节作为类的<strong>指纹</strong>（指纹即其身份证明）。可以通过对象的指纹和其所属类的指纹进行比对，<strong>当类信息改变时，指纹大概率会不同</strong>（注意是类的结构信息，而非对象数据），所以当两者不同时就抛出一个异常。</p><p>&emsp;&emsp;具体如何进行编码和排布对于当前的学习不是那么重要，只需要知道对象流输出中包含所有对象的类型和数据域，每个对象都被赋予一个序列号，相同对象的重复出现将被存储为对这个对象序列号的引用。</p><h3 id="3-4-序列化单例和类型安全的枚举"><a href="#3-4-序列化单例和类型安全的枚举" class="headerlink" title="3.4 序列化单例和类型安全的枚举"></a><strong>3.4 序列化单例和类型安全的枚举</strong></h3><p>&emsp;&emsp;<a href="../2019030501.html" title="Title">枚举类</a>这篇博客有提到序列化枚举类，当枚举类或使用单例模式进行序列化化时目标对象是唯一的，这其中隐藏着一个问题：<strong>即序列化后的对象和原对象是相等吗？</strong></p><p>&emsp;&emsp;我们实现单例模式时，期望得到的实例应该是唯一的，而<strong>序列化的对象却是一个全新的对象</strong>，所以其它方式实现单例模式时，只要实现了Serializable接口，目标对象就不唯一了，所以需要加如 <code>readResolve()</code>方法来避免这种情况，此方法会直接返回单例对象。</p><p>&emsp;&emsp;而使用Java中的枚举类时不会出现此问题，因为<strong>Jvm限制枚举类型及其枚举常量是唯一的</strong>，在序列化时只会将枚举对象的name属性输出到流中，反序列化时在通过 <code>Enum.valueOf()</code> 方法根据名字来查找枚举对象。同时Jvm禁止了枚举类的 <code>readObject()</code> ， <code>writeObject()</code> 和 <code>readResolve()</code> 等方法，避免上述规范被破坏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;<span class="comment">//定义了此方法后，对象被序列化时会被调用，其返回的对象在之后会成为readObject()的返回值。</span></span><br><span class="line">    <span class="keyword">if</span>(filed == A) <span class="keyword">return</span> Demo.A;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(filed == B) <span class="keyword">return</span> Demo.B;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-克隆和序列化"><a href="#3-5-克隆和序列化" class="headerlink" title="3.5 克隆和序列化"></a><strong>3.5 克隆和序列化</strong></h3><p>&emsp;&emsp;<a href="../2018083001.html" title="Title">Java对象克隆</a>这篇博客中有谈到用序列化去实现克隆，相比重载 <code>equals()</code> 还要更为简单。只要声明对象为可序列化的，将其序列化到流中再读回，即可得到一个深拷贝的结果，但序列化的性能相比复制数据域来说是要慢很多的，所以个人觉得非深克隆的情况还是避免使用好一点。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java核心技术 卷Ⅱ》</p></blockquote><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698" target="_blank" rel="noopener">序列化</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf" target="_blank" rel="noopener">java序列化</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的对象序列化，内容包括：概述（什么是序列化、为什么要序列化、使用场景、序列化与反序列化），Java序列化（ObjectInputStream与ObjectOutputStream、序列化ID、安全性、Transient、自定义序列化、writeReplace()和readResolve()、Externalizable），原理（序列化流程、序列化后内容改变、被多个对象共享、序列化单例和类型安全的枚举、克隆和序列化）。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>办公利器-截图工具</title>
    <link href="http://linyishui.top/2020042301.html"/>
    <id>http://linyishui.top/2020042301.html</id>
    <published>2020-04-23T03:12:27.000Z</published>
    <updated>2020-04-23T09:28:53.512Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a><strong>截图工具</strong></h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a><strong>1. 需求</strong></h2><ul><li>简单易用</li><li>满足截图+实时编辑+保存/复制等基础功能</li><li>能够支持滚动截图</li><li>能够录制动态视频或动态图（最好）</li></ul><h2 id="2-Snipaste"><a href="#2-Snipaste" class="headerlink" title="2. Snipaste"></a><strong>2. Snipaste</strong></h2><p>&emsp;&emsp;<a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a>，可以直接在Windows商店获取，知名的开源贴图/截图软件，除了截图外，贴图是核心内容。写这篇博文的原因也是因为Snipaste无法满足博主日常需求，记录一下我寻找替代方案的过程。</p><p>&emsp;&emsp;这里偷懒一下，直接从官方文档和一些网络上的资源，摘抄我经常使用的功能。</p><p>&emsp;&emsp;以下动图一些快捷键和官方不一致，如<code>F2</code>应为<code>F3</code>，需要注意，懒得一个个再截了。</p><h3 id="2-1-截图"><a href="#2-1-截图" class="headerlink" title="2.1 截图"></a><strong>2.1 截图</strong></h3><ul><li>快捷键（默认为 <code>F1</code>）</li><li><code>鼠标左键</code> 单击托盘图标</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010108.jpg" alt></p><h3 id="2-2-取色"><a href="#2-2-取色" class="headerlink" title="2.2 取色"></a><strong>2.2 取色</strong></h3><ul><li>当放大镜可见的时候，按下 <code>C</code> 可复制该像素点的颜色值（RGB/Hex）。之后可以 <code>F3</code> 将它贴出，或者 <code>Ctrl</code> + <code>V</code> 贴到其他程序里</li><li>可按下 <code>Shift</code> 来切换颜色格式</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010110.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010111.jpg" alt></p><h3 id="2-3-纯文本截图"><a href="#2-3-纯文本截图" class="headerlink" title="2.3 纯文本截图"></a><strong>2.3 纯文本截图</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010112.jpg" alt></p><h3 id="2-4-编辑"><a href="#2-4-编辑" class="headerlink" title="2.4 编辑"></a><strong>2.4 编辑</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010113.gif" alt></p><h3 id="2-5-开始贴图"><a href="#2-5-开始贴图" class="headerlink" title="2.5 开始贴图"></a><strong>2.5 开始贴图</strong></h3><ul><li>快捷键（默认 <code>F3</code>）</li><li><code>鼠标中键</code> 单击托盘图标</li><li>截图时选择 <code>贴到屏幕</code></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010109.jpg" alt></p><h3 id="2-6-缩放贴图"><a href="#2-6-缩放贴图" class="headerlink" title="2.6 缩放贴图"></a><strong>2.6 缩放贴图</strong></h3><ul><li><code>滑动滚轮</code></li><li><code>+</code> <code>-</code></li><li>拖动贴图窗口的边缘</li></ul><h3 id="2-7-设置贴图透明度"><a href="#2-7-设置贴图透明度" class="headerlink" title="2.7 设置贴图透明度"></a><strong>2.7 设置贴图透明度</strong></h3><ul><li><code>Ctrl</code> + <code>滑动滚轮</code></li><li><code>Ctrl</code> + <code>+</code> <code>-</code></li></ul><h3 id="2-8-关闭单张贴图"><a href="#2-8-关闭单张贴图" class="headerlink" title="2.8 关闭单张贴图"></a><strong>2.8 关闭单张贴图</strong></h3><ul><li><code>Esc</code> / <code>左键双击</code></li><li><ul><li>可自定义</li></ul></li><li><code>Ctrl</code> + <code>W</code></li><li>被关闭的贴图，可再次被贴出，除非超过“可被恢复的已关闭贴图数”</li><li><ul><li>如何恢复：按下贴图键一次或多次</li></ul></li><li>“可被恢复的已关闭贴图数”可在选项对话框设置（默认设置/建议是 <strong>1</strong>）</li><li>当你觉得自己可能不需要这张贴图了，<strong>关闭</strong>贴图操作是你的首选，因为它同时提供了一种后悔药，防止你刚把贴图关闭就后悔了，想找回来</li><li><strong>如果你并不希望这张贴图消失，而只是想暂时隐藏它，那么你不应该关闭它</strong>，而是使用“隐藏所有贴图”，或者把它移动到另一个贴图分组</li><li>关闭 Snipaste 时，如果已关闭的贴图没有被显示出来，它们会被自动销毁（即使未达到最大计数）</li></ul><h3 id="2-9-隐藏所有贴图"><a href="#2-9-隐藏所有贴图" class="headerlink" title="2.9 隐藏所有贴图"></a><strong>2.9 隐藏所有贴图</strong></h3><ul><li>快捷键（默认为 <code>Shift</code> + <code>F3</code>）</li><li>再次按下快捷键将显示所有贴图</li><li>注意，隐藏所有贴图与上面提到的关闭单张贴图<strong>是完全不同的行为</strong>，也就是说，隐藏所有贴图不会影响对已关闭贴图的计数</li><li>被隐藏的贴图不会被自动销毁，即使关闭 Snipaste 时它们都是隐藏状态</li></ul><h3 id="2-10-销毁贴图"><a href="#2-10-销毁贴图" class="headerlink" title="2.10 销毁贴图"></a><strong>2.10 销毁贴图</strong></h3><ul><li><code>Shift</code> + <code>Esc</code> / 在贴图窗口的右键菜单中选 <code>销毁</code></li><li>当你确认自己不可能再需要这张贴图，并且不希望这张贴图留下任何痕迹，才建议使用<strong>销毁</strong></li><li>被销毁的贴图，不会再通过贴图键被恢复出来</li><li><ul><li>可是再按贴图键，还是贴出来了？</li></ul></li><li><ul><li><ul><li>这是因为它还在你剪贴板里，Snipaste 是把它当做新的内容贴了出来</li></ul></li></ul></li><li>如果希望销毁当前分组的所有贴图，关闭该贴图分组即可</li></ul><h3 id="2-11-总结"><a href="#2-11-总结" class="headerlink" title="2.11 总结"></a><strong>2.11 总结</strong></h3><p>&emsp;&emsp;根据官网描述，开源版本已停止更新，作者发布了2.X收费版本，但翻阅了新增功能，并没有我想要的如滚动截图等。</p><p>&emsp;&emsp;GitHub中相关issules：<a href="https://github.com/Snipaste/feedback/issues/19" target="_blank" rel="noopener">关于滚屏截屏支持讨论</a>，虽然被作者接纳，但从2016年到今天也未见到相关更新。</p><p>&emsp;&emsp;所以，只能考虑其他替代方案。</p><h2 id="3-多个工具共用"><a href="#3-多个工具共用" class="headerlink" title="3. 多个工具共用"></a><strong>3. 多个工具共用</strong></h2><p>&emsp;&emsp;首先先采用比较缓和的方案，找到能支持滚动截图的工具，辅助Snipaste。</p><p>&emsp;&emsp;因为博主需要使用滚动截图的场景常为浏览器，所以有以下几种方案来在浏览器中滚动截图。</p><h3 id="3-1-Chrome-命令-实现长截图"><a href="#3-1-Chrome-命令-实现长截图" class="headerlink" title="3.1 Chrome 命令 实现长截图"></a><strong>3.1 Chrome 命令 实现长截图</strong></h3><p>&emsp;&emsp;第一种方案是使用 Chrome62 版本时更新的长截图功能，缺点是不够灵活，不能随意控制截取范围等，优点是在产生的图片文件大小在接受范围内时，清晰度很高。</p><blockquote><p>Windows：</p><ul><li>打开调试界面（<code>F12</code>）</li><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code> 打开命令行</li><li>输入命令：Capture full size screenshot</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 截图整个页面</span></span><br><span class="line">Capture full size screenshot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 截图单个节点，需要先在调试界面选中节点[Elements]</span></span><br><span class="line">Capture node screenshot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 截图当前可见</span></span><br><span class="line">Capture screenshot</span><br></pre></td></tr></table></figure><h3 id="3-2-Chrome-插件-Nimbus"><a href="#3-2-Chrome-插件-Nimbus" class="headerlink" title="3.2 Chrome 插件 Nimbus"></a><strong>3.2 Chrome 插件 Nimbus</strong></h3><p>&emsp;&emsp;在Chrome扩展商店搜索Nimbus，并安装。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010114.png" alt></p><p>&emsp;&emsp;功能如下图所示，可以支持如滚动截屏，录制视频等需求。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010115.png" alt></p><p>&emsp;&emsp;截屏或录屏都有多种选项（Tab或桌面），如下所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010116.png" alt></p><p>&emsp;&emsp;整个屏幕并非指桌面，不是录屏软件那种获取系统每帧数据或是视频采集卡等对桌面进行录屏，只是范围扩散到屏幕，捕捉的还是当前页面。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010117.png" alt></p><p>&emsp;&emsp;但可以对某个应用进行截图或录屏，这样就不会只能局限于浏览器使用了。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010118.png" alt></p><p>&emsp;&emsp;选择某个应用进行录屏，如下图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010119.png" alt></p><p>&emsp;&emsp;视频甚至可以转换为Gif，日常使用很方便。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010120.png" alt></p><h2 id="4-单个工具替代"><a href="#4-单个工具替代" class="headerlink" title="4. 单个工具替代"></a><strong>4. 单个工具替代</strong></h2><h3 id="4-1-FScapture"><a href="#4-1-FScapture" class="headerlink" title="4.1 FScapture"></a><strong>4.1 FScapture</strong></h3><ul><li>官网：<a href="https://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FastStone Capture</a></li><li>开源软件</li><li>支持屏幕任意截长图，甚至录屏</li></ul><p>&emsp;&emsp;官网有点年代感，等以后Nimbus无法满足我的需求时再试用一下。</p><h3 id="4-2-ShareX"><a href="#4-2-ShareX" class="headerlink" title="4.2 ShareX"></a><strong>4.2 ShareX</strong></h3><ul><li>官网：<a href="https://getsharex.com/" target="_blank" rel="noopener">ShareX</a></li><li>开源软件，专业工具，功能强大</li><li>屏幕截取，录制相关功能齐全</li><li>支持Firefox、Chrome浏览器扩展</li><li>扩展功能丰富，如支持二维码生成等</li></ul><p>&emsp;&emsp;有机会会试用一下，感觉很强大。</p><h3 id="4-3-Xnip"><a href="#4-3-Xnip" class="headerlink" title="4.3 Xnip"></a><strong>4.3 Xnip</strong></h3><p>&emsp;&emsp;上述软件应该都只支持Windows系统，Mac作为最好的办公工具当然也有专业的截图工具（此为个人观点，好想买台MacBook Pro..orz），除了自带截图外，Xnip是一个好的选择，手里没有Mac，没法对比一下了。</p><h3 id="4-4-QQ截图"><a href="#4-4-QQ截图" class="headerlink" title="4.4 QQ截图"></a><strong>4.4 QQ截图</strong></h3><p>&emsp;&emsp;emmm，QQ自带的截图功能，日常使用足以满足，截屏、截长屏、录屏等都可以支持，但感觉使用不是很方便（其实人家有快捷键…），对比一下单一的截屏软件，首先会有一些不需要的中间步骤，然后还会有种混乱感吧，怕误操作把截图什么的发给别人…</p><p>&emsp;&emsp;最重要的是用QQ截图不能装逼，俗话说装逼是第一生产力，在马斯洛的<a href="https://zh.wikipedia.org/wiki/%E9%9C%80%E6%B1%82%E5%B1%82%E6%AC%A1%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">需求层次理论</a>中对应的是高层次的人类需求，而QQ太low，就算是俺们搬砖的也得西装笔挺的才有干活的动力嘛。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010122.png" alt></p><h3 id="4-5-Windows-截图工具"><a href="#4-5-Windows-截图工具" class="headerlink" title="4.5 Windows 截图工具"></a><strong>4.5 Windows 截图工具</strong></h3><p>&emsp;&emsp;不是很好用。不过Edge自带的截长图功能还行，不像Chrome那样需要输入命令，对非程序员用户不太友好。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010121.png" alt></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="[https://axutongxue.github.io/2019/01/15/%E8%BF%99%E4%B8%89%E6%AC%BE%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%BB%A1%E8%B6%B3%E4%BD%A0%E5%AF%B9%E6%88%AA%E5%9B%BE%E7%9A%84%E6%89%80%E6%9C%89%E9%9C%80%E6%B1%82/](https://axutongxue.github.io/2019/01/15/这三款软件，满足你对截图的所有需求/">这三款软件，满足你对截图的所有需求</a>)</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理办公中常用的截图工具，主要针对博主当前的需求。
    
    </summary>
    
      <category term="实用工具" scheme="http://linyishui.top/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tools" scheme="http://linyishui.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建个人博客 (七) 优化加载记录</title>
    <link href="http://linyishui.top/2020042201.html"/>
    <id>http://linyishui.top/2020042201.html</id>
    <published>2020-04-22T09:49:01.000Z</published>
    <updated>2020-04-24T01:47:12.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化加载记录"><a href="#优化加载记录" class="headerlink" title="优化加载记录"></a><strong>优化加载记录</strong></h1><h2 id="PageSpeed-Insights测试Blog性能"><a href="#PageSpeed-Insights测试Blog性能" class="headerlink" title="PageSpeed Insights测试Blog性能"></a><strong>PageSpeed Insights测试Blog性能</strong></h2><p>&emsp;&emsp;通过<a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">PageSpeed Insights</a>检查网站加载速度。</p><p>&emsp;&emsp;手机端测试结果如下，性能尚可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010103.png" alt></p><p>&emsp;&emsp;桌面端测试结果如下，评分一下就下来了，虽然会有一些波动，但多次测试都低于49。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010104.png" alt></p><p>&emsp;&emsp;首先查看优化建议，主要是核心js代码，这部分先暂时不动（博主目前前端优化技术有限）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010105.png" alt></p><p>&emsp;&emsp;查看其它影响项，发现看板娘占用了很多的网络资源（需要加载模型），所以先尝试移除这个功能。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010106.png" alt></p><h3 id="移除看板娘"><a href="#移除看板娘" class="headerlink" title="移除看板娘"></a><strong>移除看板娘</strong></h3><p>&emsp;&emsp;卸载相关包。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;删掉根目录配置文件中相关内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态妹子</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-shizuku</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">left</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">125</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">250</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;更新博客，再次测试，发现评分直接提高到97（汗，看来罪魁祸首就是模型了）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010107.png" alt></p><p>&emsp;&emsp;使用Google Chrome自带的Audits，再次测试博客加载性能。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://blog.serenader.me/ye-mian-de-jia-zai-xing-neng-you-hua-fang-an" target="_blank" rel="noopener">页面的加载性能优化方案</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://linyishui.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://linyishui.top/tags/hexo/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="http://linyishui.top/2020041701.html"/>
    <id>http://linyishui.top/2020041701.html</id>
    <published>2020-04-17T01:31:16.000Z</published>
    <updated>2020-04-27T02:24:12.810Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-为什么需要WebSocket"><a href="#1-1-为什么需要WebSocket" class="headerlink" title="1.1 为什么需要WebSocket"></a><strong>1.1 为什么需要WebSocket</strong></h3><p>&emsp;&emsp;我们已经有了HTTP协议，为什么还需要使用WebSocket呢？答案就是解决HTTP的缺陷-<strong>通信只能由客户端发起</strong>。</p><p>&emsp;&emsp;很多场景下我们需要由服务端主动向客户端推送消息，而HTTP协议这种单向请求的设计注定了服务器端有连续的状态变化时，客户端很难去获知。</p><p>&emsp;&emsp;早期，很多网站为了实现<a href="https://zh.wikipedia.org/wiki/推送技术" target="_blank" rel="noopener">推送技术</a>，所用的技术都是<a href="https://zh.wikipedia.org/wiki/輪詢" target="_blank" rel="noopener">轮询</a>。轮询是指由浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，然后服务器返回最新的数据给客户端。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求与回复可能会包含较长的<a href="https://zh.wikipedia.org/wiki/HTTP头字段" target="_blank" rel="noopener">头部</a>，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源，最常见的场景就是聊天室。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010102.png" alt></p><p>&emsp;&emsp;比较新的轮询技术是<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。</p><p>&emsp;&emsp;由此契机催生了WebSocket协议，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h3 id="1-2-什么是WebSocket"><a href="#1-2-什么是WebSocket" class="headerlink" title="1.2 什么是WebSocket"></a><strong>1.2 什么是WebSocket</strong></h3><p>&emsp;&emsp;<strong>WebSocket</strong>是一种<a href="https://zh.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在单个<a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP</a>连接上进行<a href="https://zh.wikipedia.org/wiki/全雙工" target="_blank" rel="noopener">全双工</a>通信，位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>。</p><p>&emsp;&emsp;WebSocket协议诞生于2008年，最初在<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>规范中被引用为TCPConnection，作为基于TCP的套接字API的占位符。2008年6月，<a href="https://zh.wikipedia.org/w/index.php?title=Michael_Carter&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Michael Carter</a>进行了一系列讨论，最终形成了称为WebSocket的协议。</p><p>&emsp;&emsp;WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>&emsp;&emsp;WebSocket是一种与<a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP</a>不同的协议。两者都位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>，并且都依赖于<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>的TCP协议。 虽然它们不同，但是RFC 6455中规定：<code>it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries</code>（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-1" target="_blank" rel="noopener">[1]</a>从HTTP协议更改为WebSocket协议。</p><p>&emsp;&emsp;WebSocket协议支持Web<a href="https://zh.wikipedia.org/wiki/浏览器" target="_blank" rel="noopener">浏览器</a>（或其他客户端应用程序）与Web<a href="https://zh.wikipedia.org/wiki/服务器" target="_blank" rel="noopener">服务器</a>之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)之类的技术以非标准化的方式实现了类似的双向通信。</p><p>&emsp;&emsp;<strong>与HTTP不同，WebSocket提供全双工通信</strong>。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-2" target="_blank" rel="noopener">[2]</a><a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-quantum-3" target="_blank" rel="noopener">[3]</a>此外，<strong>WebSocket还可以在TCP之上实现消息流</strong>。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p><blockquote><ul><li>单工通信：即只能A到B（广播），同一时间只允许一方向另一方传送消息，另一方则不允许反过来传送。</li><li>全双工：指在发送数据的同时也能接收数据，二者同步进行。</li><li>半双工：指在一个时间段内只有一个动作发生，数据信息可以沿两个方向传送，但同一时刻一个信道只允许单方向传送，因此也称为双向交替通信。如果要改变传输方向，需由开关进行切换。半双工方式要求收发两端都有发送装置和接收装置。由于这种方式要频繁变换信道方向，故效率低，但可以节约传输线路。半双工方式适用于终端与终端之间的会话式通信。</li></ul></blockquote><p>&emsp;&emsp;WebSocket协议规范将<code>ws</code>（WebSocket）和<code>wss</code>（WebSocket Secure）定义为两个新的<a href="https://zh.wikipedia.org/wiki/統一資源標識符" target="_blank" rel="noopener">统一资源标识符</a>（URI）方案<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-4" target="_blank" rel="noopener">[4]</a>，分别对应明文和加密连接，其中<code>wss</code>表示使用了<a href="https://zh.wikipedia.org/wiki/TLS" target="_blank" rel="noopener">TLS</a>的Websocket。除了方案名称和片段ID（不支持<code>#</code>）之外，其余的URI组件都被定义为此URI的通用语法。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-5" target="_blank" rel="noopener">[5]</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">w</span><span class="variable">s:</span>//example.<span class="keyword">com</span>/wsapi</span><br><span class="line"><span class="keyword">ws</span><span class="variable">s:</span>//secure.example.<span class="keyword">com</span>/wsapi</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。        </p><p>&emsp;&emsp;使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架。</p><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a><strong>1.3 优点</strong></h3><ul><li><p><strong>较少的控制开销</strong>。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a href="https://zh.wikipedia.org/wiki/掩码" target="_blank" rel="noopener">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p></li><li><p><strong>更强的实时性</strong>。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的<a href="https://zh.wikipedia.org/w/index.php?title=长轮询&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">长轮询</a>比较，其也能在短时间内更多次地传递数据。</p></li><li><p><strong>保持连接状态</strong>。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p></li><li><p><strong>更好的二进制支持</strong>。Websocket定义了<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</p></li><li><p><strong>可以支持扩展</strong>。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a href="https://zh.wikipedia.org/wiki/数据压缩" target="_blank" rel="noopener">压缩</a>等。</p></li><li><p><strong>更好的压缩效果</strong>。相对于<a href="https://zh.wikipedia.org/wiki/HTTP压缩" target="_blank" rel="noopener">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a href="https://zh.wikipedia.org/wiki/上下文" target="_blank" rel="noopener">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-14" target="_blank" rel="noopener">[14]</a></p></li></ul><h3 id="1-4-WebSocket和Socket"><a href="#1-4-WebSocket和Socket" class="headerlink" title="1.4 WebSocket和Socket"></a><strong>1.4 WebSocket和Socket</strong></h3><blockquote><p>WebSocket和Socket 的区别：</p><p>&emsp;&emsp;软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。</p><p>&emsp;&emsp;Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。</p><p>&emsp;&emsp;WebSocket 则是一个典型的应用层协议。</p><p>&emsp;&emsp;总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。</p></blockquote><h3 id="1-5-一次Websocket握手请求"><a href="#1-5-一次Websocket握手请求" class="headerlink" title="1.5 一次Websocket握手请求"></a><strong>1.5 一次Websocket握手请求</strong></h3><p>&emsp;&emsp;客户端请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;服务器回应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Location</span>: ws://example.com/</span><br></pre></td></tr></table></figure><ul><li>Connection 必须设置 Upgrade，表示客户端希望连接升级。</li><li>Upgrade 字段必须设置 Websocket，表示希望升级到 Websocket 协议。</li><li>Sec-WebSocket-Key 是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。把 “Sec-WebSocket-Key” 加上一个特殊字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算 SHA-1 摘要，之后进行 BASE-64 编码，将结果做为 “Sec-WebSocket-Accept” 头的值，返回给客户端。如此操作，可以尽量避免普通 HTTP 请求被误认为 Websocket 协议。</li><li>Sec-WebSocket-Version 表示支持的 Websocket 版本。RFC6455 要求使用的版本是 13，之前草案的版本均应当弃用。</li><li>Origin 字段是可选的，通常用来表示在浏览器中发起此 Websocket 连接所在的页面，类似于 Referer。但是，与 Referer 不同的是，Origin 只包含了协议和主机名称。</li><li>其他一些定义在 HTTP 协议中的字段，如 Cookie 等，也可以在 Websocket 中使用。</li></ul><h3 id="1-6-支持Websocket的服务器"><a href="#1-6-支持Websocket的服务器" class="headerlink" title="1.6 支持Websocket的服务器"></a><strong>1.6 支持Websocket的服务器</strong></h3><p>&emsp;&emsp;在服务器方面，网上都有不同对websocket支持的服务器：</p><ul><li>php - <a href="http://code.google.com/p/phpwebsocket/" target="_blank" rel="noopener">http://code.google.com/p/phpwebsocket/</a></li><li>jetty - <a href="http://jetty.codehaus.org/jetty/（版本7开始支持websocket）" target="_blank" rel="noopener">http://jetty.codehaus.org/jetty/（版本7开始支持websocket）</a></li><li>netty - <a href="http://www.jboss.org/netty" target="_blank" rel="noopener">http://www.jboss.org/netty</a></li><li>ruby - <a href="http://github.com/gimite/web-socket-ruby" target="_blank" rel="noopener">http://github.com/gimite/web-socket-ruby</a></li><li>Kaazing - <a href="https://web.archive.org/web/20100923224709/http://www.kaazing.org/confluence/display/KAAZING/Home" target="_blank" rel="noopener">https://web.archive.org/web/20100923224709/http://www.kaazing.org/confluence/display/KAAZING/Home</a></li><li>Tomcat - <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/（7.0.27支持websocket，建议用tomcat8，7.0.27中的接口已经过时）</a></li><li>WebLogic - <a href="http://www.oracle.com/us/products/middleware/cloud-app-foundation/weblogic/overview/index.html" target="_blank" rel="noopener">http://www.oracle.com/us/products/middleware/cloud-app-foundation/weblogic/overview/index.html（12.1.2開始支持）</a></li><li>node.js - <a href="https://github.com/Worlize/WebSocket-Node" target="_blank" rel="noopener">https://github.com/Worlize/WebSocket-Node</a></li><li>node.js - <a href="http://socket.io/" target="_blank" rel="noopener">http://socket.io</a></li><li>nginx - <a href="http://nginx.com/" target="_blank" rel="noopener">http://nginx.com/</a></li><li>mojolicious - <a href="http://mojolicio.us/" target="_blank" rel="noopener">http://mojolicio.us/</a></li><li>python - <a href="https://github.com/abourget/gevent-socketio" target="_blank" rel="noopener">https://github.com/abourget/gevent-socketio</a></li><li>Django - <a href="https://github.com/stephenmcd/django-socketio" target="_blank" rel="noopener">https://github.com/stephenmcd/django-socketio</a></li><li>erlang - <a href="https://github.com/ninenines/cowboy.git" target="_blank" rel="noopener">https://github.com/ninenines/cowboy.git</a></li></ul><h2 id="第二节-HTML5-WebSocket"><a href="#第二节-HTML5-WebSocket" class="headerlink" title="第二节 HTML5 WebSocket"></a><strong>第二节 HTML5 WebSocket</strong></h2><p>&emsp;&emsp;浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>&emsp;&emsp;当你获取 Web Socket 连接后，你可以通过 <strong>send()</strong> 方法来向服务器发送数据，并通过 <strong>onmessage</strong> 事件来接收服务器返回的数据。</p><p>&emsp;&emsp;以下 API 用于创建 WebSocket 对象。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Socket = <span class="keyword">new</span> <span class="type">WebSocket</span>(url, [protocol] );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h3 id="2-1-WebSocket-属性"><a href="#2-1-WebSocket-属性" class="headerlink" title="2.1 WebSocket 属性"></a><strong>2.1 WebSocket 属性</strong></h3><table><thead><tr><th style="text-align:left"><strong>属性</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">Socket.readyState</td><td style="text-align:left">只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td></tr><tr><td style="text-align:left">Socket.bufferedAmount</td><td style="text-align:left">只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td></tr></tbody></table><h3 id="2-2-WebSocket-事件"><a href="#2-2-WebSocket-事件" class="headerlink" title="2.2 WebSocket 事件"></a><strong>2.2 WebSocket 事件</strong></h3><table><thead><tr><th style="text-align:left"><strong>事件</strong></th><th style="text-align:left"><strong>事件处理程序</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">open</td><td style="text-align:left">Socket.onopen</td><td style="text-align:left">连接建立时触发</td></tr><tr><td style="text-align:left">message</td><td style="text-align:left">Socket.onmessage</td><td style="text-align:left">客户端接收服务端数据时触发</td></tr><tr><td style="text-align:left">error</td><td style="text-align:left">Socket.onerror</td><td style="text-align:left">通信发生错误时触发</td></tr><tr><td style="text-align:left">close</td><td style="text-align:left">Socket.onclose</td><td style="text-align:left">连接关闭时触发</td></tr></tbody></table><h3 id="2-3-WebSocket-方法"><a href="#2-3-WebSocket-方法" class="headerlink" title="2.3 WebSocket 方法"></a><strong>2.3 WebSocket 方法</strong></h3><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">Socket.send()</td><td style="text-align:left">使用连接发送数据</td></tr><tr><td style="text-align:left">Socket.close()</td><td style="text-align:left">关闭连接</td></tr></tbody></table><h3 id="2-4-WebSocket-实例"><a href="#2-4-WebSocket-实例" class="headerlink" title="2.4 WebSocket 实例"></a><strong>2.4 WebSocket 实例</strong></h3><p>&emsp;&emsp;WebSocket 协议本质上是一个基于 TCP 的协议。</p><p>&emsp;&emsp;为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">         <span class="function"><span class="keyword">function</span> <span class="title">WebSocketTest</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">         &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="string">"WebSocket"</span> <span class="keyword">in</span> <span class="built_in">window</span>)</span></span><br><span class="line"><span class="undefined">            &#123;</span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"您的浏览器支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="undefined">               </span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="actionscript">               <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:9998/echo"</span>);</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">               &#123;</span></span><br><span class="line"><span class="actionscript">                  <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span><br><span class="line"><span class="actionscript">                  ws.send(<span class="string">"发送数据"</span>);</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"数据发送中..."</span>);</span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span></span></span><br><span class="line"><span class="undefined">               &#123; </span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">var</span> received_msg = evt.data;</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"数据已接收..."</span>);</span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">               &#123; </span></span><br><span class="line"><span class="actionscript">                  <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"连接已关闭..."</span>); </span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="actionscript">            <span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">            &#123;</span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 浏览器不支持 WebSocket</span></span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"您的浏览器不支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">         &#125;</span></span><br><span class="line"><span class="undefined">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sse"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:WebSocketTest()"</span>&gt;</span>运行 WebSocket<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;python服务部分省略。</p><hr><h2 id="第三节-实现"><a href="#第三节-实现" class="headerlink" title="第三节 实现"></a><strong>第三节 实现</strong></h2><p>&emsp;&emsp;有多种方式来实现 WebSocket 协议，Spring Boot 采用基于 STOMP 的实现，常见的还有如 Socket.IO等。</p><h3 id="3-1-STOMP"><a href="#3-1-STOMP" class="headerlink" title="3.1 STOMP"></a><strong>3.1 STOMP</strong></h3><p>&emsp;&emsp;STOMP：即<code>Simple Text Orientated Messaging Protocol</code>，它是一个简单的文本消息传输协议，属于 WebSocket 的子协议， 提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单， 易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。</p><h3 id="3-2-引入依赖"><a href="#3-2-引入依赖" class="headerlink" title="3.2 引入依赖"></a><strong>3.2 引入依赖</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此处使用jetty代替内置的Tomcat服务器，可以只引入<code>spring-boot-starter-websocket</code>即可。</p><h3 id="3-3-配置"><a href="#3-3-配置" class="headerlink" title="3.3 配置"></a><strong>3.3 配置</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry stompEndpointRegistry)</span> </span>&#123;</span><br><span class="line">        stompEndpointRegistry.addEndpoint(<span class="string">"/simple"</span>)</span><br><span class="line">                .setAllowedOrigins(<span class="string">"*"</span>) <span class="comment">//解决跨域问题</span></span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.enableSimpleBroker(<span class="string">"/topic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@EnableWebSocketMessageBroker</code> 注解表示开启使用STOMP协议，来传输基于代理的消息，Broker即代理。</li><li><code>registerStompEndpoints</code>方法表示注册STOMP协议的节点，并指定映射的URL。</li><li><code>addEndpoint().withSockJS()</code>用来注册STOMP协议节点，同时指定使用SockJS。</li><li><code>configureMessageBroker</code>方法用来配置消息代理，此处实现推送功能，所以是<code>/topic</code>。</li></ul><h3 id="3-4-消息类"><a href="#3-4-消息类" class="headerlink" title="3.4 消息类"></a><strong>3.4 消息类</strong></h3><p>&emsp;&emsp;请求消息类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;响应消息类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String responseMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseMessage</span><span class="params">(String responseMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseMessage = responseMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResponseMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-控制器"><a href="#3-5-控制器" class="headerlink" title="3.5 控制器"></a><strong>3.5 控制器</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WsController</span><span class="params">(SimpMessagingTemplate messagingTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messagingTemplate = messagingTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping</span>(<span class="string">"/welcome"</span>)</span><br><span class="line">    <span class="meta">@SendTo</span>(<span class="string">"/topic/say"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseMessage <span class="title">say</span><span class="params">(RequestMessage message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseMessage(<span class="string">"welcome,"</span> + message.getName() + <span class="string">" !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时推送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发现消息</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">"/topic/callback"</span>, <span class="string">"定时推送消息时间: "</span> + df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>say方法上添加的<code>@MessageMapping</code>注解和我们之前使用的<code>@RequestMapping</code>类似。</p></li><li><p><code>@SendTo</code>注解表示当服务器有消息需要推送的时候， 会对订阅了<code>@SendTo</code>中路径的浏览器发送消息。</p></li><li><p>除此之外，还定义了一个定时推送消息方法，这个方法每隔1秒会主动给订阅了主题<code>/topic/callback</code>的客户端推送消息。</p></li><li>到此为止服务器端就编写完成，可以看到服务器的编写非常简单。</li></ul><h3 id="3-6-网站客户端"><a href="#3-6-网站客户端" class="headerlink" title="3.6 网站客户端"></a><strong>3.6 网站客户端</strong></h3><p>&emsp;&emsp;<a href="https://github.com/yidao620c/SpringBootBucket/tree/master/springboot-websocket/src/test/java/com/xncoding/jwt/socket/client/html" target="_blank" rel="noopener">测试代码</a></p><p>&emsp;&emsp;页面上面点击”连接”按钮后，开始连接到<code>/simple</code>节点。输入名字后点击发送，将向<code>/welcome</code>的url发送消息。</p><p>&emsp;&emsp;同时订阅了两个主题：<code>/topic/say</code> 和 <code>/topic/callback</code>，会接收到服务器的say方法的返回，以及定时推送消息。</p><h3 id="3-7-Android客户端"><a href="#3-7-Android客户端" class="headerlink" title="3.7 Android客户端"></a><strong>3.7 Android客户端</strong></h3><p>&emsp;&emsp;参考 <a href="https://github.com/NaikSoftware/StompProtocolAndroid" target="_blank" rel="noopener">StompProtocolAndroid</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/WebSocket" target="_blank" rel="noopener">WebSocket-维基百科</a></p><p><a href="https://www.runoob.com/html/html5-websocket.html" target="_blank" rel="noopener">html5-websocket-菜鸟教程</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p><p><a href="https://www.xncoding.com/2017/07/15/spring/sb-websocket.html" target="_blank" rel="noopener">SpringBoot系列 - 集成WebSocket实时通信</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍WebSocket相关知识，内容包括：简介（为什么需要WebSocket、什么是WebSocket、优点、WebSocket和Socket、一次Websocket握手请求、支持Websocket的服务器），HTML5 WebSocket（WebSocket属性、WebSocket事件、WebSocket方法、WebSocket实例），实现（STOMP、引入依赖、配置、消息类、控制器、网站客户端、Android客户端）。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="webSocket" scheme="http://linyishui.top/tags/webSocket/"/>
    
  </entry>
  
  <entry>
    <title>Nginx简单处理一次灰度发布问题</title>
    <link href="http://linyishui.top/2020041501.html"/>
    <id>http://linyishui.top/2020041501.html</id>
    <published>2020-04-15T06:28:48.000Z</published>
    <updated>2020-04-16T09:41:22.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nginx简单处理一次灰度发布问题"><a href="#Nginx简单处理一次灰度发布问题" class="headerlink" title="Nginx简单处理一次灰度发布问题"></a><strong>Nginx简单处理一次灰度发布问题</strong></h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a><strong>1.需求</strong></h2><p>&emsp;&emsp;公司接手的一个半成品项目，客户要求更新版本时不要停掉网站（灰度发布）。</p><p>&emsp;&emsp;马上想到的方案是：主从热备和负载均衡，nginx+keepalived，然后又想到了自动部署-CI/CD，及时打住避免越想越远。这个项目本身比较粗糙，简单的解决当前的问题即可。</p><p>&emsp;&emsp;原系统使用session存储会话信息，所以还要解决session如何共享的问题，google了一下，决定nginx配置两台服务器负载均衡，发布新版本时，一次更新一个，然后使用Redis来共享session。</p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a><strong>2.实现</strong></h2><p>&emsp;&emsp;时间和精力有限，先在本地和测试服务器跑通一个demo。</p><p>&emsp;&emsp;两台机器：本机，服务器A</p><table><thead><tr><th style="text-align:center">工具</th><th style="text-align:center">本机</th><th style="text-align:center">服务器A</th></tr></thead><tbody><tr><td style="text-align:center">JDK 1.8</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Nginx</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">Redis</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr></tbody></table><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a><strong>2.1 代码</strong></h3><p>&emsp;&emsp;首先新建spring-boot项目，代码如下。</p><h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="(1) pom.xml"></a><strong>(1) pom.xml</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-application-properties"><a href="#2-application-properties" class="headerlink" title="(2) application.properties"></a><strong>(2) application.properties</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8022</span><br><span class="line"></span><br><span class="line">spring.redis.host=&#123;服务器A&#125;</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=</span><br><span class="line">spring.redis.timeout=5000</span><br></pre></td></tr></table></figure><h4 id="3-Application"><a href="#3-Application" class="headerlink" title="(3) Application"></a><strong>(3) Application</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NginxKeepalivedRedisDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NginxKeepalivedRedisDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-控制器和实体类"><a href="#4-控制器和实体类" class="headerlink" title="(4) 控制器和实体类"></a><strong>(4) 控制器和实体类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">login</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">"sessionId"</span>,session.getId());</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(<span class="string">"01"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        session.setAttribute(<span class="string">"userInfo"</span>, userInfo);</span><br><span class="line">        content.put(<span class="string">"hostAddress"</span>,InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">        content.put(<span class="string">"hostName"</span>,InetAddress.getLocalHost().getHostName());</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5392373940126446170L</span>;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a><strong>2.2 调试</strong></h3><p>&emsp;&emsp;尝试启动，发现报错：Connection refused: no further information。很明显Redis无法连接。</p><p>&emsp;&emsp;先开了下命令行，尝试 telnet 服务器A 6379 ，无法连通。</p><p>&emsp;&emsp;检查了一下防火墙，确认端口已经开放了，然后又检查了一下阿里云控制平台上是否在安全组中开放端口，发现也是正确的。</p><p>&emsp;&emsp;google了一下，尝试修改redis.conf，将bind 127.0.0.1 修改为0.0.0.0。</p><p>&emsp;&emsp;再次telnet，可以连通，分别在本地和服务器A发布服务（服务器端口8022被占用，启动时指定了端口8023），并分别访问：http://{服务器A}:8023/login</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务器A返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"6a5e81a6-04f4-4ca8-afd4-1559695c1446"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"xxx.xxx.xxx.xxx"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 本地返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"DESKTOP-xx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"2a7c4873-1f9b-414a-85fc-6298562de64b"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"192.168.31.197"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问：<a href="http://qxamoy.com:8023/login" target="_blank" rel="noopener">http://qxamoy.com:8023/login</a></p><p>&emsp;&emsp;修改配置文件nginx.conf（我新建了一个demo.conf并在nginx.conf中引用）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 负载均衡配置</span></span><br><span class="line">upstream demo_upstream&#123;</span><br><span class="line">  <span class="keyword">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8022</span> weight=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">server</span> xxx:<span class="number">8023</span> weight=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#虚拟主机的配置</span></span><br><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">    <span class="meta">#监听端口</span></span><br><span class="line">    listen <span class="number">7051</span>;</span><br><span class="line">    <span class="meta"># 指定ip地址或者域名，多个配置之间用空格分隔</span></span><br><span class="line">    server_name localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#对 "/" 启用反向代理</span></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//demo_upstream;</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动nginx。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx.exe</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问<a href="http://localhost:7051/login" target="_blank" rel="noopener">http://localhost:7051/login</a></p><p>&emsp;&emsp;可以观察每次请求后返回结果的变化（ip和session），顺利的话会看到根据权重来切换接收的服务端，所以日常更新版本时可以依次对单个服务器进行更新来完成“灰度发布”。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.v2ex.com/t/477509" target="_blank" rel="noopener">大家是怎么做到服务器热更新的?</a></p><p><a href="https://blog.csdn.net/IT_10/article/details/89365436" target="_blank" rel="noopener">超详细的Nginx负载均衡+高可用配置</a></p><p><a href="https://www.cnblogs.com/54chensongxia/p/12096493.html" target="_blank" rel="noopener">Spring系列.@EnableRedisHttpSession原理简析</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      使用Nginx来简单处理一次灰度发布的问题，更新网站后台同时“不停掉服务”。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="nginx" scheme="http://linyishui.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Postman笔记（持续更新）</title>
    <link href="http://linyishui.top/2020041001.html"/>
    <id>http://linyishui.top/2020041001.html</id>
    <published>2020-04-10T07:41:30.000Z</published>
    <updated>2020-04-23T02:55:45.926Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Postman笔记"><a href="#Postman笔记" class="headerlink" title="Postman笔记"></a><strong>Postman笔记</strong></h1><h2 id="1-自动获取Token"><a href="#1-自动获取Token" class="headerlink" title="1. 自动获取Token"></a><strong>1. 自动获取Token</strong></h2><p>&emsp;&emsp;首先根据login-api返回body确定token的位置。</p><p>&emsp;&emsp;然后在login-api中设置Tests，增加如下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"Status code is 200"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(responseBody);</span><br><span class="line"><span class="comment">// 项目多了一个Bearer，postman会自动生成，所以导致出现两个Bearer</span></span><br><span class="line"><span class="keyword">var</span> temp = data.token.substring(<span class="number">7</span>);</span><br><span class="line">pm.environment.set(<span class="string">"token"</span>, temp);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;添加自定义environment。</p><p>&emsp;&emsp;重新发送登录请求，观察是否自动生成环境变量。</p><p>&emsp;&emsp;接下来在使用token的api中通过的方式来获取变量，【Authorization】-&gt;【TYPE-Bearer Token】</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.postman.com/api-documentation-generator" title="Title" target="_blank" rel="noopener">postman-doc</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Postman笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="postman" scheme="http://linyishui.top/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建个人博客 (六) 异常解决记录</title>
    <link href="http://linyishui.top/2020040301.html"/>
    <id>http://linyishui.top/2020040301.html</id>
    <published>2020-04-03T02:31:00.000Z</published>
    <updated>2020-04-23T01:51:23.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo异常解决记录"><a href="#Hexo异常解决记录" class="headerlink" title="Hexo异常解决记录"></a><strong>Hexo异常解决记录</strong></h1><h2 id="unknown-block-tag-endif"><a href="#unknown-block-tag-endif" class="headerlink" title="unknown block tag: endif"></a><strong>unknown block tag: endif</strong></h2><p>&emsp;&emsp;一次更新博客（hexo g）时，出现以下异常。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010101.png" alt></p><p>&emsp;&emsp;google了一下，看到有类似问题的是因为在’{‘和’%’之间多写了空格这种语法错误，所以花了一些时间去找项目中的swig文件，因为刚好这次更新也有增加一些博客功能，怀疑是不是修改swig文件时也写错了。(<a href="https://52heartz.top/articles/hexo-template-render-error/" title="title" target="_blank" rel="noopener">Hexo 的 Template render error 错误</a> 和 <a href="https://github.com/hexojs/hexo/issues/3346" title="title" target="_blank" rel="noopener">hexo 在markdown文档中出现<code>{-% %-}</code>语法会报错，提示“Template render error: (unknown path) </a>)</p><p>&emsp;&emsp;但很快便发现没有找到异常，所以思考了一下，既然代码文件中的endif没有问题，会不会是其他地方也写了endif，突然想到这次提交也更新了MD文件，记录我这次更新，其中也直接记录了{\% endif \%}，所以就修改了相关描述。</p><p>&emsp;&emsp;重试了一下，问题解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://linyishui.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://linyishui.top/tags/hexo/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十四）Redis配置统计字典（未完成）</title>
    <link href="http://linyishui.top/2020032801.html"/>
    <id>http://linyishui.top/2020032801.html</id>
    <published>2020-03-28T08:26:47.000Z</published>
    <updated>2020-04-22T09:26:26.871Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十四章-Redis配置统计字典"><a href="#第十四章-Redis配置统计字典" class="headerlink" title="第十四章 Redis配置统计字典"></a><strong>第十四章 Redis配置统计字典</strong></h1><h2 id="14-1-info系统状态说明"><a href="#14-1-info系统状态说明" class="headerlink" title="14.1 info系统状态说明"></a><strong>14.1 info系统状态说明</strong></h2><h3 id="14-1-1-命令说明"><a href="#14-1-1-命令说明" class="headerlink" title="14.1.1 命令说明"></a><strong>14.1.1 命令说明</strong></h3><h3 id="14-1-2-详细说明"><a href="#14-1-2-详细说明" class="headerlink" title="14.1.2 详细说明"></a><strong>14.1.2 详细说明</strong></h3><hr><h2 id="14-2-standalone配置说明和分析"><a href="#14-2-standalone配置说明和分析" class="headerlink" title="14.2 standalone配置说明和分析"></a><strong>14.2 standalone配置说明和分析</strong></h2><h3 id="14-2-1-总体配置"><a href="#14-2-1-总体配置" class="headerlink" title="14.2.1 总体配置"></a><strong>14.2.1 总体配置</strong></h3><h3 id="14-2-2-最大内存及策略"><a href="#14-2-2-最大内存及策略" class="headerlink" title="14.2.2 最大内存及策略"></a><strong>14.2.2 最大内存及策略</strong></h3><h3 id="14-2-3-AOF相关配置"><a href="#14-2-3-AOF相关配置" class="headerlink" title="14.2.3 AOF相关配置"></a><strong>14.2.3 AOF相关配置</strong></h3><h3 id="14-2-4-RDB相关配置"><a href="#14-2-4-RDB相关配置" class="headerlink" title="14.2.4 RDB相关配置"></a><strong>14.2.4 RDB相关配置</strong></h3><h3 id="14-2-5-慢查询配置"><a href="#14-2-5-慢查询配置" class="headerlink" title="14.2.5 慢查询配置"></a><strong>14.2.5 慢查询配置</strong></h3><h3 id="14-2-6-数据结构优化配置"><a href="#14-2-6-数据结构优化配置" class="headerlink" title="14.2.6 数据结构优化配置"></a><strong>14.2.6 数据结构优化配置</strong></h3><h3 id="14-2-7-复制相关配置"><a href="#14-2-7-复制相关配置" class="headerlink" title="14.2.7 复制相关配置"></a><strong>14.2.7 复制相关配置</strong></h3><h3 id="14-2-8-客户端相关配置"><a href="#14-2-8-客户端相关配置" class="headerlink" title="14.2.8 客户端相关配置"></a><strong>14.2.8 客户端相关配置</strong></h3><h3 id="14-2-9-安全相关配置"><a href="#14-2-9-安全相关配置" class="headerlink" title="14.2.9 安全相关配置"></a><strong>14.2.9 安全相关配置</strong></h3><hr><h2 id="14-3-Sentinel配置说明和分析"><a href="#14-3-Sentinel配置说明和分析" class="headerlink" title="14.3 Sentinel配置说明和分析"></a><strong>14.3 Sentinel配置说明和分析</strong></h2><hr><h2 id="14-4-Cluster配置说明和分析"><a href="#14-4-Cluster配置说明和分析" class="headerlink" title="14.4 Cluster配置说明和分析"></a><strong>14.4 Cluster配置说明和分析</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十四）Redis配置统计字典，内容包括：info系统状态说明（命令说明，详细说明），standalone配置说明和分析（总体配置、最大内存及策略、AOF相关配置、RDB相关配置、慢查询配置、数据结构优化配置、复制相关配置、客户端相关配置、安全相关配置），Sentinel配置说明和分析，Cluster配置说明和分析等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十三）Redis监控运维云平台-CacheCloud（未完成）</title>
    <link href="http://linyishui.top/2020032501.html"/>
    <id>http://linyishui.top/2020032501.html</id>
    <published>2020-03-25T08:26:40.000Z</published>
    <updated>2020-04-22T09:21:52.485Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十三章-Redis监控运维云平台-CacheCloud"><a href="#第十三章-Redis监控运维云平台-CacheCloud" class="headerlink" title="第十三章 Redis监控运维云平台-CacheCloud"></a><strong>第十三章 Redis监控运维云平台-CacheCloud</strong></h1><h2 id="13-1-CacheCloud是什么"><a href="#13-1-CacheCloud是什么" class="headerlink" title="13.1 CacheCloud是什么"></a><strong>13.1 CacheCloud是什么</strong></h2><h3 id="13-1-1-现有问题"><a href="#13-1-1-现有问题" class="headerlink" title="13.1.1 现有问题"></a><strong>13.1.1 现有问题</strong></h3><h3 id="13-1-2-CacheCloud基本功能"><a href="#13-1-2-CacheCloud基本功能" class="headerlink" title="13.1.2 CacheCloud基本功能"></a><strong>13.1.2 CacheCloud基本功能</strong></h3><hr><h2 id="13-2-快速部署"><a href="#13-2-快速部署" class="headerlink" title="13.2 快速部署"></a><strong>13.2 快速部署</strong></h2><h3 id="13-2-1-CacheCloud环境需求"><a href="#13-2-1-CacheCloud环境需求" class="headerlink" title="13.2.1 CacheCloud环境需求"></a><strong>13.2.1 CacheCloud环境需求</strong></h3><h3 id="13-2-2-CacheCloud快速开始"><a href="#13-2-2-CacheCloud快速开始" class="headerlink" title="13.2.2 CacheCloud快速开始"></a><strong>13.2.2 CacheCloud快速开始</strong></h3><hr><h2 id="13-3-机器部署"><a href="#13-3-机器部署" class="headerlink" title="13.3 机器部署"></a><strong>13.3 机器部署</strong></h2><h3 id="13-3-1-部署脚本"><a href="#13-3-1-部署脚本" class="headerlink" title="13.3.1 部署脚本"></a><strong>13.3.1 部署脚本</strong></h3><h3 id="13-3-2-添加机器"><a href="#13-3-2-添加机器" class="headerlink" title="13.3.2 添加机器"></a><strong>13.3.2 添加机器</strong></h3><hr><h2 id="13-4-接入应用"><a href="#13-4-接入应用" class="headerlink" title="13.4 接入应用"></a><strong>13.4 接入应用</strong></h2><h3 id="13-4-1-总体流程"><a href="#13-4-1-总体流程" class="headerlink" title="13.4.1 总体流程"></a><strong>13.4.1 总体流程</strong></h3><h3 id="13-4-2-账户申请和审批"><a href="#13-4-2-账户申请和审批" class="headerlink" title="13.4.2 账户申请和审批"></a><strong>13.4.2 账户申请和审批</strong></h3><h3 id="13-4-3-应用申请和审批"><a href="#13-4-3-应用申请和审批" class="headerlink" title="13.4.3 应用申请和审批"></a><strong>13.4.3 应用申请和审批</strong></h3><h3 id="13-4-4-客户端接入"><a href="#13-4-4-客户端接入" class="headerlink" title="13.4.4 客户端接入"></a><strong>13.4.4 客户端接入</strong></h3><hr><h2 id="13-5-用户功能"><a href="#13-5-用户功能" class="headerlink" title="13.5 用户功能"></a><strong>13.5 用户功能</strong></h2><h3 id="13-5-1-应用统计信息"><a href="#13-5-1-应用统计信息" class="headerlink" title="13.5.1 应用统计信息"></a><strong>13.5.1 应用统计信息</strong></h3><h3 id="13-5-2-实例列表"><a href="#13-5-2-实例列表" class="headerlink" title="13.5.2 实例列表"></a><strong>13.5.2 实例列表</strong></h3><h3 id="13-5-3-应用详情"><a href="#13-5-3-应用详情" class="headerlink" title="13.5.3 应用详情"></a><strong>13.5.3 应用详情</strong></h3><h3 id="13-5-4-命令曲线"><a href="#13-5-4-命令曲线" class="headerlink" title="13.5.4 命令曲线"></a><strong>13.5.4 命令曲线</strong></h3><h3 id="13-5-5-CacheCloud-Redis-Shell-控制台"><a href="#13-5-5-CacheCloud-Redis-Shell-控制台" class="headerlink" title="13.5.5 CacheCloud Redis Shell 控制台"></a><strong>13.5.5 CacheCloud Redis Shell 控制台</strong></h3><h3 id="13-5-6-慢查询"><a href="#13-5-6-慢查询" class="headerlink" title="13.5.6 慢查询"></a><strong>13.5.6 慢查询</strong></h3><h3 id="13-5-7-应用拓扑"><a href="#13-5-7-应用拓扑" class="headerlink" title="13.5.7 应用拓扑"></a><strong>13.5.7 应用拓扑</strong></h3><hr><h2 id="13-6-运维功能"><a href="#13-6-运维功能" class="headerlink" title="13.6 运维功能"></a><strong>13.6 运维功能</strong></h2><h3 id="13-6-1-应用运维"><a href="#13-6-1-应用运维" class="headerlink" title="13.6.1 应用运维"></a><strong>13.6.1 应用运维</strong></h3><h3 id="13-6-2-接入已存在的Redis节点"><a href="#13-6-2-接入已存在的Redis节点" class="headerlink" title="13.6.2 接入已存在的Redis节点"></a><strong>13.6.2 接入已存在的Redis节点</strong></h3><h3 id="13-6-3-Redis配置模板"><a href="#13-6-3-Redis配置模板" class="headerlink" title="13.6.3 Redis配置模板"></a><strong>13.6.3 Redis配置模板</strong></h3><h3 id="13-6-4-迁移工具"><a href="#13-6-4-迁移工具" class="headerlink" title="13.6.4 迁移工具"></a><strong>13.6.4 迁移工具</strong></h3><h3 id="13-6-5-监控报警"><a href="#13-6-5-监控报警" class="headerlink" title="13.6.5 监控报警"></a><strong>13.6.5 监控报警</strong></h3><h3 id="13-6-6-系统配置管理"><a href="#13-6-6-系统配置管理" class="headerlink" title="13.6.6 系统配置管理"></a><strong>13.6.6 系统配置管理</strong></h3><hr><h2 id="13-7-客户端上报"><a href="#13-7-客户端上报" class="headerlink" title="13.7 客户端上报"></a><strong>13.7 客户端上报</strong></h2><h3 id="13-7-1-客户端上报整体设计"><a href="#13-7-1-客户端上报整体设计" class="headerlink" title="13.7.1 客户端上报整体设计"></a><strong>13.7.1 客户端上报整体设计</strong></h3><h3 id="13-7-2-Jedis核心代码修改"><a href="#13-7-2-Jedis核心代码修改" class="headerlink" title="13.7.2 Jedis核心代码修改"></a><strong>13.7.2 Jedis核心代码修改</strong></h3><h3 id="13-7-3-带上报功能的客户端"><a href="#13-7-3-带上报功能的客户端" class="headerlink" title="13.7.3 带上报功能的客户端"></a><strong>13.7.3 带上报功能的客户端</strong></h3><h3 id="13-7-4-CacheCloud客户端设计"><a href="#13-7-4-CacheCloud客户端设计" class="headerlink" title="13.7.4 CacheCloud客户端设计"></a><strong>13.7.4 CacheCloud客户端设计</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十三）Redis监控运维云平台-CacheCloud，内容包括：CacheCloud是什么，快速部署，机器部署，接入应用，用户功能，运维功能，客户端上报等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十二）开发运维的“陷阱”（未完成）</title>
    <link href="http://linyishui.top/2020032401.html"/>
    <id>http://linyishui.top/2020032401.html</id>
    <published>2020-03-24T08:26:34.000Z</published>
    <updated>2020-04-22T09:14:21.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十二章-开发运维的“陷阱”"><a href="#第十二章-开发运维的“陷阱”" class="headerlink" title="第十二章 开发运维的“陷阱”"></a><strong>第十二章 开发运维的“陷阱”</strong></h1><h2 id="12-1-Linux配置优化"><a href="#12-1-Linux配置优化" class="headerlink" title="12.1 Linux配置优化"></a><strong>12.1 Linux配置优化</strong></h2><h3 id="12-1-1-内存分配控制"><a href="#12-1-1-内存分配控制" class="headerlink" title="12.1.1 内存分配控制"></a><strong>12.1.1 内存分配控制</strong></h3><h3 id="12-1-2-swappiness"><a href="#12-1-2-swappiness" class="headerlink" title="12.1.2 swappiness"></a><strong>12.1.2 swappiness</strong></h3><h3 id="12-1-3-THP"><a href="#12-1-3-THP" class="headerlink" title="12.1.3 THP"></a><strong>12.1.3 THP</strong></h3><h3 id="12-1-4-OOM-killer"><a href="#12-1-4-OOM-killer" class="headerlink" title="12.1.4 OOM killer"></a><strong>12.1.4 OOM killer</strong></h3><h3 id="12-1-5-使用NTP"><a href="#12-1-5-使用NTP" class="headerlink" title="12.1.5 使用NTP"></a><strong>12.1.5 使用NTP</strong></h3><h3 id="12-1-6-ulimit"><a href="#12-1-6-ulimit" class="headerlink" title="12.1.6 ulimit"></a><strong>12.1.6 ulimit</strong></h3><h3 id="12-1-7-TCP-backlog"><a href="#12-1-7-TCP-backlog" class="headerlink" title="12.1.7 TCP backlog"></a><strong>12.1.7 TCP backlog</strong></h3><hr><h2 id="12-2-flushall-flushdb误操作"><a href="#12-2-flushall-flushdb误操作" class="headerlink" title="12.2 flushall/flushdb误操作"></a><strong>12.2 flushall/flushdb误操作</strong></h2><h3 id="12-2-1-缓存与存储"><a href="#12-2-1-缓存与存储" class="headerlink" title="12.2.1 缓存与存储"></a><strong>12.2.1 缓存与存储</strong></h3><h3 id="12-2-2-借助AOF机制恢复"><a href="#12-2-2-借助AOF机制恢复" class="headerlink" title="12.2.2 借助AOF机制恢复"></a><strong>12.2.2 借助AOF机制恢复</strong></h3><h3 id="12-2-3-RDB有什么变化"><a href="#12-2-3-RDB有什么变化" class="headerlink" title="12.2.3 RDB有什么变化"></a><strong>12.2.3 RDB有什么变化</strong></h3><h3 id="12-2-4-从节点有什么变化"><a href="#12-2-4-从节点有什么变化" class="headerlink" title="12.2.4 从节点有什么变化"></a><strong>12.2.4 从节点有什么变化</strong></h3><h3 id="12-2-5-快速恢复数据"><a href="#12-2-5-快速恢复数据" class="headerlink" title="12.2.5 快速恢复数据"></a><strong>12.2.5 快速恢复数据</strong></h3><hr><h2 id="12-3-安全的Redis"><a href="#12-3-安全的Redis" class="headerlink" title="12.3 安全的Redis"></a><strong>12.3 安全的Redis</strong></h2><h3 id="12-3-1-Redis密码机制"><a href="#12-3-1-Redis密码机制" class="headerlink" title="12.3.1 Redis密码机制"></a><strong>12.3.1 Redis密码机制</strong></h3><h3 id="12-3-2-伪装危险命令"><a href="#12-3-2-伪装危险命令" class="headerlink" title="12.3.2 伪装危险命令"></a><strong>12.3.2 伪装危险命令</strong></h3><h3 id="12-3-3-防火墙"><a href="#12-3-3-防火墙" class="headerlink" title="12.3.3 防火墙"></a><strong>12.3.3 防火墙</strong></h3><h3 id="12-3-4-bind"><a href="#12-3-4-bind" class="headerlink" title="12.3.4 bind"></a><strong>12.3.4 bind</strong></h3><h3 id="12-3-5-定期备份数据"><a href="#12-3-5-定期备份数据" class="headerlink" title="12.3.5 定期备份数据"></a><strong>12.3.5 定期备份数据</strong></h3><h3 id="12-3-6-不使用默认端口"><a href="#12-3-6-不使用默认端口" class="headerlink" title="12.3.6 不使用默认端口"></a><strong>12.3.6 不使用默认端口</strong></h3><h3 id="12-3-7-使用非root用户启动"><a href="#12-3-7-使用非root用户启动" class="headerlink" title="12.3.7 使用非root用户启动"></a><strong>12.3.7 使用非root用户启动</strong></h3><hr><h2 id="12-4-处理bigkey"><a href="#12-4-处理bigkey" class="headerlink" title="12.4 处理bigkey"></a><strong>12.4 处理bigkey</strong></h2><h3 id="12-4-1-bigkey的危害"><a href="#12-4-1-bigkey的危害" class="headerlink" title="12.4.1 bigkey的危害"></a><strong>12.4.1 bigkey的危害</strong></h3><h3 id="12-4-2-如何发现"><a href="#12-4-2-如何发现" class="headerlink" title="12.4.2 如何发现"></a><strong>12.4.2 如何发现</strong></h3><h3 id="12-4-3-如何删除"><a href="#12-4-3-如何删除" class="headerlink" title="12.4.3 如何删除"></a><strong>12.4.3 如何删除</strong></h3><h3 id="12-4-4-最佳实践思路"><a href="#12-4-4-最佳实践思路" class="headerlink" title="12.4.4 最佳实践思路"></a><strong>12.4.4 最佳实践思路</strong></h3><hr><h2 id="12-5-寻找热点key"><a href="#12-5-寻找热点key" class="headerlink" title="12.5 寻找热点key"></a><strong>12.5 寻找热点key</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十二）开发运维的“陷阱”，内容包括：Linux配置优化，flushall/flushdb误操作，安全的Redis，处理bigkey，寻找热点key等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十一）缓存设计（未完成）</title>
    <link href="http://linyishui.top/2020032101.html"/>
    <id>http://linyishui.top/2020032101.html</id>
    <published>2020-03-21T08:26:28.000Z</published>
    <updated>2020-04-22T09:08:08.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十一章-缓存设计"><a href="#第十一章-缓存设计" class="headerlink" title="第十一章 缓存设计"></a><strong>第十一章 缓存设计</strong></h1><h2 id="11-1-缓存的收益与成本"><a href="#11-1-缓存的收益与成本" class="headerlink" title="11.1 缓存的收益与成本"></a><strong>11.1 缓存的收益与成本</strong></h2><hr><h2 id="11-2-缓存更新策略"><a href="#11-2-缓存更新策略" class="headerlink" title="11.2 缓存更新策略"></a><strong>11.2 缓存更新策略</strong></h2><hr><h2 id="11-3-缓存粒度控制"><a href="#11-3-缓存粒度控制" class="headerlink" title="11.3 缓存粒度控制"></a><strong>11.3 缓存粒度控制</strong></h2><hr><h2 id="11-4-穿透优化"><a href="#11-4-穿透优化" class="headerlink" title="11.4 穿透优化"></a><strong>11.4 穿透优化</strong></h2><hr><h2 id="11-5-无底洞优化"><a href="#11-5-无底洞优化" class="headerlink" title="11.5 无底洞优化"></a><strong>11.5 无底洞优化</strong></h2><hr><h2 id="11-6-雪崩优化"><a href="#11-6-雪崩优化" class="headerlink" title="11.6 雪崩优化"></a><strong>11.6 雪崩优化</strong></h2><hr><h2 id="11-7-热点key重建优化"><a href="#11-7-热点key重建优化" class="headerlink" title="11.7 热点key重建优化"></a><strong>11.7 热点key重建优化</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十一）缓存设计，内容包括：缓存的收益与成本，缓存更新策略，缓存粒度控制，穿透优化，无底洞优化，雪崩优化，热点key重建优化等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十）集群（未完成）</title>
    <link href="http://linyishui.top/2020031801.html"/>
    <id>http://linyishui.top/2020031801.html</id>
    <published>2020-03-18T08:26:19.000Z</published>
    <updated>2020-04-22T09:05:11.539Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十章-集群"><a href="#第十章-集群" class="headerlink" title="第十章 集群"></a><strong>第十章 集群</strong></h1><h2 id="10-1-数据分布"><a href="#10-1-数据分布" class="headerlink" title="10.1 数据分布"></a><strong>10.1 数据分布</strong></h2><h3 id="10-1-1-数据分布理论"><a href="#10-1-1-数据分布理论" class="headerlink" title="10.1.1 数据分布理论"></a><strong>10.1.1 数据分布理论</strong></h3><h3 id="10-1-2-Redis数据分区"><a href="#10-1-2-Redis数据分区" class="headerlink" title="10.1.2 Redis数据分区"></a><strong>10.1.2 Redis数据分区</strong></h3><h3 id="10-1-3-集群功能限制"><a href="#10-1-3-集群功能限制" class="headerlink" title="10.1.3 集群功能限制"></a><strong>10.1.3 集群功能限制</strong></h3><hr><h2 id="10-2-搭建集群"><a href="#10-2-搭建集群" class="headerlink" title="10.2 搭建集群"></a><strong>10.2 搭建集群</strong></h2><h3 id="10-2-1-准备节点"><a href="#10-2-1-准备节点" class="headerlink" title="10.2.1 准备节点"></a><strong>10.2.1 准备节点</strong></h3><h3 id="10-2-2-节点握手"><a href="#10-2-2-节点握手" class="headerlink" title="10.2.2 节点握手"></a><strong>10.2.2 节点握手</strong></h3><h3 id="10-2-3-分配槽"><a href="#10-2-3-分配槽" class="headerlink" title="10.2.3 分配槽"></a><strong>10.2.3 分配槽</strong></h3><h3 id="10-2-4-用redis-trib-rb搭建集群"><a href="#10-2-4-用redis-trib-rb搭建集群" class="headerlink" title="10.2.4 用redis-trib.rb搭建集群"></a><strong>10.2.4 用redis-trib.rb搭建集群</strong></h3><hr><h2 id="10-3-节点通信"><a href="#10-3-节点通信" class="headerlink" title="10.3 节点通信"></a><strong>10.3 节点通信</strong></h2><h3 id="10-3-1-通信流程"><a href="#10-3-1-通信流程" class="headerlink" title="10.3.1 通信流程"></a><strong>10.3.1 通信流程</strong></h3><h3 id="10-3-2-Gossip消息"><a href="#10-3-2-Gossip消息" class="headerlink" title="10.3.2 Gossip消息"></a><strong>10.3.2 Gossip消息</strong></h3><h3 id="10-3-3-节点选择"><a href="#10-3-3-节点选择" class="headerlink" title="10.3.3 节点选择"></a><strong>10.3.3 节点选择</strong></h3><hr><h2 id="10-4-集群伸缩"><a href="#10-4-集群伸缩" class="headerlink" title="10.4 集群伸缩"></a><strong>10.4 集群伸缩</strong></h2><h3 id="10-4-1-伸缩原理"><a href="#10-4-1-伸缩原理" class="headerlink" title="10.4.1 伸缩原理"></a><strong>10.4.1 伸缩原理</strong></h3><h3 id="10-4-2-扩容集群"><a href="#10-4-2-扩容集群" class="headerlink" title="10.4.2 扩容集群"></a><strong>10.4.2 扩容集群</strong></h3><h3 id="10-4-3-收缩集群"><a href="#10-4-3-收缩集群" class="headerlink" title="10.4.3 收缩集群"></a><strong>10.4.3 收缩集群</strong></h3><hr><h2 id="10-5-请求路由"><a href="#10-5-请求路由" class="headerlink" title="10.5 请求路由"></a><strong>10.5 请求路由</strong></h2><h3 id="10-5-1-请求重定向"><a href="#10-5-1-请求重定向" class="headerlink" title="10.5.1 请求重定向"></a><strong>10.5.1 请求重定向</strong></h3><h3 id="10-5-2-Smart客户端"><a href="#10-5-2-Smart客户端" class="headerlink" title="10.5.2 Smart客户端"></a><strong>10.5.2 Smart客户端</strong></h3><h3 id="10-5-3-ASK重定向"><a href="#10-5-3-ASK重定向" class="headerlink" title="10.5.3 ASK重定向"></a><strong>10.5.3 ASK重定向</strong></h3><hr><h2 id="10-6-故障转移"><a href="#10-6-故障转移" class="headerlink" title="10.6 故障转移"></a><strong>10.6 故障转移</strong></h2><h3 id="10-6-1-故障发现"><a href="#10-6-1-故障发现" class="headerlink" title="10.6.1 故障发现"></a><strong>10.6.1 故障发现</strong></h3><h3 id="10-6-2-故障恢复"><a href="#10-6-2-故障恢复" class="headerlink" title="10.6.2 故障恢复"></a><strong>10.6.2 故障恢复</strong></h3><h3 id="10-6-3-故障转移时间"><a href="#10-6-3-故障转移时间" class="headerlink" title="10.6.3 故障转移时间"></a><strong>10.6.3 故障转移时间</strong></h3><h3 id="10-6-4-故障演练"><a href="#10-6-4-故障演练" class="headerlink" title="10.6.4 故障演练"></a><strong>10.6.4 故障演练</strong></h3><hr><h2 id="10-7-集群运维"><a href="#10-7-集群运维" class="headerlink" title="10.7 集群运维"></a><strong>10.7 集群运维</strong></h2><h3 id="10-7-1-集群完整性"><a href="#10-7-1-集群完整性" class="headerlink" title="10.7.1 集群完整性"></a><strong>10.7.1 集群完整性</strong></h3><h3 id="10-7-2-带宽消耗"><a href="#10-7-2-带宽消耗" class="headerlink" title="10.7.2 带宽消耗"></a><strong>10.7.2 带宽消耗</strong></h3><h3 id="10-7-3-Pub-Sub广播问题"><a href="#10-7-3-Pub-Sub广播问题" class="headerlink" title="10.7.3 Pub/Sub广播问题"></a><strong>10.7.3 Pub/Sub广播问题</strong></h3><h3 id="10-7-4-集群倾斜"><a href="#10-7-4-集群倾斜" class="headerlink" title="10.7.4 集群倾斜"></a><strong>10.7.4 集群倾斜</strong></h3><h3 id="10-7-5-集群读写分离"><a href="#10-7-5-集群读写分离" class="headerlink" title="10.7.5 集群读写分离"></a><strong>10.7.5 集群读写分离</strong></h3><h3 id="10-7-6-手动故障转移"><a href="#10-7-6-手动故障转移" class="headerlink" title="10.7.6 手动故障转移"></a><strong>10.7.6 手动故障转移</strong></h3><h3 id="10-7-7-数据迁移"><a href="#10-7-7-数据迁移" class="headerlink" title="10.7.7 数据迁移"></a><strong>10.7.7 数据迁移</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十）集群，内容包括：数据分布，搭建集群，节点通信，集群伸缩，请求路由，故障转移，集群运维等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（九）哨兵（未完成）</title>
    <link href="http://linyishui.top/2020031601.html"/>
    <id>http://linyishui.top/2020031601.html</id>
    <published>2020-03-16T08:26:13.000Z</published>
    <updated>2020-04-22T08:58:18.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第九章-哨兵"><a href="#第九章-哨兵" class="headerlink" title="第九章 哨兵"></a><strong>第九章 哨兵</strong></h1><h2 id="9-1-基本概念"><a href="#9-1-基本概念" class="headerlink" title="9.1 基本概念"></a><strong>9.1 基本概念</strong></h2><h3 id="9-1-1-主从复制的问题"><a href="#9-1-1-主从复制的问题" class="headerlink" title="9.1.1 主从复制的问题"></a><strong>9.1.1 主从复制的问题</strong></h3><h3 id="9-1-2-高可用"><a href="#9-1-2-高可用" class="headerlink" title="9.1.2 高可用"></a><strong>9.1.2 高可用</strong></h3><h3 id="9-1-3-Redis-Sentinel的高可用性"><a href="#9-1-3-Redis-Sentinel的高可用性" class="headerlink" title="9.1.3 Redis Sentinel的高可用性"></a><strong>9.1.3 Redis Sentinel的高可用性</strong></h3><hr><h2 id="9-2-安装和部署"><a href="#9-2-安装和部署" class="headerlink" title="9.2 安装和部署"></a><strong>9.2 安装和部署</strong></h2><h3 id="9-2-1-部署拓扑结构"><a href="#9-2-1-部署拓扑结构" class="headerlink" title="9.2.1 部署拓扑结构"></a><strong>9.2.1 部署拓扑结构</strong></h3><h3 id="9-2-2-部署Redis数据节点"><a href="#9-2-2-部署Redis数据节点" class="headerlink" title="9.2.2 部署Redis数据节点"></a><strong>9.2.2 部署Redis数据节点</strong></h3><h3 id="9-2-3-部署Sentinel节点"><a href="#9-2-3-部署Sentinel节点" class="headerlink" title="9.2.3 部署Sentinel节点"></a><strong>9.2.3 部署Sentinel节点</strong></h3><h3 id="9-2-4-配置优化"><a href="#9-2-4-配置优化" class="headerlink" title="9.2.4 配置优化"></a><strong>9.2.4 配置优化</strong></h3><h3 id="9-2-5-部署技巧"><a href="#9-2-5-部署技巧" class="headerlink" title="9.2.5 部署技巧"></a><strong>9.2.5 部署技巧</strong></h3><hr><h2 id="9-3-API"><a href="#9-3-API" class="headerlink" title="9.3 API"></a><strong>9.3 API</strong></h2><hr><h2 id="9-4-客户端连接"><a href="#9-4-客户端连接" class="headerlink" title="9.4 客户端连接"></a><strong>9.4 客户端连接</strong></h2><h3 id="9-4-1-Redis-Sentinel的客户端"><a href="#9-4-1-Redis-Sentinel的客户端" class="headerlink" title="9.4.1 Redis Sentinel的客户端"></a><strong>9.4.1 Redis Sentinel的客户端</strong></h3><h3 id="9-4-2-Redis-Sentinel客户端基本实现原理"><a href="#9-4-2-Redis-Sentinel客户端基本实现原理" class="headerlink" title="9.4.2 Redis Sentinel客户端基本实现原理"></a><strong>9.4.2 Redis Sentinel客户端基本实现原理</strong></h3><h3 id="9-4-3-Java操作Redis-Sentinel"><a href="#9-4-3-Java操作Redis-Sentinel" class="headerlink" title="9.4.3 Java操作Redis Sentinel"></a><strong>9.4.3 Java操作Redis Sentinel</strong></h3><hr><h2 id="9-5-实现原理"><a href="#9-5-实现原理" class="headerlink" title="9.5 实现原理"></a><strong>9.5 实现原理</strong></h2><h3 id="9-5-1-三个定时监控任务"><a href="#9-5-1-三个定时监控任务" class="headerlink" title="9.5.1 三个定时监控任务"></a><strong>9.5.1 三个定时监控任务</strong></h3><h3 id="9-5-2-主观下线和客观下线"><a href="#9-5-2-主观下线和客观下线" class="headerlink" title="9.5.2 主观下线和客观下线"></a><strong>9.5.2 主观下线和客观下线</strong></h3><h3 id="9-5-3-领导者Sentinel节点选举"><a href="#9-5-3-领导者Sentinel节点选举" class="headerlink" title="9.5.3 领导者Sentinel节点选举"></a><strong>9.5.3 领导者Sentinel节点选举</strong></h3><h3 id="9-5-4-故障转移"><a href="#9-5-4-故障转移" class="headerlink" title="9.5.4 故障转移"></a><strong>9.5.4 故障转移</strong></h3><hr><h2 id="9-6-开发与运维中的问题"><a href="#9-6-开发与运维中的问题" class="headerlink" title="9.6 开发与运维中的问题"></a><strong>9.6 开发与运维中的问题</strong></h2><h3 id="9-6-1-故障转移日志分析"><a href="#9-6-1-故障转移日志分析" class="headerlink" title="9.6.1 故障转移日志分析"></a><strong>9.6.1 故障转移日志分析</strong></h3><h3 id="9-6-2-节点运维"><a href="#9-6-2-节点运维" class="headerlink" title="9.6.2 节点运维"></a><strong>9.6.2 节点运维</strong></h3><h3 id="9-6-3-高可用读写分离"><a href="#9-6-3-高可用读写分离" class="headerlink" title="9.6.3 高可用读写分离"></a><strong>9.6.3 高可用读写分离</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（九）哨兵，内容包括：基本概念，安装和部署，API，客户端连接，实现原理，开发与运维中的问题等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
</feed>
