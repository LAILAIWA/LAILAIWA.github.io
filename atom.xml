<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-04-17T11:02:16.959Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Speciosity</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket</title>
    <link href="http://linyishui.top/2020041701.html"/>
    <id>http://linyishui.top/2020041701.html</id>
    <published>2020-04-17T01:31:16.000Z</published>
    <updated>2020-04-17T11:02:16.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-为什么需要WebSocket"><a href="#1-1-为什么需要WebSocket" class="headerlink" title="1.1 为什么需要WebSocket"></a><strong>1.1 为什么需要WebSocket</strong></h3><p>​        我们已经有了HTTP协议，为什么还需要使用WebSocket呢？答案就是解决HTTP的缺陷-<strong>通信只能由客户端发起</strong>。</p><p>​        很多场景下我们需要由服务端主动向客户端推送消息，而HTTP协议这种单向请求的设计注定了服务器端有连续的状态变化时，客户端很难去获知。</p><p>​        早期，很多网站为了实现<a href="https://zh.wikipedia.org/wiki/推送技术" target="_blank" rel="noopener">推送技术</a>，所用的技术都是<a href="https://zh.wikipedia.org/wiki/輪詢" target="_blank" rel="noopener">轮询</a>。轮询是指由浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，然后服务器返回最新的数据给客户端。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求与回复可能会包含较长的<a href="https://zh.wikipedia.org/wiki/HTTP头字段" target="_blank" rel="noopener">头部</a>，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源，最常见的场景就是聊天室。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010102.png" alt=""></p><p>​        比较新的轮询技术是<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。</p><p>​        由此契机催生了WebSocket协议，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h3 id="1-2-什么是WebSocket"><a href="#1-2-什么是WebSocket" class="headerlink" title="1.2 什么是WebSocket"></a><strong>1.2 什么是WebSocket</strong></h3><p>​        <strong>WebSocket</strong>是一种<a href="https://zh.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在单个<a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP</a>连接上进行<a href="https://zh.wikipedia.org/wiki/全雙工" target="_blank" rel="noopener">全双工</a>通信，位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>。</p><p>​        WebSocket协议诞生于2008年，最初在<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>规范中被引用为TCPConnection，作为基于TCP的套接字API的占位符。2008年6月，<a href="https://zh.wikipedia.org/w/index.php?title=Michael_Carter&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Michael Carter</a>进行了一系列讨论，最终形成了称为WebSocket的协议。</p><p>​        WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>​        WebSocket是一种与<a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP</a>不同的协议。两者都位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>，并且都依赖于<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>的TCP协议。 虽然它们不同，但是RFC 6455中规定：<code>it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries</code>（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-1" target="_blank" rel="noopener">[1]</a>从HTTP协议更改为WebSocket协议。</p><p>​        WebSocket协议支持Web<a href="https://zh.wikipedia.org/wiki/浏览器" target="_blank" rel="noopener">浏览器</a>（或其他客户端应用程序）与Web<a href="https://zh.wikipedia.org/wiki/服务器" target="_blank" rel="noopener">服务器</a>之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)之类的技术以非标准化的方式实现了类似的双向通信。</p><p>​        <strong>与HTTP不同，WebSocket提供全双工通信</strong>。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-2" target="_blank" rel="noopener">[2]</a><a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-quantum-3" target="_blank" rel="noopener">[3]</a>此外，<strong>WebSocket还可以在TCP之上实现消息流</strong>。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p><blockquote><ul><li>单工通信：即只能A到B（广播），同一时间只允许一方向另一方传送消息，另一方则不允许反过来传送。</li><li>全双工：指在发送数据的同时也能接收数据，二者同步进行。</li><li>半双工：指在一个时间段内只有一个动作发生，数据信息可以沿两个方向传送，但同一时刻一个信道只允许单方向传送，因此也称为双向交替通信。如果要改变传输方向，需由开关进行切换。半双工方式要求收发两端都有发送装置和接收装置。由于这种方式要频繁变换信道方向，故效率低，但可以节约传输线路。半双工方式适用于终端与终端之间的会话式通信。</li></ul></blockquote><p>​        WebSocket协议规范将<code>ws</code>（WebSocket）和<code>wss</code>（WebSocket Secure）定义为两个新的<a href="https://zh.wikipedia.org/wiki/統一資源標識符" target="_blank" rel="noopener">统一资源标识符</a>（URI）方案<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-4" target="_blank" rel="noopener">[4]</a>，分别对应明文和加密连接，其中<code>wss</code>表示使用了<a href="https://zh.wikipedia.org/wiki/TLS" target="_blank" rel="noopener">TLS</a>的Websocket。除了方案名称和片段ID（不支持<code>#</code>）之外，其余的URI组件都被定义为此URI的通用语法。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-5" target="_blank" rel="noopener">[5]</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">w</span><span class="variable">s:</span>//example.<span class="keyword">com</span>/wsapi</span><br><span class="line"><span class="keyword">ws</span><span class="variable">s:</span>//secure.example.<span class="keyword">com</span>/wsapi</span><br></pre></td></tr></table></figure><p>​        默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。        </p><p>​        使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架。</p><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a><strong>1.3 优点</strong></h3><ul><li><p><strong>较少的控制开销</strong>。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a href="https://zh.wikipedia.org/wiki/掩码" target="_blank" rel="noopener">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p></li><li><p><strong>更强的实时性</strong>。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的<a href="https://zh.wikipedia.org/w/index.php?title=长轮询&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">长轮询</a>比较，其也能在短时间内更多次地传递数据。</p></li><li><p><strong>保持连接状态</strong>。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p></li><li><p><strong>更好的二进制支持</strong>。Websocket定义了<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</p></li><li><p><strong>可以支持扩展</strong>。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a href="https://zh.wikipedia.org/wiki/数据压缩" target="_blank" rel="noopener">压缩</a>等。</p></li><li><p><strong>更好的压缩效果</strong>。相对于<a href="https://zh.wikipedia.org/wiki/HTTP压缩" target="_blank" rel="noopener">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a href="https://zh.wikipedia.org/wiki/上下文" target="_blank" rel="noopener">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-14" target="_blank" rel="noopener">[14]</a></p></li></ul><hr><h2 id="第二节-HTML5-WebSocket"><a href="#第二节-HTML5-WebSocket" class="headerlink" title="第二节 HTML5 WebSocket"></a><strong>第二节 HTML5 WebSocket</strong></h2><p>​        浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>​        当你获取 Web Socket 连接后，你可以通过 <strong>send()</strong> 方法来向服务器发送数据，并通过 <strong>onmessage</strong> 事件来接收服务器返回的数据。</p><p>以下 API 用于创建 WebSocket 对象。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Socket = <span class="keyword">new</span> <span class="type">WebSocket</span>(url, [protocol] );</span><br></pre></td></tr></table></figure><p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><hr><h2 id="第三节-实现"><a href="#第三节-实现" class="headerlink" title="第三节 实现"></a><strong>第三节 实现</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/WebSocket" target="_blank" rel="noopener">WebSocket-维基百科</a></p><p><a href="https://www.runoob.com/html/html5-websocket.html" target="_blank" rel="noopener">html5-websocket-菜鸟教程</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍WebSocket相关知识，内容包括：。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="websocket" scheme="http://linyishui.top/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Nginx简单处理一次灰度发布问题</title>
    <link href="http://linyishui.top/2020041501.html"/>
    <id>http://linyishui.top/2020041501.html</id>
    <published>2020-04-15T06:28:48.000Z</published>
    <updated>2020-04-16T09:41:22.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nginx简单处理一次灰度发布问题"><a href="#Nginx简单处理一次灰度发布问题" class="headerlink" title="Nginx简单处理一次灰度发布问题"></a><strong>Nginx简单处理一次灰度发布问题</strong></h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a><strong>1.需求</strong></h2><p>&emsp;&emsp;公司接手的一个半成品项目，客户要求更新版本时不要停掉网站（灰度发布）。</p><p>&emsp;&emsp;马上想到的方案是：主从热备和负载均衡，nginx+keepalived，然后又想到了自动部署-CI/CD，及时打住避免越想越远。这个项目本身比较粗糙，简单的解决当前的问题即可。</p><p>&emsp;&emsp;原系统使用session存储会话信息，所以还要解决session如何共享的问题，google了一下，决定nginx配置两台服务器负载均衡，发布新版本时，一次更新一个，然后使用Redis来共享session。</p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a><strong>2.实现</strong></h2><p>&emsp;&emsp;时间和精力有限，先在本地和测试服务器跑通一个demo。</p><p>&emsp;&emsp;两台机器：本机，服务器A</p><table><thead><tr><th style="text-align:center">工具</th><th style="text-align:center">本机</th><th style="text-align:center">服务器A</th></tr></thead><tbody><tr><td style="text-align:center">JDK 1.8</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Nginx</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">Redis</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr></tbody></table><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a><strong>2.1 代码</strong></h3><p>&emsp;&emsp;首先新建spring-boot项目，代码如下。</p><h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="(1) pom.xml"></a><strong>(1) pom.xml</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-application-properties"><a href="#2-application-properties" class="headerlink" title="(2) application.properties"></a><strong>(2) application.properties</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8022</span><br><span class="line"></span><br><span class="line">spring.redis.host=&#123;服务器A&#125;</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=</span><br><span class="line">spring.redis.timeout=5000</span><br></pre></td></tr></table></figure><h4 id="3-Application"><a href="#3-Application" class="headerlink" title="(3) Application"></a><strong>(3) Application</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NginxKeepalivedRedisDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NginxKeepalivedRedisDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-控制器和实体类"><a href="#4-控制器和实体类" class="headerlink" title="(4) 控制器和实体类"></a><strong>(4) 控制器和实体类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">login</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">"sessionId"</span>,session.getId());</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(<span class="string">"01"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        session.setAttribute(<span class="string">"userInfo"</span>, userInfo);</span><br><span class="line">        content.put(<span class="string">"hostAddress"</span>,InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">        content.put(<span class="string">"hostName"</span>,InetAddress.getLocalHost().getHostName());</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5392373940126446170L</span>;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a><strong>2.2 调试</strong></h3><p>&emsp;&emsp;尝试启动，发现报错：Connection refused: no further information。很明显Redis无法连接。</p><p>&emsp;&emsp;先开了下命令行，尝试 telnet 服务器A 6379 ，无法连通。</p><p>&emsp;&emsp;检查了一下防火墙，确认端口已经开放了，然后又检查了一下阿里云控制平台上是否在安全组中开放端口，发现也是正确的。</p><p>&emsp;&emsp;google了一下，尝试修改redis.conf，将bind 127.0.0.1 修改为0.0.0.0。</p><p>&emsp;&emsp;再次telnet，可以连通，分别在本地和服务器A发布服务（服务器端口8022被占用，启动时指定了端口8023），并分别访问：http://{服务器A}:8023/login</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务器A返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"6a5e81a6-04f4-4ca8-afd4-1559695c1446"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"xxx.xxx.xxx.xxx"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 本地返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"DESKTOP-xx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"2a7c4873-1f9b-414a-85fc-6298562de64b"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"192.168.31.197"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问：<a href="http://qxamoy.com:8023/login" target="_blank" rel="noopener">http://qxamoy.com:8023/login</a></p><p>&emsp;&emsp;修改配置文件nginx.conf（我新建了一个demo.conf并在nginx.conf中引用）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 负载均衡配置</span></span><br><span class="line">upstream demo_upstream&#123;</span><br><span class="line">  <span class="keyword">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8022</span> weight=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">server</span> xxx:<span class="number">8023</span> weight=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#虚拟主机的配置</span></span><br><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">    <span class="meta">#监听端口</span></span><br><span class="line">    listen <span class="number">7051</span>;</span><br><span class="line">    <span class="meta"># 指定ip地址或者域名，多个配置之间用空格分隔</span></span><br><span class="line">    server_name localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#对 "/" 启用反向代理</span></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//demo_upstream;</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动nginx。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx.exe</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问<a href="http://localhost:7051/login" target="_blank" rel="noopener">http://localhost:7051/login</a></p><p>&emsp;&emsp;可以观察每次请求后返回结果的变化（ip和session），顺利的话会看到根据权重来切换接收的服务端，所以日常更新版本时可以依次对单个服务器进行更新来完成“灰度发布”。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.v2ex.com/t/477509" target="_blank" rel="noopener">大家是怎么做到服务器热更新的?</a></p><p><a href="https://blog.csdn.net/IT_10/article/details/89365436" target="_blank" rel="noopener">超详细的Nginx负载均衡+高可用配置</a></p><p><a href="https://www.cnblogs.com/54chensongxia/p/12096493.html" target="_blank" rel="noopener">Spring系列.@EnableRedisHttpSession原理简析</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      使用Nginx来简单处理一次灰度发布的问题，更新网站后台同时“不停掉服务”。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="nginx" scheme="http://linyishui.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Postman笔记（持续更新）</title>
    <link href="http://linyishui.top/2020041001.html"/>
    <id>http://linyishui.top/2020041001.html</id>
    <published>2020-04-10T07:41:30.000Z</published>
    <updated>2020-04-10T07:50:25.676Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Postman笔记"><a href="#Postman笔记" class="headerlink" title="Postman笔记"></a><strong>Postman笔记</strong></h1><h2 id="1-自动获取Token"><a href="#1-自动获取Token" class="headerlink" title="1. 自动获取Token"></a><strong>1. 自动获取Token</strong></h2><p>&emsp;&emsp;首先根据login-api返回body确定token的位置。</p><p>&emsp;&emsp;然后在login-api中设置Tests，增加如下代码。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pm</span>.test(<span class="string">"Status code is 200"</span>, function () &#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="title">var</span> <span class="class"><span class="keyword">data</span> = <span class="type">JSON</span>.parse(<span class="title">responseBody</span>);</span></span><br><span class="line"><span class="meta"># 项目多了一个Bearer，postman会自动生成，所以导致出现两个Bearer</span></span><br><span class="line"><span class="title">var</span> temp = <span class="class"><span class="keyword">data</span>.token.substring(7);</span></span><br><span class="line"><span class="title">pm</span>.environment.set(<span class="string">"token"</span>, temp);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;添加自定义environment。</p><p>&emsp;&emsp;重新发送登录请求，观察是否自动生成环境变量。</p><p>&emsp;&emsp;接下来在使用token的api中通过的方式来获取变量，【Authorization】-&gt;【TYPE-Bearer Token】</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.postman.com/api-documentation-generator" title="Title" target="_blank" rel="noopener">postman-doc</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Postman笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="postman" scheme="http://linyishui.top/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（二）API介绍</title>
    <link href="http://linyishui.top/2020030201.html"/>
    <id>http://linyishui.top/2020030201.html</id>
    <published>2020-04-08T01:34:54.000Z</published>
    <updated>2020-04-21T09:36:39.348Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-API介绍"><a href="#第二章-API介绍" class="headerlink" title="第二章 API介绍"></a><strong>第二章 API介绍</strong></h1><h2 id="2-1-准备"><a href="#2-1-准备" class="headerlink" title="2.1 准备"></a><strong>2.1 准备</strong></h2><p>&emsp;&emsp;首先了解一些通用的Redis全局命令、数据结构和内部编码、单线程命令处理机制。</p><h3 id="2-1-1-全局命令"><a href="#2-1-1-全局命令" class="headerlink" title="2.1.1 全局命令"></a><strong>2.1.1 全局命令</strong></h3><p>&emsp;&emsp;Redis有5种数据结构，它们是键值对中的值，对于键来说有一些通用的命令。</p><h4 id="1-查看所有键"><a href="#1-查看所有键" class="headerlink" title="1. 查看所有键"></a><strong>1. 查看所有键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set java jedis</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set python redis-py</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">"python"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h4 id="2-键总数"><a href="#2-键总数" class="headerlink" title="2. 键总数"></a><strong>2. 键总数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;dbsize命令会返回当前数据库中键的总数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush mylist a b c d e f g</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; dbsize</span><br><span class="line">(integer) <span class="number">4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;dbsize命令在计算键总数时不会遍历所有键，而是直接获取Redis内置的键总数变量，所有dbsize命令的时间复杂度为O(1)。而keys命令则会遍历所有键，时间复杂度为O(n)，当Redis保存了大量键时，线上环境禁止使用。</p><h4 id="3-检查键是否存在"><a href="#3-检查键是否存在" class="headerlink" title="3. 检查键是否存在"></a><strong>3. 检查键是否存在</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果键存在就返回1，否则返回0。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists not_exist_key</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="4-删除键"><a href="#4-删除键" class="headerlink" title="4. 删除键"></a><strong>4. 删除键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key [key ...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;del是一个通用命令，无论值是什么数据结构类型，del命令都可以将其删除。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists java</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del mylist</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists mylist</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del not_exist_key</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set a</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set c</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del a b c</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="5-键过期"><a href="#5-键过期" class="headerlink" title="5. 键过期"></a><strong>5. 键过期</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis支持对键添加过期时间，当超过过期时间后，会自动删除键。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire hello <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; tll hello</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; tll hello</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; tll hello</span><br><span class="line">(integer) -<span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><blockquote><p>tll命令会返回键的剩余过期时间，返回值有三类：</p><ul><li>大于0的整数：键剩余的过期时间。</li><li>-1：键没设置过期时间。</li><li>-2：键不存在。</li></ul></blockquote><h4 id="6-键的数据结构类型"><a href="#6-键的数据结构类型" class="headerlink" title="6. 键的数据结构类型"></a><strong>6. 键的数据结构类型</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;返回键对应的数据类型。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set a b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; type a</span><br><span class="line">string</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush mylist a b c d e f g</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; type mylist</span><br><span class="line">list</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; type not_exist_key</span><br><span class="line">none</span><br></pre></td></tr></table></figure><h3 id="2-1-2-数据结构和内部编码"><a href="#2-1-2-数据结构和内部编码" class="headerlink" title="2.1.2 数据结构和内部编码"></a><strong>2.1.2 数据结构和内部编码</strong></h3><p>&emsp;&emsp;type命令实际返回的就是当前键的数据结构类型，分别是：string、hash、list、set、zset，这些只是Redis对外的数据结构。实际上每种数据结构都有自己的底层内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码。</p><p>&emsp;&emsp;可以看到每种数据结构都有两种以上的内部编码实现，如list数据结构包含了linked和ziplist两种内部编码。同时有些内部编码，例如ziplist，可以作为多种外部数据结构的内部实现，可以通过object encoding命令查询内部编码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding hello</span><br><span class="line">"embstr"</span><br><span class="line">127.0.0.1:6379&gt; object encoding mylist</span><br><span class="line">"ziplist"</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis这样设计有两个好处：第一，可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令（有点装饰模式的意思）。第二，多种内部编码实现可以在不同的场景下发挥各自的优势，如ziplist比较节省内存，但是在列表元素比较多的情况下性能会有所下降，此时Redis会根据配置选项将列表类型的内部实现转换为linkedlist。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010105.jpg" alt=""></p><h3 id="2-1-3-单线程架构"><a href="#2-1-3-单线程架构" class="headerlink" title="2.1.3 单线程架构"></a><strong>2.1.3 单线程架构</strong></h3><p>&emsp;&emsp;Redis使用单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p><h4 id="1-单线程模型"><a href="#1-单线程模型" class="headerlink" title="1. 单线程模型"></a><strong>1. 单线程模型</strong></h4><p>&emsp;&emsp;首先开启三个redis-cli客户端同时执行命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端1设置一个字符串键值对</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line"><span class="comment"># 客户端2对counter做自增操作</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; incr counter</span><br><span class="line"><span class="comment"># 客户端3对counter做自增操作</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; incr counter</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis客户端和服务端的模型可以简化为图2-3，每次客户端调用都经历了：发送命令、执行命令、返回结果三个过程。Redis是单线程来处理命令的，所以一条命令从客户端到达服务端不会立刻被执行，而是进入一个队列中，然后逐个等待执行。因此上述三个命令的执行顺序并不确定。但一定不会发生并发问题，Redis通过I/O多路复用技术来解决I/O问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010106.jpg" alt=""></p><h4 id="2-为什么单线程可以这么快？"><a href="#2-为什么单线程可以这么快？" class="headerlink" title="2. 为什么单线程可以这么快？"></a><strong>2. 为什么单线程可以这么快？</strong></h4><p>&emsp;&emsp;通常单线程处理能力要比多线程差，而Redis却反常的拥有高性能的单线程模型，主要原因有以下三点：</p><blockquote><ul><li>纯内存访问，基础速度快，响应时间短。</li><li>非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间，如图2-6。</li><li>单线程避免了线程切换和竞态产生的消耗。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010107.jpg" alt=""></p><blockquote><p>单线程模型的优点：</p><ul><li>简化数据结构和算法的实现。</li><li>避免了线程切换和竞态产生的消耗。</li></ul></blockquote><p>&emsp;&emsp;单线程模型有一个弊端是不能出现执行时间过长的命令，否则会导致阻塞，这对于Redis这种高性能的服务是致命的，所以Redis是面向快速执行场景的数据库。</p><hr><h2 id="2-2-字符串"><a href="#2-2-字符串" class="headerlink" title="2.2 字符串"></a><strong>2.2 字符串</strong></h2><p>&emsp;&emsp;所有的键都是字符串类型，其它数据结构类型也是基于字符串类型来构建的。字符串既可以是字符串（当然包括如JSON和XML等）、数字、二进制（图片、音频、视频）等，但最大不能超过512MB。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010108.jpg" alt=""></p><h3 id="2-2-1-命令"><a href="#2-2-1-命令" class="headerlink" title="2.2.1 命令"></a><strong>2.2.1 命令</strong></h3><h4 id="1-设置值"><a href="#1-设置值" class="headerlink" title="(1) 设置值"></a><strong>(1) 设置值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br><span class="line">setex ...</span><br><span class="line">setnx ...</span><br></pre></td></tr></table></figure><blockquote><p>可选参数：</p><ul><li>ex seconds ：为键设置秒级过期时间。</li><li>px milliseconds：为键设置毫秒级过期时间。</li><li>nx：键必须不存在，才可以设置成功，用于添加。</li><li>xx：与nx相反，键必须存在，才可以设置成功，用于更新。</li></ul></blockquote><p>&emsp;&emsp;setnx和setxx在特殊的场景有其用处，比如多个客户端同时进行添加，使用setnx可以保证只有一个客户端能设置成功，算是一种分布式锁的实现方案。</p><h4 id="2-获取值"><a href="#2-获取值" class="headerlink" title="(2) 获取值"></a><strong>(2) 获取值</strong></h4><p>&emsp;&emsp;获取值，值不存在返回nil（空）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><h4 id="3-批量设置值"><a href="#3-批量设置值" class="headerlink" title="(3) 批量设置值"></a><strong>(3) 批量设置值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure><h4 id="4-批量获取值"><a href="#4-批量获取值" class="headerlink" title="(4) 批量获取值"></a><strong>(4) 批量获取值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;批量操作可以提高开发效率。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010109.jpg" alt=""></p><p>&emsp;&emsp;Redis可以支撑起每秒数万次的读写操作，但这是服务端的处理性能，客户端除了命令时间还要加上网络时间，假设网络时间为1毫秒，一次命令时间0.1毫秒，那么执行1000次get所需时间为1100毫秒，而1次mget则只需101毫秒。所以网络往往成为性能的瓶颈，不过要注意过量的批量操作也会导致Redis阻塞或网络拥塞。</p><h4 id="5-计数"><a href="#5-计数" class="headerlink" title="(5) 计数"></a><strong>(5) 计数</strong></h4><p>&emsp;&emsp;计数，对值进行自增操作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure><blockquote><p>返回值：</p><ul><li>值非整数 ：返回错误。</li><li>值为整数：返回自增后结果。</li><li>键不存在：按照值为0自增，返回结果1。</li><li>xx：与nx相反，键必须存在，才可以设置成功，用于更新。</li></ul></blockquote><p>&emsp;&emsp;如下图所示，test本不存在，hello则是非整数键。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010110.png" alt=""></p><p>&emsp;&emsp;除了自增（incr）以外，还有自减（decr）、自增指定数字（incrby）、自减指定数字（decrby）、自增浮点数（incrbyfloat）。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decr <span class="built_in">key</span></span><br><span class="line">incrby <span class="built_in">key</span> increment</span><br><span class="line">decrby <span class="built_in">key</span> decrement</span><br><span class="line">incrbyfloat <span class="built_in">key</span> increment</span><br></pre></td></tr></table></figure><h4 id="6-向字符串尾部追加值"><a href="#6-向字符串尾部追加值" class="headerlink" title="(6) 向字符串尾部追加值"></a><strong>(6) 向字符串尾部追加值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><h4 id="7-获取字符串长度"><a href="#7-获取字符串长度" class="headerlink" title="(7) 获取字符串长度"></a><strong>(7) 获取字符串长度</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><h4 id="8-设置并返回原值"><a href="#8-设置并返回原值" class="headerlink" title="(8) 设置并返回原值"></a><strong>(8) 设置并返回原值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset key value</span><br></pre></td></tr></table></figure><h4 id="9-设置指定位置的字符"><a href="#9-设置指定位置的字符" class="headerlink" title="(9) 设置指定位置的字符"></a><strong>(9) 设置指定位置的字符</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange key offeset value</span><br></pre></td></tr></table></figure><h4 id="10-获取部分字符串"><a href="#10-获取部分字符串" class="headerlink" title="(10) 获取部分字符串"></a><strong>(10) 获取部分字符串</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrange key start <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="11-命令的时间复杂度"><a href="#11-命令的时间复杂度" class="headerlink" title="(11) 命令的时间复杂度"></a><strong>(11) 命令的时间复杂度</strong></h4><p>&emsp;&emsp;下图是字符串类型命令的时间复杂度，以供参考。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010111.jpg" alt=""></p><h3 id="2-2-2-内部编码"><a href="#2-2-2-内部编码" class="headerlink" title="2.2.2 内部编码"></a><strong>2.2.2 内部编码</strong></h3><blockquote><p>字符串内部编码有三种：</p><ul><li>int：8个字节的长整型。</li><li>embstr：小于等于39个字节的字符串。</li><li>raw：大于39个字节的字符串。</li></ul></blockquote><p>&emsp;&emsp;Redis会自动根据当前值的类型和长度决定使用哪种内部编码实现。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出内部编码类型</span></span><br><span class="line">object encoding key</span><br></pre></td></tr></table></figure><h3 id="2-2-3-使用场景"><a href="#2-2-3-使用场景" class="headerlink" title="2.2.3 使用场景"></a><strong>2.2.3 使用场景</strong></h3><h4 id="1-缓存功能"><a href="#1-缓存功能" class="headerlink" title="(1) 缓存功能"></a><strong>(1) 缓存功能</strong></h4><p>&emsp;&emsp;经典的缓存应用场景如图所示，Redis作为缓存层，MySql作为存储层，绝大部分数据都是从缓存中获取。由于Redis具有支撑高并发的特性，所以缓存能起到加速读写和降低后端压力的作用。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010112.jpg" alt=""></p><p>&emsp;&emsp;1) 通过此函数获取用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2) 首先从Redis获取用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义键</span></span><br><span class="line">userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">      <span class="comment">// 从Redis获取值</span></span><br><span class="line">      value = redis.get(userRedisKey);</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">// 将值进行反序列化为UserInfo并返回结果</span></span><br><span class="line">      userInfo = deserialize(value);</span><br><span class="line">      <span class="keyword">return</span> userInfo;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;3) 如果没有从Redis获取到用户信息，则需要从MySql中获取，并将结果写入Redis，并添加1小时过期时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从MySql获取用户信息</span></span><br><span class="line">userInfo = mysql.get(id);</span><br><span class="line">      <span class="comment">// 将userInfo序列化，并存入Redis</span></span><br><span class="line">      redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));</span><br><span class="line">      <span class="comment">// 返回结果</span></span><br><span class="line">      <span class="keyword">return</span> userInfo;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;合并后伪代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">// 定义键</span></span><br><span class="line">userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">       <span class="comment">// 从Redis获取值</span></span><br><span class="line">       value = redis.get(userRedisKey);</span><br><span class="line">       <span class="keyword">if</span> (value != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="comment">// 将值进行反序列化为UserInfo并返回结果</span></span><br><span class="line">       userInfo = deserialize(value);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 从MySql获取用户信息</span></span><br><span class="line">userInfo = mysql.get(id);</span><br><span class="line">       <span class="comment">// 将userInfo序列化，并存入Redis</span></span><br><span class="line">       redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));      </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 返回结果</span></span><br><span class="line">       <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-计数"><a href="#2-计数" class="headerlink" title="(2) 计数"></a><strong>(2) 计数</strong></h4><p>&emsp;&emsp;Redis可以实现快速技术、查询缓存的功能，同时数据可以异步落地到其他数据源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户观看后增加一次视频播放数，当然计数系统还有防作弊、不同维度计数、数据持久化到底层数据源等</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">incrVideoCounter</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">       key = <span class="string">"video:playCount:"</span> + id;</span><br><span class="line">       <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-共享Session"><a href="#3-共享Session" class="headerlink" title="(3) 共享Session"></a><strong>(3) 共享Session</strong></h4><p>&emsp;&emsp;如图所示，一个分布式Web服务将用户的Session信息保存在各自的服务器中，这样会造成一个问题，出于负载均衡的考虑，分布式服务器会将用户的访问均衡到不同的服务器上，用户每刷新一次访问可能会发现要重新登录，这是用户无法容忍的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010113.jpg" alt=""></p><p>&emsp;&emsp;为了解决这个问题，可以使用Redis将Session进行集中管理，如下图所示，这种模式下只要保证Redis是高可用和扩展性的，每次用户更新或查询登录信息都直接从Redis获取。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010114.jpg" alt=""></p><h4 id="4-限速"><a href="#4-限速" class="headerlink" title="(4) 限速"></a><strong>(4) 限速</strong></h4><p>&emsp;&emsp;很多应用出于安全的考虑，会在每次登录时让用户输入手机验证码，以确认是否本人操作。但为了使短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，如图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010115.jpg" alt=""></p><p>&emsp;&emsp;此功能可以通过Redis实现，伪代码如下。当然一些限制IP地址不能短时间多次访问也可以如此实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phoneNum = <span class="string">"138xxxxxxxx"</span>;</span><br><span class="line">key = <span class="string">"shortMsg:limit:"</span> + phoneNum;</span><br><span class="line"><span class="comment">// SET key value EX 60 NX 过期时间60秒+NX只做新增</span></span><br><span class="line">isExists = redis.set(key.1, <span class="string">"EX 60"</span>, <span class="string">"NX"</span>);</span><br><span class="line"><span class="keyword">if</span>(isExists != <span class="keyword">null</span> || redis.incr(key) &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">          <span class="comment">// 通过</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 限速</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-哈希"><a href="#2-3-哈希" class="headerlink" title="2.3 哈希"></a><strong>2.3 哈希</strong></h2><p>&emsp;&emsp;hash，可以叫哈希、字典、关联数组。在Redis中，哈希类型是指键值本身又是一个键值对结构，形如value={ {field1, value1}, … ,{filedN, valueN} }，Redis键值对和哈希类型二者关系如下图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010116.jpg" alt=""></p><h3 id="2-3-1-命令"><a href="#2-3-1-命令" class="headerlink" title="2.3.1 命令"></a><strong>2.3.1 命令</strong></h3><h4 id="1-设置值-1"><a href="#1-设置值-1" class="headerlink" title="(1) 设置值"></a><strong>(1) 设置值</strong></h4><p>&emsp;&emsp;设置值，成功返回1，失败返回0。和set一样hset也有NX版本-hsetnx，作用域由键变为field。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset user:<span class="number">1</span> name tom</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-获取值-1"><a href="#2-获取值-1" class="headerlink" title="(2) 获取值"></a><strong>(2) 获取值</strong></h4><p>&emsp;&emsp;获取值，键或field不存在时返回nil。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hget user:<span class="number">1</span> name</span><br><span class="line"><span class="string">"tom"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hget user:<span class="number">2</span> name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="3-删除一个或多个field"><a href="#3-删除一个或多个field" class="headerlink" title="(3) 删除一个或多个field"></a><strong>(3) 删除一个或多个field</strong></h4><p>&emsp;&emsp;删除一个或多个field，返回结果为成功删除的field个数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field ...]</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hdel user:<span class="number">1</span> name</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hdel user:<span class="number">1</span> age</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="4-计算field的个数"><a href="#4-计算field的个数" class="headerlink" title="(4) 计算field的个数"></a><strong>(4) 计算field的个数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset user:<span class="number">1</span> name tom</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset user:<span class="number">1</span> age <span class="number">23</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset user:<span class="number">1</span> city tianjin</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hlen user:<span class="number">1</span></span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="5-批量设置或获取field-value"><a href="#5-批量设置或获取field-value" class="headerlink" title="(5) 批量设置或获取field-value"></a><strong>(5) 批量设置或获取field-value</strong></h4><p>&emsp;&emsp;批量设置或获取field-value，hmget需要key和多个field，hmset需要key和多对field-value</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field ...]</span><br><span class="line">hmset key field value [field value ...]</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hmset user:<span class="number">1</span> name mike age <span class="number">12</span> city tianjin</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hmget user:<span class="number">1</span> name city</span><br><span class="line"><span class="number">1</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"tianjin"</span></span><br></pre></td></tr></table></figure><h4 id="6-判断field是否存在"><a href="#6-判断field是否存在" class="headerlink" title="(6) 判断field是否存在"></a><strong>(6) 判断field是否存在</strong></h4><p>&emsp;&emsp;判断field是否存在，存在为1，否则为0。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hexists user:<span class="number">1</span> name</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="7-获取所有field"><a href="#7-获取所有field" class="headerlink" title="(7) 获取所有field"></a><strong>(7) 获取所有field</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hkeys user:<span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>) <span class="string">"name"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"age"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"city"</span></span><br></pre></td></tr></table></figure><h4 id="8-获取所有value"><a href="#8-获取所有value" class="headerlink" title="(8) 获取所有value"></a><strong>(8) 获取所有value</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hvalues key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hvalues user:<span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"12"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"tianjin"</span></span><br></pre></td></tr></table></figure><h4 id="9-获取所有的field-value"><a href="#9-获取所有的field-value" class="headerlink" title="(9) 获取所有的field-value"></a><strong>(9) 获取所有的field-value</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hgetall user:<span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>) <span class="string">"name"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"age"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"12"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"city"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"tianjin"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果哈希元素个数较多，可能会阻塞Redis，如果只须获取部分field，可以使用hmget；一定要获取全部field-value可以使用hscan命令，渐进式遍历哈希类型。</p><h4 id="10-field指定数字自增"><a href="#10-field指定数字自增" class="headerlink" title="(10) field指定数字自增"></a><strong>(10) field指定数字自增</strong></h4><p>&emsp;&emsp;同incrby和incrbyfloat一样，指定数字自增，但作用域是field。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field</span><br><span class="line">hincrbyfloat key field</span><br></pre></td></tr></table></figure><h4 id="11-计算value的字符串长度"><a href="#11-计算value的字符串长度" class="headerlink" title="(11) 计算value的字符串长度"></a><strong>(11) 计算value的字符串长度</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hstrlen key field</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hstrlen user:<span class="number">1</span> name</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="12-命令的时间复杂度"><a href="#12-命令的时间复杂度" class="headerlink" title="(12) 命令的时间复杂度"></a><strong>(12) 命令的时间复杂度</strong></h4><p>&emsp;&emsp;下图是哈希类型命令的时间复杂度，以供参考。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010117.jpg" alt=""></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010118.jpg" alt=""></p><h3 id="2-3-2-内部编码"><a href="#2-3-2-内部编码" class="headerlink" title="2.3.2 内部编码"></a><strong>2.3.2 内部编码</strong></h3><blockquote><p>哈希类型的内部编码有两种：</p><ul><li><strong>ziplist</strong>（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认为512个），同时所有值都小于hash-max-ziplist-value配置（默认为6字节）时，Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以相比hashtable会更节省空间。</li><li><strong>hashtable</strong>（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，这种情况ziplist的读写效率会下降，而hashtable读写时间复杂度为O(1)。</li></ul></blockquote><h3 id="2-3-3-使用场景"><a href="#2-3-3-使用场景" class="headerlink" title="2.3.3 使用场景"></a><strong>2.3.3 使用场景</strong></h3><p>&emsp;&emsp;如图所示，为关系型数据库和Redis哈希类型存储用户信息的对比。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010119.jpg" alt=""></p><p>&emsp;&emsp;相比于使用字符串序列化缓存用户信息，哈希类型更为直观，并且在更新操作上更加便捷。可以将每个用户的id定义为键的后缀，多对field-value对应每个用户的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">// 定义键，用户id作为key后缀</span></span><br><span class="line">userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">       <span class="comment">// 从Redis获取值，使用hgetall获取所有用户信息映射关系</span></span><br><span class="line">       userInfoMap = redis.hgetAll(userRedisKey);</span><br><span class="line">       UserInfo userInfo;</span><br><span class="line">       <span class="keyword">if</span> (userInfoMap != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="comment">// 将映射关系转化为UserInfo</span></span><br><span class="line">       userInfo = transferMapToUserInfo(userInfoMap);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 从MySql获取用户信息</span></span><br><span class="line">userInfo = mysql.get(id);</span><br><span class="line">           <span class="comment">// 将UserInfo转换为映射关系并通过hmset保存到Redis</span></span><br><span class="line">       redis.hmset(userRedisKey, transferUserInfoToMap(userInfo));    </span><br><span class="line">       <span class="comment">// 添加过期时间</span></span><br><span class="line">       redis.expire(userRedisKey, <span class="number">3600</span>);      </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 返回结果</span></span><br><span class="line">       <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，哈希类型和关系型数据库的不同：</p><ul><li>哈希类型是稀疏的，而关系型数据库是完全结构化的。比如哈希类型每个键可以有不同的field，而关系型数据库一旦添加新的列，每行都要为其设置值（即使为null）</li><li>关系型数据库可以做复杂的关系查询，而Redis去模拟关系型复杂查询开发比较困难，维护成本很高。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010120.jpg" alt=""></p><p>&emsp;&emsp;目前为止，有三种方法来缓存用户信息，下面分别列出其实现方法和优缺点。</p><h4 id="1-原生字符串类型：每个属性一个键"><a href="#1-原生字符串类型：每个属性一个键" class="headerlink" title="(1) 原生字符串类型：每个属性一个键"></a><strong>(1) 原生字符串类型：每个属性一个键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:<span class="number">1</span>:name tom</span><br><span class="line">set user:<span class="number">1</span>:age <span class="number">23</span></span><br><span class="line">set user:<span class="number">1</span>:city beijing</span><br></pre></td></tr></table></figure><ul><li>优点：简单直观，每个属性都支持更新操作。</li><li>缺点：占用过多的键，内存占用量较大，同时用户信息内聚性比较差，所以此方案一般不会在生产环境使用。</li></ul><h4 id="2-序列化字符串类型：将用户信息序列化后用一个键保存"><a href="#2-序列化字符串类型：将用户信息序列化后用一个键保存" class="headerlink" title="(2) 序列化字符串类型：将用户信息序列化后用一个键保存"></a><strong>(2) 序列化字符串类型：将用户信息序列化后用一个键保存</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:<span class="number">1</span>: serialize(userInfo)</span><br></pre></td></tr></table></figure><ul><li>优点：简化编程，如果合理使用序列化可以提高内存的使用效率。</li><li>缺点：序列化和反序列化有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。</li></ul><h4 id="3-哈希类型：每个用户属性使用一对field-value，但是只用一个键保存"><a href="#3-哈希类型：每个用户属性使用一对field-value，但是只用一个键保存" class="headerlink" title="(3) 哈希类型：每个用户属性使用一对field-value，但是只用一个键保存"></a><strong>(3) 哈希类型：每个用户属性使用一对field-value，但是只用一个键保存</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:<span class="number">1</span>:name tom age <span class="number">23</span> city beijing</span><br></pre></td></tr></table></figure><ul><li>优点：简单直观，如果合理使用可以减少内存空间的使用。</li><li>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</li></ul><hr><h2 id="2-4-列表"><a href="#2-4-列表" class="headerlink" title="2.4 列表"></a><strong>2.4 列表</strong></h2><p>&emsp;&emsp;列表类型（list）用来存储多个有序的字符串。如图所示，5个元素从左到右组成了一个<strong>有序</strong>的列表，每个字符串即元素（element），一个列表最多可存储<strong>2^32-1</strong>个元素。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010121.jpg" alt=""></p><p>&emsp;&emsp;在Redis中，可以对列表两端<strong>插入</strong>（push）和<strong>弹出</strong>（pop），还可以<strong>获取指定范围的元素列表</strong>、<strong>获取指定索引下标的元素</strong>等。总的来说，列表是一种比较灵活的数据结构，可以充当<strong>栈</strong>和<strong>队列</strong>的角色。</p><blockquote><p>列表类型有两个特点：</p><ul><li><strong>元素有序</strong>，意味着可以通过索引下标获取某个元素或某个范围内元素列表。</li><li><strong>元素可重复</strong>。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010122.jpg" alt=""></p><h3 id="2-4-1-命令"><a href="#2-4-1-命令" class="headerlink" title="2.4.1 命令"></a><strong>2.4.1 命令</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010123.jpg" alt=""></p><h4 id="1-添加操作"><a href="#1-添加操作" class="headerlink" title="(1) 添加操作"></a><strong>(1) 添加操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从右边插入元素</span></span><br><span class="line">rpush key value [value ...]</span><br><span class="line"><span class="comment"># 从左边插入元素</span></span><br><span class="line">lpush key value [value ...]</span><br><span class="line"><span class="comment"># 向某个元素前或后插入元素</span></span><br><span class="line">linsert key before|after pivot value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush listkey c b a</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="comment"># lrange key 0 -1从左到右获取列表所有元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; linsert listkey before b java</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><h4 id="2-查找操作"><a href="#2-查找操作" class="headerlink" title="(2) 查找操作"></a><strong>(2) 查找操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取指定范围内的元素列表</span></span><br><span class="line">lrange key start <span class="keyword">end</span></span><br><span class="line"><span class="comment"># 获取列表指定索引下标的元素</span></span><br><span class="line">lindex key index</span><br><span class="line"><span class="comment"># 获取列表长度</span></span><br><span class="line">llen key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lindex listkey -<span class="number">1</span></span><br><span class="line"><span class="string">"a"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; llen listkey</span><br><span class="line">(integer) <span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>索引下标有两个特点：</p><ul><li>索引下标从左到右分别是0到N-1，从右到左分别是-1到-N。</li><li>lrange中的end选项包含了自身，不同于大部分编程语言不包含end。</li></ul></blockquote><h4 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="(3) 删除操作"></a><strong>(3) 删除操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从列表左侧弹出元素</span></span><br><span class="line">lpop key</span><br><span class="line"><span class="comment"># 从列表右侧弹出元素</span></span><br><span class="line">rpop key</span><br><span class="line"><span class="comment"># 删除指定元素</span></span><br><span class="line">lrem key count value</span><br><span class="line"><span class="comment"># 按照索引范围修剪列表</span></span><br><span class="line">ltrim key start <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop listkey</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="comment"># 先从左插入4个a，再删除从左开始4个a元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrem listkey <span class="number">4</span> a</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"a"</span></span><br><span class="line"><span class="comment"># 只保留第2到第4个元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ltrim listkey <span class="number">1</span> <span class="number">3</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><blockquote><p>count情况包括三种：</p><ul><li><strong>count&gt;0</strong>：从左到右，删除最多count个元素。</li><li><strong>count&lt;0</strong>：从右到左，删除最多count绝对值个元素。</li><li><strong>count=0</strong>：删除所有。</li></ul></blockquote><h4 id="4-修改操作"><a href="#4-修改操作" class="headerlink" title="(4) 修改操作"></a><strong>(4) 修改操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第3个元素为python</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lset listkey <span class="number">2</span> python</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"python"</span></span><br></pre></td></tr></table></figure><h4 id="5-阻塞操作"><a href="#5-阻塞操作" class="headerlink" title="(5) 阻塞操作"></a><strong>(5) 阻塞操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ...] timeout</span><br><span class="line">brpop key [key ...] timeout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.列表为空：timeout=3，客户端等待3秒才能返回，timeout=0，客户端一直阻塞。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:test <span class="number">3</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line">...阻塞...</span><br><span class="line"><span class="comment"># 如果期间添加了数据element1，客户端立即返回。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:test <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"list:test"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"element1"</span></span><br><span class="line">(<span class="number">2.06</span>s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.列表不为空：客户端立即返回。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"list:test"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"element1"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;blpop/brpop是lpop和rpop的阻塞版本，除了弹出方向不同，使用方法基本相同。</p><blockquote><p>使用brpop时需要注意两点：</p><ul><li><p>如果是多个键，brpop会从左到右遍历键，一旦有一个可以弹出元素，客户端立即返回。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:<span class="number">1</span> list:<span class="number">2</span> list:<span class="number">3</span> <span class="number">0</span></span><br><span class="line">&gt;   ..阻塞..</span><br><span class="line">&gt;   <span class="comment"># 另一个客户端同时分别插入元素</span></span><br><span class="line">&gt;   client-lpush&gt; lpush list:<span class="number">2</span> element2</span><br><span class="line">&gt;   (integer) <span class="number">1</span></span><br><span class="line">&gt;   client-lpush&gt; lpush list:<span class="number">3</span> element3</span><br><span class="line">&gt;   (integer) <span class="number">1</span></span><br><span class="line">&gt;   <span class="comment"># 客户端立即返回list:2中的element2，因为其最先有可以弹出的元素</span></span><br><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:<span class="number">1</span> list:<span class="number">2</span> list:<span class="number">3</span> <span class="number">0</span></span><br><span class="line">&gt;   <span class="number">1</span>) <span class="string">"list:2"</span></span><br><span class="line">&gt;   <span class="number">2</span>) <span class="string">"element2_1"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>如果多个客户端对同一个键执行brpop，最先执行brpop命令的客户端可以获取到弹出的值。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment"># 客户端1</span></span><br><span class="line">&gt;   client-<span class="number">1</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line">&gt;   ..阻塞..</span><br><span class="line">&gt;   <span class="comment"># 客户端2</span></span><br><span class="line">&gt;   client-<span class="number">2</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line">&gt;   ..阻塞..</span><br><span class="line">&gt;   <span class="comment"># 客户端3</span></span><br><span class="line">&gt;   client-<span class="number">3</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line">&gt;   ..阻塞..</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="comment"># 此时另一个客户端lpush一个元素到list:test列表中</span></span><br><span class="line">&gt;   client-lpush&gt; lpush list:test element</span><br><span class="line">&gt;   (integer) <span class="number">1</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="comment"># 客户端1会获取到元素，因为其最先执行brpop，客户端2和3会继续阻塞</span></span><br><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:<span class="number">1</span> list:<span class="number">2</span> list:<span class="number">3</span> <span class="number">0</span></span><br><span class="line">&gt;   <span class="number">1</span>) <span class="string">"list:test"</span></span><br><span class="line">&gt;   <span class="number">2</span>) <span class="string">"element"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010124.jpg" alt=""></p><h3 id="2-4-2-内部编码"><a href="#2-4-2-内部编码" class="headerlink" title="2.4.2 内部编码"></a><strong>2.4.2 内部编码</strong></h3><blockquote><p>列表类型的内部编码有两种：</p><ul><li><strong>ziplist</strong>：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li><li><strong>linkedlist</strong>（链表）：当列表类型无法满足ziplist的条件时，Redis会使用链表实现。</li></ul></blockquote><p>&emsp;&emsp;Redis 3.2版本提供了quicklist的内部编码，其结合了ziplist和linkedlist的优势，是一种更优秀的内部编码实现。</p><h3 id="2-4-3-使用场景"><a href="#2-4-3-使用场景" class="headerlink" title="2.4.3 使用场景"></a><strong>2.4.3 使用场景</strong></h3><h4 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="(1) 消息队列"></a><strong>(1) 消息队列</strong></h4><p>&emsp;&emsp;如下图所示，Redis的lpush+brpop命令组合即可实现<strong>阻塞队列</strong>，生产者客户端使用lpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010125.jpg" alt=""></p><h4 id="2-文章列表"><a href="#2-文章列表" class="headerlink" title="(2) 文章列表"></a><strong>(2) 文章列表</strong></h4><p>&emsp;&emsp;每个用户都有属于自己的文章列表，现需要分页展示文章列表。这种情况可以考虑列表，因为列表不但是有序的，同时支持按照索引范围获取元素。</p><blockquote><ol><li><p>每篇文章饰演哈希结构存储，例如每篇文章有三个属性：title、timestamp和content。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    hmset article:1 title xx timestamp 1476536196 content xxxx</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    hmset article:k title yy timestamp 1476512536 content yyyy</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>向用户文章列表添加文章，user:{id}:articles作为用户文章列表的键。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    lpush user:1:articles article:1 article:3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    lpush user:k:articles article:5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>分页获取用户文章列表，例如下面伪代码获取用户id=1的前10篇文章。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    articles = <span class="keyword">lrange</span> user:<span class="number">1</span>:articles <span class="number">0</span> <span class="number">9</span></span><br><span class="line">&gt;    <span class="keyword">for</span> article in &#123;articles&#125;</span><br><span class="line">&gt;    hgetall &#123;article&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p> 使用列表类型来保存和获取文章列表会存在两个问题：</p><ul><li>如果每次分页获取的文章个数较多，需要执行多次hgetall操作，此时可以考虑使用<strong>Pipeline</strong>批量获取，或者考虑将文章数据<strong>序列化为字符串类型</strong>，<strong>使用mget批量获取</strong>。</li><li>分页获取文章列表时，lrange命令在列表两端性能较好，但如果列表较大，获取列表中间范围的元素性能会变差，此时可以考虑将列表做<strong>二级拆分</strong>，或使用Redis 3.2的<strong>quicklist</strong>内部编码实现，获取中间的元素也可以高效完成。</li></ul></blockquote><blockquote><p> 使用列表时可以参考如下口诀：</p><ul><li>lpush + lpop = Stack（栈）</li><li>lpush + rpop = Queue（队列）</li><li>lpush + ltrim = Capped Collection（有限集合）</li><li>lpush + brpop = Message Queue（消息队列）</li></ul></blockquote><hr><h2 id="2-5-集合"><a href="#2-5-集合" class="headerlink" title="2.5 集合"></a><strong>2.5 集合</strong></h2><p>&emsp;&emsp;集合（set）类型也是用来保存多个字符串元素，但和列表不同的是，集合<strong>不允许有重复</strong>元素，且集合中的元素是<strong>无序</strong>的，不能通过索引下标获取元素。Redis除了支持集合内的增删改查，还支持了多个集合取交集、并集、差集。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010126.jpg" alt=""></p><h3 id="2-5-1-命令"><a href="#2-5-1-命令" class="headerlink" title="2.5.1 命令"></a><strong>2.5.1 命令</strong></h3><p>&emsp;&emsp;1到7为集合内操作，8到11为集合间操作。</p><h4 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="(1) 添加元素"></a><strong>(1) 添加元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果为成功个数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists myset</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd myset a b c</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd myset a b</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="(2) 删除元素"></a><strong>(2) 删除元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">srem key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果为成功个数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srem myset a b</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd myset hello</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="3-计算元素个数"><a href="#3-计算元素个数" class="headerlink" title="(3) 计算元素个数"></a><strong>(3) 计算元素个数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br><span class="line"></span><br><span class="line"><span class="comment"># scard时间复杂度为O(1)，不会遍历集合，而是直接用Redis内部的变量（类似类中的计数器属性）</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scard myset</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="4-判断元素是否在集合中"><a href="#4-判断元素是否在集合中" class="headerlink" title="(4) 判断元素是否在集合中"></a><strong>(4) 判断元素是否在集合中</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sismember key element</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果给定元素element在集合中就返回1，否则返回0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srem myset c</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="5-随机从集合返回指定个数元素"><a href="#5-随机从集合返回指定个数元素" class="headerlink" title="(5) 随机从集合返回指定个数元素"></a><strong>(5) 随机从集合返回指定个数元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># count是可选参数，默认为1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srandmember myset <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srandmember myset</span><br><span class="line"><span class="string">"d"</span></span><br></pre></td></tr></table></figure><h4 id="6-从集合随机弹出元素"><a href="#6-从集合随机弹出元素" class="headerlink" title="(6) 从集合随机弹出元素"></a><strong>(6) 从集合随机弹出元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spop key</span><br><span class="line"></span><br><span class="line"><span class="comment"># spop操作可以从集合随机弹出一个元素，如下一次pop后，元素变为(d, b, a)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; spop myset</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis 3.2版本后，spop也支持[count]参数。srandmember和spop都是随机选出元素，只不过spop会同时删掉此元素。</p><h4 id="7-获取所有元素"><a href="#7-获取所有元素" class="headerlink" title="(7) 获取所有元素"></a><strong>(7) 获取所有元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果是无序的</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;smembers和lrange、hgetall一样，都属于比较<strong>重</strong>的命令，如果元素过多就存在阻塞Redis的可能，可以通过<strong>sscan</strong>来代替。</p><h4 id="8-求多个集合的交集"><a href="#8-求多个集合的交集" class="headerlink" title="(8) 求多个集合的交集"></a><strong>(8) 求多个集合的交集</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增两个集合</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd user:<span class="number">1</span>:follow it music his sports</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd user:<span class="number">2</span>:follow it news ent sports</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 获取交集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinter user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow</span><br><span class="line"><span class="number">1</span>) <span class="string">"sports"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"it"</span></span><br></pre></td></tr></table></figure><h4 id="9-求多个集合的并集"><a href="#9-求多个集合的并集" class="headerlink" title="(9) 求多个集合的并集"></a><strong>(9) 求多个集合的并集</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sunion key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取并集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sunion user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow</span><br><span class="line"><span class="number">1</span>) <span class="string">"sports"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"it"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"his"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"news"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"music"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"ent"</span></span><br></pre></td></tr></table></figure><h4 id="10-求多个集合的差集"><a href="#10-求多个集合的差集" class="headerlink" title="(10) 求多个集合的差集"></a><strong>(10) 求多个集合的差集</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sdiff key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取差集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinter user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow</span><br><span class="line"><span class="number">1</span>) <span class="string">"music"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"his"</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010127.jpg" alt=""></p><h4 id="11-将交集、并集、差集的结果保存"><a href="#11-将交集、并集、差集的结果保存" class="headerlink" title="(11) 将交集、并集、差集的结果保存"></a><strong>(11) 将交集、并集、差集的结果保存</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [key ...]</span><br><span class="line">sunionstore destination key [key ...]</span><br><span class="line">sdiffstore destination key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合间的运算在元素较多时会比较耗时，可以通过上述三个命令将结果保存在destination key中。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinterstore user:<span class="number">1</span>_2:inter user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; type user:<span class="number">1</span>_2:inter</span><br><span class="line">set</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers user:<span class="number">1</span>_2:inter</span><br><span class="line"><span class="number">1</span>) <span class="string">"it"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"sports"</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010128.jpg" alt=""></p><h3 id="2-5-2-内部编码"><a href="#2-5-2-内部编码" class="headerlink" title="2.5.2 内部编码"></a><strong>2.5.2 内部编码</strong></h3><blockquote><p>集合类型的内部编码有两种：</p><ul><li><strong>intset</strong>（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis会选用intset来作为集合内部实现，从而减少内存的使用。</li><li><strong>hashtable</strong>（哈希表）：集合无法满足intset的条件时，选用hashtable作为集合内部实现。</li></ul></blockquote><h3 id="2-5-3-使用场景"><a href="#2-5-3-使用场景" class="headerlink" title="2.5.3 使用场景"></a><strong>2.5.3 使用场景</strong></h3><p>&emsp;&emsp;集合类型比较典型的使用场景是<strong>标签</strong>。</p><p>&emsp;&emsp;例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就可以是标签。有了这些用户数据，就可以从这个维度得到兴趣相投的用户，以及共同喜欢的标签等，这些对于提高用户体验以及增强用户粘度比较重要。</p><h4 id="1-给用户添加标签"><a href="#1-给用户添加标签" class="headerlink" title="(1) 给用户添加标签"></a><strong>(1) 给用户添加标签</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd user:<span class="number">1</span>:tags tag1 tag2 tag5</span><br><span class="line">sadd user:<span class="number">2</span>:tags tag2 tag3 tag5</span><br><span class="line">...</span><br><span class="line">sadd user:k:tags tag1 tag2 tag4</span><br></pre></td></tr></table></figure><h4 id="2-给标签添加用户"><a href="#2-给标签添加用户" class="headerlink" title="(2) 给标签添加用户"></a><strong>(2) 给标签添加用户</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd tag1:users user:<span class="number">1</span> user:<span class="number">3</span></span><br><span class="line">sadd tag2:users user:<span class="number">1</span> user:<span class="number">2</span> user:<span class="number">3</span></span><br><span class="line">...</span><br><span class="line">sadd tagk:users user:<span class="number">1</span> user:<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="3-删除用户下的标签"><a href="#3-删除用户下的标签" class="headerlink" title="(3) 删除用户下的标签"></a><strong>(3) 删除用户下的标签</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srem user:<span class="number">1</span>:tags tag1 tag5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="4-删除标签下的用户"><a href="#4-删除标签下的用户" class="headerlink" title="(4) 删除标签下的用户"></a><strong>(4) 删除标签下的用户</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srem tag1:users user:<span class="number">1</span></span><br><span class="line">srem tag5:users user:<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;3和4都是尽量放在一个事务下执行。</p><h4 id="5-计算用户共同感兴趣的标签"><a href="#5-计算用户共同感兴趣的标签" class="headerlink" title="(5) 计算用户共同感兴趣的标签"></a><strong>(5) 计算用户共同感兴趣的标签</strong></h4><p>&emsp;&emsp;可以通过sinter命令，来计算用户共同感兴趣的标签。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sinter user:<span class="number">1</span>:tags user:<span class="number">2</span>:tags</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述只是一种简单的标签，实际应用上可能会复杂很多。</p><blockquote><p> 集合类型一般有这几种应用场景：</p><ul><li>sadd = Tagging（标签）</li><li>spop/srandmember = Random item（队列）</li><li>sadd + sinter = Social Graph（社交需求）</li></ul></blockquote><hr><h2 id="2-6-有序集合"><a href="#2-6-有序集合" class="headerlink" title="2.6 有序集合"></a><strong>2.6 有序集合</strong></h2><p>&emsp;&emsp;有序集合，保留了<strong>元素不能重复</strong>的特性，但元素可以<strong>排序</strong>。和列表使用<strong>索引下标</strong>作为排序依据不同的是，有序集合通过给每个元素设置一个<strong>分数</strong>（score）作为排序依据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010129.jpg" alt=""></p><p>&emsp;&emsp;下图给出了列表、集合、有序集合的异同点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010130.jpg" alt=""></p><h3 id="2-6-1-命令"><a href="#2-6-1-命令" class="headerlink" title="2.6.1 命令"></a><strong>2.6.1 命令</strong></h3><p>&emsp;&emsp;1到11为集合内操作，12到13为集合间操作。</p><h4 id="1-添加成员"><a href="#1-添加成员" class="headerlink" title="(1) 添加成员"></a><strong>(1) 添加成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zadd key store member [store member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有序集合user:ranking中添加用户tom和分数251，返回表示成功个数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd user:ranking <span class="number">251</span> tom</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><blockquote><p> Redis 3.2版本为zadd命令添加了nx、xx、ch、incr四个选项：</p><ul><li><strong>nx</strong>：member必须不存在，才可以设置成功，用于添加。</li><li><strong>xx</strong>：member必须存在，才可以设置成功，用于更新。</li><li><strong>ch</strong>：返回此次操作后，有序集合元素和分数变化的个数。</li><li><strong>incr</strong>：对score做增加，相当于后面介绍的zincrby。</li></ul></blockquote><p>&emsp;&emsp;有序集合相比集合提供了排序字段，但是也产生了代价，zadd的时间复杂度为O(log(n))，sadd的时间复杂度为O(1)。</p><h4 id="2-计算成员个数"><a href="#2-计算成员个数" class="headerlink" title="(2) 计算成员个数"></a><strong>(2) 计算成员个数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br><span class="line"></span><br><span class="line"><span class="comment"># zcard和scard一样，时间复杂度为O(1)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcard user:ranking</span><br><span class="line">(integer) <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="3-计算某个成员分数"><a href="#3-计算某个成员分数" class="headerlink" title="(3) 计算某个成员分数"></a><strong>(3) 计算某个成员分数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存在返回分数，不存在返回nil</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zscore user:ranking tom</span><br><span class="line"><span class="string">"251"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zscore user:ranking test</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="4-计算成员的排名"><a href="#4-计算成员的排名" class="headerlink" title="(4) 计算成员的排名"></a><strong>(4) 计算成员的排名</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br><span class="line">zrevrank key member</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrank是分数从低到高返回排名，zrevrank则相反</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrank user:ranking tom</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrank user:ranking tom</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="5-删除成员"><a href="#5-删除成员" class="headerlink" title="(5) 删除成员"></a><strong>(5) 删除成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除集合中元素，返回表示成功个数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrem user:ranking mike</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="6-增加成员的分数"><a href="#6-增加成员的分数" class="headerlink" title="(6) 增加成员的分数"></a><strong>(6) 增加成员的分数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zincrby user:ranking <span class="number">9</span> tom</span><br><span class="line"><span class="string">"260"</span></span><br></pre></td></tr></table></figure><h4 id="7-返回指定排名范围内的成员"><a href="#7-返回指定排名范围内的成员" class="headerlink" title="(7) 返回指定排名范围内的成员"></a><strong>(7) 返回指定排名范围内的成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">zrange key start <span class="keyword">end</span> [withscores]</span><br><span class="line">zrevrange key start <span class="keyword">end</span> [withscores]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有序集合是按照分值排名的，zrange是从低到高返回，zrevrange则相反，withscores选项会同时返回分数。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange user:ranking <span class="number">0</span> <span class="number">2</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"kris"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"frank"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"200"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrange user:ranking <span class="number">0</span> <span class="number">2</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"260"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"250"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"220"</span></span><br></pre></td></tr></table></figure><h4 id="8-返回指定分数范围内的成员"><a href="#8-返回指定分数范围内的成员" class="headerlink" title="(8) 返回指定分数范围内的成员"></a><strong>(8) 返回指定分数范围内的成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [withscores] [limit offset count]</span><br><span class="line">zrevrangebyscore key min max [withscores] [limit offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrangebyscore按照分值从低到高返回，zrevrangebyscore则相反，withscores选项会同时返回分数，[limit offset count]可以限制输出的起始位置和个数。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrangebyscore user:ranking <span class="number">200</span> <span class="number">221</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"frank"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"200"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrangebyscore user:ranking <span class="number">200</span> <span class="number">221</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"frank"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"200"</span></span><br><span class="line"><span class="comment"># min和max还支持开区间（小括号）和闭区间（中括号），-inf和+inf分别代表无限小和无限大</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrangebyscore user:ranking (<span class="number">200</span> +inf withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"250"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"260"</span></span><br></pre></td></tr></table></figure><h4 id="9-返回指定分数范围内的成员个数"><a href="#9-返回指定分数范围内的成员个数" class="headerlink" title="(9) 返回指定分数范围内的成员个数"></a><strong>(9) 返回指定分数范围内的成员个数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcount user:ranking <span class="number">221</span> <span class="number">200</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="10-删除指定排名内的升序元素"><a href="#10-删除指定排名内的升序元素" class="headerlink" title="(10) 删除指定排名内的升序元素"></a><strong>(10) 删除指定排名内的升序元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zremrangebyrank user:ranking <span class="number">0</span> <span class="number">2</span></span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="11-删除指定分数范围内的成员"><a href="#11-删除指定分数范围内的成员" class="headerlink" title="(11) 删除指定分数范围内的成员"></a><strong>(11) 删除指定分数范围内的成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zremrangebyscore user:ranking (<span class="number">250</span> +inf</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="12-交集"><a href="#12-交集" class="headerlink" title="(12) 交集"></a><strong>(12) 交集</strong></h4><blockquote><ul><li><strong>destination</strong>：交集计算结果保存到这个键。</li><li><strong>numkeys</strong>：需要做交集计算键的个数。</li><li><strong>key [key …]</strong>：需要做交集计算的键。</li><li><strong>weights weight [weight …]</strong>：每个键的权重，在做交集计算时，每个键中的每个member会将自己的分数乘以这个权重，默认为1。</li><li><strong>aggregate sum|min|max</strong>：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认为sum。</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;添加如图所示两个集合。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010131.jpg" alt=""></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd user:ranking:<span class="number">1</span> <span class="number">1</span> kris <span class="number">91</span> mike <span class="number">200</span> frank <span class="number">220</span> tim <span class="number">250</span> martin <span class="number">251</span> tom</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd user:ranking:<span class="number">2</span> <span class="number">8</span> james <span class="number">77</span> mike <span class="number">625</span> martin <span class="number">888</span> tom</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求两个集合的交集，weights和aggregate取默认值，分值做了sum操作</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zinterstore user:ranking:<span class="number">1</span>_inter_2 <span class="number">2</span> user:ranking:<span class="number">1</span> user:ranking:<span class="number">2</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange user:ranking:<span class="number">1</span>_inter_2 <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"168"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"875"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"1139"</span></span><br><span class="line"><span class="comment"># 配置权重，使集合2权重为集合1一半，并使聚合效果变为max</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zinterstore user:ranking:<span class="number">1</span>_inter_2 <span class="number">2</span> user:ranking:<span class="number">1</span> user:ranking:<span class="number">2</span> weights <span class="number">1</span> <span class="number">0.5</span> aggregate max</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange user:ranking:<span class="number">1</span>_inter_2 <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"91"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"312.5"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"444"</span></span><br></pre></td></tr></table></figure><h4 id="13-并集"><a href="#13-并集" class="headerlink" title="(13) 并集"></a><strong>(13) 并集</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zunionstore user:ranking:<span class="number">1</span>_union_2 <span class="number">2</span> user:ranking:<span class="number">1</span> user:ranking:<span class="number">2</span></span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange user:ranking:<span class="number">1</span>_inter_2 <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"kris"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"james"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"8"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"168"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"frank"</span></span><br><span class="line"><span class="number">8</span>) <span class="string">"200"</span></span><br><span class="line"><span class="number">9</span>) <span class="string">"tim"</span></span><br><span class="line"><span class="number">10</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">11</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">12</span>) <span class="string">"875"</span></span><br><span class="line"><span class="number">13</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">14</span>) <span class="string">"1139"</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010132.jpg" alt=""></p><h3 id="2-6-2-内部编码"><a href="#2-6-2-内部编码" class="headerlink" title="2.6.2 内部编码"></a><strong>2.6.2 内部编码</strong></h3><blockquote><p>有序集合有两种内部编码：</p><ul><li><strong>ziplist</strong>（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时列表中每个元素的值都小于zset-max-ziplist-value配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li><li><strong>skiplist</strong>（跳跃表）：当无法满足ziplist的条件时，Redis选用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li></ul></blockquote><h3 id="2-6-3-使用场景"><a href="#2-6-3-使用场景" class="headerlink" title="2.6.3 使用场景"></a><strong>2.6.3 使用场景</strong></h3><p>&emsp;&emsp;有序集合比较常见的使用场景是<strong>排行榜系统</strong>。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能有多方面：时间、播放数量、获得的赞数。我们试着实现一个简单的赞数的维度。</p><h4 id="1-添加用户赞数"><a href="#1-添加用户赞数" class="headerlink" title="(1) 添加用户赞数"></a><strong>(1) 添加用户赞数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户mike上传了一个视频，并获得了3个赞</span></span><br><span class="line">zadd user:ranking:<span class="number">2016</span>_03_15 <span class="number">3</span> mike</span><br><span class="line"><span class="comment"># 又获得了一个赞</span></span><br><span class="line">zincrby user:ranking:<span class="number">2016</span>_03_15 <span class="number">1</span> mike</span><br></pre></td></tr></table></figure><h4 id="2-取消用户赞数"><a href="#2-取消用户赞数" class="headerlink" title="(2) 取消用户赞数"></a><strong>(2) 取消用户赞数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为如用户注销或用户作弊等原因需要将用户以及获得赞数删除</span></span><br><span class="line">zrem user:ranking:<span class="number">2016</span>_03_15 mike</span><br></pre></td></tr></table></figure><h4 id="3-展示获取赞数最多的十个用户"><a href="#3-展示获取赞数最多的十个用户" class="headerlink" title="(3) 展示获取赞数最多的十个用户"></a><strong>(3) 展示获取赞数最多的十个用户</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrangebyrank user:ranking:<span class="number">2016</span>_03_15 <span class="number">0</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="4-展示用户信息以及用户分数"><a href="#4-展示用户信息以及用户分数" class="headerlink" title="(4) 展示用户信息以及用户分数"></a><strong>(4) 展示用户信息以及用户分数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将用户名作为键后缀，将用户信息保存在哈希类型中</span></span><br><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:<span class="number">2016</span>_03_15 mike</span><br><span class="line">zrank user:ranking:<span class="number">2016</span>_03_15 mike</span><br></pre></td></tr></table></figure><hr><h2 id="2-7-键管理"><a href="#2-7-键管理" class="headerlink" title="2.7 键管理"></a><strong>2.7 键管理</strong></h2><p>&emsp;&emsp;从单个键管理、遍历键、数据库管理三个维度来介绍一些通用命令。</p><h3 id="2-7-1-单个键管理"><a href="#2-7-1-单个键管理" class="headerlink" title="2.7.1 单个键管理"></a><strong>2.7.1 单个键管理</strong></h3><h4 id="1-键重命名"><a href="#1-键重命名" class="headerlink" title="(1) 键重命名"></a><strong>(1) 键重命名</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get python</span><br><span class="line"><span class="string">"jedis"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set python jedis</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename python java</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get python</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get java</span><br><span class="line"><span class="string">"jedis"</span></span><br><span class="line"><span class="comment"># 若rename之前，键java就已经存在，那么其值就会被覆盖</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set a b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set c d</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename a c</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get a</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get c</span><br><span class="line"><span class="string">"b"</span></span><br><span class="line"><span class="comment"># 为了防止误操作被强行rename，Redis提供了renamenx命令，确保只有newKey不存在时才能覆盖</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set java jedis</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set python redis-py</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; renamenx python java</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get java</span><br><span class="line"><span class="string">"jedis"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get python</span><br><span class="line"><span class="string">"redis-py"</span></span><br></pre></td></tr></table></figure><blockquote><p>使用重命名命令时需要注意：</p><ul><li><p>由于重命名键期间会执行del命令删除旧的键，如果键对应的值较大，会存在阻塞Redis的可能性。</p></li><li><p>如果rename和renamenx中的key和newkey是相同的，在Redis3.2版本之后和之前结果略有不同。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment"># 3.2</span></span><br><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename key key</span><br><span class="line">&gt;   OK</span><br><span class="line">&gt;   <span class="comment"># 3.2之前</span></span><br><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename key key</span><br><span class="line">&gt;   (error) ERR source and destination objects are the same</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="2-随机返回一个键"><a href="#2-随机返回一个键" class="headerlink" title="(2) 随机返回一个键"></a><strong>(2) 随机返回一个键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">randomkey</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; dbsize</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; randomkey</span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; randomkey</span><br><span class="line"><span class="string">"jedis"</span></span><br></pre></td></tr></table></figure><h4 id="3-键过期"><a href="#3-键过期" class="headerlink" title="(3) 键过期"></a><strong>(3) 键过期</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 键在seconds秒后过期</span></span><br><span class="line">expire key seconds</span><br><span class="line"><span class="comment"># 键在秒级时间戳timestamp后过期</span></span><br><span class="line">expireat key timestamp</span><br><span class="line"><span class="comment"># 键在milliseconds毫秒后过期</span></span><br><span class="line">pexpire key milliseconds</span><br><span class="line"><span class="comment"># 键在毫秒级时间戳timestamp后过期</span></span><br><span class="line">pexpireat key milliseconds-timestamp</span><br><span class="line"><span class="comment"># 查询键的剩余过期时间，返回值（大于等于0:表示剩余时间，-1:键没有设置过期时间，-2:键不存在）</span></span><br><span class="line">ttl key</span><br><span class="line"><span class="comment"># 查询键的剩余过期时间，毫秒级</span></span><br><span class="line">pttl key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire hello <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="comment"># 还剩7秒</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line">...</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="comment"># 返回结果为-2，表示键已被删除</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">(integer) -<span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expireat hello <span class="number">1469980800</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不论是过期时间还是时间戳，秒级还是毫秒级，在Redis内部最终使用的都是pexpireat。</p><blockquote><p>使用过期命令需要注意以下几点：</p><ol><li><p>如果 expire key 的键不存在，返回结果为0。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire not_exist_key <span class="number">30</span></span><br><span class="line">&gt;    (integer) <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>如果过期时间为负值，键会立即被删除，犹如使用del命令一样。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">&gt;    OK</span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire hello -<span class="number">2</span></span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get hello</span><br><span class="line">&gt;    (nil)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>persist命令可以将键的过期时间清除。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset key f1 v1</span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire key <span class="number">50</span></span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl key</span><br><span class="line">&gt;    (integer) <span class="number">46</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; persist key</span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl key</span><br><span class="line">&gt;    (integer) -<span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p><strong>对于字符串类型键，执行set命令会去掉过期时间</strong>，这个问题在开发中很容易被忽视。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="comment">// set命令的函数setKey，可以看到最后执行了removeExpire(db, key)函数去掉了过期时间</span></span><br><span class="line">&gt;    <span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">if</span> (lookupKeyWrite(db, key) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;            dbAdd(db, key, val);</span><br><span class="line">&gt;        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;            dbOverwrite(db, key, val);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        incrRefCount(val);</span><br><span class="line">&gt;        <span class="comment">// 去掉过期时间</span></span><br><span class="line">&gt;        removeExpire(db, key);</span><br><span class="line">&gt;        signalModifiedKey(db, key);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote>   <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire hello <span class="number">50</span></span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">&gt;    (integer) <span class="number">46</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">&gt;    OK</span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">&gt;    (integer) -<span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="5"><li><p>Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素做过期时间设置。</p></li><li><p>setex命令作为set + expire的组合，不但是原子执行，同时减少了一次网络通讯的时间。</p></li></ol></blockquote><h4 id="4-迁移键"><a href="#4-迁移键" class="headerlink" title="(4) 迁移键"></a><strong>(4) 迁移键</strong></h4><p>&emsp;&emsp;有时我们会想把部分数据由一个Redis转移到另一个Redis，Redis发展历程中提供了move、restore、migrate三组迁移键的方法。</p><h4 id="1-move"><a href="#1-move" class="headerlink" title="1) move"></a><strong>1) move</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;move指令用于Redis内部进行数据迁移，Redis内部可以有多个数据库，彼此数据是隔离的。move指令把指定的键从源数据库移动到目标数据库，但不建议在生产环境使用多数据库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010133.jpg" alt=""></p><h4 id="2-dump-restore"><a href="#2-dump-restore" class="headerlink" title="2) dump+restore"></a><strong>2) dump+restore</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dump key</span><br><span class="line">restore key ttl value</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;dump+restore可以实现在不同的Redis实例之间进行数据迁移的功能。</p><blockquote><p>整个迁移的过程分为两步：</p><ol><li>在源Redis上，dump命令会将键值序列化，格式采用的是RDB格式。</li><li>在目标Redis上，restore命令将上面序列化的值进行复原，其中ttl参数代表过期时间，如果ttl=0代表没有过期时间。</li></ol></blockquote><p>&emsp;&emsp;需要注意两点：第一，整个迁移过程并非原子性的，而是通过客户端分布完成的。第二，迁移过程是开启了两个客户端连接，所以dump的结果不是在源Redis和目标Redis之间进行传输。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010134.jpg" alt=""></p><blockquote><p>演示过程：</p><ol><li><p>在源Redis上执行dump。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    redis-source&gt; set hello world</span><br><span class="line">&gt;    OK</span><br><span class="line">&gt;    redis-source&gt; dump hello</span><br><span class="line">&gt;    <span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>在目标Redis上执行restore。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;    redis-target&gt; get hello</span><br><span class="line">&gt;    (nil)</span><br><span class="line">&gt;    redis-target&gt; restore hello <span class="number">0</span> <span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span><br><span class="line">&gt;    OK</span><br><span class="line">&gt;    redis-target&gt; get hello</span><br><span class="line">&gt;    <span class="string">"world"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>   上面2步对应的伪代码如下。</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    Redis sourceRedis = <span class="keyword">new</span> Redis(<span class="string">"sourceMachine"</span>, <span class="number">6379</span>);</span><br><span class="line">&gt;    Redis targetRedis = <span class="keyword">new</span> Redis(<span class="string">"targetMachine"</span>, <span class="number">6379</span>);</span><br><span class="line">&gt;    targetRedis.restore(<span class="string">"hello"</span>, <span class="number">0</span>, sourceRedis.dump(key));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="3"><li><p>migrate</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    migrate host port key|<span class="string">""</span> destination-db timeout [copy] [replace] [keys key [key ...]]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>   migrate命令也是用于在Redis实例间进行数据迁移的，实际上migrate命令就是将dump、restore、del三个命令进行组合，从而简化了操作流程。migrate命令具有原子性，而且从Redis 3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁移效率，migrate在水平扩容中起到重要作用。</p></blockquote><p>&emsp;&emsp;如图所示，实现过程和dump+restore基本类似，但有三点不同。</p><blockquote><ol><li>整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis上执行migrate命令即可。</li><li>migrate命令的数据传输直接在源Redis和目标Redis上完成的。</li><li>目标Redis完成restore后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否在源Redis上删除对应的键。</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010135.jpg" alt=""></p><blockquote><p>migrate参数说明：</p><ul><li><strong>host</strong>：目标Redis的IP地址。</li><li><strong>port</strong>：目标Redis的端口。</li><li><strong>key|“”</strong>：在Redis 3.0.6版本之前，migrate只支持迁移一个键，所以此处是要迁移的键，但Redis 3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串””。</li><li><strong>destination-db</strong>：目标Redis的数据库索引，例如要迁移到0号数据库，这里就写0。</li><li><strong>timeout</strong>：迁移的超时时间（单位为毫秒）。</li><li><strong>[copy]</strong>：如果添加此选项，迁移后并不删除源键。</li><li><strong>[replace]</strong>：如果添加此选项，migrate不管目标Redis是否存在该键都会正常迁移进行数据覆盖。</li><li><strong>[keys key [key …]]</strong>：迁移多个键。</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源Redis使用6379端口，目标Redis使用6380端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况1：源Redis有键hello，目标Redis没有</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> hello <span class="number">0</span> <span class="number">1000</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 情况2：源Redis和目标Reids都有键hello，需要加replace选项</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get hello</span><br><span class="line"><span class="string">"world"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6380</span>&gt; get hello</span><br><span class="line"><span class="string">"redis"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> hello <span class="number">0</span> <span class="number">1000</span></span><br><span class="line">(error) ERR Target instance replied with error: BUSYKEY Target key name already exists.</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> hello <span class="number">0</span> <span class="number">1000</span> replace</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 情况3：源Redis没有键hello</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> hello <span class="number">0</span> <span class="number">1000</span></span><br><span class="line">NOKEY</span><br></pre></td></tr></table></figure><blockquote><p>Redis 3.0.6版本以后迁移多个键的功能：</p><ul><li><p>源Redis批量添加多个键</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mset key1 value1 key2 value2 key3 value3</span><br><span class="line">&gt;   OK</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>源Redis执行如下命令完成多个键的迁移</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> <span class="string">""</span> <span class="number">0</span> <span class="number">5000</span> keys key1 key2 key3</span><br><span class="line">&gt;   OK</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010136.jpg" alt=""></p><h3 id="2-7-2-遍历键"><a href="#2-7-2-遍历键" class="headerlink" title="2.7.2 遍历键"></a><strong>2.7.2 遍历键</strong></h3><h4 id="1-全量遍历键"><a href="#1-全量遍历键" class="headerlink" title="(1) 全量遍历键"></a><strong>(1) 全量遍历键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; dbsize</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mset hello world redis best jedis best hill high</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 获取所有键</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">"hill"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"jedis"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><blockquote><p>pattern使用glob风格的通配符：</p><ul><li>* ：代表匹配任意字符。</li><li>? ：代表匹配一个字符。 </li><li>[] ：代表匹配部分字符，如[1, 3]代表匹配1和3，[1-10]代表匹配1到10的任意数字。</li><li>\x ：用来做转移，例如要匹配星号、问号需要进行转义。</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys [j,r]edis</span><br><span class="line"><span class="number">1</span>) <span class="string">"jedis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redis"</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys h?ll*</span><br><span class="line"><span class="number">1</span>) <span class="string">"hill"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当需要遍历所有键时（如检测过期或闲置时间、寻找大对象），keys是一个很有帮助的命令，例如想删除所有以video字符串开头的键，可以如下操作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli keys video* | xargs redis-cli del</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但Redis是单线程架构，如果对大量的键执行keys命令很可能会造成Redis阻塞，所以一般不建议在生产环境下使用keys命令。</p><blockquote><p>生产环境下代替方案：</p><ul><li>在一个不对外提供服务的Redis从节点上执行，这样不会阻塞到客户端的请求，但会影响到主从复制。</li><li>如果确认键值总数确实比较少，可以执行此命令。</li><li>使用scan命令渐进式的遍历所有键，可以有效防止阻塞。</li></ul></blockquote><h4 id="2-渐进式遍历"><a href="#2-渐进式遍历" class="headerlink" title="(2) 渐进式遍历"></a><strong>(2) 渐进式遍历</strong></h4><p>&emsp;&emsp;Redis 2.8版本后，提供了一个新的命令<strong>scan</strong>，有效的解决了keys命令存在的问题。<strong>与keys命令遍历所有键的方式不同，scan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题</strong>，scan命令的时间复杂度为O(1)，但要真正的实现keys的功能，需要多次执行scan。Redis存储键值对实际使用的是hashtable的数据结构，简化模型如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010137.jpg" alt=""></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次执行scan，可以想象成只扫描一个字典中的一部分键，知道将字典中的所有键遍历完毕</span></span><br><span class="line">scan cursor [match pattern] [count number]</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>cursor</strong>：必须参数，实际上cursor是一个游标，第一次遍历从0开始，每次scan遍历完都返回当前游标的值，直到游标值为0，表示遍历结束。</li><li><strong>match pattern</strong>：可选参数，它的作用是做模式的匹配，这点和keys的模式匹配很像。</li><li><strong>count number</strong>：可选参数，它的作用是表明每次要遍历的键个数，默认值是10，此参数可以适当增大。</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现有一个Redis有26个键，遍历所有的键，第一次执行返回两个部分，第一部分的6就是下次scan需要的cursor，第二部分是10个键。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scan <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"6"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"w"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"i"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"e"</span></span><br><span class="line">   <span class="number">4</span>) <span class="string">"x"</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">"j"</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">"q"</span></span><br><span class="line">   <span class="number">7</span>) <span class="string">"y"</span></span><br><span class="line">   <span class="number">8</span>) <span class="string">"u"</span></span><br><span class="line">   <span class="number">9</span>) <span class="string">"b"</span></span><br><span class="line">   <span class="number">10</span>) <span class="string">"o"</span></span><br><span class="line"><span class="comment"># 使用新的cursor="6"，执行scan 6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scan <span class="number">6</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"11"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"h"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"n"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"m"</span></span><br><span class="line">   <span class="number">4</span>) <span class="string">"t"</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">"c"</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">"d"</span></span><br><span class="line">   <span class="number">7</span>) <span class="string">"g"</span></span><br><span class="line">   <span class="number">8</span>) <span class="string">"p"</span></span><br><span class="line">   <span class="number">9</span>) <span class="string">"z"</span></span><br><span class="line">   <span class="number">10</span>) <span class="string">"a"</span></span><br><span class="line"><span class="comment"># 这次得到的11，继续执行scan 11得到结果cursor为0，说明所有的键都被遍历过了</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scan <span class="number">11</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"0"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"s"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"f"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"r"</span></span><br><span class="line">   <span class="number">4</span>) <span class="string">"v"</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">"k"</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">"l"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了scan以外，Redis还提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决如hgetall、smembers、zrange可能产生的阻塞问题，对应的命令分别为hscan、sscan、zscan。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前集合有两种类型的元素，分别以old:user和new:user开头</span></span><br><span class="line">String key = <span class="string">"myset"</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">String pattern = <span class="string">"old:user"</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">String cursor = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       ScanResult scanResult = redis.sscan(key, cursor, pattern);</span><br><span class="line">       List elements = scanResult.getResult();</span><br><span class="line">       <span class="keyword">if</span> (elements != <span class="keyword">null</span> &amp;&amp; elements.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           redis.rem(key, elements);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       cursor = scanResult.getStringCursor();</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">"0"</span>.equals(cursor)) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;渐进式遍历可以有效的解决相应命令的阻塞问题，但scan并非完美，如果在遍历的过程中出现键的变化（增删改），遍历效果就可能会遇到：新增的键没被遍历到，遍历出重复的键等情况。即<strong>scan并不能保证完整的遍历出来所有的键</strong>。</p><h3 id="2-7-3-数据库管理"><a href="#2-7-3-数据库管理" class="headerlink" title="2.7.3 数据库管理"></a><strong>2.7.3 数据库管理</strong></h3><h4 id="1-切换数据库"><a href="#1-切换数据库" class="headerlink" title="(1) 切换数据库"></a><strong>(1) 切换数据库</strong></h4><p>&emsp;&emsp;许多关系型数据库支持一个实例下有多个数据库存在，与关系型数据库用字符来区分不同数据库名相比，Redis使用数字作为多个数据库的实现，默认是16个数据库。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select dbIndex</span><br><span class="line">database <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world <span class="comment"># 默认进到0号数据库</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get hello</span><br><span class="line"><span class="string">"world"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; select <span class="number">15</span> <span class="comment"># 切换到15号数据库</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>[<span class="number">15</span>]&gt; get hello <span class="comment"># 数据库间是隔离的</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述过程如图所示，还有当使用 redis-cli -h {ip} -p {port} 链接Redis时，默认也是0号数据库，其他数据库会显示index下标。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010138.jpg" alt=""></p><p>&emsp;&emsp;那么可以像关系型数据库那样，0号数据库作为正式库，1号数据库作为测试库，这样二者的数据也不会互相影响呢？Redis 3.0开始慢慢的在淡化此功能，例如Redis的分布式实现<strong>Redis Cluster只允许使用0号数据库</strong>，只是为了向下兼容老版本才没有完全废弃此功能。</p><blockquote><p>废弃这个功能的原因有三点：</p><ul><li>Redis是单线程的，如果使用多个数据库，这些库仍然只使用一个CPU，还是会影响到彼此的。</li><li>多数据库的使用方式，会让调试和运维不同业务的数据库变得困难。假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定位问题变得困难。</li><li>部分Redis客户端不支持这种方式，即使支持，在开发时来回切换数字形式的数据库也容易混乱。</li></ul></blockquote><p>&emsp;&emsp;所以一般建议在一台机器上部署多个Redis来实现，以端口号来区分，这样既保证了业务之间不会受影响，有利用了多核CPU的资源。</p><h4 id="2-清除数据库"><a href="#2-清除数据库" class="headerlink" title="(2) 清除数据库"></a><strong>(2) 清除数据库</strong></h4><p>&emsp;&emsp;flushdb/flushall命令用于清除数据库，区别是flushdb只清除当前数据库，flushall会清除所有数据库。</p><blockquote><p>flushdb/flushall命令存在的问题：</p><ul><li>flushdb/flushall命令会将所有的数据清除，一旦误操作很难处理。</li><li>如果当前数据库键值比较多，flushdb/flushall命令存在阻塞Redis的可能性。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（二）API介绍，内容包括：准备，字符串，哈希，列表，集合，有序集合，键管理等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建个人博客 (六) 异常解决记录</title>
    <link href="http://linyishui.top/2020040301.html"/>
    <id>http://linyishui.top/2020040301.html</id>
    <published>2020-04-03T02:31:00.000Z</published>
    <updated>2020-04-03T10:24:51.466Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo异常解决记录"><a href="#Hexo异常解决记录" class="headerlink" title="Hexo异常解决记录"></a><strong>Hexo异常解决记录</strong></h1><h2 id="unknown-block-tag-endif"><a href="#unknown-block-tag-endif" class="headerlink" title="unknown block tag: endif"></a><strong>unknown block tag: endif</strong></h2><p>&emsp;&emsp;一次更新博客（hexo g）时，出现以下异常。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010101.png" alt=""></p><p>&emsp;&emsp;google了一下，看到有类似问题的是因为在’{‘和’%’之间多写了空格这种语法错误，所以花了一些时间去找项目中的swig文件，因为刚好这次更新也有增加一些博客功能，怀疑是不是修改swig文件时也写错了。(<a href="https://52heartz.top/articles/hexo-template-render-error/" title="title" target="_blank" rel="noopener">Hexo 的 Template render error 错误</a> 和 <a href="https://github.com/hexojs/hexo/issues/3346" title="title" target="_blank" rel="noopener">hexo 在markdown文档中出现<code>{-% %-}</code>语法会报错，提示“Template render error: (unknown path) </a>)</p><p>&emsp;&emsp;但很快便发现没有找到异常，所以思考了一下，既然代码文件中的endif没有问题，会不会是其他地方也写了endif，突然想到这次提交也更新了MD文件，记录我这次更新，其中也直接记录了{\% endif \%}，所以就修改了相关描述。</p><p>&emsp;&emsp;重试了一下，问题解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://linyishui.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://linyishui.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（一）Redis简介</title>
    <link href="http://linyishui.top/2020030102.html"/>
    <id>http://linyishui.top/2020030102.html</id>
    <published>2020-03-01T07:24:19.000Z</published>
    <updated>2020-04-08T03:57:23.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-Redis简介"><a href="#第一章-Redis简介" class="headerlink" title="第一章 Redis简介"></a><strong>第一章 Redis简介</strong></h1><h2 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1 什么是Redis?"></a><strong>1.1 什么是Redis?</strong></h2><p>&emsp;&emsp;Redis是一种基于<strong>键值对</strong>的NoSQL（非关系型）数据库。与另外一些键值对数据库不同的是，Redis的值可以是：string、hash、list、set、zset（有序集合）、Bitmaps（位图）、HyperLogLog（做基数统计）、GEO（地理信息定位）等多种数据结构和算法。</p><blockquote><p>Redis主要有哪些优势？</p><ul><li>值可以存放多种数据结构和算法，所以可以满足大量的应用场景。</li><li>将数据存放在内存，所以有高效的读写性能。</li><li>内存中的数据通过快照和日志的方式保存在硬盘上，防止丢失。</li></ul></blockquote><p>&emsp;&emsp;Redis的作者本身想通过MySql来实现一个高性能的队列功能，但优化SQL无法提高性能，所以他决定自己开发一款数据库，即Redis。目前大部分国内外知名的互联网企业都在使用Redis，还有一些开源技术如ELK（即Elasticsearch，Logstash 和Kibana，实现集中式日志系统）也把Redis当作组件中的重要一环。</p><hr><h2 id="1-2-Redis特性"><a href="#1-2-Redis特性" class="headerlink" title="1.2 Redis特性"></a><strong>1.2 Redis特性</strong></h2><h3 id="1-2-1-速度快"><a href="#1-2-1-速度快" class="headerlink" title="1.2.1 速度快"></a><strong>1.2.1 速度快</strong></h3><blockquote><p>Redis速度非常快，其高效性能的原因有：</p><ul><li>所有数据都存放在内存。</li><li>使用C语言实现。</li><li>使用单线程架构，避免了多线程竞争问题。</li><li>作者对源码进行了精打细磨，曾被人评价是少有的集性能与优雅于一身的开源代码。</li></ul></blockquote><h3 id="1-2-2-基于键值对的数据结构服务器"><a href="#1-2-2-基于键值对的数据结构服务器" class="headerlink" title="1.2.2 基于键值对的数据结构服务器"></a><strong>1.2.2 基于键值对的数据结构服务器</strong></h3><p>&emsp;&emsp;大部分语言都会提供类似字典的功能，映射这种组织数据的方式叫做<strong>基于键值的方式</strong>，但Redis中的值不仅可以是字符串，还可以是字符串、哈希、列表、集合、有序集合。同时又在字符串的基础上演变出了Bitmaps（位图）、HyperLogLog（做基数统计）两种高级数据结构，并且随着LBS（Location Based Service，基于位置服务）的发展加入了GEO（地理信息定位）功能。</p><h3 id="1-2-3-丰富的功能"><a href="#1-2-3-丰富的功能" class="headerlink" title="1.2.3 丰富的功能"></a><strong>1.2.3 丰富的功能</strong></h3><blockquote><p>Redis还提供许多额外功能：</p><ul><li>提供了键过期功能，可以用来实现缓存。</li><li>提供了发布订阅功能，可以用来实现消息系统。</li><li>支持Lua脚本功能，可以利用Lua创造出新的Redis命令。</li><li>提供了简单的事务功能，能在一定程度上保证事务特性。</li><li>提供了流水线（Pipeline）功能，使客户端能将一批命令一次性传到Redis，减少了网络的开销。</li></ul></blockquote><h3 id="1-2-4-简单稳定"><a href="#1-2-4-简单稳定" class="headerlink" title="1.2.4 简单稳定"></a><strong>1.2.4 简单稳定</strong></h3><p>&emsp;&emsp;Redis的简单主要体现在三个方面：首先是源码很精简，几万行代码，对于大部分使用者来说都是可以去快速阅读一遍的。其次Redis使用单线程模型，不仅使得Redis服务端处理模型变得简单，也使客户端开发变得简单。最后Redis不需要依赖操作系统的类库（如Memcache需要依赖libevent），Redis自己实现了事件处理的相关功能。</p><p>&emsp;&emsp;Redis虽然精简，但非常稳定。</p><h3 id="1-2-5-客户端语言多"><a href="#1-2-5-客户端语言多" class="headerlink" title="1.2.5 客户端语言多"></a><strong>1.2.5 客户端语言多</strong></h3><p>&emsp;&emsp;Redis提供了简单的TCP通信协议，方便编程语言接入Redis，因为主流公司的认可，所以大部分客户端编程语言都支持Redis。</p><h3 id="1-2-6-持久化"><a href="#1-2-6-持久化" class="headerlink" title="1.2.6 持久化"></a><strong>1.2.6 持久化</strong></h3><p>&emsp;&emsp;数据存放在内存一般被认为是不安全的（断电或机器故障导致数据丢失），Redis提供了两种持久化方式：<strong>RDB</strong>和<strong>AOF</strong>。</p><h3 id="1-2-7-主从复制"><a href="#1-2-7-主从复制" class="headerlink" title="1.2.7 主从复制"></a><strong>1.2.7 主从复制</strong></h3><p>&emsp;&emsp;Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式的基础。</p><h3 id="1-2-8-高可用和分布式"><a href="#1-2-8-高可用和分布式" class="headerlink" title="1.2.8 高可用和分布式"></a><strong>1.2.8 高可用和分布式</strong></h3><p>&emsp;&emsp;Redis从2.8版本后提供了高可用实现：Redis Sentinel，能保证Redis节点的故障发现和故障自动转移。</p><p>&emsp;&emsp;3.0版本正式提供了分布式实现：Redis Cluster，提供了高可用、读写和容量的扩展性。</p><hr><h2 id="1-3-Redis使用场景"><a href="#1-3-Redis使用场景" class="headerlink" title="1.3 Redis使用场景"></a><strong>1.3 Redis使用场景</strong></h2><h3 id="1-3-1-Redis可以做什么？"><a href="#1-3-1-Redis可以做什么？" class="headerlink" title="1.3.1 Redis可以做什么？"></a><strong>1.3.1 Redis可以做什么？</strong></h3><blockquote><ol><li><strong>缓存</strong>，常用于大型网站来加速数据访问和缓解后端数据库压力。Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。</li><li><strong>排行榜系统</strong>，几乎所有网站都需要各种规则的排行榜，或是依据热度排行，或是发布时间，或是结合各种复杂维度计算。Redis提供了列表和有序集合数据结构，合理的使用这些结构可以很方便的构建各种排行榜系统。</li><li><strong>计数器应用</strong>，如一些视频网站的播放数，电商网站的浏览数，对于数据的实时性有较高的要求，如果并发量很大时，传统关系型数据库很难做好这一工作。Redis天然支持计数功能，且性能优越。</li><li><strong>社交网络</strong>，比如赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等常见功能，由于社交网站访问量通常较大，且传统关系型数据库不太适合存储这种类型的数据，而Redis提供的数据结构比较容易实现这些功能。</li><li><strong>消息队列系统</strong>，大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列功能，虽然相比专业的消息队列还有所欠缺，但可以满足大部分基础需求。</li></ol></blockquote><h3 id="1-3-2-Redis不可以做什么？"><a href="#1-3-2-Redis不可以做什么？" class="headerlink" title="1.3.2 Redis不可以做什么？"></a><strong>1.3.2 Redis不可以做什么？</strong></h3><p>&emsp;&emsp;正像大部分技术一样，Redis也有其边界。</p><p>&emsp;&emsp;首先站在<strong>数据规模</strong>的角度来看，我们把数据分为大规模数据和小规模数据。因为其存放数据于内存这一设定，在面对海量数据时就是一个性价比极低的选择。</p><p>&emsp;&emsp;然后站在<strong>数据冷热</strong>的角度来看，我们把数据分为热数据和冷数据，热数据指需要频繁操作的数据，冷数据则相反。例如对于视频网站，视频基本信息需要在各个业务线频繁操作，而用户观看记录（不要和观看数混为一谈，此处应该指行为数据）相比就不会那么繁忙，先不讨论两者的规模差异，视频信息属于热数据，用户观看记录属于冷数据。冷数据存放于内存是一种浪费，而热数据可以放在内存中加速读写，也减轻了后端存储的负载压力。</p><hr><h2 id="1-4-如何用好Redis？"><a href="#1-4-如何用好Redis？" class="headerlink" title="1.4 如何用好Redis？"></a><strong>1.4 如何用好Redis？</strong></h2><blockquote><ul><li><strong>不要把Redis当作黑盒使用，开发和运维一样重要</strong>。很多线上故障都是因为开发者把Redis当作黑盒使用而造成的：如果不了解Redis的单线程模型，可能会在有上千万个键的Redis上执行keys *操作；如果不了解持久化相关原理，可能会在一个写操作量很大的Redis上配置自动保存RDB。相比专职的关系型数据库DBA，大部分公司并没有人来专职运维Redis，所以往往需要开发人员来担当这一角色。这一经验对于我们学好Redis也大有帮助。</li><li><strong>阅读源码</strong>。Redis源码量很小，所以请多读Redis源码，不仅可以加深理解，也可以提高自身编程水平，甚至定制化Redis，需要大公司会对Redis进行定制来满足其业务需求。</li></ul></blockquote><hr><h2 id="1-5-安装Redis"><a href="#1-5-安装Redis" class="headerlink" title="1.5 安装Redis"></a><strong>1.5 安装Redis</strong></h2><h3 id="1-5-1-Linux上安装Redis"><a href="#1-5-1-Linux上安装Redis" class="headerlink" title="1.5.1 Linux上安装Redis"></a><strong>1.5.1 Linux上安装Redis</strong></h3><p>&emsp;&emsp;Linux上安装Redis的方式有两种：第一种是通过各个操作系统的软件管理软件进行安装，如CentOS的yum管理工具，Ubuntu的apt（Docker应该也属于第一种吧）。第二种是通过源码的方式安装。</p><p>&emsp;&emsp;Redis更新较快，所以一般推荐第二种安装方式。</p><p>&emsp;&emsp;安装步骤只需要六步即可，如下案例安装3.0.7版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-3.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-3.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s redis-3.0.7 redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>下载指定版本的Redis源码压缩包到当前目录。</li><li>解压缩Redis源码压缩包。</li><li>建立一个redis目录的软连接，指向redis-3.0.7（为了不把redis目录固定在指定版本，有利于未来版本升级，算是一种安装软件的好习惯）。</li><li>进入redis目录。</li><li>编译（编译前确保操作系统已安装gcc）。</li><li>安装（将Redis的相关运行软件放在/usr/local/bin/下，从而可以在任意目录下执行Redis的命令）。</li></ol></blockquote><p>&emsp;&emsp;如下图安装5.0.8版本。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010101.png" alt=""></p><h3 id="1-5-2-Windows上安装Redis"><a href="#1-5-2-Windows上安装Redis" class="headerlink" title="1.5.2 Windows上安装Redis"></a><strong>1.5.2 Windows上安装Redis</strong></h3><p>&emsp;&emsp;Redis官方并不支持Windows操作系统，但微软的开源技术组在GitHub上维护了一个Redis的分支：<a href="https://github.com/microsoftarchive/redis" target="_blank" rel="noopener">microsoftarchive/redis</a>。</p><p>&emsp;&emsp;首先在上述开源项目中找到想要安装的版本并下载：<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a></p><p>&emsp;&emsp;解压并在根目录打开命令行，可以把redis路径添加到环境变量，方便以后使用。</p><h3 id="1-5-3-配置、启动、操作、关闭Redis"><a href="#1-5-3-配置、启动、操作、关闭Redis" class="headerlink" title="1.5.3 配置、启动、操作、关闭Redis"></a><strong>1.5.3 配置、启动、操作、关闭Redis</strong></h3><p>&emsp;&emsp;Redis安装后，src和/usr/local/bin/下会多出几个redis开头的文件，被称作Redis Shell。类似于JDK中的可执行文件，这些文件可以帮助我们做很多事情。</p><table><thead><tr><th style="text-align:left">可执行文件</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">redis-server</td><td style="text-align:left">启动Redis</td></tr><tr><td style="text-align:left">redis-cli</td><td style="text-align:left">Redis命令行客户端</td></tr><tr><td style="text-align:left">redis-benchmark</td><td style="text-align:left">Redis基准测试工具</td></tr><tr><td style="text-align:left">redis-check-aof</td><td style="text-align:left">Redis  AOF持久化文件检查和修复工具</td></tr><tr><td style="text-align:left">redis-check-dump</td><td style="text-align:left">Redis  RDB持久化文件检查和修复工具</td></tr><tr><td style="text-align:left">redis-sentinel</td><td style="text-align:left">启动Redis Sentinel</td></tr></tbody></table><h4 id="1-启动Redis"><a href="#1-启动Redis" class="headerlink" title="1.  启动Redis"></a><strong>1.  启动Redis</strong></h4><p>&emsp;&emsp;首先启动Redis，有三种方式：默认配置、运行配置、配置文件启动。</p><h5 id="（1）默认配置"><a href="#（1）默认配置" class="headerlink" title="（1）默认配置"></a><strong>（1）默认配置</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010102.png" alt=""></p><p>&emsp;&emsp;由上述信息可以得知，我们当前版本是5.0.8，默认端口6379，线程ID-30710，Redis建议使用配置文件启动。</p><p>&emsp;&emsp;因为直接启动无法自定义配置，所以生产环境不会采用这种方式。</p><h5 id="（2）运行配置"><a href="#（2）运行配置" class="headerlink" title="（2）运行配置"></a><strong>（2）运行配置</strong></h5><p>&emsp;&emsp;redis-server要加上修改配置名和值（可以多对），没有配置的将使用默认配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server --configkey1 configValue1 --configkey2 configValue2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比如我们想修改端口号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server --port 6380</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当配置较多或是想保存配置到文件中时，不建议使用这种方式。</p><h5 id="（3）配置文件启动"><a href="#（3）配置文件启动" class="headerlink" title="（3）配置文件启动"></a><strong>（3）配置文件启动</strong></h5><p>&emsp;&emsp;将配置写到文件中，比如写到/opt/redis/redis.conf，然后只须执行下列命令即可启动Redis。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server /opt/redis/redis.conf</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis有60多个配置，此处只给出比较重要的四个，后续会专门做整理介绍。</p><table><thead><tr><th style="text-align:left">配置名</th><th style="text-align:left">配置说明</th></tr></thead><tbody><tr><td style="text-align:left">port</td><td style="text-align:left">端口</td></tr><tr><td style="text-align:left">logfile</td><td style="text-align:left">日志文件</td></tr><tr><td style="text-align:left">dir</td><td style="text-align:left">Redis工作目录（存放持久化文件和日志文件）</td></tr><tr><td style="text-align:left">daemonize</td><td style="text-align:left">是否以守护线程的方式启动Redis</td></tr></tbody></table><p>&emsp;&emsp;配置文件启动的方式具有灵活性，所以大部分生产环境会使用这种方式。</p><h4 id="2-Redis命令行客户端"><a href="#2-Redis命令行客户端" class="headerlink" title="2.  Redis命令行客户端"></a><strong>2.  Redis命令行客户端</strong></h4><p>&emsp;&emsp;我们已经启动了Redis服务，接下来是使用redis-cli连接和操作Redis服务。redis-cli有两种方式来连接Redis服务器。</p><h5 id="（1）交互式方式"><a href="#（1）交互式方式" class="headerlink" title="（1）交互式方式"></a><strong>（1）交互式方式</strong></h5><p>&emsp;&emsp;通过 redis-cli -h {host} -p {port} 的方式连接到Redis服务，之后所有的操作都通过交互的方式实现，不需要再执行 redis-cli 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p &#123;port&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010103.png" alt=""></p><h5 id="（2）命令方式"><a href="#（2）命令方式" class="headerlink" title="（2）命令方式"></a><strong>（2）命令方式</strong></h5><p>&emsp;&emsp;通过 redis-cli -h {host} -p {port}  {command}直接得到命令结果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010104.png" alt=""></p><p>&emsp;&emsp;没有 -h 参数则默认连接127.0.0.1；没有 -p 参数则默认6379端口。</p><h4 id="3-停止Redis服务"><a href="#3-停止Redis服务" class="headerlink" title="3.  停止Redis服务"></a><strong>3.  停止Redis服务</strong></h4><p>&emsp;&emsp;Redis提供了shutdown命令来停止Redis服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli shutdown</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意：</p><ol><li><p>Redis关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式。</p></li><li><p>除了shutdown命令外，也可以通过kill进程号的方式关闭Redis，但请不要粗暴的使用kill -9 强制杀死Redis服务，这样不但不会做持久化操作，还会造成缓冲区不能正常关闭，极端情况下会造成AOF和复制丢失数据的情况。</p></li><li><p>shutdown还有一个参数，表示是否在关闭Redis前生成持久化文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    $ redis-cli shutdown nosave|save</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><hr><h2 id="1-6-版本命名"><a href="#1-6-版本命名" class="headerlink" title="1.6 版本命名"></a><strong>1.6 版本命名</strong></h2><p>&emsp;&emsp;Redis借鉴了Linux对于版本号的命名规则：版本号第二位如果是奇数，表示非稳定版本（unstable），如果是偶数，表示稳定版本（stable），当然还有Beta版本。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（一）Redis简介，内容包括：简介，特性，使用场景，如何使用，安装，版本命名。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记-目录（未完待续）</title>
    <link href="http://linyishui.top/2020030101.html"/>
    <id>http://linyishui.top/2020030101.html</id>
    <published>2020-03-01T07:16:50.000Z</published>
    <updated>2020-04-08T01:36:49.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章-Redis简介"><a href="#第一章-Redis简介" class="headerlink" title="第一章 Redis简介"></a><strong>第一章 Redis简介</strong></h2><p>&emsp;&emsp;<a href="../2020030102.html" title="Title">《Redis开发与运维》读书笔记（一）Redis简介</a></p><h2 id="第二章-API介绍"><a href="#第二章-API介绍" class="headerlink" title="第二章 API介绍"></a><strong>第二章 API介绍</strong></h2><p>&emsp;&emsp;<a href="../2020030201.html" title="Title">《Redis开发与运维》读书笔记（二）API介绍</a></p><h2 id="第三章-常用功能"><a href="#第三章-常用功能" class="headerlink" title="第三章 常用功能"></a><strong>第三章 常用功能</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（三）常用功能</p><h2 id="第四章-客户端"><a href="#第四章-客户端" class="headerlink" title="第四章 客户端"></a><strong>第四章 客户端</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（四）客户端</p><h2 id="第五章-持久化"><a href="#第五章-持久化" class="headerlink" title="第五章 持久化"></a><strong>第五章 持久化</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（五）持久化</p><h2 id="第六章-复制"><a href="#第六章-复制" class="headerlink" title="第六章 复制"></a><strong>第六章 复制</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（六）复制</p><h2 id="第七章-常见问题：阻塞"><a href="#第七章-常见问题：阻塞" class="headerlink" title="第七章 常见问题：阻塞"></a><strong>第七章 常见问题：阻塞</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（七）常见问题：阻塞</p><h2 id="第八章-理解内存"><a href="#第八章-理解内存" class="headerlink" title="第八章 理解内存"></a><strong>第八章 理解内存</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（八）理解内存</p><h2 id="第九章-哨兵"><a href="#第九章-哨兵" class="headerlink" title="第九章 哨兵"></a><strong>第九章 哨兵</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（九）哨兵</p><h2 id="第十章-集群"><a href="#第十章-集群" class="headerlink" title="第十章 集群"></a><strong>第十章 集群</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十）集群</p><h2 id="第十一章-缓存设计"><a href="#第十一章-缓存设计" class="headerlink" title="第十一章 缓存设计"></a><strong>第十一章 缓存设计</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十一）缓存设计</p><h2 id="第十二章-开发运维中常见的陷阱"><a href="#第十二章-开发运维中常见的陷阱" class="headerlink" title="第十二章 开发运维中常见的陷阱"></a><strong>第十二章 开发运维中常见的陷阱</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十二）开发运维中常见的陷阱</p><h2 id="第十三章-Redis监控运维云平台-CacheCloud"><a href="#第十三章-Redis监控运维云平台-CacheCloud" class="headerlink" title="第十三章 Redis监控运维云平台-CacheCloud"></a><strong>第十三章 Redis监控运维云平台-CacheCloud</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十三）Redis监控运维云平台-CacheCloud</p><h2 id="第十四章-Redis配置统计字典"><a href="#第十四章-Redis配置统计字典" class="headerlink" title="第十四章 Redis配置统计字典"></a><strong>第十四章 Redis配置统计字典</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十四）Redis配置统计字典</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记，内容包括：Redis简介，API介绍，常用功能，客户端，持久化，复制，常见问题：阻塞，理解内存，哨兵，集群，缓存设计，开发运维中常见的陷阱，Redis监控运维云平台-CacheCloud，Redis配置统计字典。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>开发常见英文缩写合集（持续更新）</title>
    <link href="http://linyishui.top/2020022101.html"/>
    <id>http://linyishui.top/2020022101.html</id>
    <published>2020-02-21T10:21:41.000Z</published>
    <updated>2020-03-25T10:32:39.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="开发常见英文缩写合集"><a href="#开发常见英文缩写合集" class="headerlink" title="开发常见英文缩写合集"></a><strong>开发常见英文缩写合集</strong></h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a><strong>IOC</strong></h3><p>控制反转(Inversion of Control，缩写为IoC)，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入(Dependency Injection，简称DI)，还有一种方式叫“依赖查找”(Dependency Lookup)。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><strong>AOP</strong></h3><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h3><p>是一种乐观锁机制。CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a><strong>BIO</strong></h3><p>Blocking Input Output，同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a><strong>NIO</strong></h3><p>NIO是指将IO模式设为“Non-Blocking”模式。NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><h3 id="AICD"><a href="#AICD" class="headerlink" title="AICD"></a><strong>AICD</strong></h3><p>事务属性AICD：</p><p>原子性(Atomicity)：整体不可分割性，要么全做要不全不做。</p><p>一致性(Consistency) ：事务执行前、后数据库状态均一致。</p><p>隔离性(Isolation) ：在事务未提交前，它操作的数据，对其它用户不可见(从其他session读取的数据还是commit之前的数据状态)。</p><p>持久性(Durability)：一旦事务成功，将进行永久的变更，记录与redo日志。</p><h3 id="RC"><a href="#RC" class="headerlink" title="RC"></a><strong>RC</strong></h3><p>数据库隔离级别，Read Committed(读取提交内容)。</p><p>(1) 这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)</p><p>(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</p><p>(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。</p><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a><strong>RR</strong></h3><p>数据库隔离级别，Repeatable Read(可重读)。</p><p>(1)这是MySQL的默认事务隔离级别。</p><p>(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p><p>(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。</p><p>(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。</p><h3 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a><strong>Binlog</strong></h3><p>是The Binary Log的简称，意思就是二进制的日志文件。binlog是一个二进制格式的文件，用于记录用户对数据库更新的SQL语句信息，例如更改数据库表和更改内容的SQL语句都会记录到binlog里，但是对库表等内容的查询不会记录。默认情况下，binlog日志是二进制格式的，不能使用查看文本工具的命令(比如，cat，vi等)查看，而使用mysqlbinlog解析查看。当有数据写入到数据库时，还会同时把更新的SQL语句写入到对应的binlog文件里，这个文件就是上文说的binlog文件。使用mysqldump备份时，只是对一段时间的数据进行全备，但是如果备份后突然发现数据库服务器故障，这个时候就要用到binlog的日志了。主要作用是用于数据库的主从复制及数据的增量恢复。</p><h3 id="RESP"><a href="#RESP" class="headerlink" title="RESP"></a><strong>RESP</strong></h3><p>Redis Serialization Protocol，RESP 是 Redis 序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简 单，解析性能极好。</p><h3 id="COW"><a href="#COW" class="headerlink" title="COW"></a><strong>COW</strong></h3><p>写入时复制(英语：Copy-on-write，简称COW)是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者(callers)同时请求相同资源(如内存或磁盘上的数据存储)，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本(private copy)给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的(transparently)。 优点是如果调用者没有修改该资源，就不会有副本(private copy)被建立，因此多个调用者只是读取操作时可以共享同一份资源。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h3><p>Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问;在编程语言中实现事务内存。MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制。</p><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a><strong>SDS</strong></h3><p>简单动态字符串(simple dynamic string，SDS)的抽象类型。字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串sds(simple dynamic string)，是可以修改的字符串。它类似于Java中的ArrayList，它采用预分配冗余空间的方式来减少内存的频繁分配。C语言字符串使用长度为n+1的字符数组来表示长度为n的字符串，并且字符数组的最后一个元素总是空字符’\0’，因为这种字符串表示方式不能满足Redis对字符串在安全性、效率以及功能方面的要求，所以Redis自己构建了SDS，用于满足其需求。在Redis里，C语言字符串只用于一些无须对字符串值进行修改的地方，比如：日志。在Redis中，包含字符串值的键值对都是使用SDS实现的，除此之外，SDS还被用于AOF缓冲区、客户端状态的输入缓冲区。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><p>Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化文件即可实现数据恢复。RDB (Redis DataBase)。RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h3><p>Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化文件即可实现数据恢复。AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h2><h3 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a><strong>ZAB</strong></h3><p>ZAB 协议全称：Zookeeper Atomic Broadcast(Zookeeper 原子广播协议)。ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 二阶段提交过程。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作(先提交自己，再发送 commit 给所有 Follwer)。</p><h3 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a><strong>ACK</strong></h3><p>ACK消息，Acknowledgement 。是在计算机网上中通信协议的一部分，是设备或是进程发出的消息，回复已收到数据。例如在传输控制协议(TCP，Transmission Control Protocol)中就有用ACK来告知创建链接时有收到SYN数据包、使用链接时有收到数据包，或是在中止链接有收到FIN数据包。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a><strong>CAP</strong></h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性(Consistency)、可用性(Availability)、分区容忍性(Partition tolerance)。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p><p>一致性(C)：在分布式系统中的所有数据备份，在同一时刻是否同样的值。(等同于所有节点访问同一份最新的数据副本)</p><p>可用性(A)：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)</p><p>分区容忍性(P)：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a><strong>AMQP</strong></h3><p>即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h2><h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a><strong>DDD</strong></h3><p>DDD(Domain-Driven Design 领域驱动设计)是由Eric Evans最先提出，目的是对软件所涉及到的领域进行建模，以应对系统规模过大时引起的软件复杂性的问题。整个过程大概是这样的，开发团队和领域专家一起通过 通用语言(Ubiquitous Language)去理解和消化领域知识，从领域知识中提取和划分为一个一个的子领域(核心子域，通用子域，支撑子域)，并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。</p>]]></content>
    
    <summary type="html">
    
      开发中常见英文缩写合集，主要针对Java后端，可能会扩展到前端、算法、网络等。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>Git常用指令（持续更新）</title>
    <link href="http://linyishui.top/2020022001.html"/>
    <id>http://linyishui.top/2020022001.html</id>
    <published>2020-02-20T09:32:27.000Z</published>
    <updated>2020-04-21T02:05:45.544Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git常用指令笔记"><a href="#Git常用指令笔记" class="headerlink" title="Git常用指令笔记"></a><strong>Git常用指令笔记</strong></h1><h2 id="1-用户"><a href="#1-用户" class="headerlink" title="1. 用户"></a><strong>1. 用户</strong></h2><p>&emsp;&emsp;更新名字和邮箱。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"**"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"**@**.com"</span></span></span><br></pre></td></tr></table></figure><h2 id="2-本地"><a href="#2-本地" class="headerlink" title="2. 本地"></a><strong>2. 本地</strong></h2><p>&emsp;&emsp;创建空仓库或进行初始化（不会覆盖已有配置）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此命令将要提交的文件的信息添加到索引库中(将修改添加到暂存区)，以准备为下一次提交分段的内容。 默认情况下，git add命令不会添加忽略的文件。 如果在命令行上显式指定了任何忽略的文件，git add命令都将失败，并显示一个忽略的文件列表。由Git执行的目录递归或文件名遍历所导致的忽略文件将被默认忽略。 git add命令可以用-f(force)选项添加被忽略的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;path&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将所有修改添加到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ant风格添加修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add *  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将以Controller结尾的文件的所有修改添加到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add *Controller   </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将所有以Hello开头的文件的修改添加到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add Hello*    </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将以Hello开头后面只有一位的文件的修改提交到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add Hello?   </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加doc目录及其子目录下所有*.txt文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add doc/*.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有git-*.sh脚本内容(不会考虑子目录文件)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add git-*.sh</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;提交更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"First Commit"</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;推送到远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查看日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查看日志详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 尚未缓存的改动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已缓存的改动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已缓存的与未缓存的所有改动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示摘要而非整个diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --<span class="built_in">stat</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;取消文件的缓存，之后首次执行git commit不会提交前者，再次执行git commit则会提交，用来在文件还未修改成功但需要提交其他内容时跳过此次提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从工作区移除文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;file&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm -f &lt;file&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中</span></span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归删除，删掉当前目录所有文件</span></span><br><span class="line">git rm –r *</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;移动和重命名文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv README README.md</span></span><br></pre></td></tr></table></figure><h2 id="3-远程"><a href="#3-远程" class="headerlink" title="3. 远程"></a><strong>3. 远程</strong></h2><p>&emsp;&emsp;克隆项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@gitlab.**.**</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前远程仓库，列出详细信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v | --verbose</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一个新的远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@XXX.XXX.XXX.XXX:XXX</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;更新分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 相当于是从远程获取最新版本到本地，不会自动合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git pull则相当于是从远程获取最新版本并merge到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动建立追踪关系，指定本地master分支追踪origin/next分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream master origin/next</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 已有追踪关系，可以忽略远程分支名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前分支只有一个追踪分支，连远程主机名都可以省略</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果合并需要采用rebase模式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接push代码到远程新分支</span></span><br><span class="line">git push origin master:remote_new_branch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 远端即可创建新的分支remote_new_branch，提交本地修改</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支：1.推送空分支 2.delete参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :branch_a</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete branch_a</span></span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.yiibai.com/git" title="Title" target="_blank" rel="noopener">Git教程-易百教程</a></p></blockquote><blockquote><p><a href="https://www.runoob.com/git/git-tutorial.html" title="Title" target="_blank" rel="noopener">Git教程-菜鸟教程</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Git常用指令笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用指令（持续更新）</title>
    <link href="http://linyishui.top/2020021901.html"/>
    <id>http://linyishui.top/2020021901.html</id>
    <published>2020-02-19T09:30:05.000Z</published>
    <updated>2020-04-07T10:22:49.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux常用指令笔记"><a href="#Linux常用指令笔记" class="headerlink" title="Linux常用指令笔记"></a><strong>Linux常用指令笔记</strong></h1><h2 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a><strong>1. 文件</strong></h2><p>&emsp;&emsp;ls</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出目录下所有s开头文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -ltr s*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将/bin目录以下所有目录及文件详细信息列出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lR /bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出目录下所有文件及目录；目录于名称后加 <span class="string">"/"</span>, 可执行档于名称后加<span class="string">"*"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -AF</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用 mkdir 命令创建 runoob 目录</span></span><br><span class="line">[root@www ~]# mkdir runoob</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用绝对路径切换到 runoob 目录</span></span><br><span class="line">[root@www ~]# cd /root/runoob/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用相对路径切换到 runoob 目录</span></span><br><span class="line">[root@www ~]# cd ./runoob/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示回到自己的家目录，亦即是 /root 这个目录</span></span><br><span class="line">[root@www runoob]# cd ~</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></span><br><span class="line">[root@www ~]# cd ..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;CTRL+D退出当前shell命令。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.runoob.com/linux/linux-tutorial.html" title="Title" target="_blank" rel="noopener">Linux教程</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Linux常用指令笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySql笔记（持续更新）</title>
    <link href="http://linyishui.top/2020021801.html"/>
    <id>http://linyishui.top/2020021801.html</id>
    <published>2020-02-18T03:15:41.000Z</published>
    <updated>2020-03-24T07:19:41.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySql笔记"><a href="#MySql笔记" class="headerlink" title="MySql笔记"></a><strong>MySql笔记</strong></h1><h2 id="1-数据库定时备份"><a href="#1-数据库定时备份" class="headerlink" title="1 数据库定时备份"></a><strong>1 数据库定时备份</strong></h2><h3 id="1-1-Linux"><a href="#1-1-Linux" class="headerlink" title="1.1 Linux"></a><strong>1.1 Linux</strong></h3><p>&emsp;&emsp;暂无</p><h3 id="1-2-Windows"><a href="#1-2-Windows" class="headerlink" title="1.2 Windows"></a><strong>1.2 Windows</strong></h3><p>&emsp;&emsp;新建一个.bat文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> <span class="string">"Ymd=%date:~,4%%date:~5,2%%date:~8,2%"</span></span><br><span class="line"><span class="string">"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqldump"</span> --opt -u root --password=&lt;密码&gt; &lt;数据库名&gt; &gt; E:\db_backup\scwl_%Ymd%.sql</span><br><span class="line">@<span class="built_in">echo</span> on</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Windows开启定时任务：【任务管理器】-&gt;【管理工具】-&gt;【任务计划程序中】</p><h3 id="1-3-Navicat-for-MySQL"><a href="#1-3-Navicat-for-MySQL" class="headerlink" title="1.3 Navicat for MySQL"></a><strong>1.3 Navicat for MySQL</strong></h3><p>&emsp;&emsp;<a href="https://www.formysql.com/wenti/dingshi-beifen.html" title="Title" target="_blank" rel="noopener">Navicat for MySQL 如何创建定时备份</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.formysql.com/wenti/dingshi-beifen.html" title="Title" target="_blank" rel="noopener">Navicat for MySQL 如何创建定时备份</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      MySql常用功能和指令笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>LoadBalanced注解原理（未完成）</title>
    <link href="http://linyishui.top/2020021501.html"/>
    <id>http://linyishui.top/2020021501.html</id>
    <published>2020-02-15T10:22:31.000Z</published>
    <updated>2020-03-25T02:58:13.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-LoadBalanced注解原理"><a href="#Spring-Cloud-LoadBalanced注解原理" class="headerlink" title="Spring Cloud-LoadBalanced注解原理"></a><strong>Spring Cloud-LoadBalanced注解原理</strong></h1><p>​        Spring Cloud提供Ribbon来进行服务端负载均衡，和Eureka配合使用不需要再在服务集群架设负载均衡服务。</p><blockquote><ol><li>RibbonAutoConfiguration配置生成RibbonLoadBalancerClient实例</li><li>LoadBalancerInterceptorConfig配置生成LoadBalancerInterceptor实例（RibbonLoadBalancerClient实例和LoadBalancerRequestFactory实例）和RestTemplate自定义的RestTemplateCustomizer实例</li><li>通过RestTemplateCustomizer实例配置所有RestTemplate实例，即将负载均衡拦截器设置给所有RestTemplate</li><li>RibbonClientConfiguration配置生成ZoneAwareLoadBalancer实例</li></ol></blockquote><h2 id="第二节-源码解析"><a href="#第二节-源码解析" class="headerlink" title="第二节 源码解析"></a><strong>第二节 源码解析</strong></h2><h3 id="2-1-RibbonAutoConfiguration"><a href="#2-1-RibbonAutoConfiguration" class="headerlink" title="2.1 RibbonAutoConfiguration"></a><strong>2.1 RibbonAutoConfiguration</strong></h3><p>&emsp;&emsp;Ribbon基础配置类，用来生成RibbonLoadBalancerClient实例。此配置类要早于LoadBalancerAutoConfiguration前执行，因为在后者中要使用RibbonLoadBalancerClient实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 只有在classpath下能找到这些类才会构建这个Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;IClient.class, RestTemplate.class, AsyncRestTemplate.class, Ribbon.class&#125;)</span><br><span class="line"><span class="comment">// 允许在单个类中使用多个@RibbonClient</span></span><br><span class="line"><span class="meta">@RibbonClients</span></span><br><span class="line"><span class="comment">// 控制配置类启动顺序，若有Eureka，那就在Eureka配置好后再配置它</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(</span><br><span class="line">    name = &#123;<span class="string">"org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(&#123;LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class&#125;)</span><br><span class="line"><span class="comment">// 加载配置：ribbon.eager-load --&gt; true的话，那么项目启动的时候就会把Client初始化好，避免第一次惩罚</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;RibbonEagerLoadProperties.class, ServerIntrospectorProperties.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ribbon的配置文件</span></span><br><span class="line">    <span class="meta">@Autowired</span>(</span><br><span class="line">        required = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RibbonAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特征，FeaturesEndpoint这个端点('/actuator/features')会使用它</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HasFeatures <span class="title">ribbonFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">"Ribbon"</span>, Ribbon.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它是最为重要的，是一个org.springframework.cloud.context.named.NamedContextFactory 此工厂用于创建命名的Spring容器</span></span><br><span class="line">    <span class="comment">// 这里传入配置文件，每个不同命名空间就会创建一个新的容器（和Feign特别像）设置当前容器为父容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">        factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个Bean是关键，若你没定义，就用系统默认提供的Client了</span></span><br><span class="line">    <span class="comment">// RibbonLoadBalancerClient继承自LoadBalancerClient接口，是负载均衡客户端，也是负载均衡策略的调用方，内部使用和持有了SpringClientFactory</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123;LoadBalancerClient.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(<span class="keyword">this</span>.springClientFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(</span><br><span class="line">        name = &#123;<span class="string">"org.springframework.retry.support.RetryTemplate"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancedRetryFactory <span class="title">loadBalancedRetryPolicyFactory</span><span class="params">(<span class="keyword">final</span> SpringClientFactory clientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancedRetryFactory(clientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertiesFactory <span class="title">propertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertiesFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(&#123;<span class="string">"ribbon.eager-load.enabled"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RibbonApplicationContextInitializer <span class="title">ribbonApplicationContextInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RibbonApplicationContextInitializer(<span class="keyword">this</span>.springClientFactory(), <span class="keyword">this</span>.ribbonEagerLoadProperties.getClients());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnRibbonRestClientCondition</span> <span class="keyword">extends</span> <span class="title">AnyNestedCondition</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OnRibbonRestClientCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(&#123;<span class="string">"ribbon.restclient.enabled"</span>&#125;)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonProperty</span> </span>&#123;</span><br><span class="line">            RibbonProperty() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(&#123;<span class="string">"ribbon.http.client.enabled"</span>&#125;)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProperty</span> </span>&#123;</span><br><span class="line">            ZuulProperty() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Conditional</span>(&#123;RibbonAutoConfiguration.OnRibbonRestClientCondition.class&#125;)</span><br><span class="line">    <span class="meta">@interface</span> ConditionalOnRibbonRestClient &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;HttpRequest.class&#125;)</span><br><span class="line">    <span class="meta">@RibbonAutoConfiguration</span>.ConditionalOnRibbonRestClient</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientHttpRequestFactoryConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> SpringClientFactory springClientFactory;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">RibbonClientHttpRequestFactoryConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(<span class="keyword">final</span> RibbonClientHttpRequestFactory ribbonClientHttpRequestFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (restTemplate) -&gt; &#123;</span><br><span class="line">                restTemplate.setRequestFactory(ribbonClientHttpRequestFactory);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RibbonClientHttpRequestFactory <span class="title">ribbonClientHttpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RibbonClientHttpRequestFactory(<span class="keyword">this</span>.springClientFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-LoadBalancerAutoConfiguration"><a href="#2-2-LoadBalancerAutoConfiguration" class="headerlink" title="2.2 LoadBalancerAutoConfiguration"></a><strong>2.2 LoadBalancerAutoConfiguration</strong></h3><p>&emsp;&emsp;源码配置类，为RestTemplate配置拦截器，维护一个restTemplates数组，即所有标注@LoadBalanced的RestTemplate。通过LoadBalancerRequestTransformer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 可见它只对RestTemplate生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;RestTemplate.class&#125;)</span><br><span class="line"><span class="comment">// Spring容器内必须存在这个接口的Bean才会生效（参见：RibbonAutoConfiguration），即RibbonAutoConfiguration生成的RibbonLoadBalancerClient实例。</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(&#123;LoadBalancerClient.class&#125;)</span><br><span class="line"><span class="comment">// retry的配置文件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;LoadBalancerRetryProperties.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 维护容器内所有的标注有@LoadBalanced注解的Bean，必须标注有@LoadBalanced注解</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Autowired</span>(</span><br><span class="line">        required = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadBalancerRequestTransformer接口：函数transformRequest(HttpRequest, ServiceInstance)</span></span><br><span class="line">    <span class="comment">// Spring内部默认是没有提供任何实现类的</span></span><br><span class="line">    <span class="meta">@Autowired</span>(</span><br><span class="line">        required = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置一个匿名的SmartInitializingSingleton，它的afterSingletonsInstantiated()方法会在所有的单例Bean初始化完成之后，再调用一个一个的处理BeanName</span></span><br><span class="line">    <span class="comment">// 使用LoadBalancerInterceptorConfig配置好的RestTemplateCustomizer定制器，对所有的RestTemplate进行定制处理，就是将负载均衡拦截器设置给RestTemplate实例</span></span><br><span class="line">    <span class="comment">// 函数式接口RestTemplateCustomizer下面有个lambda的实现，若调用者有需要可以书写然后扔进容器里既生效</span></span><br><span class="line">    <span class="comment">// 若你项目中有多个RestTempalte，需要统一处理的话，写一个定制器是个不错的选择（比如统一要放置一个请求拦截器：输出日志之类的）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(<span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            restTemplateCustomizers.ifAvailable((customizers) -&gt; &#123;</span><br><span class="line">                Iterator var2 = <span class="keyword">this</span>.restTemplates.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                    RestTemplate restTemplate = (RestTemplate)var2.next();</span><br><span class="line">                    Iterator var4 = customizers.iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">                        RestTemplateCustomizer customizer = (RestTemplateCustomizer)var4.next();</span><br><span class="line">                        customizer.customize(restTemplate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个工厂用于createRequest()生成一个LoadBalancerRequest</span></span><br><span class="line">    <span class="comment">// 这个请求里面是包含LoadBalancerClient以及HttpRequest的</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancerRequestFactory <span class="title">loadBalancerRequestFactory</span><span class="params">(LoadBalancerClient loadBalancerClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancerClient, <span class="keyword">this</span>.transformers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;RetryTemplate.class&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryInterceptorAutoConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RetryInterceptorAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RetryLoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(LoadBalancerClient loadBalancerClient, LoadBalancerRetryProperties properties, LoadBalancerRequestFactory requestFactory, LoadBalancedRetryFactory loadBalancedRetryFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RetryLoadBalancerInterceptor(loadBalancerClient, properties, requestFactory, loadBalancedRetryFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(<span class="keyword">final</span> RetryLoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (restTemplate) -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList(restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor);</span><br><span class="line">                restTemplate.setInterceptors(list);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;RetryTemplate.class&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAutoConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RetryAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LoadBalancedRetryFactory <span class="title">loadBalancedRetryFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancedRetryFactory() &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过LoadBalancerInterceptor和RestTemplateCustomizer来添加拦截器</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass</span>(&#123;<span class="string">"org.springframework.retry.support.RetryTemplate"</span>&#125;)</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line">        LoadBalancerInterceptorConfig() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里直接使用的是requestFactory和Client构建一个拦截器对象</span></span><br><span class="line">        <span class="comment">// LoadBalancerInterceptor实现ClientHttpRequestInterceptor接口，也是实现负载均衡的入口</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(LoadBalancerClient loadBalancerClient, LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向容器内放入一个RestTemplateCustomizer定制器，在RestTemplate初始化完成后，应用此定制化器在所有的实例上。</span></span><br><span class="line">        <span class="comment">// 这个匿名实现的逻辑很简单，向所有的RestTemplate都塞入一个loadBalancerInterceptor让其具备有负载均衡的能力</span></span><br><span class="line">        <span class="comment">// 此处有注解@ConditionalOnMissingBean。也就是说如果调用者自己定义过RestTemplateCustomizer类型的Bean，此处是不会执行的</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(<span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (restTemplate) -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList(restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor);</span><br><span class="line">                restTemplate.setInterceptors(list);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>LoadBalancerAutoConfiguration要想生效类路径必须有RestTemplate，以及Spring容器内必须有LoadBalancerClient的实现Bean</li><li>LoadBalancerClient的唯一实现类是：org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient</li><li>LoadBalancerInterceptor是个ClientHttpRequestInterceptor客户端请求拦截器。它的作用是在客户端发起请求之前拦截，进而实现客户端的负载均衡</li><li>restTemplateCustomizer()返回的匿名定制器RestTemplateCustomizer它用来给所有的RestTemplate加上负载均衡拦截器（需要注意它的@ConditionalOnMissingBean注解~）</li></ol></blockquote><p>​        不难发现，负载均衡实现的核心就是一个拦截器，就是这个拦截器让一个普通的RestTemplate逆袭成为了一个具有负载均衡功能的请求器LoadBalancerInterceptor。</p><h3 id="2-3-LoadBalancerRequestFactory"><a href="#2-3-LoadBalancerRequestFactory" class="headerlink" title="2.3 LoadBalancerRequestFactory"></a><strong>2.3 LoadBalancerRequestFactory</strong></h3><p>&emsp;&emsp;工厂类，根据LoadBalancerRequestTransformer数组批量对HttpRequest进行处理，创建LoadBalancerRequest。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerRequestFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line">    <span class="keyword">private</span> List&lt;LoadBalancerRequestTransformer&gt; transformers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerRequestFactory</span><span class="params">(LoadBalancerClient loadBalancer, List&lt;LoadBalancerRequestTransformer&gt; transformers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">        <span class="keyword">this</span>.transformers = transformers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerRequestFactory</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="title">createRequest</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Lambda表达式，LoadBalancerRequest是一个函数式接口，T apply(ServiceInstance instance) </span></span><br><span class="line">        <span class="keyword">return</span> (instance) -&gt; &#123;</span><br><span class="line">            HttpRequest serviceRequest = <span class="keyword">new</span> ServiceRequestWrapper(request, instance, <span class="keyword">this</span>.loadBalancer);</span><br><span class="line">            LoadBalancerRequestTransformer transformer;</span><br><span class="line">            <span class="comment">//遍历并执行transformer.transformRequest</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.transformers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(Iterator var6 = <span class="keyword">this</span>.transformers.iterator(); var6.hasNext(); serviceRequest = transformer.transformRequest((HttpRequest)serviceRequest, instance)) &#123;</span><br><span class="line">                    transformer = (LoadBalancerRequestTransformer)var6.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行serviceRequest并返回ClientHttpResponse</span></span><br><span class="line">            <span class="keyword">return</span> execution.execute((HttpRequest)serviceRequest, body);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-LoadBalancerInterceptor"><a href="#2-4-LoadBalancerInterceptor" class="headerlink" title="2.4  LoadBalancerInterceptor"></a><strong>2.4  LoadBalancerInterceptor</strong></h3><p>&emsp;&emsp;拦截器代码，主要逻辑在intercept函数，执行交给了LoadBalancerClient来处理，通过LoadBalancerRequestFactory来构建一个LoadBalancerRequest对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个命名都不叫Client了，而叫loadBalancer</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line">    <span class="comment">// 用于构建出一个Request</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(loadBalancer, <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URI originalUri = request.getURI();</span><br><span class="line">        String serviceName = originalUri.getHost();</span><br><span class="line">        Assert.state(serviceName != <span class="keyword">null</span>, <span class="string">"Request URI does not contain a valid hostname: "</span> + originalUri);</span><br><span class="line">        <span class="keyword">return</span> (ClientHttpResponse)<span class="keyword">this</span>.loadBalancer.execute(serviceName, <span class="keyword">this</span>.requestFactory.createRequest(request, body, execution));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;createRequest中通过ServiceRequestWrapper来执行替换URI的逻辑，ServiceRequestWrapper中将URI的获取交给了LoadBalancerClient#reconstructURI方法。</p><p>&emsp;&emsp;此拦截器拦截请求后把它的serviceName委托给了LoadBalancerClient去执行，根据ServiceName可能对应N多个实际的Server，因此就可以从众多的Server中运用均衡算法，挑选出一个最为合适的Server做最终的请求（它持有真正的请求执行器ClientHttpRequestExecution）。</p><h3 id="2-5-LoadBalancerClient"><a href="#2-5-LoadBalancerClient" class="headerlink" title="2.5  LoadBalancerClient"></a><strong>2.5  LoadBalancerClient</strong></h3><p>请求被拦截后，最终都是委托给了LoadBalancerClient处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由使用负载平衡器选择要向其发送请求的服务器的类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstanceChooser</span> </span>&#123;</span><br><span class="line"><span class="comment">// 从负载平衡器中为指定的服务选择Service服务实例。</span></span><br><span class="line">    <span class="comment">// 也就是根据调用者传入的serviceId，负载均衡的选择出一个具体的实例出来</span></span><br><span class="line">    <span class="function">ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它自己定义了三个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancerClient</span> <span class="keyword">extends</span> <span class="title">ServiceInstanceChooser</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行请求</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新构造url：把url中原来写的服务名 换掉 换成实际的</span></span><br><span class="line">    <span class="function">URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    它只有一个实现类RibbonLoadBalancerClient （ServiceInstanceChooser是有多个实现类的~）。<br>RibbonLoadBalancerClient。<br>​    首先我们应当关注它的choose()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonLoadBalancerClient</span> <span class="keyword">implements</span> <span class="title">LoadBalancerClient</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choose(serviceId, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hint：你可以理解成分组。若指定了，只会在这个偏好的分组里面去均衡选择</span></span><br><span class="line">    <span class="comment">// 得到一个Server后，使用RibbonServer把server适配起来~~~</span></span><br><span class="line">    <span class="comment">// 这样一个实例就选好了~~~真正请求会落在这个实例上~</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">choose</span><span class="params">(String serviceId, Object hint)</span> </span>&#123;</span><br><span class="line">        Server server = getServer(getLoadBalancer(serviceId), hint);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server, serviceId),</span><br><span class="line">                serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据ServiceId去找到一个属于它的负载均衡器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        choose方法：传入serviceId，然后通过SpringClientFactory获取负载均衡器com.netflix.loadbalancer.ILoadBalancer，最终委托给它的chooseServer()方法选取到一个com.netflix.loadbalancer.Server实例，也就是说真正完成Server选取的是ILoadBalancer。ILoadBalancer以及它相关的类是一个较为庞大的体系，此处不做更多的展开。</p><p>​        LoadBalancerInterceptor执行的时候是直接委托执行的loadBalancer.execute()这个方法：<br>RibbonLoadBalancerClient：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hint此处传值为null：一视同仁</span></span><br><span class="line"><span class="comment">// 说明：LoadBalancerRequest是通过LoadBalancerRequestFactory.createRequest(request, body, execution)创建出来的</span></span><br><span class="line"><span class="comment">// 它实现LoadBalancerRequest接口是用的一个匿名内部类，泛型类型是ClientHttpResponse</span></span><br><span class="line"><span class="comment">// 因为最终执行的显然还是执行器：ClientHttpRequestExecution.execute()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, request, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// public方法（非接口方法）</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 同上：拿到负载均衡器，然后拿到一个serverInstance实例</span></span><br><span class="line">    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">    Server server = getServer(loadBalancer, hint);</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123; <span class="comment">// 若没找到就直接抛出异常。这里使用的是IllegalStateException这个异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把Server适配为RibbonServer  isSecure：客户端是否安全</span></span><br><span class="line">    <span class="comment">// serverIntrospector内省  参考配置文件：ServerIntrospectorProperties</span></span><br><span class="line">    RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server,</span><br><span class="line">            isSecure(server, serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用本类的重载接口方法~~~~~</span></span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口方法：它的参数是ServiceInstance --&gt; 已经确定了唯一的Server实例~~~</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到Server）（说白了，RibbonServer是execute时的唯一实现）</span></span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">        server = ((RibbonServer) serviceInstance).getServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明：执行的上下文是和serviceId绑定的</span></span><br><span class="line">    RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory.getLoadBalancerContext(serviceId);</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 真正的向server发送请求，得到返回值</span></span><br><span class="line">    <span class="comment">// 因为有拦截器，所以这里肯定说执行的是InterceptingRequestExecution.execute()方法</span></span><br><span class="line">    <span class="comment">// so会调用ServiceRequestWrapper.getURI()，从而就会调用reconstructURI()方法</span></span><br><span class="line">        T returnVal = request.apply(serviceInstance);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    ... <span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        returnVal是一个ClientHttpResponse，最后交给handleResponse()方法来处理异常情况（若存在的话），若无异常就交给提取器提值：responseExtractor.extractData(response)，这样整个请求就算全部完成了。<br>使用细节针对@LoadBalanced下的RestTemplate的使用，总结如下细节供以参考：</p><p>​        传入的String类型的url必须是绝对路径（http://…），否则抛出异常：java.lang.IllegalArgumentException: URI is not absolute<br>​        serviceId不区分大小写（<a href="http://user/...效果同http://USER/...），serviceId后不要跟port端口号" target="_blank" rel="noopener">http://user/...效果同http://USER/...），serviceId后不要跟port端口号</a></p><p>​        最后，需要特别指出的是：标注有@LoadBalanced的RestTemplate只能书写serviceId而不能再写IP地址/域名去发送请求了。若你的项目中两种case都有需要，请定义多个RestTemplate分别应对不同的使用场景~</p><h2 id="第三节-测试"><a href="#第三节-测试" class="headerlink" title="第三节 测试"></a><strong>第三节 测试</strong></h2><pre><code>了解了它的执行流程后，若需要本地测试（不依赖于注册中心），可以这么来做：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为自动配置头上有@ConditionalOnMissingBean注解，所以自定义一个覆盖它的行为即可</span></span><br><span class="line"><span class="comment">// 此处复写它的getServer()方法，返回一个固定的（访问百度首页）即可，方便测试</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">(SpringClientFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(factory) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer, Object hint)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Server(<span class="string">"www.baidu.com"</span>, <span class="number">80</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这么一来，下面这个访问结果就是百度首页的html内容喽。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String obj = restTemplate.getForObject(<span class="string">"http://my-serviceId"</span>, String.class);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        此处my-serviceId肯定是不存在的，但得益于我上面自定义配置的LoadBalancerClient</p><p>​        什么，写死return一个Server实例不优雅？确实，总不能每次上线前还把这部分代码给注释掉吧，若有多个实例呢？还得自己写负载均衡算法吗？很显然Spring Cloud早早就为我们考虑到了这一点：脱离Eureka使用配置listOfServers进行客户端负载均衡调度（..listOfServers=）</p><p>​        对于上例我只需要在主配置文件里这么配置一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ribbon.eureka.enabled=<span class="literal">false</span> <span class="comment"># 若没用euraka，此配置可省略。否则不可以</span></span></span><br><span class="line">my-serviceId.ribbon.listOfServers=www.baidu.com # 若有多个实例请用逗号分隔复制代码</span><br></pre></td></tr></table></figure><p>​        效果完全同上。Tips：这种配置法不需要是完整的绝对路径，http://是可以省略的（new Server()方式亦可）</p><p>​        自己添加一个记录请求日志的拦截器可行吗？显然是可行的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add((request, body, execution) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"当前请求的URL是："</span> + request.getURI().toString());</span><br><span class="line">        <span class="keyword">return</span> execution.execute(request, body);</span><br><span class="line">    &#125;);</span><br><span class="line">    restTemplate.setInterceptors(list);</span><br><span class="line">    <span class="keyword">return</span> restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这样每次客户端的请求都会打印这句话：当前请求的URI是：<a href="http://my-serviceId，一般情况（缺省情况）自定义的拦截器都会在负载均衡拦截器前面执行（因为它要执行最终的请求）。若你有必要定义多个拦截器且要控制顺序，可通过Ordered系列接口来实现" target="_blank" rel="noopener">http://my-serviceId，一般情况（缺省情况）自定义的拦截器都会在负载均衡拦截器前面执行（因为它要执行最终的请求）。若你有必要定义多个拦截器且要控制顺序，可通过Ordered系列接口来实现</a>~</p><p>​        最后的最后，一个非常非常重要的问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br></pre></td></tr></table></figure></p><p>​        @Autowired + @LoadBalanced能把你配置的RestTemplate自动注入进来拿来定制呢？？？核心原理是什么？</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://juejin.im/post/5d80576de51d4561b416d51f" title="Title" target="_blank" rel="noopener">为何一个@LoadBalanced注解就能让RestTemplate拥有负载均衡的能力？</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud LoadBalanced注解原理
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
      <category term="ribbon" scheme="http://linyishui.top/tags/ribbon/"/>
    
  </entry>
  
  <entry>
    <title>Idea一些常用设置和快捷操作（持续更新）</title>
    <link href="http://linyishui.top/2020021401.html"/>
    <id>http://linyishui.top/2020021401.html</id>
    <published>2020-02-14T06:33:42.000Z</published>
    <updated>2020-03-24T07:25:25.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Idea一些常用设置和快捷操作"><a href="#Idea一些常用设置和快捷操作" class="headerlink" title="Idea一些常用设置和快捷操作"></a><strong>Idea一些常用设置和快捷操作</strong></h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>​        博主所用Idea为2019.3.3(Ultimate Edition)版本</p><h2 id="第一节-插件"><a href="#第一节-插件" class="headerlink" title="第一节 插件"></a><strong>第一节 插件</strong></h2><h3 id="1-1-背景替换"><a href="#1-1-背景替换" class="headerlink" title="1.1 背景替换"></a><strong>1.1 背景替换</strong></h3><p>&emsp;&emsp;Idea可以设置修改背景图片，【Settings】-&gt;【Appearance】-&gt;【Background Image】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010133.png" alt="背景替换"></p><h3 id="1-2-代码迷你缩放图-CodeGlance"><a href="#1-2-代码迷你缩放图-CodeGlance" class="headerlink" title="1.2 代码迷你缩放图-CodeGlance"></a><strong>1.2 代码迷你缩放图-CodeGlance</strong></h3><p>&emsp;&emsp;插件可以在Idea中联网下载（或者自行下载后安装），【Settings】-&gt;【Plugins】-&gt;【CodeGlance】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010134.png" alt="代码迷你缩放图"></p><p>&emsp;&emsp;安装完毕重启，效果如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010135.png" alt="代码迷你缩放图-效果"></p><h3 id="1-3-翻译-Translation"><a href="#1-3-翻译-Translation" class="headerlink" title="1.3 翻译-Translation"></a><strong>1.3 翻译-Translation</strong></h3><p>&emsp;&emsp;【Settings】-&gt;【Plugins】-&gt;【Translation】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010136.png" alt="代码迷你缩放图-效果"></p><p>&emsp;&emsp;重启后，可勾选一段文字，右击后选择Translate进行翻译。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010137.png" alt="代码迷你缩放图-效果"></p><p>​        效果如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010138.png" alt="代码迷你缩放图-效果"></p><h3 id="1-4-彩虹括号-Rainbow-Brackets"><a href="#1-4-彩虹括号-Rainbow-Brackets" class="headerlink" title="1.4 彩虹括号-Rainbow Brackets"></a><strong>1.4 彩虹括号-Rainbow Brackets</strong></h3><p>&emsp;&emsp;【Settings】-&gt;【Plugins】-&gt;【Rainbow Brackets】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010139.png" alt="代码迷你缩放图-效果"></p><p>​        重启后，观察效果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010140.png" alt="代码迷你缩放图-效果"></p><h3 id="1-5-代码统计-Statistic"><a href="#1-5-代码统计-Statistic" class="headerlink" title="1.5 代码统计-Statistic"></a><strong>1.5 代码统计-Statistic</strong></h3><p>&emsp;&emsp;【Settings】-&gt;【Plugins】-&gt;【Statistic】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010141.png" alt="代码迷你缩放图-效果"></p><p>​        重启后，将统计工具添加到显示栏，【View】-&gt;【Tool Windows】-&gt;【Statistic】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010142.png" alt="代码迷你缩放图-效果"></p><p>​        效果如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010143.png" alt="代码迷你缩放图-效果"></p><h3 id="1-6-接口工具-RestfulToolkit"><a href="#1-6-接口工具-RestfulToolkit" class="headerlink" title="1.6 接口工具-RestfulToolkit"></a><strong>1.6 接口工具-RestfulToolkit</strong></h3><p>&emsp;&emsp;Idea 新版本自带Web，这里使用插件RestfulToolkit，【Settings】-&gt;【Plugins】-&gt;【RestfulToolkit】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010144.png" alt="代码迷你缩放图-效果"></p><p>​        重启后，可在侧栏的RestServices查看项目所有接口API，也可以直接进行接口测试。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010145.png" alt="代码迷你缩放图-效果"></p><h3 id="1-7-Json代码生成-GsonFormat"><a href="#1-7-Json代码生成-GsonFormat" class="headerlink" title="1.7 Json代码生成-GsonFormat"></a><strong>1.7 Json代码生成-GsonFormat</strong></h3><p>​        【Settings】-&gt;【Plugins】-&gt;【GsonFormat】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010146.png" alt="代码迷你缩放图-效果"></p><p>​        重启后，新建一个类Test，类中鼠标右键，选择Generate。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010147.png" alt="代码迷你缩放图-效果"></p><p>​        然后点选GsonFormat。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010148.png" alt="代码迷你缩放图-效果"></p><p>​        在弹出的输入框中键入要转换的Json串。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010149.png" alt="代码迷你缩放图-效果"></p><p>​        插件会自动识别数据类型。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010150.png" alt="代码迷你缩放图-效果"></p><p>​        最终会生成如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * id : 1</span></span><br><span class="line"><span class="comment">     * name : demoData</span></span><br><span class="line"><span class="comment">     * sort : 1</span></span><br><span class="line"><span class="comment">     * enabled : true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sort;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSort</span><span class="params">(<span class="keyword">int</span> sort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sort = sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二节-Idea设置"><a href="#第二节-Idea设置" class="headerlink" title="第二节 Idea设置"></a><strong>第二节 Idea设置</strong></h2><h3 id="2-1-生成serialVersionUID"><a href="#2-1-生成serialVersionUID" class="headerlink" title="2.1 生成serialVersionUID"></a><strong>2.1 生成serialVersionUID</strong></h3><p>&emsp;&emsp;设置：【File】-&gt;【Settings】-&gt;【Editor】-&gt;【Inspections】-&gt;【Java】-&gt;【Serialization issues】-&gt;【Serializable class without ‘serialVersionUID’】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010126.png" alt="设置生成serialVersionUID"></p><p>&emsp;&emsp;鼠标移动到类名处，【Alt】+【Enter】，即可生成serialVersionUID。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010127.png" alt="生成serialVersionUID"></p>]]></content>
    
    <summary type="html">
    
      Idea一些常用设置和快捷操作
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="idea" scheme="http://linyishui.top/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>面向对象-多态</title>
    <link href="http://linyishui.top/2020021301.html"/>
    <id>http://linyishui.top/2020021301.html</id>
    <published>2020-02-13T06:47:11.000Z</published>
    <updated>2020-03-13T10:01:13.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-什么是多态"><a href="#1-1-什么是多态" class="headerlink" title="1.1 什么是多态"></a><strong>1.1 什么是多态</strong></h3><p>&emsp;&emsp;多态，按照字面意思就是具有多种形态，用来描述同一个行为具有多种表现形式或形态能力，作为面向对象的三个特性（继承、封装和多态）之一。</p><p>&emsp;&emsp;多态就是同一个接口，使用不同的实例而执行不同操作，多态性是对象多种表现形式的体现，同一个事件发生在不同的对象上会产生不同的结果。</p><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a><strong>1.2 优点</strong></h3><blockquote><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul></blockquote><h3 id="1-3-在Java中的实现方式"><a href="#1-3-在Java中的实现方式" class="headerlink" title="1.3 在Java中的实现方式"></a><strong>1.3 在Java中的实现方式</strong></h3><blockquote><p>多态存在的三个必要条件：</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul></blockquote><p>&emsp;&emsp;多态又可以分为<strong>编译时多态</strong>和<strong>运行时多态</strong>。</p><blockquote><p>Java中使用多态特性的主要有:</p><ul><li><strong>方法重载</strong>(overload)：同一个类中可以创建多个具有相同名字的方法，但可具有不同的参数列表、返回值类型，调用方法时通过传递的参数类型来决定具体使用哪个方法，体现了多态性。是一种<strong>编译时多态</strong>，运行时调用的是确定的方法。</li><li><strong>方法重写</strong>(overrite)：子类可继承父类中的方法，但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。重写的参数列表和返回类型均不可修改，要想调用父类中被重写的方法，则必须使用关键字super。是一种<strong>运行时多态</strong>，在运行时有不同的执行效果。</li><li><strong>实现接口</strong>：对接口方法的实现，是一种<strong>运行时多态</strong>。</li><li><strong>实现抽象类的一个方法</strong>：是一种<strong>运行时多态</strong>。</li></ul></blockquote><hr><h2 id="第二节-实现原理"><a href="#第二节-实现原理" class="headerlink" title="第二节 实现原理"></a><strong>第二节 实现原理</strong></h2><p>&emsp;&emsp;多态的底层实现是<strong>动态绑定</strong>，即在运行时才把方法调用与方法实现关联起来，通过<strong>方法表</strong>来实现。动态绑定涉及到一些JVM知识，如果对JVM不够了解可以先补充一些相关知识。</p><h3 id="2-1-虚函数"><a href="#2-1-虚函数" class="headerlink" title="2.1 虚函数"></a><strong>2.1 虚函数</strong></h3><p>&emsp;&emsp;虚函数的存在是为了多态。</p><p>&emsp;&emsp;Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p><h3 id="2-2-静态绑定与动态绑定"><a href="#2-2-静态绑定与动态绑定" class="headerlink" title="2.2 静态绑定与动态绑定"></a><strong>2.2 静态绑定与动态绑定</strong></h3><blockquote><p>JVM 的方法调用指令有五个，分别是：</p><ul><li>invokestatic：调用静态方法</li><li>invokespecial：调用实例构造器&lt; init &gt;方法、私有方法和父类方法</li><li>invokevirtual：调用虚方法</li><li>invokeinterface：调用接口方法，运行时确定具体实现</li><li>invokedynamic：运行时动态解析所引用的方法，然后再执行，用于支持动态类型语言。</li></ul></blockquote><p>&emsp;&emsp;其中，invokestatic 和 invokespecial 用于静态绑定，invokevirtual 和 invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于虚方法和接口方法。</p><p>&emsp;&emsp;<strong>静态绑定</strong>在编译期就已经确定，这是因为静态方法、构造器方法、私有方法和父类方法可以唯一确定。这些方法的符号引用在类加载的解析阶段就会解析成直接引用。因此这些方法也被称为非虚方法，与之相对的便是虚方法。</p><p>&emsp;&emsp;<strong>动态绑定</strong>是指在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><p>&emsp;&emsp;虚方法的方法调用与方法实现的关联（也就是分派）有两种，<strong>一种是在编译期确定，被称为静态分派，比如方法的重载</strong>；<strong>一种是在运行时确定，被称为动态分派，比如方法的重写</strong>。对象方法基本上都是虚方法。</p><p>&emsp;&emsp;这里需要特别说明的是，final 方法由于不能被覆盖，可以唯一确定，因此 Java 语言规范规定 final 方法属于非虚方法，但仍然使用 invokevirtual 指令调用。静态绑定、动态绑定的概念和虚方法、非虚方法的概念是两个不同的概念。</p><h3 id="2-3-虚拟机中多态的实现"><a href="#2-3-虚拟机中多态的实现" class="headerlink" title="2.3 虚拟机中多态的实现"></a><strong>2.3 虚拟机中多态的实现</strong></h3><p>&emsp;&emsp;虚拟机栈中会存放当前方法调用的栈帧，在栈帧中，存储着局部变量表、操作栈、动态连接、返回地址和其他附加信息。<strong>多态的实现过程，就是方法调用动态分派的过程</strong>，通过栈帧的信息去找到被调用方法的具体实现，然后使用这个具体实现的直接引用完成方法调用。</p><h4 id="2-3-1-调用虚方法的执行过程"><a href="#2-3-1-调用虚方法的执行过程" class="headerlink" title="2.3.1 调用虚方法的执行过程"></a><strong>2.3.1 调用虚方法的执行过程</strong></h4><p>&emsp;&emsp;以 invokevirtual 指令为例，在执行时，大致可以分为以下几步：</p><blockquote><ol><li>先从操作栈中找到对象的实际类型class；</li><li>找到class中与被调用方法签名相同的方法，如果有访问权限就返回这个方法的直接引用，如果没有访问权限就报错 java.lang.IllegalAccessError；</li><li>如果第 2 步找不到相符的方法，就去搜索 class 的父类，按照继承关系自下而上依次执行第 2 步的操作；</li><li>如果第 3 步找不到相符的方法，就报错java.lang.AbstractMethodError；</li></ol></blockquote><p>&emsp;&emsp;可以看到，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p><p>&emsp;&emsp;实际上，商用虚拟机为了保证性能，通常会使用<strong>虚方法表</strong>和<strong>接口方法表</strong>，而不是每次都执行一遍上面的步骤。以虚方法表为例，虚方法表在类加载的解析阶段填充完成，其中存储了所有方法的直接引用。也就是说，动态分派在填充虚方法表的时候就已经完成了。</p><p>&emsp;&emsp;在子类的虚方法表中，如果子类覆盖了父类的某个方法，则这个方法的直接引用指向子类的实现；而子类没有覆盖的那些方法，比如 Object 的方法，直接引用指向父类或 Object 的实现。</p><h4 id="2-3-2-调用重写的虚方法"><a href="#2-3-2-调用重写的虚方法" class="headerlink" title="2.3.2 调用重写的虚方法"></a><strong>2.3.2 调用重写的虚方法</strong></h4><p>&emsp;&emsp;假设有类A和类B，B为A的子类，并重写了类A的method()方法，两个方法分别打印不同的输出。根据下列调用猜想一下实际的输出。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">B </span><span class="keyword">b </span>= new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">a.method();</span></span><br><span class="line"><span class="keyword">b.method();</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很明显最终都会打印B中method()的输出，编译时通过A类的method()验证，运行时却实际调用的B类的method()。因为不管编译时引用变量是什么数据类型，最终在方法表中存放的仍是运行时要执行的引用。</p><h4 id="2-3-3-方法表在方法调用中的工作"><a href="#2-3-3-方法表在方法调用中的工作" class="headerlink" title="2.3.3 方法表在方法调用中的工作"></a><strong>2.3.3 方法表在方法调用中的工作</strong></h4><p>&emsp;&emsp;在JVM执行Java字节码时，类型信息被存放在方法区中，通常为了优化对象调用方法的速度，方法区的类型信息中增加一个指针，该指针指向一张记录该类方法入口的表（称为<strong>方法表</strong>），表中的每一项都是指向相应方法的指针。</p><p>&emsp;&emsp;由于Java的单继承机制，一个类只能继承一个父类，而所有的类又都继承自Object类。方法表中最先存放的是Object类的方法，接下来是该类的父类的方法，最后是该类本身的方法。这里关键的地方在于，如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。</p><blockquote><p><em>注意这里只有非私有的实例方法才会出现，并且静态方法也不会出现在这里，原因很容易理解：静态方法跟对象无关，可以将方法地址直接引用，而不像实例方法需要间接引用。</em></p><p><em>更深入地讲，静态方法是由虚拟机指令invokestatic调用的，私有方法和构造函数则是由invokespecial指令调用，只有被invokevirtual和invokeinterface指令调用的方法才会在方法表中出现。</em></p></blockquote><p>&emsp;&emsp;由于以上方法的排列特性（Object——父类——子类），使得方法表的偏移量总是固定的。例如，对于任何类来说，其方法表中equals方法的偏移量总是一个定值，所有继承某父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。</p><p>&emsp;&emsp;前面说过，方法表中的表项都是指向该类对应方法的指针，这里就开始了多态的实现：在父类A的方法表中，method方法的指针指向的就是A的method方法入口。而对于子类B来说，它的方法表中的method方法则会指向其自身的method方法而非其父类的（这在类加载器载入该类时已经保证，同时JVM会保证总是能从对象引用指向正确的类型信息）。</p><p>&emsp;&emsp;结合方法指针偏移量是固定的以及指针总是指向实际类的方法域，我们不难发现多态的机制就在这里：在调用方法时，实际上必须<strong>首先完成实例方法的符号引用解析</strong>，结果是该<strong>符号引用被解析为方法表的偏移量</strong>。虚拟机通过对象引用得到方法区中类型信息的入口，查询类的方法表，当将子类对象声明为父类类型时，形式上调用的是父类方法，此时虚拟机会从实际类的方法表（虽然声明的是父类，但是实际上这里的类型信息中存放的是子类的信息）中查找该方法名对应的指针（这里用“查找”实际上是不合适的，前面提到过，方法的偏移量是固定的，所以只需根据偏移量就能获得指针），进而就能指向实际类的方法了。</p><h4 id="2-3-4-实现接口的多态"><a href="#2-3-4-实现接口的多态" class="headerlink" title="2.3.4 实现接口的多态"></a><strong>2.3.4 实现接口的多态</strong></h4><p>&emsp;&emsp;上上面的过程仅仅是利用继承实现多态的内部机制，多态的另外一种实现方式：实现接口相比而言就更加复杂，原因在于，Java的单继承保证了类的线性关系，而接口可以同时实现多个，这样光凭偏移量就很难准确获得方法的指针。所以在JVM中，多态的实例方法调用实际上有两种指令：</p><blockquote><ul><li>invokevirtual指令用于调用声明为类引用的方法。</li><li>invokeinterface指令用于调用声明为接口的方法。</li></ul></blockquote><p>&emsp;&emsp;当使用invokeinterface指令调用方法时，就不能采用固定偏移量的办法，只能老老实实挨个找了（当然实际实现并不一定如此，JVM规范并没有规定究竟如何实现这种查找，不同的JVM实现可以有不同的优化算法来提高搜索效率）。我们不难看出，在性能上，调用接口引用的方法通常总是比调用类的引用的方法要慢。这也告诉我们，在类和接口之间优先选择接口作为设计并不总是正确的。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.runoob.com/java/java-polymorphism.html" title="Title" target="_blank" rel="noopener">Java多态</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍面向对象-多态，内容包括：简介和实现原理等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Spring Boot（持续更新）</title>
    <link href="http://linyishui.top/2020021201.html"/>
    <id>http://linyishui.top/2020021201.html</id>
    <published>2020-02-12T10:47:45.000Z</published>
    <updated>2020-03-24T07:07:45.384Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问：SpringBoot的自动配置流程？"><a href="#问：SpringBoot的自动配置流程？" class="headerlink" title="问：SpringBoot的自动配置流程？"></a><strong>问：SpringBoot的自动配置流程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？"><a href="#问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？" class="headerlink" title="问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？"></a><strong>问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Spring Boot相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——其它（持续更新）</title>
    <link href="http://linyishui.top/2020021101.html"/>
    <id>http://linyishui.top/2020021101.html</id>
    <published>2020-02-11T10:46:18.000Z</published>
    <updated>2020-03-24T07:07:56.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问：讲一下用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？"><a href="#问：讲一下用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？" class="headerlink" title="问：讲一下用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？"></a><strong>问：讲一下用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库？"><a href="#问：讲一下Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库？" class="headerlink" title="问：讲一下Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库？"></a><strong>问：讲一下Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Mybatis基于接口完成查询的过程及原理？"><a href="#问：讲一下Mybatis基于接口完成查询的过程及原理？" class="headerlink" title="问：讲一下Mybatis基于接口完成查询的过程及原理？"></a><strong>问：讲一下Mybatis基于接口完成查询的过程及原理？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Mybatis的一级缓存和二级缓存？"><a href="#问：讲一下Mybatis的一级缓存和二级缓存？" class="headerlink" title="问：讲一下Mybatis的一级缓存和二级缓存？"></a><strong>问：讲一下Mybatis的一级缓存和二级缓存？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Quartz是如何完成定时任务的；集群同步机制？"><a href="#问：讲一下Quartz是如何完成定时任务的；集群同步机制？" class="headerlink" title="问：讲一下Quartz是如何完成定时任务的；集群同步机制？"></a><strong>问：讲一下Quartz是如何完成定时任务的；集群同步机制？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details>]]></content>
    
    <summary type="html">
    
      整理面试中常问的其它问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean</title>
    <link href="http://linyishui.top/2020021001.html"/>
    <id>http://linyishui.top/2020021001.html</id>
    <published>2020-02-10T07:41:41.000Z</published>
    <updated>2020-03-24T02:14:52.162Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a><strong>Spring Bean</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-Spring-Bean是什么？"><a href="#1-1-Spring-Bean是什么？" class="headerlink" title="1.1 Spring Bean是什么？"></a><strong>1.1 Spring Bean是什么？</strong></h3><p>&emsp;&emsp;在Spring中，用来构成应用程序主干并由Spring IoC容器管理的对象就是bean，所以Spring Bean是一个由Spring IoC容器实例化、组装和管理的对象。</p><h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a><strong>1.2 概念</strong></h3><blockquote><ul><li><strong>IoC</strong>：IoC(Inversion of Control)即控制反转，通过依赖注入的方式动态生成依赖对象并注入被依赖对象中。</li><li><strong>Bean容器</strong>：即Spring IoC容器，管理对象和依赖，以及依赖的注入。</li><li><strong>Bean</strong>：Java对象，遵循Bean规范，由Bean容器生成。</li><li><strong>Bean规范</strong>：满足几个条件，包括所有属性为private，提供默认构造方法，提供getter和setter，实现serializable接口。</li></ul></blockquote><hr><h2 id="第二节-生命周期"><a href="#第二节-生命周期" class="headerlink" title="第二节 生命周期"></a><strong>第二节 生命周期</strong></h2><p>&emsp;&emsp;Java对象在new时创建，不被引用后被GC回收，而Spring IoC容器托管的对象的生命周期则由容器控制。Spring Bean的生命周期如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/754a34e03cfaa40008de8e2b9c1b815c_1440w.jpg" alt="Spring Bean的生命周期"></p><hr><h2 id="第三节-解析"><a href="#第三节-解析" class="headerlink" title="第三节 解析"></a><strong>第三节 解析</strong></h2><h3 id="3-1-实例化Bean"><a href="#3-1-实例化Bean" class="headerlink" title="3.1 实例化Bean"></a><strong>3.1 实例化Bean</strong></h3><p>&emsp;&emsp;对于BeanFactory容器，当用户向容器请求一个尚未初始化的Bean时，或者是初始化Bean的时候需要注入另一个尚未初始化的依赖时，容器会调用createBean()进行实例化。</p><p>&emsp;&emsp;对于ApplicationContext容器，容器启动后就实例化所有Bean。</p><p>&emsp;&emsp;容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h3 id="3-2-依赖注入"><a href="#3-2-依赖注入" class="headerlink" title="3.2 依赖注入"></a><strong>3.2 依赖注入</strong></h3><p>&emsp;&emsp;设置对象属性，按照Spring上下文对实例化的Bean进行配置</p><h3 id="3-3-BeanNameAware"><a href="#3-3-BeanNameAware" class="headerlink" title="3.3 BeanNameAware"></a><strong>3.3 BeanNameAware</strong></h3><p>&emsp;&emsp;紧接着，Spring会检测该Bean对象是否实现了BeanNameAware接口，如果实现了则Spring将Bean的ID传递给setBeanName()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现此接口主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-BeanFactoryAware"><a href="#3-4-BeanFactoryAware" class="headerlink" title="3.4 BeanFactoryAware"></a><strong>3.4 BeanFactoryAware</strong></h3><p>&emsp;&emsp;继续检测Bean是否实现了BeanFactoryAware接口，如果实现了，则调用setBeanFactory()方法，并传递BeanFactory实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-ApplicationContextAware"><a href="#3-5-ApplicationContextAware" class="headerlink" title="3.5 ApplicationContextAware"></a><strong>3.5 ApplicationContextAware</strong></h3><p>&emsp;&emsp;继续检测Bean是否实现了ApplicationContextAware接口，如果实现了，则调用setApplicationContext()方法，并传递应用上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext的参数传入，而Spring容器在调用setBeanDactory前需要指定（注入）setBeanDactory里的参数BeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-BeanPostProcessor"><a href="#3-6-BeanPostProcessor" class="headerlink" title="3.6 BeanPostProcessor"></a><strong>3.6 BeanPostProcessor</strong></h3><p>&emsp;&emsp;当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> BeanPostProcessor &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> <span class="built_in">Object</span> postProcessBeforeInitialization(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) throws BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> <span class="built_in">Object</span> postProcessAfterInitialization(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) throws BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该接口提供了两个函数：</p><ul><li>postProcessBeforeInitialization(Object bean, String beanName)：当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会先于InitialzationBean执行，因此称为前置处理。所有Aware接口的注入就是在这一步完成的。</li><li>postProcessAfterInitialization(Object bean, String beanName)：当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会在InitialzationBean完成后执行，因此称为后置处理。</li></ul></blockquote><h3 id="3-7-InitializingBean与init-method"><a href="#3-7-InitializingBean与init-method" class="headerlink" title="3.7 InitializingBean与init-method"></a><strong>3.7 InitializingBean与init-method</strong></h3><p>&emsp;&emsp;当BeanPostProcessor的前置处理完成后就会进入本阶段，调用afterPropertiesSet()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 </p><p>&emsp;&emsp;若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</p><h3 id="3-8-DisposableBean和destroy-method"><a href="#3-8-DisposableBean和destroy-method" class="headerlink" title="3.8 DisposableBean和destroy-method"></a><strong>3.8 DisposableBean和destroy-method</strong></h3><p>&emsp;&emsp;经过以上的工作后，Bean将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁。</p><p>&emsp;&emsp;Bean可以实现DisposableBean接口，和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客、文章或书籍：</em></p><blockquote><p><a href="https://www.awaimai.com/2596.html" title="Title" target="_blank" rel="noopener">spring bean是什么</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/38597960" title="Title" target="_blank" rel="noopener">Spring中Bean的生命周期是怎样的？</a></p></blockquote><p><em>因博客主未标明不可转载或引用，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理Spring Bean。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring" scheme="http://linyishui.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>gitlab-ci.yml语法</title>
    <link href="http://linyishui.top/2020020701.html"/>
    <id>http://linyishui.top/2020020701.html</id>
    <published>2020-02-07T06:31:33.000Z</published>
    <updated>2020-03-09T10:48:52.854Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="gitlab-ci"><a href="#gitlab-ci" class="headerlink" title="gitlab-ci"></a><strong>gitlab-ci</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;自7.12版本开始，GitLab CI使用YAML文件来管理项目配置。此文件存放于项目仓库的根目录，定义了项目该如何构建。</p><blockquote><ul><li>Gitlab-CI ：<a href="https://docs.gitlab.com/ce/ci/quick_start/README.html" title="Title" target="_blank" rel="noopener">Gitlab-CI</a>是GitLab Continuous Integration（Gitlab持续集成）的简称。从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI，并且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。</li><li>Gitlab-runner ：<a href="https://docs.gitlab.com/ce/ci/runners/README.html" title="Title" target="_blank" rel="noopener">Gitlab-runner</a>是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的相互隔离的机器（或虚拟机）。考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner不建议和Gitlab安装在同一台机器上。Gitlab Runner分为两种，Shared runners和Specific runners。Specific runners只能被指定的项目使用，Shared runners则可以运行所有开启 Allow shared runners选项的项目。</li><li>Pipeline ：管道，每次commit或MR都会执行一次pipeline构建任务，包含多个阶段如测试、编译。</li><li>Stage ：阶段，每个Pipeline有多个Stage，从上向下执行，前一个执行成功才能执行下一个。</li><li>Job ：任务，CI/CD的最小运行单位，表示在指定Stage下执行的任务工作，可以有多个Job，并行执行。</li><li>Badges ：徽章，当Pipelines执行完成，会生成徽章，你可以将这些徽章加入到你的README.md文件或者你的网站。</li></ul></blockquote><hr><h2 id="第二节-案例"><a href="#第二节-案例" class="headerlink" title="第二节 案例"></a><strong>第二节 案例</strong></h2><p>&emsp;&emsp;如下面的两个任务由Runners接管，并由服务器中的runner执行，每个任务独立运行，script可以直接执行系统命令或脚本。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">job1:</span></span><br><span class="line"><span class="symbol">  script:</span> <span class="string">"execute-script-for-job1"</span></span><br><span class="line">  </span><br><span class="line"><span class="symbol">job2:</span></span><br><span class="line"><span class="symbol">  script:</span> <span class="string">"execute-script-for-job2"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个复杂任务如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># image和services这两个关键字允许使用一个自定义的Docker镜像和一系列的服务，并且可以用于整个job周期。</span></span><br><span class="line"><span class="attr">image:</span> <span class="attr">ruby:2.1</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">postgres</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="comment"># before_script用来定义所有job之前运行的命令，包括deploy(部署) jobs，但是在修复artifacts之后。它可以是一个数组或者是多行字符串。</span></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bundle</span> <span class="string">install</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="comment"># after_script用来定义所有job之后运行的命令。它必须是一个数组或者是多行字符串</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="string">secrets</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="comment"># stages用来定义可以被job调用的stages。stages的规范允许有灵活的多级pipelines。</span></span><br><span class="line"><span class="comment"># stages中的元素顺序决定了对应job的执行顺序：</span></span><br><span class="line"><span class="comment">#  1. 相同stage的job可以平行执行。</span></span><br><span class="line"><span class="comment">#  2. 下一个stage的job会在前一个stage的job成功后开始执行。</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy</span></span><br><span class="line"><span class="comment"># 如果.gitlab-ci.yml中没有定义stages，那么job's stages 会默认定义为 build，test 和 deploy。</span></span><br><span class="line"><span class="comment"># 如果一个job没有指定stage，那么这个任务会分配到test stage。</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="comment"># GItLab CI 允许在.gitlab-ci.yml文件中添加变量，并在job环境中起作用。因为这些配置是存储在git仓库中，所以最好是存储项目的非敏感配置，例如： </span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line"><span class="attr">  DATABASE_URL:</span><span class="string">"postgres://postgres@postgres/my_database"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job1:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">execute-script-for-job1</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">docker</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面列出保留字段，这些保留字段不能被定义为job名称：</p><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:center">是否必须</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">image</td><td style="text-align:center">否</td><td style="text-align:left">用于docker镜像，查看docker文档</td></tr><tr><td style="text-align:left">services</td><td style="text-align:center">否</td><td style="text-align:left">用于docker服务，查看docker文档</td></tr><tr><td style="text-align:left">stages</td><td style="text-align:center">否</td><td style="text-align:left">定义构建阶段</td></tr><tr><td style="text-align:left">types</td><td style="text-align:center">否</td><td style="text-align:left">stages 的别名(已废除)</td></tr><tr><td style="text-align:left">before_script</td><td style="text-align:center">否</td><td style="text-align:left">定义在每个job之前运行的命令</td></tr><tr><td style="text-align:left">after_script</td><td style="text-align:center">否</td><td style="text-align:left">定义在每个job之后运行的命令</td></tr><tr><td style="text-align:left">variable</td><td style="text-align:center">否</td><td style="text-align:left">定义构建变量</td></tr><tr><td style="text-align:left">cache</td><td style="text-align:center">否</td><td style="text-align:left">定义一组文件列表，可在后续运行中使用</td></tr></tbody></table><p>&emsp;&emsp;.gitlab-ci.yml的具体写法，以及关键字含义见： <a href="https://docs.gitlab.com/ee/ci/yaml/README.html" title="Title" target="_blank" rel="noopener">GitLab CI/CD Pipeline Configuration Reference</a></p><p>&emsp;&emsp;关于gitlab为什么使用.gitlab-ci.yml,见： <a href="https://about.gitlab.com/blog/2015/05/06/why-were-replacing-gitlab-ci-jobs-with-gitlab-ci-dot-yml/" title="Title" target="_blank" rel="noopener">Why we’re replacing GitLab CI jobs with .gitlab-ci.yml</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://fennay.github.io/gitlab-ci-cn/gitlab-ci-yaml.html" title="Title" target="_blank" rel="noopener">通过.gitlab-ci.yml配置任务</a></p></blockquote><blockquote><p><a href="https://docs.gitlab.com/ee/ci/examples/README.html#cicd-examples" title="Title" target="_blank" rel="noopener">CI/CD examples</a></p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000011881435" title="Title" target="_blank" rel="noopener">gitlab-ci配置详解(一)</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍GitLab-CI的配置文件gitlab-ci.yml的语法。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
      <category term="gitlab" scheme="http://linyishui.top/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>GitLab配置CI持续集成（未完成）</title>
    <link href="http://linyishui.top/2020020601.html"/>
    <id>http://linyishui.top/2020020601.html</id>
    <published>2020-02-06T06:09:42.000Z</published>
    <updated>2020-03-24T07:08:32.969Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitLab配置CI持续集成"><a href="#GitLab配置CI持续集成" class="headerlink" title="GitLab配置CI持续集成"></a><strong>GitLab配置CI持续集成</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a><strong>1.1 概念</strong></h3><blockquote><ul><li>Gitlab-CI ：<a href="https://docs.gitlab.com/ce/ci/quick_start/README.html" title="Title" target="_blank" rel="noopener">Gitlab-CI</a>是GitLab Continuous Integration（Gitlab持续集成）的简称。从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI，并且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。</li><li>Gitlab-runner ：<a href="https://docs.gitlab.com/ce/ci/runners/README.html" title="Title" target="_blank" rel="noopener">Gitlab-runner</a>是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的相互隔离的机器（或虚拟机）。考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner不建议和Gitlab安装在同一台机器上。Gitlab Runner分为两种，Shared runners和Specific runners。Specific runners只能被指定的项目使用，Shared runners则可以运行所有开启 Allow shared runners选项的项目。</li><li>Pipeline ：管道，每次commit或MR都会执行一次pipeline构建任务，包含多个阶段如测试、编译。</li><li>Stage ：阶段，每个Pipeline有多个Stage，从上向下执行，前一个执行成功才能执行下一个。</li><li>Job ：任务，CI/CD的最小运行单位，表示在指定Stage下执行的任务工作，可以有多个Job，并行执行。</li><li>Badges ：徽章，当Pipelines执行完成，会生成徽章，你可以将这些徽章加入到你的README.md文件或者你的网站。</li></ul></blockquote><h3 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a><strong>1.2 特性</strong></h3><blockquote><p>gitlab ci/cd具有以下特性：</p><ul><li>跨平台支持：只要支持go语言的平台均可以在上面进行ci,目前基本涵盖了大部分的操作系统．</li><li>多语言支持：构建时是通过脚本触发，因此基本上支持所有的语言．</li><li>Pipeline：可以通过不同的阶段形成工作流</li><li>支持docker：可以构建docker镜像，同时也支持触发在Kubernetes允许．</li></ul></blockquote><p>&emsp;&emsp;所有特性：<a href="https://about.gitlab.com/stages-devops-lifecycle/continuous-integration/" title="Title" target="_blank" rel="noopener">GitLab Continuous Integration (CI) &amp; Continuous Delivery (CD)</a></p><h3 id="1-3-结构"><a href="#1-3-结构" class="headerlink" title="1.3 结构"></a><strong>1.3 结构</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010103.png" alt="CI/CD架构"></p><p>&emsp;&emsp;gitlab ci/cd是由独立的runner程序完成，runner采用go语言编写，因此可以很好的进行跨平台，通常可以将runner部署到任何gitlab server之外的服务器，从而避免对gitlab server的影响．</p><p>&emsp;&emsp;runner项目：<a href="https://gitlab.com/gitlab-org/gitlab-runner" title="Title" target="_blank" rel="noopener">gitlab-runner</a></p><h2 id="第二节-案例"><a href="#第二节-案例" class="headerlink" title="第二节 案例"></a><strong>第二节 案例</strong></h2><h3 id="2-1-新建一个Spring-Boot项目"><a href="#2-1-新建一个Spring-Boot项目" class="headerlink" title="2.1 新建一个Spring Boot项目"></a><strong>2.1 新建一个Spring Boot项目</strong></h3><p>&emsp;&emsp;新建项目，添加一些demo代码，运行测试。</p><h3 id="2-2-新建GitLab项目"><a href="#2-2-新建GitLab项目" class="headerlink" title="2.2 新建GitLab项目"></a><strong>2.2 新建GitLab项目</strong></h3><p>&emsp;&emsp;登陆GitLab创建项目，并复制URL。</p><p>&emsp;&emsp;提交项目代码到对应URL。</p><h3 id="2-3-添加-gitlab-ci文件"><a href="#2-3-添加-gitlab-ci文件" class="headerlink" title="2.3 添加.gitlab-ci文件"></a><strong>2.3 添加.gitlab-ci文件</strong></h3><p>&emsp;&emsp;创建.gitlab-ci.yml，【.gitlab-ci.yml】用来配置 CI 用你的项目中做哪些操作。当有新内容push到仓库后，GitLab会查找是否有.gitlab-ci.yml文件，如果文件存在，Runners将会根据该文件的内容开始 build 本次 commit。</p><p>&emsp;&emsp;gitlab通过在项目的根目录放置.gitlab-ci.yml文件来触发pipline，文件书写遵循yml语法，因此，概括来说gitlab ci/cd只需要两步。</p><blockquote><ul><li>写好.gitlab-ci.yml文件，并放置到项目根目录</li><li>配置好gitlab runner．完成后，提交代码时会自动根据gitlab-ci.yml的触发条件进行执行相应的stage.</li></ul></blockquote><p>&emsp;&emsp;如下简单的.gitlab-ci.yml - maven项目，更多案例可以参考官网<a href="https://docs.gitlab.com/ee/ci/examples/README.html#cicd-examples" title="Title" target="_blank" rel="noopener">CI/CD examples</a>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">image</span>: <span class="attribute">docker</span>:latest</span><br><span class="line"><span class="attribute">services</span>:</span><br><span class="line">  - <span class="attribute">docker</span>:dind</span><br><span class="line"></span><br><span class="line"><span class="attribute">stages</span>:</span><br><span class="line">  - build</span><br><span class="line">  - package</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line"><span class="attribute">maven-build</span>:</span><br><span class="line">  <span class="attribute">image</span>: <span class="attribute">maven</span>:<span class="number">3</span>-jdk-<span class="number">8</span></span><br><span class="line">  <span class="attribute">stage</span>: build</span><br><span class="line">  <span class="attribute">script</span>: <span class="string">"mvn package"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;配置好.gitlab-ci.yml文件之后，只要把它加入git后然后推送到远程仓库，CI就会开始自动化集成</p><h3 id="2-4-配置一个Runner"><a href="#2-4-配置一个Runner" class="headerlink" title="2.4 配置一个Runner"></a><strong>2.4 配置一个Runner</strong></h3><p>&emsp;&emsp;runner配置主要分为三步:</p><blockquote><ul><li>首先安装runner安装脚本，具体见：<a href="https://docs.gitlab.com/runner/#install-gitlab-runner" title="Title" target="_blank" rel="noopener">Install GitLab Runner</a></li><li>然后注册runner到gitlab：<a href="https://docs.gitlab.com/runner/#register-gitlab-runner" title="Title" target="_blank" rel="noopener">Register GitLab Runner</a></li><li>更多配置见：<a href="https://docs.gitlab.com/runner/executors/README.html" title="Title" target="_blank" rel="noopener">Executors</a></li></ul></blockquote><p>&emsp;&emsp;登陆服务器安装gitlab-ci-multi-runner，笔者是一台Centos服务器。</p><blockquote><p>考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner不建议和Gitlab安装在同一台机器上，但笔者因为只有一台服务器所以先布置在一起了。</p></blockquote><ol><li>添加repository</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:<span class="regexp">//</span>packages.gitlab.com<span class="regexp">/install/</span>repositories<span class="regexp">/runner/gi</span>tlab-ci-multi-runner<span class="regexp">/script.rpm.sh | sudo bash</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装包</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> gitlab-runner</span><br></pre></td></tr></table></figure><ol start="3"><li>注册runner</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner <span class="keyword">register</span></span><br></pre></td></tr></table></figure><blockquote><p>注册共享的Runner需要gitlab的admin权限</p><ol><li>输入Gitlab CI地址</li><li>输入项目CI token</li><li>输入 Runner 描述</li><li>输入 Runner 标签，可以多个，用逗号隔开</li><li>输入 Runner 执行的语言 (e.g. shell)</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010105.png" alt="CI/CD"></p><p>&emsp;&emsp;相关数据值可以在登录gitlab之后，下图所示位置找到，先点击右上方Admin Settings，再找到左侧列表的runners</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010104.png" alt="CI/CD"></p><p>&emsp;&emsp;注册完成之后，GitLab-CI立刻就会多出一条Runner记录，启动runner，点击为Project启用Runner</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ci-<span class="keyword">multi-runner </span><span class="keyword">install</span></span><br><span class="line"><span class="keyword">gitlab-ci-multi-runner </span>start</span><br></pre></td></tr></table></figure><h2 id="2-5-提交代码"><a href="#2-5-提交代码" class="headerlink" title="2.5 提交代码"></a><strong>2.5 提交代码</strong></h2><p>&emsp;&emsp;推送到服务器后，pipeline一直处于struck状态，提示：This job is stuck, because the project doesn’t have any runners online assigned to it. Go to Runners page.</p><p>&emsp;&emsp;检查一下确认Runner处于正常状态。</p><p>&emsp;&emsp;出现这种情况可能是因为我们注册的Runner设置了TAG，但Job并没有。所以要按照以下4个步骤使我们的Runner能够在没有标记的情况下执行：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010108.png" alt="CI/CD"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010109.png" alt="CI/CD"></p><p>&emsp;&emsp;配置后Job成功运行，但是检查失败了，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010107.png" alt="CI/CD"></p><p>&emsp;&emsp;很明显是因为服务器缺失Maven工具，登陆服务器，安装Maven。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> maven</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次提交，问题解决，maven开始下载依赖。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010110.png" alt="CI/CD"></p><p>&emsp;&emsp;执行成功。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010111.png" alt="CI/CD"></p><h2 id="2-6-扩展"><a href="#2-6-扩展" class="headerlink" title="2.6 扩展"></a><strong>2.6 扩展</strong></h2><p>&emsp;&emsp;未完待续</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.jianshu.com/p/705428ca1410" title="Title" target="_blank" rel="noopener">基于Gitlab CI搭建持续集成环境</a></p></blockquote><blockquote><p><a href="https://docs.gitlab.com/ee/ci/examples/deploy_spring_boot_to_cloud_foundry/index.html" title="Title" target="_blank" rel="noopener">Deploy a Spring Boot application to Cloud Foundry with GitLab CI/CD</a></p></blockquote><blockquote><p><a href="https://about.gitlab.com/blog/2016/12/14/continuous-delivery-of-a-spring-boot-application-with-gitlab-ci-and-kubernetes/" title="Title" target="_blank" rel="noopener">Continuous delivery of a Spring Boot application with GitLab CI and Kubernetes</a></p></blockquote><blockquote><p><a href="https://medium.com/@deeksha.sharma25/spring-boot-micro-service-with-gitlab-ci-281c6679b3f8" title="Title" target="_blank" rel="noopener">Spring Boot Micro Service with gitlab CI</a></p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000007180257" title="Title" target="_blank" rel="noopener">GitLab-CI安装</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理GitLab简单配置CI流程，内容包括：简介，案例等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="gitlab" scheme="http://linyishui.top/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>CI/CD-持续集成和持续交付 &lt;整&gt;</title>
    <link href="http://linyishui.top/2020020501.html"/>
    <id>http://linyishui.top/2020020501.html</id>
    <published>2020-02-05T09:15:24.000Z</published>
    <updated>2020-03-06T11:02:50.130Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a><strong>CI/CD</strong></h1><h2 id="第一节-介绍"><a href="#第一节-介绍" class="headerlink" title="第一节 介绍"></a><strong>第一节 介绍</strong></h2><p>&emsp;&emsp;CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是<strong>持续集成</strong>、<strong>持续交付</strong>和<strong>持续部署</strong>。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题（亦称：“集成地狱”）。</p><p>&emsp;&emsp;具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。</p><hr><h2 id="第二节-CI-是什么？CI-和-CD-有什么区别？"><a href="#第二节-CI-是什么？CI-和-CD-有什么区别？" class="headerlink" title="第二节 CI 是什么？CI 和 CD 有什么区别？"></a><strong>第二节 CI 是什么？CI 和 CD 有什么区别？</strong></h2><p>&emsp;&emsp;“CI”始终指<strong>持续集成</strong>，它<strong>属于开发人员的自动化流程</strong>。成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享存储库中。该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。</p><p>&emsp;&emsp;“CD”指的是<strong>持续交付</strong>和/或<strong>持续部署</strong>，这些相关概念有时会交叉使用。两者都事关管道后续阶段的自动化，但它们有时也会单独使用，用于说明自动化程度。</p><p>&emsp;&emsp;持续交付通常是<strong>指开发人员对应用的更改会自动进行错误测试并上传到存储库</strong>（如 GitHub 或容器注册表），<strong>然后由运维团队将其部署到实时生产环境中</strong>。这旨在解决开发和运维团队之间可见性及沟通较差的问题。因此，持续交付的目的就是<strong>确保尽可能减少部署新代码时所需的工作量</strong>。</p><p>&emsp;&emsp;持续部署（另一种“CD”）指的是<strong>自动将开发人员的更改从存储库发布到生产环境，以供客户使用</strong>。它主要为了<strong>解决因手动流程降低应用交付速度，从而使运维团队超负荷的问题</strong>。持续部署以持续交付的优势为根基，实现了管道后续阶段的自动化。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010102.png" alt="CI/CD"></p><p>&emsp;&emsp;CI/CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。更为复杂的是，有时“持续交付”也包含了持续部署流程。</p><p>&emsp;&emsp;归根结底，我们没必要纠结于这些语义，您只需记得 CI/CD 其实就是一个流程（通常形象地表述为<strong>管道</strong>），用于实现应用开发中的高度持续自动化和持续监控。因案例而异，该术语的具体含义取决于 CI/CD 管道的自动化程度。许多企业最开始先添加 CI，然后逐步实现交付和部署的自动化（例如作为云原生应用的一部分）。</p><hr><h2 id="第三节-CI-持续集成（Continuous-Integration）"><a href="#第三节-CI-持续集成（Continuous-Integration）" class="headerlink" title="第三节 CI 持续集成（Continuous Integration）"></a><strong>第三节 CI 持续集成（Continuous Integration）</strong></h2><p>&emsp;&emsp;现代应用开发的目标是让多位开发人员同时处理同一应用的不同功能。但是，如果企业安排在一天内将所有分支源代码合并在一起（称为“合并日”），最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（IDE），而不是让团队就一个基于云的 IDE 达成一致，那么就会让问题更加雪上加霜。</p><p>&emsp;&emsp;持续集成（CI）可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或“主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误。</p><hr><h2 id="第四节-CD-持续交付（Continuous-Delivery）"><a href="#第四节-CD-持续交付（Continuous-Delivery）" class="headerlink" title="第四节 CD 持续交付（Continuous Delivery）"></a><strong>第四节 CD 持续交付（Continuous Delivery）</strong></h2><p>&emsp;&emsp;完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p><p>&emsp;&emsp;在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。</p><hr><h2 id="第五节-CD-持续部署（Continuous-Deployment）"><a href="#第五节-CD-持续部署（Continuous-Deployment）" class="headerlink" title="第五节 CD 持续部署（Continuous Deployment）"></a><strong>第五节 CD 持续部署（Continuous Deployment）</strong></h2><p>&emsp;&emsp;对于一个成熟的 CI/CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。</p><p>&emsp;&emsp;实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI/CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI/CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" title="Title" target="_blank" rel="noopener">CI/CD是什么？如何理解持续集成、持续交付和持续部署</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍什么是CI/CD？持续集成、持续交付和持续部署的意义
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
</feed>
