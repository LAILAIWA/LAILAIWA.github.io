<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2021-06-15T15:40:24.000Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>林沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《社会心理学》读书笔记（一）导论</title>
    <link href="http://linyishui.top/2021061501.html"/>
    <id>http://linyishui.top/2021061501.html</id>
    <published>2021-06-15T07:03:45.000Z</published>
    <updated>2021-06-15T15:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="一-什么是社会心理学"><a href="#一-什么是社会心理学" class="headerlink" title="一. 什么是社会心理学"></a>一. 什么是社会心理学</h2><blockquote><p>人类是情境中的生物，情境塑造了我们，决定我们未来的诸多可能性，我们便不可独立于它而存在。</p></blockquote><p>社会心理学是一门<strong>研究我们周围情境力量</strong>的科学，尤其是我们<strong>如何看待他人、如何影响他人、又如何互相关联</strong>。、</p><p>我们的社会行为不仅取决于<strong>客观情境</strong>，还取决于我们如何对其进行<strong>主观建构</strong>。</p><h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>社会心理学研究三类问题：</p><ul><li><strong>社会思维：</strong><ul><li>我们如何知觉自我和他人</li><li>我们的信念是什么</li><li>我们所做的判断</li><li>我们的态度</li></ul></li><li><strong>社会影响：</strong><ul><li>文化与生物从众的压力</li><li>说服</li><li>团体</li></ul></li><li><strong>社会关系：</strong><ul><li>偏见</li><li>攻击</li><li>吸引力和亲密关系</li><li>助人</li></ul></li></ul><p>我们的社交生活在多大程度上存在于我们的头脑之中？如果被要求听命行事，你会用残忍的方式行动吗？选择助人还是助己？</p><h3 id="社会心理学的观点"><a href="#社会心理学的观点" class="headerlink" title="社会心理学的观点"></a>社会心理学的观点</h3><ul><li>社会思维：<ol><li><strong>我们构建起社会现实。</strong>人类的通性是想要解释行为，使其归因变得次序井然，具有可预见性，能够被掌握。我们会习惯解释他人的行为，将其“人格”归类。看待自己是乐观或悲观，习惯高人一等还是低人一等？</li><li><strong>我们的社会直觉的力量是强大的，但有时是危险的。</strong>我们的直觉影响我们某些时刻的选择，人的心灵或许是无意识的，一个由直觉所操控的。思维、记忆和态度都是同时在两个水平上运行的，一个有意识和意图，一个无意识和自动，即<strong>双重加工</strong>。我们自己的直觉时常会出错，太过于相信自己的记忆力，错误的解读自己的心理，错误估计自己的未来。大部分场景中，快捷省力的速食型判断方式足以满足需求，但一些需要<strong>准确性</strong>的特殊场景下，我们最好使用<strong>批判性思维</strong>来抑制直觉冲动。</li><li><strong>态度塑造行为。</strong>我们对某些事情的态度会左右相关的行为，态度也同样依附于行为。</li></ol></li><li>社会影响：<ol start="4"><li><strong>社会影响塑造行为。</strong>我们是社会动物，会对周围环境做出反应。有时，某些社会情境具有的影响力会引发我们做出背离自己态度的举动。比如伊拉克战争爆发时，美国和以色列的群众会更倾向于战争，而世界其他国家的群众则反对战争。我们对女性美的定义取决于我们所在的文化环境等等。<strong>环境无时无刻不在影响个人。</strong></li><li><strong>性格倾向塑造行为。</strong>面对同样的情境，不同性格的人会做出不同的选择。<strong>作为社会个体，我们不仅仅是社会的产物，也同样是社会的创造者。</strong>（相互影响）</li></ol></li><li>社会关系：<ol start="6"><li><strong>社会行为同样也是生物性行为。</strong>人类是先天与后天共同作用的生物，遗传得到的天性是我们做出有利于繁衍的行为，我们遗传了这些使得血脉得以延续的基因。进化心理学研究的是自然选择如何影响我们的一些行为与反应。大脑、心灵和行为是如何共同作用成为一个相互协调的工作系统，这是社会认知神经科学关注的问题。</li><li><strong>对他人的感受和做出的行为有时是积极，有时则是消极的。</strong></li></ol></li></ul><h2 id="二-社会心理学与相关学科"><a href="#二-社会心理学与相关学科" class="headerlink" title="二. 社会心理学与相关学科"></a>二. 社会心理学与相关学科</h2><ul><li><p><strong>社会学：</strong>社会学家研究<strong>团体</strong>—从小团体到大团体（社会与其发展趋势）；社会心理学家研究<strong>个体</strong>—个体在某个特定时间对他人的看法，个体之间的相互影响及关系。比如亲密关系的研究中，社会学关系婚姻关系、离婚以及同居比例，社会心理学则关心个体如何被另一个个体吸引。</p></li><li><p><strong>人格心理学：</strong>二者都关注个体，社会心理学更多关注社会因素，人格心理学则关注个体内部功能以及个体间的差异。社会心理学关注个体间的相同点，人格心理学关注个体间的差异点。</p></li></ul><h2 id="三-价值观与事后聪明"><a href="#三-价值观与事后聪明" class="headerlink" title="三. 价值观与事后聪明"></a>三. 价值观与事后聪明</h2><blockquote><p>心理学无法解释人类存在的目的，也无法解释人类生活的意义，以及人类的最终命运。社会心理学只是我们看待自我，了解自我的其中一个视角。</p></blockquote><p>如果大脑没有预先设定你将知觉到某个物体，它便会将其阻隔在你的一视之外。我们对现实的知觉会为我们的预期所左右。<strong>客观现实的确存在，但我们总是透过信念与价值观的眼镜观察它们。</strong></p><p>每个人都难以脱离个人主观的影响，因此社会心理学的概念也会被隐含的价值观渗入。我们生活中也会有这种问题，当别人赞美国家和人民时我们称其为民族主义，当我们这样做时就叫爱国主义。一个卷入婚外情的人是追求婚姻解放还是通奸，取决于我们个人价值观。雄心勃勃的男人与盛气凌人的女人，小心谨慎的男孩子与怯生生的女孩子等。</p><p>社会心理学不是旨在事后分析，而是能够预测。当得知结果后就会觉得显而易见，比如股市震荡或大选落定，大部分评论对此并不感到意外。绝大多数的心理学实验得到结论看起来都像常识，这是因为我们提前知道了结果（事后聪明）。</p><blockquote><p>将一群人分为两组，一组告知其无论交友还是坠入爱河，性格与我们不同的人更有吸引力，俗话说异性相吸；另一组则告知其性格相似的人最有吸引力，俗话说物以类聚、人以群分。</p><p>无论哪种说法，甚至是相反的论点都会让我们觉得很有道理，比如“堕落的人不能帮助另一个堕落的人”与“堕落的人能够帮助另一个堕落的人”这种双重格言。</p></blockquote><h2 id="四-研究方法"><a href="#四-研究方法" class="headerlink" title="四. 研究方法"></a>四. 研究方法</h2><hr><p>参考：</p><p>🔗 《社会心理学》</p>]]></content>
    
    <summary type="html">
    
      内容来自《社会心理学》。
    
    </summary>
    
      <category term="心理学" scheme="http://linyishui.top/categories/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    
      <category term="psychology" scheme="http://linyishui.top/tags/psychology/"/>
    
  </entry>
  
  <entry>
    <title>《社会心理学》读书笔记</title>
    <link href="http://linyishui.top/2021061401.html"/>
    <id>http://linyishui.top/2021061401.html</id>
    <published>2021-06-14T07:03:45.000Z</published>
    <updated>2021-06-15T14:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="社会心理学"><a href="#社会心理学" class="headerlink" title="社会心理学"></a>社会心理学</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><h2 id="二-社会思维"><a href="#二-社会思维" class="headerlink" title="二. 社会思维"></a>二. 社会思维</h2><h2 id="三-社会影响"><a href="#三-社会影响" class="headerlink" title="三. 社会影响"></a>三. 社会影响</h2><h2 id="四-社会关系"><a href="#四-社会关系" class="headerlink" title="四. 社会关系"></a>四. 社会关系</h2><h2 id="五-实际应用"><a href="#五-实际应用" class="headerlink" title="五. 实际应用"></a>五. 实际应用</h2><hr><p>参考：</p><p>🔗 《社会心理学》</p>]]></content>
    
    <summary type="html">
    
      内容来自《社会心理学》。
    
    </summary>
    
      <category term="心理学" scheme="http://linyishui.top/categories/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    
      <category term="psychology" scheme="http://linyishui.top/tags/psychology/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper（五）技术内幕</title>
    <link href="http://linyishui.top/2021061001.html"/>
    <id>http://linyishui.top/2021061001.html</id>
    <published>2021-06-10T07:03:45.000Z</published>
    <updated>2021-06-20T14:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ZooKeeper（五）技术内幕"><a href="#ZooKeeper（五）技术内幕" class="headerlink" title="ZooKeeper（五）技术内幕"></a>ZooKeeper（五）技术内幕</h1><h2 id="一-系统模型"><a href="#一-系统模型" class="headerlink" title="一. 系统模型"></a>一. 系统模型</h2><h3 id="1-1-数据模型"><a href="#1-1-数据模型" class="headerlink" title="1.1 数据模型"></a>1.1 数据模型</h3><p>ZooKeeper的数据模型为 ZNode，即数据节点，可以保存数据，同事可以挂载子节点，因此构成了一个层次化的命名空间，一个树结构。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010101.png" alt></p><p>ZooKeeper中的事务指能够改变ZK服务器状态的操作，一般包括数据节点的创建和删除、数据节点内容更新和客户端会话创建与失效等操作。每个事务会被分配一个全局唯一的事务ID，即ZXID，通常是一个64位的数字，每个ZXID对应一次更新操作，而且可以间接看出ZK处理这些请求的全局顺序。</p><h3 id="1-2-节点特性"><a href="#1-2-节点特性" class="headerlink" title="1.2 节点特性"></a>1.2 节点特性</h3><h4 id="（1）节点类型"><a href="#（1）节点类型" class="headerlink" title="（1）节点类型"></a>（1）节点类型</h4><ul><li><strong>持久节点（PERSISTENT）：</strong>数据节点创建后就会一直存在于ZK服务器上，直到由删除操作主动清除此节点。</li><li><strong>持久顺序节点（PERSISTENT_SEQUENTIAL）：</strong>有额外的顺序性特点，每个父节点都会为它的一级子节点维护一份顺序，创建子节点时可以设置这个标记，ZK会自动给节点名后加一个数字后缀。</li><li><strong>临时节点（EPHEMERAL）：</strong>此节点的生命周期与客户端会话绑定，当会话失效，节点就会被自动清理掉（非TCP连接断开），临时节点只能作为叶子节点，不能创建子节点。</li><li><strong>临时顺序节点（EPHEMERAL_SEQUENTIAL）：</strong>额外有了顺序性。</li></ul><h4 id="（2）状态信息"><a href="#（2）状态信息" class="headerlink" title="（2）状态信息"></a>（2）状态信息</h4><p>通过get命令获取一个数据节点的内容：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010102.png" alt></p><p>第一行是数据内容，后面就是节点的状态信息，其实就是数据节点的Stat对象的格式化输出：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010103.png" alt></p><p>Stat类包含上一个数据节点的所有状态信息（事务ID、版本信息和子节点个数等）：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010104.png" alt></p><h3 id="1-3-版本—乐观锁保证分布式数据原子性操作"><a href="#1-3-版本—乐观锁保证分布式数据原子性操作" class="headerlink" title="1.3 版本—乐观锁保证分布式数据原子性操作"></a>1.3 版本—乐观锁保证分布式数据原子性操作</h3><p>每个数据节点都有三种类似新的版本信息：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010105.png" alt></p><p>当节点创建后，version值为0，当对此节点进行更新后，更新为1，代表变更次数。通过版本号实现的乐观锁来实现在数据并发竞争不大、事务冲突较少的应用场景。</p><p>ZK的PrepRequestProcessor处理器类中，处理每个数据更新请求（setDataRequest）时，会进行如下版本检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version = setDataRequest.getVersion();</span><br><span class="line"><span class="comment">// 获取当前服务器上该数据的最新版本</span></span><br><span class="line"><span class="keyword">int</span> currentVersion = nodeRecord.stat.getVersion();</span><br><span class="line"><span class="comment">// -1表示客户端不要求使用乐观锁</span></span><br><span class="line"><span class="keyword">if</span> (version != -<span class="number">1</span> &amp;&amp; version != currentVersion) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.BadVersionException(path);</span><br><span class="line">   &#125;</span><br><span class="line">version = currentVersion + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-4-Watcher"><a href="#1-4-Watcher" class="headerlink" title="1.4 Watcher"></a>1.4 Watcher</h3><p>ZK通过Watcher机制来实现发布/订阅的分布式通知功能，当服务端指定事件触发了Watcher，就会向指定客户端发送一个事件通知：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010106.png" alt></p><h4 id="1-4-1-结构"><a href="#1-4-1-结构" class="headerlink" title="1.4.1 结构"></a>1.4.1 结构</h4><p>Watcher对象存储在客户端的WatchManager中，收到通知后从中取出对应的Watcher对应来执行回调逻辑。</p><p>接口类Watcher表示一个标准的事件处理器，包含KeeperState和EventType两个枚举类，分别表示通知状态和事件类型，同时定义了事件的回调方法：<code>process(WatchedEvent event)</code> 。</p><p>Watcher事件常见的通知状态和事件类型：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010107.png" alt></p><p>内容变更包括节点的数据内容和数据的版本号dataVersion，即使相同数据内容，一旦有客户端调用数据更新的接口，触发的更新一样会发送相应通知。</p><p>AuthFailed是授权失败触发，使用错误的Auth只会抛出NoAuthException异常，而使用错误的Scheme则会抛出AuthFailedException，并且收到事件通知(AuthFailed, None)。</p><p>回调方法 <code>process()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WatchedEvent对象封装服务端事件并传递给Watcher</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>;</span><br></pre></td></tr></table></figure><p>WatchedEvent包含每个事件的三个基本属性：通知状态（KeeperState）、事件类型（eventType）和节点路径（path）：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010108.png" alt></p><p>相对的WatcherEvent实现了序列号接口，可以用于网络传输：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010109.png" alt></p><p>服务端生成WatchedEvent事件后，会调用getWrapper方法将自己包装成一个可序列化的WatcherEvent事件，通过网络传输给客户端。客户端收到事件对象后会先将WatcherEvent还原为WatchedEvent，并传递给process方法处理。二者对于事件的封装都很简单，比如节点数据变更，客户端无法直接获取到原始数据和变更后数据：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">KeeperState:</span> SyncConnected</span><br><span class="line"><span class="symbol">EventType:</span> NodeDataChanged</span><br><span class="line"><span class="symbol">Path:</span> /zk-book</span><br></pre></td></tr></table></figure><p>Watcher内部各组件间关系：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010110.png" alt></p><h4 id="1-4-2-客户端注册Watcher"><a href="#1-4-2-客户端注册Watcher" class="headerlink" title="1.4.2 客户端注册Watcher"></a>1.4.2 客户端注册Watcher</h4><p>注册Watcher：</p><ul><li><p>创建ZK客户端实例时，可以给定一个默认的Watcher，它会一直保存在客户端ZKWatchManager的defaultWatcher中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>客户端也可以通过 <code>getData()</code> 、<code>getChildren()</code> 和 <code>exist()</code> 三个接口来注册Watcher，例如getData：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过布尔参数标识是否使用前面的默认Watcher来进行注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(String path, <span class="keyword">boolean</span> watch, Stat stat);</span><br><span class="line"><span class="comment">// 直接提供Watcher</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat);</span><br></pre></td></tr></table></figure></li></ul><p>客户端首先会对当前客户端请求request进行标记，设置为“使用Watcher监听”，同时封装一个Watcher注册信息WatchRegistration对象，临时保存数据节点的路径和Watcher的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">getData</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       WatchRegistration wcb = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">           wcb = <span class="keyword">new</span> DataWatchRegistration(watcher, clientPath);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       request.setWatch(watcher != <span class="keyword">null</span>);</span><br><span class="line">       ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Packet可以看作是ZK中最小的通信协议单元，用于进行客户端与服务端之间的网络传输，任何需要传输的对象都需要包装成一个Packet对象。ClientCnxn的WatchRegistration也会封装到Packet中，再放入发送队列中等待客户端发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Packet <span class="title">queuePacket</span><span class="params">(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration watchRegistration)</span> </span>&#123;</span><br><span class="line">       Packet packet = <span class="keyword">null</span>;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">synchronized</span>(outgoingQueue) &#123;</span><br><span class="line">           packet = <span class="keyword">new</span> Packet(h, r, request, response, watchRegistration);</span><br><span class="line">       ...</span><br><span class="line">           outgoingQueue.add(packet);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>随后，客户端发送请求，同时等待请求返回。完成发送后，由客户端SendThread线程的readResponse方法负责接收来自服务端的响应，finishPacket方法从Packet中取出对应的Watcher并注册到ZKWatchManager中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishPacket</span><span class="params">(Packet p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">           p.watchRegistration.register(p.replyHeader.getErr());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, Set&lt;Watcher&gt;&gt; getWatches(<span class="keyword">int</span> rc) &#123;</span><br><span class="line">       <span class="keyword">return</span> watchManager.dataWatches;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端将暂时保存的Watcher转交给ZKWatchManager，最终保存到dataWatches</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (shouldAddWatch(rc)) &#123;</span><br><span class="line">           Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</span><br><span class="line">           <span class="keyword">synchronized</span>(watches) &#123;</span><br><span class="line">               Set&lt;Watcher&gt; watchers = watches.get(clientPath);</span><br><span class="line">               <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">                   watchers.put(clientPath, watchers);</span><br><span class="line">               &#125;</span><br><span class="line">               watchers.add(watcher);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010111.png" alt></p><p>极端情况下，客户端每调用一次 <code>getData()</code> 接口，就会注册一个Watcher，但这些Watcher并不会都随着客户端请求发送到服务端造成内存紧张等性能问题。ZK底层实际的网络传输序列化过程中并没有将WatchRegistration对象完全的序列化到底层字节数组中，Packet内部序列化过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">           BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">           <span class="comment">// We'll fill this in later</span></span><br><span class="line">           boa.writeInt(-<span class="number">1</span>, <span class="string">"len"</span>);</span><br><span class="line">           <span class="keyword">if</span> (requestHeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">               requestHeader.serialize(boa, <span class="string">"header"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ConnectRequest) &#123;</span><br><span class="line">               request.serialize(boa, <span class="string">"connect"</span>);</span><br><span class="line">               <span class="comment">// append "am-I-allowed-to-be-readonly" flag</span></span><br><span class="line">               boa.wirteBool(readOnly, <span class="string">"readOnly"</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">               request.serialize(boa, <span class="string">"request"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>只有requestHeader和request进行了序列化，所以尽管WatchRegistration被封装到了Packet中，但并没有序列化到底层字节数组，因此不会进行网络传输。</strong></p><h4 id="1-4-3-服务端处理Watcher"><a href="#1-4-3-服务端处理Watcher" class="headerlink" title="1.4.3 服务端处理Watcher"></a>1.4.3 服务端处理Watcher</h4><p>客户端并不会将Watcher对象真正的传递到服务端，服务端如何完成客户端的Watcher注册？</p><h5 id="（1）ServerCnxn存储"><a href="#（1）ServerCnxn存储" class="headerlink" title="（1）ServerCnxn存储"></a>（1）ServerCnxn存储</h5><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010112.png" alt></p><p>服务端收到请求后，在 <code>FinalRequestProcessor.processRequest()</code> 中判断当前请求是否需要注册Watcher：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OpCode.getData: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 当getDtatRequest.getWatch()为True时，将当前ServerCnxn对象和数据节点路径传入getData方法，最终存储在WatchManager的watchTable和watch2Paths中</span></span><br><span class="line">    <span class="keyword">byte</span> b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat, getDtatRequest.getWatch() ? cnxn : <span class="keyword">null</span>);</span><br><span class="line">    rsp = <span class="keyword">new</span> GetDataResponse(b, stat);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerCnxn是一个ZooKeeper客户端和服务器之间的连接接口，代表了一个二者间的连接。默认实现是NIOServerCnxn，3.4.0版本开始引入了基于Netty的实现NettyServerCnxn。都实现了Watcher的process接口，所以ServerCnxn也可以看作是一个Watcher。</p><p>WatchManager是ZK服务端Watcher的管理者，内部两种存储结构对应不同维度：</p><ul><li><strong>watchTable：</strong>从数据节点路径的粒度来托管Watcher。</li><li><strong>watch2Paths：</strong>从Watcher的粒度控制事件触发需要触发的数据节点。</li></ul><p>WatchManager还负责Watcher事件的触发，移除掉已被触发的Watcher。服务端DataTree会托管两个WatchManager（dataWatches和childWatches，对应数据变更和子节点变更）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010113.png" alt></p><h5 id="（2）Watcher触发"><a href="#（2）Watcher触发" class="headerlink" title="（2）Watcher触发"></a>（2）Watcher触发</h5><p>服务端如何触发Watcher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">setData</span><span class="params">(String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, <span class="keyword">long</span> zxid, <span class="keyword">long</span> time)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</span><br><span class="line">       DataNode n = nodes.get(path);</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">byte</span> lasdtdata[] = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">synchronized</span> (n) &#123;</span><br><span class="line">           lastdata = n.data;</span><br><span class="line">           n.data = data;</span><br><span class="line">           n.stat.setMtime(time);</span><br><span class="line">           n.stat.setMzxid(zxid);</span><br><span class="line">           n.stat.setVersion(version);</span><br><span class="line">           n.copyStat(s);</span><br><span class="line">       &#125;</span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">// 指定节点数据更新后，调用WatchManager的triggerWatch来触发相关事件</span></span><br><span class="line">       dataWatches.triggerWatch(path, EventType.NodeDataChanged);</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> triggerWatch(path, type, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>&#123;</span><br><span class="line">       WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type, KeeperState.SyncConnected, path);</span><br><span class="line">       HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           watchers = watchTable.remove(path);</span><br><span class="line">           ......</span><br><span class="line">           <span class="comment">// 如果不存在Watcher，直接返回</span></span><br><span class="line">           <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">               HashSet&lt;String&gt; paths = watch2Paths.get(w);</span><br><span class="line">               <span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   paths.remove(path);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">           <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           w.process(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> watchers;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>WatchManager的触发逻辑：</p><ol><li><p><strong>封装WatchedEvent：</strong>先将通知状态（KeeperState）、事件类型（EventType）和节点路径封装成一个WatchedEvent对象。</p></li><li><p><strong>查询Watcher：</strong>根据节点路径从watchTable中取出对应的Watcher，若没找到则说明没有客户端在该节点注册过Watcher，直接退出；若找到了则将其提取出来，同时直接从watchTable和watch2Paths中将其删除（<strong>Watcher在服务端是一次性的，用完及删</strong>）。</p></li><li><p><strong>调用process方法来触发Watcher：</strong>逐个调用步骤2找到的Watcher的process方法，即请求中的ServerCnxn对应方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServerCnxn</span> <span class="keyword">extends</span> <span class="title">ServerCnxn</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 请求头标记-1，标识当前是一个通知</span></span><br><span class="line">        ReplyHeader h -= <span class="keyword">new</span> ReplyHeader(-<span class="number">1</span>, -<span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Convert WatchedEvent to a type that can be sent over the write</span></span><br><span class="line">        <span class="comment">// WatchedEvent包装为WatcherEvent方便网络传输序列化</span></span><br><span class="line">        WatcherEvent e = event.getWrapper();</span><br><span class="line">        <span class="comment">// 向客户端发送通知</span></span><br><span class="line">        sendResponse(h, e, <span class="string">"notification"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerCnxn中的process不包含业务逻辑，真正的Watcher回调和业务逻辑都在客户端</p></li></ol><h5 id="（3）客户端回调Watcher"><a href="#（3）客户端回调Watcher" class="headerlink" title="（3）客户端回调Watcher"></a>（3）客户端回调Watcher</h5><ul><li><p><strong>SendThread接收事件通知：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZK客户端如何接收事件通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 服务端响应统一处理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> throw IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// -1 means notification 通知类型的响应</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 1.将字节流转换为WatcherEvent对象</span></span><br><span class="line">            WatcherEvent event = <span class="keyword">new</span> WatcherEvent();</span><br><span class="line">            event.deserialize(bbia, <span class="string">"response"</span>);</span><br><span class="line">            <span class="comment">// 2.处理chrootPath</span></span><br><span class="line">            <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">            <span class="keyword">if</span> (chrootPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 对服务端传过来的完整字节路径进行处理，生成客户端一个相对节点路径</span></span><br><span class="line">                String serverPath = event.getPath();</span><br><span class="line">                <span class="keyword">if</span> (serverPath.compareTo(chrootPath) == <span class="number">0</span>)</span><br><span class="line">                    event.setPath(<span class="string">"/"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                    event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.还原WatchedEvent，适配process接口参数</span></span><br><span class="line">            WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 4.回调Watcher，将WatchedEvent交给EventThread线程，在下一个轮询周期进行Watcher回调</span></span><br><span class="line">            eventThread.queueEvent(we);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>EventThread处理事件通知：</strong></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010114.png" alt></p><p>SentThread通过 <code>EventThread.queueEvent()</code> 将事件传给EventThread线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueEvent</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (event.getType() == EventType.None &amp;&amp; sessionState == event.getState()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       sessionState = event.getState();</span><br><span class="line">       <span class="comment">// materialize the watchers based on the event</span></span><br><span class="line">       WatcherSetEventPair pair = <span class="keyword">new</span> WatcherSetEventPair();</span><br><span class="line">       watcher.materialize(event.getState(), event.getType(), event.getPath(), event));</span><br><span class="line">       <span class="comment">// queue the pair (watch set &amp; event) for later processing</span></span><br><span class="line">       <span class="comment">// 取出所有相关Watcher后，放入waitingEvents队列</span></span><br><span class="line">       waitingEvents.add(pair);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 根据通知事件，从ZKWatchManager中取出所有相关Watcher</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">materialize</span><span class="params">(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String clientPath)</span> </span>&#123;</span><br><span class="line">       Set&lt;Watcher&gt; result = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">       <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">       ...</span><br><span class="line">           <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">           <span class="keyword">case</span> NodeCreated:</span><br><span class="line">               <span class="comment">// 从相应的Watcher存储中去除对应的Watcher，客户端的Watcher也是一次性的</span></span><br><span class="line">               <span class="keyword">synchronized</span> (dataWatches) &#123;</span><br><span class="line">                   addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">synchronized</span> (existWatches) &#123;</span><br><span class="line">                   addTo(existWatches.remove(clientPath), result);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addTo</span><span class="params">(Set&lt;Watcher&gt; from, Set&lt;Watcher&gt; to)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (from != <span class="keyword">null</span>) &#123;</span><br><span class="line">           to.addAll(from);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>EventThread的run方法不断对waitingEvents队列进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           isRunning = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">               Object event = waitingEvents.take();</span><br><span class="line">               <span class="keyword">if</span> (event == eventOfDeath) &#123;</span><br><span class="line">                   wasKilled = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   processEvent(event);</span><br><span class="line">               &#125;</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (event <span class="keyword">instanceof</span> WatcherSetEventPair) &#123;</span><br><span class="line">               <span class="comment">// each watcher will process the event</span></span><br><span class="line">               WatcherSetEventPair pair = (WatcherSetEventPair) event;</span><br><span class="line">               <span class="comment">// 每次从waitingEvents中取出一个Watcher并进行串行同步处理</span></span><br><span class="line">               <span class="keyword">for</span> (Watcher watcher : pair.watchers) &#123;</span><br><span class="line">                   <span class="keyword">try</span>&#123;</span><br><span class="line">                       <span class="comment">// 调用process完成回调</span></span><br><span class="line">                       watcher.process(pair.event);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-4-Watcher特性"><a href="#1-4-4-Watcher特性" class="headerlink" title="1.4.4 Watcher特性"></a>1.4.4 Watcher特性</h4><ul><li><strong>一次性：</strong>无论是服务端还是客户端，一旦Watcher被触发，就会从ZK存储中删除，所以使用时要反复注册，这样能够减轻服务器的压力。</li><li><strong>客户端串行执行：</strong>客户端Watcher回调时一个串行同步过程，保证了执行顺序。</li><li><strong>轻量：</strong>WatchedEvent是Watcher通知机制的最小通知单元，只包含三部分内容（通知状态、事件类型和节点路径），客户端需要主动去获取更新数据。客户端向服务端注册Watcher时，没有把真实Watcher对象传给服务端，只是在请求中使用Boolean类型标记，服务端仅仅保存了当前连接的ServerCnxn对象。</li></ul><h3 id="1-5-ACL—保障数据安全"><a href="#1-5-ACL—保障数据安全" class="headerlink" title="1.5 ACL—保障数据安全"></a>1.5 ACL—保障数据安全</h3><h4 id="权限模式-Scheme"><a href="#权限模式-Scheme" class="headerlink" title="权限模式-Scheme"></a>权限模式-Scheme</h4><p>权限模式用来确定权限验证过程中使用的检验策略，常用的四种权限模式：</p><ul><li><p><strong>IP：</strong>通过IP地址粒度进行权限控制，也支持按网段的方式进行配置，如 <code>ip:192.168.0.1/24</code> 表示针对 <code>192.168.0.*</code> IP段进行权限控制。</p></li><li><p><strong>Digest：</strong></p><ul><li><p>最常用的模式，类似于 <code>username:password</code> 形式的权限表示进行权限控制来区分不同应用。</p></li><li><p>ZK先后会进行两次编码处理，<strong>SHA-1算法加密</strong>和<strong>BASE64编码</strong>，由 <code>DigestAuthenticationProvider.generateDigest(String idPassword)</code> 函数进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigestAuthenticationProviderUsage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        System.out.println(DigestAuthenticationProvider.generateDigest(<span class="string">"foo:zk-book"</span>));</span><br><span class="line">        <span class="comment">// 输出：foo:kWN6aNS.... 混淆无序的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>World：</strong>最开放的模式，数据节点访问对所有用户开放，只有一个权限标识 <code>world:anyone</code> 。</p></li><li><p><strong>Super：</strong>超级用户模式，可以对任意ZK节点进行任意操作。</p></li></ul><h4 id="授权对象-ID"><a href="#授权对象-ID" class="headerlink" title="授权对象-ID"></a>授权对象-ID</h4><p>授权对象指权限赋予的用户或一个指定实体，如IP地址或机器：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210601/202106010115.png" alt></p><h4 id="权限-Permission"><a href="#权限-Permission" class="headerlink" title="权限-Permission"></a>权限-Permission</h4><p>权限指通过权限检查后允许执行的操作，分为5类：</p><ul><li><strong>CREATE：</strong>数据节点的创建权限，允许授权对象在该数据节点下创建子节点。</li><li><strong>DELETE：</strong>子节点的删除权限，允许授权对象删除该数据节点的子节点。</li><li><strong>READ：</strong>数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等。</li><li><strong>WRITE：</strong>数据节点的更新权限，允许授权对象对该数据节点进行更新操作。</li><li><strong>ADMIN：</strong>数据节点的管理权限，允许授权对象对该数据节点进行ACL相关的设置操作。</li></ul><h4 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h4><p>ZK允许开发人员用过指定方式对ZK进行扩展，即 Pluggable ZooKeeper Authentication 机制，实现接口AuthenticationProvider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZK默认的几种权限模式对应DigestAuthenticationProvider和IPAuthenticationProvider</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getScheme</span><span class="params">()</span></span>;</span><br><span class="line">    KeeperException.<span class="function">Code <span class="title">handleAuthentication</span><span class="params">(ServerCnxn cnxn, <span class="keyword">byte</span> authData[])</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String id, String aclExpr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现自定义权限控制器后，需要将其注册到ZK中，有两种方式：</p><ul><li><p><strong>系统属性：</strong>启动参数添加配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dzookeeper.authProvider.1=com.zkbook.CustomAuthenticationProvider</span><br></pre></td></tr></table></figure></li><li><p><strong>配置文件：</strong><code>zoo.cfg</code> 中添加配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authProvider.1=com.zkbook.CustomAuthenticationProvider</span><br></pre></td></tr></table></figure></li></ul><p>权限控制器注册采用了<strong>延迟加载</strong>的策略，第一次处理包含权限控制请求时才会进行权限控制器的初始化，同时ZK将所有控制器注册到ProviderRegistry中，顺序为：DigestAuthenticationProvider和IPAuthenticationProvider先初始化，然后扫描 <code>zookeeper.authProvider</code> 获取自定义控制器并初始化。</p><h4 id="ACL管理"><a href="#ACL管理" class="headerlink" title="ACL管理"></a>ACL管理</h4><p>通过zkCli脚本登录ZK服务器后，通过两种方式设置ACL：</p><ul><li><p><strong>数据节点创建的同时进行ACL权限的设置：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令格式</span></span><br><span class="line">create [-s] [-e] path data acl</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> create -e /zk-book init digest: foo:MiHs3Eiylp......</span></span><br><span class="line">Created /zk-book</span><br><span class="line"><span class="meta">$</span><span class="bash"> getAcl /zk-book</span></span><br><span class="line">'digest,'foo:MiHs3Eiylp......</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>setAcl</code> 命令单独对已经存在的数据节点进行ACL设置：</strong>，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setAcl path acl</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> create -e /zk-book init</span></span><br><span class="line">Created /zk-book</span><br><span class="line"><span class="meta">$</span><span class="bash"> setAcl /zk-book digest:foo:MiHs3Eiylp......</span></span><br><span class="line">cZxid = 0x400000042</span><br><span class="line">ctime = ......</span><br><span class="line">mZxid = 0x400000042</span><br><span class="line">mtime = ......</span><br><span class="line">pZxid = 0x400000042</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x1472ff49b020003</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br><span class="line"><span class="meta">$</span><span class="bash"> getAcl /zk-book</span></span><br><span class="line">'digest,'foo:MiHs3Eiylp......</span><br></pre></td></tr></table></figure></li></ul><p>一旦对一个数据节点设置了ACL权限控制，没有授权的ZK客户端就无法访问该数据节点，但如果一个持久数据节点包含了ACL权限控制，其创建客户端已不再使用，这些数据节点如何清理？<strong>Super模式</strong>下使用超级管理员权限。</p><p>ZK服务器启动时添加如下系统属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># foo表示管理员名，后续字符串由管理员自主配置</span><br><span class="line">-Dzookeeper.DigestAuthenticationProvider.superDigest=foo:MiHs3Eiylp......</span><br></pre></td></tr></table></figure><p>应用中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthSampleSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String PATH = <span class="string">"/zk-book"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ZooKeeper zk1 = <span class="keyword">new</span> ZooKeeper(<span class="string">"domain1.book.zookeeper:2181"</span>, <span class="number">5000</span>, <span class="keyword">null</span>);</span><br><span class="line">        zk1.addAuthInfo(<span class="string">"digest"</span>, <span class="string">"foo:true"</span>.getBytes());</span><br><span class="line">        zk1.create(PATH, <span class="string">"init"</span>.getBytes(), Ids.CREATOR_ALL_ACL, CreateMode.EPHEMERAL);</span><br><span class="line">        ZooKeeper zk2 = <span class="keyword">new</span> ZooKeeper(<span class="string">"domain1.book.zookeeper:2181"</span>, <span class="number">50000</span>, <span class="keyword">null</span>);</span><br><span class="line">        zk2.addAuthInfo(<span class="string">"digest"</span>, <span class="string">"foo:zk-book"</span>.getBytes());</span><br><span class="line">        System.out.println(zk2.getData(PATH, <span class="keyword">false</span>, <span class="keyword">null</span>));</span><br><span class="line">        ZooKeeper zk3 = <span class="keyword">new</span> ZooKeeper(<span class="string">"domain1.book.zookeeper:2181"</span>, <span class="number">50000</span>, <span class="keyword">null</span>);</span><br><span class="line">        zk3.addAuthInfo(<span class="string">"digest"</span>, <span class="string">"foo:false"</span>.getBytes());</span><br><span class="line">        System.out.println(zk3.getData(PATH, <span class="keyword">false</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 org.apache.zookeeper.KeeperException$NoAuthException: KeeperErrorCode = NoAuth for /zk-book foo:false无法通过权限校验，foo:zk-book超级管理员可以随意进行操作</span></span><br></pre></td></tr></table></figure><h2 id="二-序列化与协议"><a href="#二-序列化与协议" class="headerlink" title="二. 序列化与协议"></a>二. 序列化与协议</h2><h2 id="三-客户端"><a href="#三-客户端" class="headerlink" title="三. 客户端"></a>三. 客户端</h2><h2 id="四-会话"><a href="#四-会话" class="headerlink" title="四. 会话"></a>四. 会话</h2><h2 id="五-服务器启动"><a href="#五-服务器启动" class="headerlink" title="五. 服务器启动"></a>五. 服务器启动</h2><h2 id="六-Leader选举"><a href="#六-Leader选举" class="headerlink" title="六. Leader选举"></a>六. Leader选举</h2><h2 id="七-各服务器角色介绍"><a href="#七-各服务器角色介绍" class="headerlink" title="七. 各服务器角色介绍"></a>七. 各服务器角色介绍</h2><h2 id="八-请求处理"><a href="#八-请求处理" class="headerlink" title="八. 请求处理"></a>八. 请求处理</h2><h2 id="九-数据与存储"><a href="#九-数据与存储" class="headerlink" title="九. 数据与存储"></a>九. 数据与存储</h2><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      内容来自《从Paxos到Zookeeper-分布式一致性原理与实践》，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="zookeeper" scheme="http://linyishui.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper（四）应用场景与实现</title>
    <link href="http://linyishui.top/2021052001.html"/>
    <id>http://linyishui.top/2021052001.html</id>
    <published>2021-05-20T07:03:45.000Z</published>
    <updated>2021-06-13T14:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ZooKeeper（四）应用场景与实现"><a href="#ZooKeeper（四）应用场景与实现" class="headerlink" title="ZooKeeper（四）应用场景与实现"></a>ZooKeeper（四）应用场景与实现</h1><h2 id="一-典型应用场景"><a href="#一-典型应用场景" class="headerlink" title="一. 典型应用场景"></a>一. 典型应用场景</h2><p>ZooKeeper是一个高可用的基于发布/订阅模式的分布式数据管理和协调框架，基于ZAB算法，ZK可以很好的保证分布式环境的数据一致性。</p><h3 id="1-1-数据发布-订阅"><a href="#1-1-数据发布-订阅" class="headerlink" title="1.1 数据发布/订阅"></a>1.1 数据发布/订阅</h3><p>数据发布/订阅（配置中心）：<strong>发布者将数据发布到ZK的一个或一系列节点上，订阅者进行订阅，从而动态的获取数据，实现配置信息的集中式管理和数据的动态更新</strong>。</p><p>发布/订阅系统一般都包含两种设计模式：<strong>推和拉模式</strong>。推模式下服务端主动将数据更新发送给所有订阅的客户端，拉模式下则是由客户端主动发起请求获取最新数据（轮询）。ZK将推拉结合，<strong>客户端向服务端注册自己感兴趣的节点，当节点数据变更，服务端发送Watcher事件通知，客户端收到消息后主动获取最新数据</strong>。</p><p>案例：系统中需要一些通用的配置信息，如机器列表信息、运行时的开关配置、数据库配置信息等，这些全局的配置信息通常有3个特性：</p><ul><li>数据量较小</li><li>数据内容会在运行时发生动态变化</li><li>集群中各机器共享，配置一致</li></ul><p>单机系统通常会采用本地配置文件或内存变量（JMX来实现对系统运行时内存变量的更新）的方式，但对于分布式系统来说这两张方式比较难管理。</p><ul><li><p><strong>配置存储：</strong></p><p>首先将初始化配置存放在ZK上，选取一个数据节点，如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010101.png" alt></p><p>写入配置信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#DBCP</span></span><br><span class="line"><span class="string">dbcp.driverClassName=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="string">dbcp.dbJDBCUrl=jdbc:mysql://1.1.1.1:3306/taokeeper</span></span><br><span class="line"><span class="string">dbcp.characterEncoding=GBK</span></span><br><span class="line"><span class="string">dbcp.username=xiaoming</span></span><br><span class="line"><span class="string">dbcp.password=123456</span></span><br><span class="line"><span class="string">dbcp.maxActive=30</span></span><br><span class="line"><span class="string">dbcp.maxIdle=10</span></span><br><span class="line"><span class="string">dbcp.maxWait=10000</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置获取：</strong>每个客户端启动时从ZK节点上读取配置信息，并且在该配置节点上注册一个数据变更的Watcher监听，一旦数据发生变更，所有订阅的客户端都能收到通知。</p></li><li><p><strong>配置变更：</strong>运行时可能要切换数据库，此时只需对ZK节点上的配置信息进行更改。</p></li></ul><h3 id="1-2-负载均衡"><a href="#1-2-负载均衡" class="headerlink" title="1.2 负载均衡"></a>1.2 负载均衡</h3><p>负载均衡即对多台机器、网络连接、CPU、磁盘驱动或其他资源进行分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间和避免过载的目的。</p><p>分布式系统具有对等性，为了保证系统的高可用性，通常采用副本的方式来对数据和服务进行部署，对于消费者而言需要在这些对等的服务提供方选择一个来执行业务逻辑。</p><p>典型的负载均衡如<strong>DNS</strong>，即<strong>域名系统</strong>（Domain Name System），可以看作是一个超大规模的分布式映射表，用于将域名和IP地址进行一一映射，方便用户使用域名来访问互联网站点。</p><p>我们只能注册有限的域名，当系统规模变大，很难通过统一的DNS配置来管理。可以使用本地HOST绑定来实现域名解析的工作，解决了域名紧张的问题，可以随时修改域名和IP的映射，但机器规模扩大时，系统上线前要在每台机器上绑定域名会非常不方便，如果需要临时更新域名还需要到每台机器上变更。</p><h4 id="（1）动态DNS服务"><a href="#（1）动态DNS服务" class="headerlink" title="（1）动态DNS服务"></a>（1）动态DNS服务</h4><ul><li><p><strong>配置管理：</strong></p><p>首先要在ZK上创建一个节点进行域名配置：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010102.png" alt></p><p>每个应用都可以创建一个属于自己的数据节点作为域名配置的根节点，配置清单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单个IP:PORT</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8080</span></span><br><span class="line"><span class="comment">#多个IP:PORT</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8080,</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure></li><li><p><strong>域名解析：</strong></p><p>传统DNS解析的工作由操作系统的域名和IP地址映射机制或域名解析服务器完成。而ZK实现的DDNS则需要每个应用自己从ZK数据节点上获取一份IP地址和端口的配置，并自行解析。每个应用都会在域名节点注册一个数据变更Watcher监听。</p></li><li><p><strong>域名变更：</strong></p><p>运行过程中要更新IP地址或端口时，只需对指定的域名节点进行更新操作，ZK会向订阅的客户端发送通知。</p></li></ul><h4 id="（2）自动化的DNS服务"><a href="#（2）自动化的DNS服务" class="headerlink" title="（2）自动化的DNS服务"></a>（2）自动化的DNS服务</h4><p>上述实现在域名变更的环节还是需要人为的介入取修改域名节点上的IP地址和端口，ZK实现了自动化的DNS服务为了实现服务的自动化定位，系统架构如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010103.png" alt></p><p>重要的组件：</p><ul><li><strong>Register：</strong>集群负责域名的动态注册</li><li><strong>Dispatcher：</strong>集群负责域名解析</li><li><strong>Scanner：</strong>集群负责检测以及维护服务状态（探测服务的可用性、屏蔽异常服务节点等）</li><li><strong>SDK：</strong>提供各种语言的系统接入协议，提供服务注册以及查询接口</li><li><strong>Monitor：</strong>负责收集服务信息以及对DDNS自身状态的监控</li><li><strong>Controller：</strong>后台管理的Console，负责授权管理、流量控制、静态配置服务和手动屏蔽服务等功能，运维人员可以在上面管理Register、Dispatcher、Scanner等集群。</li></ul><p>自动化DNS流程：</p><ul><li><p><strong>域名注册：</strong></p><p>服务提供者在启动过程把自己的域名信息注册到 Register 集群中去</p><ol><li>服务提供者通过SDK提供的API接口，将域名、IP地址和端口发送给 Register 集群。</li><li>Register 收到后根据域名将信息写入相应的ZK域名节点中。</li></ol></li><li><p><strong>域名解析：</strong>与域名注册过程相反，服务消费者在使用域名时，会向 Dispatcher 发出域名解析请求。Dispatcher 收到请求后，会从ZK上指定域名节点读取相应的IP:PORT列表，通过一定的策略选取一个返回给前端应用。</p></li><li><p><strong>域名探测：</strong></p><p>指DDNS系统对域名下所有注册的IP地址和端口进行可用性检测/健康度检测，一般有两种方式：</p><ol><li>服务端主动发起健康度心跳检测，需要在服务端和客户端之间建立起一个TCP长链接；</li><li>客户端主动向服务端发起健康度心跳检测。</li></ol><p>DDNS架构中的域名检测使用的是服务提供者主动定时向Scanner进行状态汇报的模式（第二种）。Scanner负责记录每个服务提供者最近一次的状态汇报时间，一旦超过5秒没有收到状态汇报就认定此IP和端口不可用，并进行域名清理过程。</p><p>域名清理，Scanner会在ZK中找到对于域名节点，并将IP和端口配置从节点内容中移除。</p></li></ul><h3 id="1-3-命名服务"><a href="#1-3-命名服务" class="headerlink" title="1.3 命名服务"></a>1.3 命名服务</h3><p>分布式系统中被命名的实体通常是集群中的机器、提供的服务地址或远程对象等，较常见的是一些分布式服务框架RPC或RMI中的服务地址列表，通过命名服务，客户端应用能够根据指定名字来获取资源的实体、服务地址和提供者的信息等。</p><ul><li>Java的JNDI（Java命名与目录接口，Java Naming and Directory Interface）是一种典型的命名服务，标准的J2EE容器都提供了对JNDI规范的实现，可以用来完成数据源的配置和管理。</li><li>ZK的命名服务，上层应用只需一个全局唯一的名字，类似于唯一主键。</li></ul><p>使用ZK来实现一套分布式全局唯一ID的分配机制：数据库的单库单表可以使用自带的 <code>auto_increment</code> 属性来自动为每条记录生成一个唯一ID，但随着数据库数据规模不断增大，分库分表后这个属性就只能针对单一表中记录自动生成ID。</p><p>UUID（通用唯一识别码，Universally Unique Identifier）在分布式系统中常用于作唯一标识元素标准，一个标准的UUID是一个包含32位字符和4个短线的字符串。</p><p>UUID的缺点：</p><ul><li>长度过长：生成的字符串过长，相比INT类型存储开销更大。</li><li>含义不明：字符串本身没有含义。</li></ul><p>可以通过ZK节点来生成全局唯一ID：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010104.png" alt></p><p>ZK中每个数据节点都能维护一份子节点的顺序队列，当客户端创建一个顺序子节点时，ZK会自动以后缀的形式在子节点上添加一个序号：</p><ol><li>所有客户端根据自己的任务类型，在指定类型的任务下通过调用 <code>create()</code> 接口来创建一个顺序节点（如“job-”节点）。</li><li>节点创建完毕， <code>create()</code> 返回一个完整的节点名（如“job-0000000003”）。</li><li>客户端拿到返回值后，拼接上type类型（如“type2-job-0000000003”）作为全局唯一ID。</li></ol><h3 id="1-4-分布式协调-通知"><a href="#1-4-分布式协调-通知" class="headerlink" title="1.4 分布式协调/通知"></a>1.4 分布式协调/通知</h3><p>分布式系统需要引入一个协调者（Coordinator）控制整个系统的运行流程（如分布式事务的处理或机器间的互相协调等）便于将分布式协调的职责从应用本身抽离，减少系统间的耦合性，提供可扩展性。</p><p>基于ZK实现的分布式协调/通知通常做法：不同的客户端都对ZK上同一个数据节点进行Watcher注册，监听数据节点的变化，如果发生变化，所有订阅的客户端都能收到并处理。</p><h4 id="（1）MySQL数据复制总线-Mysql-Replicator"><a href="#（1）MySQL数据复制总线-Mysql-Replicator" class="headerlink" title="（1）MySQL数据复制总线-Mysql_Replicator"></a>（1）MySQL数据复制总线-Mysql_Replicator</h4><p>MySQL数据复制总线是一个实时数据复制框架，<strong>用于在不同的MySQL数据库实例之间进行异步数据复制合数据变化通知</strong>。</p><p>系统是由一个MySQL数据库集群、消息队列系统、任务管理监控平台以及ZK集群等组件共同构成的一个包含数据生产者、复制管道和数据消费者等部分的数据总线系统：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010105.png" alt></p><p>ZK负责一系列的分布式协调工作，根据功能将数据复制组件划分为三个核心模块，每个模块作为独立的进程运行在服务端，运行时数据和配置信息保存在ZK上：</p><ul><li><strong>Core：</strong>实现了数据复制的核心逻辑，将数据复制封装成管道，并抽象出生产者和消费者两个概念，生产者通常是MySQL的Binlog日志。</li><li><strong>Server：</strong>负责启动和停止复制任务。</li><li><strong>Monitor：</strong>负责监控任务的运行状态，如果在数据复制期间发生异常或故障会告警。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010106.png" alt></p><h4 id="（2）Core进行分布式协调的流程"><a href="#（2）Core进行分布式协调的流程" class="headerlink" title="（2）Core进行分布式协调的流程"></a>（2）Core进行分布式协调的流程</h4><ol><li><p><strong>任务注册：</strong></p><p>Core进程启动时，首先向 <code>/mysql_replicator/tasks</code> 节点（任务列表节点）注册任务。当注册过程发现子节点已存在，表示已有其他Task机器注册了该任务，以下为“复制热门商品”的任务：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010107.png" alt></p></li><li><p><strong>任务热备份：</strong></p><ul><li>复制组件采用热备份的容灾方式来应对复制任务可能会遇到的故障，即0将同一个复制任务部署在不同的主机上，主备机器通过ZK互相检测运行健康状况。</li><li>实现热备方案，不管第一步是否创建了任务节点，每台任务机器都要在 <code>/mysql_replicator/tasks/copy_hot_item/instances</code> 节点上将自己的主机名注册上去。注册的是一个临时的顺序节点 <code>/mysql_replicator/tasks/copy_hot_item/instances/[Hostname]-1</code> 最后的序列号是临时顺序节点的精华。</li><li>完成子节点创建后，每台机器都可以通过对比自己是否是所有子节点序号中最小的，如果是就将自己的运行状态置为 RUNNING，其余的机器则设置为 STANDBY，即<strong>小序号优先</strong>。</li></ul></li><li><p><strong>热备切换：</strong></p><ul><li>任务机器在完成状态标识后就可以工作了，RUNNING进行数据复制，STANDBY则进入待命状态，一旦RUNNING的机器出现故障，取一个待命状态最小的机器替补执行。</li><li>所以待命的机器都要在 <code>/mysql_replicator/tasks/copy_hot_item/instances</code> 节点注册一个Watcher监听子节点列表变更，订阅所有任务机器的变化情况，RUNNING机器宕机与ZK断开连接后节点会消失，其余机器收到通知后开启新一轮的RUNNING选举。</li></ul></li><li><p><strong>记录执行状态：</strong>RUNNING机器需要将运行时的上下文保留给STANDBY机器，MySQL选择 <code>/mysql_replicator/tasks/copy_hot_item/lastCommit</code> 作为Binlog日志消费位点的存储节点， RUNNING定时写入当前信息。</p></li></ol><h4 id="（3）Server管理Core组件"><a href="#（3）Server管理Core组件" class="headerlink" title="（3）Server管理Core组件"></a>（3）Server管理Core组件</h4><ol><li><p><strong>控制台协调：</strong>Server的主要工作是通过ZK来对不同任务进行控制和协调，Server将每个复制任务对于生产者的元数据（库名、表名、用户名和密码等数据库信息以及消费者相关信息）以配置的形式写入任务节点 <code>/mysql_replicator/tasks/copy_hot_item</code> 使任务的所有机器都能能共享配置。</p></li><li><p><strong>冷备切换：</strong></p><p>在一定规模的分布式项目中，往往有许多MySQL实例需要进行数据复制，每个实例都要对应一个复制任务，如果每个任务都进行双机热备份会消耗太多的机器。</p><p>根据这个问题设计一种新的冷备份的方案，它对所有任务进行分组：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010108.png" alt></p><p>Core进程被配置了所属Group，<strong>冷备份扫描</strong>：</p><ul><li>假如一个Core进程被标记了group1，启动后会获取对应节点下所有的Task列表。</li><li>如果找到了任务 <code>copy_hot_item</code> 会遍历instances节点，若没有子节点则创建一个临时的顺序节点 <code>copy_hot_item/instances/[Hostname]-1</code> 。</li><li>类似于热备份的小序号优先，<strong>最小的Core进程标记为RUNNING，不同的是其他Core进程会自动将创建的子节点删除，然后继续遍历下一个Task节点</strong>。</li></ul></li><li><p><strong>冷热备份对比：</strong></p><ul><li>热备份：针对一个任务使用两台机器做备份，由于Watcher通知和临时顺序节点的特性，可以实时的进行协调；机器资源消耗较大。</li><li>冷备份：使用了扫描机制，虽然降低了实时性，但节省了机器资源。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010109.png" alt></p></li></ol><h4 id="（4）机器间通信方式"><a href="#（4）机器间通信方式" class="headerlink" title="（4）机器间通信方式"></a>（4）机器间通信方式</h4><p>常见分布式系统机器间通信方式：</p><ul><li><strong>心跳检测：</strong>不同机器之间检测彼此是否在正常运行，使用ZK的临时节点实现而不同于常规的PING或TCP长连接。所有机器在ZK的一个指定节点下创建临时子节点，机器之间可以根据临时节点判断对应机器是否存活，这样机器之间不需要直接交互。</li><li><strong>工作进度汇报：</strong>任务分发到不同机器上执行后，需要实时的将自己的执行进度汇报给分发系统，每个任务客户端在指定节点下创建临时子节点：<ul><li>通过判断临时节点是否存在判断对应任务机器是否存活；</li><li>各个任务机器实时的将自己的任务执行进度写入临时节点，中心系统定时的获取。</li></ul></li><li><strong>系统调度：</strong>控制台将指令发送给所有客户端，实际是改ZK节点的数据，数据变更的通知再发送给客户端。</li></ul><p>用ZK来实现分布式通信可以降低系统间的耦合和减少底层网络通信以及协议设计上的重复工作。</p><h3 id="1-5-集群管理"><a href="#1-5-集群管理" class="headerlink" title="1.5 集群管理"></a>1.5 集群管理</h3><p>集群管理包括：</p><ul><li>集群监控：侧重对集群运行时状态的收集</li><li>集群控制：侧重对集群进行操作与控制</li></ul><h4 id="（1）传统Agent的弊端"><a href="#（1）传统Agent的弊端" class="headerlink" title="（1）传统Agent的弊端"></a>（1）传统Agent的弊端</h4><p>传统基于Agent的分布式集群管理体系，每台机器部署一个Agent，负责主动向指定的监控中心汇报状态，来实现集群监控，其弊端：</p><ul><li><strong>大规模升级困难：</strong>大规模升级的情况下，客户端形式的Agent非常麻烦。</li><li><strong>统一的Agent无法满足多样的需求：</strong>Agent可以满足如CPU使用率、负载、内存使用率、网络吞吐以及磁盘容量等基本物理状态的监控，但如果要深入到业务状态（比如监控每个消费者对消息的消费状态，或是分布式任务调度每台任务机器上的任务执行情况）就不适合由统一的Agent来提供。</li><li><strong>编程语言多样性：</strong>传统的Agent需要提供各种语言版的客户端。</li></ul><h4 id="（2）分布式日志收集系统"><a href="#（2）分布式日志收集系统" class="headerlink" title="（2）分布式日志收集系统"></a>（2）分布式日志收集系统</h4><p>分布式日志收集系统要解决的问题：</p><ul><li><strong>变化的日志源机器：</strong>每个应用的机器几乎每天都是变化的，可能是因为</li><li><strong>变化的收集器机器：</strong>日志收集系统自身也会有机器的变更和扩容。</li></ul><p>流程：</p><ul><li><p><strong>注册收集器机器：</strong>在ZK上创建一个节点作为收集器的根节点，每个收集器机器启动时都会在收集器节点下创建自己的节点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010110.png" alt></p></li><li><p><strong>任务分发：</strong>待所有收集器都创建好自己的节点，根据子节点数目将所有日志源机器分为对应的若干组，然后将分组后的机器列表分别写到收集器创建的子节点上，每台收集器都可以从自己的节点上获取日志源机器列表。</p></li><li><p><strong>状态汇报：</strong>我们要考虑到机器有随时挂掉的可能，所以要有一个收集器的状态汇报机制，每个收集器机器在创建完自己的节点后还要再对应的子节点上创建一个状态子节点，定期向该节点写入自己的状态信息（类似于心跳检测）。</p></li><li><p><strong>动态分配：</strong>如果收集器挂掉或者扩容，需要动态的进行收集任务的分配。在运行过程中，日志系统始终关注着 <code>/logs/collector</code> 节点下所有子节点的变更，一旦检测到有收集器停止汇报或有新的收集器加入就会进行任务的重新分配。</p><p>将之前分配的任务转移的方法：</p><ul><li><strong>全局动态分配：</strong>系统根据新的收集器机器列表，将所有日志源机器重新进行分组，重新分配给当前所有收集器。</li><li><strong>局部动态分配：</strong>在小范围内进行任务的动态分配，每个收集器在汇报状态的同时也携带自己的负载（非CPU负载而是当前任务的综合评估），当收集器挂掉，就优先分配给负载较低的机器，新的机器加入时也会把负载较高的机器部分任务转移过去。</li></ul></li></ul><p>注意事项：</p><ul><li><strong>节点类型：</strong>每个代表收集器的子节点如果是临时节点，当节点失效时会被立即删除，记录的日志源机器列表也会随之消失，所以应该是持久节点。</li><li><strong>日志系统节点监听：</strong>实际生产运行中，收集器更改状态节点的频率可能很高（小于1秒），且收集器数量会很大，日志系统如果要监听所有节点变化，对应的数据量太过庞大，所以日志系统并没有实时的接收每次节点状态变更，大部分都是没什么用的，而是采用<strong>主动轮询</strong>的方案，只是有一点延时。</li></ul><h4 id="（3）在线云主机管理"><a href="#（3）在线云主机管理" class="headerlink" title="（3）在线云主机管理"></a>（3）在线云主机管理</h4><p>集群机器的监控，对机器的状态尤其是机器在线率统计有较高要求，并能对机器变更有快速的响应：</p><ol><li>如何快速统计出当前生产环境一共有多少台机器？</li><li>如何快速获取到机器上下线情况？</li><li>如何实时监控集群中每台主机的运行时状态？</li></ol><ul><li><p><strong>机器上下线：</strong>新增机器时，先将指定的Agent部署到机器，部署启动后向ZK指定节点进行注册，创建一个临时子节点：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010111.png" alt></p><p>创建完子节点后，对 <code>/XAE/machines</code> 节点关注的监控中心会收到“子节点变更”的事件，即上线通知；同理也可以收到下线通知。</p></li><li><p><strong>机器监控：</strong>运行过程中，Agent会定时将主机的运行状态信息写入ZK对应主机节点，监控中心通过订阅这些节点数据变更来获取运行时信息。</p></li></ul><h3 id="1-6-Master选举"><a href="#1-6-Master选举" class="headerlink" title="1.6 Master选举"></a>1.6 Master选举</h3><p>分布式系统中，常常需要Master节点来协调其他单元，如一些读写分离的应用场景，客户端的写请求往往是由Master来处理的。</p><p>分布式环境常见场景：集群中所有系统单元需要对前端业务提供数据，如一个经过一系列海量数据处理计算得到的商品ID，让一台机器计算后共享给其他机器来减少重复劳动，系统可以分为客户端集群、分布式缓存系统、海量数据处理总线和ZooKeeper四个部分：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010112.png" alt></p><p>Client集群每台定时通过ZK完成Master选举，选出的Master进行一系列海量数据处理得到一个结果，将其放置在一个内存/数据库中，并通知其他客户端来获取。</p><p>我们对Master选举的需求是从所有机器中选择一台机器，通常情况下可以使用数据库主键来实现：所有机器插入一条相同主键的记录，成功的一台为Master。但这种方案没法应对Master挂掉的问题，因为关系型数据库无法通知这一事件。</p><p>利用ZooKeeper的强一致性，我们在分布式高并发场景下可以创建一个全局唯一的节点，所以我们可以实现：<strong>每天所有客户端定时创建一个临时节点 <code>/master_election/2013-09-20/binding</code> ，只有一个会成功创建，其就成为了Master，没有创建成功的再次节点上注册一个节点变更的Watcher，监控当前的Master机器是否存活，一旦挂掉就重新进行选举</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010113.png" alt></p><h3 id="1-7-分布式锁"><a href="#1-7-分布式锁" class="headerlink" title="1.7 分布式锁"></a>1.7 分布式锁</h3><p>不同主机共享一组资源，需要互斥手段防止彼此的干扰来保证一致性，此时使用分布式锁。关系型数据库本身具有排他性，来实现不同进程的互斥，但容易导致性能瓶颈。</p><h4 id="（1）排他锁"><a href="#（1）排他锁" class="headerlink" title="（1）排他锁"></a>（1）排他锁</h4><p>排他锁（Exclusive Locks，即X锁）又叫写锁或独占锁，当事务A对数据对象O加排他锁，在持有锁期间只允许事务A对O进行读取和更新操作。</p><ul><li><p><strong>定义锁：</strong>Java常用 synchronized 或 ReentrantLock 来定义锁，ZK没有类似的API来使用，而是直接用一个数据节点来表示一个锁（如 <code>/exclusive_lock/lock</code> ）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010114.png" alt></p></li><li><p><strong>获取锁：</strong>客户端通过调用 <code>create()</code> 接口在 <code>/exclusive_lock</code> 节点下创建临时子节点，最终只有一个可以创建成功，即获取到了锁，没有获取到的客户端在 <code>/exclusive_lock</code> 节点注册一个子节点变更的Watcher监听。</p></li><li><p><strong>释放锁：</strong>因为锁是一个临时节点，有两种情况会释放锁：</p><ul><li>当前获取锁的客户端集群宕机，ZK上此临时节点会被移除。</li><li>正常执行完业务逻辑，客户端主动删除自己创建的临时节点。</li></ul><p>节点删除后，其他客户端收到通知再次发起分布式锁的获取，整个流程如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010115.png" alt></p></li></ul><h4 id="（2）共享锁"><a href="#（2）共享锁" class="headerlink" title="（2）共享锁"></a>（2）共享锁</h4><p>共享锁（Shared Locks，简称S锁）又叫读锁，事务A对数据对象O加上共享锁，其他事务只能对O进行读操作和加共享锁，直到所有共享锁释放。</p><ul><li><p><strong>定义锁：</strong>直接用一个数据节点来表示一个锁（如 <code>/shared_lock/192.168.0.1-R-000000001</code> ）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010116.png" alt></p></li><li><p><strong>获取锁：</strong>客户端到 <code>/shared_lock</code> 节点下创建一个临时顺序节点，若当前是读请求，就创建R类节点；如果是写请求，就创建W类节点。</p></li><li><p><strong>判断读写顺序：</strong></p><ol><li>创建完节点后，获取 <code>/shared_lock</code> 节点下所有子节点，并注册Watcher变更监听。</li><li>确定自己的节点序号在所有子节点中的顺序。</li><li>读写两种情况：<ul><li>读请求：如果没有比自己序号小的子节点，或是小的节点都是读请求，表示自己已经获取到共享锁，同时开始执行读取逻辑。</li><li>写请求：如果自己不是序号最小的子节点，就要进入等待。</li></ul></li><li>接收到Watcher通知后，重复步骤1。</li></ol></li><li><p><strong>释放锁：</strong>流程同排他锁。</p><p>整个流程如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010117.png" alt></p></li></ul><h5 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h5><p>上述共享锁实现可以满足机器规模较小的场景（10台以内），当机器规模较大时，针对判断读写顺序步骤结合下图实例，猜想实际运行的情况。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010118.png" alt></p><p>实际运行：</p><ol><li>192.168.0.1机器首先进行读操作，完成后将首个子节点删除。</li><li>余下4台机器均受到节点移除的通知，重新从 <code>/shared_lock</code> 节点上获取一份新的子节点列表。</li><li>每个机器判断自己的读写顺序，其中192.168.0.2这台机器检测到自己已经是最小机器了，于是开始读操作，而其他机器发现未轮到自己就继续等待。</li><li>继续….</li></ol><p>其中步骤3，该通知发给了所有机器，但实际上只对192.168.0.2这台机器有用，整个流程大量的Watcher通知和子节点列表获取操作重复运行，大部分机器判断的结果都是需要继续等待。<strong>在集群规模较大的场景下，不仅会对ZooKeeper服务器造成巨大的性能影响和网络冲击</strong>，更为严重的是，<strong>若同一时间有多个节点对应的客户端完成事务或是事务中断引起节点消失，ZK服务器就会在短时间内向其余客户端发送大量的事件通知—即羊群效应</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经济学里经常用“羊群效应”来描述经济个体的从众跟风心理。“羊群效应”就是比喻人都有一种从众心理，从众心理很容易导致盲从，而盲从往往会陷入骗局或遭到失败。</span><br></pre></td></tr></table></figure><p>产生问题的原因在于没有找准客户端真正的关注点，每个客户端只需关注比自己小的那一个节点的变更情况即可：</p><ol><li>客户端调用 <code>create()</code> 方法创建一个类似于 <code>/shared_lock/[hostname]-请求类型-序号</code> 的临时顺序节点。</li><li>客户端调用 <code>getChildren()</code> 接口来获取所有已经创建的子节点列表，这里不再注册任何Watcher。</li><li>如果无法获取共享锁，就调用 <code>exist()</code> 来对比自己小的那个节点注册Watcher，读写请求情况不一样：<ul><li>读请求：向比自己序号小的最后一个写请求节点注册</li><li>写请求：向比自己序号小的最后一个节点注册</li></ul></li><li>等待Watcher通知，继续进入步骤2。</li></ol><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010119.png" alt></p><h3 id="1-8-分布式队列"><a href="#1-8-分布式队列" class="headerlink" title="1.8 分布式队列"></a>1.8 分布式队列</h3><p>分布式队列如常见的消息队列：ActiveMQ、Metamorphosis、Kafka和HornetQ等。分为两大类：常规的先入先出队列、等到队列元素集聚后才统一安排的Barrier模型。</p><h4 id="（1）FIFO-先入先出"><a href="#（1）FIFO-先入先出" class="headerlink" title="（1）FIFO-先入先出"></a>（1）FIFO-先入先出</h4><p>使用ZooKeeper实现FIFO队列类似于全写的共享锁模型，所有客户端到 <code>/queue_fifo</code> 节点下创建一个临时顺序节点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010120.png" alt></p><p>创建完节点后，确定执行顺序的步骤：</p><ol><li>通过调用 <code>getChildren()</code> 接口来获取 <code>/queue_fifo</code> 节点下所有的子节点，也就是获取队列中所有的元素。</li><li>确定自己的节点序号在所有子节点中的顺序。</li><li>如果自己不是序号最小的子节点，进入等待，同时向比自己序号小的最后一个节点注册Watcher监听。</li><li>接收到Watcher通知，重复步骤1。</li></ol><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010121.png" alt></p><h4 id="（2）Barrier：分布式屏障"><a href="#（2）Barrier：分布式屏障" class="headerlink" title="（2）Barrier：分布式屏障"></a>（2）Barrier：分布式屏障</h4><p>Barrier原意障碍物，在分布式系统中指系统间的一个协调条件，规定一个队列的元素必须都集聚后才能统一进行安排，否则一直等待。</p><p>开始时，<code>/queue_barrier</code> 节点是一个已存在的默认节点，并将其节点的数据内容赋值为一个数字n来代表Barrier值，当子节点数达到n后才能打开Barrier，所有客户端都要到此节点下创建一个临时节点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010122.png" alt></p><p>创建完节点后，确定执行顺序的步骤：</p><ol><li>通过调用 <code>getData()</code> 接口获取 <code>/queue_barrier</code> 节点的数据内容：10。</li><li>通过调用 <code>getChildren()</code> 接口获取 <code>/queue_barrier</code> 节点下所有子节点，即获取队列中所有元素，同时注册对子节点列表变更的Watcher监听。</li><li>统计子节点的个数。</li><li>如果子节点个数不足10个，需要进入等待。</li><li>接收到Watcher通知后，重复步骤2。</li></ol><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010123.png" alt></p><h2 id="二-大型分布式系统的应用"><a href="#二-大型分布式系统的应用" class="headerlink" title="二. 大型分布式系统的应用"></a>二. 大型分布式系统的应用</h2><p>ZK因为便捷的使用方式、卓越的运行性能和良好的稳定性，已经被广泛的应用在越来越多的大型分布式系统中，用来解决如配置管理、分布式通知/协调、集群管理和Master选举等一系列分布式问题。</p><h3 id="2-1-Hadoop"><a href="#2-1-Hadoop" class="headerlink" title="2.1 Hadoop"></a>2.1 Hadoop</h3><p>Hadoop是Apache开源的一个大型分布式计算框架，定义了一种能够开发和运行处理海量数据的软件规范，用来实现一个在大规模集群中对海量数据进行分布式计算的软件平台。<strong>核心是HDFS和MapReduce，分别提供了对海量数据的存储和计算能力</strong>。0.23.0版本后又引入全新一代MapReduce框架YARN。</p><p>在Hadoop中，ZooKeeper注意用于实现HA（High Availability，高可用）集中于Hadoop Common中的HA模块，HDFS的NameNode与YARN的ResourceManager都是基于此HA模块实现自己的HA功能，YARN还用ZooKeeper来存储应用的运行状态。</p><h4 id="（1）YARN"><a href="#（1）YARN" class="headerlink" title="（1）YARN"></a>（1）YARN</h4><p>YARN是Hadoop为了提高计算节点Master的扩展性，同时为了支持多计算模型和提供资源的细粒度调度而引入的全新一代分布式调度框架。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010124.png" alt></p><p>YARN由四部分组成：</p><ul><li><strong>ResourceManager（RM）：</strong>核心模块，全局资源管理器，负责整个系统的资源管理和分配，同时接收各个节点（NodeManager）的资源汇报信息，并将信息按照一定的策略分配给各个应用程序（ApplicationMaster）。其内部维护了各个应用程序的ApplicationMaster信息、NodeManager信息以及资源使用信息等。</li><li><strong>NodeManager（NM）</strong></li><li><strong>ApplicationMaster（AM）</strong></li><li><strong>Container</strong></li></ul><h4 id="（2）ResourceManager单点问题"><a href="#（2）ResourceManager单点问题" class="headerlink" title="（2）ResourceManager单点问题"></a>（2）ResourceManager单点问题</h4><p>上述架构可以明显看出存在一个问题：ResourceManager单点问题。YARN设计了一套 <strong>Active/Standby 模式的 ResourceManager HA 架构</strong>：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010125.png" alt></p><p>运行期间有多个RM并存，只有一个处于Active状态，另外则处于Standby状态，当Active节点无法正常工作时，其余节点通过竞争选举出新的Active节点。</p><p>YARN使用基于ZooKeeper实现的ActiveStandbyElector组件来确定RM的状态，从而实现多个RM的主备切换：</p><ol><li><strong>创建锁节点：</strong>ZK上会有一个类似于 <code>/yarn-leader-election/pseudo-yarn-rm-cluster</code> 的锁节点，所有RM在启动时，都会去竞争写一个Lock子节点 <code>../ActiveStandbyElectorLock</code> ，该子节点类型是临时节点，创建成功的RM切换为Active状态，没有的切换为Standby状态。</li><li><strong>注册Watcher监听：</strong>Standby状态的RM向 <code>../ActiveStandbyElectorLock</code> 节点注册一个Watcher监听节点变更。</li><li><strong>主备切换：</strong>当Active状态的节点出现异常情况，其创建的Lock节点会随之删除，所有Standby状态的RM收到通知后重复步骤1操作。</li></ol><p>HDFS中的NameNode和ResourceManager都使用该组件来实现各自的HA。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010126.png" alt></p><h4 id="（3）Fencing隔离"><a href="#（3）Fencing隔离" class="headerlink" title="（3）Fencing隔离"></a>（3）Fencing隔离</h4><p>分布式环境中，机器会由于网络闪断或自身负载过高（GC占用时间过长或CPU负载过高）导致无法正常的对外进行及时响应，即“<strong>假死</strong>”的情况。当Active状态的RM1机器发生假死情况，主备切换后RM2成为Active状态，而RM1恢复正常后依然会认为自己处于Active状态，即<strong>分布式脑裂现象</strong>（Brain-Split）。</p><p>Fencing机制利用ZK数据节点的ACL权限控制机制来实现不同RM之间的隔离，多个RM之间通过竞争创建锁节点来实现主备状态的确定，改进为创建的根节点必须携带ZK的ACL信息，目的是为了独占该根节点，防止其他RM对节点进行更新。</p><p>当RM1出现假死后，ZK会将其创建的锁节点移除，RM2创建相应的锁节点并切换为Active状态。RM1恢复之后会试图更新ZK的相关数据，但发现没有权限，说明当前节点不是自己创建的，于是自动切换回Standby状态。</p><h4 id="（4）ResourceManager状态存储"><a href="#（4）ResourceManager状态存储" class="headerlink" title="（4）ResourceManager状态存储"></a>（4）ResourceManager状态存储</h4><p>在ResourceManager中，RMStateStore能够存储一些RM的内部状态信息，包括Application和它们的Attempts信息、Delegation Token及Version Information等，大部分状态信息因为很容易从上下文信息中重构出来所以不需要持久化存储，所以存储的设计方案有：</p><ul><li>基于内存实现，一般用于日常开发测试。</li><li>基于文件系统实现，如HDFS。</li><li>基于ZooKeeper实现。</li></ul><p>Hadoop官方建议使用ZooKeeper来实现，存放在 <code>/rmstore</code> 节点下，RMAppRoot节点下存放的是与各个Application相关的信息，RMDTSecretManagerRoot存放的是安全相关的Token等信息：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010127.png" alt></p><p>每个Active状态的RM在初始化阶段会从ZK上读取这些状态信息。</p><h3 id="2-2-HBase"><a href="#2-2-HBase" class="headerlink" title="2.2 HBase"></a>2.2 HBase</h3><p>HBase，即 Hadoop Database，是 Google Bigtable 的开源实现，基于Hadoop文件系统设计的面向海量数据的高可靠性、高性能、面向列、可伸缩的分布式存储系统。</p><p>与大部分分布式NoSQL数据库不同的是，HBase针对数据写入具有强一致性的特性，甚至包括索引列也实现了强一致性。</p><p>HBase在实现上遵守了 Google BigTable 论文的设计思想，BigTable使用Chubby来负责分布式状态的协调，Chubby是Google实现的一种基于Paxos算法的分布式锁服务，HBase则采用了开源的ZooKeeper服务来完成对整个系统的分布式协调工作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010128.png" alt></p><h4 id="（1）系统冗错"><a href="#（1）系统冗错" class="headerlink" title="（1）系统冗错"></a>（1）系统冗错</h4><p>启动时，每个RegionServer服务器都会到ZK的 <code>/hbase/rs</code> 节点下创建一个信息节点（rs状态节点），同时HMaster对这个节点注册监听。某个RS挂掉，ZK因为一段时间无法收到心跳信息，而删除掉其对应的rs状态节点。</p><p>同时HMaster收到ZK的NodeDelete通知，从而感知到某个节点断开，并立即开始冗错工作，将该RS处理的数据分片Region重新路由到其他节点上，并记录到Meta信息中供客户端查询。</p><p>HMaster不直接通过心跳机制管理RS的状态，因为会随着系统容量的不断增加其管理负担会越来越重。</p><h4 id="（2）RootRegion管理"><a href="#（2）RootRegion管理" class="headerlink" title="（2）RootRegion管理"></a>（2）RootRegion管理</h4><p>数据存储的位置信息记录在元数据分片RootRegion，每次客户端发起请求要知道数据的位置，先要查询RootRegion（存储在ZK上的 <code>/hbase/root-region-server</code> 节点），RootRegion发生变化，如Region的手工移动、Balance或RootRegion所在服务器发生故障，能够通过ZK来感知变化并执行容灾措施，从而保证客户端总能拿到正确的RootRegion信息。</p><h4 id="（3）Region状态管理"><a href="#（3）Region状态管理" class="headerlink" title="（3）Region状态管理"></a>（3）Region状态管理</h4><p>Region是HBase中数据的物理切片，每个Region记录全局数据的一小部分，不同Region间数据不重复。但对于分布式系统来说，Region是会经常因为系统故障、负载均衡、配置修改、Region分裂和合并等发生变更。一旦Region移动就会尽力Offline和重新Online的过程。</p><p>Offline期间数据不能被访问，并且Region的状态变化需要让全局知晓，否则可能导致某些事务性异常。对于HBase集群，Region的数量可能达到10万级别，所以需要依赖ZK来做到。</p><h4 id="（4）分布式SplitLog任务管理"><a href="#（4）分布式SplitLog任务管理" class="headerlink" title="（4）分布式SplitLog任务管理"></a>（4）分布式SplitLog任务管理</h4><p>某台RegionServer服务器挂掉时，总有一部分新写入的数据还没有持久化到HFile中，因此迁移该RegionServer服务时要从HLog中恢复这部分还在内存中的数据，最关键的一步是SplitLog，即HMaster需要遍历该RegionServer服务器的HLog，并按Region切分成小块移动到新的地址下，再进行数据的Replay。</p><p>单个RegionServer的日志量相对庞大（数千个Region，上GB的日志），但又需要系统快速的完成日志的恢复工作，一个可行的方案是将处理HLog的任务分配给多台RegionServer服务器来共同处理，需要一个持久化组件辅助HMaster完成任务的分配。</p><p>HMaster会在ZK上创建一个 <code>/hbase/splitlog</code> 的节点，将哪个RegionServer处理哪个Region这样的信息以列表的形式存放在该节点，各个RegionServer服务器自行到该节点上领取任务并在任务执行成功或失败后更新该节点的信息，以通知HMaster继续进行后续步骤。ZK负责分布式集群中相互通知和信息持久化的角色。</p><h4 id="（5）Replication管理"><a href="#（5）Replication管理" class="headerlink" title="（5）Replication管理"></a>（5）Replication管理</h4><p>HBase通过Replication实现实时的主备同步，从而拥有了容灾和分流等关系型数据库拥有的功能。与传统Replication不同的是，HBase中Replication是多对多的，且每个节点随时都有可能挂掉。</p><p>在ZK上记录一个 <code>/hbase/replication</code> 节点，然后把不同的RegionServer服务器对应的HLog文件名称记录到相应的节点上，HMaster集群会将新增的数据推送给Slave集群，并同时将推送信息记录到ZK上（断点记录），重复以上过程。服务器挂掉时，因为ZK上已经保存了断点信息，只要用这些信息协调推送HLog数据的主节点服务器就可以继续复制。</p><h4 id="（6）ZooKeeper部署"><a href="#（6）ZooKeeper部署" class="headerlink" title="（6）ZooKeeper部署"></a>（6）ZooKeeper部署</h4><p>HBase的启动脚本（hbase-env.sh）中可以选择由HBase启动其自带的默认ZK还是使用一个已有的外部ZK集群。一般建议后者，可以方便多个HBase复用一套ZK集群，但要为每个HBase集群明确指定对应的ZK根节点配置（配置项zookeeper.znode.parent）确保HBase集群间互不干扰。</p><p>对应HBase客户端只要指定ZK的集群地址和对应HBase根节点配置即可。HBase集群启动时会在ZK上逐个添加对应的初始化节点，并在HMaster以及RegionServer进程中进行相应节点的Watcher注册。</p><h3 id="2-3-Kafka"><a href="#2-3-Kafka" class="headerlink" title="2.3 Kafka"></a>2.3 Kafka</h3><p>Kafka是由社交公司LinkedIn于2010年12月份开源的分布式消息系统，由Scala语言开发，广泛运用在Twitter、Netflix和Tumblr等大型互联网站点上。</p><ul><li>主要用于<strong>实现低延迟的发送和收集大量的事件和日志数据</strong>（活跃数据，如网站的PV数和用户访问记录），这些数据以日志的形式记录下来，然后由一个专门的系统进行日志的收集与统计。</li><li>吞吐量极高，整体设计是典型的发布与订阅模式系统。集群中所有服务器都是对等的，可以在不做任何配置更改的情况下实现服务器的添加与删除，消息的生产者和消费者也能做到随意重启和机器上下线。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010129.png" alt></p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><strong>消息生产者：</strong>即Producer，生成消息并发送到Kafka服务器上。</li><li><strong>消息消费者：</strong>即Consumer，负责消费Kafka服务器上的消息。</li><li><strong>主题：</strong>即Topic，由用户定义并配置在Kafka服务端，用于建立生产者和消费者之间的订阅关系：生产者发送消息到指定topic下，消费者从该topic消费消息。</li><li><strong>消息分区：</strong>即Partition，一个topic下分多个分区，如topic1分10个分区，由两台服务器提供，每台5个分区，服务器ID为0和1，分区为0-0到0-4和1-0到1-4。消息分区机制和分区数量与消费者的负载均衡机制有很大关系。</li><li><strong>Broker：</strong>即Kafka的服务器，用于存储消息。</li><li><strong>消费者分组：</strong>即Group，用于归组同类消费者，多个消费者可以共同消费一个topic下的消息，这些消费者组成一个分组/集群。</li><li><strong>Offset：</strong>消息存储在Kafka的Broker上，消费者拉取消息数据的过程需要在文件中的偏移量。</li></ul><h4 id="Broker注册"><a href="#Broker注册" class="headerlink" title="Broker注册"></a>Broker注册</h4><p>Broker、Producer和Consumer是分布式部署，Broker虽然相互独立运行但需要一个注册系统统一管理所有节点。ZK上配置一个Broker节点 <code>/broker/ids</code> ，每个Broker服务器启动时都先会到ZK上进行注册 <code>/broker/ids/[0...N]</code> 一个临时节点。</p><p>使用全局唯一ID（Broker  ID）来指代每台Broker服务器，创建完节点后每个Broker会将自己的IP地址和端口等信息写入此节点。</p><h4 id="Topic注册"><a href="#Topic注册" class="headerlink" title="Topic注册"></a>Topic注册</h4><p>Kafka中将同一个Topic的消息分为多个分区并分布到多个Broker上，这些分区信息和Broker的对应信息也由ZK维护，记录在节点 <code>/brokers/topics</code> ，即Topic节点。每个Topic都会对应一个节点 <code>/brokers/topics/[topic]</code> 。</p><p>Broker服务器启动后，会到对应的Topic节点下注册自己的Broker ID，并写入针对该Topic的分区总数 。如临时节点 <code>/brokers/topics/login3-&gt;2</code> 表明Broker ID为3的一台服务器对应，login这个主题的消息提供了2个分区进行消息存储。 </p><h4 id="生产者负载均衡"><a href="#生产者负载均衡" class="headerlink" title="生产者负载均衡"></a>生产者负载均衡</h4><p>因为一个Topic会进行分区并分布到不同的Broker服务器，所以生产者要合理的将消息发送到对应的Broker上，如何进行生产者的负载均衡？</p><ul><li><strong>四层负载均衡：</strong><ul><li>根据生产者的IP地址和端口为器确定一个相关联的Broker，一个生产者对应一个Broker，其消息都发送给此Broker。</li><li>优点：整体架构简单，每个生产者只需维护和Broker的单个TCP链接。</li><li>缺点：无法做到真正的负载均衡，生产者也无法实时感知到Broker的新增和删除，也就无法做到动态的负载均衡。</li></ul></li><li><strong>ZooKeeper负载均衡：</strong><ul><li>生产者通过Broker节点的变化动态感知到Broker服务器列表的变更，生产者注册对“Broker增加与减少”、“Topic的新增与减少”和“Broker与Topic关联关系的变化”等事件注册Watcher监听。</li><li>开发人员可以控制生产者根据一定规则来进行数据分区，而不仅仅是随机算法。即语义分区。</li></ul></li></ul><h4 id="消费者负载均衡"><a href="#消费者负载均衡" class="headerlink" title="消费者负载均衡"></a>消费者负载均衡</h4><p>每个消费者分组都会分配一个全局唯一的Group ID，每个消费者分配一个全局唯一的Consumer ID，格式为 <code>Hostname:UUID</code> 。</p><h5 id="ZK记录消息分区与消费者关系"><a href="#ZK记录消息分区与消费者关系" class="headerlink" title="ZK记录消息分区与消费者关系"></a>ZK记录消息分区与消费者关系</h5><p>每个消息分区有且只能同事有一个消费者进行消息的消费。所以要在ZK上记录下消息分区与消费者之间的对应关系。当消费者确定了对一个分区的消费权利，要将其Consumer ID写入对应分区的临时节点上，如 <code>/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]</code> 最后即消息分区的标识，节点内容就是消费该分区上消息的消费者的Consumer ID。</p><h5 id="ZK记录消费进度Offset"><a href="#ZK记录消费进度Offset" class="headerlink" title="ZK记录消费进度Offset"></a>ZK记录消费进度Offset</h5><p>消费者对分区进行消费时，要定时的将分区消息的消费进度/Offset（节点为 <code>/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</code> ，内容为Offset值）记录到ZK上去，以便该消费者重启或其他消费者重新接管该消息分区消费后，能够从之前的进度开始继续消费。</p><h5 id="消费者注册"><a href="#消费者注册" class="headerlink" title="消费者注册"></a>消费者注册</h5><p>消费者服务器初始化启动时加入消费者分组的过程：</p><ol><li><strong>注册到消费者分组Group：</strong><ul><li>消费者启动时，在ZK注册自己的临时节点 <code>/consumers/[group_id]/ids/[consumer_id]</code> </li><li>完成创建后，消费者将自己订阅的Topic信息写入该节点。</li></ul></li><li><strong>对Group中消费者的变化注册监听：</strong>每个消费者会关注所属Group中消费者服务器的变化情况，对 <code>/consumers/[group_id]/ids</code> 节点注册子节点变化的Watcher监听，当消费者发生变化，会触发消费者的负载均衡。</li><li><strong>对Broker服务器的变化注册监听：</strong>消费者对 <code>/broker/ids/[0...N]</code> 中的节点进行监听注册，当Broker服务器列表发生变化，会根据具体情况决定是否需要进行消费者的负载均衡。</li><li><strong>进行消费者负载均衡：</strong>让同一个Topic下不同分区的消息尽量均衡的呗多个消费者消费，当一个Group组内消费者服务器发生变更，或Broker服务器发生变更会触发消费者负载均衡。</li></ol><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>一个消费者分组中每个消费者记为C~1~，C~2~，…，C~i~ ，…. ，C~G~ 。对于消费者C~i~其对应的消息分区分配策略为：</p><ol><li>设置P~T~为指定Topic所有的消息分区。</li><li>设置C~G~为同一个消费者分组中所有的消费者。</li><li>对P~T~进行排序，使分布在同一个Broker服务器上的分区尽量靠在一起。</li><li>对C~G~进行排序。</li><li>设置i为C~i~在C~G~中位置的索引值，同事hi设置 N = size(P~T~) / size(C~G~) 。</li><li>将编号为 <code>i*N~(I+1)*N-1</code> 的消息分区分配给消费者C~i~ 。</li><li>重写更新ZooKeeper上消息分区与消费者 C~i~ 的关系。</li></ol><h2 id="三-阿里巴巴的应用实践"><a href="#三-阿里巴巴的应用实践" class="headerlink" title="三. 阿里巴巴的应用实践"></a>三. 阿里巴巴的应用实践</h2><p>未完待续。</p><h3 id="3-1-消息中间件-Metamorphosis"><a href="#3-1-消息中间件-Metamorphosis" class="headerlink" title="3.1 消息中间件-Metamorphosis"></a>3.1 消息中间件-Metamorphosis</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010130.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010131.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010132.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010133.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010134.png" alt></p><h3 id="3-2-RPC服务框架-Dubbo"><a href="#3-2-RPC服务框架-Dubbo" class="headerlink" title="3.2 RPC服务框架-Dubbo"></a>3.2 RPC服务框架-Dubbo</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010135.png" alt></p><h3 id="3-3-基于MySQL-Binlog的增量订阅和消费组件-Canal"><a href="#3-3-基于MySQL-Binlog的增量订阅和消费组件-Canal" class="headerlink" title="3.3 基于MySQL Binlog的增量订阅和消费组件-Canal"></a>3.3 基于MySQL Binlog的增量订阅和消费组件-Canal</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010136.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010137.png" alt></p><h3 id="3-4-分布式数据库同步系统-Otter"><a href="#3-4-分布式数据库同步系统-Otter" class="headerlink" title="3.4 分布式数据库同步系统-Otter"></a>3.4 分布式数据库同步系统-Otter</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010138.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010139.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010140.png" alt></p><h3 id="3-5-轻量级分布式通用搜索平台-终搜"><a href="#3-5-轻量级分布式通用搜索平台-终搜" class="headerlink" title="3.5 轻量级分布式通用搜索平台-终搜"></a>3.5 轻量级分布式通用搜索平台-终搜</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010141.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010142.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010143.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010144.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010145.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010146.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010147.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010148.png" alt></p><h3 id="3-6-实时计算引擎-JStorm"><a href="#3-6-实时计算引擎-JStorm" class="headerlink" title="3.6 实时计算引擎-JStorm"></a>3.6 实时计算引擎-JStorm</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210501/202105010149.png" alt></p><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      内容来自《从Paxos到Zookeeper-分布式一致性原理与实践》，内容包括：应用场景（数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁、分布式队列），分布式系统应用（Hadoop、HBase、Kafka），阿里巴巴应用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="zookeeper" scheme="http://linyishui.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper（三）开源客户端ZkClient和Curator</title>
    <link href="http://linyishui.top/2021051601.html"/>
    <id>http://linyishui.top/2021051601.html</id>
    <published>2021-05-16T06:35:20.000Z</published>
    <updated>2021-05-19T13:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ZooKeeper（三）开源客户端"><a href="#ZooKeeper（三）开源客户端" class="headerlink" title="ZooKeeper（三）开源客户端"></a>ZooKeeper（三）开源客户端</h1><h2 id="一-ZkClient"><a href="#一-ZkClient" class="headerlink" title="一. ZkClient"></a>一. ZkClient</h2><p>ZkClient是GitHub上的一个开源的ZooKeeper客户端，它在ZK原生API接口上进行了包装，同时内部实现了诸如Session超时重连、Watcher反复注册等功能。</p><h3 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zookeeper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sgroschupf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zkclient.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-创建会话"><a href="#1-2-创建会话" class="headerlink" title="1.2 创建会话"></a>1.2 创建会话</h3><p>构造函数API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkClient</span><span class="params">(String serverstring)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkClient</span><span class="params">(String zkServers, <span class="keyword">int</span> connectionTimeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkClient</span><span class="params">(String zkServers, <span class="keyword">int</span> sessionTimeout, <span class="keyword">int</span> connectionTimeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkClient</span><span class="params">(String zkServers, <span class="keyword">int</span> sessionTimeout, <span class="keyword">int</span> connectionTimeout, ZkSerializer zkSerializer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkClient</span><span class="params">(IZkConnection connection)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkClient</span><span class="params">(IZkConnection connection, <span class="keyword">int</span> connectionTimeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkClient</span><span class="params">(IZkConnection connection, <span class="keyword">int</span> connectionTimeout, ZkSerializer zkSerializer)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>zkServers</td><td>指ZooKeeper服务器列表，由英文状态逗号分开的host:port字符串组成，每一个都代表一台ZooKeeper机器，例如，192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181</td></tr><tr><td>sessionTimeout</td><td>会话超时时间，单位为毫秒，默认是30000ms</td></tr><tr><td>connectionTimeout</td><td>连接创建超时时间，单位为毫秒。此参数表明如果在这个时间段内还是无法和ZooKeeper建立连接，就抛出异常</td></tr><tr><td>connection</td><td>IZkConnection接口的实现类</td></tr><tr><td>zkSerializer</td><td>自定义序列化器</td></tr></tbody></table><ul><li>ZooKeeper会话的建立是一个异步的过程，开发人员需要自己来进行等待处理，ZkClient通过内部包装，将这个异步的会话创建过程同步化了，方便开发者使用。</li><li>IZkConnection接口是对ZooKeeper原生接口最直接的包装和交互层，包含了增删改查一系列接口的定义，有两种默认实现 <code>ZkConnection</code> 和 <code>InMemoryConnection</code> 。</li><li>ZkClient中定义了ZkSerializer接口允许用户传入一个序列化实现，如Hessian或Kryo，默认情况下会使用Java自带的序列化方式。</li><li>ZkClient不再需要提供Watcher参数，其引入了Listener来实现Watcher的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ZK客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Create_Session_Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ZkClient zkClient = <span class="keyword">new</span> ZkClient(<span class="string">"domain1.book.zookeeper:2181"</span>, <span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"ZooKeeper session established."</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-创建节点"><a href="#1-3-创建节点" class="headerlink" title="1.3 创建节点"></a>1.3 创建节点</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200140.png" alt></p><p><code>createEphemeral</code> 接口是创建临时节点，<code>createPersistentSequential</code> 则是创建持久顺序节点。</p><p>ZK原生API无法递归创建节点，只能在父节点存在时创建子节点，所以每次都要检查父节点是否存在。ZkClient通过 <code>createParents</code> 参数在内部帮助我们递归建立父节点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200141.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200142.png" alt></p><h3 id="1-4-删除节点"><a href="#1-4-删除节点" class="headerlink" title="1.4 删除节点"></a>1.4 删除节点</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200143.png" alt></p><p><code>deleteRecursive</code> 自动完成逐层遍历删除节点的操作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200144.png" alt></p><h3 id="1-5-读取数据"><a href="#1-5-读取数据" class="headerlink" title="1.5 读取数据"></a>1.5 读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span></span>;</span><br><span class="line"><span class="comment">// 注册事件监听</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">subscribeChildChanges</span><span class="params">(String path, IZkChildListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IZkChildListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IZkChildListener 参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>parentPath</td><td>子节点变更通知对应的父节点的节点路径</td></tr><tr><td>currentChilds</td><td>子节点的相对路径列表，如果没有子节点，会传入null</td></tr></tbody></table><p>节点注册监听后会收到如下事件通知：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200145.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200146.png" alt></p><ul><li>客户端可以对一个不存在的节点进行子节点变更的监听。</li><li>一旦客户端对一个节点注册子节点列表变更监听之后，当该节点的子节点列表发送变更时，服务端都会通知并将最新的子节点列表发送给客户端。</li><li>该节点本身的创建或删除也会通知到客户端。</li><li>ZkClient的Listener不同于Watcher，一旦注册就会一直生效。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Object&gt; <span class="function">T <span class="title">readData</span><span class="params">(String path)</span></span>;</span><br><span class="line">&lt;T extends Object&gt; <span class="function">T <span class="title">readData</span><span class="params">(String path, <span class="keyword">boolean</span> returnNullIfPathNotExists)</span></span>;</span><br><span class="line">&lt;T extends Object&gt; <span class="function">T <span class="title">readData</span><span class="params">(String path, Stat stat)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200147.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样通过注册Listener来实现监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IZkDataListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>dataPath</td><td>事件通知对应的节点路径</td></tr><tr><td>data</td><td>最新的数据内容</td></tr></tbody></table><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200148.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200149.png" alt></p><h3 id="1-6-更新数据"><a href="#1-6-更新数据" class="headerlink" title="1.6 更新数据"></a>1.6 更新数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeData</span><span class="params">(String path, Object data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeData</span><span class="params">(<span class="keyword">final</span> String path, Object data, <span class="keyword">final</span> <span class="keyword">int</span> expectedVersion)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200150.png" alt></p><p>检测指定节点是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="二-Curator"><a href="#二-Curator" class="headerlink" title="二. Curator"></a>二. Curator</h2><p>Curator是由Netflix开发的一套ZooKeeper客户端框架，和ZkClient一样解决了非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等。Curator在ZK原生API的基础上进行了包装，提供了一套易用性和可读性更强的Fluent风格的API框架。除此之外，Curator还提供了ZooKeeper各种应用场景（Recipe，如共享锁服务、Master选举机制和分布式计数器）的抽象封装。</p><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-创建会话"><a href="#2-2-创建会话" class="headerlink" title="2.2 创建会话"></a>2.2 创建会话</h3><ol><li><p>使用 <code>CuratorFrameworkFactory</code> 工厂类的两个静态方法来创建一个客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CuratorFramework <span class="title">newClient</span><span class="params">(String connectString, RetryPolicy retryPolicy)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> CuratorFramework <span class="title">newClient</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeoutMs, <span class="keyword">int</span> connectionTimeoutMs, RetryPolicy retryPolicy)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>通过调用 <code>CuratorFramework</code> 中的 <code>start()</code> 方法来启动会话。</p></li></ol><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200151.png" alt></p><p>Curator通过接口 <code>RetryPolicy</code> 来让用户自定义重试策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allowRetry</span><span class="params">(<span class="keyword">int</span> retryCount, <span class="keyword">long</span> elapsedTimeMs, RetrySleeper sleeper)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200152.png" alt></p><p>使用Curator创建一个ZK客户端会话：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200153.png" alt></p><p><code>ExponentialBackoffRetry</code> 是默认重试策略之一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExponentialBackoffRetry(<span class="keyword">int</span> baseSleepTimeMs, <span class="keyword">int</span> maxRetries);</span><br><span class="line">ExponentialBackoffRetry(<span class="keyword">int</span> baseSleepTimeMs, <span class="keyword">int</span> maxRetries, <span class="keyword">int</span> maxSleepMs);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200154.png" alt></p><p>给定一个初始sleep时间baseSleepTimeMs，在此基础上结合重试次数，通过以下公式计算出当前需要sleep的时间：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前sleep时间 = baseSleepTimeMs * Math.max(<span class="number">1</span>, random.nextInt(<span class="number">1</span> &lt;&lt; (retryCount + <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p>使用Fluent风格的API接口创建会话：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200155.png" alt></p><p>使用Curator创建含隔离命名空间的会话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现不同ZK业务之间的隔离，需要给每个业务分配一个独立的命名空间，即指定一个ZK根路径：</span></span><br><span class="line">    CuratorFrameworkFactory.builder()</span><br><span class="line">                           .connectString(<span class="string">"domain.book.zookeeper:2181"</span>)</span><br><span class="line">                           .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                           .retryPolicy(retryPolicy)</span><br><span class="line">                           .namespace(<span class="string">"base"</span>)</span><br><span class="line">                           .build();</span><br></pre></td></tr></table></figure><h3 id="2-3-创建节点"><a href="#2-3-创建节点" class="headerlink" title="2.3 创建节点"></a>2.3 创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CuratorFramework</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CreateBuilder <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProtectACLCreateModePathAndBytesable&lt;String&gt; <span class="title">creatingParentsIfNeeded</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateModable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">withMode</span><span class="params">(CreateMode mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PathAndBytesable&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">forPath</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">forPath</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><ul><li><p>创建一个节点，初始内容为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(path);</span><br></pre></td></tr></table></figure></li><li><p>创建一个节点，附带初始内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(path, <span class="string">"init"</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>创建一个临时节点，初始内容为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br></pre></td></tr></table></figure></li><li><p>创建一个临时节点，并自动递归创建父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200156.png" alt></p><h3 id="2-4-删除节点"><a href="#2-4-删除节点" class="headerlink" title="2.4 删除节点"></a>2.4 删除节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CuratorFramework</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeleteBuilder <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// Versionable&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">withVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"><span class="comment">// DeleteBuilder</span></span><br><span class="line"><span class="comment">// 客户端执行一个删除节点的操作，可能由于网络原因导致删除失败，在某些场景中这种异常是致命的，比如Master选举。当调用guaranteed()，会记录下这次失败的删除操作，只要客户端会话有效，就会在后台反复重试直到节点删除成功</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeleteBuilderBase <span class="title">guaranteed</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// PathAndBytesable&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">forPath</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">forPath</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><ul><li><p>删除一个节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此接口只能删除叶子节点</span></span><br><span class="line">client.delete().forPath(path);</span><br></pre></td></tr></table></figure></li><li><p>删除一个节点，并递归删除其所有子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().deletingChildrenIfNeeded().forPath(path);</span><br></pre></td></tr></table></figure></li><li><p>删除一个节点，强制指定版本进行删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().withVersion(version).forPath(path);</span><br></pre></td></tr></table></figure></li><li><p>删除一个节点，强制保证删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().forPath(path);</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200157.png" alt></p><h3 id="2-5-读取数据"><a href="#2-5-读取数据" class="headerlink" title="2.5 读取数据"></a>2.5 读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CuratorFramework</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GetDataBuilder <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// Statable&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">storingStatIn</span><span class="params">(Stat stat)</span></span>;</span><br><span class="line"><span class="comment">// Pathable&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">forPath</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><ul><li><p>读取一个节点的数据内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值为byte[]</span></span><br><span class="line">client.getData().forPath(path);</span><br></pre></td></tr></table></figure></li><li><p>读取一个节点的数据内容，同时获取到该节点的stat：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Curator通过传入一个旧的stat变量的方式来存储服务端返回的最新的节点状态信息</span></span><br><span class="line">client.getData().storingStatIn(stat).forPath(path);</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200158.png" alt></p><h3 id="2-6-更新数据"><a href="#2-6-更新数据" class="headerlink" title="2.6 更新数据"></a>2.6 更新数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CuratorFramework</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SetDataBuilder <span class="title">setData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// Versionable&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">withVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"><span class="comment">// PathAndBytesable&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">forPath</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">forPath</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><ul><li><p>更新一个节点的数据内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个stat对象</span></span><br><span class="line">client.setData().forPath(path);</span><br></pre></td></tr></table></figure></li><li><p>更新一个节点的数据内容，强制指定版本进行更新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// withVersion用来实现CAS，version通常由一个旧的stat对象获取到</span></span><br><span class="line">client.setData().withVersion(version).forPath(path);</span><br></pre></td></tr></table></figure></li></ul><p>示例：第一次使用最新的stat变量进行更新操作，第二次则使用了过期的stat变量。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200159.png" alt></p><h3 id="2-7-异步接口"><a href="#2-7-异步接口" class="headerlink" title="2.7 异步接口"></a>2.7 异步接口</h3><p>以上API皆为Curator的同步接口，Curator引入了 <code>BackgroundCallback</code> 接口，用来处理异步接口调用之后服务端返回的结果信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackgroundCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>client</td><td>当前客户端实例</td></tr><tr><td>event</td><td>服务端事件，CuratorEvent定义了ZK服务端发送到客户端的一系列事件参数</td></tr></tbody></table><p>CuratorEvent中比较重要的两个参数：</p><ul><li><strong>事件类型（CuratorEventType）：</strong><code>getType()</code> 代表本次事件的类型<ul><li>CREATE：<code>CuratorFramework#create()</code></li><li>DELETE：<code>CuratorFramework#delete()</code></li><li>EXISXTS：<code>CuratorFramework#checkExists()</code></li><li>GET_DATA：<code>CuratorFramework#getData()</code></li><li>SET_DATA：<code>CuratorFramework#setData()</code></li><li>CHILDREN：<code>CuratorFramework#getChildren()</code></li><li>SYNC：<code>CuratorFramework#sync()</code></li><li>GET_ACL：<code>CuratorFramework#getACL()</code></li><li>WATCHED：<code>Watchable#usingWatcher(Watcher) / Watchable#watched()</code></li><li>CLOSING：ZK客户端与服务端连接断开事件</li></ul></li><li><strong>响应码（int）：</strong>定义在<code>org.apache.zookeeper.KeeperException.Code</code> 中，常见的有：<ul><li>0（OK）接口调用成功</li><li>-4（ConnectionLoss）客户端与服务端连接断开</li><li>-110（NodeExists）指定节点已存在</li><li>-112（SessionExpired）会话已过期</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Backgroudable&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(Object context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback, Object context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback, Executor executor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback, Object context, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure><p>在ZooKeeper中，所有异步通知事件处理都由EventThread线程来处理，其串行处理机制在绝大部分应用场景下能够保证对事件处理的顺序性，但也有弊端就是一旦碰到一个复杂的处理单元，就会消耗过长的处理时间，从而影响到对其他事件的处理。因此接口会让用户传入一个Executor实例，把复杂的事件处理放到一个专门的线程池中，如 <code>Executors.newFixedThreadPool(2)</code> 。</p><p>示例：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200160.png" alt></p><h3 id="2-8-典型使用场景"><a href="#2-8-典型使用场景" class="headerlink" title="2.8 典型使用场景"></a>2.8 典型使用场景</h3><p>参考案例都在recipes包中，需要单独引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="（1）事件监听"><a href="#（1）事件监听" class="headerlink" title="（1）事件监听"></a>（1）事件监听</h4><p>Curator引入了Cache来实现对ZK服务端事件的监听，Cache可以看作是一个本地缓存视图和远程ZooKeeper视图的对比过程，同时自动处理反复监听。<strong>Cache分为两种：节点监听（NodeCache）和子节点监听（PathChildrenCache）。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeCache用于监听指定ZK数据节点本身的变化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NodeCache</span><span class="params">(CuratorFramework client, String path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NodeCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> dataIsCompressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeCache定义了事件处理的回调接口NodeCacheListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NodeCacheListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">voidnodeChanged</span><span class="params">()</span> throw Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>client</td><td>Curator客户端实例</td></tr><tr><td>path</td><td>数据节点的节点路径</td></tr><tr><td>dataIsCompressed</td><td>是否进行数据压缩</td></tr></tbody></table><p>示例： </p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200161.png" alt></p><p><code>start()</code> 有个布尔类型参数，默认为false，当设置为true时NodeCache首次启动会立即从ZK上读取对应节点的数据内容，并保存在Cache中。NodeCache不仅可以用于监听数据节点的内容变更，也能监听节点是否存在。若原本节点不存在，Cache会在节点创建后触发NodeCacheListener。</p><p><code>PathChildrenCache</code> 用于监听指定ZK数据节点的子节点变化情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData, ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> dataIsCompressed, ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> dataIsCompressed, <span class="keyword">final</span> ExecutorService executorService)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> dataIsCompressed, <span class="keyword">final</span> CloseableExecutorService executorService)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件处理的回调接口，子节点发生变化时回调方法，事件类型包括：新增子节点、数据变更、子节点删除三类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PathChildrenCacheListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200162.png" alt></p><p>示例：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200163.png" alt></p><h4 id="（2）Master选举"><a href="#（2）Master选举" class="headerlink" title="（2）Master选举"></a>（2）Master选举</h4><p>分布式系统常见场景：一个复杂的任务，仅需从集群中选举出一台仅需处理即可。</p><p>大致思路：选择一个根节点，如 <code>/master_select</code> ，多台机器同时向该节点创建一个子节点 <code>/master_select/lock</code> 最终只有一台机器能创建成功，就相当于被选为Master。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200164.png" alt></p><p>监听器 LeaderSelectorListenerAdapter 需要自行实现，Curator会在成功获取Master权利后回调此监听器：执行完方法会立即释放权利，重新开始下一轮选举</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200165.png" alt></p><h4 id="（3）分布式锁"><a href="#（3）分布式锁" class="headerlink" title="（3）分布式锁"></a>（3）分布式锁</h4><p>为了保证分布式环境的数据一致，需要在程序某个运行节点进行同步控制，比如用时间戳来生成流水号，以下示例展示这种典型的并发问题：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200166.png" alt></p><p>因为没有同步导致了上述的数据重复问题，可以使用Curator来实现分布式锁：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200167.png" alt></p><h4 id="（4）分布式计数器"><a href="#（4）分布式计数器" class="headerlink" title="（4）分布式计数器"></a>（4）分布式计数器</h4><p>统计系统的在线人数，我们可以指定一个ZK数据节点作为计数器，多个应用实例在分布式锁的控制下，通过更新该数据节点来实现计数（可以直接使用封装的 DistributedAtomicInteger）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200168.png" alt></p><h4 id="（5）分布式Barrier"><a href="#（5）分布式Barrier" class="headerlink" title="（5）分布式Barrier"></a>（5）分布式Barrier</h4><p>Barrier是一种用来控制多线程之间同步的经典方法，JDK自带CyclicBarrier实现：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200169.png" alt></p><p>多线程在并发情况下，都会准确的等待所有先都处于就绪状态后才开始同时执行其他业务逻辑，但分布式系统有多个JVM，此时可以使用Curator提供的DistributedBarrier：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200170.png" alt></p><p>上述为主线程触发Barrier释放不同，Curator还提供了另一种线程自发的触发Barrier释放：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200171.png" alt></p><h4 id="（6）Curator提供的工具"><a href="#（6）Curator提供的工具" class="headerlink" title="（6）Curator提供的工具"></a>（6）Curator提供的工具</h4><p>较常用的有 ZKPaths 和 EnsurePath，前者可以来构建ZNode路径、递归创建和删除节点等：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200172.png" alt></p><p>后者提供了一种能确保数据节点存在的机制，有些场景我们要做某些操作必须先要确保节点存在，若不存在就要先创建节点，但分布式环境中可能有其他机器也在尝试创建该节点，就导致我们创建时得到“节点已存在”的异常。</p><p>EnsurePath采取了静默的节点创建方式：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200173.png" alt></p><h4 id="（7）单元测试-TestingServer"><a href="#（7）单元测试-TestingServer" class="headerlink" title="（7）单元测试 TestingServer"></a>（7）单元测试 TestingServer</h4><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200174.png" alt></p><h4 id="（8）集群测试-TestingCluster"><a href="#（8）集群测试-TestingCluster" class="headerlink" title="（8）集群测试 TestingCluster"></a>（8）集群测试 TestingCluster</h4><p>使用示例：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200175.png" alt></p><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      内容来自《从Paxos到Zookeeper-分布式一致性原理与实践》，内容包括：ZkClient的API和使用示例，Curator的API和使用示例等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="zookeeper" scheme="http://linyishui.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper（二）Java客户端API</title>
    <link href="http://linyishui.top/2021051501.html"/>
    <id>http://linyishui.top/2021051501.html</id>
    <published>2021-05-15T04:11:16.000Z</published>
    <updated>2021-05-19T13:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ZooKeeper（二）Java客户端API"><a href="#ZooKeeper（二）Java客户端API" class="headerlink" title="ZooKeeper（二）Java客户端API"></a>ZooKeeper（二）Java客户端API</h1><h2 id="一-创建会话"><a href="#一-创建会话" class="headerlink" title="一. 创建会话"></a>一. 创建会话</h2><p>通过构建一个ZooKeeper对象来创建会话，这是一个异步过程，构造函数会在处理完客户端初始化后立即返回，此时会话处于CONNECTING状态。会话真正创建完毕后，服务端向客户端发送一个事件通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数API</span></span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher);</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly);</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd);</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200115.png" alt></p><p>实例代码如图：重写了process方法负责处理收到的Watcher通知，收到服务端发送的SyncConnected事件后，解除主程序在CountDownLatch上的等待阻塞。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200116.png" alt></p><p>复用sessionId，维持之前会话：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200117.png" alt></p><h2 id="二-创建节点"><a href="#二-创建节点" class="headerlink" title="二. 创建节点"></a>二. 创建节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步创建节点</span></span><br><span class="line"><span class="function">String <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], List&lt;ACL&gt; acl, CreateMode createMode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], List&lt;ACL&gt; acl, CreateMode createMode, StringCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p>ZooKeeper节点内容只支持字节数组类型（byte[]），即ZooKeeper不负责为节点内容进行序列化，需要开发人员自己使用序列化工具操作。</p><p>默认不需要关注权限参数，只需在acl中传入 <code>Ids.OPEN_ACL_UNSAFE</code> ，表示不受权限控制。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200118.png" alt></p><p>创建同步节点，分别创建临时节点和临时顺序节点，二者返回值不一样。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200119.png" alt></p><p>创建异步节点，只需要实现 <code>AsyncCallback.StringCallback()</code> 接口即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200120.png" alt></p><p>AsyncCallback包括七种不同的回调接口：</p><ul><li>StatCallback</li><li>DataCallback</li><li>ACLCallback</li><li>ChildrenCallback</li><li>Children2Callback</li><li>StringCallback</li><li>VoidCallback</li></ul><p>同步接口调用过程需要关注抛出异常的可能，异步接口本身不抛出异常，素有异常都在回调函数中通过响应码（Result Code）体现。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200121.png" alt></p><h2 id="三-删除节点"><a href="#三-删除节点" class="headerlink" title="三. 删除节点"></a>三. 删除节点</h2><p>ZooKeeper只允许删除叶子节点，即如果节点存在子节点就无法被直接删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">int</span> version, VoidCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200122.png" alt></p><h2 id="四-读取数据"><a href="#四-读取数据" class="headerlink" title="四. 读取数据"></a>四. 读取数据</h2><h3 id="（1）getChildren"><a href="#（1）getChildren" class="headerlink" title="（1）getChildren"></a>（1）getChildren</h3><p>获取一个节点下的所有子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watcher)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, ChildrenCallback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, ChildrenCallback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, Stat stat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, Children2Callback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, Children2Callback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200123.png" alt></p><p>当有子节点被添加或删除时，服务端会向客户端发送一个 <code>NodeChildrenChanged(EventType.NodeChildrenChanged)</code> 类型的事件通知。要注意该通知不包含最新的节点列表，客户端必须主动重新获取。</p><p>使用同步接口获取子节点列表：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200124.png" alt></p><p>注意，Watcher通知是一次性的，一旦触发一次通知，该Watcher就失效了，因此客户端需要反复注册Watcher。</p><p>使用异步接口获取子节点列表：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200125.png" alt></p><p>异步接口经常被应用在这样的使用场景：应用启动时获取一些配置信息，如“机器列表”，这些配置通常较大，并且不希望配置的获取影响应用的主流程。</p><h3 id="（2）getData"><a href="#（2）getData" class="headerlink" title="（2）getData"></a>（2）getData</h3><p>获取一个节点的数据内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] getData(String path, <span class="keyword">boolean</span> watcher, Stat stat);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, DataCallback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, DataCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200126.png" alt></p><p>当节点的状态发生变更，ZooKeeper服务端向客户端发送一个 <code>NodeDataChanged(EventType.NodeDataChanged)</code> 的事件通知。节点的数据内容和数据版本变化都被看作是节点的变化。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200127.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200128.png" alt></p><h2 id="五-更新数据"><a href="#五-更新数据" class="headerlink" title="五. 更新数据"></a>五. 更新数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stat <span class="title">setData</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, StatCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200129.png" alt></p><p><code>getData</code> 读取数据接口并未提供根据指定数据版本来获取数据的接口，<code>setData</code> 此处的version类似于CAS比较并交换原理，对应预期值表示针对此版本更新，这样在一个客户端读取并修改中间其他客户端的修改会使这次修改无效，从而避免并发问题。</p><p>分别使用不同的version进行了三次更新操作：数据版本从0开始，-1非合法的数据版本，这里用来告诉服务端，客户端要基于最新版本进行更新操作。第三次操作使用了之前的数据版本1所以导致更新失败。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200130.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200131.png" alt></p><h2 id="六-检测节点是否存在"><a href="#六-检测节点是否存在" class="headerlink" title="六. 检测节点是否存在"></a>六. 检测节点是否存在</h2><p>检测节点是否存在，返回一个stat对象，当节点被创建、被删除或数据被更新会通过Watcher通知客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watcher)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, StatCallback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, StatCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200132.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200133.png" alt></p><p>上述示例中，先后进行了如下操作：</p><ol><li>通过exists接口检测是否存在指定节点，同时注册了一个Watcher。</li><li>创建节点/zk-book，此时服务端马上会向客户端发送一个事件通知：NodeCreated。客户端收到该事件通知后，再次调用exists接口，同时注册Watcher。</li><li>更新该节点的数据，这个时候，服务端又会向客户端发送一个事件通知：NodeDataChanged。客户端收到该事件通知后，继续调用exists接口，同时注册Watcher。</li><li>创建子节点/zk-book/c1。</li><li>删除子节点/zk-book/c1。</li><li>删除节点/zk-book。此时客户端会收到服务端的事件通知：NodeDeleted。</li></ol><p>综上所述，可以得知：</p><ul><li>无论指定节点是否存在，通过调用exists接口都可以注册Watcher。</li><li>exists接口中注册的Watcher，能够对节点创建、节点删除和节点数据更新事件进行监听。</li><li>对于指定节点的子节点的各种变化，都不会通知客户端。</li></ul><h2 id="七-权限控制"><a href="#七-权限控制" class="headerlink" title="七. 权限控制"></a>七. 权限控制</h2><p>集群模式下的ZooKeeper，不同的应用之间往往是不会存在共享数据的使用场景的，因此需要解决不同应用之间的权限问题。</p><p>通过设置服务端上数据节点的ACL，来控制客户端对该节点的访问权限。ZooKeeper提供了多种权限控制模式：</p><ul><li>world</li><li>auth</li><li>digest：主要讲解该模式</li><li>ip</li><li>super</li></ul><p>客户端在会话创建后，调用 <code>addAuthInfo(String scheme, byte[] auth)</code> 接口进行权限信息的设置：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200134.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200135.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200136.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200137.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200139.png" alt></p><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      内容来自《从Paxos到Zookeeper-分布式一致性原理与实践》，内容包括：创建会话、节点，删除节点，读取、更新数据，检测节点是否存在，权限控制等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="zookeeper" scheme="http://linyishui.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper（一）概述和ZAB协议</title>
    <link href="http://linyishui.top/2021051001.html"/>
    <id>http://linyishui.top/2021051001.html</id>
    <published>2021-05-10T13:27:05.000Z</published>
    <updated>2021-05-19T13:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ZooKeeper（一）概述和ZAB协议"><a href="#ZooKeeper（一）概述和ZAB协议" class="headerlink" title="ZooKeeper（一）概述和ZAB协议"></a>ZooKeeper（一）概述和ZAB协议</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是ZooKeeper？"><a href="#1-1-什么是ZooKeeper？" class="headerlink" title="1.1 什么是ZooKeeper？"></a>1.1 什么是ZooKeeper？</h3><ul><li>Apache ZooKeeper 由 Apache Hadoop 子项目发展而来。</li><li>ZooKeeper是一个开源的分布式协调服务，由雅虎创建，Google Chubby 的开源实现。</li><li>设计目标是将那些复杂易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</li><li>ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如<strong>统一命名服务</strong>、<strong>配置关联</strong>和<strong>分布式锁</strong>等分布式的基础服务。</li><li>ZooKeeper并没有直接采用 Paxos 算法，而是一种被称为 ZAB（ZooKeeper Atomic Broadcast）的一致性协议。</li></ul><p>ZooKeeper 是一个典型的分布式数据一致性的解决方案，应用可以基于它实现诸如<strong>数据发布/订阅</strong>、<strong>负载均衡</strong>、<strong>命名服务</strong>、<strong>分布式协调/通知</strong>、<strong>集群管理</strong>、<strong>Master选举</strong>、<strong>分布式锁</strong>和<strong>分布式队列</strong>等功能。</p><h3 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h3><ul><li><strong>顺序一致性：</strong>从同一客户端发起的事务请求，将会严格的按照发送顺序被应用到ZooKeeper中。</li><li><strong>原子性：</strong>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，要么整个集群所有机器都成功应用了某个事务，要么都没有应用。</li><li><strong>单一视图：</strong>无论客户端连接哪个ZooKeeper服务器，看到的服务端数据模型都是一致的。</li><li><strong>可靠性：</strong>一旦服务端成功应用了一个事务，并完成对客户端的响应，事务引起的服务端状态一直保留到下个事务进行变更。</li><li><strong>实时性：</strong>ZooKeeper仅保证在一定时间段内，客户端最终一定能够从服务端读取到最新的数据状态。</li></ul><h3 id="1-3-设计目标"><a href="#1-3-设计目标" class="headerlink" title="1.3 设计目标"></a>1.3 设计目标</h3><ol><li><strong>简单的数据模型：</strong>分布式程序通过一个共享的、树型结构的名字空间来相互协调</li><li><strong>可以构建集群：</strong>一般3~5台机器可以组成一个可用的ZooKeeper集群，每台机器都会在内存中维护当前的服务器状态，机器之间互相都保持着通信。ZooKeeper客户端会与任意一台机器创建一个TCP连接，一旦连接断开，客户端会自动连接到其他机器。</li><li><strong>顺序访问：</strong>ZooKeeper为客户端的每个更新请求分配一个全局唯一的递增编号，反映了事务操作的先后顺序。</li><li><strong>高性能：</strong>ZooKeeper将全量数据存储在内存中，直接服务于客户端的所有非事务请求，非常适合于读操作为主的场景。</li></ol><h3 id="1-4-核心概念"><a href="#1-4-核心概念" class="headerlink" title="1.4 核心概念"></a>1.4 核心概念</h3><ul><li><p><strong>集群角色：</strong></p><ul><li>最典型的集群模式是Master/Slave（主备模式），能够处理所有写操作的是Master机器，所有通过异步复制方式获取最新数据，并提供读服务的机器是Slave机器。</li><li>ZooKeeper并没有采用这种模式，而是引入了新的三个角色：<ul><li><strong>Leader：</strong>集群中所有机器通过选举过程选定一个Leader，其为客户端提供读和写服务。</li><li><strong>Follower：</strong>提供读服务。</li><li><strong>Observer：</strong>提供读服务，不参与Leader选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以在不影响写性能的情况下提高集群的读性能。</li></ul></li></ul></li><li><p><strong>会话（Session）：</strong></p><ul><li>在ZooKeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。</li><li>ZooKeeper对外的服务端口默认是2181，客户端启动时首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始，客户端通过这个连接进行心跳检测与服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接收响应，同时还能通过该连接接收服务器的Watch事件通知。</li><li>sessionTimeout值用来设置一个客户端会话的超时时间。因服务器压力过大、网络故障或客户端主动断开连接等导致的连接断开，只要在sessionTimeout规定时间内重新连上一台服务器，之前创建的会话仍会有效。</li></ul></li><li><p><strong>数据节点（ZNode）：</strong>分布式中节点即每台机器，在ZooKeeper中，节点分为两类：</p><ul><li><strong>机器节点：</strong>构成集群的机器</li><li><strong>数据节点：</strong>数据模型中的数据单元，即ZNode，又可以分为<ul><li><strong>持久节点：</strong>一旦此ZNode被创建，除非主动进行移除操作，否则将一直保存。</li><li><strong>临时节点：</strong>生命周期和客户端会话绑定，一旦客户端会话失效，该客户端创建的所有临时节点都会被移除。</li></ul></li></ul><p>数据模型是一棵树，由斜杠（<code>/</code>）进行分割的路径，就是一个ZNode，如 <code>/foo/path1</code> 。每个ZNode上都会保存自己的数据内容，以及一系列属性信息。</p><p>ZooKeeper允许用户为每个节点添加一个特殊的属性：SEQUENTIAL，当节点标记此属性，在节点创建时会自动在节点名后追加一个由父节点维护的自增整型数字。</p></li><li><p><strong>版本：</strong>ZooKeeper的每个ZNode都会维护一个叫做 <strong>Stat</strong> 的数据结构，Stat中记录了节点的三个数据版本：</p><ul><li>version：当前ZNode的版本</li><li>cversion：当前ZNode子节点的版本</li><li>aversion：当前ZNode的ACL版本</li></ul></li><li><p><strong>Watcher：</strong>即事件监听器，用户可以在指定节点上注册一些Watcher，在一些特定事件触发时，ZooKeeper服务端会将事件通知到感兴趣的客户端上。</p></li><li><p><strong>ACL：</strong>ZooKeeper采用 Access Control Lists 策略来进行权限控制，类似于UNIX文件系统的权限控制，定义了5种权限：</p><ul><li><strong>CREATE：</strong>创建子节点的权限</li><li><strong>READ：</strong>获取节点数据和子节点列表的权限</li><li><strong>WRITE：</strong>更新节点数据的权限</li><li><strong>DELETE：</strong>删除子节点的权限</li><li><strong>ADMIN：</strong>设置节点ACL的权限</li></ul></li></ul><h2 id="二-ZAB-协议"><a href="#二-ZAB-协议" class="headerlink" title="二. ZAB 协议"></a>二. ZAB 协议</h2><h3 id="2-1-什么是ZAB协议？"><a href="#2-1-什么是ZAB协议？" class="headerlink" title="2.1 什么是ZAB协议？"></a>2.1 什么是ZAB协议？</h3><p>ZooKeeper并没有完全采用 Paxos 算法，而是使用了一个称为 ZooKeeper Atomic Broadcast（ZAB，ZooKeeper<strong>原子消息广播协议</strong>）的协议来作为其数据一致性的核心算法。</p><p>ZAB协议是一种支持崩溃恢复的原子广播协议，最初只是为雅虎公司内部一些<strong>高吞吐量、低延迟、健壮、简单</strong>的分布式系统场景设计的，并不像Paxos算法那样通用和可扩展。</p><p>基于该协议，ZooKeeper实现了一种<strong>主备模式</strong>的系统架构来保持集群中各副本之间的数据一致性。ZooKeeper使用一个单一的主进程来接收并处理客户端所有的事务请求，通过ZAB的原子广播协议将服务器的数据状态以事务Proposal的形式广播到所有的副本进程。该主备模型保证了<strong>同一时刻集群中只能有一个主进程来广播服务器的状态变更</strong>，因此能够很好的处理客户端大量的并发请求。并且<strong>支持分布式环境中对于顺序状态的需求</strong>（有些状态变更必须依赖于比它早生成的状态变更），保证了一个全局的变更序列被顺序应用。因为主进程随时可能崩溃或重启，还要做到主进程有问题时仍能正常工作。</p><p>所有事务请求必须由一个全局唯一的服务器来协调处理，即Leader服务器，余下的服务器成为Follower服务器。Leader服务器负责将一个客户端事务请求转换为一个事务 Proposal（提议），并将该提议分发给集群中所有的Follower服务器。之后Leader服务器等待所有Follower服务器的反馈，一旦超过半数进行了正确的反馈，Leader服务器再次向所有的Follower服务器分发Commit消息，要求将前一个提议提交。</p><h3 id="2-2-协议介绍"><a href="#2-2-协议介绍" class="headerlink" title="2.2 协议介绍"></a>2.2 协议介绍</h3><p>ZAB协议包含两种基本模式：</p><ul><li><strong>崩溃恢复：</strong><ul><li>当整个服务框架在启动过程，或是Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB进入该模式选举产生新的Leader服务器。</li><li>选出新的Leader，且集群中已有过半的机器与新的Leader完成状态同步（指数据同步，用来保证过半机器与Leader保持一致）之后，ZAB退出该模式。</li></ul></li><li><strong>消息广播：</strong><ul><li>集群中有过半的Follower服务器完成了与Leader服务器的状态同步，服务框架进入该模式。</li><li>当一台遵守ZAB协议的服务器启动并加入集群时，若此时已存在Leader服务器，它会自觉的进入数据恢复模式：找到Leader所在服务器，并与其进行数据同步，然后一起参与到消息广播流程中。</li></ul></li></ul><h4 id="（1）消息广播"><a href="#（1）消息广播" class="headerlink" title="（1）消息广播"></a>（1）消息广播</h4><p>消息广播的过程类似于二阶段提交：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200111.png" alt></p><p>ZAB没有中断逻辑，所以Follower服务器反馈Ack后就可以提交事务Proposal，这种简化模型自然存在Leader单点故障引起的数据不一致问题。ZAB协议通过崩溃恢复模式来解决这个问题。</p><p>整个消息广播协议基于具有FIFO特性的TCP协议来进行网络通信，很容易保证消息接收和发送的顺序性。Leader为每个事务Proposal分配一个全局单调递增的事务ID（ZXID），每个事务按照ZXID的先后顺序进行排序和处理。</p><p>Leader服务器为每个Follower服务器各自分配一个队列，将需要广播的事务Proposal依次放入队列中，根据FIFO的策略进行消息发送。每个Follower服务器收到事务Proposal后，首先以事务日志的形式写入到本地磁盘中，在成功写入后反馈给Leader一个Ack响应。收到超过半数的Ack响应后，Leader会广播一个Commit消息给所有Follower服务器以通知进行事务提交，同时Leader完成自己的事务提交。</p><h4 id="（2）崩溃恢复"><a href="#（2）崩溃恢复" class="headerlink" title="（2）崩溃恢复"></a>（2）崩溃恢复</h4><p>进入崩溃恢复模式后，需要选举出一个新的Leader服务器，这需要一个高效且可靠的选举算法，不仅需要让新Leader自己知道已被选举为Leader，还要让集群中所有机器快速感知到这点。</p><p><strong>ZAB协议要确保那些已经在Leader服务器上提交的事务最终被所有服务器提交。</strong></p><p>假设一个事务已在Leader服务器提交，但在将Commit消息发送给所有Follower之前，Leader挂掉了：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200112.png" alt></p><p><strong>ZAB协议要确保丢弃那些只在Leader服务器上被提出的事务。</strong></p><p>相反，在崩溃恢复过程中出现一个需要被丢弃的提案，在崩溃恢复结束后需要跳过该事务Proposal：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200113.png" alt></p><p>针对以上两点，如果Leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号（ZXID）的事务Proposal，就可以保证新选举出的Leader一定具有所有已经提交的提案，还可以省区Leader服务器检查Proposal的提交和丢弃工作这一步。</p><p>完成Leader选举后，在正式工作前，Leader服务器首先要确认事务日志中所有的Proposal是否都已经被集群中过半的机器提交了，即<strong>是否完成数据同步</strong>。</p><ul><li>Leader为每个Follower准备一个队列，将没有被各Follower同步的事务以Proposal消息的形式逐个发送给Follower，并每个都跟着发送一个Commit消息。</li><li>等到所有Follower都将其尚未同步的事务Proposal从Leader上同步过来并成功应用到本地数据库后，Leader将该Follower加如到真正可用的Follower列表，并开始之后流程。</li></ul><p><strong>如何处理需要丢弃的事务Proposal？</strong></p><p>ZXID时一个64位的数字，低32位可以看作简单的递增计数器，高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader服务器，就会从Leader上取出其本地日志中最大事务Proposal的ZXID，解析出epoch值并加1，将此编号作为新的epoch，并将低32位置0。</p><p>这样可以区分开不同的Leader周期变化，从而避免不同的Leader服务器错误的使用相同的ZXID提出不同的事务Proposal。</p><p>当一个包含了上个周期尚未提交的事务Proposal的服务器启动时，其肯定无法成为Leader。因为当前集群一定包含一个Quorum集合，集合中的机器一定包含了更高epoch的事务Proposal，因此该机器肯定非最高编号事务。当其连接上Leader后，Leader根据自己记录的最后被提交的Proposal对比，并要求Follower进行一个回退操作—回退到一个确实已经被集群过半机器提交的最新的事务Proposal（如上图4-4 Server1连接后，会被要求去除P3）。</p><h3 id="2-3-深入剖析"><a href="#2-3-深入剖析" class="headerlink" title="2.3 深入剖析"></a>2.3 深入剖析</h3><p>未完待续…</p><h4 id="（1）-系统模型"><a href="#（1）-系统模型" class="headerlink" title="（1） 系统模型"></a>（1） 系统模型</h4><h4 id="（2）-问题描述"><a href="#（2）-问题描述" class="headerlink" title="（2） 问题描述"></a>（2） 问题描述</h4><h4 id="（3）-算法描述"><a href="#（3）-算法描述" class="headerlink" title="（3） 算法描述"></a>（3） 算法描述</h4><h4 id="（4）-运行分析"><a href="#（4）-运行分析" class="headerlink" title="（4） 运行分析"></a>（4） 运行分析</h4><h3 id="2-4-ZAB与Paxos算法的异同"><a href="#2-4-ZAB与Paxos算法的异同" class="headerlink" title="2.4 ZAB与Paxos算法的异同"></a>2.4 ZAB与Paxos算法的异同</h3><ul><li>二者都存在一个Leader进程角色，负责协调多个Follower进程的运行。</li><li><p>Leader进程都会等待超过半数的Follower进程正确反馈后，才会将提案提交。</p></li><li><p>ZAB协议中标识Leader周期的epoch值，Paxos算法中叫Ballot。</p></li></ul><p>二者的本质区别在于设计目标不同，ZAB协议用于构建一个高可用的分布式数据主备系统，而Paxos算法则用于构建一个分布式的一致性状态机系统。</p><h2 id="三-简单使用"><a href="#三-简单使用" class="headerlink" title="三. 简单使用"></a>三. 简单使用</h2><h3 id="3-1-部署与运行"><a href="#3-1-部署与运行" class="headerlink" title="3.1 部署与运行"></a>3.1 部署与运行</h3><p>ZooKeeper使用Java语言编写，所以需要1.6以上版本的Java环境。ZooKeeper包含集群和单机两种运行模式。</p><h4 id="（1）部署"><a href="#（1）部署" class="headerlink" title="（1）部署"></a>（1）部署</h4><ol><li><p>下载安装包并解压：<code>http:zookeeper.apache.org/releases.html</code></p></li><li><p>配置文件 <code>zoo.cfg</code> ：</p><p><code>%ZK_HOME%/conf</code> 目录下 <code>zoo_sample.cfg</code> 重命名为 <code>zoo.cfg</code> </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tickTime=2000</span></span><br><span class="line"><span class="string">dataDir=/var/lib/zookeeper/</span></span><br><span class="line"><span class="string">clientPort=2181</span></span><br><span class="line"><span class="string">initLimit=5</span></span><br><span class="line"><span class="string">syncLimit=2</span></span><br><span class="line"><span class="comment"># server.id=host:port:port 用来感知集群由哪些机器构成，id表示机器序号，dataDir目录下需要有一个myid文件，内容为一个数字对应此id</span></span><br><span class="line"><span class="string">server.1=&lt;IP1&gt;:2888:3888</span></span><br><span class="line"><span class="string">server.2=&lt;IP2&gt;:2888:3888</span></span><br><span class="line"><span class="string">server.3=&lt;IP3&gt;:2888:3888</span></span><br></pre></td></tr></table></figure><ul><li>集群模式下所有cfg文件都应是一致的，最好使用代码仓库管理起来。</li><li>id取值范围为 ：1~255。</li></ul></li><li><p>创建 <code>myid</code> 文件，在dataDir指定目录下，内容为数字id</p></li><li><p>为所有机器配置2和3步内容</p></li><li><p>启动服务器：使用 <code>%ZK_HOME%/bin</code> 目录下的 <code>zkServer.sh</code> 脚本启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh zkServer.sh start</span></span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.4.3/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li><li><p>验证服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> telnet 127.0.0.1 2181</span></span><br><span class="line">stat</span><br></pre></td></tr></table></figure></li></ol><p>单机模式与集群模式只是在 <code>zoo.cfg</code> 的配置上有些差异，<code>server.id</code> 只有一项 <code>server.1</code> 。</p><h4 id="（2）运行和停止"><a href="#（2）运行和停止" class="headerlink" title="（2）运行和停止"></a>（2）运行和停止</h4><p>启动服务：</p><ul><li>Java命令行：在 <code>%ZK_HOME%</code> 目录下执行命令 <code>java -cp zookeeper -3.4.3 jar:lib/ slf4j-api-1.6. 1. jar:lib/slf4j- log4j12-1.6.1.jar:lib/log4j-1.2.15.jar:conf org. apache. zookeeper. server.quorum.QuorumPeerMain conf/zoo.cfg</code> 注意log4j和slf4j版本</li><li>自带的启动脚本</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200114.png" alt></p><p>停止服务：<code>sh zkServer.sh stop</code></p><h4 id="（3）常见异常"><a href="#（3）常见异常" class="headerlink" title="（3）常见异常"></a>（3）常见异常</h4><ul><li><strong>端口被占用：</strong><code>java.net.BindException: Address already in use</code> 异常是因为2181端口被其他进程占用，关闭对应进程并重启ZK即可。</li><li><strong>磁盘没有剩余空间：</strong><code>java.io.IOException: No space left on device</code> 遇到此异常，ZK会立即执行Failover策略，从而退出进程。清理磁盘空间，为了避免后续再次遇到此问题，最好加上对ZK服务器磁盘使用的监控和ZK日志的自动清理。</li><li><strong>无法找到 <code>myid</code> 文件：</strong>缺少此文件，创建即可。</li><li><strong>集群中其他机器Leader选举端口未开：</strong> <code>Cannot open channel to 2 at election adress /xx.xx.xx.xx:3888</code> 这是由于启动过程中，虽然当前机器启动了，但其他机器还未启动完。ZK使用3888端口进行Leader选举过程的投票通信。</li></ul><h3 id="3-2-客户端脚本"><a href="#3-2-客户端脚本" class="headerlink" title="3.2 客户端脚本"></a>3.2 客户端脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入bin目录，确认是否连接上ZK服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sh zkCli.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接指定ZK服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sh zkCli.sh -server ip:port</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个ZK节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s或e分别指定节点特性顺序或临时节点，不加则默认为持久节点；acl进行权限控制，默认不加控制</span></span><br><span class="line">create [-s] [-e] path data acl</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在根节点下创建一个叫/zk-book的节点，内容为123</span></span><br><span class="line">create /zk-book 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls列出ZK指定节点下所有子节点</span></span><br><span class="line">ls path [watch]</span><br><span class="line">ls /</span><br><span class="line"><span class="meta">#</span><span class="bash"> get命令获取指定节点的数据内容和属性信息</span></span><br><span class="line">get path [watch]</span><br><span class="line">get /zk-book</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新指定节点的数据内容，version参数指定本次更新基于ZNode哪个数据版本进行</span></span><br><span class="line">set path data [version]</span><br><span class="line">set /zk-book 456</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除，要删除节点，其不能包含子节点</span></span><br><span class="line">delete path [version]</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      内容来自《从Paxos到Zookeeper-分布式一致性原理与实践》，内容包括：概述，ZAB协议，简单使用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="zookeeper" scheme="http://linyishui.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://linyishui.top/2021042101.html"/>
    <id>http://linyishui.top/2021042101.html</id>
    <published>2021-04-21T13:27:05.000Z</published>
    <updated>2021-05-13T08:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="一-从ACID到CAP-BASE"><a href="#一-从ACID到CAP-BASE" class="headerlink" title="一. 从ACID到CAP/BASE"></a>一. 从ACID到CAP/BASE</h2><h3 id="1-1-ACID"><a href="#1-1-ACID" class="headerlink" title="1.1 ACID"></a>1.1 ACID</h3><p>数据库事务和ACID可以参看：<a href="2020120801.html">《高性能MySQL》（一）架构和历史</a> 中事务章节。</p><h3 id="1-2-什么是分布式事务"><a href="#1-2-什么是分布式事务" class="headerlink" title="1.2 什么是分布式事务"></a>1.2 什么是分布式事务</h3><p>分布式数据库中，数据分散在不同的机器上，分布式事务中事务的参与者、支持事务的服务器、资源服务器以及事务管理器可能分别位于不同的节点上。</p><p>思考如何实现分布式的事务处理？</p><p>首先我们要把分布式事务看作一组分布式的操作序列，即一组子事务，所以分布式事务也具有ACID的事务特性。</p><p>实现分布式事务，保证数据的严格一致性时必然要牺牲掉部分系统可用性。</p><h3 id="1-3-CAP"><a href="#1-3-CAP" class="headerlink" title="1.3 CAP"></a>1.3 CAP</h3><p>CAP理论：一个分布式系统不可能同时满足<strong>一致性</strong>（Consistency）、<strong>可用性</strong>（Availability）和<strong>分区容错性</strong>（Partition tolerance），最多同时满足其中两项。</p><ul><li>一致性：分布式中指数据在多个副本间能否保持一致。对一个数据更新且执行成功后，所有用户都要能读到最新的值。</li><li>可用性：系统服务必须一直处于可用的状态，用户的每个操作请求总是能在<strong>有限的时间</strong>内<strong>返回结果</strong>。系统存在一个合理的响应时间，否则就会使用户对系统失望。</li><li>分区容错性：分布式系统在遇到任何网络分区故障时，仍要保证对外提供满足一致性和可用性的服务。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200102.png" alt></p><p>对于分布式系统来说，分区容错性是一个最基本的要求，因为分布式必然要把组件部署到不同的节点，网络问题必定会出现，所以架构设计师往往需要把精力花在如何根据业务特点在一致性和可用性之间寻求平衡。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200101.png" alt></p><h3 id="1-4-BASE理论"><a href="#1-4-BASE理论" class="headerlink" title="1.4 BASE理论"></a>1.4 BASE理论</h3><p>BASE 是 <strong>Basically Available（基本可用），Soft state（软状态）和 Eventually consistent（最终一致性）</strong>，是对CAP中一致性和可用性权衡的结果，核心思想是即使无法做到强一致性（Strong consistency），每个应用都可以根据自身业务特点采用适当的方式来使系统最终一致性（Eventual consistency）。</p><p><strong>基本可用</strong>，指分布式系统在出现不可预知的故障时，允许损失部分可用性，但这不等价于系统不可用：</p><ul><li><strong>响应时间上的损失</strong>：如正常情况下，搜索引擎要在0.5秒内返回给用户查询结果，但由于故障导致响应时间增加到1到2秒。</li><li><strong>功能上的损失</strong>：如正常情况下，消费者能在商城平台顺利完成每一笔订单，但在一些节日购物高峰为了保证系统稳定，部分消费者可能被引导到一个降级页面。</li></ul><p><strong>弱状态</strong>：也叫软状态，指允许系统中的数据存在中间状态，并认为该中间状态的存在不影响系统整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程出现延时。</p><p><strong>最终一致性</strong>：系统中所有的数据副本，经过一段时间的同步后，最终能够达到一个一致的状态。最终一致性的5种变种：</p><ul><li><strong>因果一致性（Causial consistency）：</strong>进程A在更新完某个数据后通知了进程B，进程B能读取到A更新后的最新值，如果B要对数据进行更新要基于此最新值，即不能发生丢失更新的情况；而与此无关的进程C无此限制。</li><li><strong>读己之所写（Read your writes）：</strong>进程A更新一个数据后，自己总能访问更新后的最新值，是一种特殊的因果一致性。</li><li><strong>会话一致性（Session consistency）：</strong>系统保证在同一个有效的会话中实现读己之所写的一致性。</li><li><strong>单调读一致性（Monotonic read consistency）：</strong>如果一个进程从系统中读出一个数据后，系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li><li><strong>单调写一致性（Monotonic write consistency）：</strong>系统保证来自同一个进程的写操作被顺序的执行。</li></ul><p>现代的关系型数据库中，往往会采用同步和一步的方式来实现主备数据复制技术：</p><ul><li>同步方式：数据的复制过程通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。</li><li>异步方式：备库的更新往往存在延时，取决于事务日志在主备数据库之间传输的时间长短，如果时间过久或传输中出现异常导致无法及时将事务应用到备库，就会导致数据不一致。</li></ul><p>BASE理论不同于传统事务ACID的强一致性模型，提出牺牲强一致性来获得可用性，允许数据在一段时间内不一致，但最终达到一致性状态。</p><h2 id="二-一致性协议"><a href="#二-一致性协议" class="headerlink" title="二. 一致性协议"></a>二. 一致性协议</h2><p>有很多的经典的一致性协议和算法来解决分布式一致性问题，最著名的有<strong>二阶段提交协议</strong>、<strong>三阶段提交协议</strong>和<strong>Paxos算法</strong>。</p><h3 id="2-1-二阶段提交-2PC"><a href="#2-1-二阶段提交-2PC" class="headerlink" title="2.1 二阶段提交-2PC"></a>2.1 二阶段提交-2PC</h3><p>2PC，即二阶段提交，Two-Phase Commit 的缩写，为了使分布式系统下所有的节点在进行事务处理过程中能保持<strong>原子性</strong>和<strong>一致性</strong>而设计的算法。目前大部分关系型数据库都采用2PC来完成分布式事务处理。</p><p>执行流程：</p><ul><li><strong>阶段一：提交事务请求</strong>（也叫投票阶段）<ol><li><strong>事务询问：</strong>协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，等待各参与者响应。</li><li><strong>执行事务：</strong>各参与者执行事务操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志。</li><li><strong>各参与者向协调者反馈事务询问的响应：</strong>参与者成功执行了事务操作，反馈给协调者Yes响应，表示事务可以执行；若未执行成功，反馈No。</li></ol></li><li><strong>阶段二：执行事务提交</strong>（所有参与者都反馈Yes，进行阶段二）<ol><li><strong>发送提交请求：</strong>协调者向所有参与者节点发出 <code>Commit</code> 请求。</li><li><strong>事务提交：</strong>参与者收到 <code>Commit</code> 请求，正式执行事务提交操作，在完成提交后释放事务资源。</li><li><strong>反馈事务提交结果：</strong>参与者在完成事务提交之后，向协调者发送 <code>Ack</code> 消息。</li><li><strong>完成事务：</strong>协调者收到所有参与者的 <code>Ack</code> 消息后，完成事务。</li></ol></li><li><strong>中断事务：</strong>当某个参与者反馈了No响应、或等待接收所有参与者反馈超时之后，执行中断事务<ol><li><strong>发送回滚请求：</strong>协调者向所有参与者节点发出 <code>Rollback</code> 请求。</li><li><strong>事务回滚：</strong>参与者接收到 <code>Rollback</code> 请求后，利用其在阶段一中记录的 <code>Undo</code> 信息来执行事务回滚操作，并释放事务占用资源。</li><li><strong>反馈事务回滚结果：</strong>参与者完成回滚后，向协调者发送 <code>Ack</code> 消息。</li><li><strong>中断事务：</strong>协调者收到所有参与者反馈的 <code>Ack</code> 消息后，完成事务中断。</li></ol></li></ul><p>2PC的核心是每个事务都采用<strong>先尝试后提交</strong>的处理方式，可以看作一个强一致性算法。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200104.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200105.png" alt></p><p>优缺点：</p><ul><li>优点：原理简单，实现方便。</li><li>缺点：同步阻塞、单点问题、脑裂、太过保守<ul><li><strong>同步阻塞：</strong>在二阶段的提交过程，所有参与该事务操作的逻辑都处于阻塞状态，各个参与者在等待其他参与者响应的过程无法进行其他操作。</li><li><strong>单点问题：</strong>协调者太过重要，一旦出现问题整个流程就无法运作，如果是在阶段二出现问题，更会导致参与者都处于锁定事务资源的状态。</li><li><strong>数据不一致：</strong>在阶段二执行事务提交时，当协调者向所有参与者发生Commit请求后，发生局部网络异常或是协调者自身未发送完即崩溃，导致只有部分参与者收到了Commit请求。收到的提交事务，未收到的无法提交，出现数据不一致现象。</li><li><strong>太过保守：</strong>参与者出现故障而导致协调者始终无法获取到所有响应，此时只能依靠协调者自身的超时机制来判断是否需要中断事务，显得过于保守，没有完善的容错机制，导致一个节点的失败导致整个事务失败。</li></ul></li></ul><h3 id="2-2-三阶段提交-3PC"><a href="#2-2-三阶段提交-3PC" class="headerlink" title="2.2 三阶段提交-3PC"></a>2.2 三阶段提交-3PC</h3><p>3PC，即三阶段提交，Three-Phase Commit的缩写，针对2PC的缺陷进行了优化，将2PC的提交事务请求过程一分为2。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200106.png" alt></p><p>执行阶段：</p><ul><li><strong>阶段一：CanCommit</strong><ol><li><strong>事务询问：</strong>协调者向所有参与者发送一个包含事务内容的 <code>canCommit</code> 请求，询问是否可以执行事务提交操作，并开始等待各参与者响应。</li><li><strong>各参与者向协调者反馈事务询问的响应：</strong>参与者接收到 <code>canCommit</code> 请求后，若判断自己可以顺利执行事务则反馈Yes响应，并进入预备状态，否则反馈No响应。</li></ol></li><li><strong>阶段二：PreCommit</strong><ul><li><strong>执行事务预提交：</strong>协调者收到所有Yes反馈<ol><li><strong>发送预提交请求：</strong>协调者向所有参与者发送一个包含事务内容的 <code>preCommit</code> 请求，并进入 <code>Prepared</code> 阶段。</li><li><strong>事务预提交：</strong>参与者接收到 <code>preCommit</code> 请求后，执行事务操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志。</li><li><strong>各参与者向协调者反馈事务执行的响应：</strong>参与者成功执行了事务操作，反馈给协调者 <code>Ack</code> 响应，同时等待最终指令（commit或abort）。</li></ol></li><li><strong>中断事务：</strong>任意一个参与者反馈了No响应、或等待超时后仍未收到所有参与者的反馈响应<ol><li><strong>发送中断请求：</strong>协调者向所有参与者发送 <code>abort</code> 请求。</li><li><strong>中断事务：</strong>无论是收到协调者的 <code>abort</code> 请求，或是等待协调者请求超时，参与者都会中断事务。</li></ol></li></ul></li><li><strong>阶段三：doCommit</strong><ul><li><strong>执行提交：</strong>协调者处于正常状态，且收到了所有参与者的 <code>Ack</code> 响应<ol><li><strong>发送提交请求：</strong>协调者将从预提交状态转换为提交状态，并向所有参与者发送 <code>doCommit</code> 请求。</li><li><strong>事务提交：</strong>参与者收到 <code>doCommit</code> 请求，正式执行事务提交操作，完成提交后释放事务资源。</li><li><strong>反馈事务提交结果：</strong>参与者完成事务提交后，向协调者发送 <code>Ack</code> 消息。</li><li><strong>完成事务：</strong>协调者收到所有参与者的 <code>Ack</code> 消息后，完成事务。</li></ol></li><li><strong>中断事务：</strong>协调者处于正常状态，且有任一的参与者反馈了No响应，或者等待超时后仍未收到所有参与者响应<ol><li><strong>发送中断请求：</strong>协调者向所有参与者发送 <code>abort</code> 请求。</li><li><strong>事务回滚：</strong>参与者接收到 <code>abort</code> 请求后，利用其在阶段二中记录的 <code>Undo</code> 信息来执行事务回滚操作，并释放事务占用资源。</li><li><strong>反馈事务回滚结果：</strong>参与者完成回滚后，向协调者发送 <code>Ack</code> 消息。</li><li><strong>中断事务：</strong>协调者收到所有参与者反馈的 <code>Ack</code> 消息后，完成事务中断。</li></ol></li></ul></li></ul><p>进入阶段三后可能会出现两种故障：</p><ul><li>协调者出现问题</li><li>协调者和参与者之间网络出现故障</li></ul><p>最终都会导致参与者无法及时收到 <code>doCommit</code> 请求或 <code>abort</code> 请求，这时参与者会在等待超时后继续进行事务提交。</p><p>优缺点：</p><ul><li>优点：相较2PC降低了参与者的阻塞范围，能够在出现单点故障后达成一致。</li><li>缺点：3PC在去除阻塞的同时也带来了新问题，就是在参与者收到 <code>preCommit</code> 请求后，如果网络出现分区，这时协调者所在的节点和参与者无法进行正常的网络通信，这个参与者仍会进行事务的提交，导致了数据不一致性。</li></ul><h3 id="2-3-Paxos-算法"><a href="#2-3-Paxos-算法" class="headerlink" title="2.3 Paxos 算法"></a>2.3 Paxos 算法</h3><p>Paxos 算法由 Leslie Lamport 于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题的最有效算法之一。Paxos 算法解决了分布式系统中发生任何的机器宕机或网络异常，都不会破坏整个系统的一致性。</p><p>Paxos算法支持分布式节点角色之间的轮换，避免了分布式单点的出现，既解决了无限期等待问题，也解决了脑裂问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拜占庭将军问题：</span><br><span class="line"></span><br><span class="line">拜占庭帝国有多支军队，不同军队的将军之间需要制定一个统一的行动计划，从而做出进攻或撤退的决定，各个将军在地理上被分割开，只能依靠通讯员进行联络。通讯员中可能存在叛徒，可以任意的篡改消息。</span><br></pre></td></tr></table></figure><p>理论上来说，在异步系统和不可靠通道上来达到一致性状态是不可能的，因此往往假设信道是可靠的。现实中，大部分系统都部署在同一个局域网，消息被篡改的情况比较罕见；硬件或网络原因导致的消息不完整问题，只需一套简单的校验算法即可避免。因此实际工程实践中，可以假设不存在拜占庭将军问题，我们需要什么样的算法来保证一致性？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">古希腊有一个叫 Paxos 的小岛，岛上采用议会的形式来通过法令，议员间通过信使进行消息的传递，议员或信使都是兼职的，随时可能离开议会厅，信使可能会重复的传递消息，也可能一去不回。议会协议要保证在这种情况下仍能正确的产生法令，并且不出现冲突。</span><br></pre></td></tr></table></figure><p>Paxos算法的核心是一个一致性算法，即 Lamport 的论文 The Part-Time Parliament 中提到的 synod 算法。</p><h4 id="2-3-1-问题描述"><a href="#2-3-1-问题描述" class="headerlink" title="2.3.1 问题描述"></a>2.3.1 问题描述</h4><p>对于一个一致性算法来说要保证几点：</p><ul><li>在这些被提出的提案中，只有一个会被选定。</li><li>如果没有提案被提出，就不会有被选定的提案。</li><li>当一个提案被选定后，进程应该可以获取被选定的提案信息。</li></ul><p>一致性的安全性需求：（Paxos的目标就是保证最终有一个提案被选定）</p><ul><li>只有被提出的提案才能被选定。</li><li>只能有一个值被选定。</li><li>如果某个进程认为某个提案被选定了，这个提案必须是真的被选定的那个。</li></ul><p>在该一致性算法中，有三种参与角色：Proposer（提议人）、Acceptor（接收人）和 Learner ，一个进程可能充当不只一种角色，假设不同参与者之间可以通过收发消息来进行通信：</p><ul><li>每个参与者以任意的速度执行，可能会因为出错而停止，也可能会重启。即使一个提案被选定后，所有参与者也有可能失败或重启，因此除非失败或重启的参与者可以记录某些信息，否则将无法确定最终的值。</li><li>消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被损坏，即消息内容不会被篡改。</li></ul><h4 id="2-3-2-提案的选定"><a href="#2-3-2-提案的选定" class="headerlink" title="2.3.2 提案的选定"></a>2.3.2 提案的选定</h4><p>选定一个唯一提案，最简单的方案是只允许一个 Acceptor 存在，Proposer 只能发送提案给它，Acceptor 选择它接收到的第一个提案，这种方案存在单点故障。</p><p>存在多个 Acceptor ：Proposer 向一个 Acceptor 集合发送提案，集合中每个 Acceptor 都可能会批准该提案，当有足够多的 Acceptor 批准这个提案时，就可以认为它被选定了。</p><h4 id="2-3-3-推导过程"><a href="#2-3-3-推导过程" class="headerlink" title="2.3.3 推导过程"></a>2.3.3 推导过程</h4><p>需求：在没有失败和消息丢失的情况下，即使只有一个提案被提出，也要选出一个提案。</p><p>这就意味着<strong>P1：一个 Acceptor 必须批准它收到的第一个提案</strong>。这可能会导致每个 Acceptor 都批准了第一个提案，但没有一个提案是多数人批准的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200107.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200108.png" alt></p><p>一个提案需要由半数以上的 Acceptor 批准的需求暗示着<strong>一个 Acceptor 必须能够批准不止一个提案</strong>。</p><p>Paxos 使用一个<strong>全局编号</strong>来唯一标识每一个被 Acceptor 批准的提案，当一个具有某 Value 值的提案被半数以上的 Acceptor 批准后，即该 Value 被选定了和该提案被选定了。提案变成了一个由编号和 Value 组成的组合体 “【编号, Value】”。</p><p><strong>P2：如果编号为M~0~、Value值为V~0~的提案被选定了，那么所有比编号M~0~更高的，且被选定的（被 Acceptor 批准的）提案，其Value值必须也是V~0~</strong></p><p>通信是异步的，一个提案可能会在某个 Acceptor 还未收到任何提案时就被选定了，所以仍需要P1来保证提案会被选定。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200109.png" alt></p><p><strong>P2b：如果一个提案[M~0~, V~0~]被选定后，那么之后任何 Proposer 产生的编号更高的提案，其Value值必须也是V~0~</strong></p><p>因为一个提案必须在被 Proposer 提出后才能被 Acceptor 批准，所以P2b包含P2。</p><h4 id="2-3-4-数学归纳法证明"><a href="#2-3-4-数学归纳法证明" class="headerlink" title="2.3.4 数学归纳法证明"></a>2.3.4 数学归纳法证明</h4><p>需要证明结论：<strong>假设某个提案[M~0~, V~0~]被选定了，证明任何编号M~n~&gt;M~0~的提案，其Value值都是V~0~</strong>。</p><p>我们可以通过对M~n~进行第二数学归纳法进行证明，即证明：<strong>假设编号在M~0~到M~n-1~之间的提案，其Value值都是V~0~，证明编号为M~n~的提案的Value值也为V~0~</strong>。</p><p>因为M~0~的提案已被选定，意味着肯定存在一个由半数以上的 Acceptor 组成的集合C，都批准了提案。<strong>C中的每个 Acceptor 都批准了在M~0~到M~n-1~范围内的提案，并且每个编号在M~0~到M~n-1~之间的被批准的提案，其Value值都是V~0~</strong>。</p><p>因为任何包含半数以上的 Acceptor 组成的集合都至少包含一个C的成员，所以如果保持下面P2c的不变性，可以认为编号为M~n~的提案的Value值也为V~0~。</p><p><strong>P2c：对于任意的M~n~和V~n~，如果提案[M~n~, V~n~]被提出，那么肯定存在一个由半数以上的 Acceptor 组出的集合S，满足以下两个两个条件中的任意一个：</strong></p><ul><li>要么，S中不存在任何批准过编号小于M~n~的提案的 Acceptor。</li><li>要么，选取S中所有 Acceptor 批准的编号小于 M~n~ 的提案，其中编号最大的哪个提案其 Value 值是 V~n~ 。</li></ul><p>P2c=&gt;P2b=&gt;P2，通过P2和P1保证一致性。</p><p>假设提案[M~0~, V~0~]被选定了，需要证明在P2c的前提下，对于所有的[M~n~, V~n~]，存在 V~n~ = V~0~ ：（第二数学归纳法）</p><ol><li>当 M~n~ = M~0~ + 1 时，因为[M~0~, V~0~]被选定了，一定会存在一个 Acceptor 的子集S，S中的 Acceptor 已批准了小于 M~n~ 的提案，因此 V~n~ 只能是S中编号小于  M~n~ 但为最大编号的提案。因为 M~n~ = M~0~ + 1 ，所以提案是 [M~0~, V~0~] ；同时由于S和通过[M~0~, V~0~]的集合都是多数集，所以二者一定存在交集，这样 Proposer 在确定 V~n~ 取值时一定会选择 V~0~ 。</li><li>编号在 M~0~ + 1 到 M~n~ - 1 之间的Value值都为 V~0~ ，要证明编号为 M~n~ 的提案的Value值也为 V~0~ 。根据P1c，一定会存在一个 Acceptor 的子集S，S中的 Acceptor 已批准了小于 M~n~ 的提案，那么编号为 M~n~ 的提案的Value值只能是S中编号小于 M~n~ 但为最大编号的提案的值。只要编号落在 M~0~ + 1 到 M~n~ - 1 之间，那么Value值就是 V~0~ ；如果不落在区间内，那肯定是 M~0~ ，因为S肯定会和批准[M~0~, V~0~]的集合有交集，如果编号为 M~0~ ，那么其Value值也为 V~0~ 。</li></ol><h4 id="2-3-5-Proposer-生成提案"><a href="#2-3-5-Proposer-生成提案" class="headerlink" title="2.3.5 Proposer 生成提案"></a>2.3.5 Proposer 生成提案</h4><p>对于 Proposer 来说，获取已经被通过的提案远比预测未来可能被通过的提案简单。因此 <strong>Proposer 在产生一个编号为 M~n~ 的提案时，必须要知道当前一个将要或已经被半数以上 Acceptor 批准的编号小于 M~n~ 的最大提案编号。并且 Proposer 会要求所有 Acceptor 不再批准任何编号小于 M~n~ 的提案</strong>。  </p><p><strong>提案生成算法</strong>：</p><ol><li>Proposer 选择一个新的提案编号 M~n~ ，然后向某个 Acceptor 集合的成员发送请求（即编号为 M~n~ 的提案的 Prepare 请求），要求该集合中的 Acceptor 做出如下回应。<ul><li>向 Proposer 承诺，保证不再批准任何编号小于 M~n~ 的提案。</li><li>如果 Acceptor 已经批准过任何提案，那么其就向 Proposer 反馈当前该 Acceptor 已经批准的编号小于 M~n~ 但为最大编号的那个提案的值。</li></ul></li><li>如果 Proposer 收到了来自半数以上的 Acceptor 的响应结果，那么它可以产生编号为 M~n~ 、Value值为 V~n~ 的提案，V~n~ 是所有响应中编号最大的提案的 Value 值。还有一种情况，即半数以上都未批准过任何提案，也即响应中不包含任何提案，此时 V~n~ 值可以由 Proposer 任意选择。</li></ol><p>Proposer 发送给 Acceptor 选定的提案期望获得批准的请求叫Accept请求。接受请求的 Acceptor 集合不一定是之前响应Prepare请求的那一个。</p><h4 id="2-3-6-Acceptor-批准提案"><a href="#2-3-6-Acceptor-批准提案" class="headerlink" title="2.3.6 Acceptor 批准提案"></a>2.3.6 Acceptor 批准提案</h4><p>一个 Acceptor 可能接收到两种来自 Proposer 的请求：</p><ul><li><strong>Prepare请求：</strong>Acceptor 可以在任何时候响应。</li><li><strong>Accept请求：</strong>在不违背Accept现有承诺的前提下，任意响应Accept请求。</li></ul><p><strong>P1a：一个 Acceptor 只要尚未响应过任何编号大于 M~n~ 的Prepare请求，它就可以接受这个编号为 M~n~ 的提案。</strong></p><h4 id="2-3-7-算法优化"><a href="#2-3-7-算法优化" class="headerlink" title="2.3.7 算法优化"></a>2.3.7 算法优化</h4><p>假设一个 Acceptor 收到了一个编号为 M~n~ 的Prepare请求，但此时它已经对大于 M~n~ 的Prepare请求做出了响应，因此它肯定不会再批准编号 M~n~ 的提案，所以 Acceptor 没有必要对此请求做出响应，可以选择忽略这种Prepare请求。同理还可以忽略已经批准过的提案的Prepare请求。</p><p>这样 Acceptor 只需记住它已经批准的提案的最大编号和它已经做出Prepare请求响应的提案的最大编号，以便再出现故障或节点重启时也能保证P2c的不变性。</p><p>对于 Proposer 来说，只要保证不会产生相同编号的提案，可以丢弃任意提案和运行时状态信息。</p><h4 id="2-3-8-算法陈述"><a href="#2-3-8-算法陈述" class="headerlink" title="2.3.8 算法陈述"></a>2.3.8 算法陈述</h4><p>综上所述，可以得到一个类似二阶段提交的算法执行过程：</p><ul><li>阶段一<ol><li>Proposer 选择一个提案编号 M~n~ ，然后向 Acceptor 的某个超过半数的子集成员发送编号为 M~n~ 的Prepare请求。</li><li>如果一个 Acceptor 收到一个编号为 M~n~ 的Prepare请求，且编号 M~n~ 大于它已经响应的所有Prepare请求的编号，那么它会将它已经批准过的最大编号的提案作为响应反馈给 Proposer ，同时承诺不会再批准小于编号 M~n~ 的任何提案。</li></ol></li><li>阶段二<ol><li>如果 Proposer 收到来自半数以上的 Acceptor 对于其发出的编号为 M~n~ 的Prepare请求的响应，它就会发送一个针对[M~n~, V~n~]提案的 Accept 请求给 Acceptor （ V~n~ 为收到的响应中编号最大的提案的值，若响应中不包含提案，它可以是任意值）。</li><li>如果 Acceptor 收到此 Accept 请求，只要该 Acceptor 尚未对编号大于 M~n~ 的Prepare请求做出响应，它就可以通过这个提案。</li></ol></li></ul><h4 id="2-3-9-提案的获取"><a href="#2-3-9-提案的获取" class="headerlink" title="2.3.9 提案的获取"></a>2.3.9 提案的获取</h4><p>Learner 获取提案的几种方案：</p><ol><li>Learner 获取提案的前提是此提案已被半数以上的 Acceptor 批准。因此最简单的做法是一旦 Acceptor 批准了提案，就把其发送给所有的 Learner 。这种做法会让每个 Acceptor 与所有的 Learner 通信，通信次数至少为二者个数的乘积。</li><li>让所有的 Acceptor 对提案的批准情况统一发送给一个<strong>主Learner</strong>，主Learner 被通知一个提案已被选定后会负责通知其他 Learner 。此方案通过多加一个步骤，大大减少了通信次数，但带来了主Learner可能发生故障这个隐患。</li><li>针对方案二，将主Learner扩大为特定的Learner集合，从而提高可靠性。</li></ol><h4 id="2-3-10-通过选取主Proposer保证算法的活性"><a href="#2-3-10-通过选取主Proposer保证算法的活性" class="headerlink" title="2.3.10 通过选取主Proposer保证算法的活性"></a>2.3.10 通过选取主Proposer保证算法的活性</h4><p>Paxos算法可能会出现多个Proposer相互导致对方提案请求被忽略的死循环：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200110.png" alt></p><p>解决方案：选定一个主Proposer，并规定只有主Proposer才能提出议案。</p><p><strong>基于Best Efforts 1PC模式的事务</strong>，参考spring-data-neo4j的实现。鉴于Best Efforts 1PC模式的性能优势，以及相对简单的实现方式，它被大多数的sharding框架和项目采用</p><p><strong>事务补偿（幂等值）</strong></p><p>对于那些对性能要求很高，但对一致性要求并不高的系统，往往并不苛求系统的实时一致性，只要在一个允许的时间周期内达到最终一致性即可，这使得事务补偿机制成为一种可行的方案。事务补偿机制最初被提出是在“长事务”的处理中，但是对于分布式系统确保一致性也有很好的参考意义。笼统地讲，与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查并补救的措施，它只期望在一个容许时间周期内得到最终一致的结果就可以了。事务补偿的实现与系统业务紧密相关，并没有一种标准的处理方式。一些常见的实现方式有：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步，等等。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24036067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24036067</a></p><p>事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</p><p>复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。</p></blockquote><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由。</p><ol><li>利用数据库自增ID和UUID</li></ol><p>优点：最简单。</p><p>缺点：单点风险、单机性能瓶颈。</p><blockquote><p>使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p></blockquote><ol start="2"><li>结合数据库维护一个Sequence表</li></ol><p>此方案的思路也很简单，在数据库中建立一个Sequence表，表的结构类似于：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`SEQUENCE`</span> (  </span><br><span class="line">    <span class="symbol">`table_name`</span> varchar(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="symbol">`nextid`</span> bigint(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`table_name`</span>)  </span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><p>每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应表的nextid,并将nextid的值加1后更新到数据库中以备下次使用。此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。有人提出使用Master-Slave进行主从同步，但这也只能解决单点问题，并不能解决读写比为1:1的访问压力问题。</p><ol start="3"><li>利用数据库集群并设置相应的步长（Flickr方案）</li></ol><p>优点：高可用、ID较简洁。</p><p>缺点：需要单独的数据库集群。</p><ol start="4"><li>Twitter Snowflake</li></ol><p>优点：高性能高可用、易拓展。</p><p>缺点：需要独立的集群以及ZK。</p><blockquote><p><a href="http://blog.sina.com.cn/s/blog_6b7c2e660102vbi2.html" title="Title" target="_blank" rel="noopener">Twitter的分布式自增ID算法Snowflake</a></p><p>在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt;*</span> <span class="number">10</span><span class="bullet">---0000000000</span> <span class="number">0000000000</span> <span class="number">0000000000</span> <span class="number">0000000000</span> <span class="number">0</span> <span class="meta">---</span> <span class="number">00000</span> <span class="bullet">---00000</span> <span class="bullet">---000000000000</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。</p><p>这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。</p></blockquote><ol start="5"><li>一大波GUID、Random算法</li></ol><p>优点：简单。</p><p>缺点：生成ID较长，有重复几率。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24036067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24036067</a> 博主团队采用的策略是：时间戳+用户标识码+随机数</p><p>优点有：</p><ul><li><p>方便、成本低。</p></li><li><p>基本无重复的可能。</p></li><li><p>自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订</p></li><li><p>单号尽可能的短一些，并且评估下来四位已经足够。</p></li><li><p>可排序，因为时间戳在最前面。</p></li></ul><p>当然也有一些缺点，比如长度稍长，性能要比int/bigint的稍差等。</p></blockquote><p><a href="https://www.cnblogs.com/mayundalao/p/11798502.html" target="_blank" rel="noopener">分布式事务的四种解决方案</a></p><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      简单整理了分布式事务相关知识，内容包括：ACID到CAP/BASE，2PC二阶段提交，3PC三阶段提交，Paxos算法等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="transaction" scheme="http://linyishui.top/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://linyishui.top/2021042001.html"/>
    <id>http://linyishui.top/2021042001.html</id>
    <published>2021-04-20T13:26:57.000Z</published>
    <updated>2021-05-13T08:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p>我们先了解一下什么叫幂等？在分布式应用中，幂等是非常重要的，也就是相同条件下对一个业务的操作，不管操作多少次，结果都是一样。</p><p>为什么要有幂等这种场景？因为在大的系统中，都是分布式部署，如：订单业务 和 库存业务有可能都是独立部署的，都是单独的服务。用户下订单，会调用到订单服务和库存服务。</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/ee6b8a81617a444fb8bac512ee7d3ebd?from=pc" alt="海量订单产生的业务高峰期，如何避免消息的重复消费？"></p><p>因为分布式部署，很有可能在调用库存服务时，因为网络等原因，订单服务调用失败，但其实库存服务已经处理完成，只是返回给订单服务处理结果时出现了异常。这个时候一般系统会作补偿方案，也就是订单服务再此放起库存服务的调用,库存减1.</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="built_in">count</span> = <span class="built_in">count</span> <span class="number">-1</span> <span class="keyword">where</span> good_id=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样就出现了问题，其实上一次调用已经减了1，只是订单服务没有收到处理结果。现在又调用一次，又要减1，这样就不符合业务了，多扣了。</p><p>幂等这个概念就是，不管库存服务在相同条件下调用几次，处理结果都一样。这样才能保证补偿方案的可行性。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="乐观锁方案"><a href="#乐观锁方案" class="headerlink" title="乐观锁方案"></a>乐观锁方案</h3><p>借鉴数据库的乐观锁机制，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">count</span> = <span class="keyword">count</span> <span class="number">-1</span> , <span class="keyword">version</span> = <span class="keyword">version</span> + <span class="number">1</span> <span class="keyword">where</span> good_id=<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</p><h3 id="唯一ID-指纹码"><a href="#唯一ID-指纹码" class="headerlink" title="唯一ID + 指纹码"></a>唯一ID + 指纹码</h3><p>原理就是利用数据库主键去重，业务完成后插入主键标识</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> t_check <span class="keyword">where</span> <span class="keyword">ID</span>=唯一<span class="keyword">ID</span> + 指纹码</span><br></pre></td></tr></table></figure><ul><li>唯一ID就是业务表的唯一的主键，如商品ID</li><li>指纹码就是为了区别每次正常操作的码，每次操作时生成指纹码；可以用时间戳+业务编号的方式。</li></ul><p>上面的sql语句：</p><ul><li>返回如果为0 表示没有操作过，那业务操作后就可以insert into t_check(唯一ID+指纹码)</li><li>返回如果大于0 表示操作过，就直接返回</li></ul><p>好处：实现简单</p><p>坏处：高并发下数据库瓶颈</p><p>解决方案：根据ID进行分库分表进行算法路由</p><h3 id="redis原子操作"><a href="#redis原子操作" class="headerlink" title="redis原子操作"></a>redis原子操作</h3><p>利用redis的原子操作，做个操作完成的标记。这个性能就比较好。但会遇到一些问题。</p><p>第一：我们是否需要把业务结果进行数据落库，如果落库，关键解决的问题时数据库和redis操作如何做到原子性？</p><blockquote><p>这个意思就是库存减1了，但redis进行操作完成标记时，失败了怎么办？也就是一定要保证落库和redis 要么一起成功，要么一起失败</p></blockquote><p>第二：如果不进行落库，那么都存储到缓存中，如何设置定时同步策略？</p><blockquote><p>这个意思就是库存减1，不落库，直接先操作redis操作完成标记，然后由另外的同步服务进行库存落库，这个就是增加了系统复杂性，而且同步策略如何设置</p></blockquote><ul><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/zhishixingqiu/%3Fzhihu" target="_blank" rel="noopener">《Java 2019 超神之路》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Dubbo/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Dubbo 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Spring/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Spring 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/MyBatis/good-collection/%3Fzhihu" target="_blank" rel="noopener">《MyBatis 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Spring-MVC/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Spring MVC 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Spring-Boot/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Spring Boot 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Entity/good-collection/%3Fzhihu" target="_blank" rel="noopener">《数据库实体设计合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Interview/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Java 面试题 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Interview/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Java 学习指南 —— 精品合集》</a></li></ul><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      简单整理了分布式锁相关知识，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性</title>
    <link href="http://linyishui.top/2021041901.html"/>
    <id>http://linyishui.top/2021041901.html</id>
    <published>2021-04-19T13:26:49.000Z</published>
    <updated>2021-05-13T08:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h1><h2 id="一-引文"><a href="#一-引文" class="headerlink" title="一. 引文"></a>一. 引文</h2><h3 id="1-1-什么是并发？"><a href="#1-1-什么是并发？" class="headerlink" title="1.1 什么是并发？"></a>1.1 什么是并发？</h3><p>并发：当逻辑控制流（一次程序操作，如读取或更新内存变量的值）在时间上重叠，那它就是并发的。</p><p>一般并发都特指更新操作的并发，即有多个线程同时更新内存中变量的值。</p><h3 id="1-2-数据复制延时问题"><a href="#1-2-数据复制延时问题" class="headerlink" title="1.2 数据复制延时问题"></a>1.2 数据复制延时问题</h3><p>数据复制一般会有延时问题，即无法及时读取到更新后的最新数据。</p><h3 id="1-3-分布式一致性问题"><a href="#1-3-分布式一致性问题" class="headerlink" title="1.3 分布式一致性问题"></a>1.3 分布式一致性问题</h3><p>分布式系统一般采用数据复制都是基于两类需求：</p><ul><li>增加系统的可用性，防止单点故障引起的系统不可用；</li><li>提供系统整体性能，通过负载均衡技术，让分布在不同位置的数据副本都为用户提供服务。</li></ul><p><strong>分布式一致性问题</strong>：在<strong>分布式环境</strong>引入<strong>数据复制机制</strong>后，不同数据节点间可能出现的，并无法依靠应用程序自身解决的<strong>数据不一致情况</strong>。</p><p><strong>数据一致性</strong>：指对一个副本数据进行更新的同时，必须确保能够更新其他的副本。</p><h3 id="1-4-如何解决一致性问题？"><a href="#1-4-如何解决一致性问题？" class="headerlink" title="1.4 如何解决一致性问题？"></a>1.4 如何解决一致性问题？</h3><p>既然是由于延时引起的问题，可以将写入的动作阻塞，直到数据复制完成后，才完成写入动作。</p><p>这样能解决问题，但带来了新的问题：<strong>写入的性能很差</strong>。后续的写请求都要阻塞在前一个请求的写操作上，不适用于有大量写请求的场景。</p><p>所以我们需要在保证数据一致性和不影响系统运行的性能间做一个权衡，从而划分出<strong>一致性级别</strong>：</p><ul><li>强一致性：系统写入什么，读出来就是什么，会对性能有较大影响。</li><li>弱一致性：系统写入成功后不保证可以立刻读到写入的值，只尽可能的保证在某个时间级别（如秒级别）后，数据能达到一致性状态，细分：<ul><li>会话一致性：只保证对于写入的值，在同一个客户端会话中可以读取到一致的值，其他会话不能保证。</li><li>用户一致性：只保证对于写入的值，在同一个用户中可以读取到一致的值，其他用户不能保证。</li></ul></li><li>最终一致性：特殊的弱一致性，非常重要的一种一致性模型。</li></ul><p>接下来引入几种典型的分布式一致性协议，学习它们是如何解决分布式一致性问题。</p><p>## </p><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      简单整理了分布式一致性相关知识，内容包括：引文等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="consistency" scheme="http://linyishui.top/tags/consistency/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（未完成）</title>
    <link href="http://linyishui.top/2021031501.html"/>
    <id>http://linyishui.top/2021031501.html</id>
    <published>2021-03-15T13:57:00.000Z</published>
    <updated>2021-05-13T08:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是动态规划？"><a href="#1-1-什么是动态规划？" class="headerlink" title="1.1 什么是动态规划？"></a>1.1 什么是动态规划？</h3><p><strong>动态规划</strong>（英语：Dynamic Programming，简称DP）是一种<strong>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</strong>。常常适用于<strong>有重叠子问题</strong>和<strong>最优子结构</strong>（Optimal substructure）性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>在20世纪50年代初，由美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：<strong>一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表</strong>。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><h3 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h3><p>在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法 [4] 。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有<a href="https://baike.baidu.com/item/最优值" target="_blank" rel="noopener">最优值</a>的解。动态规划算法与<a href="https://baike.baidu.com/item/分治法" target="_blank" rel="noopener">分治法</a>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从<a href="https://baike.baidu.com/item/这些子" target="_blank" rel="noopener">这些子</a>问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式 [5] 。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>多阶段决策问题</strong></li></ul><p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题 [6] 。</p><p>各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果 [6] 。</p><ul><li><strong>动态规划问题中的术语</strong></li></ul><p><a href="https://baike.baidu.com/item/阶段" target="_blank" rel="noopener">阶段</a>：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的 [6] 。</p><p><a href="https://baike.baidu.com/item/状态" target="_blank" rel="noopener">状态</a>：状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点 [6] 。</p><p><a href="https://baike.baidu.com/item/无后效性" target="_blank" rel="noopener">无后效性</a>：我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性 [6] 。</p><p><a href="https://baike.baidu.com/item/决策" target="_blank" rel="noopener">决策</a>：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称<a href="https://baike.baidu.com/item/决策变量" target="_blank" rel="noopener">决策变量</a>，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史 [6] 。</p><p>决策变量的范围称为允许决策集合 [6] 。</p><p><a href="https://baike.baidu.com/item/策略" target="_blank" rel="noopener">策略</a>：由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合 [6] 。</p><p>允许策略集合中达到最优效果的策略称为最优策略 [6] 。</p><p>给定k阶段状态变量x(k)的值后，如果这一阶段的决策变量一经确定，第k+1阶段的状态变量x(k+1)也就完全确定，即x(k+1)的值随x(k)和第k阶段的决策u(k)的值变化而变化，那么可以把这一关系看成(x(k)，u(k))与x(k+1)确定的对应关系，用x(k+1)=Tk(x(k),u(k))表示。这是从k阶段到k+1阶段的状态转移规律，称为状态转移方程 [6] 。</p><p>最优化原理：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略” [6] 。</p><p>最优性原理实际上是要求问题的最优策略的子策略也是最优 [6] 。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>多阶段决策问题中，各个阶段采取的<a href="https://baike.baidu.com/item/决策" target="_blank" rel="noopener">决策</a>，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法 [7] 。</p><h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性 [8] 。</p><ul><li><strong><a href="https://baike.baidu.com/item/最优化原理" target="_blank" rel="noopener">最优化原理</a>**</strong>（最优子结构性质）**</li></ul><p>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质 [8] 。</p><ul><li><strong><a href="https://baike.baidu.com/item/无后效性" target="_blank" rel="noopener">无后效性</a></strong></li></ul><p>将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性 [8] 。</p><ul><li><strong>子问题的重叠性</strong></li></ul><p>动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间</p><h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><p>动态规划在查找有很多<strong>重叠子问题</strong>的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p><p>动态规划只能应用于有<strong>最优子结构</strong>的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p><p>适用情况：</p><ul><li><p><strong>最优子结构性质</strong>：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p></li><li><p><strong>无后效性</strong>：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p></li><li><strong>子问题重叠性质</strong>：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。</li></ul><h3 id="1-3-动态规划与记忆化搜索"><a href="#1-3-动态规划与记忆化搜索" class="headerlink" title="1.3 动态规划与记忆化搜索"></a>1.3 动态规划与记忆化搜索</h3><p><a href="https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp</a></p><h2 id="二-算法"><a href="#二-算法" class="headerlink" title="二. 算法"></a>二. 算法</h2><h3 id="2-1-DP的两种实现方式"><a href="#2-1-DP的两种实现方式" class="headerlink" title="2.1 DP的两种实现方式"></a>2.1 DP的两种实现方式</h3><ul><li>递归实现</li><li>记忆化搜索</li></ul><h3 id="2-2-DP常用来解决的问题"><a href="#2-2-DP常用来解决的问题" class="headerlink" title="2.2 DP常用来解决的问题"></a>2.2 DP常用来解决的问题</h3><ul><li>切割钢条问题</li><li>Floyd最短路问题</li><li>最大不下降子序列</li><li>矩阵链乘</li><li>凸多边形三角剖分</li><li>0-1背包</li><li>最长公共子序列</li><li>最优二分搜索树</li></ul><h3 id="2-3-使用动态规划的算法"><a href="#2-3-使用动态规划的算法" class="headerlink" title="2.3 使用动态规划的算法"></a>2.3 使用动态规划的算法</h3><ul><li>最长公共子序列</li><li>Floyd-Warshall算法</li><li>Viterbi算法</li><li>求解马可夫决策过程下最佳策略</li></ul><h3 id="2-4-实现原理"><a href="#2-4-实现原理" class="headerlink" title="2.4 实现原理"></a>2.4 实现原理</h3><ul><li><strong>基本思想：</strong>问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题<strong>有较多的重复出现</strong>，则可以<strong>自底向上</strong>从最终子问题向原问题逐步求解。</li><li>使用条件：<strong>可分为多个相关子问题，子问题的解被重复使用</strong><ul><li>Optimal substructure（优化子结构）：<ul><li>一个问题的优化解包含了子问题的优化解</li><li>缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性</li><li>我们可以自下而上的</li></ul></li><li>Subteties（重叠子问题）：在问题的求解过程中，很多子问题的解将被多次使用。</li></ul></li><li>动态规划算法的设计步骤：<ul><li>分析优化解的结构</li><li>递归地定义最优解的代价</li><li>自底向上地计算优化解的代价保存之，并获取构造最优解的信息</li><li>根据构造最优解的信息构造优化解</li></ul></li><li>动态规划特点：<ul><li>把原始问题划分成一系列子问题；</li><li>求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间</li><li>自底向上地计算。</li><li>整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解）</li></ul></li></ul><h2 id="三-算法题"><a href="#三-算法题" class="headerlink" title="三. 算法题"></a>三. 算法题</h2><p>动态规划等价于记忆化搜索，学习深度优先搜索和记忆化搜索，方便快速理解动态规划</p><p>解决DP算法问题，写出记忆化搜索的递归函数，列出方程后，可以用数学方法，魔改优化。</p><h3 id="3-1-背包问题"><a href="#3-1-背包问题" class="headerlink" title="3.1 背包问题"></a>3.1 背包问题</h3><p>背包问题作为NP完全问题，暂时不存在多项式时间算法。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有贪心法等，分数背包问题有最优贪心解等。 背包问题具有最优子结构和重叠子问题。动态规划一般用于求解背包问题中的整数背包问题（即每种物品所选的个数必须是整数）。 </p><p>解整数背包问题： 设有n件物品，每件价值记为 P~i~ ，每件体积记为 V~i~ ，用一个最大容积为 V~max~ 的背包，求装入物品的最大价值。 用一个数组 f[i,v] 表示取i件商品填充一个容积为v的背包的最大价值，显然问题的解就是 f[n,V~max~] 。</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81" alt="{\displaystyle f[i,v]={\begin{cases}f[i-1,v],v&lt;V_{i}\\\max\{f[i-1,v],f[i-1,v-V_{i}]+P_{i}\},v\geq V_{i}\\0,iv=0\\\end{cases}}}"></p><p>对于特例0-1背包问题（即每件物品最多放1件，否则不放入）的问题，状态转移方程：</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81" alt="{\displaystyle f[i,v]={\begin{cases}f[i-1,v],v&lt;V_{i}\\\max\{f[i-1,v],f[i-1,v-V_{i}]+P_{i}\},v\geq V_{i}\\0,iv=0\\\end{cases}}}"></p><h3 id="3-2-切割钢条问题"><a href="#3-2-切割钢条问题" class="headerlink" title="3.2 切割钢条问题"></a>3.2 切割钢条问题</h3><p>（1）剑指14-剪绳子1</p><p>此案例中动态规划效率要低于贪心解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剪绳子1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），</span></span><br><span class="line"><span class="comment"> * 每段绳子的长度记为 k[0],k[1]...k[m-1] 。</span></span><br><span class="line"><span class="comment"> * 请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？</span></span><br><span class="line"><span class="comment"> * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 2</span></span><br><span class="line"><span class="comment"> * 输出: 1</span></span><br><span class="line"><span class="comment"> * 解释: 2 = 1 + 1, 1 × 1 = 1</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 10</span></span><br><span class="line"><span class="comment"> * 输出: 36</span></span><br><span class="line"><span class="comment"> * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2 &lt;= n &lt;= 58</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 数学</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz14CuttingRope1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">2</span>));</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 剪了第一段后，剩下(i - j)长度可以剪也可以不剪。</span></span><br><span class="line"><span class="comment">     * 如果不剪的话长度乘积即为j * (i - j)；</span></span><br><span class="line"><span class="comment">     * 如果剪的话长度乘积即为j * dp[i - j]。</span></span><br><span class="line"><span class="comment">     * 取两者最大值max(j * (i - j), j * dp[i - j])</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 最后返回dp[n]即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(n ^ 2)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 核心思路是：尽可能把绳子分成长度为3的小段，这样乘积最大</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 步骤如下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1</span></span><br><span class="line"><span class="comment">     * 如果 n == 4，返回4</span></span><br><span class="line"><span class="comment">     * 如果 n &gt; 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段</span></span><br><span class="line"><span class="comment">     * 以上2和3可以合并</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）剑指14-剪绳子2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剪绳子2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），</span></span><br><span class="line"><span class="comment"> * 每段绳子的长度记为 k[0],k[1]...k[m - 1] 。</span></span><br><span class="line"><span class="comment"> * 请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？</span></span><br><span class="line"><span class="comment"> * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 2</span></span><br><span class="line"><span class="comment"> * 输出: 1</span></span><br><span class="line"><span class="comment"> * 解释: 2 = 1 + 1, 1 × 1 = 1</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 10</span></span><br><span class="line"><span class="comment"> * 输出: 36</span></span><br><span class="line"><span class="comment"> * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2 &lt;= n &lt;= 1000</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 数学</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与剪绳子1唯一不同在于本题目涉及 “大数越界情况下的求余问题”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz14CuttingRope2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">2</span>));</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res  = res * <span class="number">3</span> % <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-正则表达式匹配"><a href="#3-3-正则表达式匹配" class="headerlink" title="3.3 正则表达式匹配"></a>3.3 正则表达式匹配</h3><p>剑指19-正则表达式匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式匹配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请实现一个函数用来匹配包含'. '和'*'的正则表达式。</span></span><br><span class="line"><span class="comment"> * 模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。</span></span><br><span class="line"><span class="comment"> * 在本题中，匹配是指字符串的所有字符匹配整个模式。</span></span><br><span class="line"><span class="comment"> * 例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aa"</span></span><br><span class="line"><span class="comment"> * p = "a"</span></span><br><span class="line"><span class="comment"> * 输出: false</span></span><br><span class="line"><span class="comment"> * 解释: "a" 无法匹配 "aa" 整个字符串。</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aa"</span></span><br><span class="line"><span class="comment"> * p = "a*"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。</span></span><br><span class="line"><span class="comment"> * 示例 3:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "ab"</span></span><br><span class="line"><span class="comment"> * p = ".*"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span></span><br><span class="line"><span class="comment"> * 示例 4:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aab"</span></span><br><span class="line"><span class="comment"> * p = "c*a*b"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。</span></span><br><span class="line"><span class="comment"> * 示例 5:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "mississippi"</span></span><br><span class="line"><span class="comment"> * p = "mis*is*p*."</span></span><br><span class="line"><span class="comment"> * 输出: false</span></span><br><span class="line"><span class="comment"> * s 可能为空，且只包含从 a-z 的小写字母。</span></span><br><span class="line"><span class="comment"> * p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。</span></span><br><span class="line"><span class="comment"> * 注意：本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz19IsMatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"aa"</span>;</span><br><span class="line">        String p = <span class="string">"a"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"aa"</span>;</span><br><span class="line">        p = <span class="string">"a*"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"ab"</span>;</span><br><span class="line">        p = <span class="string">".*"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"aab"</span>;</span><br><span class="line">        p = <span class="string">"c*a*b"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"mississippi"</span>;</span><br><span class="line">        p = <span class="string">"mis*is*p*."</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符非.或*，则直接比较。</span></span><br><span class="line"><span class="comment">     * 字符为.，则直接匹配，跳到下一个字符。</span></span><br><span class="line"><span class="comment">     * 字符为*，则找到下一个与其匹配的字符。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = p.length();</span><br><span class="line">        <span class="comment">// 存放已处理结果</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">2</span>) || p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题思路：</p><p>假设主串为 A，模式串为 B 从最后一步出发，需要关注最后进来的字符。假设 A 的长度为 n ，B 的长度为 m ，关注正则表达式 B 的最后一个字符是谁，它有三种可能，正常字符、<code>*</code> 和 <code>.</code>（点），那针对这三种情况讨论即可，如下：</p><ol><li>如果 B 的最后一个字符是正常字符，那就是看 <code>A[n-1]</code> 是否等于 <code>B[m-1]</code> ，相等则看 A~0..n-2~ 与 B~0..m−2~ ，不等则是不能匹配，这就是子问题。</li><li>如果 B 的最后一个字符是 <code>.</code> ，它能匹配任意字符，直接看 A~0..n-2~ 与 B~0..m−2~ </li><li>如果 BB 的最后一个字符是 <code>*</code> 它代表 <code>B[m-2]=c</code> 可以重复0次或多次，它们是一个整体 c*<ul><li>情况一：<code>A[n-1]</code> 是 0 个 c，B 最后两个字符废了，能否匹配取决于  A~0..n-1~ 与 B~0..m−3~ 是否匹配</li><li>情况二：<code>A[n-1]</code> 是多个 c 中的最后一个（这种情况必须 A[n-1]=c 或者 c=’.’），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A~0..n-2~ 与 B~0..m−1~ 是否匹配。</li></ul></li></ol><p>转移方程:</p><p><code>f[i][j]</code> 代表 A 的前 i 个和 B 的前 j 个能否匹配:</p><ul><li>对于前面两个情况，可以合并成一种情况 <code>f[i][j]</code> = <code>f[i-1][j-1]</code> </li><li>对于第三种情况，对于 c* 分为看和不看两种情况<ul><li>不看：直接砍掉正则串的后面两个， <code>f[i][j]</code> = <code>f[i][j-2]</code></li><li>看：正则串不动，主串前移一个，<code>f[i][j]</code> = <code>f[i-1][j]</code></li></ul></li></ul><p>初始条件</p><p>特判：需要考虑空串空正则</p><ul><li>空串和空正则是匹配的，<code>f[0][0]</code> = true</li><li>空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如A=’’ ,B=a∗b∗c∗）</li><li>非空串和空正则必不匹配，<code>f[1][0]</code> =…= <code>f[n][0]</code> =false</li><li>非空串和非空正则，那肯定是需要计算的了。</li></ul><p>大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 <em> 和不是 </em> 两种情况了。</p><p>复杂度分析</p><p>时间复杂度：O(mn)，其中 m 和 n 分别是字符串 s 和 p 的长度。我们需要计算出所有的状态，并且每个状态在进行转移时的时间复杂度为 O(1)。</p><p>空间复杂度：O(mn)，即为存储所有状态使用的空间。</p><h3 id="3-4-编号动态规划：最大不下降子序列"><a href="#3-4-编号动态规划：最大不下降子序列" class="headerlink" title="3.4 编号动态规划：最大不下降子序列"></a>3.4 编号动态规划：最大不下降子序列</h3><p>　　本类的状态是基础的基础，大部分的动态规划都要用到它，成为一个维。</p><ul><li><strong>最长不下降子序列定义：</strong>从序列中选出若干个数组成一个新的序列，不改变他们的队伍的顺序，要求新的序列里xi≤xi+1≤xi+1…..举个例子{4,6,5,7,3}，最长不下降子序列就是{4,6,7}。</li><li><strong>子问题的表示：</strong>令dp[i]表示以第i个元素结尾的前i个元素构成的最长不下降子序列的长度</li><li><strong>优化子结构</strong>：若最长不下降子序列包括ak，则必有一个解包含a1,a2…ak-1的最长不下降子序列，dp[i]表示为前i个元素的序列的最长不下降子序列</li><li><strong>方程</strong>： <em>dp[i] = max{dp[j] | 0&lt;j&lt;i , aj≥ai} + 1</em></li><li><strong>伪代码</strong>：</li></ul><p>　　　　输入a[1,…,n]　　输出：最长子序列</p><p> 　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626142332007-952080845.png" alt="img"></p><p><strong>时间复杂度：O(n^2)</strong></p><h3 id="3-5-划分动态规划：矩阵链乘、凸多边形三角剖分"><a href="#3-5-划分动态规划：矩阵链乘、凸多边形三角剖分" class="headerlink" title="3.5 划分动态规划：矩阵链乘、凸多边形三角剖分"></a>3.5 划分动态规划：矩阵链乘、凸多边形三角剖分</h3><p><strong>【矩阵链乘】</strong></p><ul><li><strong>优化子结构</strong>：若计算A1~n的优化顺序在k处断开矩阵链, 即A1~n=A1~k × Ak+1~n，则在A1~n的优化顺序中，对应于子问题A1~k的解必须是A1-k的优化解，对应于子问题Ak+1~n的解必须是Ak+1~n的优化解</li><li><strong>子问题重叠性：</strong></li></ul><p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626144646962-1290294296.png" alt="img"></p><ul><li><strong>方程：</strong></li></ul><p>假设：m[i, j] = 计算Ai~j的最小乘法数；  A1 … AkAk+1 …. An 是优化解(k实际上是不可预知)</p><p> 　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626143827583-1699093130.png" alt="img"></p><p>　  <img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626144206832-946860971.png" alt="img"></p><ul><li><strong>伪代码：</strong></li></ul><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：&lt;A1, A2, ..., An&gt;, Ai是矩阵</span><br><span class="line">输出：计算A1 x A2 x ... x An的最小代价方法</span><br><span class="line"></span><br><span class="line">Matrix-Chain-Order(p)</span><br><span class="line">n=length(p)-<span class="number">1</span>；</span><br><span class="line"><span class="keyword">FOR</span> i=<span class="number">1</span> <span class="keyword">TO</span> n <span class="keyword">DO</span></span><br><span class="line">    m[i, i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">FOR</span> l=<span class="number">2</span> <span class="keyword">TO</span> n <span class="keyword">DO</span> <span class="comment">/* 计算地l对角线*/</span></span><br><span class="line">    <span class="keyword">FOR</span> i=<span class="number">1</span> <span class="keyword">TO</span> n-l+<span class="number">1</span> <span class="keyword">DO</span></span><br><span class="line">        j=i+l-<span class="number">1</span>;</span><br><span class="line">        m[i, j]= ∞;</span><br><span class="line">        <span class="keyword">FOR</span> k←i <span class="keyword">To</span> j←<span class="number">1</span> <span class="keyword">DO</span> <span class="comment">/* 计算m[i,j] */</span></span><br><span class="line">             q=m[i, k]+m[k+<span class="number">1</span>, j]+ <span class="built_in">pi</span>-<span class="number">1</span>pkpj</span><br><span class="line">             <span class="keyword">IF</span> q&lt;m[i, j] <span class="keyword">THEN</span>                  m[i,j]=q; s[i,j]=k;</span><br><span class="line">Return m <span class="built_in">and</span> s.</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Print</span>-Optimal-Parens(s, i, j) <span class="comment">//构建最优解，输出A1-n的优化计算顺序</span></span><br><span class="line"> <span class="keyword">IF</span> j=<span class="built_in">i</span></span><br><span class="line"> THEN <span class="keyword">Print</span> “A”i;</span><br><span class="line"> <span class="keyword">ELSE</span> <span class="keyword">Print</span> “(”</span><br><span class="line">     <span class="keyword">Print</span>-Optimal-Parens(s, i, s[i, j])</span><br><span class="line">     <span class="keyword">Print</span>-Optimal-Parens(s, s[i, j]+1, j)</span><br><span class="line">     <span class="keyword">Print</span> “)”</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><ul><li>算法复杂度<ul><li>计算代价的时间：三层循环 O(n3)</li><li>构建最优解的时间： O(n)</li><li><strong>总时间复杂度：O(n3)</strong></li></ul></li><li><p>空间复杂度</p><ul><li>使用数组m和s</li><li>需要<strong>空间O(n3)</strong></li></ul><p><strong>【三角剖分】</strong></p></li><li><p><strong>优化子结构</strong>：将多边形P划分为不相交三角形的弦的集合</p></li><li><strong>优化问题</strong>:</li></ul><p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626150321546-748343160.png" alt="img"></p><ul><li><p><strong>方程</strong>：设t[i,j] = &lt;vi-1,vi,…..,vj&gt;的优化三角剖分代价</p><p>　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626150546681-278989483.png" alt="img"></p></li></ul><h3 id="3-6-数轴动态规划：0-1背包"><a href="#3-6-数轴动态规划：0-1背包" class="headerlink" title="3.6 数轴动态规划：0-1背包"></a>3.6 数轴动态规划：0-1背包</h3><p>### </p><ul><li><strong>问题描述</strong>：给定n种物品和一个背包，物品i的重量是wi，价值vi，背包容量为C，问如何选择装入背包的物品，使装入背包中的物品的总价值最大？对于每种物品总能选择完全装入或不装入，一个物品最多装入一次。</li><li><strong>等价整数规划问题：</strong></li></ul><p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626151529727-1771169615.png" alt="img"></p><ul><li><strong>Naive的方法</strong>：每个物品只有两种选择：不装或装，n个物品共2n个装取方案，每个装取方案的计算代价为n，总计算代价为O(n2n)</li><li><p><strong>问题的划分：</strong></p><p>　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626151725491-1249436922.png" alt="img"></p></li><li><p><strong>定义代价矩阵m与方程</strong>：  </p></li><li><ul><li><strong><em>定义m(i, j)\</em> :</strong>背包容量为j，可选物品为xi,xi+1…xn时，问题的最优解代价时m[i,j]</li><li><em>m(n, j) = 0,  0</em> ≤ <em>j &lt;wn</em></li><li><em>m(n, j) = vn,  j ≥**wn</em></li><li><em>m(i, j) = m(i+1, j), 　　   0≤</em> <em>j&lt; wi</em></li><li><em>m(i, j) = max{m(i+1, j), m(i+1, j-wi)+vi},   j ≥</em> <em>wi</em></li></ul></li><li><p><strong>优化子结构和自底向上的代价</strong></p></li></ul><p>　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626154205161-1543350290.png" alt="img"><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626154222124-1568769512.png" alt="img"></p><ul><li><strong>伪代码</strong></li></ul><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>输入：C&gt;0, wi&gt;0, vi&gt;0, 1≤ i≤n<br>输出：(x1, x2, …, xn), xi∈{0, 1}, 满足 ∑1≤i≤nwi xi ≤C, ∑1≤i≤nvi xi 最大</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> <span class="attribute">j</span>=0 <span class="keyword">To</span> min(wn-1, C) <span class="keyword">Do</span></span><br><span class="line">      m[n, j] = 0;</span><br><span class="line"><span class="keyword">For</span> <span class="attribute">j</span>=wn <span class="keyword">To</span> C <span class="keyword">Do</span></span><br><span class="line">      m[n, j] = vn;</span><br><span class="line"><span class="keyword">For</span> <span class="attribute">i</span>=n-1 <span class="keyword">To</span> 2 <span class="keyword">Do</span></span><br><span class="line">    <span class="keyword">For</span> <span class="attribute">j</span>=0 <span class="keyword">To</span> min(wi -1, C)  <span class="keyword">Do</span></span><br><span class="line">      m[i, j] = m[i+1, j];</span><br><span class="line">    <span class="keyword">For</span> <span class="attribute">j</span>=wi  <span class="keyword">To</span> C   <span class="keyword">Do</span></span><br><span class="line">      m[i, j]=max&#123;m[i+1, j], m[i+1, j-wi]+vi&#125;;</span><br><span class="line"><span class="keyword">If</span>  C&lt;w1  Then  m[1, C]=m[2, C];</span><br><span class="line">      <span class="keyword">Else</span>  m[1, C]=max&#123;m[2, C], m[2, C-w1]+v1&#125;;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">m</span>(1, C)是最优解代价值，相应解计算如下: <span class="comment">//构造优化解</span></span><br><span class="line">    <span class="keyword">If</span> <span class="built_in">m</span>(1, C) = <span class="built_in">m</span>(2, C)</span><br><span class="line">    Then x1 = 0;</span><br><span class="line">    <span class="keyword">Else</span> x1 = 1;</span><br><span class="line">如果x1=0, 由<span class="built_in">m</span>(2, C)继续构造最优解;</span><br><span class="line">如果x1=1, 由<span class="built_in">m</span>(2, C-w1)继续构造最优解.</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><ul><li>时间复杂度：<ul><li>计算代价的时间为O(Cn)</li><li>构造最优解的时间:O(Cn)</li><li><strong>总时间复杂度为:O(Cn)</strong></li></ul></li><li>空间复杂度：<ul><li><strong>使用数组m，需要空间O(Cn)</strong></li></ul></li></ul><h3 id="3-7-前缀动态规划：最长公共子序列（LCS）"><a href="#3-7-前缀动态规划：最长公共子序列（LCS）" class="headerlink" title="3.7 前缀动态规划：最长公共子序列（LCS）"></a>3.7 前缀动态规划：最长公共子序列（LCS）</h3><p>### </p><ul><li><strong>问题描述</strong>：Z是序列X与Y的公共子序列如果Z是X的子序列也是Y的子序列。</li><li><p><strong>Naive方法：</strong></p><ul><li>枚举X的每个子序列Z</li><li>检查Z是否为Y的子序列</li><li><strong>T(n)=O(n2m)</strong></li></ul></li><li><p><strong>优化子结构：</strong></p></li><li><ul><li><em>设X=(x1, …, xm)、Y=(y1, …, yn)是两个序列， LCSXY=(z1, …, zk)是X与Y的LCS，我们有：</em></li><li><em>如果xm=yn, 则zk=xm=yn, LCSXY = LCSXm-1Yn-1 + &lt;xm=yn&gt;,  LCSXm-1Yn-1是Xm-1和Yn-1的LCS.</em></li><li><em>如果xm<strong>≠yn，且zk≠</strong>xm，则LCSXY是Xm-1和Y的LCS，即 LCSXY = LCSXm-1Y</em></li><li><em>如果xm≠<strong>yn,且zk≠</strong>yn,则LCSXY是X与Yn-1的LCS，即 LCSXY = LCSXYn-1</em></li></ul></li></ul><p>　　　　<em><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161250797-846687005.png" alt="img"></em></p><ul><li><strong>子问题重叠性</strong></li></ul><p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161407046-1649798663.png" alt="img"></p><ul><li><strong>方程：</strong></li></ul><p>　　　　<strong><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161153121-2116602929.png" alt="img"></strong></p><ul><li><strong>自底向上计算：</strong></li></ul><p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161510812-1390787212.png" alt="img"></p><ul><li><strong>伪代码</strong></li></ul><p><strong><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626164412918-1817122808.png" alt="img"></strong></p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入：X = (x1,x2,...,xm)，Y = (y1,y2,...yn)</span><br><span class="line">输出：Z = X与Y的最长公共子序列</span><br><span class="line"></span><br><span class="line"><span class="keyword">C</span>[<span class="number">0</span>:m,<span class="number">0</span>:n]: <span class="keyword">C</span>[i,j]是Xi与Yj的LCS的长度   B[<span class="number">1</span>:m,<span class="number">1</span>:n]:</span><br><span class="line">B[i,j]是指针，指向计算<span class="keyword">C</span>[i,j]时所选择的子问题的优化解所对应的<span class="keyword">C</span>表的表项</span><br><span class="line"></span><br><span class="line">LCS-length(X, Y)</span><br><span class="line">m←length(X)；n←length(Y)；</span><br><span class="line"><span class="keyword">For</span> i←<span class="number">0</span> To m <span class="keyword">Do</span> <span class="keyword">C</span>[i,<span class="number">0</span>]←<span class="number">0</span>;</span><br><span class="line"><span class="keyword">For</span> j←<span class="number">0</span> To n <span class="keyword">Do</span> <span class="keyword">C</span>[<span class="number">0</span>,j]←<span class="number">0</span>;</span><br><span class="line"><span class="keyword">For</span> i←<span class="number">1</span> To m <span class="keyword">Do</span></span><br><span class="line">  <span class="keyword">For</span> j←<span class="number">1</span> To n <span class="keyword">Do</span></span><br><span class="line">    <span class="keyword">If</span> xi = yj</span><br><span class="line">    Then <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i<span class="number">-1</span>,j<span class="number">-1</span>]+<span class="number">1</span>；B[i,j]←“↖”;</span><br><span class="line">      Else <span class="keyword">If</span> <span class="keyword">C</span>[i<span class="number">-1</span>,j]≥<span class="keyword">C</span>[i,j<span class="number">-1</span>] Then</span><br><span class="line">              <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i<span class="number">-1</span>,j]; B[i,j]←“↑”;</span><br><span class="line">           Else <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i,j<span class="number">-1</span>]; B[i,j]←“←”;</span><br><span class="line"><span class="keyword">Return</span> <span class="keyword">C</span> and B.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Print</span>-LCS(B, X, i, j)</span><br><span class="line">IF i=<span class="number">0</span> or j=<span class="number">0</span> THEN <span class="keyword">Return</span>;</span><br><span class="line">IF B[i, j]=“↖”</span><br><span class="line">THEN <span class="keyword">Print</span>-LCS(B, X, i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">Print</span> xi;</span><br><span class="line">ELSE <span class="keyword">If</span> B[i, j]=“↑”</span><br><span class="line">    THEN <span class="keyword">Print</span>-LCS(B, X, i<span class="number">-1</span>, j);</span><br><span class="line">    ELSE <span class="keyword">Print</span>-LCS(B, X, i, j<span class="number">-1</span>).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Print</span>-LCS(B, X, length(X), length(Y))</span><br><span class="line">      可打印出X与Y的LCS。</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><ul><li><p>时间复杂度</p><p>：</p><ul><li>计算代价的时间：O(mn)</li><li>构造最优解的时间：O(m+n)</li><li><strong>总时间复杂度为： O(mn)</strong></li></ul></li><li><p>空间复杂度</p><p>：</p><ul><li>使用数组C和B，需要<strong>空间O(mn)</strong></li></ul></li></ul><h3 id="3-8-树形动态规划：最优二分搜索树"><a href="#3-8-树形动态规划：最优二分搜索树" class="headerlink" title="3.8 树形动态规划：最优二分搜索树"></a>3.8 树形动态规划：最优二分搜索树</h3><hr><p>参考：</p><p>🔗 《<a href="https://zh.wikipedia.org/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">维基百科-动态规划</a>》</p><p>🔗 《<a href="https://www.cnblogs.com/hithongming/p/9229871.html" target="_blank" rel="noopener">【算法复习】动态规划</a>》</p><p>🔗 《<a href="https://www.cnblogs.com/hithongming/p/9229871.html" target="_blank" rel="noopener">如何理解动态规划？</a>》</p>]]></content>
    
    <summary type="html">
    
      内容包括：概述，实现，算法题等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>算法复习 (三) 图-无向图（未完成）</title>
    <link href="http://linyishui.top/2021030401.html"/>
    <id>http://linyishui.top/2021030401.html</id>
    <published>2021-03-04T13:36:06.000Z</published>
    <updated>2021-04-20T05:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法复习-三-图-无向图"><a href="#算法复习-三-图-无向图" class="headerlink" title="算法复习 (三) 图-无向图"></a>算法复习 (三) 图-无向图</h1><h2 id="一-图"><a href="#一-图" class="headerlink" title="一. 图"></a>一. 图</h2><h3 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1 应用场景"></a>1.1 应用场景</h3><ul><li>地图。正在计划旅行的人也许想知道“从普罗维登斯到普林斯顿的最短路线”。对最短路径上经历过交通堵塞的旅行者可能会问：“从普罗维登斯到普林斯顿的哪条路线最快？”要回答这些问题，我们都要处理有关结点（十字路口）之间多条连接（公路）的信息。</li><li>网页信息。当我们在浏览网页时，页面上都会包含其他网页的引用（链接）。通过单击链接，我们可以从一个页面跳到另一个页面。整个互联网就是一张图，结点是网页，连接就是超链接。图算法是帮助我们在网络上定位信息的搜索引擎的关键组件。</li><li>电路。在一块电路板上，晶体管、电阻、电容等各种元件是精密连接在一起的。我们使用计算机来控制制造电路板的机器并检查电路板的功能是否正常。我们既要检查短路这类简单问题，也要检查这幅电路图中的导线在蚀刻到芯片上时是否会出现交叉等复杂问题。第一类问题的答案仅取决于连接（导线）的属性，而第二个问题则会涉及导线、各种元件<br>以及芯片的物理特性等详细信息。</li><li>任务调度。商品的生产过程包含了许多工序以及一些限制条件，这些条件会决定某些任务的先后次序。如何安排才能在满足限制条件的情况下用最少的时间完成这些生产工序呢？<br>商业交易。零售商和金融机构都会跟踪市场中的买卖信息。在这种情形下，一条连接可以表示现金和商品在买方和卖方之间的转移。在此情况下，理解图的连接结构原理可能有助于增强人们对市场的理解。</li><li>配对。学生可以申请加入各种机构，例如社交俱乐部、大学或是医学院等。这里结点就对应学生和机构，而连接则对应递交的申请。我们希望找到申请者与他们感兴趣的空位之间配对的方法。</li><li>计算机网络。计算机网络是由能够发送、转发和接收各种消息的站点互相连接组成的。我们感兴趣的是这种互联结构的性质，因为我们希望网络中的线路和交换设备能够高效率地处理网络流量。</li><li>软件。编译器会使用图来表示大型软件系统中各个模块之间的关系。图中的结点即构成整个系统的各种类和模块，连接则为类的方法之间的可能调用关系（静态分析），或是系统运行时的实际调用关系（动态分析）。我们需要分析这幅图来决定如何以最优的方式为程序分配资源。</li><li>社交网络。当你在使用社交网站时，会和你的朋友之间建立起明确的关系。这里，结点对应人而连接则联系着你和你的朋友或是关注者。分析这些社交网络的性质是当前图算法的一个重要应用。对它感兴趣的不止是社交网络的公司，还包括政治、外交、娱乐、教育、市场等许多其他机构。</li></ul><table><thead><tr><th>应用</th><th>结点</th><th>连接</th></tr></thead><tbody><tr><td>地图</td><td>十字路口</td><td>公路</td></tr><tr><td>网络内容</td><td>网页</td><td>超链接</td></tr><tr><td>电路</td><td>元器件</td><td>导线</td></tr><tr><td>任务调度</td><td>任务</td><td>限制条件</td></tr><tr><td>商业交易</td><td>客户</td><td>交易</td></tr><tr><td>配对</td><td>学生</td><td>申请</td></tr><tr><td>计算机网络</td><td>网站</td><td>物理连接</td></tr><tr><td>软件</td><td>方法</td><td>调用关系</td></tr><tr><td>社交网络</td><td>人</td><td>友谊关系</td></tr></tbody></table><h3 id="1-2-常用术语"><a href="#1-2-常用术语" class="headerlink" title="1.2 常用术语"></a>1.2 常用术语</h3><ul><li>某个顶点的度数即为依附于它的边的总数。</li><li>子图是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。许多计算问题都需要识别各种类型的子图，特别是由能够顺序连接一系列顶点的边所组成的子图。</li><li>路径是由边顺序连接的一系列顶点。</li><li>简单路径是一条没有重复顶点的路径。环是一条至少含有一条边且起点和终点相同的路径。</li><li>简单环是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。</li><li>路径或者环的长度为其中所包含的边数。</li><li>当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另一个顶点是连通的。</li><li>如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是<strong>连通图</strong>。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。</li><li>无环图是一种不包含环的图。</li><li>图的密度是指已经连接的顶点对占所有可能被连接的顶点对的比例。在稀疏图中，被连接的顶点对很少；而在稠密图中，只有少部分顶点对之间没有边连接。</li><li>二分图是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010113.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010116.png" alt></p><h3 id="1-3-图与树的关系"><a href="#1-3-图与树的关系" class="headerlink" title="1.3 图与树的关系"></a>1.3 图与树的关系</h3><p>树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一棵树。图的生成树森林是它的所有连通子图的生成树的集合。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010114.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010115.png" alt></p><p>当且仅当一幅含有V个结点的图满足下列 5 个条件之一时，它就是一棵树：</p><ul><li>G有V-1条边且不含有环；</li><li>G有V-1条边且是连通的；</li><li>G是连通的，但删除任意一条边都会使它不再连通；</li><li>G是无环图，但添加任意一条边都会产生一条环；</li><li>G中的任意一对顶点之间仅存在一条简单路径。</li></ul><h3 id="1-4-四种图模型"><a href="#1-4-四种图模型" class="headerlink" title="1.4 四种图模型"></a>1.4 四种图模型</h3><p>4 种最重要的图模型：</p><ul><li>无向图（简单连接）</li><li>有向图（连接有方向性）</li><li>加权图（连接带有权值）</li><li>加权有向图（连接既有方向性又带有权值）</li></ul><h2 id="二-无向图"><a href="#二-无向图" class="headerlink" title="二. 无向图"></a>二. 无向图</h2><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>定义：图是由一组顶点和一组能够将两个顶点相连的边组成的。</p><p>一般使用 0 至 V-1 来表示一张含有 V 个顶点的图中的各个顶<br>点。用 v-w 的记法来表示连接 v 和 w 的边，w-v 是这条边的另一种表示方法。</p><p>绘制出的图有时会误导我们，因为图的定义和绘出的图像是无关的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010111.png" alt></p><p>特殊的图。我们的定义允许出现两种简单而特殊的情况：</p><ul><li>自环，即一条连接一个顶点和其自身的边；</li><li>连接同一对顶点的两条边称为平行边。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010112.png" alt></p><p>数学家常常将含有平行边的图称为多重图，而将没有平行边或自环的图称为简单图。后续不会出现这种特殊情况，所以用两个顶点就可以指代一条边了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first; <span class="comment">// 链表的首结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123; <span class="comment">// 和Stack 的push() 方法完全相同</span></span><br><span class="line">        Node oldfirst = first;</span><br><span class="line">        first = <span class="keyword">new</span> Node();</span><br><span class="line">        first.item = item;</span><br><span class="line">        first.next = oldfirst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node current = first;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Item item = current.item;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">// 顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E; <span class="comment">// 边的数目</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj; <span class="comment">// 邻接表：数组+链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V]; <span class="comment">// 创建邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) <span class="comment">// 将所有链表初始化为空</span></span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(In in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in.readInt()); <span class="comment">// 读取V并将图初始化</span></span><br><span class="line">        <span class="keyword">int</span> E = in.readInt(); <span class="comment">// 读取E</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123; <span class="comment">// 添加一条边</span></span><br><span class="line">            <span class="keyword">int</span> v = in.readInt(); <span class="comment">// 读取一个顶点</span></span><br><span class="line">            <span class="keyword">int</span> w = in.readInt(); <span class="comment">// 读取另一个顶点</span></span><br><span class="line">            addEdge(v, w); <span class="comment">// 添加一条连接它们的边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        adj[v].add(w); <span class="comment">// 将w添加到v的链表中</span></span><br><span class="line">        adj[w].add(v); <span class="comment">// 将v添加到w的链表中</span></span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-深度优先搜索"><a href="#三-深度优先搜索" class="headerlink" title="三. 深度优先搜索"></a>三. 深度优先搜索</h2><h3 id="3-1-什么是深度优先搜索？"><a href="#3-1-什么是深度优先搜索？" class="headerlink" title="3.1 什么是深度优先搜索？"></a>3.1 什么是深度优先搜索？</h3><p><strong>深度优先搜索算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的递归算法，它会沿着图的边寻找和起点连通的所有顶点。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p><p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的拓扑排序，利用拓扑排序表可以方便的解决很多相关的图论问题，如无权最长路径问题等等。这种算法不会根据图的结构等信息调整执行策略来源请求。</p><h3 id="3-2-迷宫问题和-Tremaux-搜索"><a href="#3-2-迷宫问题和-Tremaux-搜索" class="headerlink" title="3.2 迷宫问题和 Tremaux 搜索"></a>3.2 迷宫问题和 Tremaux 搜索</h3><p>思考图的搜索过程的一种有益的方法是，考虑另一个和它等价的问题：在一个由各种通道和路口组成的迷宫中找到出路。有些迷宫的规则很简单，但大多数迷宫则需要很复杂的策略才行。</p><p>用迷宫代替图、通道代替边、路口代替顶点仅仅只是一些文字游戏，但就目前来说，这么做可以帮助我们直观地认识问题，参见下图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010102.png" alt></p><p>探索迷宫而不迷路的一种古老办法（至少可以追溯到忒修斯和米诺陶的传说）叫做 <strong>Tremaux 搜索</strong>，参见下图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010103.png" alt></p><p>要探索迷宫中的所有通道，我们需要：</p><ul><li>选择一条没有标记过的通道，在你走过的路上铺一条绳子；</li><li>标记所有你第一次路过的路口和通道；</li><li>当来到一个标记过的路口时（用绳子）回退到上个路口；</li><li>当回退到的路口已没有可走的通道时继续回退。</li></ul><p>绳子可以保证你总能找到一条出路，标记则能保证你不会两次经过同一条通道或者同一个路口。要知道是否完全探索了整个迷宫需要的证明更复杂，只有用图搜索才能够更好地处理问题。</p><p>Tremaux 搜索很直接，但它与完全搜索一张图仍然稍有不同，因此我们接下来看看图的搜索方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearch</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v))</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) dfs(G, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-算法描述"><a href="#3-3-算法描述" class="headerlink" title="3.3 算法描述"></a>3.3 算法描述</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010104.png" alt></p><p>搜索连通图的经典递归算法<strong>深度优先搜索</strong>（遍历所有的顶点和边）和 Tremaux 搜索类似。要搜索一幅图，只需用一个递归方法来遍历所有顶点。<strong>深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比</strong>。</p><p>在访问其中一个顶点时：</p><ul><li>将它标记为已访问；</li><li>递归地访问它的所有没有被标记过的邻居顶点。</li></ul><p>它使用一个 boolean 数组来记录和起点连通的所有顶点。递归方法会标记给定的顶点并调用自己来访问该顶点的相邻顶点列表中所有没有被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。</p><p>算法遍历边和访问顶点的顺序与图的表示是有关的，而不只是与图的结构或是算法有关。因为深度优先搜索只会访问和起点连通的顶点，使用下图所示的一幅小型连通图为例，一幅连通的无向图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010105.png" alt></p><ul><li>在示例中，顶点 2 是顶点 0 之后第一个被访问的顶点，因为它正好是 0 的邻接表的第一个元素。</li><li>深度优先搜索中每条边都会被访问两次，且在第二次时总会发现这个顶点已经被标记过。这意味着深度优先搜索的轨迹可能会比你想象的长一倍！示例图仅含有 8 条边，但需要追踪算法在邻接表的 16 个元素上的操作。</li></ul><p>下图显示的是示例中每个顶点被标记后算法使用的数据结构，起点为顶点 0。使用深度优先搜索的轨迹，寻找所有和顶点 0 连通的顶点：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010106.png" alt></p><p>查找开始于构造函数调用递归的 <code>dfs()</code> 来标记和访问顶点0，后续处理如下所述：</p><ul><li>因为顶点 2 是 0 的邻接表的第一个元素且没有被标记过，<code>dfs()</code> 递归调用自己来标记并访问顶点 2（效果是系统会将顶点 0 和 0 的邻接表的当前位置压入栈中）。</li><li>现在，顶点 0 是 2 的邻接表的第一个元素且已经被标记过了，因此 <code>dfs()</code> 跳过了它。接下来，顶点 1 是 2 的邻接表的第二个元素且没有被标记，<code>dfs()</code> 递归调用自己来标记并访问顶点 1。</li><li>对顶点 1 的访问和前面有所不同：因为它的邻接表中的所有顶点（0 和 2）都已经被标记过了，因此不需要再进行递归，方法从 <code>dfs(1)</code> 中返回。下一条被检查的边是 2-3（在 2 的邻接表中顶点 1 之后的顶点是 3），因此 <code>dfs()</code> 递归调用自己来标记并访问顶点3。</li><li>顶点 5 是 3 的邻接表的第一个元素且没有被标记，因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 5。</li><li>顶点 5 的邻接表中的所有顶点（3 和 0）都已经被标记过了，因此不需要再进行递归。</li><li>顶点 4 是 3 的邻接表的下一个元素且没有被标记过，因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 4。这是最后一个需要被标记的顶点。</li><li>在顶点 4 被标记了之后，<code>dfs()</code> 会检查它的邻接表，然后再检查 3 的邻接表，然后是 2 的邻接表，然后是 0 的，最后发现不需要再进行任何递归调用，因为所有的顶点都已经被标记过了。</li></ul><h3 id="3-4-使用场景"><a href="#3-4-使用场景" class="headerlink" title="3.4 使用场景"></a>3.4 使用场景</h3><ul><li><strong>连通性问题</strong> / <strong>路径检测问题</strong> ：比如给定一幅图，回答“两个给定的顶点是否连通？”或者“图中有多少个连通子图？”等类似问题。问题“两个给定的顶点是否连通？”等价于“两个给定的顶点之间是否存在一条路径？”</li><li><strong>单点路径</strong>：给定一幅图和一个起点 s，回答“从 s 到给定目的顶点 v 是否存在一条路径？如果有，找出这条路径。”等类似问题。</li></ul><p>深度优先搜索算法之所以极为简单，是因为它所基于的概念为人所熟知并且非常容易实现。事实上，它是一个既小巧而又强大的算法，研究人员用它解决了无数困难的问题。上述两个问题只是我们将要研究的许多问题的开始。</p><h3 id="3-5-算法题"><a href="#3-5-算法题" class="headerlink" title="3.5 算法题"></a>3.5 算法题</h3><p>剑指第12题-矩阵中的路径：深度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 矩阵中的路径</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</span></span><br><span class="line"><span class="comment"> * 路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。</span></span><br><span class="line"><span class="comment"> * 如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</span></span><br><span class="line"><span class="comment"> * 例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [["a","b","c","e"],</span></span><br><span class="line"><span class="comment"> * ["s","f","c","s"],</span></span><br><span class="line"><span class="comment"> * ["a","d","e","e"]]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入：board = [["a","b"],["c","d"]], word = "abcd"</span></span><br><span class="line"><span class="comment"> * 输出：false</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1 &lt;= board.length &lt;= 200</span></span><br><span class="line"><span class="comment"> * 1 &lt;= board[i].length &lt;= 200</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 深度优先搜索</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz12Exist</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] board = &#123;</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'S'</span>, <span class="string">'F'</span>, <span class="string">'C'</span>, <span class="string">'S'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String word = <span class="string">"ABCCED"</span>;</span><br><span class="line">        System.out.println(exist(board, word));</span><br><span class="line">        <span class="keyword">char</span>[][] board1 = &#123;&#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;, &#123;<span class="string">'c'</span>, <span class="string">'d'</span>&#125;&#125;;</span><br><span class="line">        String word1 = <span class="string">"abcd"</span>;</span><br><span class="line">        System.out.println(exist(board1, word1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间复杂度 O(3^K * M * N) ：</span></span><br><span class="line"><span class="comment">     *      最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K)；</span></span><br><span class="line"><span class="comment">     *      矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。</span></span><br><span class="line"><span class="comment">     *      方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3^K) 。</span></span><br><span class="line"><span class="comment">     * 空间复杂度 O(K) ：</span></span><br><span class="line"><span class="comment">     *      搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K)</span></span><br><span class="line"><span class="comment">     *      （因为函数返回后，系统调用的栈空间会释放）。</span></span><br><span class="line"><span class="comment">     *      最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, words, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board 二维矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 单词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 单词坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否命中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未命中：横纵坐标越界，矩阵对应位置元素不等于单词对应位置元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单词遍历结束，全部命中</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记表示已访问过</span></span><br><span class="line">        board[i][j] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">// 递归访问相邻矩阵元素</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, word, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剑指第13题-机器人的运动范围：深度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。</span></span><br><span class="line"><span class="comment"> * 一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），</span></span><br><span class="line"><span class="comment"> * 也不能进入行坐标和列坐标的数位之和大于k的格子。</span></span><br><span class="line"><span class="comment"> * 例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。</span></span><br><span class="line"><span class="comment"> * 但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：m = 2, n = 3, k = 1</span></span><br><span class="line"><span class="comment"> * 输出：3</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：m = 3, n = 1, k = 0</span></span><br><span class="line"><span class="comment"> * 输出：1</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1 &lt;= n,m &lt;= 100</span></span><br><span class="line"><span class="comment"> * 0 &lt;= k &lt;= 20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz13MovingCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">        m = <span class="number">3</span>;</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">        m = <span class="number">16</span>;</span><br><span class="line">        n = <span class="number">8</span>;</span><br><span class="line">        k = <span class="number">4</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(mn)，其中 m 为方格的行数， n 为方格的列数。</span></span><br><span class="line"><span class="comment">     * 一共有 O(mn) 个状态需要计算，每个状态递推计算的时间复杂度为 O(1)，所以总时间复杂度为 O(mn)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(mn)，其中 m 为方格的行数，n 为方格的列数。我们需要 O(mn) 大小的结构来记录每个位置是否可达。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; getSum(i) + getSum(j) || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, m, n, k, visited) + dfs(i, j + <span class="number">1</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = a / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tmp % <span class="number">10</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-寻找路径"><a href="#四-寻找路径" class="headerlink" title="四. 寻找路径"></a>四. 寻找路径</h2><h3 id="4-1-路径API"><a href="#4-1-路径API" class="headerlink" title="4.1 路径API"></a>4.1 路径API</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010107.png" alt></p><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Graph G = <span class="keyword">new</span> Graph(<span class="keyword">new</span> In(args[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">int</span> s = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">    Paths search = <span class="keyword">new</span> Paths(G, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">        StdOut.print(s + <span class="string">" to "</span> + v + <span class="string">": "</span>);</span><br><span class="line">        <span class="keyword">if</span> (search.hasPathTo(v))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : search.pathTo(v))</span><br><span class="line">                <span class="keyword">if</span> (x == s) StdOut.print(x);</span><br><span class="line">                <span class="keyword">else</span> StdOut.print(<span class="string">"-"</span> + x);</span><br><span class="line">        StdOut.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h3><p>DepthFirstPaths使用深度优先搜索查找图中的路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用深度优先搜索查找图中的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此顶点上是否调用过 dfs()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从起点到一个顶点的已知路径上的最后一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 G 中找出所有起点为 s 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在从 s 到 v 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s 到 v 的路径，如果不存在则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x]) &#123;</span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算轨迹如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010109.png" alt></p><p>为了保存到达每个顶点的已知路径，这段代码使用了一个以顶点编号为索引的数组 edgeTo[]，edgeTo[w]=v 表示 v-w 是第一次访问 w 时经过的边。edgeTo[] 数组是一棵用父链接表示的以 s 为根且含有所有与 s 连通的顶点的树。</p><p>下图显示的是示例中每个顶点被标记后 edgeTo[] 的内容，起点为顶点 0。marked[] 和 adj[] 的内容与  DepthFirstSearch 的轨迹相同，递归调用和边检查的详细描述也完全一样，这里不再赘述。深度优先搜索向 edgeTo[] 数组中顺序添加了 0-2、2-1、2-3、3-5 和 3-4。这些边构成了一棵以起点为根结点的树并提供了 pathTo() 方法所需的信息，使得调用者可以按照前文所述的方法找到从 0 到顶点 1、2、3、4、5 的路径。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010110.png" alt></p><h2 id="五-广度优先搜索"><a href="#五-广度优先搜索" class="headerlink" title="五. 广度优先搜索"></a>五. 广度优先搜索</h2><h3 id="5-1-什么是广度优先搜索？"><a href="#5-1-什么是广度优先搜索？" class="headerlink" title="5.1 什么是广度优先搜索？"></a>5.1 什么是广度优先搜索？</h3><p>广度优先搜索算法（Breadth-First Search，BFS）</p><p>单点最短路径。给定一幅图和一个起点 s，回答“从 s 到给定目的顶点 v 是否存在一条路径？如果有，找出其中最短的那条（所含边数最少）。”等类似问题。</p><p>解决这个问题的经典方法叫做广度优先搜索（BFS)。深度优先搜索在这个问题上没有什么作为，因为它遍历整个图的顺序和找出最短路径的目标没有任何关系。相比之下，广度优先搜索正是为了这个目标才出现的。</p><p>要找到从 s 到 v 的最短路径，从 s 开始，在所有由一条边就可以到达的顶点中寻找 v，如果找不到我们就继续在与 s 距离两条边的所有顶点中查找v，如此一直进行。深度优先搜索就好像是一个人在走迷宫，广度优先搜索则好像是一组人在一起朝各个方向走这座迷宫，每个人都有自己的绳子。当出现新的叉路时，可以假设一个探索者可以分裂为更多的人来搜索它们，当两个探索者相遇时，会合二为一（并继续使用先到达者的绳子），参见下图-广度优先的迷宫搜索。</p><p><img src="C:\Users\hspcadmin\Desktop\文档\202104120101.png" alt></p><h3 id="5-2-算法描述"><a href="#5-2-算法描述" class="headerlink" title="5.2 算法描述"></a>5.2 算法描述</h3><p>在深度优先搜索中，我们用了一个可以下压的栈（这是由系统管理的，以支持递归搜索方法）。使用 LIFO（后进先出）的规则来描述压栈和走迷宫时先探索相邻的通道类似。从有待搜索的通道中选择最晚遇到过的那条。在广度优先搜索中，我们希望按照与起点的距离的顺序来遍历所有顶点，看起来这种顺序很容易实现：使用（FIFO，先进先出）队列来代替栈（LIFO，后进先出）即可。我们将从有待搜索的通道中选择最早遇到的那条。</p><p>算法 4.2 实现了广度优先搜索算法。它使用了一个队列来保存所有已经被标记过但其邻接表还未被检查过的顶点。先将起点加入队列，然后重复以下步骤直到队列为空：</p><ul><li>取队列中的下一个顶点 v 并标记它；</li><li>将与 v 相邻的所有未被标记过的顶点加入队列。</li></ul><p><img src="C:\Users\hspcadmin\Desktop\文档\202104120102.png" alt></p><p>步骤：</p><p><img src="C:\Users\hspcadmin\Desktop\文档\202104120103.png" alt></p><ul><li>从队列中删去顶点 0 并将它的相邻顶点 2、1 和 5 加入队列中，标记它们并分别将它们在 <code>edgeTo[]</code> 中的值设为 0。</li><li>从队列中删去顶点 2 并检查它的相邻顶点 0 和 1，发现两者都已经被标记。将相邻的顶点 3 和 4 加入队列，标记它们并分别将它们在 <code>edgeTo[]</code> 中的值设为 2。</li><li>从队列中删去顶点 1 并检查它的相邻顶点 0 和 2，发现它们都已经被标记了。</li><li>从队列中删去顶点 5 并检查它的相邻顶点 3 和 0，发现它们都已经被标记了。</li><li>从队列中删去顶点 3 并检查它的相邻顶点 5、4 和 2，发现它们都已经被标记了。</li><li>从队列中删去顶点 4 并检查它的相邻顶点 3 和 2，发现它们都已经被标记了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用广度优先搜索查找图中的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 到达该顶点的最短路径是否已知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 到达该顶点的已知路径上的最后一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        bfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 标记起点</span></span><br><span class="line">        marked[s] = <span class="keyword">true</span>; </span><br><span class="line">        <span class="comment">// 将它加入队列</span></span><br><span class="line">        queue.enqueue(s); </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队列中删去下一顶点</span></span><br><span class="line">            <span class="keyword">int</span> v = queue.dequeue(); </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="comment">// 对于每个未被标记的相邻顶点</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    <span class="comment">// 保存最短路径的最后一条边</span></span><br><span class="line">                    edgeTo[w] = v; </span><br><span class="line">                    <span class="comment">// 标记它，因为最短路径已知</span></span><br><span class="line">                    marked[w] = <span class="keyword">true</span>; </span><br><span class="line">                    <span class="comment">// 并将它添加到队列中</span></span><br><span class="line">                    queue.enqueue(w); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">return</span> marked[v]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x]) &#123;</span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-使用场景"><a href="#5-3-使用场景" class="headerlink" title="5.3 使用场景"></a>5.3 使用场景</h3><h2 id="六-连通分量"><a href="#六-连通分量" class="headerlink" title="六. 连通分量"></a>六. 连通分量</h2><hr><p>参考：</p><p>🔗 《算法-第4版》</p>]]></content>
    
    <summary type="html">
    
      内容主要来自《算法-第4版》，内容包括：图，无向图，深度优先搜索，寻找路径，广度优先搜索等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="graph" scheme="http://linyishui.top/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（六）高级特性</title>
    <link href="http://linyishui.top/2021020101.html"/>
    <id>http://linyishui.top/2021020101.html</id>
    <published>2021-02-01T13:16:33.000Z</published>
    <updated>2021-03-03T13:23:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（六）高级特性"><a href="#《高性能MySQL》（六）高级特性" class="headerlink" title="《高性能MySQL》（六）高级特性"></a>《高性能MySQL》（六）高级特性</h1><h2 id="一-分区表"><a href="#一-分区表" class="headerlink" title="一. 分区表"></a>一. 分区表</h2><h3 id="1-1-什么是分区表？"><a href="#1-1-什么是分区表？" class="headerlink" title="1.1 什么是分区表？"></a>1.1 什么是分区表？</h3><p>分区表是一个独立的逻辑表，底层由多个物理子表组成。一组底层表的句柄对象的封装，对分区表的请求通过句柄对象转换为对存储引擎的接口调用。</p><p>MySQL索引根据分区的子表定义，没有全局索引，不能像Oracle那样指定索引和表是否分区。</p><p>创建表时使用 PARTITION BY 子句定义每个分区存放的数据。每次查询时优化器根据分区定义过滤掉其它分区，使查询只须扫描包含数据的分区。</p><h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><ul><li>无法全部放入内存的大表，或是大部分历史数据、只有少量热点数据。</li><li>分区表的数据易于维护，批量删除大量数据可以直接清除整个分区；还可以对一个分区进行优化、检查、修复等操作。</li><li>分区表的数据可以分布在不同的物理设备上。</li><li>使用分区表可以避免一些特殊瓶颈，如InnoDB的单个索引的互斥访问、ext3文件系统的inode锁竞争等。</li><li>可以备份和恢复独立的分区，在大数据集的场景有很好的效果。</li></ul><h3 id="1-3-使用限制"><a href="#1-3-使用限制" class="headerlink" title="1.3 使用限制"></a>1.3 使用限制</h3><ul><li>一个表最多有1024个分区。</li><li>MySQL 5.1中分区表达式必须返回整数，MySQL 5.5的某些场景可以直接使用列进行分区。</li><li>若分区字段中有主键或唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</li><li>分区表无法使用外键约束。</li></ul><h3 id="1-4-实现原理"><a href="#1-4-实现原理" class="headerlink" title="1.4 实现原理"></a>1.4 实现原理</h3><p>分区表由多个相关底层表实现，底层表由句柄对象表示，存储引擎管理分区的各个底层表与普通表相同，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。</p><p>几种操作的逻辑：虽然都要锁住所有底层表，但其实只是行级锁</p><ul><li>SELECT 查询：查询一个分区表时，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后调用对应存储引擎接口访问各个分区的数据。</li><li>INSERT 操作：写入一条记录时，分区层先打开并锁住所有的底层表，然后确定在哪个分区接收这条记录，并把记录写入底层表。</li><li>DELETE 操作：删除一条记录时，分区层先打开并锁住所有底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作。</li><li>UPDATE 操作：更新一条记录时，分区层先打开并锁住所有底层表，MySQL要先确定更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据所在底层表进行删除操作。</li></ul><h3 id="1-5-分区表的类型"><a href="#1-5-分区表的类型" class="headerlink" title="1.5 分区表的类型"></a>1.5 分区表的类型</h3><p>分区表达式可以使用各种函数，但返回值一定要是一个确定的整数，且不能是一个常数（案例使用YEAR函数根据时间进行分区）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqles (</span><br><span class="line">order_date DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">--other columns</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(order_date)) (</span><br><span class="line"><span class="keyword">PARTITION</span> p_2010 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2011 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2011</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2012 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2012</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_catchall <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>MySQL支持键值、哈希和列表分区，以及使用 RANGE COLUMNS 类型的分区。</p><p>系统通过子分区可降低索引的互斥访问竞争。最近一年的分区数据会被频繁访问，导致大量的互斥量的竞争。使用哈希子分区可以将数据切成多个小片，大大降低互斥量的竞争问题。</p><h3 id="1-6-合理使用分区表"><a href="#1-6-合理使用分区表" class="headerlink" title="1.6 合理使用分区表"></a>1.6 合理使用分区表</h3><p>假设一个需求：需要从一个大表中查出一段时间的记录，表中包含多年的历史数据，按照时间排序。仅仅几个月的数据可能会有上亿或十亿条记录。</p><p>首先不能每次查询时扫描全表，并且考虑索引在空间和维护上的消耗也不能使用（可能会产生大量的碎片，导致一个查询有成千上万的随机I/O）。</p><p>只能<strong>让所有的查询只在数据表上做顺序扫描</strong>，或者<strong>将数据表和索引都缓存在内存中</strong>。</p><p><strong>数据量大时，除非是索引覆盖查询，否则B-Tree索引无法起作用了，数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，若数据量巨大，这将产生大量随机I/O，导致响应时间过长，并且索引的维护代价也很高</strong>。</p><p>分区可以看作初始形态的索引，以非常小的代价定位到数据在哪一片区域，在区域内可以做顺序扫描、可以建索引、可以将数据缓存到内存。分区无需额外的数据结构记录每个分区有哪些数据（因为不需要精确定位数据位置）。</p><p>保证大数据量可扩展性的策略：</p><ul><li><strong>全量扫描数据，不要任何索引</strong>：只要能用WHERE条件将需要的数据限制在少数分区中，效率是很高的，需要一些简单运算保证响应时间能够满足要求，此策略适用于正常方式访问大量数据时。</li><li><strong>索引数据，并分离热点</strong>：当数据有明显的热点，此外的数据很少会被访问到，可以将这部分热点数据单独放在一个分区，从而有机会全部缓存到内存中，使查询只用访问一个很小的分区表，能够有效的使用索引和缓存。</li></ul><h3 id="1-7-常见问题"><a href="#1-7-常见问题" class="headerlink" title="1.7 常见问题"></a>1.7 常见问题</h3><p>上述两种分区策略都基于查询能够过滤到额外分区、分区本身并不会带来额外的代价，但在一些场景下这两种假设会有问题：</p><ul><li><strong>NULL值使分区过滤无效</strong>：<ul><li>所有的NULL值或非法值会被存放到第一个分区；所以如查询 <code>WHERE order_date BETWEEN &#39;2012-01-01&#39; AND &#39;2012-01-31&#39;</code> 会检查2012分区和第一个分区，因为YEAR函数在接收非法值时可能会返回NULL。</li><li>当第一个分区特别大时，代价会很高，尤其是策略<strong>全量扫描数据，不要任何索引</strong>；为了避免此状况，可以创建一个不用的第一分区，通过 <code>PARTITION p_nulls VALUES LESS THAN(0)</code> 来创建，这样如果插入的数据都是有效的情况下第一分区是空的，即使需要检测第一分区也不会有太高代价。</li></ul></li><li><strong>分区列和索引列不匹配</strong>：二者不匹配会导致查询无法进行分区过滤，比如在列a上定义了索引，在列b上进行分区，这样每个分区都有独立的索引，所以扫描列b上的索引需要扫描每个分区对应的索引，虽然扫描速度并不是特别慢，但还是应该尽量避免建立和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。</li><li><strong>选择分区的成本可能很高</strong>：不同的分区类型实现方式不同，性能也不同；范围分区在判断记录数据属于哪一分区的成本很高，因为服务器要扫描所有的分区定义的列表，这样的线性搜索会随分区数增多成本变高。对于键分区或哈希分区则没有此问题，100个左右的分区数不会有问题。</li><li><strong>打开并锁住所有底层表的成本可能很高</strong>：此操作发生于分区过滤之前，无法通过分区过滤降低开销，对于一些本来很快的操作，如根据主键查询单行，会带来额外的开销；可以通过批量操作的方式来降低单个开销，如批量插入或 LOAD DATA INFILE、一次删除多行数据等，同时需要限制分区的个数。</li><li><strong>维护分区的成本可能很高</strong>：新增或删除分区等操作很快（不包括删除大分区），而重组分区（先创建一个临时分区，然后将数据复制到其中，最后删除原分区）或类似ALTER语句的操作需要复制数据。</li></ul><p>使用分区表的限制：</p><ul><li>所有分区要使用相同的存储引擎；</li><li>分区可以使用的函数或表达式受限；</li><li>一些存储引擎不支持分区或有更多限制；</li></ul><h3 id="1-8-优化查询"><a href="#1-8-优化查询" class="headerlink" title="1.8 优化查询"></a>1.8 优化查询</h3><p>分区这种粗粒度索引可以让查询扫描更少的数据，对于访问分区表来说，重要的一点是WHERE条件中加入分区列，即使看起来很多余，因为这样可以使优化器过滤掉无需访问的分区。</p><p>通过EXPLAIN PARTITION观察优化器是否执行了分区过滤，需要注意的是MySQL只能在使用分区函数的列本身进行比较时才能过滤分区，而不能根据表达式的值去过滤分区：<strong>查询时只能通过列来过滤分区</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--无法过滤分区：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales_by_day <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(<span class="keyword">day</span>) = <span class="number">2010</span></span><br><span class="line"><span class="comment">--可以过滤分区：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales_by_day <span class="keyword">WHERE</span> <span class="keyword">day</span> <span class="keyword">BETWEEN</span> <span class="string">'2010-01-01'</span> <span class="keyword">AND</span> <span class="string">'2010-12-31'</span></span><br></pre></td></tr></table></figure><h3 id="1-9-合并表"><a href="#1-9-合并表" class="headerlink" title="1.9 合并表"></a>1.9 合并表</h3><p>合并表（Merge Table）是简单版的分区实现，分区表是一种逻辑上的概念，用户无法访问底层的各个分区，但用户可以单独访问合并表的各个子表。</p><p>分区表与优化器更紧密结合，而合并表则是要被淘汰的技术。</p><p>后续省略。</p><h2 id="二-视图"><a href="#二-视图" class="headerlink" title="二. 视图"></a>二. 视图</h2><h3 id="2-1-什么是视图？"><a href="#2-1-什么是视图？" class="headerlink" title="2.1 什么是视图？"></a>2.1 什么是视图？</h3><ul><li>视图在MySQL 5.0版本引入；</li><li>本身是虚拟表，不存储数据，访问视图时从实体表获取数据；</li><li>视图与表在同一个命名空间，不能对视图创建触发器；</li></ul><h3 id="2-2-视图的两种实现算法"><a href="#2-2-视图的两种实现算法" class="headerlink" title="2.2 视图的两种实现算法"></a>2.2 视图的两种实现算法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Oceania <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> Oceania <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure><p>视图的两种实现：</p><ul><li><p><strong>临时表算法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> TMP_Oceania <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> TMP_Oceania <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>合并算法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure></li></ul><p>可以在 <code>EXPLAIN EXTENDED</code> 后使用 <code>SHOW WARNINGS</code> 查看使用视图的查询重写后的结果，临时表算法实现的视图会显示为派生表（DERIVED）：<code>EXPLAIN SELECT * FROM View</code> 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010101.png" alt></p><p>只要无法在原表记录和视图记录建立一对一映射的场景都无法使用临时表算法实现视图，如 GROUP BY，DISTINCT，聚合函数，UNION，子查询等。</p><h3 id="2-3-可更新视图"><a href="#2-3-可更新视图" class="headerlink" title="2.3 可更新视图"></a>2.3 可更新视图</h3><p>可更新视图就是能够通过更新视图来更新视图涉及的表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Oceania <span class="keyword">SET</span> Population = Population * <span class="number">1.1</span> <span class="keyword">WHERE</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure><p>视图定义包含 GROUP BY，聚合函数，UNION等情况不能更新相关表，所有使用临时表算法实现的视图不能更新，被更新的列必须来自同一张表。</p><p><code>CHECK OPTION</code> 表示任何通过视图更新的行，都必须符合视图本身的WHERE条件定义，不能更新视图定义列外的列。</p><h3 id="2-4-视图对性能的影响"><a href="#2-4-视图对性能的影响" class="headerlink" title="2.4 视图对性能的影响"></a>2.4 视图对性能的影响</h3><p>视图在某些场景也可以帮助提高性能，</p><ul><li><p>重构Schema时使用视图，修改表结构时不会影响应用运行；</p></li><li><p>使用视图实现基于列的权限控制，不需要真正的在系统创建权限，没有额外开销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> XX <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> XXX;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> public.* <span class="keyword">TO</span> public_user;</span><br></pre></td></tr></table></figure></li><li><p>视图并没有看起来那样简单，使用视图提示性能需要做比较详细的测试，临时表算法实现的视图在很多场景下性能很糟糕，合并算法实现的视图也会有额外开销，并且视图的性能很难预测。</p></li></ul><h3 id="2-5-使用视图的一些限制"><a href="#2-5-使用视图的一些限制" class="headerlink" title="2.5 使用视图的一些限制"></a>2.5 使用视图的一些限制</h3><ul><li>MySQL不支持物化视图，指将视图结果数据存放在一个可以查看的表，并定时从原始表刷新数据到这个表；</li><li>MySQL视图不支持创建索引，但可以使用缓存表或汇总表模拟物化视图和索引；</li><li>MySQL不会保存视图定义的原始SQL语句，可以通过使用视图的 <code>.frm</code> 文件最后一行获取信息2，如果有FILE权限，可以直接使用SQL语句的 <code>LOAD_FILE()</code> 读取 <code>.frm</code> 的视图创建信息，再处理掉转义字符等。</li></ul><h2 id="三-外键约束"><a href="#三-外键约束" class="headerlink" title="三. 外键约束"></a>三. 外键约束</h2><p>InnoDB引擎支持外键。</p><p>优点：</p><ul><li>如果想确保两个表始终有一致性的数据，使用外键比在应用中保证一致性要高效的多，级联更新和删除也要更快。</li></ul><p>缺点：</p><ul><li>InnoDB强制外键使用索引，当外键列的选择性很低，会导致一个非常大且选择性很低的索引，且该索引除了做外键限制没有其他作用。</li><li>使用外键需要成本，每次修改数据时都要在另一张表中多执行一次查询操作。</li><li>查询需要额外访问一些表，意味着需要额外的锁。若向子表写入一条记录，外键约束使InnoDB检查父表中对应的记录进行加锁操作，确保该记录不会在事务完成时被删除，会导致额外的锁等待，甚至导致一些难以排查的死锁。</li></ul><p>可以使用触发器来代替外键，当外键只是用作数值约束。如果只是把外键做约束，在应用层实现会更好，因为外键会带来大量的额外消耗，很多过往的经验告诉我们在删除外键时性能会有大幅提升。</p><h2 id="四-在MySQL内部存储代码"><a href="#四-在MySQL内部存储代码" class="headerlink" title="四. 在MySQL内部存储代码"></a>四. 在MySQL内部存储代码</h2><h3 id="4-1-存储代码的方式"><a href="#4-1-存储代码的方式" class="headerlink" title="4.1 存储代码的方式"></a>4.1 存储代码的方式</h3><p>主要区别在于执行的上下文—输入和输出</p><ul><li>触发器</li><li>存储过程：可以接收参数返回值</li><li>函数：可以接收参数返回值</li><li>定时任务 / 事件</li></ul><h3 id="4-2-存储代码的优缺点"><a href="#4-2-存储代码的优缺点" class="headerlink" title="4.2 存储代码的优缺点"></a>4.2 存储代码的优缺点</h3><p>优点：</p><ul><li>服务器内部执行，离数据最近，可以节省带宽和网络延迟；</li><li>这是一种代码重用，方便统一业务规则，保证某些行为总是一致，所以也带来了一定的安全性；</li><li>简化代码的维护和版本更新；</li><li>帮助提升安全性，提供了更细粒度的权限控制，应用可以通过存储过程的接口访问没有权限的表；</li><li>服务器端可以缓存存储过程的执行计划，降低了需要反复调用的过程的消耗；</li><li>在服务器端部署，备份和维护都在服务器端完成；</li><li>可以在应用开发和数据库开发间更好的分工。</li></ul><p>缺点：</p><ul><li>MySQL没有提供好用的开发和调试工具，编写存储代码难度较高；</li><li>存储代码相比应用代码效率要差一些，很难实现复杂逻辑；</li><li>存储代码可能会带来额外的复杂性，原本只需部署应用代码和库表结构变更，还需要额外部署内部存储代码；</li><li>部署在服务器会带来安全隐患，只要破解数据库就将功能和数据全部获取；</li><li>存储过程给数据库服务器带来额外的压力，数据库服务器的扩展性要远差于应用服务器。</li><li>无法控制存储程序的资源消耗，可能一个错误就把服务器拖死。</li><li>存储代码的实现有很多限制，调试也很困难，难以定位问题。</li><li>与基于语句的二进制日志复制合作的不好。</li></ul><h3 id="4-3-存储过程和函数"><a href="#4-3-存储过程和函数" class="headerlink" title="4.3 存储过程和函数"></a>4.3 存储过程和函数</h3><p>优化器对存储代码的限制：</p><ul><li>优化器无法使用关键字DETERMINISTIC来优化单个查询中多次调用存储函数的情况。</li><li>优化器无法评估存储函数的执行成本。</li><li>每个连接都有独立的存储过程的执行计划缓存，如果有多个连接需要调用同一个存储过程，就会浪费空间来反复缓存同样的执行计划（连接池或持久化连接会造成缓存更长的生命周期）。</li><li>存储过程和复制是一对诡异的组合，最好不要复制对存储程序的调用，直接复制其改变的数据。MySQL 5.1 后引入行复制。</li></ul><h3 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a>4.4 触发器</h3><h4 id="4-4-1-什么是触发器？"><a href="#4-4-1-什么是触发器？" class="headerlink" title="4.4.1 什么是触发器？"></a>4.4.1 什么是触发器？</h4><ul><li>触发器可以让你在执行 INSERT、UPDATE或DELETE时，执行一些特定的操作。</li><li>可以指定是在SQL语句前或后触发，触发器本身没有返回值，但可以读取或改变触发SQL语句所影响的数据。</li><li>使用触发器可以减少客户端和服务器之间的通信，简化应用逻辑，一定程度上提高性能。</li></ul><h4 id="4-4-2-使用注意"><a href="#4-4-2-使用注意" class="headerlink" title="4.4.2 使用注意"></a>4.4.2 使用注意</h4><ul><li>对每个表的每个事件，最多只能定义一个触发器（如不能再AFTER INSERT上定义两个触发器）。</li><li>MySQL只支持基于行的触发，即触发器始终针对一条记录，而不是针对整个SQL语句，当数据集变得很大时，效率会很低。</li><li>触发器会掩盖服务器背后很多工作，而触发器的问题很难排查。</li><li>触发器可能会导致死锁和锁等待，触发器执行失败会导致SQL也失败，但不会有直接明确的提示。</li><li>触发器在InnoDB表上是在同一个事务中完成的，执行操作是原子的，原子操作和触发器操作会同时失败或成功。</li><li>在InnoDB上使用触发器去检查数据一致性要小心MVCC，可能会得到错误结果。</li></ul><h3 id="4-5-事件"><a href="#4-5-事件" class="headerlink" title="4.5 事件"></a>4.5 事件</h3><ul><li>MySQL 5.1 引入事件作为一种新的存储代码的方式，MySQL内部实现的类似于Linux的定时任务。</li><li>指定MySQL在某个时间执行一段SQL代码，或者每隔一个时间间隔。其中复杂的SQL封装在一个存储过程中，事件执行时只需做一个简单的调用。</li><li>事件在一个独立事件调度线程中被初始化，该线程和处理连接的线程没有关系，它不接收任何参数，也没有任何返回值。可以在MySQL的日志中看到命令的执行日志，在表 INFORMATION_SCHEMA.EVENTS 中看到各个事件状态。</li><li>事件实现机制本身开销不大，但事件需要执行SQL，这可能会对性能有很大影响；事件和其他存储程序一样，在和基于语句的复制一起工作时可能会导致一些问题。</li><li>定时事件可能会执行很久，前一个事件未执行完，后一个事件开始执行，开发要自己处理这种情况下的并发（可以使用 <code>GET_LOCK()</code> 确保当前总是只有一个事件在执行-加锁）。</li><li>通过 <code>SET GLOBAL event_scheduler := 1;</code> 设置事件调度线程，设置后此线程执行各个用户指定的事件中的各段SQL代码。</li><li>事件调度本身是一个单独的线程，MySQL创建一个新的进程用于事件执行，进程和线程的生命周期是事件的执行过程，状态总为 Connect 。</li></ul><h2 id="五-游标"><a href="#五-游标" class="headerlink" title="五. 游标"></a>五. 游标</h2><p>暂略。</p><h2 id="六-绑定变量"><a href="#六-绑定变量" class="headerlink" title="六. 绑定变量"></a>六. 绑定变量</h2><h3 id="6-1-什么是绑定变量？"><a href="#6-1-什么是绑定变量？" class="headerlink" title="6.1 什么是绑定变量？"></a>6.1 什么是绑定变量？</h3><ul><li><p>MySQL 4.1 版本引入绑定变量（prepared statement），用于提高客户端和服务器端数据传输的效率。</p></li><li><p>流程：创建一个绑定变量的SQL时，客户端向服务端发送一个SQL语句的原型；服务端收到后，解析并存储这个SQL语句的部分执行计划，返回给客户端一个SQL语句处理句柄，以后每次执行此类查询，客户端都指定使用这个句柄。</p></li><li><p>语法：用问号标记可以接收参数的位置，通过向服务器端发送各个问号的取值和这个SQL的句柄来执行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb1(col1, col2, col3) <span class="keyword">VALUES</span> (?, ?, ?);</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-绑定变量为何能提高性能？"><a href="#6-2-绑定变量为何能提高性能？" class="headerlink" title="6.2 绑定变量为何能提高性能？"></a>6.2 绑定变量为何能提高性能？</h3><ul><li>在服务器端只需解析一次SQL语句。</li><li>在服务器端某些优化器的工作只需执行一次，因为会缓存一部分执行计划。</li><li>以二进制的方式只发送参数和句柄，比每次都发送ASCII码文本效率要高，比如一个二进制的日期只需三个字节，而后者则需要十个字节；可以分块传输，而无需一次性传输；还节省了将数据从原始格式转为文本格式的开销。</li><li>只传输参数，而不是整个语句，网络开销降低。</li><li>MySQL直接将参数存储到缓存，不需要在内存中多次复制。</li></ul><h3 id="6-3-优化"><a href="#6-3-优化" class="headerlink" title="6.3 优化"></a>6.3 优化</h3><p>比如当执行计划需要根据传入的参数计算时，MySQL无法缓存这部分计划。</p><p>根据优化器工作阶段，划分三类优化：</p><ol><li><strong>准备阶段</strong>：服务器解析SQL语句，移除不可能条件，并且重写子查询。</li><li><strong>第一次执行</strong>：服务器先简化嵌套循环的关联，并将外关联转换成内关联。</li><li><strong>每次SQL语句执行</strong>：<ul><li>过滤分区</li><li>尽量移除 <code>COUNT()</code> 、<code>MIN()</code> 和 <code>MAX()</code> </li><li>移除常数表达式</li><li>做必要的等值传播</li><li>分析和优化 ref 、range 和索引优化等访问数据的方法</li><li>优化关联顺序</li></ul></li></ol><h3 id="6-4-SQL接口的绑定变量"><a href="#6-4-SQL接口的绑定变量" class="headerlink" title="6.4 SQL接口的绑定变量"></a>6.4 SQL接口的绑定变量</h3><p>MySQL 在 4.1 版本中支持了SQL接口的绑定变量，不需要使用二进制传输协议也可以直接以SQL的方式使用绑定变量。</p><p>服务器会将SQL语句翻译，无需使用二进制协议：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> := <span class="string">'SELECT actor_id, first_name, last_name FROM actor WHERE first_name = ?'</span>;</span><br><span class="line"><span class="keyword">PREPARE</span> stmt_fetch_actor <span class="keyword">FROM</span> @<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SET</span> @actor_name := <span class="string">'Penelope'</span></span><br><span class="line"><span class="keyword">EXECUTE</span> stmt_fetch_actor <span class="keyword">USING</span> @actor_name;</span><br><span class="line">DEALLOATE <span class="keyword">PREPARE</span> stmt_fetch_actor;</span><br></pre></td></tr></table></figure><p>这种写法的主要用途是在存储过程中使用，可以灵活的拼接字符串等参数构建SQL语句，除此外相比二进制协议就没什么优势了。</p><p>使用限制：</p><ul><li>绑定变量是会话级别，连接之间不能共用绑定变量句柄。一旦连接断开，原来的句柄也不能使用，使用连接池和持久化连接可以缓解此问题。</li><li>MySQL 5.1 之前版本，绑定变量的SQL不能使用查询缓存。</li><li>只执行一次的SQL，使用绑定变量会多一次额外的准备阶段消耗，和一次额外的网络开销。</li><li>不能在存储函数中使用。</li><li>未释放的绑定变量资源容易造成资源泄露，对所有线程造成影响。</li><li>如BEGIN等操作无法在绑定变量中完成。</li></ul><h3 id="6-5-三种绑定变量的区别"><a href="#6-5-三种绑定变量的区别" class="headerlink" title="6.5 三种绑定变量的区别"></a>6.5 三种绑定变量的区别</h3><ul><li><strong>客户端模拟的绑定变量</strong>：接收一个带参数的SQL，将指定的值带入，最后将完整的查询发送到服务器端。</li><li><strong>服务端的绑定变量</strong>：客户端使用特殊的二进制协议将带参数的字符串发送到服务器端，然后使用二进制协议将具体的参数值发送给服务器端并执行。</li><li><strong>SQL接口的绑定变量</strong>：客户端先发送一个带参数的字符串到服务器，类似于使用PREPARE的SQL语句，然后发送设置参数的SQL，最后使用EXECUTE来执行SQL，使用普通的文本传输协议。</li></ul><h2 id="七-用户自定义函数"><a href="#七-用户自定义函数" class="headerlink" title="七. 用户自定义函数"></a>七. 用户自定义函数</h2><p>暂略。</p><h2 id="八-插件"><a href="#八-插件" class="headerlink" title="八. 插件"></a>八. 插件</h2><p>暂略。</p><h2 id="九-字符集和校对"><a href="#九-字符集和校对" class="headerlink" title="九. 字符集和校对"></a>九. 字符集和校对</h2><p>暂略。</p><h2 id="十-全文索引"><a href="#十-全文索引" class="headerlink" title="十. 全文索引"></a>十. 全文索引</h2><h3 id="10-1-什么是全文索引？"><a href="#10-1-什么是全文索引？" class="headerlink" title="10.1 什么是全文索引？"></a>10.1 什么是全文索引？</h3><ul><li><strong>场景</strong>：如果想要通过关键字的匹配来进行查询过滤，需要基于相似度的查询而不是精确的数据比较，全文索引专为此场景设计。</li><li><strong>支持</strong>：各种字符串内容的搜索，包括CHAR、VARCHAR和TEXT类型，支持自然语言搜索和布尔搜索。</li><li>互联网搜索引擎技术和全文索引基本原理相同。</li></ul><h3 id="10-2-自然语言的全文索引"><a href="#10-2-自然语言的全文索引" class="headerlink" title="10.2 自然语言的全文索引"></a>10.2 自然语言的全文索引</h3><p>该引擎会计算每一个文档对象和查询的相关度，相关度基于匹配的关键词个数，以及关键词在文档中出现的次数。出现次数越少的词语，匹配时的相关度就越高，常见的词语将不会搜索（超过50%的记录都出现），即使不在停用词列表中出现。</p><p>可以根据WHERE子句中的MATCH AGAINST来区分查询是否使用全文索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> film_text;</span><br><span class="line"><span class="comment">--index_type为FULLTEXT，假设两个字段title, description建立了全文索引</span></span><br><span class="line"><span class="keyword">select</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>), <span class="keyword">MATCH</span>(title, description) AGAINST(<span class="string">'factory casualties'</span>) <span class="keyword">AS</span> relevance </span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description) AGAINST(<span class="string">'factory casualties'</span>);</span><br><span class="line"><span class="comment">--MySQL将搜索词语分为两个独立的关键词进行搜索，函数MATCH()会返回关键词匹配的相关度</span></span><br></pre></td></tr></table></figure><p>在MATCH函数中指定的列必须和全文索引指定的列相同，否则无法使用全文索引，因为全文索引不会记录关键字来自哪一列。也意味着无法使用全文索引来查询某个关键字是否在某一列中存在。</p><h3 id="10-3-布尔全文索引"><a href="#10-3-布尔全文索引" class="headerlink" title="10.3 布尔全文索引"></a>10.3 布尔全文索引</h3><p>用户可以在布尔搜索的查询中自定义某个被搜索词语的相关性，通过停用词列表过滤掉“噪声”词，要求搜索关键词长度需要大于 <code>ft_min_word_len</code> 且小于 <code>ft_max_word_len</code> ，搜索结果未经排序。</p><p>通过<strong>前缀修饰符</strong>来定制布尔搜索：</p><ul><li>dinosaur：包含dinosaur的行rank值更高</li><li>~dinosaur：包含dinosaur的行rank值更低</li><li>+dinosaur：行记录必须包含dinosaur</li><li>-dinosaur：行记录不可以包含dinosaur</li><li>dino*：包含以dino开头的单词的行rank值更高</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询必须同时包含factory和casualties</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description)</span><br><span class="line">AGAINST(<span class="string">'+factory +casualties'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询中使用括号进行短语搜索</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description)</span><br><span class="line">AGAINST(<span class="string">'"spirited casualties"'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure><p>短语搜索较慢，因为单使用全文索引无法判断是否精确匹配到短语，通常还要查询原文确定记录是否包含完整的短语，因为需要回表过滤，所以效率不高。</p><h3 id="10-4-使用限制"><a href="#10-4-使用限制" class="headerlink" title="10.4 使用限制"></a>10.4 使用限制</h3><ul><li>全文索引只能通过词频来判断相关性，索引不会记录索引词在字符串的位置。</li><li>全文索引只有全部在内存中时才有较好的性能，使用精确短语搜索时，需要数据和索引都在内存中。</li><li>全文索引相比其他索引在 INSERT、UPDATE 和 DELETE 操作的代价都很大：<ul><li>修改文本中的100个单词，需要100次索引操作，而不是一次。</li><li>一般情况，列长度不会影响其他索引类型，但对于全文索引，个位数单词文本和10000个单词的文本，性能可能相差几个数量级。</li><li>全文索引有更多碎片，可能需要做更多的 <code>OPTIMIZE TABLE</code> 操作。</li></ul></li><li>全文索引影响优化器：<ul><li>查询中使用了 <code>MATCH AGAINST</code> 子句，对应列有可用的全文索引，这种情况一定会使用全文索引，即使可能有性能更好的其他索引。</li><li>全文索引只能用作全文搜索匹配，任何其他操作，如WHERE条件比较，都需要在MySQL完成全文搜索返回记录后才能进行，普通索引可以在处理WHERE条件时一次判断多个比较表达式。</li><li>全文索引不存储索引列的实际值，索引不能用作索引覆盖扫描。</li><li>除了相关性排序，全文索引不能用于其他排序。</li></ul></li></ul><h2 id="十一-分布式（XA）事务"><a href="#十一-分布式（XA）事务" class="headerlink" title="十一. 分布式（XA）事务"></a>十一. 分布式（XA）事务</h2><h3 id="11-1-MySQL中的XA事务"><a href="#11-1-MySQL中的XA事务" class="headerlink" title="11.1 MySQL中的XA事务"></a>11.1 MySQL中的XA事务</h3><p>存储引擎的事务特性能保证在存储引擎级别实现ACID，分布式事务则可以扩展到数据库层面，以及多个数据库之间。通过<strong>两阶段提交</strong>来实现。</p><p>MySQL 在 5.0 版本支持 XA 事务，XA事务需要有一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）；如果协调器收到所有参与者都准备好的消息，就会告诉事务可以提交了（第二阶段）。MySQL在 XA 事务中的角色是参与者而不是协调者。</p><h3 id="11-2-内部XA事务"><a href="#11-2-内部XA事务" class="headerlink" title="11.2 内部XA事务"></a>11.2 内部XA事务</h3><h4 id="（1）二进制日志在使用XA事务"><a href="#（1）二进制日志在使用XA事务" class="headerlink" title="（1）二进制日志在使用XA事务"></a>（1）二进制日志在使用XA事务</h4><p>MySQL本身的插件式架构导致其内部需要使用XA事务。MySQL中各个存储引擎相互独立，无法感知对方的存在，所以一个跨存储引擎的事务需要一个外部的协调者，否则无法满足ACID。</p><p>存储引擎提交的同时，需要将提交信息写入二进制日志，这就是一个分布式事务，可以把二进制日志操作看作一个独立的存储引擎。</p><h4 id="（2）XA事务影响性能"><a href="#（2）XA事务影响性能" class="headerlink" title="（2）XA事务影响性能"></a>（2）XA事务影响性能</h4><p>XA事务导致MySQL性能大幅下降，直接破坏了MySQL内部的批量提交（一种通过单磁盘I/O操作完成多个事务提交的技术，已有多种解决方案），使得MySQL不得不进行多次额外的 <code>fsync()</code> 调用。</p><p>一个事务若是开启了二进制日志，不仅需要对二进制日志进行持久化操作，InnoDB事务日志还需要两次日志持久化操作。即<strong>二进制日志安全的事务实现需要至少三次 <code>fsync()</code> 操作。</strong></p><h4 id="（3）配置项"><a href="#（3）配置项" class="headerlink" title="（3）配置项"></a>（3）配置项</h4><p>可以通过将 <code>innodb_support_xa</code> 设置为0 关闭二进制日志（复制需要二进制日志和XA事务的支持，所以此设置也会使复制无法使用）。</p><p>将 <code>sync_binlog</code> 设置为1，保证存储引擎和二进制日志是真正同步的。否则事务提交了二进制日志却可能未“提交”到磁盘。</p><h3 id="11-3-外部XA事务"><a href="#11-3-外部XA事务" class="headerlink" title="11.3 外部XA事务"></a>11.3 外部XA事务</h3><p>MySQL能够作为参与者完成一个外部的分布式事务，但其对XA协议的支持还不完整，如当前版本还不支持一个事务中多个连接可以做关联。</p><p>因为通信延迟和参与者本身可能失败，外部XA事务会比内部的消耗更大。对于网络环境不稳定或用户长时间等待而不提交，需要避免使用XA事务，它会影响所有参与者。</p><p>XA事务是一种在多个服务器之间同步数据的方法，不能使用MySQL本身的复制，以及性能非瓶颈时可以尝试使用。</p><h2 id="十二-查询缓存"><a href="#十二-查询缓存" class="headerlink" title="十二. 查询缓存"></a>十二. 查询缓存</h2><h3 id="12-1-什么是查询缓存？"><a href="#12-1-什么是查询缓存？" class="headerlink" title="12.1 什么是查询缓存？"></a>12.1 什么是查询缓存？</h3><p>MySQL可以缓存查询的执行计划，相同类型的SQL可以跳过SQL的解析和执行计划生成阶段；查询缓存是另一种缓存类型，缓存完整的SELECT结果。</p><p>命中查询缓存后会直接返回结果，跳过了解析、优化和执行阶段。</p><p>查询缓存系统会跟踪查询涉及的每张表，当表发生变化会导致相关的缓存数据失效；虽然看起来这种实现比较低效率，因为表变化时未必会导致数据查询结果有变更，但这样的实现代价很小。</p><p>查询缓存对于应用程序来说是完全透明的。</p><h3 id="12-2-谨慎使用查询缓存"><a href="#12-2-谨慎使用查询缓存" class="headerlink" title="12.2 谨慎使用查询缓存"></a>12.2 谨慎使用查询缓存</h3><p>查询缓存是一个影响服务器扩展性的因素，可能会变成整个服务器的资源竞争点，在多核服务器上甚至可能导致服务器僵死。默认建议关闭查询缓存，如果判断查询缓存很有作用，也应该只配置一个较小的查询缓存空间（如几十兆）。</p><h3 id="12-3-MySQL如何判断缓存命中？"><a href="#12-3-MySQL如何判断缓存命中？" class="headerlink" title="12.3 MySQL如何判断缓存命中？"></a>12.3 MySQL如何判断缓存命中？</h3><p>缓存存放在一个引用表中，通过一个哈希值引用，哈希值包括查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能会影响返回结果的信息。</p><p>当判断缓存是否命中时，MySQL不会解析、正规化或参数化查询语句，而是直接使用SQL语句和其他收到的原始信息来判断。<strong>任何字符上的不同，如空格、注释等都会导致缓存不命中</strong>。</p><p>当查询语句中有一些不确定的数据时，不会被缓存。如函数 <code>NOW()</code> 或 <code>CURRENT_DATE()</code> 的查询不会被缓存，以及 <code>CURRENT_USER</code> 或 <code>CONNECTION_ID()</code> 。总结，<strong>查询包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库的系统表，或任何包含列级别权限的表，都不会被缓存</strong>。</p><p>MySQL并不解析SQL，它如何知道查询中含有不确定的函数？MySQL通过一个大小写不敏感的检查确认SQL语句是否以SEL开头。查询缓存是在完整的SELECT语句基础之上，只有在刚收到SQL语句时检查，所以子查询和存储过程都无法使用查询缓存。</p><h3 id="12-4-使用限制"><a href="#12-4-使用限制" class="headerlink" title="12.4 使用限制"></a>12.4 使用限制</h3><ul><li>开启查询缓存会对读写操作都带来额外的消耗：<ul><li>读查询在开始前要检查是否命中缓存；</li><li>读查询可以被缓存，在执行完成后，MySQL检查还未被缓存，会将结果存入查询缓存；</li><li>向某个表写入数据时，MySQL要将相关缓存设置失效。如果查询缓存很大或者碎片很多</li></ul></li><li>对查询缓存操作是一个加锁排他操作。</li><li>事务中修改某表会使对应查询缓存都设置失效，但InnoDB的多版本特性会暂时将这个修改对其他事务屏蔽，此事务提交前，这个表的相关查询无法被缓存，只能在事务提交后才被缓存。因此，长时间运行的事务会大大降低查询缓存的命中率。</li><li>查询缓存可能会使用大量的内存，并且因为操作靠一个全局锁保护，所有需要做该操作的查询都要等待这个锁。</li></ul><h3 id="12-5-查询缓存如何使用内存"><a href="#12-5-查询缓存如何使用内存" class="headerlink" title="12.5 查询缓存如何使用内存"></a>12.5 查询缓存如何使用内存</h3><p>查询缓存全部存储在内存中。除了查询结果，还要存放一些维护相关的数据，类似于文件系统：（大概需要40KB的内存资源）</p><ul><li>确定哪些内存目前可用；</li><li>哪些已经用掉；</li><li>哪些用来存储数据表和查询结果之前的映射；</li><li>哪些用来存储数据表和查询结果之前的映射；</li><li>哪些用来存储查询字符串和查询结果。</li></ul><p>MySQL用于查询缓存的内存被分为一个个的数据块，数据块是变长的。每个数据块存储了自己的类型、大小和数据本身，还外加指向前一个和后一个数据块的指针。</p><p>数据块类型：不同存储块在内存使用上没有不同</p><ul><li>存储查询结果</li><li>存储查询和数据表的映射</li><li>存储查询文本</li></ul><p>使用流程：</p><ul><li>服务器启动时，先初始化查询缓存需要的内存，内存池初始是一个完整的空闲块。空闲块的大小就是所配置查询缓存大小再减去用于维护元数据的数据结构所消耗的空间。</li><li>当有查询结果需要缓存时，MySQL先从大的空间块中申请一个数据块用于存储结果。这个数据块需要大于配置 <code>query_cache_min_res_unit</code> ，即使查询结果远远小于此。因为需要在查询开始返回结果的时候就分配空间，此时是无法预知查询结果有多大，MySQL无法为每个查询结果精确分配空间。</li></ul><p>分配内存块操作很慢，需要先锁住空间块，然后找到合适大小的数据块。当需要缓存一个查询结果时，MySQL先选择一个尽可能小的内存块，然后将结果存入其中。如果数据块全部用完，但仍有数据需要存储，MySQL会申请一块新数据块（尽量小）。查询完成后有剩余会被释放。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010102.png" alt></p><p>上述分配内存块并非指<strong>通过函数 <code>malloc()</code> 向操作系统申请内存</strong>，此操作只在初次创建查询缓存时执行一次。指的是在空闲块列表中找到一个合适的内存块，或者从正在使用的、待淘汰的内存块中回收再使用（MySQL自己管理内存）。</p><p>假设平均查询结果很小，服务器在并发地向不同的两个连接返回结果，返回结果后MySQL回收剩余数据块空间时会发现，回收的数据块小于 <code>query_cache_min_res_unit</code> ，所以不能直接在后续的内存块中分配使用：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010103.png" alt></p><h3 id="12-6-适用场景"><a href="#12-6-适用场景" class="headerlink" title="12.6 适用场景"></a>12.6 适用场景</h3><p>理论上可以通过对比打开和关闭查询缓存的系统效率来判断：关闭查询缓存时，每个查询都需要完整的执行，每次写操作执行完成后立刻返回；打开查询缓存时，每次读请求先检查缓存是否命中，如果命中则立刻返回，否则就完整地执行查询，每次写操作则需要检查查询缓存中是否有需要失效的缓存，然后再返回。</p><p>对于一些需要消耗大量资源的查询通常都适合使用缓存，如汇总计算查询 <code>COUNT()</code> ；较为复杂的SELECT语句，如多表JOIN后还需要做排序和分页，此类查询每次执行消耗都很大，但返回结果集很小，非常适合查询缓存（UPDATE、DELETE 和 INSERT 操作要占比小）。</p><p>一个判断查询缓存是否有效的直接数据是命中率，即使用查询缓存返回结果占总查询的比率。当MySQL接收到一个SELECT查询时，要么增加 <code>Qcache_hits</code> 的值，要么增加 <code>Com_select</code> 的值。计算查询缓存命中率： <code>Qcache_hits / ( Qcache_hits + Com_select )</code> 。命中率多大才合适很难判断，有时即使很低的命中率对于性能提升也有好处。</p><p>缓存未命中的几种可能：</p><ul><li>查询语句无法被缓存，如包含不确定的函数、查询结果太大而无法缓存，都会导致状态值 <code>Qcache_not_cached</code> 增加。</li><li>MySQL从未处理这个查询，所以结果也不曾被缓存过。</li><li>虽然缓存了结果，但由于查询缓存的内存用完，需要将某些缓存移除；或是数据表被修改导致缓存失效。</li><li>大量缓存未命中，但实际上绝大数查询都缓存了：<ul><li>查询缓存还未完成预热；</li><li>查询语句之前从未执行，若应用不会重复执行一条查询语句，即使完成预热仍会有很多缓存未命中；</li><li>缓存失效操作过多。</li></ul></li></ul><p>几种检查方案：</p><ul><li>通过参数 <code>Com_*</code> 来查看数据修改的情况，包括 Com_update，Com_delete等。</li><li>通过 <code>Qcache_lowmem_prunes</code> 来查看有多少次失效是由于内存不足导致的。</li><li>通过查看 <code>Com_select</code> 和 <code>Qcache_inserts</code> 的相对值来查看是否缓存结果未被其他SELECT语句使用。如果每次查询都是缓存未命中，然后需要将查询结果放到缓存中，那么二者值应该相当，所以期望的情况应该是 <code>Qcache_inserts</code> 远远小于 <code>Com_select</code> 。</li><li>更直观的方案：命中和写入的比率，即 <code>Qcache_hits</code> 和 <code>Qcache_inserts</code> 的比值，当结果大于3 : 1时一般表示缓存是有效的，最好是能达到10 : 1。</li></ul><h3 id="12-7-配置和维护"><a href="#12-7-配置和维护" class="headerlink" title="12.7 配置和维护"></a>12.7 配置和维护</h3><p>配置参数：</p><ul><li>query_cache_type：是否打开查询缓存，有 OFF、ON或DEMAND，DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才放入查询缓存。</li><li>query_cache_size：查询缓存使用的总内存空间，单位为字节，必须是1024的整数倍。</li><li>query_cache_min_res_unit：在查询缓存中分配内存块时的最小单位。</li><li>query_cache_limit：MySQL能缓存的最大查询结果，超过此值不会被缓存，只有结果全部返回时才能知道是否超出限制。</li><li>query_cache_wlock_invalidate：某个表被其他连接锁住，是否依然可以从查询缓存中返回结果。</li></ul><p>如何减少碎片：暂略。</p><p>提供查询缓存的使用率：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010104.png" alt></p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：分区表，视图，外键约束，内部存储代码，游标，绑定变量，用户自定义函数，全文索引，分布式事务，查询缓存等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（五）查询性能优化</title>
    <link href="http://linyishui.top/2020122901.html"/>
    <id>http://linyishui.top/2020122901.html</id>
    <published>2020-12-29T12:13:34.000Z</published>
    <updated>2021-03-03T13:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（五）查询性能优化"><a href="#《高性能MySQL》（五）查询性能优化" class="headerlink" title="《高性能MySQL》（五）查询性能优化"></a>《高性能MySQL》（五）查询性能优化</h1><p>查询优化、索引优化、库表结构优化需要齐头并进。</p><h2 id="一-为什么查询速度会慢"><a href="#一-为什么查询速度会慢" class="headerlink" title="一. 为什么查询速度会慢"></a>一. 为什么查询速度会慢</h2><p>查询是一项任务，由一系列子任务组成，每个子任务都要消耗一定时间，优化查询就是要么消除一部分子任务、要么减少子任务的执行次数、要么提供子任务的执行速度。</p><p>查询的生命周期大致包括：从客户端、到服务器、服务器进行解析、生成执行计划、执行、返回结果给客户端。其中执行是最重要的阶段，包括大量检索数据到存储引擎以及后续数据处理，如排序、分组等。</p><p>查询会在如网络、CPU计算、生成统计信息和执行计划、锁等待（互斥等待）等操作上花费时间。慢查询普遍都会存在如操作被额外的重复执行了多次、某些操作执行的太慢等问题。</p><h2 id="二-优化数据访问"><a href="#二-优化数据访问" class="headerlink" title="二. 优化数据访问"></a>二. 优化数据访问</h2><p>大部分性能低下的查询都可以通过减少访问的数据量来优化：</p><ol><li>检查是否访问了太多的行或列；</li><li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li></ol><h3 id="2-1-是否向数据库请求了不需要的数据"><a href="#2-1-是否向数据库请求了不需要的数据" class="headerlink" title="2.1 是否向数据库请求了不需要的数据"></a>2.1 是否向数据库请求了不需要的数据</h3><ul><li><strong>查询不需要的记录</strong>：比如查询大量数据后，再仅显示前面N行。最简单的解决方案是查询加LIMIT。</li><li><strong>多表关联时返回全部列</strong>：比如 SELECT <em> FROM A JOIN B JOIN C ，实际上仅需要A表的列，改为 SELECT A.</em> 最好明确指定每个返回列。</li><li><strong>总是取出全部列</strong>：每次使用 <code>SELECT *</code> 时都要仔细思考是否需要全部列，有时DBA会禁止类似写法。</li><li><strong>重复查询相同的数据</strong>：比如用户评论时要获取头像URL，可以考虑缓存这类数据，避免每次都要重复查询。</li></ul><h3 id="2-2-是否在扫描额外的记录"><a href="#2-2-是否在扫描额外的记录" class="headerlink" title="2.2 是否在扫描额外的记录"></a>2.2 是否在扫描额外的记录</h3><p>衡量查询开销的三个指标：慢查询日志包含这三项内容</p><ul><li><strong>响应时间</strong>：服务时间+排队时间，但实际测量往往无法区分二者；</li><li><strong>扫描的行数</strong>：EXPLAIN的type列反应了访问类型，如全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等，速度由慢至快，扫描行数由多到少；访问类型不够合适时，最好创建一个合适的索引；<strong>MySQL不会返回真实的扫描行数，只会告知生成结果时一共扫描了多少行，但可能大部分行是被WHERE条件过滤</strong>；</li><li><strong>返回的行数</strong>：扫描的行数和返回行数的比值通常应该很小，介于1:1和1:10之间，当然有时也会很大（比如分组统计查询）。</li></ul><p>EXPLAIN的 Using where 表示MySQL将通过WHERE条件筛选存储引擎返回的记录，MySQL应用Where条件有三种方式，由好到坏依次是：</p><ol><li>在索引中使用WHERE条件来过滤不匹配的记录，在存储引擎层完成。</li><li>使用索引覆盖扫描（Extra列出现Using index）返回记录，直接从索引中过滤不需要的记录并返回命中的结果，在服务器层完成，但无需回表查询记录。</li><li>从数据表返回数据，过滤不满足条件的记录（Extra列出现Using where），在服务器层完成，需要先从数据表读出记录然后过滤。</li></ol><p>扫描行数远远大于返回行数，需要优化：</p><ul><li>使用索引覆盖扫描。</li><li>改变库表结构，如使用单独的汇总表。</li><li>重写复杂查询，让MySQL优化器可以以更优化的方式执行。</li></ul><h3 id="2-3-重构查询的方式"><a href="#2-3-重构查询的方式" class="headerlink" title="2.3 重构查询的方式"></a>2.3 重构查询的方式</h3><h4 id="2-3-1-判断一个复杂查询还是多个简单查询"><a href="#2-3-1-判断一个复杂查询还是多个简单查询" class="headerlink" title="2.3.1 判断一个复杂查询还是多个简单查询"></a>2.3.1 判断一个复杂查询还是多个简单查询</h4><p>设计查询时需要考虑的一个问题是：是否需要将一个复杂查询拆分为多个简单查询？我们普遍会选择让数据库尽可能的完成更多的工作，因为下意识会认为网络通信、查询解析和优化是一件代价很高的事情。</p><p>但对于MySQL来说，这种常识是不准确的：</p><ol><li>MySQL的连接和断开都很轻量；</li><li>现代网络速度越来越快，无论是带宽还是延迟；</li><li>MySQL每秒能在内存扫描上百万行数据，相比下响应数据给客户端要慢很多，其他条件不变的情况下越少查询是更好；</li><li>一些情况下切为小查询能减少工作量，并且能够带来整体性能的提升，小事务经常能更高效，并且若中间暂停一段时间，也可以把一次性的压力分散到大的时间段，降低对服务器的影响和锁的持有时间。</li></ol><h4 id="2-3-2-切分查询"><a href="#2-3-2-切分查询" class="headerlink" title="2.3.2 切分查询"></a>2.3.2 切分查询</h4><p>最常见的案例，比如要<strong>定期清除大量数据</strong>，如果一个语句一次完成可能会锁住很多数据、占满整个事务日志、消耗过多系统资源、阻塞很多小但重要的查询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一万行删除一次</span></span><br><span class="line">rows_affected = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">rows_affected = do_query(<span class="string">"DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-分解关联查询"><a href="#2-3-3-分解关联查询" class="headerlink" title="2.3.3 分解关联查询"></a>2.3.3 分解关联查询</h4><p><strong>对每个表进行一次单表查询，在应用层对结果进行关联</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--关联查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post</span><br><span class="line"><span class="keyword">ON</span> tag_post.tag_id = tag.tag_id</span><br><span class="line"><span class="keyword">JOIN</span> post</span><br><span class="line"><span class="keyword">ON</span> tag_post.post_id = post.post_id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="comment">--分解为三次单表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post_id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>让缓存效率更高，单表结果方便进行缓存，已缓存的数据下次就可以跳过；关联的表发生变化会使MySQL查询缓存失效；</li><li>查询分解后可以减少锁的竞争；</li><li>应用层做关联更容易对数据库进行拆分，方便高性能和可扩展；</li><li>查询效率本身也有提升，上述例子使用 <code>IN()</code> 代替关联查询可以使MySQL按照ID顺序查询，要比随机关联高效。</li><li>减少冗余记录的查询，在应用层做关联意味着某条记录只需查询一次，而在数据库关联查询可能需要重复的访问一部分数据。</li></ul><p>适用场景：</p><ul><li>应用方便缓存单个查询的结果时；</li><li>可以将数据分布到不同的MySQL服务器时；</li><li>能够使用 <code>IN()</code> 代替关联查询时；</li><li>当查询中使用同一个数据表时。</li></ul><h2 id="三-查询执行的基础"><a href="#三-查询执行的基础" class="headerlink" title="三. 查询执行的基础"></a>三. 查询执行的基础</h2><h3 id="3-1-一个查询在MySQL中的执行过程"><a href="#3-1-一个查询在MySQL中的执行过程" class="headerlink" title="3.1 一个查询在MySQL中的执行过程"></a>3.1 一个查询在MySQL中的执行过程</h3><p>MySQL执行一个查询的过程：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280108.png" alt></p><ol><li>客户端发送一条查询给服务器。</li><li>服务器先检查缓存，若命中缓存就立即返回结果。否则进入下一步。</li><li>服务器进行SQL解析、预处理，再由优化器生成对应的执行计划。</li><li>根据执行计划调用存储引擎的API来执行查询。</li><li>将结果返回客户端。</li></ol><h3 id="3-2-MySQL-客户端-服务器通信协议"><a href="#3-2-MySQL-客户端-服务器通信协议" class="headerlink" title="3.2 MySQL 客户端 / 服务器通信协议"></a>3.2 MySQL 客户端 / 服务器通信协议</h3><p>MySQL 客户端 / 服务器通信协议是<strong>半双工协议</strong>，即要么服务器向客户端发送数据、要么客户端向服务器发送数据，两个动作不能同时发生。</p><p>优点是通信简单快速，缺点是无法进行流量控制。一方一旦开始发送消息，另一方只能接收完整消息后才能进行响应。一方不能使另一方停止，MySQL一般要等所有数据都发送给客户端后才能释放查询所占用的资源，所以客户端缓存数据可以减轻服务器压力，让查询尽快结束早点释放资源。</p><p>查看MySQL连接/线程的状态：<code>SHOW FULL PROCESSLIST</code> </p><ul><li>Sleep：线程正在等待客户端发送新的请求。</li><li>Query：线程正在执行查询或正在将结果发送给客户端。</li><li>Locked：在MySQL服务器层，该线程正在等待表锁；存储引擎级别的锁（如行锁）不会体现在线程状态。</li><li>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li><li>Copying to tmp table [on disk]：线程正在执行查询，并将结果集都复制到一个临时表中，一般是在做GROUP BY操作、文件排序、UNION操作等；on disk表示正在将一个内存表放到磁盘。</li><li>Sorting result：线程正在对结果集进行排序。</li><li>Sending data：线程可能在多个状态间传送数据、或者生成结果集、或者在向客户端返回数据。</li></ul><h3 id="3-3-查询优化处理"><a href="#3-3-查询优化处理" class="headerlink" title="3.3 查询优化处理"></a>3.3 查询优化处理</h3><p>查询的生命周期中下一步是<strong>将一个SQL转换为一个执行计划</strong>，MySQL按照执行计划和存储引擎交互：</p><ul><li><strong>解析SQL</strong>：MySQL通过关键字将SQL语句进行解析，生成一棵解析树，通过MySQL语法规则进行验证和解析查询（如关键字是否正确、顺序是否正确、引号前后是否匹配）。</li><li><strong>预处理</strong>：根据一些MySQL规则进一步检查解析树是否合法（数据表和列是否存在、名字或别名是否有歧义），验证权限。</li><li><strong>优化SQL执行计划</strong></li></ul><p><strong>查询优化器</strong>：MySQL使用基于成本的优化器，预测一个查询使用某种执行计划时的成本并选择最小的一个。</p><p>导致优化器选择错误执行计划的原因：</p><ul><li>统计信息不准确，评估成本依赖存储引擎提供的统计信息，有时信息的偏差会很大，如MVCC架构并不维护数据表行数的精确统计。</li><li>执行计划的成本估算并不等价于实际执行的成本，如读取的页面可能在内存或磁盘，具体要多少次物理I/O无法得知。</li><li>MySQL的最优并不一定是最快的执行方式，只是基于成本模型的最优计划。</li><li>MySQL并不考虑其他并发执行的查询。</li><li>MySQL并不考虑不受控制的操作的成本，如存储过程或自定义函数。</li><li>有些特殊情况并不基于成本选择优化，如全文搜索的 <code>MATCH()</code> 子句，存在全文索引就会使用，即使有时别的索引和WHERE条件会更快。</li></ul><p>优化器的优化策略：</p><ul><li>静态优化：直接对解析树进行分析，并完成优化。</li><li>动态优化：与查询的上下文或其他因素有关，如WHERE条件取值、索引中条目对应的数据行数等，需要每次查询时重新评估。</li></ul><p>能够优化的类型：</p><ul><li>重新定义关联表的顺序</li><li>将外连接转化为内连接</li><li>使用等价变换规则</li><li>优化 <code>COUNT()</code> 、<code>MIN()</code> 和 <code>MAX()</code> ，找到某一列最小值只需查询对应B-Tree索引最左端的记录，使用此类优化在EXPLAIN中会出现 <code>Select tables optimized away</code> 表示优化器从执行计划中移除该表，用一个常数取代。</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表 <code>IN()</code> 的比较</li></ul><h3 id="3-4-MySQL如何执行关联查询"><a href="#3-4-MySQL如何执行关联查询" class="headerlink" title="3.4 MySQL如何执行关联查询"></a>3.4 MySQL如何执行关联查询</h3><h4 id="3-4-1-MySQL中的关联查询"><a href="#3-4-1-MySQL中的关联查询" class="headerlink" title="3.4.1 MySQL中的关联查询"></a>3.4.1 MySQL中的关联查询</h4><p>MySQL中每个查询都是一次关联。比如对于UNION查询，MySQL先将一系列单个查询的结果放在一个临时表中，然后再重新读出临时表数据完成UNION查询。</p><p>MySQL中关联查询流程：</p><ul><li>MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去直到找到所有表中匹配的行为止。</li><li>然后根据各个表匹配的行，返回查询中需要的各个列。</li><li>MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行，返回到上一层关联表继续查找更多匹配的记录，依次迭代执行。</li></ul><p>关联操作1如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tab1.col1, tab2.col2</span><br><span class="line"><span class="keyword">FROM</span> tab1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tab2 <span class="keyword">USING</span>(col3)</span><br><span class="line"><span class="keyword">WHERE</span> tab1.col1 <span class="keyword">IN</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>伪代码如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030101.png" alt></p><p>关联操作2如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tab1.col1, tab2.col2</span><br><span class="line"><span class="keyword">FROM</span> tab1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> tab2 <span class="keyword">USING</span>(col3)</span><br><span class="line"><span class="keyword">WHERE</span> tab1.col1 <span class="keyword">IN</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>伪代码如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030102.png" alt></p><p>关联操作1的内连接使用泳道图表示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030103.png" alt></p><h4 id="3-4-2-执行计划"><a href="#3-4-2-执行计划" class="headerlink" title="3.4.2 执行计划"></a>3.4.2 执行计划</h4><p>MySQL并不像其他关系型数据库那样生成查询字节码来执行查询，而是<strong>生成查询的一棵指令树</strong>，最终的执行计划包含了重构查询的全部信息。</p><p>对某个查询执行 <code>EXPLAIN EXTENDED</code> ，然后再执行 <code>SHOW WARNINGS</code> 可以看到重构出的查询。</p><p>任意多表查询都可以使用一棵树表示，如下图为一个四表关联操作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030104.png" alt></p><p>上图这种平衡树并非MySQL执行查询的方式，MySQL总是从一个表开始嵌套循环、回溯完成所有表关联，所以是下图这种<strong>左侧深度优先树</strong>：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030105.png" alt></p><h4 id="3-4-3-关联查询优化器"><a href="#3-4-3-关联查询优化器" class="headerlink" title="3.4.3 关联查询优化器"></a>3.4.3 关联查询优化器</h4><p>关联查询优化是优化器最重要的部分，决定多个表关联的顺序。优化器通过评估不同顺序的成本选择一个代价最小的关联顺序。</p><p>有时优化器选择的并非一定是最优顺序，此时可以使用 <code>STRAIGHT_JOIN</code> 关键字重写查询，让优化器按指定顺序执行，绝大部分情况优化器的判断要比开发者精准。</p><p>优化器如何计算成本：</p><ul><li>一般会遍历每个表逐个做嵌套循环计算每一棵执行计划树的成本。</li><li>但如果有超过N个表关联，需要检查N的阶乘种关联顺序；比如N=10时就有3628800种关联顺序，过多的可能导致优化器不可能逐一评估每种顺序的成本；</li><li>当搜索空间特别大时，优化器选择贪婪搜索方式，而非逐个评估。</li></ul><h3 id="3-5-排序优化"><a href="#3-5-排序优化" class="headerlink" title="3.5 排序优化"></a>3.5 排序优化</h3><ul><li>无论怎样，排序都是一个成本很高的操作，在不能使用索引排序时，数据量小的排序会在内存中进行，数据量大时需要使用磁盘；</li><li>判断条件是需要排序的数据量是否小于<strong>排序缓冲区</strong>；</li><li>内存中直接使用快速排序；内存不够排序，先将数据分块，每个块进行快速排序，结果存放在磁盘，然后将排好序的各个块合并，并返回最终结果。</li><li>在关联查询时如果需要排序，MySQL分两种情况来处理：<ul><li>ORDER BY 子句中所有列都来自于关联的第一个表，MySQL在处理第一个表时就进行文件排序，这种情况EXPLAIN 的 Extra 字段会有 <code>Using filesort</code> ；</li><li>其他情况下，MySQL都会将关联的结果放到一个临时表中，然后在所有的关联结束后再进行文件排序，这种情况EXPLAIN 的 Extra 字段会有 <code>Using temporary; Using filesort</code> ；查询中有LIMIT会在排序后应用，MySQL 5.6 版本后，当只需返回部分排序结果时不会对所有结果进行排序。</li></ul></li></ul><h2 id="四-查询优化器"><a href="#四-查询优化器" class="headerlink" title="四. 查询优化器"></a>四. 查询优化器</h2><h3 id="4-1-查询优化器的局限性"><a href="#4-1-查询优化器的局限性" class="headerlink" title="4.1 查询优化器的局限性"></a>4.1 查询优化器的局限性</h3><h4 id="4-1-1-关联子查询"><a href="#4-1-1-关联子查询" class="headerlink" title="4.1.1 关联子查询"></a>4.1.1 关联子查询</h4><p>MySQL子查询十分糟糕，特别是WHERE条件包含 <code>IN()</code> 的子查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id = <span class="number">1</span>);</span><br><span class="line"><span class="comment">--MySQL会先执行子查询，返回所有actor_id = 1的film_id，所以我们会认为会如下执行：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span>(XXX, XXX, ......, XXX);</span><br><span class="line"><span class="comment">--但实际上，MySQL会将外层表压到子查询中，因为它认为这样可以更快的找到数据行：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film.film_id = film_actor.film_id);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030106.png" alt></p><p>MySQL选择先对file表进行全表扫描，根据返回的film_id逐个执行子查询，当数据量大时这种执行性能会很糟糕，所以我们可以改写查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用内连接代替IN子查询：</span></span><br><span class="line"><span class="keyword">SELECT</span> film.* <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">--使用函数GROUP_CONCAT拼接一个逗号分隔的列表：</span></span><br><span class="line">（省略）</span><br></pre></td></tr></table></figure><h4 id="4-1-2-UNION取LIMIT时内外层优化"><a href="#4-1-2-UNION取LIMIT时内外层优化" class="headerlink" title="4.1.2 UNION取LIMIT时内外层优化"></a>4.1.2 UNION取LIMIT时内外层优化</h4><p>有时我们希望对UNION的结果集只获取前N条记录，可以在每个子句中添加LIMIT，为了保证获取正确的顺序，需要在外层再增加一个全局的 ORDER BY 和 LIMIT 操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a)</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">20</span></span><br><span class="line"><span class="comment">-- 改写为</span></span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">20</span>)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">20</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-索引合并优化"><a href="#4-1-3-索引合并优化" class="headerlink" title="4.1.3 索引合并优化"></a>4.1.3 索引合并优化</h4><p>WHERE子句包含多个复杂条件时，MySQL可以访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</p><h4 id="4-1-4-等值传递"><a href="#4-1-4-等值传递" class="headerlink" title="4.1.4 等值传递"></a>4.1.4 等值传递</h4><p>如一个非常大的 <code>IN()</code> 列表，优化器发现有WHERE、ON或USING的子句，将这个列表的值和另外一个表的某个列关联。优化器会将列表都复制应用到关联的各个表中，列表特别大会导致无法高效的从表中过滤记录。</p><h4 id="4-1-5-并行执行"><a href="#4-1-5-并行执行" class="headerlink" title="4.1.5 并行执行"></a>4.1.5 并行执行</h4><p>MySQL无法利用多核来并行执行查询。</p><h4 id="4-1-6-哈希关联"><a href="#4-1-6-哈希关联" class="headerlink" title="4.1.6 哈希关联"></a>4.1.6 哈希关联</h4><p>MySQL只支持嵌套循环关联，只能通过建立哈希索引来变相的实现哈希关联</p><h4 id="4-1-7-松散索引扫描"><a href="#4-1-7-松散索引扫描" class="headerlink" title="4.1.7 松散索引扫描"></a>4.1.7 松散索引扫描</h4><p>MySQL不支持松散索引扫描，无法按照不连续的方式扫描一个索引。假设有索引 <code>(A,B)</code> 查询 <code>SELECT ... FROM TB WHERE B BETWEEN 2 AND 3</code> 因为索引前导字段是A，但查询只指定了B，所以无法使用索引，只能全表扫描。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210101.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210102.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210103.png" alt></p><h4 id="4-1-8-最大值和最小值优化"><a href="#4-1-8-最大值和最小值优化" class="headerlink" title="4.1.8 最大值和最小值优化"></a>4.1.8 最大值和最小值优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(actor_id) <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> first_name = <span class="string">'XX'</span>;</span><br><span class="line"><span class="comment">--因为first_name并没有索引，所以MySQL会进行一次全表扫描，通过SHOW STATUS确认</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ...;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="comment">--优化：使用LIMIT重写</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">USE</span> <span class="keyword">INDEX</span>(PRIMARY) <span class="keyword">WHERE</span> first_name = <span class="string">'XX'</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-查询优化器的提示"><a href="#4-2-查询优化器的提示" class="headerlink" title="4.2 查询优化器的提示"></a>4.2 查询优化器的提示</h3><p>暂略。</p><h3 id="4-3-优化特定类型的查询"><a href="#4-3-优化特定类型的查询" class="headerlink" title="4.3 优化特定类型的查询"></a>4.3 优化特定类型的查询</h3><h4 id="4-3-1-优化COUNT"><a href="#4-3-1-优化COUNT" class="headerlink" title="4.3.1 优化COUNT()"></a>4.3.1 优化COUNT()</h4><p>COUNT(*) 统计结果集的行数，COUNT(row) 统计某个列值的数量，二者含义不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--一个查询统计不同颜色</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">IF</span>(color = <span class="string">'blue'</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">AS</span> blue, <span class="keyword">SUM</span>(<span class="keyword">IF</span>(color = <span class="string">'red'</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(color = <span class="string">'blue'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> blue, <span class="keyword">COUNT</span>(color = <span class="string">'red'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br></pre></td></tr></table></figure><p>不需要精确值时可以使用近似值代替，比如EXPLAIN的估算行数。</p><p>COUNT() 一般都需要扫描大量的数据行才能获得精确的结果，只能加索引覆盖扫描，如果这样还不能解决性能问题，只能考虑修改应用的架构，比如增加汇总表 / 缓存系统等。</p><h4 id="4-3-2-优化关联查询"><a href="#4-3-2-优化关联查询" class="headerlink" title="4.3.2 优化关联查询"></a>4.3.2 优化关联查询</h4><ul><li>确保ON或USING子句的列上有索引，创建索引时要考虑关联的顺序，当表A和B用列c关联，若优化器的关联顺序的B、A，那么B表就不需要创建索引，<strong>一般关联只需在关联顺序的第二张表对应列上创建索引</strong>。</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li><li>升级MySQL时注意关联语法、运算符优先级等其他可能会发生变化的地方，普通关联可能会变成笛卡尔积，不同类型的关联可能会生成不同的结果。</li></ul><h4 id="4-3-3-优化子查询"><a href="#4-3-3-优化子查询" class="headerlink" title="4.3.3 优化子查询"></a>4.3.3 优化子查询</h4><p>尽可能用关联查询代替子查询。</p><h4 id="4-3-4-优化GROUP-BY和DISTINCT"><a href="#4-3-4-优化GROUP-BY和DISTINCT" class="headerlink" title="4.3.4 优化GROUP BY和DISTINCT"></a>4.3.4 优化GROUP BY和DISTINCT</h4><p>MySQL优化器会在内部处理时相互转换这两类查询，使用索引来优化；若索引无法使用，GROUP BY 会使用<strong>临时表</strong>或<strong>文件排序</strong>来做分组。</p><p>对关联查询做分组，并且按照查找表中的某个列进行分组，采用查找表的标识列效率会较高：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--效率差</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name,actor.last_name, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.first_name,actor.last_name</span><br><span class="line"><span class="comment">--效率高</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name,actor.last_name, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id</span><br><span class="line"><span class="comment">--这种写法只是在姓名和actor_id直接关联的情况下可以这样用，且有一些问题</span></span><br></pre></td></tr></table></figure><h4 id="4-3-5-优化LIMIT分页"><a href="#4-3-5-优化LIMIT分页" class="headerlink" title="4.3.5 优化LIMIT分页"></a>4.3.5 优化LIMIT分页</h4><p>分页操作：使用LIMIT加偏移量实现，加上合适的ORDER BY子句。</p><p>偏移量非常大时，比如 LIMIT 10000,20 只返回20条数据抛弃前面10000条记录。优化要么在页面中限制分页的数量，要么优化大偏移量的性能。</p><ul><li><p><strong>延迟关联</strong>：最简单就是使用索引覆盖扫描，而不是返回所有列。然后根据需要再做一次关联操作返回所有列，这种改法对于偏移量大的情况效率提升比较高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>;</span><br><span class="line"><span class="comment">--优化为：</span></span><br><span class="line"><span class="keyword">SELECT</span> film.film_id, film.description </span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span>(<span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>) <span class="keyword">AS</span> lim <span class="keyword">USING</span>(film_id)</span><br></pre></td></tr></table></figure></li><li><p>LIMIT可以转换为已知位置的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--上述查询可改为：</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, description </span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">position</span> <span class="keyword">BETWEEN</span> <span class="number">50</span> <span class="keyword">TO</span> <span class="number">54</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">position</span>;</span><br></pre></td></tr></table></figure></li><li><p>LIMIT查询主要问题是OFFSET会导致MySQL扫描大量不需要的行并且丢弃掉，可以记录上次取数据的位置，下次直接从该位置开始扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--第一次查询，返回主键为16049到16030的租借记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">--下次查询直接从16030开始</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">WHERE</span> rental_id &lt; <span class="number">16030</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-6-优化-SQL-CALC-FOUND-ROWS"><a href="#4-3-6-优化-SQL-CALC-FOUND-ROWS" class="headerlink" title="4.3.6 优化 SQL_CALC_FOUND_ROWS"></a>4.3.6 优化 SQL_CALC_FOUND_ROWS</h4><p>分页的一个常用技巧是<strong>在LIMIT语句中加上SQL_CALC_FOUND_ROWS提示</strong>，从而获得去掉LIMIT以后满足条件的行数，作为分页的总数，好像是MySQL预测到了总行数，但实际上MySQL需要扫描扫描所有满足条件的行来得到行数。</p><p>所以添加此提示后，不管是否需要，MySQL都会扫描所有满足条件的行，而不是满足LIMIT的行数后就终止扫描。</p><h4 id="4-3-7-优化-UNION-查询"><a href="#4-3-7-优化-UNION-查询" class="headerlink" title="4.3.7 优化 UNION 查询"></a>4.3.7 优化 UNION 查询</h4><p>MySQL总是会通过创建并填充临时表的方式来执行 UNION 查询，所以导致很多优化策略受限（经常要手工将WHERE，LIMIT，ORDER BY放到UNION子查询中以便优化器优化）。</p><p>除非必须要服务器消除重复的行，否则一定要使用UNION ALL，没有ALL时MySQL会给临时表增加DISTINCT选项，这会导致整个临时表做唯一性检查，这样的代价非常高。</p><h4 id="4-3-8-静态查询分析"><a href="#4-3-8-静态查询分析" class="headerlink" title="4.3.8 静态查询分析"></a>4.3.8 静态查询分析</h4><p>Percona Toolkit中的pt-query-advisor能够解析查询日志，分析查询模式，给出所有可能存在潜在问题的查询，并给出足够详细的建议。</p><h4 id="4-3-9-使用用户自定义变量"><a href="#4-3-9-使用用户自定义变量" class="headerlink" title="4.3.9 使用用户自定义变量"></a>4.3.9 使用用户自定义变量</h4><p>暂略。</p><h3 id="4-4-案例"><a href="#4-4-案例" class="headerlink" title="4.4 案例"></a>4.4 案例</h3><h3 id="4-4-1-构建一个队列表"><a href="#4-4-1-构建一个队列表" class="headerlink" title="4.4.1 构建一个队列表"></a>4.4.1 构建一个队列表</h3><ul><li><p>一个表包含多种类型的记录：未处理的记录、已处理记录、正在处理记录。</p></li><li><p>一个或多个消费者线程在表中查找未处理的记录，然后标记为正在处理，处理完成后再更新为已处理状态。</p></li><li><p>不合理的地方：</p><ul><li>随着队列表越来越大和索引深度的增加，找到未处理记录的速度越来越慢；可以将队列表拆分为已处理和未处理两部分来优化。</li><li>处理过程一般包括两步：找到未处理记录，然后加锁。前者增加服务器压力，加锁则让各个消费者线程增加竞争。</li></ul></li><li><p>如何让消费者标记正在处理的记录，而不使多个消费者重复处理同一记录？</p><ul><li><p>任何情况都应避免使用 SELECT FOR UPDATE ，会导致大量事务阻塞并等待；</p></li><li><p>用一个属性列标识正在处理记录的连接ID。</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">--查找未有线程处理且状态为待发送的记录ID</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span> unsent_emails</span><br><span class="line"><span class="keyword">WHERE</span> owner = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'unsent'</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">--result：123，456，789</span></span><br><span class="line"><span class="comment">--更新这些记录状态，并且将连接ID写入owner</span></span><br><span class="line"><span class="keyword">UPDATE</span> unsent_emails</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>, owner = CONNECTION_ID()</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span>(<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>上述SELECT走了索引，但FOR UPDATE锁会使其他查询阻塞，可以改进如下（无需用SELECT查询哪些记录还未被处理，可以用来改写所有的SELECT FOR UPDATE）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">UPDATE</span> unsent_emails</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>, owner = CONNECTION_ID()</span><br><span class="line"><span class="keyword">WHERE</span> owner = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'unsent'</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span> unsent_emails</span><br><span class="line"><span class="keyword">WHERE</span> owner = CONNECTION_ID()</span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>;</span><br><span class="line"><span class="comment">--result：123，456，789</span></span><br><span class="line"><span class="comment">--更新这些记录状态，并且将连接ID写入owner</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>基础原则：</p><ul><li>除非不得已，否则不要使用轮询。</li><li>尽量用UPDATE代替 SELECT FOR UPDATE，事务提交越快，持有锁的时间就越短，可以大大减少竞争和加速串行执行效率。</li><li>将已经处理完成和未处理数据分开，保证数据集足够小。</li><li>无法优化的查询尝试用不同策略来实现相同目的。</li><li>任务队列最好能从数据库移除，使用Redis、memcached、Q4M引擎等方案。</li></ul></li></ul><h3 id="4-4-2-计算两点之间的距离"><a href="#4-4-2-计算两点之间的距离" class="headerlink" title="4.4.2 计算两点之间的距离"></a>4.4.2 计算两点之间的距离</h3><p>感觉不是常用的场景，暂略。</p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：为什么查询速度会慢，优化数据访问，查询执行的基础，查询优化器等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（四）创建高性能索引</title>
    <link href="http://linyishui.top/2020122501.html"/>
    <id>http://linyishui.top/2020122501.html</id>
    <published>2020-12-25T12:14:26.000Z</published>
    <updated>2020-12-29T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（四）创建高性能索引"><a href="#《高性能MySQL》（四）创建高性能索引" class="headerlink" title="《高性能MySQL》（四）创建高性能索引"></a>《高性能MySQL》（四）创建高性能索引</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是索引？"><a href="#1-1-什么是索引？" class="headerlink" title="1.1 什么是索引？"></a>1.1 什么是索引？</h3><p>索引就像是书的目录，在MySQL中，存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> actor_id = <span class="number">5</span>;</span><br><span class="line"><span class="comment">--若actor_id列上有创建索引，MySQL先在索引上按值查找，然后返回所有包含值得数据行</span></span><br></pre></td></tr></table></figure><p><strong>MySQL只能高效的使用索引的最左前缀列，索引中列的顺序很重要</strong>。</p><h3 id="1-2-索引的类型"><a href="#1-2-索引的类型" class="headerlink" title="1.2 索引的类型"></a>1.2 索引的类型</h3><h4 id="1-2-1-B-Tree-索引"><a href="#1-2-1-B-Tree-索引" class="headerlink" title="1.2.1 B-Tree 索引"></a>1.2.1 B-Tree 索引</h4><p>虽然叫B-Tree索引，但存储引擎可能使用不同的存储结构，比如InnoDB使用的是 B+Tree、NDB集群使用的是 T-Tree 。MyISAM使用前缀压缩技术使得索引更小，InnoDB则按原数据格式存储；MyISAM索引通过数据的物理位置引用被索引的行，InnoDB则根据主键引用被索引的行。</p><p>B-Tree索引中所有值按顺序存储，每个叶子页到根的距离相同：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280101.png" alt></p><p>存储引擎从索引的根节点开始搜索，根节点的槽中存放了指向子节点的指针，通过指针向下层查找，通过比较节点页和要查找的值大小可以找到合适的指针到下一个子节点。叶子节点的指针指向被索引的数据。这种顺序存储很适合范围查询。</p><p>对于People表有索引包含last_name、first_name和dob，索引结构如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280102.png" alt></p><p>B-Tree 索引适用于<strong>全键值、键值范围或键前缀查找</strong>，键前缀查找只适用最左前缀：</p><ul><li><strong>全值匹配</strong>：和索引中所有列匹配，如查询叫 Cuba Allen、出生于XXX年的人。</li><li><strong>匹配最左前缀</strong>：只匹配索引第一列，如查询所有姓Allen的人。</li><li><strong>匹配列前缀</strong>：只匹配列值的开头部分，如查询所有J开头姓的人。</li><li><strong>匹配范围值</strong>：匹配列值得某个范围，如查询所有姓Allen与Barry之间的人。</li><li><strong>精确匹配某一列并范围匹配另外一列</strong>：第一列全匹配，第二列范围匹配，如查询所有姓Allen，名以K开头的人。</li><li><strong>只访问索引的查询</strong>：即查询只需访问索引，无须访问数据行，即<strong>覆盖索引</strong>。</li></ul><p>B-Tree索引支持的查询同样可以支持 ORDER BY 操作。</p><p>限制：</p><ul><li>非最左列开始无法命中索引；</li><li>不能跳过索引中的列；</li><li>查询中若有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ul><p>即从左到右依次扫描索引列，到遇到第一个范围查询（&gt;=, &gt;,&lt;, &lt;=, between ….. and ….）就停止扫描。</p><h4 id="1-2-2-哈希索引"><a href="#1-2-2-哈希索引" class="headerlink" title="1.2.2 哈希索引"></a>1.2.2 哈希索引</h4><ul><li>Memory和NDB存储引擎支持，基于哈希表实现，只有精确匹配索引所有列的查询才有效。</li><li>InnoDB有一个特殊的自适应哈希索引，在某些索引值使用非常频繁时，会在内存中基于B-Tree索引再创建一个哈希索引，从而加快查找速度。</li><li>每行数据会计算得到一个哈希码，存放在哈希索引中，同时在哈希表中保存指向每个数据行的指针。</li><li>哈希索引只包含哈希值和行指针，不存储字段值，所以不能像B-Tree索引那样避免读取行，但一般读行速度很快。</li><li>不按索引值顺序存储，无法用于排序。</li><li>不支持部分索引列匹配查找。</li><li>只支持等值比较查询，不支持任何范围查询。</li><li>哈希冲突需要遍历链表所有行指针，所以会影响性能。</li></ul><h4 id="1-2-3-空间数据索引（R-Tree）"><a href="#1-2-3-空间数据索引（R-Tree）" class="headerlink" title="1.2.3 空间数据索引（R-Tree）"></a>1.2.3 空间数据索引（R-Tree）</h4><ul><li>MyISAM支持空间索引，用来存储地理位置。</li></ul><h4 id="1-2-4-全文索引"><a href="#1-2-4-全文索引" class="headerlink" title="1.2.4 全文索引"></a>1.2.4 全文索引</h4><ul><li>全文索引类似于搜索引擎，查找的是文本中的关键词，而不是直接比较索引的值。</li><li>适用于 MATCH AGAINST 操作，而不是普通的 WHERE 条件操作。</li></ul><h3 id="1-3-索引的优点"><a href="#1-3-索引的优点" class="headerlink" title="1.3 索引的优点"></a>1.3 索引的优点</h3><ul><li>提高查询效率。</li><li>避免排序和临时表：B-Tree索引可以用于 ORDER BY 和 GROUP BY 操作。</li><li>减少了需要扫描的数据量：某些情况只使用索引就可以完成查询。</li><li>将随机I/O变为顺序I/O。</li></ul><p>索引非银弹，只有在索引能大大提高查询的效率，大于其带来的额外工作时，才是有效的，对于特别小的表全表查询可能会更高效，而特别大的表创建和使用索引的代价可能过于高昂。</p><h2 id="二-高性能索引策略"><a href="#二-高性能索引策略" class="headerlink" title="二. 高性能索引策略"></a>二. 高性能索引策略</h2><h3 id="2-1-独立的列"><a href="#2-1-独立的列" class="headerlink" title="2.1 独立的列"></a>2.1 独立的列</h3><p><strong>索引列不能是表达式的一部分，也不能是函数的参数</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> <span class="keyword">TO_DAYS</span>(<span class="keyword">CURRENT_DATE</span>) - <span class="keyword">TO_DAYS</span>(date_col) &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-前缀索引和索引选择性"><a href="#2-2-前缀索引和索引选择性" class="headerlink" title="2.2 前缀索引和索引选择性"></a>2.2 前缀索引和索引选择性</h3><p>当需要索引很长的字符列时（特别是BLOB、TEXT或很长的VARCHAR只能使用前缀索引），可以选择模拟哈希索引，也可以只索引开始的部分字符。</p><p>我们需要选择足够长的前缀保证有较高的选择性，可以通过真实数据统计前缀长度为多少时最合适。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建前缀索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">ADD</span> <span class="keyword">KEY</span> (city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure><p>前缀索引无法用于 ORDER BY 和 GROUP BY，也无法做覆盖扫描。</p><h3 id="2-3-多列索引"><a href="#2-3-多列索引" class="headerlink" title="2.3 多列索引"></a>2.3 多列索引</h3><p>为多列的每个列创建单独的索引一般不能提高查询性能，最好情况下也可能与最优索引的效率差几个数量级。</p><p>在EXPLAIN中看到索引合并（index_merge）大部分情况说明索引构建的很糟糕，有时甚至不如直接改写为UNION的方式。</p><h3 id="2-4-选择合适的索引列顺序"><a href="#2-4-选择合适的索引列顺序" class="headerlink" title="2.4 选择合适的索引列顺序"></a>2.4 选择合适的索引列顺序</h3><p>一个多列的B-Tree索引会按照最左列排序，然后是第二列、第三列等等。<strong>在不考虑排序和分组时，将选择性最高的列（根据条件命中条数最少）放到索引的最前列</strong>。</p><p>案例：</p><ol><li><p>慢查询SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> threadId) <span class="keyword">AS</span> COUNT_VALUE</span><br><span class="line"><span class="keyword">FROM</span> Message</span><br><span class="line"><span class="keyword">WHERE</span> (groupId = <span class="number">10137</span>) <span class="keyword">AND</span> (userId = <span class="number">1288826</span>) <span class="keyword">AND</span> (anonymous = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">priority</span> <span class="keyword">DESC</span>, modifiedDate <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></li><li><p>执行计划：看似选择了索引 <code>(groupId, userId)</code> 很合理</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id：<span class="number">1</span></span><br><span class="line">select_type：SIMPLE</span><br><span class="line"><span class="keyword">table</span>：Message</span><br><span class="line"><span class="keyword">type</span>：<span class="keyword">ref</span></span><br><span class="line">key：ix_groupId_userId</span><br><span class="line">key_len：<span class="number">18</span></span><br><span class="line"><span class="keyword">ref</span>: <span class="keyword">const</span>,<span class="keyword">const</span></span><br><span class="line">rows：<span class="number">1251162</span></span><br><span class="line">Extra：Using where</span><br></pre></td></tr></table></figure></li><li><p>选择性分析：条件几乎命中所有行，即索引没起到什么用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),              <span class="comment">--4142217</span></span><br><span class="line">       <span class="keyword">SUM</span>(groupId = <span class="number">10137</span>),  <span class="comment">--4092654</span></span><br><span class="line">       <span class="keyword">SUM</span>(userId = <span class="number">1288826</span>), <span class="comment">--1288496</span></span><br><span class="line">       <span class="keyword">SUM</span>(anonymous = <span class="number">0</span>)     <span class="comment">--4141934</span></span><br><span class="line"><span class="keyword">FROM</span> Message</span><br></pre></td></tr></table></figure></li><li><p>解决方案是修改应用代码，区分这部分异常数据。</p></li></ol><h3 id="2-5-聚簇索引"><a href="#2-5-聚簇索引" class="headerlink" title="2.5 聚簇索引"></a>2.5 聚簇索引</h3><p>聚簇索引是一种数据存储方式，InnoDB的聚簇索引实际上在同一结构中保存了B-Tree索引和数据行。聚簇表示数据行和相邻的键值紧凑的存储在一起，当表存在聚簇索引时，其数据行实际存放在索引的叶子页（leaf page）中。</p><p>如下图，叶子页包含了行的全部数据，而节点页只包含索引列：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280103.png" alt></p><p>InnoDB通过主键聚集数据，若没有指定主键，InnoDB会选择一个唯一的非空索引代替，没有这样的索引则会隐式的定义一个主键来作为聚簇索引。InnoDB只聚集同一个页面的记录，非同一页即使相邻键值也可能相距甚远。</p><p>聚集的优点：</p><ul><li>将相关的数据保存在一起，减少磁盘I/O操作；</li><li>数据访问更快，因为索引和数据保存在同一个B-Tree。</li><li>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</li></ul><p>聚集的缺点：</p><ul><li>若数据存放在内存，访问顺序就没那么重要，聚簇索引对于I/O的提升就不明显了。</li><li>插入速度严重依赖于插入顺序，最快是按照主键顺序插入，若非此顺序最好加载完成后通过 OPTIMIZE TABLE 重新组织一下表。</li><li>更新聚簇索引的代价高昂，会强制InnoDB将每个被更新的行移动到新位置。</li><li>基于聚簇索引的表在插入新行、或主键更新导致需要移动行时，会面临页分裂问题。行需要插入到某个已满的页中，存储引擎要把页分裂成两个页来容纳新行。</li><li>可能导致全表扫描变慢，特别是行比较稀疏或页分裂导致数据存储不连续的时候。</li><li>二级索引（非聚簇索引）要比想象的大，因为叶子节点包含了引用行的主键列。</li><li>二级索引访问需要两次索引查找，而不是一次。因为二级索引叶子节点保存的不是行的物理位置，而是行的主键值。在找到二级索引获得主键值后，仍需要去聚簇索引找到对应的行。所以InnoDB引入自适应哈希索引减少这样的重复工作。</li></ul><p>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。若主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280104.png" alt></p><p>AUTO_INCREMENT 自增列保证数据行是按顺序写入，从性能考虑使用UUID作为聚簇索引会很糟糕，插入变得完全随机。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280105.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280106.png" alt></p><h3 id="2-6-覆盖索引"><a href="#2-6-覆盖索引" class="headerlink" title="2.6 覆盖索引"></a>2.6 覆盖索引</h3><p>设计索引时不仅仅要考虑WHERE条件部分，特别是能直接通过索引获取列数据的情况。<strong>如果一个索引包含所有需要查询的字段的值，可以被称为覆盖索引</strong>。只有B-Tree索引可以作为覆盖索引。在EXPLAIN的Extra对应 <code>Using index</code> 信息。</p><p>InnoDB的二级索引的叶子节点包含主键的值，所以即使本身没有包含主键，二级索引也可以额外用于对主键做覆盖查询。</p><p>优点：</p><ul><li>减少数据访问量；</li><li>索引至少在单个页内是按列值顺序存储的，所以范围查询相比随机读取的I/O少很多。</li><li>由于聚簇索引的原因，覆盖索引对InnoDB特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，若二级主键可以覆盖查询，就可以避免对主键索引的二次查询。</li></ul><p>全字段模糊查询优化：<strong>延迟关联</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> actor = <span class="string">'SEAN CARREY'</span></span><br><span class="line">                                 <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'%APOLLO%'</span>;</span><br><span class="line"><span class="comment">--type：ref</span></span><br><span class="line"><span class="comment">--possible_keys：ACTOR,IX_PROD_ACTOR</span></span><br><span class="line"><span class="comment">--key：ACTOR</span></span><br><span class="line"><span class="comment">--key_len：52</span></span><br><span class="line"><span class="comment">--Extra：Using where</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询选择了表的所有列，而没有索引覆盖了这么多列，但WHERE条件actor命中了索引，MySQL不能再索引中执行LIKE操作</span></span><br><span class="line"><span class="comment">--优化方案：创建索引(artist,title,prod_id)</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products </span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> prod_id <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> actor = <span class="string">'SEAN CARREY'</span></span><br><span class="line">                                     <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'%APOLLO%'</span>;) AS T1 ON (t1.prod_id=products.prod_id)</span><br><span class="line"><span class="comment">--1.select_type: PRIMARY</span></span><br><span class="line"><span class="comment">--2.select_type: PRIMARY</span></span><br><span class="line"><span class="comment">--3.select_type: DERIVED</span></span><br><span class="line"><span class="comment">--3.type: ref</span></span><br><span class="line"><span class="comment">--3.key: ACTOR_2</span></span><br><span class="line"><span class="comment">--3.Extra: Using where; Using index</span></span><br></pre></td></tr></table></figure><h3 id="2-7-使用索引扫描来做排序"><a href="#2-7-使用索引扫描来做排序" class="headerlink" title="2.7 使用索引扫描来做排序"></a>2.7 使用索引扫描来做排序</h3><p>两种方式生成有序结果：</p><ol><li>排序操作；</li><li>按索引顺序扫描。EXPLAIN得到type值为index。</li></ol><p>只扫描索引本身很快，但如果不能覆盖所有列，就需要回表查询一次，而回表查询基本是随机I/O，相比顺序地全表扫描要慢。</p><p>只有索引顺序和 ORDER BY 操作顺序一样时，才可以作为排序结果。</p><h3 id="2-8-压缩索引"><a href="#2-8-压缩索引" class="headerlink" title="2.8 压缩索引"></a>2.8 压缩索引</h3><p>MyISAM使用前缀压缩来减小索引的大小，比如索引块第一个值是“perform”，第二个值是“performance”，压缩后第二个值是“7,ance”，减少空间的代价是某些操作会更慢，因为前后的依赖性所以无法使用二分查找。</p><h3 id="2-9-冗余和重复索引"><a href="#2-9-冗余和重复索引" class="headerlink" title="2.9 冗余和重复索引"></a>2.9 冗余和重复索引</h3><ul><li><strong>产生冗余和重复索引的原因</strong>：<ul><li>MySQL允许在相同列上创建多个索引，但需要单独维护重复的索引，且优化器在优化查询时也要逐个考虑。</li><li>重复索引可能会因为一些失误构建出来，如若发现应移除。表中索引越多会导致INSERT、UPDATE、DELETE速度越慢</li></ul></li><li><strong>区分冗余索引</strong>：(A)是(A,B)的冗余索引，但(B,A)或(B)则不是冗余索引。尽量扩展旧索引而不是创建新索引，有时也会需要冗余索引，因为扩展已有索引可能会导致其变得太大，从而影响其他使用该索引的查询。</li><li><strong>如何找到冗余和重复索引</strong>：<ul><li>可以通过自己编写查询访问 INFORMATION_SCHEMA 表；</li><li>或是通过如 Shlomi Noach 的 common_schema 以及 Percona Tookit 的 pt-duplicate-key-checker 等工具找出冗余和重复的索引并删除。</li></ul></li></ul><h3 id="2-10-索引和锁"><a href="#2-10-索引和锁" class="headerlink" title="2.10 索引和锁"></a>2.10 索引和锁</h3><p>索引可以使查询锁定更少的行，InnoDB只有在访问行时才会对其加锁，索引可以减少访问的行数，需要存储引擎能够过滤掉不需要的行。</p><p>查询只返回2~4之间的行，但却获取了1到4之间行的排它锁，因为MySQL为查询选择的执行计划是索引范围扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id &lt; <span class="number">5</span></span><br><span class="line">  <span class="keyword">AND</span> actor_id &lt;&gt; <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>存储引擎从索引开头获取满足 <code>actor_id &lt; 5</code> 的记录，并不知道可以过滤第一行记录，<code>Using where</code> 表示MySQL服务器将存储引擎返回行以后再应用过滤条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id &lt; <span class="number">5</span></span><br><span class="line">  <span class="keyword">AND</span> actor_id &lt;&gt; <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">--type: range</span></span><br><span class="line"><span class="comment">--key: PRIMARY</span></span><br><span class="line"><span class="comment">--Extra: Using where; Using index</span></span><br></pre></td></tr></table></figure><p>此时保证第一个连接打开，再开启第二个连接查询第一行记录，此查询会被挂起：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排它锁（写锁），从而无法使用覆盖索引，使SELECT FOR UPDATE 比 LOCK IN SHARE MODE 或非锁定查询要慢很多。</p><h3 id="2-11-实用技巧"><a href="#2-11-实用技巧" class="headerlink" title="2.11 实用技巧"></a>2.11 实用技巧</h3><ul><li>实际创建索引时经常会将一些选择性不高但频繁使用的列作为索引前缀列，如性别SEX，即使某些查询不需要这些列作为查询条件，也可以加上 <code>SEX IN(&#39;m&#39;,&#39;f&#39;)</code> 来匹配索引（仅使用列表值不多时）。</li><li>一些常用于范围查询的列尽量放在组合索引的最后，比如日期、年纪等，因为匹配索引会在第一个范围查询终止，当然一些情况也可以用IN来代替范围查询。</li><li>通过执行 <code>OPTIMIZE TABLE</code> 或者导出再导入的方式重新整理数据，这样可以消除索引和数据的碎片化。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280107.png" alt></p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：索引概述，常见索引类型，索引优缺点，高性能索引策略包括前缀索引、组合索引、聚簇索引、覆盖索引等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（三）Schema与数据类型优化</title>
    <link href="http://linyishui.top/2020122001.html"/>
    <id>http://linyishui.top/2020122001.html</id>
    <published>2020-12-20T12:14:19.000Z</published>
    <updated>2020-12-29T12:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（三）Schema与数据类型优化"><a href="#《高性能MySQL》（三）Schema与数据类型优化" class="headerlink" title="《高性能MySQL》（三）Schema与数据类型优化"></a>《高性能MySQL》（三）Schema与数据类型优化</h1><h2 id="一-选择优化的数据类型"><a href="#一-选择优化的数据类型" class="headerlink" title="一. 选择优化的数据类型"></a>一. 选择优化的数据类型</h2><ul><li>尽量使用能正确存储数据的最小数据类型；</li><li>整型比字符串操作代价更低，字符比较的字符集和校对规则更复杂，如时间等应该用数字存储；</li><li>尽量避免NULL，可为NULL的列需要更多的空间，索引构建更复杂，所以需要创建索引的列尽量是NOT NULL；</li><li>相同类型的数据，但长度范围不同、精度不同、需要的物理空间也不同，例如 DATETIME 和 TIMESTAMP 都存储时间和日期，精确到秒，TIMESTAMP只会用DATETIME一半的空间</li><li>MySQL的数字类型分整数类型和实数类型，其中 DECIMAL 支持高精度计算，如 DECIMAL(18, 9) 小数点两边将各存9个数字，小数点占一个字节，总共占9个字节。内部浮点计算统一使用 DOUBLE ，DECIMAL 只是存储类型。DECIMAL 会需要额外的空间和计算开销</li><li>字符串类型：<ul><li>VARCHAR：可变长字符串，仅使用必要空间（除非ROW_FORMAT=FIXED），使用一个或两个字节存储字符串长度。没有银弹，节省空间的带来的是UPDATE需要额外的开销（页已满InnoDB会分裂页使新行可以放入页内）</li><li>CHAR：定长字符串，根据定义的长度分配足够的空间。适合存储定长或经常修改的字符串，因为定长类型不容易产生碎片；短列如CHAR(1)只需一个字节，而VARCHAR(2)需要两个字节，一个字节存放长度。</li></ul></li><li>BLOB和TEXT：分别采用二进制和字符串存储较大数据。<ul><li>不同类型家族：TINYBLOB、SMALLBLOB / BLOB、MEDIUMBLOB、LONGBLOB 和 TINYTEXT、SMALLTEXT / TEXT、MEDIUMTEXT、LONGTEXT</li><li>当数据较大时，MySQL会使用外部区域存放值，行内需要为每个值放1~4个字节的指针。</li><li>排序时只会对前 <code>max_sort_length</code> 个字节排序，也可以使用 <code>ORDER BY SUSTRING(column, length)</code> 。</li></ul></li><li>日期和时间类型：<ul><li>DATETIME：1001年到9999年，精度为秒，格式为YYYYMMDDHHMMSS的整数，与时区无关，占用8个字节的存储空间，时间值的显式会因为时区不同而不同。</li><li>TIMESTAMP：1970年到2038年，保存从1970年1月1日午夜以来的秒数（格林尼治时间），只使用4个字节的存储空间，时间值的显式会因为时区不同而不同。</li></ul></li><li>位数据类型：<ul><li>BIT：旧版本BIT等价于TINYINT，BIT(1)存放一个位，最大为64位。BIT属于字符串类型，不建议使用。</li><li>SET</li></ul></li><li>特殊类型：<ul><li>低于秒精度的时间戳</li><li>IPv4地址，经常用 VARCHAR(15) 存放IP地址，实际上本质是32位无符号整数，小数点只是方便阅读，使用无符号整数存放，MySQL还提供了 <code>INET_ATON()</code> 和 <code>INET_NTOA()</code> 来在二者间转换。 </li></ul></li></ul><h2 id="二-选择合适的标识列"><a href="#二-选择合适的标识列" class="headerlink" title="二. 选择合适的标识列"></a>二. 选择合适的标识列</h2><p>标识列要常用于比较（如关联操作）、作为查询条件、外键等。不同表的相同标识列要保持数据类型一致，并且在选择数据类型时考虑MySQL如何执行计算和比较（如ENUM和SET使用整数存储，比较时转换为字符串）。</p><ul><li><strong>整数类型</strong>：最适合的标识列类型，效率高并且可以 AUTO_INCREMENT 。</li><li><strong>ENUM和SET类型</strong>：糟糕的选择。</li><li><strong>字符串类型</strong>：消耗空间，并且效率差于数字，特别是一些随机生成的字符串会任意分布在很大的空间内，导致INSERT或SELECT执行很慢。存储UUID应该去掉 <code>-</code> ，直接用 <code>UNHEX()</code> 函数转换为16字节数字存放在 BINARY(16) 列中，检索时使用 <code>HEX()</code> 格式化为十六进制格式。<ul><li>插入值随机写到索引的不同位置，使INSERT变慢，会导致页分裂、磁盘随机访问、对于聚簇存储引擎产生聚簇索引碎片。</li><li>逻辑上相邻的行分布在磁盘和内存的不同地方，使SELECT变慢。</li><li>随机值导致缓存赖以工作的访问局部性原理失效，整个数据集都一样“热”，缓存带来的好处就消失了。</li></ul></li></ul><h2 id="三-常见设计陷阱"><a href="#三-常见设计陷阱" class="headerlink" title="三. 常见设计陷阱"></a>三. 常见设计陷阱</h2><ol><li><strong>太多的列</strong>：MySQL存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，在服务器层将缓冲转码为各个列，将编码后的内容转码为各个行的数据格式操作代价较高，所以尽量避免上千个属性这种极端情况。</li><li><strong>太多的关联</strong>：期望查询能够快速的执行且并发性好，单个查询不要超过12个表关联。</li><li><strong>避免滥用枚举</strong>：修改枚举中值会进行一次 ALTER TABLE 操作。</li></ol><h2 id="四-范式和反范式"><a href="#四-范式和反范式" class="headerlink" title="四. 范式和反范式"></a>四. 范式和反范式</h2><p>范式化的数据库中，事实数据仅出现一次；反范式化的数据库中，信息是冗余的。</p><p>范式的优点：</p><ul><li>更新操作更快；</li><li>很少有重复数据，需要修改的数据更少；</li><li>表空间更小，在内存中执行更快；</li><li>很少有多余数据，所以更少需要 DISTINCT 或 GROUP BY 语句。</li></ul><p>范式的缺点：</p><ul><li>常常需要关联，不但代价昂贵，也可能使索引策略无效。</li></ul><p>反范式的优点：</p><ul><li>数据都在一张表，所以很少关联；</li><li>全表扫描基本是顺序I/O，不需要关联表避免了随机I/O；</li><li>可以构建有效的索引策略；</li></ul><p>真实的开发中很少会极端的遵循范式或反范式，而是混用二者；常见如<strong>复制</strong>或<strong>缓存</strong>，在不同的表存储相同的列，冗余的字段往往有其意义，比如排序需求、避免关联、避免多次查询等等。</p><h2 id="五-缓存表和汇总表"><a href="#五-缓存表和汇总表" class="headerlink" title="五. 缓存表和汇总表"></a>五. 缓存表和汇总表</h2><p>虽然冗余数据能够很好的提升性能，但有时还是需要创建一张完全独立的汇总表或缓存表。</p><p>一般缓存表用来存放那些可以简单获取但获取速度较慢的数据（逻辑上冗余的数据）；汇总表则存放使用 GROUP BY 语句聚合的数据。</p><p>例如，一个网站需要计算之前24小时发送的消息数，可以每小时生成一张汇总表（Redis应该是更好的解决方案），这样比实时维护计数器要高效的多，但并不精确。这种方案要远远快于统计message中所有行，实时计算统计值需要扫描表中的大部分数据，需要的索引也一般会影响到UPDATE操作（所以一般不希望创建这类索引）。</p><p>缓存表可以采用不同的存储引擎，比如主表是InnoDB，缓存表则使用MyISAM，这样可以得到更小的索引占用空间，并且可以做全文搜索。</p><p>使用缓存表和汇总表需要决定是实时维护数据还是定期重建，重建需要保证数据在操作时依然可用，所以需要“影子表”实现，即根据真实表创建一张影子表，完成建表后，通过一个原子性的重命名操作切换影子表和原表。</p><p><strong>更快的读，更慢的写</strong>，为了增加读查询的速度，会经常建一些额外索引、增加冗余列，甚至创建缓存表和汇总表。这些都会导致写查询变慢，开发难度提升，但能显著提高读操作的性能。</p><h2 id="六-提高-ALTER-TABLE-操作的速度"><a href="#六-提高-ALTER-TABLE-操作的速度" class="headerlink" title="六. 提高 ALTER TABLE 操作的速度"></a>六. 提高 ALTER TABLE 操作的速度</h2><p>ALTER TABLE 对于大表会执行很慢，大部分修改表操作会按新结构创建一个新的空表，从旧表查出所有数据插入新表，最后删除旧表。<strong>大部分 ALTER TABLE 操作会导致MySQL服务中断</strong>。 </p><p>常规场景的技巧：</p><ul><li>先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库切换；</li><li>“影子拷贝”，用要求的表结构创建一张和原表无关的新表，然后通过<strong>重命名</strong>和<strong>删表</strong>操作交换两张表。</li></ul><p>不是所有 ALTER TABLE 操作都要重建表，如下修改字段默认值，前者创建新表，后者直接修改 <code>.frm</code> 文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX</span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> xxx TINYINT(<span class="number">3</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> xxx <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="6-1-只修改-frm-文件，不重建表"><a href="#6-1-只修改-frm-文件，不重建表" class="headerlink" title="6.1 只修改 .frm 文件，不重建表"></a>6.1 只修改 .frm 文件，不重建表</h3><p>只修改 .frm 文件要远远快于重建表，而MySQL有时会在没必要重建表的时候仍去重建。比如移除一个列的 AUTO_INCREMENT 属性；增加、移除、修改ENUM和SET常量。</p><p>这类情况可以创建新的 <code>.frm</code> 文件，替换旧的：</p><ol><li>创建一张有相同结构的空表，进行需要的修改；</li><li>执行 <code>FLUSH TABLES WITH READ LOCK</code> ，会关闭所有正在使用的表，且禁止任何表被打开；</li><li>交换 <code>.frm</code> 文件；</li><li>执行 <code>UNLOCK TABLES</code> 释放第二步的读锁。</li></ol><h3 id="6-2-快速创建-MyISAM-索引"><a href="#6-2-快速创建-MyISAM-索引" class="headerlink" title="6.2 快速创建 MyISAM 索引"></a>6.2 快速创建 MyISAM 索引</h3><p>先禁用索引、载入数据，然后重新启用索引：因为构建索引的工作被延迟到数据完全载入后，这个时候可以利用排序来创建索引，相比会快很多，并且使索引树的碎片更少、更紧凑（只对非唯一索引有效）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">DISABLE</span> <span class="keyword">KEYS</span>;</span><br><span class="line"><span class="comment">--LOAD THE DATA</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">ENABLE</span> <span class="keyword">KEYS</span>;</span><br></pre></td></tr></table></figure><p>InnoDB也可以先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引。</p><p>操作步骤：</p><ol><li>用需要的表结构创建一张新表，但不包含索引；</li><li>载入数据到表中以构建 <code>.MYD</code> 文件；</li><li>按照需要的结构创建另一张空表，并包含索引，创建出 <code>.frm</code> 和 <code>.MYI</code> 文件；</li><li>获取读锁并刷新表；</li><li>重命名第二张表的 <code>.frm</code> 和 <code>.MYI</code> 文件，使MySQL认为是第一张表的文件；</li><li>释放读锁；</li><li>使用 <code>REPAIR TABLE</code> 重建表的索引，此操作通过排序来构建所有索引，包括唯一索引。</li></ol><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：数据类型优化，选择合适的标识列，常见Schema设计陷阱，范式与反范式，缓存表和汇总表，提高ALTER TABLE操作的速度等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（二）基准测试和服务器性能剖析</title>
    <link href="http://linyishui.top/2020121701.html"/>
    <id>http://linyishui.top/2020121701.html</id>
    <published>2020-12-17T12:12:06.000Z</published>
    <updated>2020-12-29T12:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（二）基准测试和服务器性能剖析"><a href="#《高性能MySQL》（二）基准测试和服务器性能剖析" class="headerlink" title="《高性能MySQL》（二）基准测试和服务器性能剖析"></a>《高性能MySQL》（二）基准测试和服务器性能剖析</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是基准测试？"><a href="#1-1-什么是基准测试？" class="headerlink" title="1.1 什么是基准测试？"></a>1.1 什么是基准测试？</h3><p>基准测试是针对系统设计的一种压力测试，通常是为了掌握系统的行为或重现某个系统状态、做新硬件的可靠性测试等。</p><h3 id="1-2-为什么需要基准测试？"><a href="#1-2-为什么需要基准测试？" class="headerlink" title="1.2 为什么需要基准测试？"></a>1.2 为什么需要基准测试？</h3><p>基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。观察系统在不同压力下的行为、评估系统的容量、观察系统如何处理不同的数据。</p><h2 id="二-基准测试的策略"><a href="#二-基准测试的策略" class="headerlink" title="二. 基准测试的策略"></a>二. 基准测试的策略</h2><p>两种主要策略：</p><ul><li>集成式：针对整个系统的整体测试；</li><li>单组件式：单独测试MySQL。</li></ul><p>一般建议做集成式测试，少数如需要比较不同的schema或查询的性能、针对某个具体问题的测试、避免过长的基准测试来检测某些调整的效果，可以考虑只测试MySQL。如果使用的是真实数据，那么只测试MySQL也是有效的。</p><h3 id="2-1-测试指标"><a href="#2-1-测试指标" class="headerlink" title="2.1 测试指标"></a>2.1 测试指标</h3><ul><li><strong>吞吐量</strong>：单位时间内处理的事务数，单位为每秒事务数TPS。</li><li><strong>响应时间或者延迟</strong>：任务所需的整体时间，通常使用百分比响应时间，如95%的响应时间都是5毫秒。</li><li><strong>并发性</strong>：同时工作的并发操作 / 线程数 / 连接数，当并发性增加时，要关注吞吐量是否下降，响应时间是否变长。可以通过 sysbench 指定多个线程，记录MySQL数据库的 Threads_running 状态值。</li><li><strong>可扩展性</strong>：给系统增加一倍的资源，理想情况下可以获得两倍的结果。</li></ul><h2 id="三-基准测试工具"><a href="#三-基准测试工具" class="headerlink" title="三. 基准测试工具"></a>三. 基准测试工具</h2><p>集成式测试工具：</p><ul><li>ab：Apache HTPP服务器基准测试工具，测试HTTP服务器每秒最多可以处理多少请求，只能针对单个URL进行尽可能快的压力测试。</li><li>http_load：可以通过输入文件提供多个URL随机选择进行测试。</li><li>JMeter：Java开发的测试工具，除了Web也可以测试FTP或JDBC等。</li></ul><p>单组件式测试工具：</p><ul><li>mysqlslap：MySQL 5.1发行包提供，模拟服务器的负载，输出计时信息。</li><li>MySQL Benchmark Suite（sql-bench）：MySQL发行包提供的基准测试套件，主要用于测试服务器执行查询的速度。可以用于比较不同存储引擎或不同配置的性能测试，也可以比较两个服务器的总体性能。单线程且串行执行，只能比较单CPU服务器的性能差别。</li><li>Super Smack：提供压力测试和负载生成，可以模拟多用户访问，加载测试数据到数据库，支持使用随机数据填充测试表。</li><li>Database Test Suite：OSDL开源实验室开发。</li><li>sysbench：多线程系统压测工具，支持Lua脚本语言，全能测试工具，支持MySQL、操作系统和硬件测试。</li></ul><h2 id="四-性能剖析概述"><a href="#四-性能剖析概述" class="headerlink" title="四. 性能剖析概述"></a>四. 性能剖析概述</h2><h3 id="4-1-常见场景"><a href="#4-1-常见场景" class="headerlink" title="4.1 常见场景"></a>4.1 常见场景</h3><p>常见性能相关的服务请求：</p><ul><li>如何确认服务器是否达到了性能最佳状态？</li><li>分析某条语句为什么执行的不够快？</li><li>诊断“停顿”，“堆积”或“卡死”的某些间歇性疑难故障？</li></ul><h3 id="4-2-性能剖析的标准"><a href="#4-2-性能剖析的标准" class="headerlink" title="4.2 性能剖析的标准"></a>4.2 性能剖析的标准</h3><p>定义一个性能的标准：完成某件任务的所需时间度量，也就是<strong>响应时间</strong>。对于数据库来说就是查询的响应时间，不管是DDL还是DML都用查询来泛指。优化就是在一定的工作负载下尽可能地降低响应时间。</p><p>无法测试就无法有效地优化，首先应该测量查询时间花在什么地方，要准确测量需要注意两点：</p><ul><li>不要在错误的时间启动和停止测量；</li><li>测量的是目标活动本身，而不是聚合后的信息。</li></ul><p>如测量慢查询时去排查整个服务器来判断问题出处，测量应该从慢查询开始到结束的时间，而不是查询之前或之后的时间。</p><p>查询时间包括：</p><ul><li>执行时间：只需测量定位不同的子任务花费的时间，优化去掉一些子任务、降低一些子任务执行频率、提高子任务执行效率。</li><li>等待时间：可能因为其他系统间接影响，任务间也可能因为竞争磁盘或CPU资源而相互影响，</li></ul><p>通过性能剖析可以分析定位是哪些子任务是优化的目标。</p><h2 id="五-如何进行性能剖析"><a href="#五-如何进行性能剖析" class="headerlink" title="五. 如何进行性能剖析"></a>五. 如何进行性能剖析</h2><h3 id="5-1-性能剖析步骤"><a href="#5-1-性能剖析步骤" class="headerlink" title="5.1 性能剖析步骤"></a>5.1 性能剖析步骤</h3><p>性能剖析包括两步：</p><ul><li>测量任务所花费的时间；</li><li>对结果进行统计和排序，把重要的任务排在前面。</li></ul><h3 id="5-2-性能剖析的输出信息"><a href="#5-2-性能剖析的输出信息" class="headerlink" title="5.2 性能剖析的输出信息"></a>5.2 性能剖析的输出信息</h3><p>性能剖析工具通常都是计时器，记录任务的开始和结束时间。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012010102.png" alt></p><p>性能剖析需要系统可测量化，系统需要有一些测量点可以捕获并收集数据，MySQL直到版本5.5才首次提供Performance Schema 包含一些基于时间的可测量点，在此之前只能收集到记录活动发生次数的 show status 计数器。而 Percona Server 可以提供更多更详细的查询级别测量点。</p><p>性能剖析输出的排名、总计、平均值之外缺失的信息：</p><ul><li>值得优化的查询：性能剖析不会自动给出需要优化的查询，总响应时间占比小的查询不值得优化，优化成本大于收益的查询不值得优化。</li><li>异常情况：有些查询虽然执行频率不高，但每次执行都很慢。</li><li>未知的未知：丢失时间-任务的总时间和测量得到的时间之差，如CPU时间为10秒，剖析得到任务时间为9.7秒，存在300毫秒的丢失时间。可能会忽略某些重要信息。</li><li>被隐藏的细节：只分析平均值会忽略到一些情况，如医院只看所有病人的平均体温，可以输出更多响应时间的信息，如直方图、百分比、标准差、偏差指数等。</li></ul><h2 id="六-剖析MySQL查询"><a href="#六-剖析MySQL查询" class="headerlink" title="六. 剖析MySQL查询"></a>六. 剖析MySQL查询</h2><h3 id="6-1-慢查询日志"><a href="#6-1-慢查询日志" class="headerlink" title="6.1 慢查询日志"></a>6.1 慢查询日志</h3><h4 id="（1）相关参数"><a href="#（1）相关参数" class="headerlink" title="（1）相关参数"></a>（1）相关参数</h4><ol><li>slow_query_log ：是否开启慢查询日志，1表示开启，0表示关闭。</li><li>log-slow-queries ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>long_query_time ：慢查询时间设置，当查询时间多于设定的时间值时，记录日志。</li></ol><h4 id="（2）慢查询日志配置"><a href="#（2）慢查询日志配置" class="headerlink" title="（2）慢查询日志配置"></a>（2）慢查询日志配置</h4><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：</p><ol><li><p>查询慢日志是否开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--OFF 为关闭 ON为开启</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slow_query_log%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>开启慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：使用set global slowquerylog=1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）</strong></p></li><li><p>永久开启慢查询日志：</p><p>修改my.cnf文件，增加或修改参数slow_query_log 和slow_query_log_file后，然后重启MySQL服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log =1</span><br><span class="line">slow_query_log_file=/usr/local/mysql/data/localhost-slow.log</span><br></pre></td></tr></table></figure></li></ol><h4 id="（3）慢查询时间设置"><a href="#（3）慢查询时间设置" class="headerlink" title="（3）慢查询时间设置"></a>（3）慢查询时间设置</h4><p>这个是由参数 long_query_time 控制，默认情况下 long_query_time 的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。</p><ol><li><p>查询慢日志时间设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置慢查询日志时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2-剖析服务器负载"><a href="#6-2-剖析服务器负载" class="headerlink" title="6.2 剖析服务器负载"></a>6.2 剖析服务器负载</h3><p>最简单的方式就是使用<strong>慢查询日志</strong>，是MySQL开销最低、精度最高的测量查询工具，使用时只需注意磁盘空间开销，MySQL 5.1 版本后可以通过 <code>long_query_time</code> 为 0 来捕获所有的查询，查询的响应时间可以做到微秒级。</p><p>Percona Server 的慢查询日志相比MySQL会记录更多信息，如执行计划、锁、I/O活动等。</p><p>可以在业务高峰期开启一个小时的记录查询，首先生成一个剖析报告，需要一个适合的剖析工具，如 <code>pt-query-digest</code> 分析 tcpdump。</p><h3 id="6-3-剖析单条查询"><a href="#6-3-剖析单条查询" class="headerlink" title="6.3 剖析单条查询"></a>6.3 剖析单条查询</h3><p>定位到需要优化的查询语句后，</p><ul><li><p>SHOW PROFILE：</p><ul><li><p>作用：会测量所有服务器上执行的语句，记录耗费时间和执行状态变更相关的数据。</p></li><li><p>开启：<code>SET profiling = 1;</code> </p></li><li><p>使用：<code>SHOW PROFILES</code> 和 <code>SHOW PROFILE FOR QUERY 1;</code> 结果按照执行顺序排序，而不是花费时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @query_id = <span class="number">252</span>;</span><br><span class="line"><span class="keyword">SELECT</span> STATE, <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) <span class="keyword">AS</span> Total_R,</span><br><span class="line"> <span class="keyword">ROUND</span>(</span><br><span class="line"><span class="number">100</span> * <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) /</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>)</span><br><span class="line"> <span class="keyword">FROM</span> information_schema.PROFILING</span><br><span class="line"> <span class="keyword">WHERE</span> QUERY_ID = @query_id), <span class="number">2</span></span><br><span class="line"> ) <span class="keyword">AS</span> Pct_R, </span><br><span class="line"> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> Calls,</span><br><span class="line"> <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) / <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="string">"R/Call"</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.PROFILING</span><br><span class="line"><span class="keyword">WHERE</span> QUERY_ID = @query_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> STATE</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Total_R <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></li><li><p>排序后可以明显的找到查询的耗时步骤，找到其中值得优化的部分去优化。</p></li></ul></li><li><p>SHOW STATUS：</p><ul><li><p>作用：返回一些计数器，有服务器级别和单个连接会话级别的计数器，如 <code>Queries</code> 在会话开始前为0，每提交一条查询增加1。</p></li><li><p>使用：<code>SHOW GLOBAL STATUS</code> 查看服务器级别的次数统计。<code>SHOW STATUS</code> 包含两种级别的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--重置计数器</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="comment">--执行SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tv_tallymaster_bak <span class="keyword">where</span> book_id <span class="keyword">in</span> (<span class="string">'100199100'</span>,<span class="string">'100200000'</span>);</span><br><span class="line"><span class="comment">--查看指定计数器结果</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">WHERE</span> Variable_name <span class="keyword">LIKE</span> <span class="string">'Handler%'</span> <span class="keyword">OR</span> Variable_name <span class="keyword">LIKE</span> <span class="string">'Created%'</span></span><br><span class="line"><span class="comment">-- Created_tmp_tables 表示使用临时表数目</span></span><br><span class="line"><span class="comment">-- Created_tmp_disk_tables 磁盘临时表</span></span><br><span class="line"><span class="comment">-- Handler_read_rnd_next 没有用到索引的读操作</span></span><br></pre></td></tr></table></figure></li><li><p>只能显示某种活动的频繁程度（如读索引），只有一个参数指全局级别的操作时间（Innodb_row_lock_time）。</p></li><li><p>比较有用的计数器：</p><ul><li>句柄计数器（handler counter）</li><li>临时文件</li><li>表计数器</li></ul></li><li><p>SHOW STATUS 本身也会创建一个临时表，通过句柄操作访问此表，会影响计数器数字。</p></li><li><p>EXPLAIN 有类似的结果，但基于统计；SHOW STATUS 的结果基于测量。</p></li></ul></li><li><p>检查慢查询日志的条目：</p><ul><li>使用 Percona Server 得到更详细有用的信息。</li><li><code>pt-query-digest</code> 标题一般会打印出字节偏移值（3214），使用tail指令直接跳转到对应部分：<code>tail -c +3214 /path/to/query.log | head -n100</code></li></ul></li><li><p>使用 <code>Performance Schema</code> </p></li></ul><h3 id="6-4-诊断间歇性问题"><a href="#6-4-诊断间歇性问题" class="headerlink" title="6.4 诊断间歇性问题"></a>6.4 诊断间歇性问题</h3><p>例如一个简单查询，正常情况下使用很快，但有几次不合理的执行了很久。手工执行一遍，非常快；然后用EXPLAIN查询执行计划，也正确的使用了索引。修改WHERE条件的值，排除缓存命中的可能性。</p><p>慢查询日志没有执行计划或详细的时间信息，可能是系统有其他东西消耗了资源，比如正在备份，或是某种类型的锁或争用阻塞了查询进度。</p><p>尽量避免试错的诊断方式，以下是一些常见的案例，某些是数据库问题，但也有的不是：</p><ul><li>应用通过 curl 从一个运行很慢的外部服务获取汇率报价的数据。</li><li>memcached 缓存中一些重要条目过期，导致大量请求落到MySQL重新生成缓存条目。</li><li>DNS查询偶尔有超时现象。</li><li>可能由于互斥锁争用，或者内部删除查询缓存的算法效率太低的缘故，MySQL的查询缓存有时候会导致服务有短暂的停顿。</li><li>当并发度超过某个阈值时，InnoDB的扩展性限制导致查询计划的优化需要很长时间。</li></ul><p>只能在问题发生的地方通过观察资源的使用情况，并尽可能的测量出数据，才能避免在没问题的地方耗费精力。</p><ul><li><p><strong>确认单条查询问题还是服务器问题</strong>：</p><ul><li><p>服务器整体没问题，只是某条查询慢，可以将注意力放在这条特定的查询上面。</p></li><li><p>判断方法：</p><ul><li><p>使用 <code>SHOW GLOBAL STATUS</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每秒捕获一次SHOW GLOBAL STATUS的数据，输出给awk计算并输出每秒的查询数、Threads_connected和Threads_running表示当前正在执行查询的线程数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysqladmin ext -i1 | awk <span class="string">'/Queries/&#123;q=$4-qp;qp=$4&#125; /Threads_connected/&#123;tc=$4&#125; /Threads_running/&#123;printf "%5d %5d %5d\n", q, tc, $4&#125;'</span></span></span><br></pre></td></tr></table></figure><p>每秒查询数一般会下跌，其他两个至少会出现一个尖刺。可能是服务器内部碰到了某种瓶颈，导致新查询在开始执行前因为要获取老查询正在等待的锁而造成堆积（一般也会导致后端服务器出现排队）；也可能是服务区突然收到大量查询请求，比如前端memcached突然失效导致的查询风暴。</p></li><li><p>使用 <code>SHOW PROCESSLIST</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过不停捕获SHOW PROCESSLIST的输出，观察是否有大量现场处于不正常状态或有不正常的特征，如statistics状态一般服务器在查询优化阶段确定表关联顺序—非常快，所以查询不应长时间处与此状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \G垂直输出结果，方便使用 sort|uniq|sort 计算某一列值出现次数，一般State列会很有用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -e <span class="string">'SHOW PROCESSLIST\G'</span> | grep State: | sort | uniq -c | sort -rn</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 大量线程处于freeing items说明出现了大量有问题查询</span></span><br></pre></td></tr></table></figure><ul><li>也可以直接查询表：<code>SELECT * FROM information_schema.PROCESSLIST</code></li><li>使用 innotop 工具。</li></ul></li><li><p>使用查询日志：</p><ul><li>开启慢查询日志，并在全局级别设置 <code>long_query_time=0</code> ，确认所有连接都采用了新设置，可能需要重置所有连接，或是使用 Percona Server。</li><li>也可以通过 tcpdump 和 pt-query-digest 工具替代。</li><li>找到吞吐量突然下降时间段的日志，一般是吞吐量下降后第一个完成的查询。</li></ul></li></ul></li></ul></li><li><p><strong>捕获诊断数据</strong>：</p><ul><li><p>辅助工具：</p><ul><li>一个可靠且实时的触发器；</li><li>一个收集诊断数据的工具。</li></ul></li><li><p>找到能和正常时的阈值进行比较的指标，如正在运行的线程数量、处于“freeing items”状态的线程数量等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -e <span class="string">'SHOW PROCESSLIST/G'</span> | grep -c <span class="string">"State: freeing items"</span></span></span><br></pre></td></tr></table></figure></li><li><p>Percona Toolkit 的 pt-stalk 可以在触发条件时收集数据。</p></li><li><p>需要收集的数据：系统状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存使用率、MySQL的几个SHOW STATUS / SHOW PROCESSLIST / SHOW INNODB STATUS</p></li></ul></li></ul><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：基准测试和服务器性能剖析，MySQL查询剖析等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（一）架构和历史</title>
    <link href="http://linyishui.top/2020120801.html"/>
    <id>http://linyishui.top/2020120801.html</id>
    <published>2020-12-08T12:03:19.000Z</published>
    <updated>2021-05-12T12:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（一）架构和历史"><a href="#《高性能MySQL》（一）架构和历史" class="headerlink" title="《高性能MySQL》（一）架构和历史"></a>《高性能MySQL》（一）架构和历史</h1><p>MySQL的存储引擎架构将<strong>查询处理</strong>及其他<strong>系统任务</strong>和<strong>数据的存储/提取</strong>相分离。从而可以在使用时根据性能、特性等需求来选择数据存储的方式。</p><h2 id="一-MySQL逻辑架构"><a href="#一-MySQL逻辑架构" class="headerlink" title="一. MySQL逻辑架构"></a>一. MySQL逻辑架构</h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012010101.png" alt></p><ul><li>第一层：连接处理、授权认证、安全等等。</li><li>第二层：查询解析、分析、优化、缓存以及所有的内置函数，还有所有的跨存储引擎的实现：存储过程、触发器、视图。</li><li>第三层：存储引擎，服务器通过API与存储引擎进行通信，包括几十个底层函数，如“开始一个事务”、“根据主键提取一行记录”。存储引擎不会解析SQL（Innodb会解析外键，因为MySQL服务器本身没有实现此功能），存储引擎只会简单的响应上层服务器的请求。</li></ul><h3 id="1-1-连接与安全"><a href="#1-1-连接与安全" class="headerlink" title="1.1 连接与安全"></a>1.1 连接与安全</h3><p>每个客户端连接对应服务器进程中的一个线程，连接的所有查询都在此线程中进行，服务器会负责缓存线程而不必每次都创建新线程，MySQL 5.5后支持线程池来支持大量连接。</p><p>认证基于用户名、原始主机信息和密码。使用安全套接字SSL的方式连接，可以使用X5.09证书认证。连接成功后会继续验证用户是否有相应请求的权限。</p><h3 id="1-2-优化与执行"><a href="#1-2-优化与执行" class="headerlink" title="1.2 优化与执行"></a>1.2 优化与执行</h3><p>MySQL会解析查询，并创建内部数据结构-解析树，然后对其进行各种优化，包括重写查询、决定表的读写顺序、选择合适的索引等。</p><ul><li>可以通过特殊关键字 <strong>hint</strong> 提示优化器，影响其决策过程；</li><li>可以通过 <strong>explain</strong> 请求优化器解释优化过程的各个因素，从而了解到服务的优化决策，便于用户重构查询和schema、修改相关配置。</li></ul><p>对于如 SELECT 语句，在解析查询前会检查查询缓存，若有相应查询就可以直接返回结果。 </p><h2 id="二-并发控制"><a href="#二-并发控制" class="headerlink" title="二. 并发控制"></a>二. 并发控制</h2><p>MySQL在两个层控制并发：服务器层和存储引擎层。</p><h3 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1 读写锁"></a>2.1 读写锁</h3><p>并发读数据不会有问题，但当一个用户读取数据，另外一个用户删除数据时，可能读取会报错，也可能读到了不一致的数据。</p><p>通过实现共享锁（shared lock）和排它锁（exclusive lock），也叫读锁和写锁，这两种锁组成的锁系统来解决问题。写锁会阻塞其他写锁和读锁，</p><h3 id="2-2-锁粒度"><a href="#2-2-锁粒度" class="headerlink" title="2.2 锁粒度"></a>2.2 锁粒度</h3><p>为了提高共享资源的并发性，减少锁定的对象，避免锁住所有资源。但锁的所有操作，如获取锁、检查是否锁已释放、释放锁等都会增加系统开销。<strong>锁策略就是在锁的开销和数据的安全性之间寻找平衡</strong>。</p><ul><li><strong>表锁</strong>：<ul><li>表锁是开销最小的锁，会锁定整张表，写操作时会阻塞其他读写操作，写锁未被持有时其他用户才能获取读锁，读锁间不相互阻塞。</li><li>写锁的优先级比读锁要高，所以写请求可能会被插入到读请求前，服务器可能会忽略存储引擎的表锁实现为如 <code>ALTER TABLE</code> 之类的语句加表锁。</li></ul></li><li><strong>行锁</strong>：<ul><li>行锁可以提供更好的并发性，但也带来了最大的锁开销。行锁由存储引擎实现（InnoDB和XtraDB等）</li></ul></li></ul><h3 id="2-3-锁类型"><a href="#2-3-锁类型" class="headerlink" title="2.3 锁类型"></a>2.3 锁类型</h3><p>MySQL包括如下锁类型：</p><ul><li><p><strong>读写锁</strong>：同Java一样，写锁持有时其他事务不能获取任何锁，读锁持有时其他事务可以获取读锁，但不能获取写锁。</p><ul><li><strong>互斥锁</strong>：简称X锁，又叫写锁。</li><li><strong>共享锁</strong>：简称S锁，又叫读锁。</li></ul></li><li><p><strong>意向锁</strong>：更容易的支持多粒度的封锁，在同时存在行级锁和表级锁的情况下，事务想要对表加锁，要首先分别检查是否有其他事务加表锁或行锁，这个过程需要对每一行都进行一次检测，这相当耗时。</p><p><strong>意向锁在 X/S 锁之上引入了 IX/IS，二者都是表锁，规定事务获取某行的X或S锁前要先获取IX或IS锁</strong>。这样当事务想对表加写锁时只需检测是否有其他事务对表加了 X/IX/S/IS 锁，只需做一次检测。（<strong>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁</strong>）</p><ul><li><strong>意向共享锁</strong>（IS Lock）：事务想要获得一张表中某几行的共享锁；</li><li><strong>意向排他锁</strong>（IX Lock）：事务想要获得一张表中某几行的排他锁；</li><li><strong>插入意向锁</strong>（Insert Intention Lock）：插入意向锁是间隙锁的一种，专门针对insert操作的。即多个事务在同一个索引、同一个范围区间内插入记录时，如果插入的位置不冲突，则不会阻塞彼此</li></ul></li><li><p><strong>自增锁</strong>（Auto-inc Locks）：自增锁是一种特殊的<strong>表级别锁</strong>，专门针对事务插入 AUTO-INCREMENT 类型的列。即一个事务正在往表中插入记录时，其他事务的插入必须等待，以便第1个事务插入的行得到的主键值是连续的。</p></li><li><p><strong>记录锁</strong>（Record Locks）：</p><ul><li>记录锁是的单个行记录上的锁，会阻塞其他事务对其插入、更新、删除；</li><li><code>locks rec but not gap</code> 。</li></ul></li><li><p><strong>间隙锁</strong>（Gap Lock）：间隙锁锁定记录的一个间隔，但不包含记录本身。</p></li><li><p><strong>临键锁</strong>（Next-Key Lock）：</p><ul><li><code>Next-Key Lock = Gap Lock + Record Lock</code> 临建锁是记录锁与间隙锁的组合，即：既包含索引记录，又包含索引区间，主要是为了解决幻读。</li></ul></li></ul><p>总结：</p><ul><li>表锁：意向锁，自增锁。</li><li>行锁：读写锁，记录锁，间隙锁，临键锁。</li></ul><h2 id="三-事务"><a href="#三-事务" class="headerlink" title="三. 事务"></a>三. 事务</h2><h3 id="3-1-什么是事务？"><a href="#3-1-什么是事务？" class="headerlink" title="3.1 什么是事务？"></a>3.1 什么是事务？</h3><p>事务是<strong>一组原子性的SQL查询</strong>，一个独立的工作单元。全部语句能够被数据库引擎成功应用，则执行该组查询；有任一语句无法执行，事务的所有语句都不会执行。<strong>要么全部执行成功，要么全部执行失败</strong>。</p><h3 id="3-2-ACID"><a href="#3-2-ACID" class="headerlink" title="3.2 ACID"></a>3.2 ACID</h3><ul><li><strong>原子性（Atomicity）</strong>：事务作为一个不可分割的整体被执行，包含在其中的对数据库的操作要么<strong>全部被执行</strong>，要么<strong>全部不执行</strong>。</li><li><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。数据库发生故障导致事务中断，未完成的修改不能写入物理数据库。</li><li><strong>隔离性（Isolation）</strong>：一个事务在最终提交前应该对其他事务是不可见的，在并发操作相同数据时，每个事务都有独立的数据空间；多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。</li></ul><p>事务所带来的安全性也需要额外的工作和开销，而MySQL的存储引擎架构可以支持用户根据业务是否需要事务选择合适的存储引擎。</p><h3 id="3-3-隔离级别"><a href="#3-3-隔离级别" class="headerlink" title="3.3 隔离级别"></a>3.3 隔离级别</h3><ol><li><strong>读未提交</strong>（READ UNCOMMITTED）：<ul><li>事务中的修改，即使没有提交，对其它事务也是可见的。</li><li>会<strong>导致脏读</strong>（读到未提交的数据），性能也并未比其它级别好很多。</li></ul></li><li><strong>读已提交</strong>（READ COMMITTED）： <ul><li>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li><li>也叫不可重复读，因为两次执行相同的查询可能会得到不同的结果。</li><li>大部分数据库的默认隔离级别，MySQL因为历史遗留问题，默认隔离级别是可重复读。</li></ul></li><li><strong>可重复读</strong>（REPEATABLE READ）：<ul><li>保证在同一个事务中多次读取同一数据的结果是一样的。</li><li>不可重复读在同一事务中多次读取可能会读到不同的数据结果，可重复读则保证同一个事务中只会读到相同结果</li></ul></li><li><strong>可串行化</strong>（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</li></ol><table><thead><tr><th>隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th><th style="text-align:center">加锁读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>READ COMMITTED</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>REPEATABLE READ</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>SERIALIZABLE</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr></tbody></table><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200103.png" alt></p><h4 id="（1）为什么MySQL默认是可重复读？"><a href="#（1）为什么MySQL默认是可重复读？" class="headerlink" title="（1）为什么MySQL默认是可重复读？"></a>（1）为什么MySQL默认是可重复读？</h4><p>MySql的历史版本中，主从复制基于binlog（记录数据库修改的文件），当时binlog只有 <strong>statement</strong> 这种模式（记录修改SQL语句），后来还有<strong>row</strong>（记录每行数据变更）和 <strong>mixed</strong>（前两种模式混合）总共三种模式。</p><p><strong>statement</strong>模式在<strong>读已提交</strong>下进行主从复制有BUG，在master上执行的顺序为先删后插，而binlog的记录顺序为先插后删，所以slave同步binlog后导致执行顺序和master不一致。</p><p>解决方法：</p><ol><li>调整隔离级别为<strong>可重复读</strong>。</li><li>更新模式为<strong>row</strong>（5.1版本后引入）。</li></ol><h4 id="（2）为什么选择读已提交？"><a href="#（2）为什么选择读已提交？" class="headerlink" title="（2）为什么选择读已提交？"></a>（2）为什么选择读已提交？</h4><p>首先排除<strong>读未提交</strong>和<strong>可串行化</strong>，前者会出现脏读，后者每次读操作都要加锁。</p><p>选读已提交/不可重复读的原因：</p><ol><li><strong>可重复读下，存在间隙锁</strong>（封锁索引记录中的间隔）导致死锁概率增加：如 <code>SELECT * FROM test WHERE id BETWEEN 5 AND 7</code> ，表中有id（1，5，7，10），所以存在5个间隙，上述sql会锁住(5,7]和(7,10]这两个区间，导致区间无法插入数据。而<strong>读已提交不存在间隙锁</strong>。</li><li><strong>可重复读下，条件未命中索引会锁表</strong>，而<strong>读已提交，只会锁行</strong>。</li><li><strong>读已提交，因为半一致性读的特性会增加update操作的并发性</strong>。一个事务执行完update操作，但尚未提交，另一事务获取锁时发现已占用，InnoDB开启半一致性读返回最新的已提交版本，MySql会重新发起一次读操作，此时可以读到此行的最新版本并加锁，而可重复读这时事务只能等待前一事务提交。</li><li><strong>不可重复读问题可以接受</strong>，已经提交了数据，即使不一样通常也不会造成问题。</li></ol><h3 id="3-4-并发一致性问题"><a href="#3-4-并发一致性问题" class="headerlink" title="3.4 并发一致性问题"></a>3.4 并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，所以有几种并发一致性问题：</p><ol><li><strong>修改丢失</strong>：即一个事务的更新背另一个事务的更新替换。</li><li><strong>读脏数据</strong>：指当前事务读到另外事务未提交的数据。</li><li><strong>不可重复读</strong>：指一个事务多次读取同一数据集合，在此期间另外事务也访问了此集合并做出修改，导致前个事务两次读取数据不一致。</li><li><strong>幻影读</strong>：本质也是不可重复读，指一个事务读取某个范围的数据，另一事务在此范围插入新数据，导致前个事务再次读取结果不一致。<strong>区别在要避免幻读需要锁整张表，而避免不可重复读只需锁住行即可</strong>。</li></ol><p>通过锁机制来解决此问题，MySql提供了对应的封锁机制来实现，<strong>通过三级封锁协议来处理并发一致性问题</strong>。</p><h3 id="3-5-封锁协议"><a href="#3-5-封锁协议" class="headerlink" title="3.5 封锁协议"></a>3.5 封锁协议</h3><ul><li><strong>三级封锁协议</strong>：<ul><li>一级：<strong>事务 T 要修改数据 A 时必须加写锁，直到 T 结束才释放锁</strong>。可以解决修改丢失问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</li><li>二级：<strong>在一级的基础上，要求读取数据 A 时必须加读锁，读取完马上释放读锁</strong>。可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</li><li>三级：<strong>在二级的基础上，要求读取数据 A 时必须加读锁，直到事务结束了才能释放读锁</strong>。可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</li></ul></li><li><strong>两段封锁协议</strong>：<strong>加锁和解锁分为两个阶段进行</strong>。</li></ul><h3 id="3-6-死锁"><a href="#3-6-死锁" class="headerlink" title="3.6 死锁"></a>3.6 死锁</h3><ul><li>死锁指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</li><li>InnoDB有死锁检测和死锁超时机制，处理死锁时会将持有最少行级排他锁的事务进行回滚。</li><li>死锁可能是因为真正的数据冲突，有时可能完全是由于存储引擎的实现方式导致的。</li><li>应用程序需要考虑如何处理死锁，大部分情况只需重新执行因死锁回滚的事务即可。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看数据库隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line"><span class="keyword">select</span> @@global.tx_isolation,@@tx_isolation;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看innodb状态，打印死锁日志，NaviCat复制出去看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--设置隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> XXX;</span><br><span class="line"><span class="comment">--只改变当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">READ</span> COMMITED;</span><br></pre></td></tr></table></figure><h3 id="3-7-事务日志"><a href="#3-7-事务日志" class="headerlink" title="3.7 事务日志"></a>3.7 事务日志</h3><p>事务日志用来提高事务的执行效率，存储引擎在修改表的数据时只需修改内存拷贝，再把修改行为记录在持久的硬盘上的事务日志中，而不是每次都把修改的数据持久到硬盘。</p><p>事务日志通过追加的方式，操作是磁盘小块区域上的顺序I/O，要比随机I/O快得多。所以每次修改数据需要<strong>写两次磁盘</strong>。</p><h3 id="3-8-存储引擎与事务"><a href="#3-8-存储引擎与事务" class="headerlink" title="3.8 存储引擎与事务"></a>3.8 存储引擎与事务</h3><p>MySQL有很多支持事务的存储引擎，如InnoDB、NDB Cluster、XtraDB和PBXT等。</p><h4 id="（1）自动提交（AUTO-COMMIT）"><a href="#（1）自动提交（AUTO-COMMIT）" class="headerlink" title="（1）自动提交（AUTO COMMIT）"></a>（1）自动提交（AUTO COMMIT）</h4><p>MySQL默认采用自动提交模式。每个查询都会被当做一个事务执行提交操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'AUTOCOMMIT'</span></span><br><span class="line"></span><br><span class="line">Variable_name<span class="keyword">Value</span></span><br><span class="line">autocommit    <span class="keyword">ON</span></span><br><span class="line"><span class="comment">--1启用0禁用</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>数据定义语言（DDL）中涉及大量数据改变的操作（如Alter Table、Lock Tables）会强制执行COMMIT提交当前活动事务。</p><h4 id="（2）在事务中混合使用存储引擎"><a href="#（2）在事务中混合使用存储引擎" class="headerlink" title="（2）在事务中混合使用存储引擎"></a>（2）在事务中混合使用存储引擎</h4><p>事务由存储引擎实现，所以在一个事务中使用多种存储引擎不可靠，如果在事务中混合使用了多个包括事务型和非事务型存储引擎的表，正常提交不会有问题，但需要回滚时非事务型的表无法撤销变更。而且仅仅在回滚时提示一个警告，其余情况不会有提示。</p><h4 id="（3）隐式和显式锁定"><a href="#（3）隐式和显式锁定" class="headerlink" title="（3）隐式和显式锁定"></a>（3）隐式和显式锁定</h4><ul><li><p>隐式锁定：InnoDB采用<strong>两阶段锁定协议</strong>，事务执行过程中可以随时锁定，但只有事务提交或回滚时才会释放，并且是同一时刻释放。InnoDB根据隔离级别在需要时自动加锁。</p></li><li><p>显式锁定：通过特点语句进行锁定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><p><code>LOCK TABLES</code> 和 <code>UNLOCK TABLES</code> 由服务器层实现，与存储引擎无关，不能用来代替事务。</p></li></ul><h2 id="四-多版本并发控制-MVCC"><a href="#四-多版本并发控制-MVCC" class="headerlink" title="四. 多版本并发控制-MVCC"></a>四. 多版本并发控制-MVCC</h2><h3 id="4-1-什么是多版本并发控制？"><a href="#4-1-什么是多版本并发控制？" class="headerlink" title="4.1 什么是多版本并发控制？"></a>4.1 什么是多版本并发控制？</h3><p>大部分事务型存储引擎实现的都不是简单的行级锁，一般都同时实现了多版本并发控制-MVCC，<strong>该机制可以在很多情况下避免加锁操作，所以可以降低开销，一般都会实现非阻塞的读操作和只锁定必要行的写操作</strong>。</p><p>MVCC实现机制各不相同：</p><ul><li>乐观并发控制</li><li>悲观并发控制</li></ul><p><strong>MVCC只兼容于 REPEATABLE READ 和 READ COMMITED 这两个隔离级别，而 READ UNCOMMITED 总是读取最新的数据行而不是符合当前事务版本的数据行，SERIALIZABLE 则会对所有读取的行加锁</strong>。</p><h3 id="4-2-如何实现多版本并发控制？"><a href="#4-2-如何实现多版本并发控制？" class="headerlink" title="4.2 如何实现多版本并发控制？"></a>4.2 如何实现多版本并发控制？</h3><p><strong>通过保存数据在某个时间点的快照来实现</strong>。</p><p>InnoDB通过在每行记录后面保存两个隐藏的列，一个保存了行的创建时间，一个保存行的过期时间（实际存储的非时间而是系统版本号）。每开启一个新事务，版本号都会自动递增，事务开始时刻的版本号作为事务的版本号与查询到的每行记录进行比较。</p><p>在REPEATABLE READ隔离级别下：</p><ul><li>SELECT：根据两个条件检查每行记录，符合才作为查询结果返回。<ul><li>只查找版本早于当前事务版本的数据行，确保事务读取的行是事务开始前存在或自己修改过的。</li><li>行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行在事务开始前未被删除。</li></ul></li><li>INSERT：为新插入的每一行保存当前系统版本号作为<strong>行版本号</strong>。</li><li>DELETE：为删除的每一行保存当前系统版本号作为<strong>行删除标识</strong>。</li><li>UPDATE：插入一行新纪录，保存当前系统版本号作为<strong>行版本号</strong>，同时保存当前系统版本号到原来的行作为<strong>行删除标识</strong>。</li></ul><p>通过这两个版本号可以使大部分读操作都不需加锁（乐观），以少量的额外存储空间和检查维护工作换取好的性能。</p><h2 id="五-存储引擎"><a href="#五-存储引擎" class="headerlink" title="五. 存储引擎"></a>五. 存储引擎</h2><p>文件系统中，MySQL将每个数据库保存为数据目录下的一个子目录。创建表时在数据库子目录下创建一个和表同名的 <code>.frm</code> 文件保存表的定义。表的定义统一在服务层处理，数据和索引则在不同的存储引擎中保存方式不同。</p><p>正因为使用了文件系统的目录文件，所以MySQL大小写敏感和平台相关，Windows中不敏感，而类Unix中则敏感。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看表信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'表名'</span></span><br></pre></td></tr></table></figure><p>返回字段：</p><table><thead><tr><th>字段</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>Name</td><td>表名</td><td>version</td></tr><tr><td>Engine</td><td>存储引擎类型</td><td>InnoDB</td></tr><tr><td>Version</td><td></td><td>10</td></tr><tr><td>Row_format</td><td>行格式：<br>-Dynamic的行长度可变，一般会有如VARCHAR或BLOB这种可变长字段<br>-Fixed的行长度固定，只包含如CHAR何INTEGER这种固定长度字段<br>-Compressed只在压缩表存在<br>….</td><td>Compact</td></tr><tr><td>Rows</td><td>表的行数，对于InnoDB是估计值，MyISAM则是精确值</td><td>25</td></tr><tr><td>Avg_row_length</td><td>平均每行包含的字节数</td><td>655</td></tr><tr><td>Data_length</td><td>表数据的大小，单位字节</td><td>16384</td></tr><tr><td>Max_data_length</td><td>表数据的最大容量</td><td>0</td></tr><tr><td>Index_length</td><td>索引大小</td><td>16384</td></tr><tr><td>Data_free</td><td>表示已分配但目前没有使用的空间。包括已删除的行以及后续可以被Insert利用的空间</td><td>0</td></tr><tr><td>Auto_increment</td><td>下一个自增的值</td><td></td></tr><tr><td>Create_time</td><td>表的创建时间</td><td>2020-12-02 13:04:02</td></tr><tr><td>Update_time</td><td>表数据的最后修改时间</td><td></td></tr><tr><td>Check_time</td><td>使用CHECK TABLE命令或myisamchk等工具最后一次检查表的时间</td><td></td></tr><tr><td>Collation</td><td>表的默认字符集和字符列排序规则</td><td>gbk_chinese_ci</td></tr><tr><td>Checksum</td><td>启用时保存整个表的实时校验和</td><td></td></tr><tr><td>Create_options</td><td>创建表时指定的其他选项</td><td></td></tr><tr><td>Comment</td><td>额外信息，InnoDB表空间的剩余空间信息，视图VIEW文本等</td></tr></tbody></table><h3 id="5-1-InnoDB"><a href="#5-1-InnoDB" class="headerlink" title="5.1 InnoDB"></a>5.1 InnoDB</h3><p>MySQL默认的事务型存储引擎，设计用来执行大量<strong>短期事务</strong>，短期事务很少回滚。</p><p>MySQL 5.1后，新的InnoDB plugin提供很多新特性，如利用排序创建索引、删除或增加索引时不需要复制全表数据、新的支持压缩的存储格式、新的大型列值如BLOB的存储方式、以及文件格式管理等。</p><p>InnoDB：</p><ul><li>数据存储在<strong>表空间</strong>（tablespace）中，由一系列数据文件组成，InnoDB可以将每个表的数据和索引存放在单独的文件中。</li><li>采用MVCC来支持高并发，实现了四个标准的隔离级别，默认是<strong>可重复读</strong>（REPEATABLE READ），<strong>通过间隙锁策略防止幻读出现</strong>，间隙锁使InnoDB不仅锁行，还未锁定索引中的间隙以防止幻影行的插入。</li><li>表基于<strong>聚簇索引</strong>建立，主键查询有很好的性能，但其二级索引（非主键索引）必须包含主键列，若主键列很大会导致所有索引都很大（主键应尽量小一些）。</li><li>内部优化：从磁盘读取数据时采用了<strong>可预测性预读</strong>、自动在内存中创建hash索引以加速读操作的<strong>自适应哈希索引</strong>、能够加速插入操作的<strong>插入缓冲区</strong>等。</li><li>InnoDB支持热备份，如 MySQL Enterprise Backup、XtraBackup都可以实现。</li></ul><h3 id="5-2-MyISAM"><a href="#5-2-MyISAM" class="headerlink" title="5.2 MyISAM"></a>5.2 MyISAM</h3><p>支持如全文索引、压缩、空间函数等，但不支持事务和行级锁，崩溃后无法安全恢复。对于只读数据或小表且可以接受修复操作的场景仍可以继续使用该引擎。</p><p>MyISAM：</p><ul><li><strong>存储</strong>：表存储在两个文件中：数据文件和索引文件，分别以 <code>.MYD</code> 和 <code>.MYI</code> 为扩展名。</li><li><strong>加锁与并发</strong>：对整张表加锁，不能针对行；读取时对所有需要的表加共享锁，写入时则加排它锁，但允许表读取时向表中插入新纪录（<strong>允许并发插入</strong>）。</li><li><strong>修复</strong>：可以手工或自动执行检查和修复操作，修复操作可能会导致数据丢失而且执行速度很慢。<ul><li><code>CHECK TABLE mytable</code> 检查表错误。</li><li><code>REPAIR TABLE mytable</code> 修复错误。</li><li><code>myisamchk</code> 命令行工具。</li></ul></li><li><strong>索引</strong>：即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引。支持全文索引，基于分词创建的索引，可以支持复杂查询。</li><li><strong>延迟更新索引键</strong>：创建表时，若指定了 <code>DELAY_KEY_WRITE</code> 选项，在每次修改执行成功后不会马上把修改的索引数据写入磁盘，而是写入内存的键缓冲区，只有清理键缓冲区或关闭表时才写入磁盘；这种方式可以极大的提升写入性能，但在崩溃时会造成索引损坏，需要进行修复。</li><li><strong>压缩表</strong>：使用 <code>myisampack</code> 将表压缩（打包pack），压缩状态不允许修改，可以极大的减少磁盘空间占用，压缩表支持索引，但索引也是只读的。</li><li><strong>性能</strong>：数据以紧密格式存储，在某些场景下性能很好。主要问题是表锁，容易导致查询处于 Locked 状态。</li></ul><h3 id="5-3-MySQL内建其他存储引擎"><a href="#5-3-MySQL内建其他存储引擎" class="headerlink" title="5.3 MySQL内建其他存储引擎"></a>5.3 MySQL内建其他存储引擎</h3><ul><li><p><strong>Archive引擎</strong>：</p><ul><li>只支持INSERT和SELECT操作。</li><li><strong>高速插入和压缩</strong>：插入缓存所有的写，利用zli对插入的行进行压缩，比MyISAM更少的磁盘I/O。</li><li>每次查询都要执行全表扫描，适合日志和数据采集类应用。</li><li>支持行级锁和专用缓冲区，可以实现高并发的插入。</li><li>查询在返回前会阻止其他查询执行以保证一致性读。</li></ul></li><li><p><strong>Blackhole引擎</strong>：不保存任何数据，服务器会记录Blackhole表的日志，可以用于复制数据到备库或记录日志。</p></li><li><p><strong>CSV引擎</strong>：将CSV文件当做MySQL表来处理，不支持索引。可以作为一种数据交换的机制。</p></li><li><p><strong>Federated引擎</strong>：访问其他MySQL服务器的一个代理，创建一个客户端连接，并将查询传输到远程服务器执行，然后提取或发送需要的数据。市场化设计，经常有问题，默认禁用。</p></li><li><p><strong>Memory引擎</strong>：所有数据都存在内存，不需要磁盘I/O，表结构重启后仍能保留，但数据会丢失，比MyISAM要快一个数量级。</p><ul><li>支持Hash索引，只支持表级锁，不支持BLOB或TEXT类型，且行长度固定，即使指定VARCHAR实际存储时也会转换成CHAR。</li><li>MySQL执行查询时如果需要临时表来保存中间结果，内部就是使用Memory表，如果结果太大超过内存表限制或含有BLOB和TEXT字段，会转换为MyISAM表。</li></ul><p>适用场景：</p><ul><li>查找或映射表。</li><li>缓存周期性聚合数据的结果。</li><li>保存数据分析中产生的中间数据。</li></ul></li><li><p><strong>Merge引擎</strong>：由多个MyISAM表合并成的虚拟表，引入分区功能后已被废弃。</p></li><li><p><strong>NDB引擎</strong>：MySQL服务器、NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合被称为MySQL集群。</p></li></ul><h3 id="5-4-第三方存储引擎"><a href="#5-4-第三方存储引擎" class="headerlink" title="5.4 第三方存储引擎"></a>5.4 第三方存储引擎</h3><ul><li><strong>OLTP类引擎</strong>：<ul><li>Percona的XtraDB存储引擎基于InnoDB改进，可以作为InnoDB引擎的替代品</li><li>PBXT，支持ACID事务和MVCC等。</li><li>TokuDB，使用一种叫分形树的索引数据结构，是一种大数据存储引擎，拥有很高的压缩比。</li><li>RethinkDB，采用只能追加的写时复制B树作为索引的数据结构。</li></ul></li><li><strong>面向列的引擎</strong>：MySQL默认面向行，每行数据一起存储，查询也以行为单位处理。大数据量时面向列的方式可以传输更少的数据，压缩效率也更好。</li><li><strong>社区引擎</strong>：如Aria、Groonga、OQGraph、Q4M、SphinxSE、Spider、VPForMySQL等。</li></ul><h3 id="5-5-如何选择合适的存储引擎"><a href="#5-5-如何选择合适的存储引擎" class="headerlink" title="5.5 如何选择合适的存储引擎"></a>5.5 如何选择合适的存储引擎</h3><p>大部分情况选择InnoDB，除非需要用到InnoDB不具备的特性，并且没有替代方案，否则请尽量选择InnoDB引擎。</p><p>尽量不要混合使用多种存储引擎，会带来一系列复杂和预想不到的问题。</p><h3 id="5-6-转换表的存储引擎"><a href="#5-6-转换表的存储引擎" class="headerlink" title="5.6 转换表的存储引擎"></a>5.6 转换表的存储引擎</h3><ul><li><p><code>ALTER TABLE</code> ：<code>ALTER TABLE mytable ENGINE = InnoDB;</code> 需要执行较长时间，MySQL会按行将数据从原表复制到一张新表，复制期间可能会消耗系统所有I/O能力，同时对原表加上读锁。注意，即使后续再恢复原引擎，也会丢失如外键等和引擎相关的特性。</p></li><li><p><strong>导出与导入</strong>：使用 <code>mysqldump</code> 工具将数据导出到文件，修改文件中 CREATE TABLE 语句的存储引擎选项，注意修改表名（避免重复），工具默认会在 CREATE TABLE 语句前加上 DROP TABLE 可能会导致数据丢失。</p></li><li><p><strong>创建与查询</strong>：综合前两种方法，先创建一个新的存储引擎的表，然后利用 <code>INSERT...SELECT</code> 语句来导入数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">LIKE</span> myisam_table;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table;</span><br></pre></td></tr></table></figure><p>数据量大时可以考虑分批处理，针对每一段数据执行事务提交操作，避免大事务产生过多的undo。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> x <span class="keyword">AND</span> y;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>如果有必要，可以在执行时对原表加锁，以确保新表和原表数据一致。</p><p>Percona Toolkit提供了 pt-online-schema-change 工具方便简单安全的执行上述过程。</p></li></ul><h2 id="六-时间线-Timeline"><a href="#六-时间线-Timeline" class="headerlink" title="六. 时间线-Timeline"></a>六. 时间线-Timeline</h2><ul><li>版本  3.23 2001</li><li>版本  4.0   2003</li><li>版本  4.1   2005</li><li>版本  5.0   2006</li><li>版本  5.1   2008</li><li>版本  5.5   2010 ：Oracle收购，InnoDB成为默认存储引擎。</li><li>版本  5.6   </li><li>….</li></ul><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：MySQL逻辑架构，并发控制，事务，多版本并发控制，存储引擎，时间线等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构设计模式（三）进程间通信</title>
    <link href="http://linyishui.top/2020112801.html"/>
    <id>http://linyishui.top/2020112801.html</id>
    <published>2020-11-28T15:28:34.000Z</published>
    <updated>2020-12-17T14:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-微服务架构中要频繁使用进程间通信"><a href="#1-1-微服务架构中要频繁使用进程间通信" class="headerlink" title="1.1 微服务架构中要频繁使用进程间通信"></a>1.1 微服务架构中要频繁使用进程间通信</h3><p>FIGO有一个REST API供移动端和Web端使用，还使用了一些云服务如Twilio消息服务和Stripe支付服务，但在单体应用内是语言级方法或函数相互调用，除了开发API和集成云服务不会考虑<strong>进程间通信</strong>（IPC）。</p><p>微服务架构中各个服务实例通常是在多台机器上运行的进程，所以必须使用进程间通信进行交互。选择合适的进程间通信机制是一个重要的架构决策，除了影响应用的可用性，甚至还与事务管理互相影响。<strong>理想的微服务架构应该在内部由松散耦合的若干服务组成，服务间使用异步消息相互通信</strong>。</p><h3 id="1-2-常见进程间通信技术"><a href="#1-2-常见进程间通信技术" class="headerlink" title="1.2 常见进程间通信技术"></a>1.2 常见进程间通信技术</h3><p>进程间通信技术有很多：</p><ul><li>基于同步请求 / 响应的通信机制：如 HTTP REST 或 gRPC，REST（JSON）主要用于服务与外部其他应用程序的通信。</li><li>异步的基于消息的通信机制：如 AMQP 或 STOMP。</li></ul><p>消息格式也有：</p><ul><li>基于文本的 JSON 或 XML，有可读性。</li><li>基于二进制的 Avro 或 Protocol Buffers 格式，更加高效。</li></ul><h3 id="1-3-交互方式"><a href="#1-3-交互方式" class="headerlink" title="1.3 交互方式"></a>1.3 交互方式</h3><p>选择进程间通信机制要先考虑服务与其客户端的交互方式，从而可以专注于需求而不是单纯技术层面的考量，交互方式的选择会影响可用性和后续的集成测试策略。</p><p>交互方式关注两个维度：</p><ul><li>映射关系：<ul><li><strong>一对一</strong>：每个客户端由一个服务实例来处理。</li><li><strong>一对多</strong>：每个客户端由多个服务实例来处理。</li></ul></li><li>同步异步：<ul><li><strong>同步模式</strong>：客户端请求需要服务端实时响应，客户端等待响应时可能导致阻塞。</li><li><strong>异步模式</strong>：客户端请求不会阻塞进程，服务端响应可以非实时。</li></ul></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">一对一</th><th style="text-align:center">一对多</th></tr></thead><tbody><tr><td style="text-align:center">同步模式</td><td style="text-align:center">请求/响应</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">异步模式</td><td style="text-align:center">异步请求/响应<br>单向通知</td><td style="text-align:center">发布/订阅<br>发布/异步响应</td></tr></tbody></table><ul><li>一对一的交互方式：<ul><li><strong>请求/响应</strong>：一个客户端向服务端发起请求，等待响应；客户端期望服务端很快发送响应。在一个基于线程的应用中，等待过程可能造成线程阻塞，这种方式会导致服务紧耦合。</li><li><strong>异步请求/响应</strong>：客户端发送请求到服务端，服务端异步响应请求。客户端等待时不会阻塞线程，而服务端响应也不一定会马上返回。</li><li><strong>单向通知</strong>：客户端请求发送到服务端，但不期望服务端做出任何响应。</li></ul></li><li>一对多的交互方式：<ul><li><strong>发布/订阅</strong>：客户端发布通知消息，被零个或多个感兴趣的服务订阅。</li><li><strong>发布/异步响应</strong>：客户端发布请求消息，然后等待从感兴趣的服务发回的响应。</li></ul></li></ul><p>注意：底层的进程间通信技术并不会影响所选择的交互方式，可以是REST或消息机制，但选择同步请求/响应方式都会使客户端等待响应。</p><h3 id="1-4-定义API"><a href="#1-4-定义API" class="headerlink" title="1.4 定义API"></a>1.4 定义API</h3><p>设计良好的接口在暴漏有用功能的同时隐藏实现细节，实现可以被修改，但接口尽量保持不变以不对客户端产生影响。</p><p>Java是静态类型编程语言，如果接口与客户端不兼容，应用程序会无法通过编译。微服务架构的挑战是：没有一个简单的编程语言结构可以用来构造和定义服务的API。若使用不兼容的API部署新版本的服务，编译阶段不会出错，但会导致运行时故障。</p><p>使用<strong>接口定义语言</strong>（IDL）精确定义服务的API很重要，API优先设计，迭代几轮API定义后再开始具体的服务实现编程。</p><ul><li>使用消息机制，API由消息通道、消息类型和消息格式组成。</li><li>使用HTTP，API由URL、HTTP动词以及请求和响应格式组成。</li></ul><h3 id="1-5-API演化"><a href="#1-5-API演化" class="headerlink" title="1.5 API演化"></a>1.5 API演化</h3><p>微服务中API的使用者很有可能是另外的开发团队或组织外的人，不能够要求客户端跟服务端API版本保持一致，现代应用程序有着极高的可用性要求，一般会采用滚动升级的方式来更新服务，所以一个服务的新版本和旧版本肯定会共存。</p><ul><li><p><strong>语义化版本控制</strong>：是一组规则，用于指定如何使用版本号，并且以正确的方式递增版本号。</p><p>版本号由三部分组成：</p><ul><li>MAJOR：对API进行不兼容的更改时。</li><li>MINOR：对API进行向后兼容的增强时。</li><li>PATCH：进行向后兼容的错误修复时。</li></ul><p>如使用REST API时，可以使用主要版本作为URL路径的第一个元素；使用消息机制的服务，可以在发布的消息中包含版本号。</p></li><li><p><strong>进行次要并且向后兼容的改变</strong>：向后兼容是对API的附加更改或功能增强。</p><ul><li>客户端和服务端应该遵守健壮性原则，服务为缺少的请求属性提供默认值，客户端忽略额外的响应属性。</li></ul></li><li><p><strong>进行主要并且不向后兼容的改变</strong>：因为无法强制客户端升级，所以需要在一段时间内同时支持新旧版本的API。</p><ul><li>使用基于HTTP的进程间通信机制，如REST，可以在URL中嵌入主要版本号，版本1对应 <code>/v1/...</code> 和 版本2对应 <code>/v2/...</code> 为前缀。</li></ul></li></ul><h3 id="1-6-消息格式"><a href="#1-6-消息格式" class="headerlink" title="1.6 消息格式"></a>1.6 消息格式</h3><ul><li>基于文本：消息过度冗长，解析文本引入了额外开销。<ul><li>XML：相比JSON更长。</li><li>JSON</li></ul></li><li>基于二进制：提供了一个强类型定义的IDL（接口描述文件），用于定义消息的格式。编译器自动根据格式生成序列化和反序列化代码。<ul><li>Protocol Buffers：使用tagged fields，带标记的字段。</li><li>Avro：其消费者在解析消息前要知道格式。</li></ul></li></ul><h2 id="二-基于同步远程过程调用模式的通信"><a href="#二-基于同步远程过程调用模式的通信" class="headerlink" title="二. 基于同步远程过程调用模式的通信"></a>二. 基于同步远程过程调用模式的通信</h2><p>基于同步远程过程调用（RPI）的通信机制中，客户端假定消息将及时到达。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010131.jpg" alt></p><p>代理接口通常封装底层通信协议，可以选如REST何gRPC等。</p><h3 id="2-1-REST"><a href="#2-1-REST" class="headerlink" title="2.1 REST"></a>2.1 REST</h3><h4 id="2-1-1-RESTful风格"><a href="#2-1-1-RESTful风格" class="headerlink" title="2.1.1 RESTful风格"></a>2.1.1 RESTful风格</h4><p>REST是一种总是使用HTTP协议的进程间通信机制，提供了一系列架构约束，强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，其强化了安全性也能封装遗留系统。</p><p>REST使用<strong>资源</strong>表示单个业务对象，使用<strong>HTTP动词</strong>来操作资源，使用<strong>URL</strong>引用资源。</p><ul><li>GET获取资源</li><li>POST创建资源</li><li>PUT更新资源</li><li>DELETE删除资源</li></ul><h4 id="2-1-2-成熟度模型"><a href="#2-1-2-成熟度模型" class="headerlink" title="2.1.2 成熟度模型"></a>2.1.2 成熟度模型</h4><ul><li>Level 0：客户端只是向服务端点发起HTTP POST请求，进行服务调用。每个请求指明了需要执行的操作、针对的目标和必要的参数。</li><li>Level 1：该层级引入资源的概念，客户端需要发出指定要执行的操作和包含任何参数的POST请求。</li><li>Level 2：使用HTTP动词来执行操作，请求查询参数和主体指定操作的参数，这能够让服务借助Web基础设施服务，如通过CDN缓存GET请求。</li><li>Level 3：基于HATEOAS（Hypertext As The Engine Of Application State）原则设计，基本思想是由GET请求返回的资源信息中包含链接，链接能够执行该资源允许的操作。如客户端通过订单资源包含的链接取消某一订单或获取该订单详情。优点包括无需在客户端代码中写入硬链接的URL，因为资源包括允许操作的链接，客户端无需猜测在当前状态应执行何操作。</li></ul><h4 id="2-1-3-需要解决的问题"><a href="#2-1-3-需要解决的问题" class="headerlink" title="2.1.3 需要解决的问题"></a>2.1.3 需要解决的问题</h4><ul><li>在一个请求中获取多个资源：<ul><li>API允许获取资源时检索相关资源，如 <code>GET/orders/order-id-1345?expand=consumer</code> 检索order和consumer。但对于复杂的场景不太适用。</li><li>GraphQL 和 Netflix Falcor 实现了高效的数据获取。</li></ul></li><li>把操作映射为HTTP动词：有可能有多种更新操作，如取消或修改订单。<ul><li>使用子资源，如 <code>POST/orders/{orderId}/cancel</code> 和 <code>POST/orders/{orderId}/revise</code>  端点。</li><li>将动词指定为URL的查询参数。</li><li>此两种解决方案都有些违背了RESTful的要求。</li></ul></li></ul><h4 id="2-1-4-优缺点"><a href="#2-1-4-优缺点" class="headerlink" title="2.1.4 优缺点"></a>2.1.4 优缺点</h4><p>优点：</p><ul><li>简单直观</li><li>可以使用浏览器扩展（如Postman插件）或 curl 之类的命令行来测试HTTP API</li><li>直接支持请求 / 响应方式的通信</li><li>HTTP对防火墙友好</li><li>不需要中间代理，简化了系统架构</li></ul><p>缺点：</p><ul><li>只支持请求 / 响应方式的通信</li><li>可能导致可用性降低。由于客户端和服务直接通信，而未通过代理缓冲消息，二者在调用期间都要保持在线。</li><li>客户端必须知道服务实例的位置-URL，但现代应用要求客户端必须使用<strong>服务发现机制</strong>来定位服务实例。</li><li>在单个请求中获取多个资源具有挑战性。</li><li>很难将多个更新操作映射为HTTP动词。</li></ul><h3 id="2-2-gRPC"><a href="#2-2-gRPC" class="headerlink" title="2.2 gRPC"></a>2.2 gRPC</h3><p>gRPC是一个用于编写跨语言客户端和服务端的框架，是一种基于二进制消息的协议，所以必须采用API优先的服务设计方法。</p><p>可以使用Protocol Buffer的IDL定义gRPC的API，是谷歌公司用于序列化结构化数据的一套语言中立机制，使用Protocol Buffer编译器生成客户端的<strong>桩</strong>（sub，也叫存根）和服务器<strong>骨架</strong>（skeleton），支持如Java、C#、Node.js 和 Golang等。<strong>客户端和服务端使用 HTTP/2 以Protocol Buffer格式交换二进制消息</strong>。</p><p>gRPC API 由一个或多个服务和请求/响应消息定义组成。服务定义类似于Java接口，是强类型方法的集合，支持请求/响应RPC和流式RPC。服务器可以使用消息流回复客户端，客户端也可以向服务器发送消息流。</p><p>Protocol Buffers是一种高效的二进制消息格式，消息的每个字段都有编号和一个类型代码；消息接收方可以提取所需字段，跳过无法识别的字段。因此特性gRPC API可以保持向后兼容的同时进行变更。</p><p>如OrderService的gRPC API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateOrderRequest和CreateOrderReply是具有类型的消息</span></span><br><span class="line">service OrderService &#123;</span><br><span class="line">    <span class="function">rpc <span class="title">createOrder</span><span class="params">(CreateOrderRequest)</span> <span class="title">returns</span> <span class="params">(CreateOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">rpc <span class="title">cancelOrder</span><span class="params">(CancelOrderRequest)</span> <span class="title">returns</span> <span class="params">(CancelOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">rpc <span class="title">reviseOrder</span><span class="params">(ReviseOrderRequest)</span> <span class="title">returns</span> <span class="params">(ReviseOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateOrderRequest &#123;</span><br><span class="line">    int64 restaurantId = <span class="number">1</span>;</span><br><span class="line">    int64 consumerId = <span class="number">2</span>;</span><br><span class="line">    repeated LineItem lineItems = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LineItem &#123;</span><br><span class="line">    string menuItemId = <span class="number">1</span>;</span><br><span class="line">    int32 quantity = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateOrderReply &#123;</span><br><span class="line">    int64 orderId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>设计具有复杂更新操作的API很简单</li><li>具有高效、紧凑的进程间通信机制，特别是交换大量消息时</li><li>支持在远程过程调用和消息传递过程中使用双向流式消息方式</li><li>实现了客户端和各种语言编写的服务端之间的互操作性</li></ul><p>缺点：</p><ul><li>与基于REST/JSON的API机制相比，JavaScript客户端使用基于gRPC的API需要做更多工作</li><li>旧式防火墙可能不支持HTTP/2</li></ul><h3 id="2-3-使用断路器模式处理局部故障"><a href="#2-3-使用断路器模式处理局部故障" class="headerlink" title="2.3 使用断路器模式处理局部故障"></a>2.3 使用断路器模式处理局部故障</h3><p>服务间通信总是无法避免会遇到局部故障，可以通过断路器模式来应对故障。</p><p>断路器模式：<strong>远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内，这个代理会立即拒绝其他调用</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010132.jpg" alt></p><p>OrderServiceProxy会无限期阻塞，等待响应，在带来糟糕体验的同时，消耗如线程等宝贵资源，最终API Gateway 将耗尽资源无法处理请求，整个API都不可用。</p><p>解决此问题：</p><ul><li><p><strong>开发可靠的远程过程调用代理</strong>：如 Netflix Hystrix 等开源库。</p><p>当服务同步调用一个服务时，需要保证：</p><ul><li><strong>网络超时</strong>：等待请求的响应时，不要无限阻塞，设定一个超时，保证不会一直在无响应的请求上浪费资源。</li><li><strong>限制客户端向服务器发出请求的数量</strong>：对特定请求服务设置上限，达到上限后新的请求会立即失败。</li><li><strong>断路器模式</strong>：监控客户端发出请求的成功和失败数目，失败比例超过阈值，启动断路器，让后续调用立即失效。大量的请求失败表示被调服务不可用，即使再发送请求也无济于事，而是经过一段时间后再尝试，若请求成功则解除断路器。</li></ul></li><li><p><strong>从服务失效故障中恢复</strong>：</p><p>根据具体情况选择如何从无响应的远程服务中恢复服务：</p><ul><li>返回错误：如图 3-3 创建Order失败时，只能将失败返回给移动端。</li><li>返回备用值：如图 3-3 使用API组合模式实现，调用了多个服务并将结果组合在一起。结果的重要性不同，如Order服务不可用时要返回其数据的缓存版本或错误信息；其他则不重要，可以返回缓存版本或忽略。</li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010133.jpg" alt></p><h3 id="2-4-服务发现"><a href="#2-4-服务发现" class="headerlink" title="2.4 服务发现"></a>2.4 服务发现</h3><h4 id="2-4-1-为什么需要服务发现？"><a href="#2-4-1-为什么需要服务发现？" class="headerlink" title="2.4.1 为什么需要服务发现？"></a>2.4.1 为什么需要服务发现？</h4><p>发送请求需要知道服务实例的网络位置，现代基于云的微服务应用程序中，服务实例具有动态分配的IP地址，还会因为自动扩展、故障和升级等导致服务实例集动态修改。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010134.jpg" alt></p><h4 id="2-4-2-服务发现机制会做什么？"><a href="#2-4-2-服务发现机制会做什么？" class="headerlink" title="2.4.2 服务发现机制会做什么？"></a>2.4.2 服务发现机制会做什么？</h4><p>服务发现的关键组件是服务注册表，是包含服务实例网络位置信息的数据库。服务实例启动和停止时，服务发现机制都会更新服务注册表，客户端调用服务时，服务发现机制会查询服务注册表获取服务实例的列表，并将请求路由到其中一个服务实例。</p><h4 id="2-4-3-实现方式"><a href="#2-4-3-实现方式" class="headerlink" title="2.4.3 实现方式"></a>2.4.3 实现方式</h4><ul><li>服务及其客户直接与服务注册表交互；</li><li>通过部署基础设施来处理服务发现。</li></ul><h4 id="2-4-4-应用层服务发现模式"><a href="#2-4-4-应用层服务发现模式" class="headerlink" title="2.4.4 应用层服务发现模式"></a>2.4.4 应用层服务发现模式</h4><p>服务实例使用服务注册表来注册网络位置，客户端先查询表获取信息再向其中一个实例发送请求。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010135.jpg" alt></p><ul><li><strong>自注册模式</strong>：服务实例向服务注册表注册自己，服务注册表定期调用<strong>运行状况检查</strong>端点来验证服务实例是否正常且能接收请求，服务实例要定期调用心跳API以防止注册过期。</li><li><strong>客户端发现模式</strong>：客户端从服务注册表检索可用服务实例的列表，客户端可以缓存服务实例，并且使用负载均衡算法来选择服务实例。</li></ul><p>应用层服务发现工具：Spring Cloud默认使用Eureka进行服务发现。</p><ul><li>Eureka：高可用的注册中心</li><li>Ribbon：Eureka的 HTTP 客户端</li></ul><p>优点：</p><ul><li>服务发现与部署平台无关，可以解决多平台部署问题。如同时使用Kubernetes和遗留环境，基于Eureka能同时适用二者，而基于平台的服务发现只能用于Kubernetes平台。</li></ul><p>弊端：</p><ul><li>需要为每种编程语言提供服务发现库，Spring Cloud 只能服务于 Spring 开发，如 Node.js 或 Golang 需要相应的服务发现框架。</li><li>开发者负责设置和管理服务注册表，最好使用部署基础设施提供的服务发现机制。</li></ul><h4 id="2-4-5-平台层服务发现模式"><a href="#2-4-5-平台层服务发现模式" class="headerlink" title="2.4.5 平台层服务发现模式"></a>2.4.5 平台层服务发现模式</h4><p>现代部署平台，如Docker和Kubernetes都有内置的服务注册表和服务发现机制。平台为每个服务提供DNS名称、虚拟IP地址（VIP地址）和解析为VIP地址的DNS名称。客户端向DNS名称和VIP发出请求，部署平台自动将请求路由到其中一个可用实例，整个流程完全由平台处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010136.jpg" alt></p><ul><li><strong>第三方注册模式</strong>：由注册服务器（第三方）负责处理注册，服务不用再自己注册。</li><li><strong>服务端发现模式</strong>：客户端不需要查询注册表，而是向DNS名称发出请求，对此名称的请求会解析到路由器，路由器查询服务注册表并对请求进行负载均衡。</li></ul><p>优点：</p><ul><li>服务和客户端不需包含服务发现代码，不论任何语言和框架都可以使用。</li></ul><p>弊端：</p><ul><li>仅限于使用此平台部署的服务，但尽管如此还是推荐平台提供的服务发现。</li></ul><h2 id="三-基于异步消息模式的通信"><a href="#三-基于异步消息模式的通信" class="headerlink" title="三. 基于异步消息模式的通信"></a>三. 基于异步消息模式的通信</h2><p>使用消息机制时，服务之间的通信采用异步交换消息的方式完成。</p><p>实现方案：</p><ul><li>通常会使用<strong>消息代理</strong>，它充当服务之间的中介。</li><li><strong>无代理架构</strong>，直接向服务发送消息，因为通信是异步的，所有客户端不会堵塞和等待回复。</li></ul><h3 id="3-1-消息传递"><a href="#3-1-消息传递" class="headerlink" title="3.1 消息传递"></a>3.1 消息传递</h3><p>消息通过消息通道进行交换，发送方将消息写入通道，接受方从通道读取消息：</p><ul><li><p><strong>消息</strong>：</p><ul><li>组成结构：消息头部 + 消息主体。</li><li>内容：<ul><li>标题：名称与值对的集合，描述正在发送的数据的元数据。</li><li>消息ID：唯一标识。</li><li>返回地址：指定发送回复的消息通道。</li><li>正文：文本或二进制格式的数据。</li></ul></li><li>消息类型：<ul><li>文档：仅包含数据的通用消息。</li><li>命令：一条等同于RPC请求的消息，指定要调用的操作及参数。</li><li>事件：标识发送方发生了重要事件，通常是领域事件，表示领域对象状态更改。</li></ul></li></ul></li><li><p><strong>消息通道</strong>：消息传递基础设施的抽象。</p><ul><li>消息通道类型：<ul><li><strong>点对点通道</strong>：向正在从通道读取的一个消费者传递消息，实现一对一交互方式，常用于命令式消息。</li><li><strong>发布-订阅通道</strong>：将一条消息发给所有订阅的接收方，实现一对多交互方式，常用于事件式消息。</li></ul></li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010137.jpg" alt></p><h3 id="3-2-使用消息机制实现交互方式"><a href="#3-2-使用消息机制实现交互方式" class="headerlink" title="3.2 使用消息机制实现交互方式"></a>3.2 使用消息机制实现交互方式</h3><p>消息机制本质是异步的，只提供异步请求/响应，客户端和服务端通过交换一对消息来实现异步请求/响应方式的交互。</p><p>如下图，客户端发送命令式消息，内容通过服务拥有的点对点消息通道传递，服务处理请求后将包含结果的回复消息发送到客户端拥有的点对点通道。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010138.jpg" alt></p><p>客户端必须告诉服务发送回复消息的位置，并且要对回复和请求进行匹配。msgId叫相关性ID，用来匹配二者。</p><p>消息机制可以实现的交互方式：</p><ul><li><strong>实现请求/响应和异步请求/响应</strong>，前者期望立即响应。</li><li><strong>实现单向通知</strong>：客户端将消息发送到服务所拥有的点对点通道，服务订阅并处理消息，但并不回复。</li><li><strong>实现发布/订阅</strong>：客户端将消息发布到由多个接收方读取的发布/订阅通道，微服务中可以用发布/订阅来发布领域事件，如OrderService将Order事件发布到Order通道，对特定领域事件感兴趣的服务只要订阅即可。</li><li><strong>实现发布/异步响应</strong>：是发布/订阅和请求/响应两种方式的元素组合在一起，客户端发布一条消息，在消息的头部中指定<strong>回复通道</strong>（同时也是一个发布-订阅通道）。消费者将包含<strong>相关性ID</strong>的回复消息写入回复通道，客户端通过相关性ID来收集响应，以此将回复消息与请求匹配。</li></ul><h3 id="3-3-为基于消息机制的服务API创建API规范"><a href="#3-3-为基于消息机制的服务API创建API规范" class="headerlink" title="3.3 为基于消息机制的服务API创建API规范"></a>3.3 为基于消息机制的服务API创建API规范</h3><p>服务的异步API包含供客户端调用的操作和由服务对外发布的事件：</p><ul><li>记录异步操作：<ul><li>请求/异步响应式API：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式，以及服务发送的回复消息的类型和格式。</li><li>单向通知式API：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式。</li></ul></li><li>记录事件发布：服务还可以使用发布/定义的方式对外发布事件，API风格的规范包括事件通道以及服务发布到通道的事件式消息的类型和格式。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010139.jpg" alt></p><h3 id="3-4-使用消息代理"><a href="#3-4-使用消息代理" class="headerlink" title="3.4 使用消息代理"></a>3.4 使用消息代理</h3><p>消息代理，即服务通信的基础设施服务。除了消息代理架构，还有基于无代理的消息传递架构，其中服务相互通信。二者各有利弊，通常会选择消息代理架构。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010140.jpg" alt></p><ul><li><p>无代理消息：服务直接交换消息</p><ul><li>ZeroMQ是一种流行的无代理消息技术，支持各种传输协议（如TCP、UNIX）风格的套接字和多播。</li><li>优点：<ul><li>允许更轻的网络流量和更低的延迟，因为消息直接从发送方到接收方，少了一层代理；</li><li>消除了消息代理可能成为性能瓶颈或单点故障的可能性；</li><li>具有较低的操作复杂性，因为不需要设置和维护消息代理。</li></ul></li><li>缺点：<ul><li>服务需要知道彼此的位置，必须使用服务发现机制。</li><li>会导致可用性降低，因为在交换消息时，消息的发送方和接收方必须同时在线。</li><li>在实现例如确保消息能够成功投递这些复杂功能时的挑战性更大。</li></ul></li><li>这些弊端和同步请求响应的交互方式相同，所以大多数企业应用选择基于消息代理的架构。</li></ul></li><li><p>基于代理的消息：消息代理作为所有消息的中介节点。</p><ul><li><p>开源消息代理技术：</p><ul><li>Apache ActiveMQ</li><li>RabbitMQ</li><li>Apache Kafka</li><li>AWS Kinesis 和 AWS SQS ：基于云的消息服务。</li></ul></li><li><p>优点：</p><ul><li>发送方不需知道接收方的网络位置。</li><li>消息代理可以缓冲消息，直到接收方能够处理它们。</li></ul></li><li>需要考虑：<ul><li>支持的编程语言</li><li>支持的消息标准：如AMQP何STOMP</li><li>消息排序</li><li>投递保证</li><li>持久性：消息能否持久化到磁盘并在代理崩溃时恢复</li><li>耐久性：接收方重连到消息代理，是否会收到断开连接时发送的消息</li><li>可扩展性</li><li>延迟</li><li>竞争性（并发）接收方</li></ul></li><li>每种消息代理只能尽量侧重以上的几点，需要根据场景需求选择合适的消息代理。</li></ul></li></ul><p>使用消息代理实现消息通道：</p><ul><li>ActiveMQ等JMS消息代理具有队列和主题；</li><li>RabbitMQ等基于AMQP的消息代理具有交换和队列；</li><li>Kafka有主题；</li><li>AWS Kinesis有流</li><li>AWS SQS有队列。</li></ul><table><thead><tr><th>消息代理</th><th>点对点通道</th><th>发布-订阅通道</th></tr></thead><tbody><tr><td>JMS</td><td>队列</td><td>主题</td></tr><tr><td>Kafka</td><td>主题</td><td>主题</td></tr><tr><td>AMQP</td><td>队列</td><td>组播式交换和每客户端队列</td></tr><tr><td>AWS Kinesis</td><td>流</td><td>流</td></tr><tr><td>AWS SQS</td><td>队列</td><td>/</td></tr></tbody></table><p>只有AWS SQS只支持点对点通道，其余都支持发布-订阅通道。</p><p>消息代理的优点：</p><ul><li>松耦合：</li><li>消息缓存</li><li>灵活的通信</li><li>明确的进程间通信</li></ul><p>消息代理的缺点：</p><ul><li>潜在的性能瓶颈</li><li>潜在的单点故障</li><li>额外的操作复杂性</li></ul><h3 id="3-5-处理并发和消息顺序"><a href="#3-5-处理并发和消息顺序" class="headerlink" title="3.5 处理并发和消息顺序"></a>3.5 处理并发和消息顺序</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010141.jpg" alt></p><h3 id="3-6-处理重复消息"><a href="#3-6-处理重复消息" class="headerlink" title="3.6 处理重复消息"></a>3.6 处理重复消息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010142.jpg" alt></p><h3 id="3-7-事务性消息"><a href="#3-7-事务性消息" class="headerlink" title="3.7 事务性消息"></a>3.7 事务性消息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010143.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010144.jpg" alt></p><h3 id="3-8-消息相关类库和框架"><a href="#3-8-消息相关类库和框架" class="headerlink" title="3.8 消息相关类库和框架"></a>3.8 消息相关类库和框架</h3><h2 id="四-使用异步消息提供可用性"><a href="#四-使用异步消息提供可用性" class="headerlink" title="四. 使用异步消息提供可用性"></a>四. 使用异步消息提供可用性</h2><h3 id="4-1-同步消息会降低可用性"><a href="#4-1-同步消息会降低可用性" class="headerlink" title="4.1 同步消息会降低可用性"></a>4.1 同步消息会降低可用性</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010145.jpg" alt></p><h3 id="4-2-消除同步交互"><a href="#4-2-消除同步交互" class="headerlink" title="4.2 消除同步交互"></a>4.2 消除同步交互</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010146.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010147.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010148.jpg" alt></p><hr><p>参考：</p><p>🔗 《微服务架构设计模式》</p>]]></content>
    
    <summary type="html">
    
      《微服务架构设计模式》读书笔记，内容：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="microservice" scheme="http://linyishui.top/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构设计模式（二）服务的拆分策略</title>
    <link href="http://linyishui.top/2020111001.html"/>
    <id>http://linyishui.top/2020111001.html</id>
    <published>2020-11-10T12:07:16.000Z</published>
    <updated>2020-11-26T13:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="服务的拆分策略"><a href="#服务的拆分策略" class="headerlink" title="服务的拆分策略"></a>服务的拆分策略</h1><h2 id="第一节-微服务架构是什么？"><a href="#第一节-微服务架构是什么？" class="headerlink" title="第一节 微服务架构是什么？"></a>第一节 微服务架构是什么？</h2><h3 id="1-1-软件架构是什么？"><a href="#1-1-软件架构是什么？" class="headerlink" title="1.1 软件架构是什么？"></a>1.1 软件架构是什么？</h3><p><strong>软件架构</strong>是一种抽象的结构，由软件的各个组成部分和它们之间的依赖关系构成。<strong>计算机系统的软件架构是构建这个系统所需要的一组结构，包含软件元素、它们之间的关系以及两者的属性</strong>。</p><p>将软件分解成元素和定义这些元素之间的关系，决定了软件的能力。</p><p>应用程序有两个层次的需求：<strong>功能性需求</strong>和<strong>质量性需求</strong>，后者决定一个应用在运行和开发时的质量，由所选择的软件架构决定。</p><h3 id="1-2-软件架构的-4-1-视图模型"><a href="#1-2-软件架构的-4-1-视图模型" class="headerlink" title="1.2 软件架构的 4 + 1 视图模型"></a>1.2 软件架构的 4 + 1 视图模型</h3><p>软件架构可以像建筑一样有多个架构视角（+1指场景，把视图串联在一起）：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010108.jpg" alt></p><p>每个视图的目的：</p><ul><li>逻辑视图：开发人员创建的元素，在面向对象语言中是类（Class）和包（Package），关系包括继承、关联和依赖。</li><li>实现视图：构建编译系统的输出，组件是由一个或多个模块组成的可执行或可部署单元。在Java中模块是JAR文件，组件是WAR文件或可执行JAR文件；关系包括模块间的依赖关系和组件模块间的组合关系。</li><li>进程视图：运行时的组件，元素是进程，进程间关系即进程间通信。</li><li>部署视图：进程如何映射到机器，元素由计算机和进程组成，机器之间的关系即网络。</li></ul><h3 id="1-3-架构的风格"><a href="#1-3-架构的风格" class="headerlink" title="1.3 架构的风格"></a>1.3 架构的风格</h3><p>分层架构将软件元素按层的方式组织，每层都有自己的职责，上一层只能依赖于下方的层。</p><p>应用程序可以根据分层结构分为：</p><ul><li>表现层</li><li>业务逻辑层</li><li>数据持久化层</li></ul><p>但表现层无法体现应用可能由多个系统调用的情况，持久化层也无法体现多个数据库交互，业务逻辑层实际上也并不一定依赖于数据持久化层。</p><p>六边形结构是分层结构的替代架构：业务逻辑不再依赖于适配器，而是相反适配器都依赖于业务逻辑。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010109.jpg" alt></p><ul><li>入栈端口是业务逻辑公开的API，外部程序都可以调用它。</li><li><p>出栈端口是业务逻辑调用外部系统的方式，比如存储接口定义了一系列数据访问操作。</p></li><li><p>入栈适配器调用入栈端口处理外部的请求，Spring MVC Controller 或 订阅消息的消息代理客户端。</p></li><li>出栈适配器调用外部应用或服务处理业务逻辑的请求，如数据访问对象（DAO）类或调用远程服务的代理类。</li></ul><h3 id="1-4-微服务架构风格"><a href="#1-4-微服务架构风格" class="headerlink" title="1.4 微服务架构风格"></a>1.4 微服务架构风格</h3><p>单体架构是一种架构风格，实现视图是单个组件，将应用构建为单个可执行或可部署组件。</p><p>微服务架构是一种架构风格，实现视图由多个组件构成，将应用构建为松耦合、可独立部署的一组服务。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010110.jpg" alt></p><h4 id="1-4-1-什么是服务？"><a href="#1-4-1-什么是服务？" class="headerlink" title="1.4.1 什么是服务？"></a>1.4.1 什么是服务？</h4><p>单一的、可独立部署的软件组件就是服务，其API封装了内部实现，强制实现了应用程序的模块化。每个服务都有自己的架构甚至技术栈，往往都是六边形架构，业务逻辑和适配器交互。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010111.jpg" alt></p><h4 id="1-4-2-什么是松耦合？"><a href="#1-4-2-什么是松耦合？" class="headerlink" title="1.4.2 什么是松耦合？"></a>1.4.2 什么是松耦合？</h4><p>服务自身的持久化数据就像类的私有属性一样被封装，这样开发者就可以任意修改服务的数据结构而不用担心影响到别的服务。</p><h4 id="1-4-3-共享类库的角色"><a href="#1-4-3-共享类库的角色" class="headerlink" title="1.4.3 共享类库的角色"></a>1.4.3 共享类库的角色</h4><p>开发时会把常用的功能打包以便多个应用可以重用，而不必复制代码，这是减少重复代码的好方法，但有可能会意外的在服务之间引入耦合。</p><p>把可能会变更的功能作为服务来实现（如业务功能），而不变的可以打包成库。</p><h4 id="1-4-4-服务大小并不重要"><a href="#1-4-4-服务大小并不重要" class="headerlink" title="1.4.4 服务大小并不重要"></a>1.4.4 服务大小并不重要</h4><p>“微”并不特指服务很小，更多的含义应该是单一，我们需要能够识别服务，并确定它们之间如何协作。</p><h2 id="第二节-为应用程序定义微服务架构"><a href="#第二节-为应用程序定义微服务架构" class="headerlink" title="第二节 为应用程序定义微服务架构"></a>第二节 为应用程序定义微服务架构</h2><p>定义程序架构和软件开发一样，没有一个机械化的流程可以保证输出一个合理的架构，我们只能使用一些不断迭代和创新的方法：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010112.jpg" alt></p><p>大致流程：</p><ul><li>第一步将应用程序的需求提炼为各种<strong>系统操作</strong>，是程序必须要处理的请求。</li><li>第二步确定如何<strong>分解服务</strong>。</li><li>第三步<strong>确定每个服务的API</strong>。将每个系统操作分配给服务，服务可以独立或协作实现操作。</li></ul><p>服务分解的几个障碍：</p><ul><li><strong>网络延迟</strong>：服务间往返太多会出现问题。</li><li><strong>同步通信</strong>：服务间的同步通信会降低可用性，需要使用<strong>自包含服务</strong>。</li><li><strong>跨服务的数据一致性</strong>：使用<strong>Saga</strong>。</li><li><strong>上帝类</strong>（God Class）：使用<strong>领域驱动设计</strong>（DDD）消除上帝类。</li></ul><h3 id="2-1-识别系统操作"><a href="#2-1-识别系统操作" class="headerlink" title="2.1 识别系统操作"></a>2.1 识别系统操作</h3><p>第一步创建由关键类组成的抽象领域模型，关键类提供用于描述系统操作的词汇表。第二步确定系统操作，根据领域模型描述每个系统操作的行为。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010113.jpg" alt></p><p>领域模型来源于用户故事中的名词，系统操作来源于动词。</p><h4 id="（1）创建抽象领域模型"><a href="#（1）创建抽象领域模型" class="headerlink" title="（1）创建抽象领域模型"></a>（1）创建抽象领域模型</h4><p>通过需求整理用户故事，从中提炼得到：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010114.jpg" alt></p><p>每个类的作用：</p><ul><li>Consumer：下订单的用户。</li><li>Order：用户下的订单，描述订单信息并跟踪状态。</li><li>OrderLineItem：订单的一个条目。</li><li>DeliveryInfo：送餐的时间和地址。</li><li>Restaurant：餐馆，准备生产订单，同时要发起送货。</li><li>MenuItem：餐馆菜单的一个条目。</li><li>Courier：送餐员负责把订单送到用户手里，可跟踪送餐员可用性和位置。</li><li>Address：用户和餐馆的地址。</li><li>Location：送餐员当前经纬度。</li></ul><h4 id="（2）定义系统操作"><a href="#（2）定义系统操作" class="headerlink" title="（2）定义系统操作"></a>（2）定义系统操作</h4><p>系统操作包括：</p><ul><li>命令型：创建、更新或删除数据的系统操作。</li><li>查询型：查询和读取数据的系统操作。</li></ul><p>分析用户故事中的动词，识别系统指令：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010121.jpg" alt></p><p>命令规范定义了命令对应的参数、返回值和领域模型类的行为，行为规范包括前置条件和后置条件：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010122.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010123.jpg" alt></p><p>抽象的领域模型和系统操作可以回答这个应用是做什么的问题，每一个系统操作的行为都通过领域模型的方式来描述。</p><h3 id="2-2-根据业务能力进行服务拆分"><a href="#2-2-根据业务能力进行服务拆分" class="headerlink" title="2.2 根据业务能力进行服务拆分"></a>2.2 根据业务能力进行服务拆分</h3><h4 id="（1）什么是业务能力？"><a href="#（1）什么是业务能力？" class="headerlink" title="（1）什么是业务能力？"></a>（1）什么是业务能力？</h4><p>业务能力：指一些能够为公司产生价值的商业活动。</p><p>组织的业务能力指组织的业务是什么，这通常是固定的，而组织采用何种方式来实现其业务能力往往是不断变化的。每个组织有哪些业务能力，通过对组织的目标、结构和商业流程的分析得来。每个业务都可以看作是一个服务，除非只面向业务而非技术。</p><p>业务能力集中在业务对象上，如理赔业务对象是理赔管理功能的重点，能力又可以划分为子能力，理赔管理又包括理赔信息管理、理赔审核和理赔付款管理。</p><blockquote><p>FTGO的业务能力：</p><ul><li>供应商管理<ul><li>Courier management：送餐员相关信息管理</li><li>Restaurant information management：餐馆菜单和其他信息管理（如营业地址和时间）</li></ul></li><li>消费者管理<ul><li>消费者有关信息的管理</li></ul></li><li>订单获取和履行<ul><li>Order management：让消费者可以创建和管理订单</li><li>Restaurant order management：让餐馆可以管理订单的生产过程</li><li>送餐管理</li><li>Courier availability management：送餐员实时状态</li><li>Delivery management：把订单送到用户手中</li></ul></li><li>会计记账<ul><li>Consumer accounting：管理跟消费者相关的会计记账</li><li>Restaurant accounting：管理跟餐馆相关的会计记账</li><li>Courier accounting：管理跟送餐员相关的会计记账</li></ul></li><li>其他</li></ul></blockquote><h4 id="（2）根据业务能力映射到服务"><a href="#（2）根据业务能力映射到服务" class="headerlink" title="（2）根据业务能力映射到服务"></a>（2）根据业务能力映射到服务</h4><p>确定了业务能力后可以为每个能力定义服务，能力有级别划分，哪层级别映射到服务是很主观的判断，有以下理由：</p><ul><li>供应商管理映射到两个服务，因为餐馆和送餐员是完全不同的供应商。</li><li>订单获取和履行映射到三个服务，每个服务负责流程的不同阶段。其中送餐员可用性管理和交付管理结合在一起，映射到单个服务，因为二者交织在一起。</li><li>会计记账能力映射到一个独立服务，不同类型的会计也很相似。</li></ul><p>如下图所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010124.jpg" alt></p><p>架构定义流程的一个重要步骤是调查服务如何在每个关键架构服务中协作，比如你发现由于过多的进程间通信导致特定的分解效率低下，导致必须要把一些服务组合在一起。而在复杂性方面则会增长到很值得拆分的程度。</p><h3 id="2-3-根据DDD子域进行服务拆分"><a href="#2-3-根据DDD子域进行服务拆分" class="headerlink" title="2.3 根据DDD子域进行服务拆分"></a>2.3 根据DDD子域进行服务拆分</h3><p>DDD通过定义多个领域模型解决传统模型难以让所有团队保持一致的难题（如术语），每个领域模型都有明确的范围。</p><ul><li><strong>子域</strong>：领域驱动为每个子域定义单独的领域模型，领域用来描述应用程序问题域的一个术语。识别子域和识别业务能力一样，分析业务并识别业务的不同专业领域，如FTGO的子域有（订单获取、订单管理、餐馆管理、送餐与会计）</li><li><strong>限界上下文</strong>（bounded context）：领域模型的边界被称为限界上下文，包括实现这个模型的代码集合。</li></ul><p>通过DDD的方式定义一个个子域，并把每个子域对应为对应的一个服务，从而完成微服务的设计工作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010125.jpg" alt></p><h3 id="2-4-拆分的原则"><a href="#2-4-拆分的原则" class="headerlink" title="2.4 拆分的原则"></a>2.4 拆分的原则</h3><p>面向对象的设计原则也可以应用于微服务架构：</p><ul><li><strong>单一职责原则</strong>（SRP）：每个类都应该只有一个职责，这样就只有一个理由对它进行修改。多个职责就会使类变得不稳定，对于微服务而言就如FTGO中为客户获取餐食中每个方面（订单获取、订单准备、送餐）都由单一的服务承载。</li><li><strong>闭包原则</strong>（CCP）：在包中所包含的类都是对同类变化的集合，如果要对包进行修改，需要调整的类都应该在包内。若两个类的修改必须耦合的先后发生，它们应该在同一个包内，这样开发者只须对一个交付包进行修改，而不是大规模的修改整个应用。对于微服务架构，CCP是解决分布式单体的利器。</li></ul><h3 id="2-5-拆分单体应用为服务的难点"><a href="#2-5-拆分单体应用为服务的难点" class="headerlink" title="2.5 拆分单体应用为服务的难点"></a>2.5 拆分单体应用为服务的难点</h3><ul><li><strong>网络延迟</strong>：<ul><li>问题：服务分解导致两个服务间大量的往返调用。</li><li>解决：可以通过批处理一次往返多个对象，或者把多个相关服务组合用编程语言的函数调用代替高昂的进程间通信来解决。</li></ul></li><li><strong>同步进程间通信导致可用性降低</strong>：<ul><li>问题：如新增订单 <code>createOrder()</code> 通常让 OrderService 使用REST同步调用其他服务，REST这样的协议会降低服务可用性，任一被调用服务不在可用状态就导致订单无法创建。</li><li>解决：异步消息降低同步调用的紧耦合，同时提高可用性。</li></ul></li><li><strong>在服务之间维持数据一致性</strong>：<ul><li>问题：需要更新多个服务的数据时，保持服务间的数据一致性。如餐馆接受订单时，要在KitchenService和DeliveryService中同时更新，前者修改Ticket状态，后者安排订单交付，都要以原子化的方式完成更新。</li><li>解决：传统的解决方案是基于两阶段提交的分布式事务管理，但并非最好的选择；Saga是一系列使用消息协作的本地事务，唯一的限制是最终一致性，需要原子更新数据都在单个服务中。</li></ul></li><li><strong>获取一致的数据视图</strong>：<ul><li>问题：无法跨过多个数据库获得一致的真实视图。单体应用中ACID保证返回一致视图，微服务即使每个服务数据库都一致也无法得到。</li><li>解决：视图必须驻留在单个服务中。</li></ul></li><li><strong>上帝类阻碍了拆分</strong>：<ul><li>问题：整个应用程序都要使用的全局类，上帝类代表对应用至关重要的概念如银行账户、电子商务订单、保险政策等等。对于FIGO就是Order类，系统大部分服务都涉及订单。如下图2-10是传统建模创建的Order类结构。</li><li>解决：<ul><li>将Order类打包到库，创建一个中央数据库，处理订单的所有服务都要访问该库。但此方案破坏了微服务架构的原则，并导致了紧耦合。</li><li>将Order数据库封装到OrderService供其他服务调用，但OrderService将成为一个纯数据服务，成为缺乏业务逻辑的<strong>贫血领域模型</strong>。</li><li>好的方案是遵循DDD将每个服务视为领域模型的单独子域，FTGO的每个与订单相关的服务都有自己的领域模型及对应的Order类的版本。如下图2-11，对于DeliveryService，Order可以命名为更合适的Delivery。</li></ul></li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010126.jpg" alt></p><p>DeliveryService对Order的其他属性不感兴趣：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010127.jpg" alt></p><p>KitchenService的Order就是一个Ticket（后厨工单），只包含状态、请求送餐时间、准备时间等，以及告诉餐馆准备的订单项列表。而不关心如消费者、付款、交付这些无关属性。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010128.jpg" alt></p><p>每个领域模型的Order类都表示同一个订单业务实体的不同方面，应用必须维持不同服务中这些不同对象之间的一致性。比如一旦OrderService授权消费者的信用卡，必须触发KitchenService中创建Ticket。同样，如果KitchenService拒绝订单，必须在OrderService中取消订单，并为客户退款。</p><p><strong>可以通过事件驱动机制Saga来维护服务间的一致性</strong>。</p><h3 id="2-6-定义服务API"><a href="#2-6-定义服务API" class="headerlink" title="2.6 定义服务API"></a>2.6 定义服务API</h3><p>到这个阶段，我们有了一个系统操作列表和潜在服务列表，下一步是定义每个服务的API：<strong>服务的操作和事件</strong>。</p><p>定义API操作的原因：</p><ol><li>某些操作对应系统操作，由外部客户端调用，或者其他服务调用。</li><li>支持服务之间协作的操作，仅供其他服务调用。</li></ol><p>服务通过对外发布事件，使其能与其他服务协作。</p><h4 id="（1）将系统操作分配给服务"><a href="#（1）将系统操作分配给服务" class="headerlink" title="（1）将系统操作分配给服务"></a>（1）将系统操作分配给服务</h4><p>第一步，确定哪个服务是请求的初始入口点。如 <code>noteUpdateLocation()</code> 更新送餐员位置，因为与送餐员相关，所以应该分配给CourierService，但它也是需要送餐地点的DeliveryService。这种情况最好把操作分配给需要操作所提供信息的服务，其他情况下分配给具有处理它所需信息的服务更有意义。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010129.jpg" alt></p><h4 id="（2）确定支持服务协作所需要的API"><a href="#（2）确定支持服务协作所需要的API" class="headerlink" title="（2）确定支持服务协作所需要的API"></a>（2）确定支持服务协作所需要的API</h4><p>第二步，是确定在处理每个系统操作时，服务之间如何交互。</p><p>如 <code>createOrder()</code> 操作需要OrderService调用一下服务以验证其前置条件并使后置条件成立：</p><ul><li>ConsumerService：验证消费者是否可以下订单并获取付款信息。</li><li>RestaurantService：验证订单行项目，验证送货地址和时间是否在餐厅的服务区域内，验证订单最低要求，并获得订单行项目的价格。</li><li>KitchenService：创建Ticket后厨工单。</li><li>AccountingService：授权消费者的信用卡。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010130.jpg" alt></p><hr><p>参考：</p><p>🔗 《微服务架构设计模式》</p>]]></content>
    
    <summary type="html">
    
      《微服务架构设计模式》读书笔记，内容：微服务架构是什么，微服务架构风格，为应用定义微服务架构的流程（识别系统操作、根据业务能力或DDD子域进行服务拆分、拆分的原则和难点、定义服务的API）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="microservice" scheme="http://linyishui.top/tags/microservice/"/>
    
  </entry>
  
</feed>
