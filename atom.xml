<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2021-03-08T13:06:22.883Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>林沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法复习 (三) 图-无向图（未完成）</title>
    <link href="http://linyishui.top/2021030401.html"/>
    <id>http://linyishui.top/2021030401.html</id>
    <published>2021-03-04T13:36:06.000Z</published>
    <updated>2021-03-08T13:06:22.883Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法复习-三-图-无向图"><a href="#算法复习-三-图-无向图" class="headerlink" title="算法复习 (三) 图-无向图"></a>算法复习 (三) 图-无向图</h1><h2 id="一-图"><a href="#一-图" class="headerlink" title="一. 图"></a>一. 图</h2><h3 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1 应用场景"></a>1.1 应用场景</h3><ul><li>地图。正在计划旅行的人也许想知道“从普罗维登斯到普林斯顿的最短路线”。对最短路径上经历过交通堵塞的旅行者可能会问：“从普罗维登斯到普林斯顿的哪条路线最快？”要回答这些问题，我们都要处理有关结点（十字路口）之间多条连接（公路）的信息。</li><li>网页信息。当我们在浏览网页时，页面上都会包含其他网页的引用（链接）。通过单击链接，我们可以从一个页面跳到另一个页面。整个互联网就是一张图，结点是网页，连接就是超链接。图算法是帮助我们在网络上定位信息的搜索引擎的关键组件。</li><li>电路。在一块电路板上，晶体管、电阻、电容等各种元件是精密连接在一起的。我们使用计算机来控制制造电路板的机器并检查电路板的功能是否正常。我们既要检查短路这类简单问题，也要检查这幅电路图中的导线在蚀刻到芯片上时是否会出现交叉等复杂问题。第一类问题的答案仅取决于连接（导线）的属性，而第二个问题则会涉及导线、各种元件<br>以及芯片的物理特性等详细信息。</li><li>任务调度。商品的生产过程包含了许多工序以及一些限制条件，这些条件会决定某些任务的先后次序。如何安排才能在满足限制条件的情况下用最少的时间完成这些生产工序呢？<br>商业交易。零售商和金融机构都会跟踪市场中的买卖信息。在这种情形下，一条连接可以表示现金和商品在买方和卖方之间的转移。在此情况下，理解图的连接结构原理可能有助于增强人们对市场的理解。</li><li>配对。学生可以申请加入各种机构，例如社交俱乐部、大学或是医学院等。这里结点就对应学生和机构，而连接则对应递交的申请。我们希望找到申请者与他们感兴趣的空位之间配对的方法。</li><li>计算机网络。计算机网络是由能够发送、转发和接收各种消息的站点互相连接组成的。我们感兴趣的是这种互联结构的性质，因为我们希望网络中的线路和交换设备能够高效率地处理网络流量。</li><li>软件。编译器会使用图来表示大型软件系统中各个模块之间的关系。图中的结点即构成整个系统的各种类和模块，连接则为类的方法之间的可能调用关系（静态分析），或是系统运行时的实际调用关系（动态分析）。我们需要分析这幅图来决定如何以最优的方式为程序分配资源。</li><li>社交网络。当你在使用社交网站时，会和你的朋友之间建立起明确的关系。这里，结点对应人而连接则联系着你和你的朋友或是关注者。分析这些社交网络的性质是当前图算法的一个重要应用。对它感兴趣的不止是社交网络的公司，还包括政治、外交、娱乐、教育、市场等许多其他机构。</li></ul><table><thead><tr><th>应用</th><th>结点</th><th>连接</th></tr></thead><tbody><tr><td>地图</td><td>十字路口</td><td>公路</td></tr><tr><td>网络内容</td><td>网页</td><td>超链接</td></tr><tr><td>电路</td><td>元器件</td><td>导线</td></tr><tr><td>任务调度</td><td>任务</td><td>限制条件</td></tr><tr><td>商业交易</td><td>客户</td><td>交易</td></tr><tr><td>配对</td><td>学生</td><td>申请</td></tr><tr><td>计算机网络</td><td>网站</td><td>物理连接</td></tr><tr><td>软件</td><td>方法</td><td>调用关系</td></tr><tr><td>社交网络</td><td>人</td><td>友谊关系</td></tr></tbody></table><h3 id="1-2-常用术语"><a href="#1-2-常用术语" class="headerlink" title="1.2 常用术语"></a>1.2 常用术语</h3><ul><li>某个顶点的度数即为依附于它的边的总数。</li><li>子图是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。许多计算问题都需要识别各种类型的子图，特别是由能够顺序连接一系列顶点的边所组成的子图。</li><li>路径是由边顺序连接的一系列顶点。</li><li>简单路径是一条没有重复顶点的路径。环是一条至少含有一条边且起点和终点相同的路径。</li><li>简单环是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。</li><li>路径或者环的长度为其中所包含的边数。</li><li>当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另一个顶点是连通的。</li><li>如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是<strong>连通图</strong>。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。</li><li>无环图是一种不包含环的图。</li><li>图的密度是指已经连接的顶点对占所有可能被连接的顶点对的比例。在稀疏图中，被连接的顶点对很少；而在稠密图中，只有少部分顶点对之间没有边连接。</li><li>二分图是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010113.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010116.png" alt></p><h3 id="1-3-图与树的关系"><a href="#1-3-图与树的关系" class="headerlink" title="1.3 图与树的关系"></a>1.3 图与树的关系</h3><p>树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一棵树。图的生成树森林是它的所有连通子图的生成树的集合。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010114.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010115.png" alt></p><p>当且仅当一幅含有V个结点的图满足下列 5 个条件之一时，它就是一棵树：</p><ul><li>G有V-1条边且不含有环；</li><li>G有V-1条边且是连通的；</li><li>G是连通的，但删除任意一条边都会使它不再连通；</li><li>G是无环图，但添加任意一条边都会产生一条环；</li><li>G中的任意一对顶点之间仅存在一条简单路径。</li></ul><h3 id="1-4-四种图模型"><a href="#1-4-四种图模型" class="headerlink" title="1.4 四种图模型"></a>1.4 四种图模型</h3><p>4 种最重要的图模型：</p><ul><li>无向图（简单连接）</li><li>有向图（连接有方向性）</li><li>加权图（连接带有权值）</li><li>加权有向图（连接既有方向性又带有权值）</li></ul><h2 id="二-无向图"><a href="#二-无向图" class="headerlink" title="二. 无向图"></a>二. 无向图</h2><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>定义：图是由一组顶点和一组能够将两个顶点相连的边组成的。</p><p>一般使用 0 至 V-1 来表示一张含有 V 个顶点的图中的各个顶<br>点。用 v-w 的记法来表示连接 v 和 w 的边，w-v 是这条边的另一种表示方法。</p><p>绘制出的图有时会误导我们，因为图的定义和绘出的图像是无关的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010111.png" alt></p><p>特殊的图。我们的定义允许出现两种简单而特殊的情况：</p><ul><li>自环，即一条连接一个顶点和其自身的边；</li><li>连接同一对顶点的两条边称为平行边。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010112.png" alt></p><p>数学家常常将含有平行边的图称为多重图，而将没有平行边或自环的图称为简单图。后续不会出现这种特殊情况，所以用两个顶点就可以指代一条边了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first; <span class="comment">// 链表的首结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123; <span class="comment">// 和Stack 的push() 方法完全相同</span></span><br><span class="line">        Node oldfirst = first;</span><br><span class="line">        first = <span class="keyword">new</span> Node();</span><br><span class="line">        first.item = item;</span><br><span class="line">        first.next = oldfirst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node current = first;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Item item = current.item;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">// 顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E; <span class="comment">// 边的数目</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj; <span class="comment">// 邻接表：数组+链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V]; <span class="comment">// 创建邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) <span class="comment">// 将所有链表初始化为空</span></span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(In in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in.readInt()); <span class="comment">// 读取V并将图初始化</span></span><br><span class="line">        <span class="keyword">int</span> E = in.readInt(); <span class="comment">// 读取E</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123; <span class="comment">// 添加一条边</span></span><br><span class="line">            <span class="keyword">int</span> v = in.readInt(); <span class="comment">// 读取一个顶点</span></span><br><span class="line">            <span class="keyword">int</span> w = in.readInt(); <span class="comment">// 读取另一个顶点</span></span><br><span class="line">            addEdge(v, w); <span class="comment">// 添加一条连接它们的边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        adj[v].add(w); <span class="comment">// 将w添加到v的链表中</span></span><br><span class="line">        adj[w].add(v); <span class="comment">// 将v添加到w的链表中</span></span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-深度优先搜索"><a href="#三-深度优先搜索" class="headerlink" title="三. 深度优先搜索"></a>三. 深度优先搜索</h2><h3 id="3-1-什么是深度优先搜索？"><a href="#3-1-什么是深度优先搜索？" class="headerlink" title="3.1 什么是深度优先搜索？"></a>3.1 什么是深度优先搜索？</h3><p><strong>深度优先搜索算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的递归算法，它会沿着图的边寻找和起点连通的所有顶点。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p><p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的拓扑排序，利用拓扑排序表可以方便的解决很多相关的图论问题，如无权最长路径问题等等。这种算法不会根据图的结构等信息调整执行策略来源请求。</p><h3 id="3-2-迷宫问题和-Tremaux-搜索"><a href="#3-2-迷宫问题和-Tremaux-搜索" class="headerlink" title="3.2 迷宫问题和 Tremaux 搜索"></a>3.2 迷宫问题和 Tremaux 搜索</h3><p>思考图的搜索过程的一种有益的方法是，考虑另一个和它等价的问题：在一个由各种通道和路口组成的迷宫中找到出路。有些迷宫的规则很简单，但大多数迷宫则需要很复杂的策略才行。</p><p>用迷宫代替图、通道代替边、路口代替顶点仅仅只是一些文字游戏，但就目前来说，这么做可以帮助我们直观地认识问题，参见下图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010102.png" alt></p><p>探索迷宫而不迷路的一种古老办法（至少可以追溯到忒修斯和米诺陶的传说）叫做 <strong>Tremaux 搜索</strong>，参见下图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010103.png" alt></p><p>要探索迷宫中的所有通道，我们需要：</p><ul><li>选择一条没有标记过的通道，在你走过的路上铺一条绳子；</li><li>标记所有你第一次路过的路口和通道；</li><li>当来到一个标记过的路口时（用绳子）回退到上个路口；</li><li>当回退到的路口已没有可走的通道时继续回退。</li></ul><p>绳子可以保证你总能找到一条出路，标记则能保证你不会两次经过同一条通道或者同一个路口。要知道是否完全探索了整个迷宫需要的证明更复杂，只有用图搜索才能够更好地处理问题。</p><p>Tremaux 搜索很直接，但它与完全搜索一张图仍然稍有不同，因此我们接下来看看图的搜索方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearch</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v))</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) dfs(G, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-算法描述"><a href="#3-3-算法描述" class="headerlink" title="3.3 算法描述"></a>3.3 算法描述</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010104.png" alt></p><p>搜索连通图的经典递归算法<strong>深度优先搜索</strong>（遍历所有的顶点和边）和 Tremaux 搜索类似。要搜索一幅图，只需用一个递归方法来遍历所有顶点。<strong>深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比</strong>。</p><p>在访问其中一个顶点时：</p><ul><li>将它标记为已访问；</li><li>递归地访问它的所有没有被标记过的邻居顶点。</li></ul><p>它使用一个 boolean 数组来记录和起点连通的所有顶点。递归方法会标记给定的顶点并调用自己来访问该顶点的相邻顶点列表中所有没有被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。</p><p>算法遍历边和访问顶点的顺序与图的表示是有关的，而不只是与图的结构或是算法有关。因为深度优先搜索只会访问和起点连通的顶点，使用下图所示的一幅小型连通图为例，一幅连通的无向图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010105.png" alt></p><ul><li>在示例中，顶点 2 是顶点 0 之后第一个被访问的顶点，因为它正好是 0 的邻接表的第一个元素。</li><li>深度优先搜索中每条边都会被访问两次，且在第二次时总会发现这个顶点已经被标记过。这意味着深度优先搜索的轨迹可能会比你想象的长一倍！示例图仅含有 8 条边，但需要追踪算法在邻接表的 16 个元素上的操作。</li></ul><p>下图显示的是示例中每个顶点被标记后算法使用的数据结构，起点为顶点 0。使用深度优先搜索的轨迹，寻找所有和顶点 0 连通的顶点：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010106.png" alt></p><p>查找开始于构造函数调用递归的 <code>dfs()</code> 来标记和访问顶点0，后续处理如下所述：</p><ul><li>因为顶点 2 是 0 的邻接表的第一个元素且没有被标记过，<code>dfs()</code> 递归调用自己来标记并访问顶点 2（效果是系统会将顶点 0 和 0 的邻接表的当前位置压入栈中）。</li><li>现在，顶点 0 是 2 的邻接表的第一个元素且已经被标记过了，因此 <code>dfs()</code> 跳过了它。接下来，顶点 1 是 2 的邻接表的第二个元素且没有被标记，<code>dfs()</code> 递归调用自己来标记并访问顶点 1。</li><li>对顶点 1 的访问和前面有所不同：因为它的邻接表中的所有顶点（0 和 2）都已经被标记过了，因此不需要再进行递归，方法从 <code>dfs(1)</code> 中返回。下一条被检查的边是 2-3（在 2 的邻接表中顶点 1 之后的顶点是 3），因此 <code>dfs()</code> 递归调用自己来标记并访问顶点3。</li><li>顶点 5 是 3 的邻接表的第一个元素且没有被标记，因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 5。</li><li>顶点 5 的邻接表中的所有顶点（3 和 0）都已经被标记过了，因此不需要再进行递归。</li><li>顶点 4 是 3 的邻接表的下一个元素且没有被标记过，因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 4。这是最后一个需要被标记的顶点。</li><li>在顶点 4 被标记了之后，<code>dfs()</code> 会检查它的邻接表，然后再检查 3 的邻接表，然后是 2 的邻接表，然后是 0 的，最后发现不需要再进行任何递归调用，因为所有的顶点都已经被标记过了。</li></ul><h3 id="3-4-使用场景"><a href="#3-4-使用场景" class="headerlink" title="3.4 使用场景"></a>3.4 使用场景</h3><ul><li><strong>连通性问题</strong> / <strong>路径检测问题</strong> ：比如给定一幅图，回答“两个给定的顶点是否连通？”或者“图中有多少个连通子图？”等类似问题。问题“两个给定的顶点是否连通？”等价于“两个给定的顶点之间是否存在一条路径？”</li><li><strong>单点路径</strong>：给定一幅图和一个起点 s，回答“从 s 到给定目的顶点 v 是否存在一条路径？如果有，找出这条路径。”等类似问题。</li></ul><p>深度优先搜索算法之所以极为简单，是因为它所基于的概念为人所熟知并且非常容易实现。事实上，它是一个既小巧而又强大的算法，研究人员用它解决了无数困难的问题。上述两个问题只是我们将要研究的许多问题的开始。</p><h3 id="3-5-算法题"><a href="#3-5-算法题" class="headerlink" title="3.5 算法题"></a>3.5 算法题</h3><p>剑指第12题-矩阵中的路径：深度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 矩阵中的路径</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</span></span><br><span class="line"><span class="comment"> * 路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。</span></span><br><span class="line"><span class="comment"> * 如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</span></span><br><span class="line"><span class="comment"> * 例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [["a","b","c","e"],</span></span><br><span class="line"><span class="comment"> * ["s","f","c","s"],</span></span><br><span class="line"><span class="comment"> * ["a","d","e","e"]]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入：board = [["a","b"],["c","d"]], word = "abcd"</span></span><br><span class="line"><span class="comment"> * 输出：false</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1 &lt;= board.length &lt;= 200</span></span><br><span class="line"><span class="comment"> * 1 &lt;= board[i].length &lt;= 200</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 深度优先搜索</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz12Exist</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] board = &#123;</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'S'</span>, <span class="string">'F'</span>, <span class="string">'C'</span>, <span class="string">'S'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String word = <span class="string">"ABCCED"</span>;</span><br><span class="line">        System.out.println(exist(board, word));</span><br><span class="line">        <span class="keyword">char</span>[][] board1 = &#123;&#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;, &#123;<span class="string">'c'</span>, <span class="string">'d'</span>&#125;&#125;;</span><br><span class="line">        String word1 = <span class="string">"abcd"</span>;</span><br><span class="line">        System.out.println(exist(board1, word1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间复杂度 O(3^K * M * N) ：</span></span><br><span class="line"><span class="comment">     *      最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K)；</span></span><br><span class="line"><span class="comment">     *      矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。</span></span><br><span class="line"><span class="comment">     *      方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3^K) 。</span></span><br><span class="line"><span class="comment">     * 空间复杂度 O(K) ：</span></span><br><span class="line"><span class="comment">     *      搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K)</span></span><br><span class="line"><span class="comment">     *      （因为函数返回后，系统调用的栈空间会释放）。</span></span><br><span class="line"><span class="comment">     *      最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, words, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board 二维矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 单词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 单词坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否命中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未命中：横纵坐标越界，矩阵对应位置元素不等于单词对应位置元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单词遍历结束，全部命中</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记表示已访问过</span></span><br><span class="line">        board[i][j] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">// 递归访问相邻矩阵元素</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, word, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剑指第13题-机器人的运动范围：深度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。</span></span><br><span class="line"><span class="comment"> * 一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），</span></span><br><span class="line"><span class="comment"> * 也不能进入行坐标和列坐标的数位之和大于k的格子。</span></span><br><span class="line"><span class="comment"> * 例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。</span></span><br><span class="line"><span class="comment"> * 但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：m = 2, n = 3, k = 1</span></span><br><span class="line"><span class="comment"> * 输出：3</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：m = 3, n = 1, k = 0</span></span><br><span class="line"><span class="comment"> * 输出：1</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1 &lt;= n,m &lt;= 100</span></span><br><span class="line"><span class="comment"> * 0 &lt;= k &lt;= 20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz13MovingCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">        m = <span class="number">3</span>;</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">        m = <span class="number">16</span>;</span><br><span class="line">        n = <span class="number">8</span>;</span><br><span class="line">        k = <span class="number">4</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(mn)，其中 m 为方格的行数， n 为方格的列数。</span></span><br><span class="line"><span class="comment">     * 一共有 O(mn) 个状态需要计算，每个状态递推计算的时间复杂度为 O(1)，所以总时间复杂度为 O(mn)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(mn)，其中 m 为方格的行数，n 为方格的列数。我们需要 O(mn) 大小的结构来记录每个位置是否可达。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; getSum(i) + getSum(j) || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, m, n, k, visited) + dfs(i, j + <span class="number">1</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = a / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tmp % <span class="number">10</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-寻找路径"><a href="#四-寻找路径" class="headerlink" title="四. 寻找路径"></a>四. 寻找路径</h2><h3 id="4-1-路径API"><a href="#4-1-路径API" class="headerlink" title="4.1 路径API"></a>4.1 路径API</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010107.png" alt></p><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Graph G = <span class="keyword">new</span> Graph(<span class="keyword">new</span> In(args[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">int</span> s = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">    Paths search = <span class="keyword">new</span> Paths(G, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">        StdOut.print(s + <span class="string">" to "</span> + v + <span class="string">": "</span>);</span><br><span class="line">        <span class="keyword">if</span> (search.hasPathTo(v))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : search.pathTo(v))</span><br><span class="line">                <span class="keyword">if</span> (x == s) StdOut.print(x);</span><br><span class="line">                <span class="keyword">else</span> StdOut.print(<span class="string">"-"</span> + x);</span><br><span class="line">        StdOut.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h3><p>DepthFirstPaths使用深度优先搜索查找图中的路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此顶点上是否调用过 dfs()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从起点到一个顶点的已知路径上的最后一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 G 中找出所有起点为 s 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在从 s 到 v 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s 到 v 的路径，如果不存在则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x]) &#123;</span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算轨迹如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010109.png" alt></p><p>为了保存到达每个顶点的已知路径，这段代码使用了一个以顶点编号为索引的数组 edgeTo[]，edgeTo[w]=v 表示 v-w 是第一次访问 w 时经过的边。edgeTo[] 数组是一棵用父链接表示的以 s 为根且含有所有与 s 连通的顶点的树。</p><p>下图显示的是示例中每个顶点被标记后 edgeTo[] 的内容，起点为顶点 0。marked[] 和 adj[] 的内容与  DepthFirstSearch 的轨迹相同，递归调用和边检查的详细描述也完全一样，这里不再赘述。深度优先搜索向 edgeTo[] 数组中顺序添加了 0-2、2-1、2-3、3-5 和 3-4。这些边构成了一棵以起点为根结点的树并提供了 pathTo() 方法所需的信息，使得调用者可以按照前文所述的方法找到从 0 到顶点 1、2、3、4、5 的路径。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010110.png" alt></p><h2 id="五-广度优先搜索"><a href="#五-广度优先搜索" class="headerlink" title="五. 广度优先搜索"></a>五. 广度优先搜索</h2><h2 id="六-连通分量"><a href="#六-连通分量" class="headerlink" title="六. 连通分量"></a>六. 连通分量</h2>]]></content>
    
    <summary type="html">
    
      内容主要来自《算法-第4版》，内容包括：图，无向图，深度优先搜索，寻找路径，广度优先搜索等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="graph" scheme="http://linyishui.top/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（六）高级特性</title>
    <link href="http://linyishui.top/2021020101.html"/>
    <id>http://linyishui.top/2021020101.html</id>
    <published>2021-02-01T13:16:33.000Z</published>
    <updated>2021-03-03T13:23:42.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（六）高级特性"><a href="#《高性能MySQL》（六）高级特性" class="headerlink" title="《高性能MySQL》（六）高级特性"></a>《高性能MySQL》（六）高级特性</h1><h2 id="一-分区表"><a href="#一-分区表" class="headerlink" title="一. 分区表"></a>一. 分区表</h2><h3 id="1-1-什么是分区表？"><a href="#1-1-什么是分区表？" class="headerlink" title="1.1 什么是分区表？"></a>1.1 什么是分区表？</h3><p>分区表是一个独立的逻辑表，底层由多个物理子表组成。一组底层表的句柄对象的封装，对分区表的请求通过句柄对象转换为对存储引擎的接口调用。</p><p>MySQL索引根据分区的子表定义，没有全局索引，不能像Oracle那样指定索引和表是否分区。</p><p>创建表时使用 PARTITION BY 子句定义每个分区存放的数据。每次查询时优化器根据分区定义过滤掉其它分区，使查询只须扫描包含数据的分区。</p><h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><ul><li>无法全部放入内存的大表，或是大部分历史数据、只有少量热点数据。</li><li>分区表的数据易于维护，批量删除大量数据可以直接清除整个分区；还可以对一个分区进行优化、检查、修复等操作。</li><li>分区表的数据可以分布在不同的物理设备上。</li><li>使用分区表可以避免一些特殊瓶颈，如InnoDB的单个索引的互斥访问、ext3文件系统的inode锁竞争等。</li><li>可以备份和恢复独立的分区，在大数据集的场景有很好的效果。</li></ul><h3 id="1-3-使用限制"><a href="#1-3-使用限制" class="headerlink" title="1.3 使用限制"></a>1.3 使用限制</h3><ul><li>一个表最多有1024个分区。</li><li>MySQL 5.1中分区表达式必须返回整数，MySQL 5.5的某些场景可以直接使用列进行分区。</li><li>若分区字段中有主键或唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</li><li>分区表无法使用外键约束。</li></ul><h3 id="1-4-实现原理"><a href="#1-4-实现原理" class="headerlink" title="1.4 实现原理"></a>1.4 实现原理</h3><p>分区表由多个相关底层表实现，底层表由句柄对象表示，存储引擎管理分区的各个底层表与普通表相同，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。</p><p>几种操作的逻辑：虽然都要锁住所有底层表，但其实只是行级锁</p><ul><li>SELECT 查询：查询一个分区表时，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后调用对应存储引擎接口访问各个分区的数据。</li><li>INSERT 操作：写入一条记录时，分区层先打开并锁住所有的底层表，然后确定在哪个分区接收这条记录，并把记录写入底层表。</li><li>DELETE 操作：删除一条记录时，分区层先打开并锁住所有底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作。</li><li>UPDATE 操作：更新一条记录时，分区层先打开并锁住所有底层表，MySQL要先确定更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据所在底层表进行删除操作。</li></ul><h3 id="1-5-分区表的类型"><a href="#1-5-分区表的类型" class="headerlink" title="1.5 分区表的类型"></a>1.5 分区表的类型</h3><p>分区表达式可以使用各种函数，但返回值一定要是一个确定的整数，且不能是一个常数（案例使用YEAR函数根据时间进行分区）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqles (</span><br><span class="line">order_date DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">--other columns</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(order_date)) (</span><br><span class="line"><span class="keyword">PARTITION</span> p_2010 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2011 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2011</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2012 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2012</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_catchall <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>MySQL支持键值、哈希和列表分区，以及使用 RANGE COLUMNS 类型的分区。</p><p>系统通过子分区可降低索引的互斥访问竞争。最近一年的分区数据会被频繁访问，导致大量的互斥量的竞争。使用哈希子分区可以将数据切成多个小片，大大降低互斥量的竞争问题。</p><h3 id="1-6-合理使用分区表"><a href="#1-6-合理使用分区表" class="headerlink" title="1.6 合理使用分区表"></a>1.6 合理使用分区表</h3><p>假设一个需求：需要从一个大表中查出一段时间的记录，表中包含多年的历史数据，按照时间排序。仅仅几个月的数据可能会有上亿或十亿条记录。</p><p>首先不能每次查询时扫描全表，并且考虑索引在空间和维护上的消耗也不能使用（可能会产生大量的碎片，导致一个查询有成千上万的随机I/O）。</p><p>只能<strong>让所有的查询只在数据表上做顺序扫描</strong>，或者<strong>将数据表和索引都缓存在内存中</strong>。</p><p><strong>数据量大时，除非是索引覆盖查询，否则B-Tree索引无法起作用了，数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，若数据量巨大，这将产生大量随机I/O，导致响应时间过长，并且索引的维护代价也很高</strong>。</p><p>分区可以看作初始形态的索引，以非常小的代价定位到数据在哪一片区域，在区域内可以做顺序扫描、可以建索引、可以将数据缓存到内存。分区无需额外的数据结构记录每个分区有哪些数据（因为不需要精确定位数据位置）。</p><p>保证大数据量可扩展性的策略：</p><ul><li><strong>全量扫描数据，不要任何索引</strong>：只要能用WHERE条件将需要的数据限制在少数分区中，效率是很高的，需要一些简单运算保证响应时间能够满足要求，此策略适用于正常方式访问大量数据时。</li><li><strong>索引数据，并分离热点</strong>：当数据有明显的热点，此外的数据很少会被访问到，可以将这部分热点数据单独放在一个分区，从而有机会全部缓存到内存中，使查询只用访问一个很小的分区表，能够有效的使用索引和缓存。</li></ul><h3 id="1-7-常见问题"><a href="#1-7-常见问题" class="headerlink" title="1.7 常见问题"></a>1.7 常见问题</h3><p>上述两种分区策略都基于查询能够过滤到额外分区、分区本身并不会带来额外的代价，但在一些场景下这两种假设会有问题：</p><ul><li><strong>NULL值使分区过滤无效</strong>：<ul><li>所有的NULL值或非法值会被存放到第一个分区；所以如查询 <code>WHERE order_date BETWEEN &#39;2012-01-01&#39; AND &#39;2012-01-31&#39;</code> 会检查2012分区和第一个分区，因为YEAR函数在接收非法值时可能会返回NULL。</li><li>当第一个分区特别大时，代价会很高，尤其是策略<strong>全量扫描数据，不要任何索引</strong>；为了避免此状况，可以创建一个不用的第一分区，通过 <code>PARTITION p_nulls VALUES LESS THAN(0)</code> 来创建，这样如果插入的数据都是有效的情况下第一分区是空的，即使需要检测第一分区也不会有太高代价。</li></ul></li><li><strong>分区列和索引列不匹配</strong>：二者不匹配会导致查询无法进行分区过滤，比如在列a上定义了索引，在列b上进行分区，这样每个分区都有独立的索引，所以扫描列b上的索引需要扫描每个分区对应的索引，虽然扫描速度并不是特别慢，但还是应该尽量避免建立和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。</li><li><strong>选择分区的成本可能很高</strong>：不同的分区类型实现方式不同，性能也不同；范围分区在判断记录数据属于哪一分区的成本很高，因为服务器要扫描所有的分区定义的列表，这样的线性搜索会随分区数增多成本变高。对于键分区或哈希分区则没有此问题，100个左右的分区数不会有问题。</li><li><strong>打开并锁住所有底层表的成本可能很高</strong>：此操作发生于分区过滤之前，无法通过分区过滤降低开销，对于一些本来很快的操作，如根据主键查询单行，会带来额外的开销；可以通过批量操作的方式来降低单个开销，如批量插入或 LOAD DATA INFILE、一次删除多行数据等，同时需要限制分区的个数。</li><li><strong>维护分区的成本可能很高</strong>：新增或删除分区等操作很快（不包括删除大分区），而重组分区（先创建一个临时分区，然后将数据复制到其中，最后删除原分区）或类似ALTER语句的操作需要复制数据。</li></ul><p>使用分区表的限制：</p><ul><li>所有分区要使用相同的存储引擎；</li><li>分区可以使用的函数或表达式受限；</li><li>一些存储引擎不支持分区或有更多限制；</li></ul><h3 id="1-8-优化查询"><a href="#1-8-优化查询" class="headerlink" title="1.8 优化查询"></a>1.8 优化查询</h3><p>分区这种粗粒度索引可以让查询扫描更少的数据，对于访问分区表来说，重要的一点是WHERE条件中加入分区列，即使看起来很多余，因为这样可以使优化器过滤掉无需访问的分区。</p><p>通过EXPLAIN PARTITION观察优化器是否执行了分区过滤，需要注意的是MySQL只能在使用分区函数的列本身进行比较时才能过滤分区，而不能根据表达式的值去过滤分区：<strong>查询时只能通过列来过滤分区</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--无法过滤分区：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales_by_day <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(<span class="keyword">day</span>) = <span class="number">2010</span></span><br><span class="line"><span class="comment">--可以过滤分区：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales_by_day <span class="keyword">WHERE</span> <span class="keyword">day</span> <span class="keyword">BETWEEN</span> <span class="string">'2010-01-01'</span> <span class="keyword">AND</span> <span class="string">'2010-12-31'</span></span><br></pre></td></tr></table></figure><h3 id="1-9-合并表"><a href="#1-9-合并表" class="headerlink" title="1.9 合并表"></a>1.9 合并表</h3><p>合并表（Merge Table）是简单版的分区实现，分区表是一种逻辑上的概念，用户无法访问底层的各个分区，但用户可以单独访问合并表的各个子表。</p><p>分区表与优化器更紧密结合，而合并表则是要被淘汰的技术。</p><p>后续省略。</p><h2 id="二-视图"><a href="#二-视图" class="headerlink" title="二. 视图"></a>二. 视图</h2><h3 id="2-1-什么是视图？"><a href="#2-1-什么是视图？" class="headerlink" title="2.1 什么是视图？"></a>2.1 什么是视图？</h3><ul><li>视图在MySQL 5.0版本引入；</li><li>本身是虚拟表，不存储数据，访问视图时从实体表获取数据；</li><li>视图与表在同一个命名空间，不能对视图创建触发器；</li></ul><h3 id="2-2-视图的两种实现算法"><a href="#2-2-视图的两种实现算法" class="headerlink" title="2.2 视图的两种实现算法"></a>2.2 视图的两种实现算法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Oceania <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> Oceania <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure><p>视图的两种实现：</p><ul><li><p><strong>临时表算法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> TMP_Oceania <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> TMP_Oceania <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>合并算法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure></li></ul><p>可以在 <code>EXPLAIN EXTENDED</code> 后使用 <code>SHOW WARNINGS</code> 查看使用视图的查询重写后的结果，临时表算法实现的视图会显示为派生表（DERIVED）：<code>EXPLAIN SELECT * FROM View</code> 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010101.png" alt></p><p>只要无法在原表记录和视图记录建立一对一映射的场景都无法使用临时表算法实现视图，如 GROUP BY，DISTINCT，聚合函数，UNION，子查询等。</p><h3 id="2-3-可更新视图"><a href="#2-3-可更新视图" class="headerlink" title="2.3 可更新视图"></a>2.3 可更新视图</h3><p>可更新视图就是能够通过更新视图来更新视图涉及的表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Oceania <span class="keyword">SET</span> Population = Population * <span class="number">1.1</span> <span class="keyword">WHERE</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure><p>视图定义包含 GROUP BY，聚合函数，UNION等情况不能更新相关表，所有使用临时表算法实现的视图不能更新，被更新的列必须来自同一张表。</p><p><code>CHECK OPTION</code> 表示任何通过视图更新的行，都必须符合视图本身的WHERE条件定义，不能更新视图定义列外的列。</p><h3 id="2-4-视图对性能的影响"><a href="#2-4-视图对性能的影响" class="headerlink" title="2.4 视图对性能的影响"></a>2.4 视图对性能的影响</h3><p>视图在某些场景也可以帮助提高性能，</p><ul><li><p>重构Schema时使用视图，修改表结构时不会影响应用运行；</p></li><li><p>使用视图实现基于列的权限控制，不需要真正的在系统创建权限，没有额外开销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> XX <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> XXX;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> public.* <span class="keyword">TO</span> public_user;</span><br></pre></td></tr></table></figure></li><li><p>视图并没有看起来那样简单，使用视图提示性能需要做比较详细的测试，临时表算法实现的视图在很多场景下性能很糟糕，合并算法实现的视图也会有额外开销，并且视图的性能很难预测。</p></li></ul><h3 id="2-5-使用视图的一些限制"><a href="#2-5-使用视图的一些限制" class="headerlink" title="2.5 使用视图的一些限制"></a>2.5 使用视图的一些限制</h3><ul><li>MySQL不支持物化视图，指将视图结果数据存放在一个可以查看的表，并定时从原始表刷新数据到这个表；</li><li>MySQL视图不支持创建索引，但可以使用缓存表或汇总表模拟物化视图和索引；</li><li>MySQL不会保存视图定义的原始SQL语句，可以通过使用视图的 <code>.frm</code> 文件最后一行获取信息2，如果有FILE权限，可以直接使用SQL语句的 <code>LOAD_FILE()</code> 读取 <code>.frm</code> 的视图创建信息，再处理掉转义字符等。</li></ul><h2 id="三-外键约束"><a href="#三-外键约束" class="headerlink" title="三. 外键约束"></a>三. 外键约束</h2><p>InnoDB引擎支持外键。</p><p>优点：</p><ul><li>如果想确保两个表始终有一致性的数据，使用外键比在应用中保证一致性要高效的多，级联更新和删除也要更快。</li></ul><p>缺点：</p><ul><li>InnoDB强制外键使用索引，当外键列的选择性很低，会导致一个非常大且选择性很低的索引，且该索引除了做外键限制没有其他作用。</li><li>使用外键需要成本，每次修改数据时都要在另一张表中多执行一次查询操作。</li><li>查询需要额外访问一些表，意味着需要额外的锁。若向子表写入一条记录，外键约束使InnoDB检查父表中对应的记录进行加锁操作，确保该记录不会在事务完成时被删除，会导致额外的锁等待，甚至导致一些难以排查的死锁。</li></ul><p>可以使用触发器来代替外键，当外键只是用作数值约束。如果只是把外键做约束，在应用层实现会更好，因为外键会带来大量的额外消耗，很多过往的经验告诉我们在删除外键时性能会有大幅提升。</p><h2 id="四-在MySQL内部存储代码"><a href="#四-在MySQL内部存储代码" class="headerlink" title="四. 在MySQL内部存储代码"></a>四. 在MySQL内部存储代码</h2><h3 id="4-1-存储代码的方式"><a href="#4-1-存储代码的方式" class="headerlink" title="4.1 存储代码的方式"></a>4.1 存储代码的方式</h3><p>主要区别在于执行的上下文—输入和输出</p><ul><li>触发器</li><li>存储过程：可以接收参数返回值</li><li>函数：可以接收参数返回值</li><li>定时任务 / 事件</li></ul><h3 id="4-2-存储代码的优缺点"><a href="#4-2-存储代码的优缺点" class="headerlink" title="4.2 存储代码的优缺点"></a>4.2 存储代码的优缺点</h3><p>优点：</p><ul><li>服务器内部执行，离数据最近，可以节省带宽和网络延迟；</li><li>这是一种代码重用，方便统一业务规则，保证某些行为总是一致，所以也带来了一定的安全性；</li><li>简化代码的维护和版本更新；</li><li>帮助提升安全性，提供了更细粒度的权限控制，应用可以通过存储过程的接口访问没有权限的表；</li><li>服务器端可以缓存存储过程的执行计划，降低了需要反复调用的过程的消耗；</li><li>在服务器端部署，备份和维护都在服务器端完成；</li><li>可以在应用开发和数据库开发间更好的分工。</li></ul><p>缺点：</p><ul><li>MySQL没有提供好用的开发和调试工具，编写存储代码难度较高；</li><li>存储代码相比应用代码效率要差一些，很难实现复杂逻辑；</li><li>存储代码可能会带来额外的复杂性，原本只需部署应用代码和库表结构变更，还需要额外部署内部存储代码；</li><li>部署在服务器会带来安全隐患，只要破解数据库就将功能和数据全部获取；</li><li>存储过程给数据库服务器带来额外的压力，数据库服务器的扩展性要远差于应用服务器。</li><li>无法控制存储程序的资源消耗，可能一个错误就把服务器拖死。</li><li>存储代码的实现有很多限制，调试也很困难，难以定位问题。</li><li>与基于语句的二进制日志复制合作的不好。</li></ul><h3 id="4-3-存储过程和函数"><a href="#4-3-存储过程和函数" class="headerlink" title="4.3 存储过程和函数"></a>4.3 存储过程和函数</h3><p>优化器对存储代码的限制：</p><ul><li>优化器无法使用关键字DETERMINISTIC来优化单个查询中多次调用存储函数的情况。</li><li>优化器无法评估存储函数的执行成本。</li><li>每个连接都有独立的存储过程的执行计划缓存，如果有多个连接需要调用同一个存储过程，就会浪费空间来反复缓存同样的执行计划（连接池或持久化连接会造成缓存更长的生命周期）。</li><li>存储过程和复制是一对诡异的组合，最好不要复制对存储程序的调用，直接复制其改变的数据。MySQL 5.1 后引入行复制。</li></ul><h3 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a>4.4 触发器</h3><h4 id="4-4-1-什么是触发器？"><a href="#4-4-1-什么是触发器？" class="headerlink" title="4.4.1 什么是触发器？"></a>4.4.1 什么是触发器？</h4><ul><li>触发器可以让你在执行 INSERT、UPDATE或DELETE时，执行一些特定的操作。</li><li>可以指定是在SQL语句前或后触发，触发器本身没有返回值，但可以读取或改变触发SQL语句所影响的数据。</li><li>使用触发器可以减少客户端和服务器之间的通信，简化应用逻辑，一定程度上提高性能。</li></ul><h4 id="4-4-2-使用注意"><a href="#4-4-2-使用注意" class="headerlink" title="4.4.2 使用注意"></a>4.4.2 使用注意</h4><ul><li>对每个表的每个事件，最多只能定义一个触发器（如不能再AFTER INSERT上定义两个触发器）。</li><li>MySQL只支持基于行的触发，即触发器始终针对一条记录，而不是针对整个SQL语句，当数据集变得很大时，效率会很低。</li><li>触发器会掩盖服务器背后很多工作，而触发器的问题很难排查。</li><li>触发器可能会导致死锁和锁等待，触发器执行失败会导致SQL也失败，但不会有直接明确的提示。</li><li>触发器在InnoDB表上是在同一个事务中完成的，执行操作是原子的，原子操作和触发器操作会同时失败或成功。</li><li>在InnoDB上使用触发器去检查数据一致性要小心MVCC，可能会得到错误结果。</li></ul><h3 id="4-5-事件"><a href="#4-5-事件" class="headerlink" title="4.5 事件"></a>4.5 事件</h3><ul><li>MySQL 5.1 引入事件作为一种新的存储代码的方式，MySQL内部实现的类似于Linux的定时任务。</li><li>指定MySQL在某个时间执行一段SQL代码，或者每隔一个时间间隔。其中复杂的SQL封装在一个存储过程中，事件执行时只需做一个简单的调用。</li><li>事件在一个独立事件调度线程中被初始化，该线程和处理连接的线程没有关系，它不接收任何参数，也没有任何返回值。可以在MySQL的日志中看到命令的执行日志，在表 INFORMATION_SCHEMA.EVENTS 中看到各个事件状态。</li><li>事件实现机制本身开销不大，但事件需要执行SQL，这可能会对性能有很大影响；事件和其他存储程序一样，在和基于语句的复制一起工作时可能会导致一些问题。</li><li>定时事件可能会执行很久，前一个事件未执行完，后一个事件开始执行，开发要自己处理这种情况下的并发（可以使用 <code>GET_LOCK()</code> 确保当前总是只有一个事件在执行-加锁）。</li><li>通过 <code>SET GLOBAL event_scheduler := 1;</code> 设置事件调度线程，设置后此线程执行各个用户指定的事件中的各段SQL代码。</li><li>事件调度本身是一个单独的线程，MySQL创建一个新的进程用于事件执行，进程和线程的生命周期是事件的执行过程，状态总为 Connect 。</li></ul><h2 id="五-游标"><a href="#五-游标" class="headerlink" title="五. 游标"></a>五. 游标</h2><p>暂略。</p><h2 id="六-绑定变量"><a href="#六-绑定变量" class="headerlink" title="六. 绑定变量"></a>六. 绑定变量</h2><h3 id="6-1-什么是绑定变量？"><a href="#6-1-什么是绑定变量？" class="headerlink" title="6.1 什么是绑定变量？"></a>6.1 什么是绑定变量？</h3><ul><li><p>MySQL 4.1 版本引入绑定变量（prepared statement），用于提高客户端和服务器端数据传输的效率。</p></li><li><p>流程：创建一个绑定变量的SQL时，客户端向服务端发送一个SQL语句的原型；服务端收到后，解析并存储这个SQL语句的部分执行计划，返回给客户端一个SQL语句处理句柄，以后每次执行此类查询，客户端都指定使用这个句柄。</p></li><li><p>语法：用问号标记可以接收参数的位置，通过向服务器端发送各个问号的取值和这个SQL的句柄来执行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb1(col1, col2, col3) <span class="keyword">VALUES</span> (?, ?, ?);</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-绑定变量为何能提高性能？"><a href="#6-2-绑定变量为何能提高性能？" class="headerlink" title="6.2 绑定变量为何能提高性能？"></a>6.2 绑定变量为何能提高性能？</h3><ul><li>在服务器端只需解析一次SQL语句。</li><li>在服务器端某些优化器的工作只需执行一次，因为会缓存一部分执行计划。</li><li>以二进制的方式只发送参数和句柄，比每次都发送ASCII码文本效率要高，比如一个二进制的日期只需三个字节，而后者则需要十个字节；可以分块传输，而无需一次性传输；还节省了将数据从原始格式转为文本格式的开销。</li><li>只传输参数，而不是整个语句，网络开销降低。</li><li>MySQL直接将参数存储到缓存，不需要在内存中多次复制。</li></ul><h3 id="6-3-优化"><a href="#6-3-优化" class="headerlink" title="6.3 优化"></a>6.3 优化</h3><p>比如当执行计划需要根据传入的参数计算时，MySQL无法缓存这部分计划。</p><p>根据优化器工作阶段，划分三类优化：</p><ol><li><strong>准备阶段</strong>：服务器解析SQL语句，移除不可能条件，并且重写子查询。</li><li><strong>第一次执行</strong>：服务器先简化嵌套循环的关联，并将外关联转换成内关联。</li><li><strong>每次SQL语句执行</strong>：<ul><li>过滤分区</li><li>尽量移除 <code>COUNT()</code> 、<code>MIN()</code> 和 <code>MAX()</code> </li><li>移除常数表达式</li><li>做必要的等值传播</li><li>分析和优化 ref 、range 和索引优化等访问数据的方法</li><li>优化关联顺序</li></ul></li></ol><h3 id="6-4-SQL接口的绑定变量"><a href="#6-4-SQL接口的绑定变量" class="headerlink" title="6.4 SQL接口的绑定变量"></a>6.4 SQL接口的绑定变量</h3><p>MySQL 在 4.1 版本中支持了SQL接口的绑定变量，不需要使用二进制传输协议也可以直接以SQL的方式使用绑定变量。</p><p>服务器会将SQL语句翻译，无需使用二进制协议：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> := <span class="string">'SELECT actor_id, first_name, last_name FROM actor WHERE first_name = ?'</span>;</span><br><span class="line"><span class="keyword">PREPARE</span> stmt_fetch_actor <span class="keyword">FROM</span> @<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SET</span> @actor_name := <span class="string">'Penelope'</span></span><br><span class="line"><span class="keyword">EXECUTE</span> stmt_fetch_actor <span class="keyword">USING</span> @actor_name;</span><br><span class="line">DEALLOATE <span class="keyword">PREPARE</span> stmt_fetch_actor;</span><br></pre></td></tr></table></figure><p>这种写法的主要用途是在存储过程中使用，可以灵活的拼接字符串等参数构建SQL语句，除此外相比二进制协议就没什么优势了。</p><p>使用限制：</p><ul><li>绑定变量是会话级别，连接之间不能共用绑定变量句柄。一旦连接断开，原来的句柄也不能使用，使用连接池和持久化连接可以缓解此问题。</li><li>MySQL 5.1 之前版本，绑定变量的SQL不能使用查询缓存。</li><li>只执行一次的SQL，使用绑定变量会多一次额外的准备阶段消耗，和一次额外的网络开销。</li><li>不能在存储函数中使用。</li><li>未释放的绑定变量资源容易造成资源泄露，对所有线程造成影响。</li><li>如BEGIN等操作无法在绑定变量中完成。</li></ul><h3 id="6-5-三种绑定变量的区别"><a href="#6-5-三种绑定变量的区别" class="headerlink" title="6.5 三种绑定变量的区别"></a>6.5 三种绑定变量的区别</h3><ul><li><strong>客户端模拟的绑定变量</strong>：接收一个带参数的SQL，将指定的值带入，最后将完整的查询发送到服务器端。</li><li><strong>服务端的绑定变量</strong>：客户端使用特殊的二进制协议将带参数的字符串发送到服务器端，然后使用二进制协议将具体的参数值发送给服务器端并执行。</li><li><strong>SQL接口的绑定变量</strong>：客户端先发送一个带参数的字符串到服务器，类似于使用PREPARE的SQL语句，然后发送设置参数的SQL，最后使用EXECUTE来执行SQL，使用普通的文本传输协议。</li></ul><h2 id="七-用户自定义函数"><a href="#七-用户自定义函数" class="headerlink" title="七. 用户自定义函数"></a>七. 用户自定义函数</h2><p>暂略。</p><h2 id="八-插件"><a href="#八-插件" class="headerlink" title="八. 插件"></a>八. 插件</h2><p>暂略。</p><h2 id="九-字符集和校对"><a href="#九-字符集和校对" class="headerlink" title="九. 字符集和校对"></a>九. 字符集和校对</h2><p>暂略。</p><h2 id="十-全文索引"><a href="#十-全文索引" class="headerlink" title="十. 全文索引"></a>十. 全文索引</h2><h3 id="10-1-什么是全文索引？"><a href="#10-1-什么是全文索引？" class="headerlink" title="10.1 什么是全文索引？"></a>10.1 什么是全文索引？</h3><ul><li><strong>场景</strong>：如果想要通过关键字的匹配来进行查询过滤，需要基于相似度的查询而不是精确的数据比较，全文索引专为此场景设计。</li><li><strong>支持</strong>：各种字符串内容的搜索，包括CHAR、VARCHAR和TEXT类型，支持自然语言搜索和布尔搜索。</li><li>互联网搜索引擎技术和全文索引基本原理相同。</li></ul><h3 id="10-2-自然语言的全文索引"><a href="#10-2-自然语言的全文索引" class="headerlink" title="10.2 自然语言的全文索引"></a>10.2 自然语言的全文索引</h3><p>该引擎会计算每一个文档对象和查询的相关度，相关度基于匹配的关键词个数，以及关键词在文档中出现的次数。出现次数越少的词语，匹配时的相关度就越高，常见的词语将不会搜索（超过50%的记录都出现），即使不在停用词列表中出现。</p><p>可以根据WHERE子句中的MATCH AGAINST来区分查询是否使用全文索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> film_text;</span><br><span class="line"><span class="comment">--index_type为FULLTEXT，假设两个字段title, description建立了全文索引</span></span><br><span class="line"><span class="keyword">select</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>), <span class="keyword">MATCH</span>(title, description) AGAINST(<span class="string">'factory casualties'</span>) <span class="keyword">AS</span> relevance </span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description) AGAINST(<span class="string">'factory casualties'</span>);</span><br><span class="line"><span class="comment">--MySQL将搜索词语分为两个独立的关键词进行搜索，函数MATCH()会返回关键词匹配的相关度</span></span><br></pre></td></tr></table></figure><p>在MATCH函数中指定的列必须和全文索引指定的列相同，否则无法使用全文索引，因为全文索引不会记录关键字来自哪一列。也意味着无法使用全文索引来查询某个关键字是否在某一列中存在。</p><h3 id="10-3-布尔全文索引"><a href="#10-3-布尔全文索引" class="headerlink" title="10.3 布尔全文索引"></a>10.3 布尔全文索引</h3><p>用户可以在布尔搜索的查询中自定义某个被搜索词语的相关性，通过停用词列表过滤掉“噪声”词，要求搜索关键词长度需要大于 <code>ft_min_word_len</code> 且小于 <code>ft_max_word_len</code> ，搜索结果未经排序。</p><p>通过<strong>前缀修饰符</strong>来定制布尔搜索：</p><ul><li>dinosaur：包含dinosaur的行rank值更高</li><li>~dinosaur：包含dinosaur的行rank值更低</li><li>+dinosaur：行记录必须包含dinosaur</li><li>-dinosaur：行记录不可以包含dinosaur</li><li>dino*：包含以dino开头的单词的行rank值更高</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询必须同时包含factory和casualties</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description)</span><br><span class="line">AGAINST(<span class="string">'+factory +casualties'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询中使用括号进行短语搜索</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description)</span><br><span class="line">AGAINST(<span class="string">'"spirited casualties"'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure><p>短语搜索较慢，因为单使用全文索引无法判断是否精确匹配到短语，通常还要查询原文确定记录是否包含完整的短语，因为需要回表过滤，所以效率不高。</p><h3 id="10-4-使用限制"><a href="#10-4-使用限制" class="headerlink" title="10.4 使用限制"></a>10.4 使用限制</h3><ul><li>全文索引只能通过词频来判断相关性，索引不会记录索引词在字符串的位置。</li><li>全文索引只有全部在内存中时才有较好的性能，使用精确短语搜索时，需要数据和索引都在内存中。</li><li>全文索引相比其他索引在 INSERT、UPDATE 和 DELETE 操作的代价都很大：<ul><li>修改文本中的100个单词，需要100次索引操作，而不是一次。</li><li>一般情况，列长度不会影响其他索引类型，但对于全文索引，个位数单词文本和10000个单词的文本，性能可能相差几个数量级。</li><li>全文索引有更多碎片，可能需要做更多的 <code>OPTIMIZE TABLE</code> 操作。</li></ul></li><li>全文索引影响优化器：<ul><li>查询中使用了 <code>MATCH AGAINST</code> 子句，对应列有可用的全文索引，这种情况一定会使用全文索引，即使可能有性能更好的其他索引。</li><li>全文索引只能用作全文搜索匹配，任何其他操作，如WHERE条件比较，都需要在MySQL完成全文搜索返回记录后才能进行，普通索引可以在处理WHERE条件时一次判断多个比较表达式。</li><li>全文索引不存储索引列的实际值，索引不能用作索引覆盖扫描。</li><li>除了相关性排序，全文索引不能用于其他排序。</li></ul></li></ul><h2 id="十一-分布式（XA）事务"><a href="#十一-分布式（XA）事务" class="headerlink" title="十一. 分布式（XA）事务"></a>十一. 分布式（XA）事务</h2><h3 id="11-1-MySQL中的XA事务"><a href="#11-1-MySQL中的XA事务" class="headerlink" title="11.1 MySQL中的XA事务"></a>11.1 MySQL中的XA事务</h3><p>存储引擎的事务特性能保证在存储引擎级别实现ACID，分布式事务则可以扩展到数据库层面，以及多个数据库之间。通过<strong>两阶段提交</strong>来实现。</p><p>MySQL 在 5.0 版本支持 XA 事务，XA事务需要有一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）；如果协调器收到所有参与者都准备好的消息，就会告诉事务可以提交了（第二阶段）。MySQL在 XA 事务中的角色是参与者而不是协调者。</p><h3 id="11-2-内部XA事务"><a href="#11-2-内部XA事务" class="headerlink" title="11.2 内部XA事务"></a>11.2 内部XA事务</h3><h4 id="（1）二进制日志在使用XA事务"><a href="#（1）二进制日志在使用XA事务" class="headerlink" title="（1）二进制日志在使用XA事务"></a>（1）二进制日志在使用XA事务</h4><p>MySQL本身的插件式架构导致其内部需要使用XA事务。MySQL中各个存储引擎相互独立，无法感知对方的存在，所以一个跨存储引擎的事务需要一个外部的协调者，否则无法满足ACID。</p><p>存储引擎提交的同时，需要将提交信息写入二进制日志，这就是一个分布式事务，可以把二进制日志操作看作一个独立的存储引擎。</p><h4 id="（2）XA事务影响性能"><a href="#（2）XA事务影响性能" class="headerlink" title="（2）XA事务影响性能"></a>（2）XA事务影响性能</h4><p>XA事务导致MySQL性能大幅下降，直接破坏了MySQL内部的批量提交（一种通过单磁盘I/O操作完成多个事务提交的技术，已有多种解决方案），使得MySQL不得不进行多次额外的 <code>fsync()</code> 调用。</p><p>一个事务若是开启了二进制日志，不仅需要对二进制日志进行持久化操作，InnoDB事务日志还需要两次日志持久化操作。即<strong>二进制日志安全的事务实现需要至少三次 <code>fsync()</code> 操作。</strong></p><h4 id="（3）配置项"><a href="#（3）配置项" class="headerlink" title="（3）配置项"></a>（3）配置项</h4><p>可以通过将 <code>innodb_support_xa</code> 设置为0 关闭二进制日志（复制需要二进制日志和XA事务的支持，所以此设置也会使复制无法使用）。</p><p>将 <code>sync_binlog</code> 设置为1，保证存储引擎和二进制日志是真正同步的。否则事务提交了二进制日志却可能未“提交”到磁盘。</p><h3 id="11-3-外部XA事务"><a href="#11-3-外部XA事务" class="headerlink" title="11.3 外部XA事务"></a>11.3 外部XA事务</h3><p>MySQL能够作为参与者完成一个外部的分布式事务，但其对XA协议的支持还不完整，如当前版本还不支持一个事务中多个连接可以做关联。</p><p>因为通信延迟和参与者本身可能失败，外部XA事务会比内部的消耗更大。对于网络环境不稳定或用户长时间等待而不提交，需要避免使用XA事务，它会影响所有参与者。</p><p>XA事务是一种在多个服务器之间同步数据的方法，不能使用MySQL本身的复制，以及性能非瓶颈时可以尝试使用。</p><h2 id="十二-查询缓存"><a href="#十二-查询缓存" class="headerlink" title="十二. 查询缓存"></a>十二. 查询缓存</h2><h3 id="12-1-什么是查询缓存？"><a href="#12-1-什么是查询缓存？" class="headerlink" title="12.1 什么是查询缓存？"></a>12.1 什么是查询缓存？</h3><p>MySQL可以缓存查询的执行计划，相同类型的SQL可以跳过SQL的解析和执行计划生成阶段；查询缓存是另一种缓存类型，缓存完整的SELECT结果。</p><p>命中查询缓存后会直接返回结果，跳过了解析、优化和执行阶段。</p><p>查询缓存系统会跟踪查询涉及的每张表，当表发生变化会导致相关的缓存数据失效；虽然看起来这种实现比较低效率，因为表变化时未必会导致数据查询结果有变更，但这样的实现代价很小。</p><p>查询缓存对于应用程序来说是完全透明的。</p><h3 id="12-2-谨慎使用查询缓存"><a href="#12-2-谨慎使用查询缓存" class="headerlink" title="12.2 谨慎使用查询缓存"></a>12.2 谨慎使用查询缓存</h3><p>查询缓存是一个影响服务器扩展性的因素，可能会变成整个服务器的资源竞争点，在多核服务器上甚至可能导致服务器僵死。默认建议关闭查询缓存，如果判断查询缓存很有作用，也应该只配置一个较小的查询缓存空间（如几十兆）。</p><h3 id="12-3-MySQL如何判断缓存命中？"><a href="#12-3-MySQL如何判断缓存命中？" class="headerlink" title="12.3 MySQL如何判断缓存命中？"></a>12.3 MySQL如何判断缓存命中？</h3><p>缓存存放在一个引用表中，通过一个哈希值引用，哈希值包括查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能会影响返回结果的信息。</p><p>当判断缓存是否命中时，MySQL不会解析、正规化或参数化查询语句，而是直接使用SQL语句和其他收到的原始信息来判断。<strong>任何字符上的不同，如空格、注释等都会导致缓存不命中</strong>。</p><p>当查询语句中有一些不确定的数据时，不会被缓存。如函数 <code>NOW()</code> 或 <code>CURRENT_DATE()</code> 的查询不会被缓存，以及 <code>CURRENT_USER</code> 或 <code>CONNECTION_ID()</code> 。总结，<strong>查询包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库的系统表，或任何包含列级别权限的表，都不会被缓存</strong>。</p><p>MySQL并不解析SQL，它如何知道查询中含有不确定的函数？MySQL通过一个大小写不敏感的检查确认SQL语句是否以SEL开头。查询缓存是在完整的SELECT语句基础之上，只有在刚收到SQL语句时检查，所以子查询和存储过程都无法使用查询缓存。</p><h3 id="12-4-使用限制"><a href="#12-4-使用限制" class="headerlink" title="12.4 使用限制"></a>12.4 使用限制</h3><ul><li>开启查询缓存会对读写操作都带来额外的消耗：<ul><li>读查询在开始前要检查是否命中缓存；</li><li>读查询可以被缓存，在执行完成后，MySQL检查还未被缓存，会将结果存入查询缓存；</li><li>向某个表写入数据时，MySQL要将相关缓存设置失效。如果查询缓存很大或者碎片很多</li></ul></li><li>对查询缓存操作是一个加锁排他操作。</li><li>事务中修改某表会使对应查询缓存都设置失效，但InnoDB的多版本特性会暂时将这个修改对其他事务屏蔽，此事务提交前，这个表的相关查询无法被缓存，只能在事务提交后才被缓存。因此，长时间运行的事务会大大降低查询缓存的命中率。</li><li>查询缓存可能会使用大量的内存，并且因为操作靠一个全局锁保护，所有需要做该操作的查询都要等待这个锁。</li></ul><h3 id="12-5-查询缓存如何使用内存"><a href="#12-5-查询缓存如何使用内存" class="headerlink" title="12.5 查询缓存如何使用内存"></a>12.5 查询缓存如何使用内存</h3><p>查询缓存全部存储在内存中。除了查询结果，还要存放一些维护相关的数据，类似于文件系统：（大概需要40KB的内存资源）</p><ul><li>确定哪些内存目前可用；</li><li>哪些已经用掉；</li><li>哪些用来存储数据表和查询结果之前的映射；</li><li>哪些用来存储数据表和查询结果之前的映射；</li><li>哪些用来存储查询字符串和查询结果。</li></ul><p>MySQL用于查询缓存的内存被分为一个个的数据块，数据块是变长的。每个数据块存储了自己的类型、大小和数据本身，还外加指向前一个和后一个数据块的指针。</p><p>数据块类型：不同存储块在内存使用上没有不同</p><ul><li>存储查询结果</li><li>存储查询和数据表的映射</li><li>存储查询文本</li></ul><p>使用流程：</p><ul><li>服务器启动时，先初始化查询缓存需要的内存，内存池初始是一个完整的空闲块。空闲块的大小就是所配置查询缓存大小再减去用于维护元数据的数据结构所消耗的空间。</li><li>当有查询结果需要缓存时，MySQL先从大的空间块中申请一个数据块用于存储结果。这个数据块需要大于配置 <code>query_cache_min_res_unit</code> ，即使查询结果远远小于此。因为需要在查询开始返回结果的时候就分配空间，此时是无法预知查询结果有多大，MySQL无法为每个查询结果精确分配空间。</li></ul><p>分配内存块操作很慢，需要先锁住空间块，然后找到合适大小的数据块。当需要缓存一个查询结果时，MySQL先选择一个尽可能小的内存块，然后将结果存入其中。如果数据块全部用完，但仍有数据需要存储，MySQL会申请一块新数据块（尽量小）。查询完成后有剩余会被释放。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010102.png" alt></p><p>上述分配内存块并非指<strong>通过函数 <code>malloc()</code> 向操作系统申请内存</strong>，此操作只在初次创建查询缓存时执行一次。指的是在空闲块列表中找到一个合适的内存块，或者从正在使用的、待淘汰的内存块中回收再使用（MySQL自己管理内存）。</p><p>假设平均查询结果很小，服务器在并发地向不同的两个连接返回结果，返回结果后MySQL回收剩余数据块空间时会发现，回收的数据块小于 <code>query_cache_min_res_unit</code> ，所以不能直接在后续的内存块中分配使用：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010103.png" alt></p><h3 id="12-6-适用场景"><a href="#12-6-适用场景" class="headerlink" title="12.6 适用场景"></a>12.6 适用场景</h3><p>理论上可以通过对比打开和关闭查询缓存的系统效率来判断：关闭查询缓存时，每个查询都需要完整的执行，每次写操作执行完成后立刻返回；打开查询缓存时，每次读请求先检查缓存是否命中，如果命中则立刻返回，否则就完整地执行查询，每次写操作则需要检查查询缓存中是否有需要失效的缓存，然后再返回。</p><p>对于一些需要消耗大量资源的查询通常都适合使用缓存，如汇总计算查询 <code>COUNT()</code> ；较为复杂的SELECT语句，如多表JOIN后还需要做排序和分页，此类查询每次执行消耗都很大，但返回结果集很小，非常适合查询缓存（UPDATE、DELETE 和 INSERT 操作要占比小）。</p><p>一个判断查询缓存是否有效的直接数据是命中率，即使用查询缓存返回结果占总查询的比率。当MySQL接收到一个SELECT查询时，要么增加 <code>Qcache_hits</code> 的值，要么增加 <code>Com_select</code> 的值。计算查询缓存命中率： <code>Qcache_hits / ( Qcache_hits + Com_select )</code> 。命中率多大才合适很难判断，有时即使很低的命中率对于性能提升也有好处。</p><p>缓存未命中的几种可能：</p><ul><li>查询语句无法被缓存，如包含不确定的函数、查询结果太大而无法缓存，都会导致状态值 <code>Qcache_not_cached</code> 增加。</li><li>MySQL从未处理这个查询，所以结果也不曾被缓存过。</li><li>虽然缓存了结果，但由于查询缓存的内存用完，需要将某些缓存移除；或是数据表被修改导致缓存失效。</li><li>大量缓存未命中，但实际上绝大数查询都缓存了：<ul><li>查询缓存还未完成预热；</li><li>查询语句之前从未执行，若应用不会重复执行一条查询语句，即使完成预热仍会有很多缓存未命中；</li><li>缓存失效操作过多。</li></ul></li></ul><p>几种检查方案：</p><ul><li>通过参数 <code>Com_*</code> 来查看数据修改的情况，包括 Com_update，Com_delete等。</li><li>通过 <code>Qcache_lowmem_prunes</code> 来查看有多少次失效是由于内存不足导致的。</li><li>通过查看 <code>Com_select</code> 和 <code>Qcache_inserts</code> 的相对值来查看是否缓存结果未被其他SELECT语句使用。如果每次查询都是缓存未命中，然后需要将查询结果放到缓存中，那么二者值应该相当，所以期望的情况应该是 <code>Qcache_inserts</code> 远远小于 <code>Com_select</code> 。</li><li>更直观的方案：命中和写入的比率，即 <code>Qcache_hits</code> 和 <code>Qcache_inserts</code> 的比值，当结果大于3 : 1时一般表示缓存是有效的，最好是能达到10 : 1。</li></ul><h3 id="12-7-配置和维护"><a href="#12-7-配置和维护" class="headerlink" title="12.7 配置和维护"></a>12.7 配置和维护</h3><p>配置参数：</p><ul><li>query_cache_type：是否打开查询缓存，有 OFF、ON或DEMAND，DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才放入查询缓存。</li><li>query_cache_size：查询缓存使用的总内存空间，单位为字节，必须是1024的整数倍。</li><li>query_cache_min_res_unit：在查询缓存中分配内存块时的最小单位。</li><li>query_cache_limit：MySQL能缓存的最大查询结果，超过此值不会被缓存，只有结果全部返回时才能知道是否超出限制。</li><li>query_cache_wlock_invalidate：某个表被其他连接锁住，是否依然可以从查询缓存中返回结果。</li></ul><p>如何减少碎片：暂略。</p><p>提供查询缓存的使用率：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010104.png" alt></p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：分区表，视图，外键约束，内部存储代码，游标，绑定变量，用户自定义函数，全文索引，分布式事务，查询缓存等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（五）查询性能优化</title>
    <link href="http://linyishui.top/2020122901.html"/>
    <id>http://linyishui.top/2020122901.html</id>
    <published>2020-12-29T12:13:34.000Z</published>
    <updated>2021-03-03T13:14:01.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（五）查询性能优化"><a href="#《高性能MySQL》（五）查询性能优化" class="headerlink" title="《高性能MySQL》（五）查询性能优化"></a>《高性能MySQL》（五）查询性能优化</h1><p>查询优化、索引优化、库表结构优化需要齐头并进。</p><h2 id="一-为什么查询速度会慢"><a href="#一-为什么查询速度会慢" class="headerlink" title="一. 为什么查询速度会慢"></a>一. 为什么查询速度会慢</h2><p>查询是一项任务，由一系列子任务组成，每个子任务都要消耗一定时间，优化查询就是要么消除一部分子任务、要么减少子任务的执行次数、要么提供子任务的执行速度。</p><p>查询的生命周期大致包括：从客户端、到服务器、服务器进行解析、生成执行计划、执行、返回结果给客户端。其中执行是最重要的阶段，包括大量检索数据到存储引擎以及后续数据处理，如排序、分组等。</p><p>查询会在如网络、CPU计算、生成统计信息和执行计划、锁等待（互斥等待）等操作上花费时间。慢查询普遍都会存在如操作被额外的重复执行了多次、某些操作执行的太慢等问题。</p><h2 id="二-优化数据访问"><a href="#二-优化数据访问" class="headerlink" title="二. 优化数据访问"></a>二. 优化数据访问</h2><p>大部分性能低下的查询都可以通过减少访问的数据量来优化：</p><ol><li>检查是否访问了太多的行或列；</li><li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li></ol><h3 id="2-1-是否向数据库请求了不需要的数据"><a href="#2-1-是否向数据库请求了不需要的数据" class="headerlink" title="2.1 是否向数据库请求了不需要的数据"></a>2.1 是否向数据库请求了不需要的数据</h3><ul><li><strong>查询不需要的记录</strong>：比如查询大量数据后，再仅显示前面N行。最简单的解决方案是查询加LIMIT。</li><li><strong>多表关联时返回全部列</strong>：比如 SELECT <em> FROM A JOIN B JOIN C ，实际上仅需要A表的列，改为 SELECT A.</em> 最好明确指定每个返回列。</li><li><strong>总是取出全部列</strong>：每次使用 <code>SELECT *</code> 时都要仔细思考是否需要全部列，有时DBA会禁止类似写法。</li><li><strong>重复查询相同的数据</strong>：比如用户评论时要获取头像URL，可以考虑缓存这类数据，避免每次都要重复查询。</li></ul><h3 id="2-2-是否在扫描额外的记录"><a href="#2-2-是否在扫描额外的记录" class="headerlink" title="2.2 是否在扫描额外的记录"></a>2.2 是否在扫描额外的记录</h3><p>衡量查询开销的三个指标：慢查询日志包含这三项内容</p><ul><li><strong>响应时间</strong>：服务时间+排队时间，但实际测量往往无法区分二者；</li><li><strong>扫描的行数</strong>：EXPLAIN的type列反应了访问类型，如全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等，速度由慢至快，扫描行数由多到少；访问类型不够合适时，最好创建一个合适的索引；<strong>MySQL不会返回真实的扫描行数，只会告知生成结果时一共扫描了多少行，但可能大部分行是被WHERE条件过滤</strong>；</li><li><strong>返回的行数</strong>：扫描的行数和返回行数的比值通常应该很小，介于1:1和1:10之间，当然有时也会很大（比如分组统计查询）。</li></ul><p>EXPLAIN的 Using where 表示MySQL将通过WHERE条件筛选存储引擎返回的记录，MySQL应用Where条件有三种方式，由好到坏依次是：</p><ol><li>在索引中使用WHERE条件来过滤不匹配的记录，在存储引擎层完成。</li><li>使用索引覆盖扫描（Extra列出现Using index）返回记录，直接从索引中过滤不需要的记录并返回命中的结果，在服务器层完成，但无需回表查询记录。</li><li>从数据表返回数据，过滤不满足条件的记录（Extra列出现Using where），在服务器层完成，需要先从数据表读出记录然后过滤。</li></ol><p>扫描行数远远大于返回行数，需要优化：</p><ul><li>使用索引覆盖扫描。</li><li>改变库表结构，如使用单独的汇总表。</li><li>重写复杂查询，让MySQL优化器可以以更优化的方式执行。</li></ul><h3 id="2-3-重构查询的方式"><a href="#2-3-重构查询的方式" class="headerlink" title="2.3 重构查询的方式"></a>2.3 重构查询的方式</h3><h4 id="2-3-1-判断一个复杂查询还是多个简单查询"><a href="#2-3-1-判断一个复杂查询还是多个简单查询" class="headerlink" title="2.3.1 判断一个复杂查询还是多个简单查询"></a>2.3.1 判断一个复杂查询还是多个简单查询</h4><p>设计查询时需要考虑的一个问题是：是否需要将一个复杂查询拆分为多个简单查询？我们普遍会选择让数据库尽可能的完成更多的工作，因为下意识会认为网络通信、查询解析和优化是一件代价很高的事情。</p><p>但对于MySQL来说，这种常识是不准确的：</p><ol><li>MySQL的连接和断开都很轻量；</li><li>现代网络速度越来越快，无论是带宽还是延迟；</li><li>MySQL每秒能在内存扫描上百万行数据，相比下响应数据给客户端要慢很多，其他条件不变的情况下越少查询是更好；</li><li>一些情况下切为小查询能减少工作量，并且能够带来整体性能的提升，小事务经常能更高效，并且若中间暂停一段时间，也可以把一次性的压力分散到大的时间段，降低对服务器的影响和锁的持有时间。</li></ol><h4 id="2-3-2-切分查询"><a href="#2-3-2-切分查询" class="headerlink" title="2.3.2 切分查询"></a>2.3.2 切分查询</h4><p>最常见的案例，比如要<strong>定期清除大量数据</strong>，如果一个语句一次完成可能会锁住很多数据、占满整个事务日志、消耗过多系统资源、阻塞很多小但重要的查询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一万行删除一次</span></span><br><span class="line">rows_affected = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">rows_affected = do_query(<span class="string">"DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-分解关联查询"><a href="#2-3-3-分解关联查询" class="headerlink" title="2.3.3 分解关联查询"></a>2.3.3 分解关联查询</h4><p><strong>对每个表进行一次单表查询，在应用层对结果进行关联</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--关联查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post</span><br><span class="line"><span class="keyword">ON</span> tag_post.tag_id = tag.tag_id</span><br><span class="line"><span class="keyword">JOIN</span> post</span><br><span class="line"><span class="keyword">ON</span> tag_post.post_id = post.post_id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="comment">--分解为三次单表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post_id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>让缓存效率更高，单表结果方便进行缓存，已缓存的数据下次就可以跳过；关联的表发生变化会使MySQL查询缓存失效；</li><li>查询分解后可以减少锁的竞争；</li><li>应用层做关联更容易对数据库进行拆分，方便高性能和可扩展；</li><li>查询效率本身也有提升，上述例子使用 <code>IN()</code> 代替关联查询可以使MySQL按照ID顺序查询，要比随机关联高效。</li><li>减少冗余记录的查询，在应用层做关联意味着某条记录只需查询一次，而在数据库关联查询可能需要重复的访问一部分数据。</li></ul><p>适用场景：</p><ul><li>应用方便缓存单个查询的结果时；</li><li>可以将数据分布到不同的MySQL服务器时；</li><li>能够使用 <code>IN()</code> 代替关联查询时；</li><li>当查询中使用同一个数据表时。</li></ul><h2 id="三-查询执行的基础"><a href="#三-查询执行的基础" class="headerlink" title="三. 查询执行的基础"></a>三. 查询执行的基础</h2><h3 id="3-1-一个查询在MySQL中的执行过程"><a href="#3-1-一个查询在MySQL中的执行过程" class="headerlink" title="3.1 一个查询在MySQL中的执行过程"></a>3.1 一个查询在MySQL中的执行过程</h3><p>MySQL执行一个查询的过程：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280108.png" alt></p><ol><li>客户端发送一条查询给服务器。</li><li>服务器先检查缓存，若命中缓存就立即返回结果。否则进入下一步。</li><li>服务器进行SQL解析、预处理，再由优化器生成对应的执行计划。</li><li>根据执行计划调用存储引擎的API来执行查询。</li><li>将结果返回客户端。</li></ol><h3 id="3-2-MySQL-客户端-服务器通信协议"><a href="#3-2-MySQL-客户端-服务器通信协议" class="headerlink" title="3.2 MySQL 客户端 / 服务器通信协议"></a>3.2 MySQL 客户端 / 服务器通信协议</h3><p>MySQL 客户端 / 服务器通信协议是<strong>半双工协议</strong>，即要么服务器向客户端发送数据、要么客户端向服务器发送数据，两个动作不能同时发生。</p><p>优点是通信简单快速，缺点是无法进行流量控制。一方一旦开始发送消息，另一方只能接收完整消息后才能进行响应。一方不能使另一方停止，MySQL一般要等所有数据都发送给客户端后才能释放查询所占用的资源，所以客户端缓存数据可以减轻服务器压力，让查询尽快结束早点释放资源。</p><p>查看MySQL连接/线程的状态：<code>SHOW FULL PROCESSLIST</code> </p><ul><li>Sleep：线程正在等待客户端发送新的请求。</li><li>Query：线程正在执行查询或正在将结果发送给客户端。</li><li>Locked：在MySQL服务器层，该线程正在等待表锁；存储引擎级别的锁（如行锁）不会体现在线程状态。</li><li>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li><li>Copying to tmp table [on disk]：线程正在执行查询，并将结果集都复制到一个临时表中，一般是在做GROUP BY操作、文件排序、UNION操作等；on disk表示正在将一个内存表放到磁盘。</li><li>Sorting result：线程正在对结果集进行排序。</li><li>Sending data：线程可能在多个状态间传送数据、或者生成结果集、或者在向客户端返回数据。</li></ul><h3 id="3-3-查询优化处理"><a href="#3-3-查询优化处理" class="headerlink" title="3.3 查询优化处理"></a>3.3 查询优化处理</h3><p>查询的生命周期中下一步是<strong>将一个SQL转换为一个执行计划</strong>，MySQL按照执行计划和存储引擎交互：</p><ul><li><strong>解析SQL</strong>：MySQL通过关键字将SQL语句进行解析，生成一棵解析树，通过MySQL语法规则进行验证和解析查询（如关键字是否正确、顺序是否正确、引号前后是否匹配）。</li><li><strong>预处理</strong>：根据一些MySQL规则进一步检查解析树是否合法（数据表和列是否存在、名字或别名是否有歧义），验证权限。</li><li><strong>优化SQL执行计划</strong></li></ul><p><strong>查询优化器</strong>：MySQL使用基于成本的优化器，预测一个查询使用某种执行计划时的成本并选择最小的一个。</p><p>导致优化器选择错误执行计划的原因：</p><ul><li>统计信息不准确，评估成本依赖存储引擎提供的统计信息，有时信息的偏差会很大，如MVCC架构并不维护数据表行数的精确统计。</li><li>执行计划的成本估算并不等价于实际执行的成本，如读取的页面可能在内存或磁盘，具体要多少次物理I/O无法得知。</li><li>MySQL的最优并不一定是最快的执行方式，只是基于成本模型的最优计划。</li><li>MySQL并不考虑其他并发执行的查询。</li><li>MySQL并不考虑不受控制的操作的成本，如存储过程或自定义函数。</li><li>有些特殊情况并不基于成本选择优化，如全文搜索的 <code>MATCH()</code> 子句，存在全文索引就会使用，即使有时别的索引和WHERE条件会更快。</li></ul><p>优化器的优化策略：</p><ul><li>静态优化：直接对解析树进行分析，并完成优化。</li><li>动态优化：与查询的上下文或其他因素有关，如WHERE条件取值、索引中条目对应的数据行数等，需要每次查询时重新评估。</li></ul><p>能够优化的类型：</p><ul><li>重新定义关联表的顺序</li><li>将外连接转化为内连接</li><li>使用等价变换规则</li><li>优化 <code>COUNT()</code> 、<code>MIN()</code> 和 <code>MAX()</code> ，找到某一列最小值只需查询对应B-Tree索引最左端的记录，使用此类优化在EXPLAIN中会出现 <code>Select tables optimized away</code> 表示优化器从执行计划中移除该表，用一个常数取代。</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表 <code>IN()</code> 的比较</li></ul><h3 id="3-4-MySQL如何执行关联查询"><a href="#3-4-MySQL如何执行关联查询" class="headerlink" title="3.4 MySQL如何执行关联查询"></a>3.4 MySQL如何执行关联查询</h3><h4 id="3-4-1-MySQL中的关联查询"><a href="#3-4-1-MySQL中的关联查询" class="headerlink" title="3.4.1 MySQL中的关联查询"></a>3.4.1 MySQL中的关联查询</h4><p>MySQL中每个查询都是一次关联。比如对于UNION查询，MySQL先将一系列单个查询的结果放在一个临时表中，然后再重新读出临时表数据完成UNION查询。</p><p>MySQL中关联查询流程：</p><ul><li>MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去直到找到所有表中匹配的行为止。</li><li>然后根据各个表匹配的行，返回查询中需要的各个列。</li><li>MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行，返回到上一层关联表继续查找更多匹配的记录，依次迭代执行。</li></ul><p>关联操作1如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tab1.col1, tab2.col2</span><br><span class="line"><span class="keyword">FROM</span> tab1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tab2 <span class="keyword">USING</span>(col3)</span><br><span class="line"><span class="keyword">WHERE</span> tab1.col1 <span class="keyword">IN</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>伪代码如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030101.png" alt></p><p>关联操作2如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tab1.col1, tab2.col2</span><br><span class="line"><span class="keyword">FROM</span> tab1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> tab2 <span class="keyword">USING</span>(col3)</span><br><span class="line"><span class="keyword">WHERE</span> tab1.col1 <span class="keyword">IN</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>伪代码如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030102.png" alt></p><p>关联操作1的内连接使用泳道图表示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030103.png" alt></p><h4 id="3-4-2-执行计划"><a href="#3-4-2-执行计划" class="headerlink" title="3.4.2 执行计划"></a>3.4.2 执行计划</h4><p>MySQL并不像其他关系型数据库那样生成查询字节码来执行查询，而是<strong>生成查询的一棵指令树</strong>，最终的执行计划包含了重构查询的全部信息。</p><p>对某个查询执行 <code>EXPLAIN EXTENDED</code> ，然后再执行 <code>SHOW WARNINGS</code> 可以看到重构出的查询。</p><p>任意多表查询都可以使用一棵树表示，如下图为一个四表关联操作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030104.png" alt></p><p>上图这种平衡树并非MySQL执行查询的方式，MySQL总是从一个表开始嵌套循环、回溯完成所有表关联，所以是下图这种<strong>左侧深度优先树</strong>：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030105.png" alt></p><h4 id="3-4-3-关联查询优化器"><a href="#3-4-3-关联查询优化器" class="headerlink" title="3.4.3 关联查询优化器"></a>3.4.3 关联查询优化器</h4><p>关联查询优化是优化器最重要的部分，决定多个表关联的顺序。优化器通过评估不同顺序的成本选择一个代价最小的关联顺序。</p><p>有时优化器选择的并非一定是最优顺序，此时可以使用 <code>STRAIGHT_JOIN</code> 关键字重写查询，让优化器按指定顺序执行，绝大部分情况优化器的判断要比开发者精准。</p><p>优化器如何计算成本：</p><ul><li>一般会遍历每个表逐个做嵌套循环计算每一棵执行计划树的成本。</li><li>但如果有超过N个表关联，需要检查N的阶乘种关联顺序；比如N=10时就有3628800种关联顺序，过多的可能导致优化器不可能逐一评估每种顺序的成本；</li><li>当搜索空间特别大时，优化器选择贪婪搜索方式，而非逐个评估。</li></ul><h3 id="3-5-排序优化"><a href="#3-5-排序优化" class="headerlink" title="3.5 排序优化"></a>3.5 排序优化</h3><ul><li>无论怎样，排序都是一个成本很高的操作，在不能使用索引排序时，数据量小的排序会在内存中进行，数据量大时需要使用磁盘；</li><li>判断条件是需要排序的数据量是否小于<strong>排序缓冲区</strong>；</li><li>内存中直接使用快速排序；内存不够排序，先将数据分块，每个块进行快速排序，结果存放在磁盘，然后将排好序的各个块合并，并返回最终结果。</li><li>在关联查询时如果需要排序，MySQL分两种情况来处理：<ul><li>ORDER BY 子句中所有列都来自于关联的第一个表，MySQL在处理第一个表时就进行文件排序，这种情况EXPLAIN 的 Extra 字段会有 <code>Using filesort</code> ；</li><li>其他情况下，MySQL都会将关联的结果放到一个临时表中，然后在所有的关联结束后再进行文件排序，这种情况EXPLAIN 的 Extra 字段会有 <code>Using temporary; Using filesort</code> ；查询中有LIMIT会在排序后应用，MySQL 5.6 版本后，当只需返回部分排序结果时不会对所有结果进行排序。</li></ul></li></ul><h2 id="四-查询优化器"><a href="#四-查询优化器" class="headerlink" title="四. 查询优化器"></a>四. 查询优化器</h2><h3 id="4-1-查询优化器的局限性"><a href="#4-1-查询优化器的局限性" class="headerlink" title="4.1 查询优化器的局限性"></a>4.1 查询优化器的局限性</h3><h4 id="4-1-1-关联子查询"><a href="#4-1-1-关联子查询" class="headerlink" title="4.1.1 关联子查询"></a>4.1.1 关联子查询</h4><p>MySQL子查询十分糟糕，特别是WHERE条件包含 <code>IN()</code> 的子查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id = <span class="number">1</span>);</span><br><span class="line"><span class="comment">--MySQL会先执行子查询，返回所有actor_id = 1的film_id，所以我们会认为会如下执行：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span>(XXX, XXX, ......, XXX);</span><br><span class="line"><span class="comment">--但实际上，MySQL会将外层表压到子查询中，因为它认为这样可以更快的找到数据行：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film.film_id = film_actor.film_id);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030106.png" alt></p><p>MySQL选择先对file表进行全表扫描，根据返回的film_id逐个执行子查询，当数据量大时这种执行性能会很糟糕，所以我们可以改写查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用内连接代替IN子查询：</span></span><br><span class="line"><span class="keyword">SELECT</span> film.* <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">--使用函数GROUP_CONCAT拼接一个逗号分隔的列表：</span></span><br><span class="line">（省略）</span><br></pre></td></tr></table></figure><h4 id="4-1-2-UNION取LIMIT时内外层优化"><a href="#4-1-2-UNION取LIMIT时内外层优化" class="headerlink" title="4.1.2 UNION取LIMIT时内外层优化"></a>4.1.2 UNION取LIMIT时内外层优化</h4><p>有时我们希望对UNION的结果集只获取前N条记录，可以在每个子句中添加LIMIT，为了保证获取正确的顺序，需要在外层再增加一个全局的 ORDER BY 和 LIMIT 操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a)</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">20</span></span><br><span class="line"><span class="comment">-- 改写为</span></span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">20</span>)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">20</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-索引合并优化"><a href="#4-1-3-索引合并优化" class="headerlink" title="4.1.3 索引合并优化"></a>4.1.3 索引合并优化</h4><p>WHERE子句包含多个复杂条件时，MySQL可以访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</p><h4 id="4-1-4-等值传递"><a href="#4-1-4-等值传递" class="headerlink" title="4.1.4 等值传递"></a>4.1.4 等值传递</h4><p>如一个非常大的 <code>IN()</code> 列表，优化器发现有WHERE、ON或USING的子句，将这个列表的值和另外一个表的某个列关联。优化器会将列表都复制应用到关联的各个表中，列表特别大会导致无法高效的从表中过滤记录。</p><h4 id="4-1-5-并行执行"><a href="#4-1-5-并行执行" class="headerlink" title="4.1.5 并行执行"></a>4.1.5 并行执行</h4><p>MySQL无法利用多核来并行执行查询。</p><h4 id="4-1-6-哈希关联"><a href="#4-1-6-哈希关联" class="headerlink" title="4.1.6 哈希关联"></a>4.1.6 哈希关联</h4><p>MySQL只支持嵌套循环关联，只能通过建立哈希索引来变相的实现哈希关联</p><h4 id="4-1-7-松散索引扫描"><a href="#4-1-7-松散索引扫描" class="headerlink" title="4.1.7 松散索引扫描"></a>4.1.7 松散索引扫描</h4><p>MySQL不支持松散索引扫描，无法按照不连续的方式扫描一个索引。假设有索引 <code>(A,B)</code> 查询 <code>SELECT ... FROM TB WHERE B BETWEEN 2 AND 3</code> 因为索引前导字段是A，但查询只指定了B，所以无法使用索引，只能全表扫描。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210101.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210102.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210103.png" alt></p><h4 id="4-1-8-最大值和最小值优化"><a href="#4-1-8-最大值和最小值优化" class="headerlink" title="4.1.8 最大值和最小值优化"></a>4.1.8 最大值和最小值优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(actor_id) <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> first_name = <span class="string">'XX'</span>;</span><br><span class="line"><span class="comment">--因为first_name并没有索引，所以MySQL会进行一次全表扫描，通过SHOW STATUS确认</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ...;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="comment">--优化：使用LIMIT重写</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">USE</span> <span class="keyword">INDEX</span>(PRIMARY) <span class="keyword">WHERE</span> first_name = <span class="string">'XX'</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-查询优化器的提示"><a href="#4-2-查询优化器的提示" class="headerlink" title="4.2 查询优化器的提示"></a>4.2 查询优化器的提示</h3><p>暂略。</p><h3 id="4-3-优化特定类型的查询"><a href="#4-3-优化特定类型的查询" class="headerlink" title="4.3 优化特定类型的查询"></a>4.3 优化特定类型的查询</h3><h4 id="4-3-1-优化COUNT"><a href="#4-3-1-优化COUNT" class="headerlink" title="4.3.1 优化COUNT()"></a>4.3.1 优化COUNT()</h4><p>COUNT(*) 统计结果集的行数，COUNT(row) 统计某个列值的数量，二者含义不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--一个查询统计不同颜色</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">IF</span>(color = <span class="string">'blue'</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">AS</span> blue, <span class="keyword">SUM</span>(<span class="keyword">IF</span>(color = <span class="string">'red'</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(color = <span class="string">'blue'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> blue, <span class="keyword">COUNT</span>(color = <span class="string">'red'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br></pre></td></tr></table></figure><p>不需要精确值时可以使用近似值代替，比如EXPLAIN的估算行数。</p><p>COUNT() 一般都需要扫描大量的数据行才能获得精确的结果，只能加索引覆盖扫描，如果这样还不能解决性能问题，只能考虑修改应用的架构，比如增加汇总表 / 缓存系统等。</p><h4 id="4-3-2-优化关联查询"><a href="#4-3-2-优化关联查询" class="headerlink" title="4.3.2 优化关联查询"></a>4.3.2 优化关联查询</h4><ul><li>确保ON或USING子句的列上有索引，创建索引时要考虑关联的顺序，当表A和B用列c关联，若优化器的关联顺序的B、A，那么B表就不需要创建索引，<strong>一般关联只需在关联顺序的第二张表对应列上创建索引</strong>。</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li><li>升级MySQL时注意关联语法、运算符优先级等其他可能会发生变化的地方，普通关联可能会变成笛卡尔积，不同类型的关联可能会生成不同的结果。</li></ul><h4 id="4-3-3-优化子查询"><a href="#4-3-3-优化子查询" class="headerlink" title="4.3.3 优化子查询"></a>4.3.3 优化子查询</h4><p>尽可能用关联查询代替子查询。</p><h4 id="4-3-4-优化GROUP-BY和DISTINCT"><a href="#4-3-4-优化GROUP-BY和DISTINCT" class="headerlink" title="4.3.4 优化GROUP BY和DISTINCT"></a>4.3.4 优化GROUP BY和DISTINCT</h4><p>MySQL优化器会在内部处理时相互转换这两类查询，使用索引来优化；若索引无法使用，GROUP BY 会使用<strong>临时表</strong>或<strong>文件排序</strong>来做分组。</p><p>对关联查询做分组，并且按照查找表中的某个列进行分组，采用查找表的标识列效率会较高：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--效率差</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name,actor.last_name, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.first_name,actor.last_name</span><br><span class="line"><span class="comment">--效率高</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name,actor.last_name, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id</span><br><span class="line"><span class="comment">--这种写法只是在姓名和actor_id直接关联的情况下可以这样用，且有一些问题</span></span><br></pre></td></tr></table></figure><h4 id="4-3-5-优化LIMIT分页"><a href="#4-3-5-优化LIMIT分页" class="headerlink" title="4.3.5 优化LIMIT分页"></a>4.3.5 优化LIMIT分页</h4><p>分页操作：使用LIMIT加偏移量实现，加上合适的ORDER BY子句。</p><p>偏移量非常大时，比如 LIMIT 10000,20 只返回20条数据抛弃前面10000条记录。优化要么在页面中限制分页的数量，要么优化大偏移量的性能。</p><ul><li><p><strong>延迟关联</strong>：最简单就是使用索引覆盖扫描，而不是返回所有列。然后根据需要再做一次关联操作返回所有列，这种改法对于偏移量大的情况效率提升比较高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>;</span><br><span class="line"><span class="comment">--优化为：</span></span><br><span class="line"><span class="keyword">SELECT</span> film.film_id, film.description </span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span>(<span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>) <span class="keyword">AS</span> lim <span class="keyword">USING</span>(film_id)</span><br></pre></td></tr></table></figure></li><li><p>LIMIT可以转换为已知位置的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--上述查询可改为：</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, description </span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">position</span> <span class="keyword">BETWEEN</span> <span class="number">50</span> <span class="keyword">TO</span> <span class="number">54</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">position</span>;</span><br></pre></td></tr></table></figure></li><li><p>LIMIT查询主要问题是OFFSET会导致MySQL扫描大量不需要的行并且丢弃掉，可以记录上次取数据的位置，下次直接从该位置开始扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--第一次查询，返回主键为16049到16030的租借记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">--下次查询直接从16030开始</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">WHERE</span> rental_id &lt; <span class="number">16030</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-6-优化-SQL-CALC-FOUND-ROWS"><a href="#4-3-6-优化-SQL-CALC-FOUND-ROWS" class="headerlink" title="4.3.6 优化 SQL_CALC_FOUND_ROWS"></a>4.3.6 优化 SQL_CALC_FOUND_ROWS</h4><p>分页的一个常用技巧是<strong>在LIMIT语句中加上SQL_CALC_FOUND_ROWS提示</strong>，从而获得去掉LIMIT以后满足条件的行数，作为分页的总数，好像是MySQL预测到了总行数，但实际上MySQL需要扫描扫描所有满足条件的行来得到行数。</p><p>所以添加此提示后，不管是否需要，MySQL都会扫描所有满足条件的行，而不是满足LIMIT的行数后就终止扫描。</p><h4 id="4-3-7-优化-UNION-查询"><a href="#4-3-7-优化-UNION-查询" class="headerlink" title="4.3.7 优化 UNION 查询"></a>4.3.7 优化 UNION 查询</h4><p>MySQL总是会通过创建并填充临时表的方式来执行 UNION 查询，所以导致很多优化策略受限（经常要手工将WHERE，LIMIT，ORDER BY放到UNION子查询中以便优化器优化）。</p><p>除非必须要服务器消除重复的行，否则一定要使用UNION ALL，没有ALL时MySQL会给临时表增加DISTINCT选项，这会导致整个临时表做唯一性检查，这样的代价非常高。</p><h4 id="4-3-8-静态查询分析"><a href="#4-3-8-静态查询分析" class="headerlink" title="4.3.8 静态查询分析"></a>4.3.8 静态查询分析</h4><p>Percona Toolkit中的pt-query-advisor能够解析查询日志，分析查询模式，给出所有可能存在潜在问题的查询，并给出足够详细的建议。</p><h4 id="4-3-9-使用用户自定义变量"><a href="#4-3-9-使用用户自定义变量" class="headerlink" title="4.3.9 使用用户自定义变量"></a>4.3.9 使用用户自定义变量</h4><p>暂略。</p><h3 id="4-4-案例"><a href="#4-4-案例" class="headerlink" title="4.4 案例"></a>4.4 案例</h3><h3 id="4-4-1-构建一个队列表"><a href="#4-4-1-构建一个队列表" class="headerlink" title="4.4.1 构建一个队列表"></a>4.4.1 构建一个队列表</h3><ul><li><p>一个表包含多种类型的记录：未处理的记录、已处理记录、正在处理记录。</p></li><li><p>一个或多个消费者线程在表中查找未处理的记录，然后标记为正在处理，处理完成后再更新为已处理状态。</p></li><li><p>不合理的地方：</p><ul><li>随着队列表越来越大和索引深度的增加，找到未处理记录的速度越来越慢；可以将队列表拆分为已处理和未处理两部分来优化。</li><li>处理过程一般包括两步：找到未处理记录，然后加锁。前者增加服务器压力，加锁则让各个消费者线程增加竞争。</li></ul></li><li><p>如何让消费者标记正在处理的记录，而不使多个消费者重复处理同一记录？</p><ul><li><p>任何情况都应避免使用 SELECT FOR UPDATE ，会导致大量事务阻塞并等待；</p></li><li><p>用一个属性列标识正在处理记录的连接ID。</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">--查找未有线程处理且状态为待发送的记录ID</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span> unsent_emails</span><br><span class="line"><span class="keyword">WHERE</span> owner = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'unsent'</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">--result：123，456，789</span></span><br><span class="line"><span class="comment">--更新这些记录状态，并且将连接ID写入owner</span></span><br><span class="line"><span class="keyword">UPDATE</span> unsent_emails</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>, owner = CONNECTION_ID()</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span>(<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>上述SELECT走了索引，但FOR UPDATE锁会使其他查询阻塞，可以改进如下（无需用SELECT查询哪些记录还未被处理，可以用来改写所有的SELECT FOR UPDATE）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">UPDATE</span> unsent_emails</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>, owner = CONNECTION_ID()</span><br><span class="line"><span class="keyword">WHERE</span> owner = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'unsent'</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span> unsent_emails</span><br><span class="line"><span class="keyword">WHERE</span> owner = CONNECTION_ID()</span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>;</span><br><span class="line"><span class="comment">--result：123，456，789</span></span><br><span class="line"><span class="comment">--更新这些记录状态，并且将连接ID写入owner</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>基础原则：</p><ul><li>除非不得已，否则不要使用轮询。</li><li>尽量用UPDATE代替 SELECT FOR UPDATE，事务提交越快，持有锁的时间就越短，可以大大减少竞争和加速串行执行效率。</li><li>将已经处理完成和未处理数据分开，保证数据集足够小。</li><li>无法优化的查询尝试用不同策略来实现相同目的。</li><li>任务队列最好能从数据库移除，使用Redis、memcached、Q4M引擎等方案。</li></ul></li></ul><h3 id="4-4-2-计算两点之间的距离"><a href="#4-4-2-计算两点之间的距离" class="headerlink" title="4.4.2 计算两点之间的距离"></a>4.4.2 计算两点之间的距离</h3><p>感觉不是常用的场景，暂略。</p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：为什么查询速度会慢，优化数据访问，查询执行的基础，查询优化器等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（四）创建高性能索引</title>
    <link href="http://linyishui.top/2020122501.html"/>
    <id>http://linyishui.top/2020122501.html</id>
    <published>2020-12-25T12:14:26.000Z</published>
    <updated>2020-12-29T12:30:50.122Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（四）创建高性能索引"><a href="#《高性能MySQL》（四）创建高性能索引" class="headerlink" title="《高性能MySQL》（四）创建高性能索引"></a>《高性能MySQL》（四）创建高性能索引</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是索引？"><a href="#1-1-什么是索引？" class="headerlink" title="1.1 什么是索引？"></a>1.1 什么是索引？</h3><p>索引就像是书的目录，在MySQL中，存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> actor_id = <span class="number">5</span>;</span><br><span class="line"><span class="comment">--若actor_id列上有创建索引，MySQL先在索引上按值查找，然后返回所有包含值得数据行</span></span><br></pre></td></tr></table></figure><p><strong>MySQL只能高效的使用索引的最左前缀列，索引中列的顺序很重要</strong>。</p><h3 id="1-2-索引的类型"><a href="#1-2-索引的类型" class="headerlink" title="1.2 索引的类型"></a>1.2 索引的类型</h3><h4 id="1-2-1-B-Tree-索引"><a href="#1-2-1-B-Tree-索引" class="headerlink" title="1.2.1 B-Tree 索引"></a>1.2.1 B-Tree 索引</h4><p>虽然叫B-Tree索引，但存储引擎可能使用不同的存储结构，比如InnoDB使用的是 B+Tree、NDB集群使用的是 T-Tree 。MyISAM使用前缀压缩技术使得索引更小，InnoDB则按原数据格式存储；MyISAM索引通过数据的物理位置引用被索引的行，InnoDB则根据主键引用被索引的行。</p><p>B-Tree索引中所有值按顺序存储，每个叶子页到根的距离相同：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280101.png" alt></p><p>存储引擎从索引的根节点开始搜索，根节点的槽中存放了指向子节点的指针，通过指针向下层查找，通过比较节点页和要查找的值大小可以找到合适的指针到下一个子节点。叶子节点的指针指向被索引的数据。这种顺序存储很适合范围查询。</p><p>对于People表有索引包含last_name、first_name和dob，索引结构如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280102.png" alt></p><p>B-Tree 索引适用于<strong>全键值、键值范围或键前缀查找</strong>，键前缀查找只适用最左前缀：</p><ul><li><strong>全值匹配</strong>：和索引中所有列匹配，如查询叫 Cuba Allen、出生于XXX年的人。</li><li><strong>匹配最左前缀</strong>：只匹配索引第一列，如查询所有姓Allen的人。</li><li><strong>匹配列前缀</strong>：只匹配列值的开头部分，如查询所有J开头姓的人。</li><li><strong>匹配范围值</strong>：匹配列值得某个范围，如查询所有姓Allen与Barry之间的人。</li><li><strong>精确匹配某一列并范围匹配另外一列</strong>：第一列全匹配，第二列范围匹配，如查询所有姓Allen，名以K开头的人。</li><li><strong>只访问索引的查询</strong>：即查询只需访问索引，无须访问数据行，即<strong>覆盖索引</strong>。</li></ul><p>B-Tree索引支持的查询同样可以支持 ORDER BY 操作。</p><p>限制：</p><ul><li>非最左列开始无法命中索引；</li><li>不能跳过索引中的列；</li><li>查询中若有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ul><p>即从左到右依次扫描索引列，到遇到第一个范围查询（&gt;=, &gt;,&lt;, &lt;=, between ….. and ….）就停止扫描。</p><h4 id="1-2-2-哈希索引"><a href="#1-2-2-哈希索引" class="headerlink" title="1.2.2 哈希索引"></a>1.2.2 哈希索引</h4><ul><li>Memory和NDB存储引擎支持，基于哈希表实现，只有精确匹配索引所有列的查询才有效。</li><li>InnoDB有一个特殊的自适应哈希索引，在某些索引值使用非常频繁时，会在内存中基于B-Tree索引再创建一个哈希索引，从而加快查找速度。</li><li>每行数据会计算得到一个哈希码，存放在哈希索引中，同时在哈希表中保存指向每个数据行的指针。</li><li>哈希索引只包含哈希值和行指针，不存储字段值，所以不能像B-Tree索引那样避免读取行，但一般读行速度很快。</li><li>不按索引值顺序存储，无法用于排序。</li><li>不支持部分索引列匹配查找。</li><li>只支持等值比较查询，不支持任何范围查询。</li><li>哈希冲突需要遍历链表所有行指针，所以会影响性能。</li></ul><h4 id="1-2-3-空间数据索引（R-Tree）"><a href="#1-2-3-空间数据索引（R-Tree）" class="headerlink" title="1.2.3 空间数据索引（R-Tree）"></a>1.2.3 空间数据索引（R-Tree）</h4><ul><li>MyISAM支持空间索引，用来存储地理位置。</li></ul><h4 id="1-2-4-全文索引"><a href="#1-2-4-全文索引" class="headerlink" title="1.2.4 全文索引"></a>1.2.4 全文索引</h4><ul><li>全文索引类似于搜索引擎，查找的是文本中的关键词，而不是直接比较索引的值。</li><li>适用于 MATCH AGAINST 操作，而不是普通的 WHERE 条件操作。</li></ul><h3 id="1-3-索引的优点"><a href="#1-3-索引的优点" class="headerlink" title="1.3 索引的优点"></a>1.3 索引的优点</h3><ul><li>提高查询效率。</li><li>避免排序和临时表：B-Tree索引可以用于 ORDER BY 和 GROUP BY 操作。</li><li>减少了需要扫描的数据量：某些情况只使用索引就可以完成查询。</li><li>将随机I/O变为顺序I/O。</li></ul><p>索引非银弹，只有在索引能大大提高查询的效率，大于其带来的额外工作时，才是有效的，对于特别小的表全表查询可能会更高效，而特别大的表创建和使用索引的代价可能过于高昂。</p><h2 id="二-高性能索引策略"><a href="#二-高性能索引策略" class="headerlink" title="二. 高性能索引策略"></a>二. 高性能索引策略</h2><h3 id="2-1-独立的列"><a href="#2-1-独立的列" class="headerlink" title="2.1 独立的列"></a>2.1 独立的列</h3><p><strong>索引列不能是表达式的一部分，也不能是函数的参数</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> <span class="keyword">TO_DAYS</span>(<span class="keyword">CURRENT_DATE</span>) - <span class="keyword">TO_DAYS</span>(date_col) &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-前缀索引和索引选择性"><a href="#2-2-前缀索引和索引选择性" class="headerlink" title="2.2 前缀索引和索引选择性"></a>2.2 前缀索引和索引选择性</h3><p>当需要索引很长的字符列时（特别是BLOB、TEXT或很长的VARCHAR只能使用前缀索引），可以选择模拟哈希索引，也可以只索引开始的部分字符。</p><p>我们需要选择足够长的前缀保证有较高的选择性，可以通过真实数据统计前缀长度为多少时最合适。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建前缀索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">ADD</span> <span class="keyword">KEY</span> (city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure><p>前缀索引无法用于 ORDER BY 和 GROUP BY，也无法做覆盖扫描。</p><h3 id="2-3-多列索引"><a href="#2-3-多列索引" class="headerlink" title="2.3 多列索引"></a>2.3 多列索引</h3><p>为多列的每个列创建单独的索引一般不能提高查询性能，最好情况下也可能与最优索引的效率差几个数量级。</p><p>在EXPLAIN中看到索引合并（index_merge）大部分情况说明索引构建的很糟糕，有时甚至不如直接改写为UNION的方式。</p><h3 id="2-4-选择合适的索引列顺序"><a href="#2-4-选择合适的索引列顺序" class="headerlink" title="2.4 选择合适的索引列顺序"></a>2.4 选择合适的索引列顺序</h3><p>一个多列的B-Tree索引会按照最左列排序，然后是第二列、第三列等等。<strong>在不考虑排序和分组时，将选择性最高的列（根据条件命中条数最少）放到索引的最前列</strong>。</p><p>案例：</p><ol><li><p>慢查询SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> threadId) <span class="keyword">AS</span> COUNT_VALUE</span><br><span class="line"><span class="keyword">FROM</span> Message</span><br><span class="line"><span class="keyword">WHERE</span> (groupId = <span class="number">10137</span>) <span class="keyword">AND</span> (userId = <span class="number">1288826</span>) <span class="keyword">AND</span> (anonymous = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">priority</span> <span class="keyword">DESC</span>, modifiedDate <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></li><li><p>执行计划：看似选择了索引 <code>(groupId, userId)</code> 很合理</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id：<span class="number">1</span></span><br><span class="line">select_type：SIMPLE</span><br><span class="line"><span class="keyword">table</span>：Message</span><br><span class="line"><span class="keyword">type</span>：<span class="keyword">ref</span></span><br><span class="line">key：ix_groupId_userId</span><br><span class="line">key_len：<span class="number">18</span></span><br><span class="line"><span class="keyword">ref</span>: <span class="keyword">const</span>,<span class="keyword">const</span></span><br><span class="line">rows：<span class="number">1251162</span></span><br><span class="line">Extra：Using where</span><br></pre></td></tr></table></figure></li><li><p>选择性分析：条件几乎命中所有行，即索引没起到什么用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),              <span class="comment">--4142217</span></span><br><span class="line">       <span class="keyword">SUM</span>(groupId = <span class="number">10137</span>),  <span class="comment">--4092654</span></span><br><span class="line">       <span class="keyword">SUM</span>(userId = <span class="number">1288826</span>), <span class="comment">--1288496</span></span><br><span class="line">       <span class="keyword">SUM</span>(anonymous = <span class="number">0</span>)     <span class="comment">--4141934</span></span><br><span class="line"><span class="keyword">FROM</span> Message</span><br></pre></td></tr></table></figure></li><li><p>解决方案是修改应用代码，区分这部分异常数据。</p></li></ol><h3 id="2-5-聚簇索引"><a href="#2-5-聚簇索引" class="headerlink" title="2.5 聚簇索引"></a>2.5 聚簇索引</h3><p>聚簇索引是一种数据存储方式，InnoDB的聚簇索引实际上在同一结构中保存了B-Tree索引和数据行。聚簇表示数据行和相邻的键值紧凑的存储在一起，当表存在聚簇索引时，其数据行实际存放在索引的叶子页（leaf page）中。</p><p>如下图，叶子页包含了行的全部数据，而节点页只包含索引列：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280103.png" alt></p><p>InnoDB通过主键聚集数据，若没有指定主键，InnoDB会选择一个唯一的非空索引代替，没有这样的索引则会隐式的定义一个主键来作为聚簇索引。InnoDB只聚集同一个页面的记录，非同一页即使相邻键值也可能相距甚远。</p><p>聚集的优点：</p><ul><li>将相关的数据保存在一起，减少磁盘I/O操作；</li><li>数据访问更快，因为索引和数据保存在同一个B-Tree。</li><li>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</li></ul><p>聚集的缺点：</p><ul><li>若数据存放在内存，访问顺序就没那么重要，聚簇索引对于I/O的提升就不明显了。</li><li>插入速度严重依赖于插入顺序，最快是按照主键顺序插入，若非此顺序最好加载完成后通过 OPTIMIZE TABLE 重新组织一下表。</li><li>更新聚簇索引的代价高昂，会强制InnoDB将每个被更新的行移动到新位置。</li><li>基于聚簇索引的表在插入新行、或主键更新导致需要移动行时，会面临页分裂问题。行需要插入到某个已满的页中，存储引擎要把页分裂成两个页来容纳新行。</li><li>可能导致全表扫描变慢，特别是行比较稀疏或页分裂导致数据存储不连续的时候。</li><li>二级索引（非聚簇索引）要比想象的大，因为叶子节点包含了引用行的主键列。</li><li>二级索引访问需要两次索引查找，而不是一次。因为二级索引叶子节点保存的不是行的物理位置，而是行的主键值。在找到二级索引获得主键值后，仍需要去聚簇索引找到对应的行。所以InnoDB引入自适应哈希索引减少这样的重复工作。</li></ul><p>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。若主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280104.png" alt></p><p>AUTO_INCREMENT 自增列保证数据行是按顺序写入，从性能考虑使用UUID作为聚簇索引会很糟糕，插入变得完全随机。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280105.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280106.png" alt></p><h3 id="2-6-覆盖索引"><a href="#2-6-覆盖索引" class="headerlink" title="2.6 覆盖索引"></a>2.6 覆盖索引</h3><p>设计索引时不仅仅要考虑WHERE条件部分，特别是能直接通过索引获取列数据的情况。<strong>如果一个索引包含所有需要查询的字段的值，可以被称为覆盖索引</strong>。只有B-Tree索引可以作为覆盖索引。在EXPLAIN的Extra对应 <code>Using index</code> 信息。</p><p>InnoDB的二级索引的叶子节点包含主键的值，所以即使本身没有包含主键，二级索引也可以额外用于对主键做覆盖查询。</p><p>优点：</p><ul><li>减少数据访问量；</li><li>索引至少在单个页内是按列值顺序存储的，所以范围查询相比随机读取的I/O少很多。</li><li>由于聚簇索引的原因，覆盖索引对InnoDB特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，若二级主键可以覆盖查询，就可以避免对主键索引的二次查询。</li></ul><p>全字段模糊查询优化：<strong>延迟关联</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> actor = <span class="string">'SEAN CARREY'</span></span><br><span class="line">                                 <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'%APOLLO%'</span>;</span><br><span class="line"><span class="comment">--type：ref</span></span><br><span class="line"><span class="comment">--possible_keys：ACTOR,IX_PROD_ACTOR</span></span><br><span class="line"><span class="comment">--key：ACTOR</span></span><br><span class="line"><span class="comment">--key_len：52</span></span><br><span class="line"><span class="comment">--Extra：Using where</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询选择了表的所有列，而没有索引覆盖了这么多列，但WHERE条件actor命中了索引，MySQL不能再索引中执行LIKE操作</span></span><br><span class="line"><span class="comment">--优化方案：创建索引(artist,title,prod_id)</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products </span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> prod_id <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> actor = <span class="string">'SEAN CARREY'</span></span><br><span class="line">                                     <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'%APOLLO%'</span>;) AS T1 ON (t1.prod_id=products.prod_id)</span><br><span class="line"><span class="comment">--1.select_type: PRIMARY</span></span><br><span class="line"><span class="comment">--2.select_type: PRIMARY</span></span><br><span class="line"><span class="comment">--3.select_type: DERIVED</span></span><br><span class="line"><span class="comment">--3.type: ref</span></span><br><span class="line"><span class="comment">--3.key: ACTOR_2</span></span><br><span class="line"><span class="comment">--3.Extra: Using where; Using index</span></span><br></pre></td></tr></table></figure><h3 id="2-7-使用索引扫描来做排序"><a href="#2-7-使用索引扫描来做排序" class="headerlink" title="2.7 使用索引扫描来做排序"></a>2.7 使用索引扫描来做排序</h3><p>两种方式生成有序结果：</p><ol><li>排序操作；</li><li>按索引顺序扫描。EXPLAIN得到type值为index。</li></ol><p>只扫描索引本身很快，但如果不能覆盖所有列，就需要回表查询一次，而回表查询基本是随机I/O，相比顺序地全表扫描要慢。</p><p>只有索引顺序和 ORDER BY 操作顺序一样时，才可以作为排序结果。</p><h3 id="2-8-压缩索引"><a href="#2-8-压缩索引" class="headerlink" title="2.8 压缩索引"></a>2.8 压缩索引</h3><p>MyISAM使用前缀压缩来减小索引的大小，比如索引块第一个值是“perform”，第二个值是“performance”，压缩后第二个值是“7,ance”，减少空间的代价是某些操作会更慢，因为前后的依赖性所以无法使用二分查找。</p><h3 id="2-9-冗余和重复索引"><a href="#2-9-冗余和重复索引" class="headerlink" title="2.9 冗余和重复索引"></a>2.9 冗余和重复索引</h3><ul><li><strong>产生冗余和重复索引的原因</strong>：<ul><li>MySQL允许在相同列上创建多个索引，但需要单独维护重复的索引，且优化器在优化查询时也要逐个考虑。</li><li>重复索引可能会因为一些失误构建出来，如若发现应移除。表中索引越多会导致INSERT、UPDATE、DELETE速度越慢</li></ul></li><li><strong>区分冗余索引</strong>：(A)是(A,B)的冗余索引，但(B,A)或(B)则不是冗余索引。尽量扩展旧索引而不是创建新索引，有时也会需要冗余索引，因为扩展已有索引可能会导致其变得太大，从而影响其他使用该索引的查询。</li><li><strong>如何找到冗余和重复索引</strong>：<ul><li>可以通过自己编写查询访问 INFORMATION_SCHEMA 表；</li><li>或是通过如 Shlomi Noach 的 common_schema 以及 Percona Tookit 的 pt-duplicate-key-checker 等工具找出冗余和重复的索引并删除。</li></ul></li></ul><h3 id="2-10-索引和锁"><a href="#2-10-索引和锁" class="headerlink" title="2.10 索引和锁"></a>2.10 索引和锁</h3><p>索引可以使查询锁定更少的行，InnoDB只有在访问行时才会对其加锁，索引可以减少访问的行数，需要存储引擎能够过滤掉不需要的行。</p><p>查询只返回2~4之间的行，但却获取了1到4之间行的排它锁，因为MySQL为查询选择的执行计划是索引范围扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id &lt; <span class="number">5</span></span><br><span class="line">  <span class="keyword">AND</span> actor_id &lt;&gt; <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>存储引擎从索引开头获取满足 <code>actor_id &lt; 5</code> 的记录，并不知道可以过滤第一行记录，<code>Using where</code> 表示MySQL服务器将存储引擎返回行以后再应用过滤条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id &lt; <span class="number">5</span></span><br><span class="line">  <span class="keyword">AND</span> actor_id &lt;&gt; <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">--type: range</span></span><br><span class="line"><span class="comment">--key: PRIMARY</span></span><br><span class="line"><span class="comment">--Extra: Using where; Using index</span></span><br></pre></td></tr></table></figure><p>此时保证第一个连接打开，再开启第二个连接查询第一行记录，此查询会被挂起：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排它锁（写锁），从而无法使用覆盖索引，使SELECT FOR UPDATE 比 LOCK IN SHARE MODE 或非锁定查询要慢很多。</p><h3 id="2-11-实用技巧"><a href="#2-11-实用技巧" class="headerlink" title="2.11 实用技巧"></a>2.11 实用技巧</h3><ul><li>实际创建索引时经常会将一些选择性不高但频繁使用的列作为索引前缀列，如性别SEX，即使某些查询不需要这些列作为查询条件，也可以加上 <code>SEX IN(&#39;m&#39;,&#39;f&#39;)</code> 来匹配索引（仅使用列表值不多时）。</li><li>一些常用于范围查询的列尽量放在组合索引的最后，比如日期、年纪等，因为匹配索引会在第一个范围查询终止，当然一些情况也可以用IN来代替范围查询。</li><li>通过执行 <code>OPTIMIZE TABLE</code> 或者导出再导入的方式重新整理数据，这样可以消除索引和数据的碎片化。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280107.png" alt></p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：索引概述，常见索引类型，索引优缺点，高性能索引策略包括前缀索引、组合索引、聚簇索引、覆盖索引等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（三）Schema与数据类型优化</title>
    <link href="http://linyishui.top/2020122001.html"/>
    <id>http://linyishui.top/2020122001.html</id>
    <published>2020-12-20T12:14:19.000Z</published>
    <updated>2020-12-29T12:29:26.468Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（三）Schema与数据类型优化"><a href="#《高性能MySQL》（三）Schema与数据类型优化" class="headerlink" title="《高性能MySQL》（三）Schema与数据类型优化"></a>《高性能MySQL》（三）Schema与数据类型优化</h1><h2 id="一-选择优化的数据类型"><a href="#一-选择优化的数据类型" class="headerlink" title="一. 选择优化的数据类型"></a>一. 选择优化的数据类型</h2><ul><li>尽量使用能正确存储数据的最小数据类型；</li><li>整型比字符串操作代价更低，字符比较的字符集和校对规则更复杂，如时间等应该用数字存储；</li><li>尽量避免NULL，可为NULL的列需要更多的空间，索引构建更复杂，所以需要创建索引的列尽量是NOT NULL；</li><li>相同类型的数据，但长度范围不同、精度不同、需要的物理空间也不同，例如 DATETIME 和 TIMESTAMP 都存储时间和日期，精确到秒，TIMESTAMP只会用DATETIME一半的空间</li><li>MySQL的数字类型分整数类型和实数类型，其中 DECIMAL 支持高精度计算，如 DECIMAL(18, 9) 小数点两边将各存9个数字，小数点占一个字节，总共占9个字节。内部浮点计算统一使用 DOUBLE ，DECIMAL 只是存储类型。DECIMAL 会需要额外的空间和计算开销</li><li>字符串类型：<ul><li>VARCHAR：可变长字符串，仅使用必要空间（除非ROW_FORMAT=FIXED），使用一个或两个字节存储字符串长度。没有银弹，节省空间的带来的是UPDATE需要额外的开销（页已满InnoDB会分裂页使新行可以放入页内）</li><li>CHAR：定长字符串，根据定义的长度分配足够的空间。适合存储定长或经常修改的字符串，因为定长类型不容易产生碎片；短列如CHAR(1)只需一个字节，而VARCHAR(2)需要两个字节，一个字节存放长度。</li></ul></li><li>BLOB和TEXT：分别采用二进制和字符串存储较大数据。<ul><li>不同类型家族：TINYBLOB、SMALLBLOB / BLOB、MEDIUMBLOB、LONGBLOB 和 TINYTEXT、SMALLTEXT / TEXT、MEDIUMTEXT、LONGTEXT</li><li>当数据较大时，MySQL会使用外部区域存放值，行内需要为每个值放1~4个字节的指针。</li><li>排序时只会对前 <code>max_sort_length</code> 个字节排序，也可以使用 <code>ORDER BY SUSTRING(column, length)</code> 。</li></ul></li><li>日期和时间类型：<ul><li>DATETIME：1001年到9999年，精度为秒，格式为YYYYMMDDHHMMSS的整数，与时区无关，占用8个字节的存储空间，时间值的显式会因为时区不同而不同。</li><li>TIMESTAMP：1970年到2038年，保存从1970年1月1日午夜以来的秒数（格林尼治时间），只使用4个字节的存储空间，时间值的显式会因为时区不同而不同。</li></ul></li><li>位数据类型：<ul><li>BIT：旧版本BIT等价于TINYINT，BIT(1)存放一个位，最大为64位。BIT属于字符串类型，不建议使用。</li><li>SET</li></ul></li><li>特殊类型：<ul><li>低于秒精度的时间戳</li><li>IPv4地址，经常用 VARCHAR(15) 存放IP地址，实际上本质是32位无符号整数，小数点只是方便阅读，使用无符号整数存放，MySQL还提供了 <code>INET_ATON()</code> 和 <code>INET_NTOA()</code> 来在二者间转换。 </li></ul></li></ul><h2 id="二-选择合适的标识列"><a href="#二-选择合适的标识列" class="headerlink" title="二. 选择合适的标识列"></a>二. 选择合适的标识列</h2><p>标识列要常用于比较（如关联操作）、作为查询条件、外键等。不同表的相同标识列要保持数据类型一致，并且在选择数据类型时考虑MySQL如何执行计算和比较（如ENUM和SET使用整数存储，比较时转换为字符串）。</p><ul><li><strong>整数类型</strong>：最适合的标识列类型，效率高并且可以 AUTO_INCREMENT 。</li><li><strong>ENUM和SET类型</strong>：糟糕的选择。</li><li><strong>字符串类型</strong>：消耗空间，并且效率差于数字，特别是一些随机生成的字符串会任意分布在很大的空间内，导致INSERT或SELECT执行很慢。存储UUID应该去掉 <code>-</code> ，直接用 <code>UNHEX()</code> 函数转换为16字节数字存放在 BINARY(16) 列中，检索时使用 <code>HEX()</code> 格式化为十六进制格式。<ul><li>插入值随机写到索引的不同位置，使INSERT变慢，会导致页分裂、磁盘随机访问、对于聚簇存储引擎产生聚簇索引碎片。</li><li>逻辑上相邻的行分布在磁盘和内存的不同地方，使SELECT变慢。</li><li>随机值导致缓存赖以工作的访问局部性原理失效，整个数据集都一样“热”，缓存带来的好处就消失了。</li></ul></li></ul><h2 id="三-常见设计陷阱"><a href="#三-常见设计陷阱" class="headerlink" title="三. 常见设计陷阱"></a>三. 常见设计陷阱</h2><ol><li><strong>太多的列</strong>：MySQL存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，在服务器层将缓冲转码为各个列，将编码后的内容转码为各个行的数据格式操作代价较高，所以尽量避免上千个属性这种极端情况。</li><li><strong>太多的关联</strong>：期望查询能够快速的执行且并发性好，单个查询不要超过12个表关联。</li><li><strong>避免滥用枚举</strong>：修改枚举中值会进行一次 ALTER TABLE 操作。</li></ol><h2 id="四-范式和反范式"><a href="#四-范式和反范式" class="headerlink" title="四. 范式和反范式"></a>四. 范式和反范式</h2><p>范式化的数据库中，事实数据仅出现一次；反范式化的数据库中，信息是冗余的。</p><p>范式的优点：</p><ul><li>更新操作更快；</li><li>很少有重复数据，需要修改的数据更少；</li><li>表空间更小，在内存中执行更快；</li><li>很少有多余数据，所以更少需要 DISTINCT 或 GROUP BY 语句。</li></ul><p>范式的缺点：</p><ul><li>常常需要关联，不但代价昂贵，也可能使索引策略无效。</li></ul><p>反范式的优点：</p><ul><li>数据都在一张表，所以很少关联；</li><li>全表扫描基本是顺序I/O，不需要关联表避免了随机I/O；</li><li>可以构建有效的索引策略；</li></ul><p>真实的开发中很少会极端的遵循范式或反范式，而是混用二者；常见如<strong>复制</strong>或<strong>缓存</strong>，在不同的表存储相同的列，冗余的字段往往有其意义，比如排序需求、避免关联、避免多次查询等等。</p><h2 id="五-缓存表和汇总表"><a href="#五-缓存表和汇总表" class="headerlink" title="五. 缓存表和汇总表"></a>五. 缓存表和汇总表</h2><p>虽然冗余数据能够很好的提升性能，但有时还是需要创建一张完全独立的汇总表或缓存表。</p><p>一般缓存表用来存放那些可以简单获取但获取速度较慢的数据（逻辑上冗余的数据）；汇总表则存放使用 GROUP BY 语句聚合的数据。</p><p>例如，一个网站需要计算之前24小时发送的消息数，可以每小时生成一张汇总表（Redis应该是更好的解决方案），这样比实时维护计数器要高效的多，但并不精确。这种方案要远远快于统计message中所有行，实时计算统计值需要扫描表中的大部分数据，需要的索引也一般会影响到UPDATE操作（所以一般不希望创建这类索引）。</p><p>缓存表可以采用不同的存储引擎，比如主表是InnoDB，缓存表则使用MyISAM，这样可以得到更小的索引占用空间，并且可以做全文搜索。</p><p>使用缓存表和汇总表需要决定是实时维护数据还是定期重建，重建需要保证数据在操作时依然可用，所以需要“影子表”实现，即根据真实表创建一张影子表，完成建表后，通过一个原子性的重命名操作切换影子表和原表。</p><p><strong>更快的读，更慢的写</strong>，为了增加读查询的速度，会经常建一些额外索引、增加冗余列，甚至创建缓存表和汇总表。这些都会导致写查询变慢，开发难度提升，但能显著提高读操作的性能。</p><h2 id="六-提高-ALTER-TABLE-操作的速度"><a href="#六-提高-ALTER-TABLE-操作的速度" class="headerlink" title="六. 提高 ALTER TABLE 操作的速度"></a>六. 提高 ALTER TABLE 操作的速度</h2><p>ALTER TABLE 对于大表会执行很慢，大部分修改表操作会按新结构创建一个新的空表，从旧表查出所有数据插入新表，最后删除旧表。<strong>大部分 ALTER TABLE 操作会导致MySQL服务中断</strong>。 </p><p>常规场景的技巧：</p><ul><li>先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库切换；</li><li>“影子拷贝”，用要求的表结构创建一张和原表无关的新表，然后通过<strong>重命名</strong>和<strong>删表</strong>操作交换两张表。</li></ul><p>不是所有 ALTER TABLE 操作都要重建表，如下修改字段默认值，前者创建新表，后者直接修改 <code>.frm</code> 文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX</span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> xxx TINYINT(<span class="number">3</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> xxx <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="6-1-只修改-frm-文件，不重建表"><a href="#6-1-只修改-frm-文件，不重建表" class="headerlink" title="6.1 只修改 .frm 文件，不重建表"></a>6.1 只修改 .frm 文件，不重建表</h3><p>只修改 .frm 文件要远远快于重建表，而MySQL有时会在没必要重建表的时候仍去重建。比如移除一个列的 AUTO_INCREMENT 属性；增加、移除、修改ENUM和SET常量。</p><p>这类情况可以创建新的 <code>.frm</code> 文件，替换旧的：</p><ol><li>创建一张有相同结构的空表，进行需要的修改；</li><li>执行 <code>FLUSH TABLES WITH READ LOCK</code> ，会关闭所有正在使用的表，且禁止任何表被打开；</li><li>交换 <code>.frm</code> 文件；</li><li>执行 <code>UNLOCK TABLES</code> 释放第二步的读锁。</li></ol><h3 id="6-2-快速创建-MyISAM-索引"><a href="#6-2-快速创建-MyISAM-索引" class="headerlink" title="6.2 快速创建 MyISAM 索引"></a>6.2 快速创建 MyISAM 索引</h3><p>先禁用索引、载入数据，然后重新启用索引：因为构建索引的工作被延迟到数据完全载入后，这个时候可以利用排序来创建索引，相比会快很多，并且使索引树的碎片更少、更紧凑（只对非唯一索引有效）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">DISABLE</span> <span class="keyword">KEYS</span>;</span><br><span class="line"><span class="comment">--LOAD THE DATA</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">ENABLE</span> <span class="keyword">KEYS</span>;</span><br></pre></td></tr></table></figure><p>InnoDB也可以先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引。</p><p>操作步骤：</p><ol><li>用需要的表结构创建一张新表，但不包含索引；</li><li>载入数据到表中以构建 <code>.MYD</code> 文件；</li><li>按照需要的结构创建另一张空表，并包含索引，创建出 <code>.frm</code> 和 <code>.MYI</code> 文件；</li><li>获取读锁并刷新表；</li><li>重命名第二张表的 <code>.frm</code> 和 <code>.MYI</code> 文件，使MySQL认为是第一张表的文件；</li><li>释放读锁；</li><li>使用 <code>REPAIR TABLE</code> 重建表的索引，此操作通过排序来构建所有索引，包括唯一索引。</li></ol><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：数据类型优化，选择合适的标识列，常见Schema设计陷阱，范式与反范式，缓存表和汇总表，提高ALTER TABLE操作的速度等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（二）基准测试和服务器性能剖析</title>
    <link href="http://linyishui.top/2020121701.html"/>
    <id>http://linyishui.top/2020121701.html</id>
    <published>2020-12-17T12:12:06.000Z</published>
    <updated>2020-12-29T12:27:10.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（二）基准测试和服务器性能剖析"><a href="#《高性能MySQL》（二）基准测试和服务器性能剖析" class="headerlink" title="《高性能MySQL》（二）基准测试和服务器性能剖析"></a>《高性能MySQL》（二）基准测试和服务器性能剖析</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是基准测试？"><a href="#1-1-什么是基准测试？" class="headerlink" title="1.1 什么是基准测试？"></a>1.1 什么是基准测试？</h3><p>基准测试是针对系统设计的一种压力测试，通常是为了掌握系统的行为或重现某个系统状态、做新硬件的可靠性测试等。</p><h3 id="1-2-为什么需要基准测试？"><a href="#1-2-为什么需要基准测试？" class="headerlink" title="1.2 为什么需要基准测试？"></a>1.2 为什么需要基准测试？</h3><p>基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。观察系统在不同压力下的行为、评估系统的容量、观察系统如何处理不同的数据。</p><h2 id="二-基准测试的策略"><a href="#二-基准测试的策略" class="headerlink" title="二. 基准测试的策略"></a>二. 基准测试的策略</h2><p>两种主要策略：</p><ul><li>集成式：针对整个系统的整体测试；</li><li>单组件式：单独测试MySQL。</li></ul><p>一般建议做集成式测试，少数如需要比较不同的schema或查询的性能、针对某个具体问题的测试、避免过长的基准测试来检测某些调整的效果，可以考虑只测试MySQL。如果使用的是真实数据，那么只测试MySQL也是有效的。</p><h3 id="2-1-测试指标"><a href="#2-1-测试指标" class="headerlink" title="2.1 测试指标"></a>2.1 测试指标</h3><ul><li><strong>吞吐量</strong>：单位时间内处理的事务数，单位为每秒事务数TPS。</li><li><strong>响应时间或者延迟</strong>：任务所需的整体时间，通常使用百分比响应时间，如95%的响应时间都是5毫秒。</li><li><strong>并发性</strong>：同时工作的并发操作 / 线程数 / 连接数，当并发性增加时，要关注吞吐量是否下降，响应时间是否变长。可以通过 sysbench 指定多个线程，记录MySQL数据库的 Threads_running 状态值。</li><li><strong>可扩展性</strong>：给系统增加一倍的资源，理想情况下可以获得两倍的结果。</li></ul><h2 id="三-基准测试工具"><a href="#三-基准测试工具" class="headerlink" title="三. 基准测试工具"></a>三. 基准测试工具</h2><p>集成式测试工具：</p><ul><li>ab：Apache HTPP服务器基准测试工具，测试HTTP服务器每秒最多可以处理多少请求，只能针对单个URL进行尽可能快的压力测试。</li><li>http_load：可以通过输入文件提供多个URL随机选择进行测试。</li><li>JMeter：Java开发的测试工具，除了Web也可以测试FTP或JDBC等。</li></ul><p>单组件式测试工具：</p><ul><li>mysqlslap：MySQL 5.1发行包提供，模拟服务器的负载，输出计时信息。</li><li>MySQL Benchmark Suite（sql-bench）：MySQL发行包提供的基准测试套件，主要用于测试服务器执行查询的速度。可以用于比较不同存储引擎或不同配置的性能测试，也可以比较两个服务器的总体性能。单线程且串行执行，只能比较单CPU服务器的性能差别。</li><li>Super Smack：提供压力测试和负载生成，可以模拟多用户访问，加载测试数据到数据库，支持使用随机数据填充测试表。</li><li>Database Test Suite：OSDL开源实验室开发。</li><li>sysbench：多线程系统压测工具，支持Lua脚本语言，全能测试工具，支持MySQL、操作系统和硬件测试。</li></ul><h2 id="四-性能剖析概述"><a href="#四-性能剖析概述" class="headerlink" title="四. 性能剖析概述"></a>四. 性能剖析概述</h2><h3 id="4-1-常见场景"><a href="#4-1-常见场景" class="headerlink" title="4.1 常见场景"></a>4.1 常见场景</h3><p>常见性能相关的服务请求：</p><ul><li>如何确认服务器是否达到了性能最佳状态？</li><li>分析某条语句为什么执行的不够快？</li><li>诊断“停顿”，“堆积”或“卡死”的某些间歇性疑难故障？</li></ul><h3 id="4-2-性能剖析的标准"><a href="#4-2-性能剖析的标准" class="headerlink" title="4.2 性能剖析的标准"></a>4.2 性能剖析的标准</h3><p>定义一个性能的标准：完成某件任务的所需时间度量，也就是<strong>响应时间</strong>。对于数据库来说就是查询的响应时间，不管是DDL还是DML都用查询来泛指。优化就是在一定的工作负载下尽可能地降低响应时间。</p><p>无法测试就无法有效地优化，首先应该测量查询时间花在什么地方，要准确测量需要注意两点：</p><ul><li>不要在错误的时间启动和停止测量；</li><li>测量的是目标活动本身，而不是聚合后的信息。</li></ul><p>如测量慢查询时去排查整个服务器来判断问题出处，测量应该从慢查询开始到结束的时间，而不是查询之前或之后的时间。</p><p>查询时间包括：</p><ul><li>执行时间：只需测量定位不同的子任务花费的时间，优化去掉一些子任务、降低一些子任务执行频率、提高子任务执行效率。</li><li>等待时间：可能因为其他系统间接影响，任务间也可能因为竞争磁盘或CPU资源而相互影响，</li></ul><p>通过性能剖析可以分析定位是哪些子任务是优化的目标。</p><h2 id="五-如何进行性能剖析"><a href="#五-如何进行性能剖析" class="headerlink" title="五. 如何进行性能剖析"></a>五. 如何进行性能剖析</h2><h3 id="5-1-性能剖析步骤"><a href="#5-1-性能剖析步骤" class="headerlink" title="5.1 性能剖析步骤"></a>5.1 性能剖析步骤</h3><p>性能剖析包括两步：</p><ul><li>测量任务所花费的时间；</li><li>对结果进行统计和排序，把重要的任务排在前面。</li></ul><h3 id="5-2-性能剖析的输出信息"><a href="#5-2-性能剖析的输出信息" class="headerlink" title="5.2 性能剖析的输出信息"></a>5.2 性能剖析的输出信息</h3><p>性能剖析工具通常都是计时器，记录任务的开始和结束时间。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012010102.png" alt></p><p>性能剖析需要系统可测量化，系统需要有一些测量点可以捕获并收集数据，MySQL直到版本5.5才首次提供Performance Schema 包含一些基于时间的可测量点，在此之前只能收集到记录活动发生次数的 show status 计数器。而 Percona Server 可以提供更多更详细的查询级别测量点。</p><p>性能剖析输出的排名、总计、平均值之外缺失的信息：</p><ul><li>值得优化的查询：性能剖析不会自动给出需要优化的查询，总响应时间占比小的查询不值得优化，优化成本大于收益的查询不值得优化。</li><li>异常情况：有些查询虽然执行频率不高，但每次执行都很慢。</li><li>未知的未知：丢失时间-任务的总时间和测量得到的时间之差，如CPU时间为10秒，剖析得到任务时间为9.7秒，存在300毫秒的丢失时间。可能会忽略某些重要信息。</li><li>被隐藏的细节：只分析平均值会忽略到一些情况，如医院只看所有病人的平均体温，可以输出更多响应时间的信息，如直方图、百分比、标准差、偏差指数等。</li></ul><h2 id="六-剖析MySQL查询"><a href="#六-剖析MySQL查询" class="headerlink" title="六. 剖析MySQL查询"></a>六. 剖析MySQL查询</h2><h3 id="6-1-慢查询日志"><a href="#6-1-慢查询日志" class="headerlink" title="6.1 慢查询日志"></a>6.1 慢查询日志</h3><h4 id="（1）相关参数"><a href="#（1）相关参数" class="headerlink" title="（1）相关参数"></a>（1）相关参数</h4><ol><li>slow_query_log ：是否开启慢查询日志，1表示开启，0表示关闭。</li><li>log-slow-queries ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>long_query_time ：慢查询时间设置，当查询时间多于设定的时间值时，记录日志。</li></ol><h4 id="（2）慢查询日志配置"><a href="#（2）慢查询日志配置" class="headerlink" title="（2）慢查询日志配置"></a>（2）慢查询日志配置</h4><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：</p><ol><li><p>查询慢日志是否开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--OFF 为关闭 ON为开启</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slow_query_log%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>开启慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：使用set global slowquerylog=1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）</strong></p></li><li><p>永久开启慢查询日志：</p><p>修改my.cnf文件，增加或修改参数slow_query_log 和slow_query_log_file后，然后重启MySQL服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log =1</span><br><span class="line">slow_query_log_file=/usr/local/mysql/data/localhost-slow.log</span><br></pre></td></tr></table></figure></li></ol><h4 id="（3）慢查询时间设置"><a href="#（3）慢查询时间设置" class="headerlink" title="（3）慢查询时间设置"></a>（3）慢查询时间设置</h4><p>这个是由参数 long_query_time 控制，默认情况下 long_query_time 的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。</p><ol><li><p>查询慢日志时间设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置慢查询日志时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2-剖析服务器负载"><a href="#6-2-剖析服务器负载" class="headerlink" title="6.2 剖析服务器负载"></a>6.2 剖析服务器负载</h3><p>最简单的方式就是使用<strong>慢查询日志</strong>，是MySQL开销最低、精度最高的测量查询工具，使用时只需注意磁盘空间开销，MySQL 5.1 版本后可以通过 <code>long_query_time</code> 为 0 来捕获所有的查询，查询的响应时间可以做到微秒级。</p><p>Percona Server 的慢查询日志相比MySQL会记录更多信息，如执行计划、锁、I/O活动等。</p><p>可以在业务高峰期开启一个小时的记录查询，首先生成一个剖析报告，需要一个适合的剖析工具，如 <code>pt-query-digest</code> 分析 tcpdump。</p><h3 id="6-3-剖析单条查询"><a href="#6-3-剖析单条查询" class="headerlink" title="6.3 剖析单条查询"></a>6.3 剖析单条查询</h3><p>定位到需要优化的查询语句后，</p><ul><li><p>SHOW PROFILE：</p><ul><li><p>作用：会测量所有服务器上执行的语句，记录耗费时间和执行状态变更相关的数据。</p></li><li><p>开启：<code>SET profiling = 1;</code> </p></li><li><p>使用：<code>SHOW PROFILES</code> 和 <code>SHOW PROFILE FOR QUERY 1;</code> 结果按照执行顺序排序，而不是花费时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @query_id = <span class="number">252</span>;</span><br><span class="line"><span class="keyword">SELECT</span> STATE, <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) <span class="keyword">AS</span> Total_R,</span><br><span class="line"> <span class="keyword">ROUND</span>(</span><br><span class="line"><span class="number">100</span> * <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) /</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>)</span><br><span class="line"> <span class="keyword">FROM</span> information_schema.PROFILING</span><br><span class="line"> <span class="keyword">WHERE</span> QUERY_ID = @query_id), <span class="number">2</span></span><br><span class="line"> ) <span class="keyword">AS</span> Pct_R, </span><br><span class="line"> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> Calls,</span><br><span class="line"> <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) / <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="string">"R/Call"</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.PROFILING</span><br><span class="line"><span class="keyword">WHERE</span> QUERY_ID = @query_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> STATE</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Total_R <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></li><li><p>排序后可以明显的找到查询的耗时步骤，找到其中值得优化的部分去优化。</p></li></ul></li><li><p>SHOW STATUS：</p><ul><li><p>作用：返回一些计数器，有服务器级别和单个连接会话级别的计数器，如 <code>Queries</code> 在会话开始前为0，每提交一条查询增加1。</p></li><li><p>使用：<code>SHOW GLOBAL STATUS</code> 查看服务器级别的次数统计。<code>SHOW STATUS</code> 包含两种级别的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--重置计数器</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="comment">--执行SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tv_tallymaster_bak <span class="keyword">where</span> book_id <span class="keyword">in</span> (<span class="string">'100199100'</span>,<span class="string">'100200000'</span>);</span><br><span class="line"><span class="comment">--查看指定计数器结果</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">WHERE</span> Variable_name <span class="keyword">LIKE</span> <span class="string">'Handler%'</span> <span class="keyword">OR</span> Variable_name <span class="keyword">LIKE</span> <span class="string">'Created%'</span></span><br><span class="line"><span class="comment">-- Created_tmp_tables 表示使用临时表数目</span></span><br><span class="line"><span class="comment">-- Created_tmp_disk_tables 磁盘临时表</span></span><br><span class="line"><span class="comment">-- Handler_read_rnd_next 没有用到索引的读操作</span></span><br></pre></td></tr></table></figure></li><li><p>只能显示某种活动的频繁程度（如读索引），只有一个参数指全局级别的操作时间（Innodb_row_lock_time）。</p></li><li><p>比较有用的计数器：</p><ul><li>句柄计数器（handler counter）</li><li>临时文件</li><li>表计数器</li></ul></li><li><p>SHOW STATUS 本身也会创建一个临时表，通过句柄操作访问此表，会影响计数器数字。</p></li><li><p>EXPLAIN 有类似的结果，但基于统计；SHOW STATUS 的结果基于测量。</p></li></ul></li><li><p>检查慢查询日志的条目：</p><ul><li>使用 Percona Server 得到更详细有用的信息。</li><li><code>pt-query-digest</code> 标题一般会打印出字节偏移值（3214），使用tail指令直接跳转到对应部分：<code>tail -c +3214 /path/to/query.log | head -n100</code></li></ul></li><li><p>使用 <code>Performance Schema</code> </p></li></ul><h3 id="6-4-诊断间歇性问题"><a href="#6-4-诊断间歇性问题" class="headerlink" title="6.4 诊断间歇性问题"></a>6.4 诊断间歇性问题</h3><p>例如一个简单查询，正常情况下使用很快，但有几次不合理的执行了很久。手工执行一遍，非常快；然后用EXPLAIN查询执行计划，也正确的使用了索引。修改WHERE条件的值，排除缓存命中的可能性。</p><p>慢查询日志没有执行计划或详细的时间信息，可能是系统有其他东西消耗了资源，比如正在备份，或是某种类型的锁或争用阻塞了查询进度。</p><p>尽量避免试错的诊断方式，以下是一些常见的案例，某些是数据库问题，但也有的不是：</p><ul><li>应用通过 curl 从一个运行很慢的外部服务获取汇率报价的数据。</li><li>memcached 缓存中一些重要条目过期，导致大量请求落到MySQL重新生成缓存条目。</li><li>DNS查询偶尔有超时现象。</li><li>可能由于互斥锁争用，或者内部删除查询缓存的算法效率太低的缘故，MySQL的查询缓存有时候会导致服务有短暂的停顿。</li><li>当并发度超过某个阈值时，InnoDB的扩展性限制导致查询计划的优化需要很长时间。</li></ul><p>只能在问题发生的地方通过观察资源的使用情况，并尽可能的测量出数据，才能避免在没问题的地方耗费精力。</p><ul><li><p><strong>确认单条查询问题还是服务器问题</strong>：</p><ul><li><p>服务器整体没问题，只是某条查询慢，可以将注意力放在这条特定的查询上面。</p></li><li><p>判断方法：</p><ul><li><p>使用 <code>SHOW GLOBAL STATUS</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每秒捕获一次SHOW GLOBAL STATUS的数据，输出给awk计算并输出每秒的查询数、Threads_connected和Threads_running表示当前正在执行查询的线程数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysqladmin ext -i1 | awk <span class="string">'/Queries/&#123;q=$4-qp;qp=$4&#125; /Threads_connected/&#123;tc=$4&#125; /Threads_running/&#123;printf "%5d %5d %5d\n", q, tc, $4&#125;'</span></span></span><br></pre></td></tr></table></figure><p>每秒查询数一般会下跌，其他两个至少会出现一个尖刺。可能是服务器内部碰到了某种瓶颈，导致新查询在开始执行前因为要获取老查询正在等待的锁而造成堆积（一般也会导致后端服务器出现排队）；也可能是服务区突然收到大量查询请求，比如前端memcached突然失效导致的查询风暴。</p></li><li><p>使用 <code>SHOW PROCESSLIST</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过不停捕获SHOW PROCESSLIST的输出，观察是否有大量现场处于不正常状态或有不正常的特征，如statistics状态一般服务器在查询优化阶段确定表关联顺序—非常快，所以查询不应长时间处与此状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \G垂直输出结果，方便使用 sort|uniq|sort 计算某一列值出现次数，一般State列会很有用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -e <span class="string">'SHOW PROCESSLIST\G'</span> | grep State: | sort | uniq -c | sort -rn</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 大量线程处于freeing items说明出现了大量有问题查询</span></span><br></pre></td></tr></table></figure><ul><li>也可以直接查询表：<code>SELECT * FROM information_schema.PROCESSLIST</code></li><li>使用 innotop 工具。</li></ul></li><li><p>使用查询日志：</p><ul><li>开启慢查询日志，并在全局级别设置 <code>long_query_time=0</code> ，确认所有连接都采用了新设置，可能需要重置所有连接，或是使用 Percona Server。</li><li>也可以通过 tcpdump 和 pt-query-digest 工具替代。</li><li>找到吞吐量突然下降时间段的日志，一般是吞吐量下降后第一个完成的查询。</li></ul></li></ul></li></ul></li><li><p><strong>捕获诊断数据</strong>：</p><ul><li><p>辅助工具：</p><ul><li>一个可靠且实时的触发器；</li><li>一个收集诊断数据的工具。</li></ul></li><li><p>找到能和正常时的阈值进行比较的指标，如正在运行的线程数量、处于“freeing items”状态的线程数量等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -e <span class="string">'SHOW PROCESSLIST/G'</span> | grep -c <span class="string">"State: freeing items"</span></span></span><br></pre></td></tr></table></figure></li><li><p>Percona Toolkit 的 pt-stalk 可以在触发条件时收集数据。</p></li><li><p>需要收集的数据：系统状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存使用率、MySQL的几个SHOW STATUS / SHOW PROCESSLIST / SHOW INNODB STATUS</p></li></ul></li></ul><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：基准测试和服务器性能剖析，MySQL查询剖析等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（一）架构和历史</title>
    <link href="http://linyishui.top/2020120801.html"/>
    <id>http://linyishui.top/2020120801.html</id>
    <published>2020-12-08T12:03:19.000Z</published>
    <updated>2020-12-17T12:11:57.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（一）架构和历史"><a href="#《高性能MySQL》（一）架构和历史" class="headerlink" title="《高性能MySQL》（一）架构和历史"></a>《高性能MySQL》（一）架构和历史</h1><p>MySQL的存储引擎架构将<strong>查询处理</strong>及其他<strong>系统任务</strong>和<strong>数据的存储/提取</strong>相分离。从而可以在使用时根据性能、特性等需求来选择数据存储的方式。</p><h2 id="一-MySQL逻辑架构"><a href="#一-MySQL逻辑架构" class="headerlink" title="一. MySQL逻辑架构"></a>一. MySQL逻辑架构</h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012010101.png" alt></p><ul><li>第一层：连接处理、授权认证、安全等等。</li><li>第二层：查询解析、分析、优化、缓存以及所有的内置函数，还有所有的跨存储引擎的实现：存储过程、触发器、视图。</li><li>第三层：存储引擎，服务器通过API与存储引擎进行通信，包括几十个底层函数，如“开始一个事务”、“根据主键提取一行记录”。存储引擎不会解析SQL（Innodb会解析外键，因为MySQL服务器本身没有实现此功能），存储引擎只会简单的响应上层服务器的请求。</li></ul><h3 id="1-1-连接与安全"><a href="#1-1-连接与安全" class="headerlink" title="1.1 连接与安全"></a>1.1 连接与安全</h3><p>每个客户端连接对应服务器进程中的一个线程，连接的所有查询都在此线程中进行，服务器会负责缓存线程而不必每次都创建新线程，MySQL 5.5后支持线程池来支持大量连接。</p><p>认证基于用户名、原始主机信息和密码。使用安全套接字SSL的方式连接，可以使用X5.09证书认证。连接成功后会继续验证用户是否有相应请求的权限。</p><h3 id="1-2-优化与执行"><a href="#1-2-优化与执行" class="headerlink" title="1.2 优化与执行"></a>1.2 优化与执行</h3><p>MySQL会解析查询，并创建内部数据结构-解析树，然后对其进行各种优化，包括重写查询、决定表的读写顺序、选择合适的索引等。</p><ul><li>可以通过特殊关键字 <strong>hint</strong> 提示优化器，影响其决策过程；</li><li>可以通过 <strong>explain</strong> 请求优化器解释优化过程的各个因素，从而了解到服务的优化决策，便于用户重构查询和schema、修改相关配置。</li></ul><p>对于如 SELECT 语句，在解析查询前会检查查询缓存，若有相应查询就可以直接返回结果。 </p><h2 id="二-并发控制"><a href="#二-并发控制" class="headerlink" title="二. 并发控制"></a>二. 并发控制</h2><p>MySQL在两个层控制并发：服务器层和存储引擎层。</p><h3 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1 读写锁"></a>2.1 读写锁</h3><p>并发读数据不会有问题，但当一个用户读取数据，另外一个用户删除数据时，可能读取会报错，也可能读到了不一致的数据。</p><p>通过实现共享锁（shared lock）和排它锁（exclusive lock），也叫读锁和写锁，这两种锁组成的锁系统来解决问题。写锁会阻塞其他写锁和读锁，</p><h3 id="2-2-锁粒度"><a href="#2-2-锁粒度" class="headerlink" title="2.2 锁粒度"></a>2.2 锁粒度</h3><p>为了提高共享资源的并发性，减少锁定的对象，避免锁住所有资源。但锁的所有操作，如获取锁、检查是否锁已释放、释放锁等都会增加系统开销。<strong>锁策略就是在锁的开销和数据的安全性之间寻找平衡</strong>。</p><ul><li><strong>表锁</strong>：<ul><li>表锁是开销最小的锁，会锁定整张表，写操作时会阻塞其他读写操作，写锁未被持有时其他用户才能获取读锁，读锁间不相互阻塞。</li><li>写锁的优先级比读锁要高，所以写请求可能会被插入到读请求前，服务器可能会忽略存储引擎的表锁实现为如 <code>ALTER TABLE</code> 之类的语句加表锁。</li></ul></li><li><strong>行锁</strong>：<ul><li>行锁可以提供更好的并发性，但也带来了最大的锁开销。行锁由存储引擎实现（InnoDB和XtraDB等）</li></ul></li></ul><h3 id="2-3-锁类型"><a href="#2-3-锁类型" class="headerlink" title="2.3 锁类型"></a>2.3 锁类型</h3><p>MySQL包括如下锁类型：</p><ul><li><p><strong>读写锁</strong>：同Java一样，写锁持有时其他事务不能获取任何锁，读锁持有时其他事务可以获取读锁，但不能获取写锁。</p><ul><li><strong>互斥锁</strong>：简称X锁，又叫写锁。</li><li><strong>共享锁</strong>：简称S锁，又叫读锁。</li></ul></li><li><p><strong>意向锁</strong>：更容易的支持多粒度的封锁，在同时存在行级锁和表级锁的情况下，事务想要对表加锁，要首先分别检查是否有其他事务加表锁或行锁，这个过程需要对每一行都进行一次检测，这相当耗时。</p><p><strong>意向锁在 X/S 锁之上引入了 IX/IS，二者都是表锁，规定事务获取某行的X或S锁前要先获取IX或IS锁</strong>。这样当事务想对表加写锁时只需检测是否有其他事务对表加了 X/IX/S/IS 锁，只需做一次检测。（<strong>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁</strong>）</p><ul><li><strong>意向共享锁</strong>（IS Lock）：事务想要获得一张表中某几行的共享锁；</li><li><strong>意向排他锁</strong>（IX Lock）：事务想要获得一张表中某几行的排他锁；</li><li><strong>插入意向锁</strong>（Insert Intention Lock）：插入意向锁是间隙锁的一种，专门针对insert操作的。即多个事务在同一个索引、同一个范围区间内插入记录时，如果插入的位置不冲突，则不会阻塞彼此</li></ul></li><li><p><strong>自增锁</strong>（Auto-inc Locks）：自增锁是一种特殊的<strong>表级别锁</strong>，专门针对事务插入 AUTO-INCREMENT 类型的列。即一个事务正在往表中插入记录时，其他事务的插入必须等待，以便第1个事务插入的行得到的主键值是连续的。</p></li><li><p><strong>记录锁</strong>（Record Locks）：</p><ul><li>记录锁是的单个行记录上的锁，会阻塞其他事务对其插入、更新、删除；</li><li><code>locks rec but not gap</code> 。</li></ul></li><li><p><strong>间隙锁</strong>（Gap Lock）：间隙锁锁定记录的一个间隔，但不包含记录本身。</p></li><li><p><strong>临键锁</strong>（Next-Key Lock）：</p><ul><li><code>Next-Key Lock = Gap Lock + Record Lock</code> 临建锁是记录锁与间隙锁的组合，即：既包含索引记录，又包含索引区间，主要是为了解决幻读。</li></ul></li></ul><p>总结：</p><ul><li>表锁：意向锁，自增锁。</li><li>行锁：读写锁，记录锁，间隙锁，临键锁。</li></ul><h2 id="三-事务"><a href="#三-事务" class="headerlink" title="三. 事务"></a>三. 事务</h2><h3 id="3-1-什么是事务？"><a href="#3-1-什么是事务？" class="headerlink" title="3.1 什么是事务？"></a>3.1 什么是事务？</h3><p>事务是<strong>一组原子性的SQL查询</strong>，一个独立的工作单元。全部语句能够被数据库引擎成功应用，则执行该组查询；有任一语句无法执行，事务的所有语句都不会执行。<strong>要么全部执行成功，要么全部执行失败</strong>。</p><h3 id="3-2-ACID"><a href="#3-2-ACID" class="headerlink" title="3.2 ACID"></a>3.2 ACID</h3><ul><li><strong>原子性（Atomicity）</strong>：事务作为一个不可分割的整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li><li><strong>隔离性（Isolation）</strong>：一个事务在最终提交前应该对其他事务是不可见的；多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。</li></ul><p>事务所带来的安全性也需要额外的工作和开销，而MySQL的存储引擎架构可以支持用户根据业务是否需要事务选择合适的存储引擎。</p><h3 id="3-3-并发一致性问题"><a href="#3-3-并发一致性问题" class="headerlink" title="3.3 并发一致性问题"></a>3.3 并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，所以有几种并发一致性问题：</p><ol><li><strong>修改丢失</strong>：即一个事务的更新背另一个事务的更新替换。</li><li><strong>读脏数据</strong>：指当前事务读到另外事务未提交的数据。</li><li><strong>不可重复读</strong>：指一个事务多次读取同一数据集合，在此期间另外事务也访问了此集合并做出修改，导致前个事务两次读取数据不一致。</li><li><strong>幻影读</strong>：本质也是不可重复读，指一个事务读取某个范围的数据，另一事务在此范围插入新数据，导致前个事务再次读取结果不一致。<strong>区别在要避免幻读需要锁整张表，而避免不可重复读只需锁住行即可</strong>。</li></ol><p>通过锁机制来解决此问题，MySql提供了对应的封锁机制来实现，<strong>通过三级封锁协议来处理并发一致性问题</strong>。</p><h3 id="3-4-封锁协议"><a href="#3-4-封锁协议" class="headerlink" title="3.4 封锁协议"></a>3.4 封锁协议</h3><ul><li><strong>三级封锁协议</strong>：<ul><li>一级：<strong>事务 T 要修改数据 A 时必须加写锁，直到 T 结束才释放锁</strong>。可以解决修改丢失问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</li><li>二级：<strong>在一级的基础上，要求读取数据 A 时必须加读锁，读取完马上释放读锁</strong>。可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</li><li>三级：<strong>在二级的基础上，要求读取数据 A 时必须加读锁，直到事务结束了才能释放读锁</strong>。可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</li></ul></li><li><strong>两段封锁协议</strong>：<strong>加锁和解锁分为两个阶段进行</strong>。</li></ul><h3 id="3-5-隔离级别"><a href="#3-5-隔离级别" class="headerlink" title="3.5 隔离级别"></a>3.5 隔离级别</h3><ol><li><strong>读未提交</strong>（READ UNCOMMITTED）：<ul><li>事务中的修改，即使没有提交，对其它事务也是可见的。</li><li>会<strong>导致脏读</strong>（读到未提交的数据），性能也并未比其它级别好很多。</li></ul></li><li><strong>读已提交</strong>（READ COMMITTED）： <ul><li>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li><li>也叫不可重复读，因为两次执行相同的查询可能会得到不同的结果。</li><li>大部分数据库的默认隔离级别，MySQL因为历史遗留问题，默认隔离级别是可重复读。</li></ul></li><li><strong>可重复读</strong>（REPEATABLE READ）：<ul><li>保证在同一个事务中多次读取同一数据的结果是一样的。</li></ul></li><li><strong>可串行化</strong>（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</li></ol><table><thead><tr><th>隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th><th style="text-align:center">加锁读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>READ COMMITTED</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>REPEATABLE READ</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>SERIALIZABLE</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr></tbody></table><h4 id="（1）为什么MySQL默认是可重复读？"><a href="#（1）为什么MySQL默认是可重复读？" class="headerlink" title="（1）为什么MySQL默认是可重复读？"></a>（1）为什么MySQL默认是可重复读？</h4><p>MySql的历史版本中，主从复制基于binlog（记录数据库修改的文件），当时binlog只有 <strong>statement</strong> 这种模式（记录修改SQL语句），后来还有<strong>row</strong>（记录每行数据变更）和 <strong>mixed</strong>（前两种模式混合）总共三种模式。</p><p><strong>statement</strong>模式在<strong>读已提交</strong>下进行主从复制有BUG，在master上执行的顺序为先删后插，而binlog的记录顺序为先插后删，所以slave同步binlog后导致执行顺序和master不一致。</p><p>解决方法：</p><ol><li>调整隔离级别为<strong>可重复读</strong>。</li><li>更新模式为<strong>row</strong>（5.1版本后引入）。</li></ol><h4 id="（2）为什么选择读已提交？"><a href="#（2）为什么选择读已提交？" class="headerlink" title="（2）为什么选择读已提交？"></a>（2）为什么选择读已提交？</h4><p>首先排除<strong>读未提交</strong>和<strong>可串行化</strong>，前者会出现脏读，后者每次读操作都要加锁。</p><p>选读已提交/不可重复读的原因：</p><ol><li><strong>可重复读下，存在间隙锁</strong>（封锁索引记录中的间隔）导致死锁概率增加：如 <code>SELECT * FROM test WHERE id BETWEEN 5 AND 7</code> ，表中有id（1，5，7，10），所以存在5个间隙，上述sql会锁住(5,7]和(7,10]这两个区间，导致区间无法插入数据。而<strong>读已提交不存在间隙锁</strong>。</li><li><strong>可重复读下，条件未命中索引会锁表</strong>，而<strong>读已提交，只会锁行</strong>。</li><li><strong>读已提交，因为半一致性读的特性会增加update操作的并发性</strong>。一个事务执行完update操作，但尚未提交，另一事务获取锁时发现已占用，InnoDB开启半一致性读返回最新的已提交版本，MySql会重新发起一次读操作，此时可以读到此行的最新版本并加锁，而可重复读这时事务只能等待前一事务提交。</li><li><strong>不可重复读问题可以接受</strong>，已经提交了数据，即使不一样通常也不会造成问题。</li></ol><h3 id="3-6-死锁"><a href="#3-6-死锁" class="headerlink" title="3.6 死锁"></a>3.6 死锁</h3><ul><li>死锁指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</li><li>InnoDB有死锁检测和死锁超时机制，处理死锁时会将持有最少行级排他锁的事务进行回滚。</li><li>死锁可能是因为真正的数据冲突，有时可能完全是由于存储引擎的实现方式导致的。</li><li>应用程序需要考虑如何处理死锁，大部分情况只需重新执行因死锁回滚的事务即可。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看数据库隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line"><span class="keyword">select</span> @@global.tx_isolation,@@tx_isolation;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看innodb状态，打印死锁日志，NaviCat复制出去看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--设置隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> XXX;</span><br><span class="line"><span class="comment">--只改变当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">READ</span> COMMITED;</span><br></pre></td></tr></table></figure><h3 id="3-7-事务日志"><a href="#3-7-事务日志" class="headerlink" title="3.7 事务日志"></a>3.7 事务日志</h3><p>事务日志用来提高事务的执行效率，存储引擎在修改表的数据时只需修改内存拷贝，再把修改行为记录在持久的硬盘上的事务日志中，而不是每次都把修改的数据持久到硬盘。</p><p>事务日志通过追加的方式，操作是磁盘小块区域上的顺序I/O，要比随机I/O快得多。所以每次修改数据需要<strong>写两次磁盘</strong>。</p><h3 id="3-8-存储引擎与事务"><a href="#3-8-存储引擎与事务" class="headerlink" title="3.8 存储引擎与事务"></a>3.8 存储引擎与事务</h3><p>MySQL有很多支持事务的存储引擎，如InnoDB、NDB Cluster、XtraDB和PBXT等。</p><h4 id="（1）自动提交（AUTO-COMMIT）"><a href="#（1）自动提交（AUTO-COMMIT）" class="headerlink" title="（1）自动提交（AUTO COMMIT）"></a>（1）自动提交（AUTO COMMIT）</h4><p>MySQL默认采用自动提交模式。每个查询都会被当做一个事务执行提交操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'AUTOCOMMIT'</span></span><br><span class="line"></span><br><span class="line">Variable_name<span class="keyword">Value</span></span><br><span class="line">autocommit    <span class="keyword">ON</span></span><br><span class="line"><span class="comment">--1启用0禁用</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>数据定义语言（DDL）中涉及大量数据改变的操作（如Alter Table、Lock Tables）会强制执行COMMIT提交当前活动事务。</p><h4 id="（2）在事务中混合使用存储引擎"><a href="#（2）在事务中混合使用存储引擎" class="headerlink" title="（2）在事务中混合使用存储引擎"></a>（2）在事务中混合使用存储引擎</h4><p>事务由存储引擎实现，所以在一个事务中使用多种存储引擎不可靠，如果在事务中混合使用了多个包括事务型和非事务型存储引擎的表，正常提交不会有问题，但需要回滚时非事务型的表无法撤销变更。而且仅仅在回滚时提示一个警告，其余情况不会有提示。</p><h4 id="（3）隐式和显式锁定"><a href="#（3）隐式和显式锁定" class="headerlink" title="（3）隐式和显式锁定"></a>（3）隐式和显式锁定</h4><ul><li><p>隐式锁定：InnoDB采用<strong>两阶段锁定协议</strong>，事务执行过程中可以随时锁定，但只有事务提交或回滚时才会释放，并且是同一时刻释放。InnoDB根据隔离级别在需要时自动加锁。</p></li><li><p>显式锁定：通过特点语句进行锁定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><p><code>LOCK TABLES</code> 和 <code>UNLOCK TABLES</code> 由服务器层实现，与存储引擎无关，不能用来代替事务。</p></li></ul><h2 id="四-多版本并发控制-MVCC"><a href="#四-多版本并发控制-MVCC" class="headerlink" title="四. 多版本并发控制-MVCC"></a>四. 多版本并发控制-MVCC</h2><h3 id="4-1-什么是多版本并发控制？"><a href="#4-1-什么是多版本并发控制？" class="headerlink" title="4.1 什么是多版本并发控制？"></a>4.1 什么是多版本并发控制？</h3><p>大部分事务型存储引擎实现的都不是简单的行级锁，一般都同时实现了多版本并发控制-MVCC，<strong>该机制可以在很多情况下避免加锁操作，所以可以降低开销，一般都会实现非阻塞的读操作和只锁定必要行的写操作</strong>。</p><p>MVCC实现机制各不相同：</p><ul><li>乐观并发控制</li><li>悲观并发控制</li></ul><p><strong>MVCC只兼容于 REPEATABLE READ 和 READ COMMITED 这两个隔离级别，而 READ UNCOMMITED 总是读取最新的数据行而不是符合当前事务版本的数据行，SERIALIZABLE 则会对所有读取的行加锁</strong>。</p><h3 id="4-2-如何实现多版本并发控制？"><a href="#4-2-如何实现多版本并发控制？" class="headerlink" title="4.2 如何实现多版本并发控制？"></a>4.2 如何实现多版本并发控制？</h3><p><strong>通过保存数据在某个时间点的快照来实现</strong>。</p><p>InnoDB通过在每行记录后面保存两个隐藏的列，一个保存了行的创建时间，一个保存行的过期时间（实际存储的非时间而是系统版本号）。每开启一个新事务，版本号都会自动递增，事务开始时刻的版本号作为事务的版本号与查询到的每行记录进行比较。</p><p>在REPEATABLE READ隔离级别下：</p><ul><li>SELECT：根据两个条件检查每行记录，符合才作为查询结果返回。<ul><li>只查找版本早于当前事务版本的数据行，确保事务读取的行是事务开始前存在或自己修改过的。</li><li>行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行在事务开始前未被删除。</li></ul></li><li>INSERT：为新插入的每一行保存当前系统版本号作为<strong>行版本号</strong>。</li><li>DELETE：为删除的每一行保存当前系统版本号作为<strong>行删除标识</strong>。</li><li>UPDATE：插入一行新纪录，保存当前系统版本号作为<strong>行版本号</strong>，同时保存当前系统版本号到原来的行作为<strong>行删除标识</strong>。</li></ul><p>通过这两个版本号可以使大部分读操作都不需加锁（乐观），以少量的额外存储空间和检查维护工作换取好的性能。</p><h2 id="五-存储引擎"><a href="#五-存储引擎" class="headerlink" title="五. 存储引擎"></a>五. 存储引擎</h2><p>文件系统中，MySQL将每个数据库保存为数据目录下的一个子目录。创建表时在数据库子目录下创建一个和表同名的 <code>.frm</code> 文件保存表的定义。表的定义统一在服务层处理，数据和索引则在不同的存储引擎中保存方式不同。</p><p>正因为使用了文件系统的目录文件，所以MySQL大小写敏感和平台相关，Windows中不敏感，而类Unix中则敏感。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看表信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'表名'</span></span><br></pre></td></tr></table></figure><p>返回字段：</p><table><thead><tr><th>字段</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>Name</td><td>表名</td><td>version</td></tr><tr><td>Engine</td><td>存储引擎类型</td><td>InnoDB</td></tr><tr><td>Version</td><td></td><td>10</td></tr><tr><td>Row_format</td><td>行格式：<br>-Dynamic的行长度可变，一般会有如VARCHAR或BLOB这种可变长字段<br>-Fixed的行长度固定，只包含如CHAR何INTEGER这种固定长度字段<br>-Compressed只在压缩表存在<br>….</td><td>Compact</td></tr><tr><td>Rows</td><td>表的行数，对于InnoDB是估计值，MyISAM则是精确值</td><td>25</td></tr><tr><td>Avg_row_length</td><td>平均每行包含的字节数</td><td>655</td></tr><tr><td>Data_length</td><td>表数据的大小，单位字节</td><td>16384</td></tr><tr><td>Max_data_length</td><td>表数据的最大容量</td><td>0</td></tr><tr><td>Index_length</td><td>索引大小</td><td>16384</td></tr><tr><td>Data_free</td><td>表示已分配但目前没有使用的空间。包括已删除的行以及后续可以被Insert利用的空间</td><td>0</td></tr><tr><td>Auto_increment</td><td>下一个自增的值</td><td></td></tr><tr><td>Create_time</td><td>表的创建时间</td><td>2020-12-02 13:04:02</td></tr><tr><td>Update_time</td><td>表数据的最后修改时间</td><td></td></tr><tr><td>Check_time</td><td>使用CHECK TABLE命令或myisamchk等工具最后一次检查表的时间</td><td></td></tr><tr><td>Collation</td><td>表的默认字符集和字符列排序规则</td><td>gbk_chinese_ci</td></tr><tr><td>Checksum</td><td>启用时保存整个表的实时校验和</td><td></td></tr><tr><td>Create_options</td><td>创建表时指定的其他选项</td><td></td></tr><tr><td>Comment</td><td>额外信息，InnoDB表空间的剩余空间信息，视图VIEW文本等</td></tr></tbody></table><h3 id="5-1-InnoDB"><a href="#5-1-InnoDB" class="headerlink" title="5.1 InnoDB"></a>5.1 InnoDB</h3><p>MySQL默认的事务型存储引擎，设计用来执行大量<strong>短期事务</strong>，短期事务很少回滚。</p><p>MySQL 5.1后，新的InnoDB plugin提供很多新特性，如利用排序创建索引、删除或增加索引时不需要复制全表数据、新的支持压缩的存储格式、新的大型列值如BLOB的存储方式、以及文件格式管理等。</p><p>InnoDB：</p><ul><li>数据存储在<strong>表空间</strong>（tablespace）中，由一系列数据文件组成，InnoDB可以将每个表的数据和索引存放在单独的文件中。</li><li>采用MVCC来支持高并发，实现了四个标准的隔离级别，默认是<strong>可重复读</strong>（REPEATABLE READ），<strong>通过间隙锁策略防止幻读出现</strong>，间隙锁使InnoDB不仅锁行，还未锁定索引中的间隙以防止幻影行的插入。</li><li>表基于<strong>聚簇索引</strong>建立，主键查询有很好的性能，但其二级索引（非主键索引）必须包含主键列，若主键列很大会导致所有索引都很大（主键应尽量小一些）。</li><li>内部优化：从磁盘读取数据时采用了<strong>可预测性预读</strong>、自动在内存中创建hash索引以加速读操作的<strong>自适应哈希索引</strong>、能够加速插入操作的<strong>插入缓冲区</strong>等。</li><li>InnoDB支持热备份，如 MySQL Enterprise Backup、XtraBackup都可以实现。</li></ul><h3 id="5-2-MyISAM"><a href="#5-2-MyISAM" class="headerlink" title="5.2 MyISAM"></a>5.2 MyISAM</h3><p>支持如全文索引、压缩、空间函数等，但不支持事务和行级锁，崩溃后无法安全恢复。对于只读数据或小表且可以接受修复操作的场景仍可以继续使用该引擎。</p><p>MyISAM：</p><ul><li><strong>存储</strong>：表存储在两个文件中：数据文件和索引文件，分别以 <code>.MYD</code> 和 <code>.MYI</code> 为扩展名。</li><li><strong>加锁与并发</strong>：对整张表加锁，不能针对行；读取时对所有需要的表加共享锁，写入时则加排它锁，但允许表读取时向表中插入新纪录（<strong>允许并发插入</strong>）。</li><li><strong>修复</strong>：可以手工或自动执行检查和修复操作，修复操作可能会导致数据丢失而且执行速度很慢。<ul><li><code>CHECK TABLE mytable</code> 检查表错误。</li><li><code>REPAIR TABLE mytable</code> 修复错误。</li><li><code>myisamchk</code> 命令行工具。</li></ul></li><li><strong>索引</strong>：即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引。支持全文索引，基于分词创建的索引，可以支持复杂查询。</li><li><strong>延迟更新索引键</strong>：创建表时，若指定了 <code>DELAY_KEY_WRITE</code> 选项，在每次修改执行成功后不会马上把修改的索引数据写入磁盘，而是写入内存的键缓冲区，只有清理键缓冲区或关闭表时才写入磁盘；这种方式可以极大的提升写入性能，但在崩溃时会造成索引损坏，需要进行修复。</li><li><strong>压缩表</strong>：使用 <code>myisampack</code> 将表压缩（打包pack），压缩状态不允许修改，可以极大的减少磁盘空间占用，压缩表支持索引，但索引也是只读的。</li><li><strong>性能</strong>：数据以紧密格式存储，在某些场景下性能很好。主要问题是表锁，容易导致查询处于 Locked 状态。</li></ul><h3 id="5-3-MySQL内建其他存储引擎"><a href="#5-3-MySQL内建其他存储引擎" class="headerlink" title="5.3 MySQL内建其他存储引擎"></a>5.3 MySQL内建其他存储引擎</h3><ul><li><p><strong>Archive引擎</strong>：</p><ul><li>只支持INSERT和SELECT操作。</li><li><strong>高速插入和压缩</strong>：插入缓存所有的写，利用zli对插入的行进行压缩，比MyISAM更少的磁盘I/O。</li><li>每次查询都要执行全表扫描，适合日志和数据采集类应用。</li><li>支持行级锁和专用缓冲区，可以实现高并发的插入。</li><li>查询在返回前会阻止其他查询执行以保证一致性读。</li></ul></li><li><p><strong>Blackhole引擎</strong>：不保存任何数据，服务器会记录Blackhole表的日志，可以用于复制数据到备库或记录日志。</p></li><li><p><strong>CSV引擎</strong>：将CSV文件当做MySQL表来处理，不支持索引。可以作为一种数据交换的机制。</p></li><li><p><strong>Federated引擎</strong>：访问其他MySQL服务器的一个代理，创建一个客户端连接，并将查询传输到远程服务器执行，然后提取或发送需要的数据。市场化设计，经常有问题，默认禁用。</p></li><li><p><strong>Memory引擎</strong>：所有数据都存在内存，不需要磁盘I/O，表结构重启后仍能保留，但数据会丢失，比MyISAM要快一个数量级。</p><ul><li>支持Hash索引，只支持表级锁，不支持BLOB或TEXT类型，且行长度固定，即使指定VARCHAR实际存储时也会转换成CHAR。</li><li>MySQL执行查询时如果需要临时表来保存中间结果，内部就是使用Memory表，如果结果太大超过内存表限制或含有BLOB和TEXT字段，会转换为MyISAM表。</li></ul><p>适用场景：</p><ul><li>查找或映射表。</li><li>缓存周期性聚合数据的结果。</li><li>保存数据分析中产生的中间数据。</li></ul></li><li><p><strong>Merge引擎</strong>：由多个MyISAM表合并成的虚拟表，引入分区功能后已被废弃。</p></li><li><p><strong>NDB引擎</strong>：MySQL服务器、NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合被称为MySQL集群。</p></li></ul><h3 id="5-4-第三方存储引擎"><a href="#5-4-第三方存储引擎" class="headerlink" title="5.4 第三方存储引擎"></a>5.4 第三方存储引擎</h3><ul><li><strong>OLTP类引擎</strong>：<ul><li>Percona的XtraDB存储引擎基于InnoDB改进，可以作为InnoDB引擎的替代品</li><li>PBXT，支持ACID事务和MVCC等。</li><li>TokuDB，使用一种叫分形树的索引数据结构，是一种大数据存储引擎，拥有很高的压缩比。</li><li>RethinkDB，采用只能追加的写时复制B树作为索引的数据结构。</li></ul></li><li><strong>面向列的引擎</strong>：MySQL默认面向行，每行数据一起存储，查询也以行为单位处理。大数据量时面向列的方式可以传输更少的数据，压缩效率也更好。</li><li><strong>社区引擎</strong>：如Aria、Groonga、OQGraph、Q4M、SphinxSE、Spider、VPForMySQL等。</li></ul><h3 id="5-5-如何选择合适的存储引擎"><a href="#5-5-如何选择合适的存储引擎" class="headerlink" title="5.5 如何选择合适的存储引擎"></a>5.5 如何选择合适的存储引擎</h3><p>大部分情况选择InnoDB，除非需要用到InnoDB不具备的特性，并且没有替代方案，否则请尽量选择InnoDB引擎。</p><p>尽量不要混合使用多种存储引擎，会带来一系列复杂和预想不到的问题。</p><h3 id="5-6-转换表的存储引擎"><a href="#5-6-转换表的存储引擎" class="headerlink" title="5.6 转换表的存储引擎"></a>5.6 转换表的存储引擎</h3><ul><li><p><code>ALTER TABLE</code> ：<code>ALTER TABLE mytable ENGINE = InnoDB;</code> 需要执行较长时间，MySQL会按行将数据从原表复制到一张新表，复制期间可能会消耗系统所有I/O能力，同时对原表加上读锁。注意，即使后续再恢复原引擎，也会丢失如外键等和引擎相关的特性。</p></li><li><p><strong>导出与导入</strong>：使用 <code>mysqldump</code> 工具将数据导出到文件，修改文件中 CREATE TABLE 语句的存储引擎选项，注意修改表名（避免重复），工具默认会在 CREATE TABLE 语句前加上 DROP TABLE 可能会导致数据丢失。</p></li><li><p><strong>创建与查询</strong>：综合前两种方法，先创建一个新的存储引擎的表，然后利用 <code>INSERT...SELECT</code> 语句来导入数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">LIKE</span> myisam_table;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table;</span><br></pre></td></tr></table></figure><p>数据量大时可以考虑分批处理，针对每一段数据执行事务提交操作，避免大事务产生过多的undo。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> x <span class="keyword">AND</span> y;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>如果有必要，可以在执行时对原表加锁，以确保新表和原表数据一致。</p><p>Percona Toolkit提供了 pt-online-schema-change 工具方便简单安全的执行上述过程。</p></li></ul><h2 id="六-时间线-Timeline"><a href="#六-时间线-Timeline" class="headerlink" title="六. 时间线-Timeline"></a>六. 时间线-Timeline</h2><ul><li>版本  3.23 2001</li><li>版本  4.0   2003</li><li>版本  4.1   2005</li><li>版本  5.0   2006</li><li>版本  5.1   2008</li><li>版本  5.5   2010 ：Oracle收购，InnoDB成为默认存储引擎。</li><li>版本  5.6   </li><li>….</li></ul><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：MySQL逻辑架构，并发控制，事务，多版本并发控制，存储引擎，时间线等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构设计模式（三）进程间通信</title>
    <link href="http://linyishui.top/2020112801.html"/>
    <id>http://linyishui.top/2020112801.html</id>
    <published>2020-11-28T15:28:34.000Z</published>
    <updated>2020-12-17T14:07:23.659Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-微服务架构中要频繁使用进程间通信"><a href="#1-1-微服务架构中要频繁使用进程间通信" class="headerlink" title="1.1 微服务架构中要频繁使用进程间通信"></a>1.1 微服务架构中要频繁使用进程间通信</h3><p>FIGO有一个REST API供移动端和Web端使用，还使用了一些云服务如Twilio消息服务和Stripe支付服务，但在单体应用内是语言级方法或函数相互调用，除了开发API和集成云服务不会考虑<strong>进程间通信</strong>（IPC）。</p><p>微服务架构中各个服务实例通常是在多台机器上运行的进程，所以必须使用进程间通信进行交互。选择合适的进程间通信机制是一个重要的架构决策，除了影响应用的可用性，甚至还与事务管理互相影响。<strong>理想的微服务架构应该在内部由松散耦合的若干服务组成，服务间使用异步消息相互通信</strong>。</p><h3 id="1-2-常见进程间通信技术"><a href="#1-2-常见进程间通信技术" class="headerlink" title="1.2 常见进程间通信技术"></a>1.2 常见进程间通信技术</h3><p>进程间通信技术有很多：</p><ul><li>基于同步请求 / 响应的通信机制：如 HTTP REST 或 gRPC，REST（JSON）主要用于服务与外部其他应用程序的通信。</li><li>异步的基于消息的通信机制：如 AMQP 或 STOMP。</li></ul><p>消息格式也有：</p><ul><li>基于文本的 JSON 或 XML，有可读性。</li><li>基于二进制的 Avro 或 Protocol Buffers 格式，更加高效。</li></ul><h3 id="1-3-交互方式"><a href="#1-3-交互方式" class="headerlink" title="1.3 交互方式"></a>1.3 交互方式</h3><p>选择进程间通信机制要先考虑服务与其客户端的交互方式，从而可以专注于需求而不是单纯技术层面的考量，交互方式的选择会影响可用性和后续的集成测试策略。</p><p>交互方式关注两个维度：</p><ul><li>映射关系：<ul><li><strong>一对一</strong>：每个客户端由一个服务实例来处理。</li><li><strong>一对多</strong>：每个客户端由多个服务实例来处理。</li></ul></li><li>同步异步：<ul><li><strong>同步模式</strong>：客户端请求需要服务端实时响应，客户端等待响应时可能导致阻塞。</li><li><strong>异步模式</strong>：客户端请求不会阻塞进程，服务端响应可以非实时。</li></ul></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">一对一</th><th style="text-align:center">一对多</th></tr></thead><tbody><tr><td style="text-align:center">同步模式</td><td style="text-align:center">请求/响应</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">异步模式</td><td style="text-align:center">异步请求/响应<br>单向通知</td><td style="text-align:center">发布/订阅<br>发布/异步响应</td></tr></tbody></table><ul><li>一对一的交互方式：<ul><li><strong>请求/响应</strong>：一个客户端向服务端发起请求，等待响应；客户端期望服务端很快发送响应。在一个基于线程的应用中，等待过程可能造成线程阻塞，这种方式会导致服务紧耦合。</li><li><strong>异步请求/响应</strong>：客户端发送请求到服务端，服务端异步响应请求。客户端等待时不会阻塞线程，而服务端响应也不一定会马上返回。</li><li><strong>单向通知</strong>：客户端请求发送到服务端，但不期望服务端做出任何响应。</li></ul></li><li>一对多的交互方式：<ul><li><strong>发布/订阅</strong>：客户端发布通知消息，被零个或多个感兴趣的服务订阅。</li><li><strong>发布/异步响应</strong>：客户端发布请求消息，然后等待从感兴趣的服务发回的响应。</li></ul></li></ul><p>注意：底层的进程间通信技术并不会影响所选择的交互方式，可以是REST或消息机制，但选择同步请求/响应方式都会使客户端等待响应。</p><h3 id="1-4-定义API"><a href="#1-4-定义API" class="headerlink" title="1.4 定义API"></a>1.4 定义API</h3><p>设计良好的接口在暴漏有用功能的同时隐藏实现细节，实现可以被修改，但接口尽量保持不变以不对客户端产生影响。</p><p>Java是静态类型编程语言，如果接口与客户端不兼容，应用程序会无法通过编译。微服务架构的挑战是：没有一个简单的编程语言结构可以用来构造和定义服务的API。若使用不兼容的API部署新版本的服务，编译阶段不会出错，但会导致运行时故障。</p><p>使用<strong>接口定义语言</strong>（IDL）精确定义服务的API很重要，API优先设计，迭代几轮API定义后再开始具体的服务实现编程。</p><ul><li>使用消息机制，API由消息通道、消息类型和消息格式组成。</li><li>使用HTTP，API由URL、HTTP动词以及请求和响应格式组成。</li></ul><h3 id="1-5-API演化"><a href="#1-5-API演化" class="headerlink" title="1.5 API演化"></a>1.5 API演化</h3><p>微服务中API的使用者很有可能是另外的开发团队或组织外的人，不能够要求客户端跟服务端API版本保持一致，现代应用程序有着极高的可用性要求，一般会采用滚动升级的方式来更新服务，所以一个服务的新版本和旧版本肯定会共存。</p><ul><li><p><strong>语义化版本控制</strong>：是一组规则，用于指定如何使用版本号，并且以正确的方式递增版本号。</p><p>版本号由三部分组成：</p><ul><li>MAJOR：对API进行不兼容的更改时。</li><li>MINOR：对API进行向后兼容的增强时。</li><li>PATCH：进行向后兼容的错误修复时。</li></ul><p>如使用REST API时，可以使用主要版本作为URL路径的第一个元素；使用消息机制的服务，可以在发布的消息中包含版本号。</p></li><li><p><strong>进行次要并且向后兼容的改变</strong>：向后兼容是对API的附加更改或功能增强。</p><ul><li>客户端和服务端应该遵守健壮性原则，服务为缺少的请求属性提供默认值，客户端忽略额外的响应属性。</li></ul></li><li><p><strong>进行主要并且不向后兼容的改变</strong>：因为无法强制客户端升级，所以需要在一段时间内同时支持新旧版本的API。</p><ul><li>使用基于HTTP的进程间通信机制，如REST，可以在URL中嵌入主要版本号，版本1对应 <code>/v1/...</code> 和 版本2对应 <code>/v2/...</code> 为前缀。</li></ul></li></ul><h3 id="1-6-消息格式"><a href="#1-6-消息格式" class="headerlink" title="1.6 消息格式"></a>1.6 消息格式</h3><ul><li>基于文本：消息过度冗长，解析文本引入了额外开销。<ul><li>XML：相比JSON更长。</li><li>JSON</li></ul></li><li>基于二进制：提供了一个强类型定义的IDL（接口描述文件），用于定义消息的格式。编译器自动根据格式生成序列化和反序列化代码。<ul><li>Protocol Buffers：使用tagged fields，带标记的字段。</li><li>Avro：其消费者在解析消息前要知道格式。</li></ul></li></ul><h2 id="二-基于同步远程过程调用模式的通信"><a href="#二-基于同步远程过程调用模式的通信" class="headerlink" title="二. 基于同步远程过程调用模式的通信"></a>二. 基于同步远程过程调用模式的通信</h2><p>基于同步远程过程调用（RPI）的通信机制中，客户端假定消息将及时到达。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010131.jpg" alt></p><p>代理接口通常封装底层通信协议，可以选如REST何gRPC等。</p><h3 id="2-1-REST"><a href="#2-1-REST" class="headerlink" title="2.1 REST"></a>2.1 REST</h3><h4 id="2-1-1-RESTful风格"><a href="#2-1-1-RESTful风格" class="headerlink" title="2.1.1 RESTful风格"></a>2.1.1 RESTful风格</h4><p>REST是一种总是使用HTTP协议的进程间通信机制，提供了一系列架构约束，强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，其强化了安全性也能封装遗留系统。</p><p>REST使用<strong>资源</strong>表示单个业务对象，使用<strong>HTTP动词</strong>来操作资源，使用<strong>URL</strong>引用资源。</p><ul><li>GET获取资源</li><li>POST创建资源</li><li>PUT更新资源</li><li>DELETE删除资源</li></ul><h4 id="2-1-2-成熟度模型"><a href="#2-1-2-成熟度模型" class="headerlink" title="2.1.2 成熟度模型"></a>2.1.2 成熟度模型</h4><ul><li>Level 0：客户端只是向服务端点发起HTTP POST请求，进行服务调用。每个请求指明了需要执行的操作、针对的目标和必要的参数。</li><li>Level 1：该层级引入资源的概念，客户端需要发出指定要执行的操作和包含任何参数的POST请求。</li><li>Level 2：使用HTTP动词来执行操作，请求查询参数和主体指定操作的参数，这能够让服务借助Web基础设施服务，如通过CDN缓存GET请求。</li><li>Level 3：基于HATEOAS（Hypertext As The Engine Of Application State）原则设计，基本思想是由GET请求返回的资源信息中包含链接，链接能够执行该资源允许的操作。如客户端通过订单资源包含的链接取消某一订单或获取该订单详情。优点包括无需在客户端代码中写入硬链接的URL，因为资源包括允许操作的链接，客户端无需猜测在当前状态应执行何操作。</li></ul><h4 id="2-1-3-需要解决的问题"><a href="#2-1-3-需要解决的问题" class="headerlink" title="2.1.3 需要解决的问题"></a>2.1.3 需要解决的问题</h4><ul><li>在一个请求中获取多个资源：<ul><li>API允许获取资源时检索相关资源，如 <code>GET/orders/order-id-1345?expand=consumer</code> 检索order和consumer。但对于复杂的场景不太适用。</li><li>GraphQL 和 Netflix Falcor 实现了高效的数据获取。</li></ul></li><li>把操作映射为HTTP动词：有可能有多种更新操作，如取消或修改订单。<ul><li>使用子资源，如 <code>POST/orders/{orderId}/cancel</code> 和 <code>POST/orders/{orderId}/revise</code>  端点。</li><li>将动词指定为URL的查询参数。</li><li>此两种解决方案都有些违背了RESTful的要求。</li></ul></li></ul><h4 id="2-1-4-优缺点"><a href="#2-1-4-优缺点" class="headerlink" title="2.1.4 优缺点"></a>2.1.4 优缺点</h4><p>优点：</p><ul><li>简单直观</li><li>可以使用浏览器扩展（如Postman插件）或 curl 之类的命令行来测试HTTP API</li><li>直接支持请求 / 响应方式的通信</li><li>HTTP对防火墙友好</li><li>不需要中间代理，简化了系统架构</li></ul><p>缺点：</p><ul><li>只支持请求 / 响应方式的通信</li><li>可能导致可用性降低。由于客户端和服务直接通信，而未通过代理缓冲消息，二者在调用期间都要保持在线。</li><li>客户端必须知道服务实例的位置-URL，但现代应用要求客户端必须使用<strong>服务发现机制</strong>来定位服务实例。</li><li>在单个请求中获取多个资源具有挑战性。</li><li>很难将多个更新操作映射为HTTP动词。</li></ul><h3 id="2-2-gRPC"><a href="#2-2-gRPC" class="headerlink" title="2.2 gRPC"></a>2.2 gRPC</h3><p>gRPC是一个用于编写跨语言客户端和服务端的框架，是一种基于二进制消息的协议，所以必须采用API优先的服务设计方法。</p><p>可以使用Protocol Buffer的IDL定义gRPC的API，是谷歌公司用于序列化结构化数据的一套语言中立机制，使用Protocol Buffer编译器生成客户端的<strong>桩</strong>（sub，也叫存根）和服务器<strong>骨架</strong>（skeleton），支持如Java、C#、Node.js 和 Golang等。<strong>客户端和服务端使用 HTTP/2 以Protocol Buffer格式交换二进制消息</strong>。</p><p>gRPC API 由一个或多个服务和请求/响应消息定义组成。服务定义类似于Java接口，是强类型方法的集合，支持请求/响应RPC和流式RPC。服务器可以使用消息流回复客户端，客户端也可以向服务器发送消息流。</p><p>Protocol Buffers是一种高效的二进制消息格式，消息的每个字段都有编号和一个类型代码；消息接收方可以提取所需字段，跳过无法识别的字段。因此特性gRPC API可以保持向后兼容的同时进行变更。</p><p>如OrderService的gRPC API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateOrderRequest和CreateOrderReply是具有类型的消息</span></span><br><span class="line">service OrderService &#123;</span><br><span class="line">    <span class="function">rpc <span class="title">createOrder</span><span class="params">(CreateOrderRequest)</span> <span class="title">returns</span> <span class="params">(CreateOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">rpc <span class="title">cancelOrder</span><span class="params">(CancelOrderRequest)</span> <span class="title">returns</span> <span class="params">(CancelOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">rpc <span class="title">reviseOrder</span><span class="params">(ReviseOrderRequest)</span> <span class="title">returns</span> <span class="params">(ReviseOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateOrderRequest &#123;</span><br><span class="line">    int64 restaurantId = <span class="number">1</span>;</span><br><span class="line">    int64 consumerId = <span class="number">2</span>;</span><br><span class="line">    repeated LineItem lineItems = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LineItem &#123;</span><br><span class="line">    string menuItemId = <span class="number">1</span>;</span><br><span class="line">    int32 quantity = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateOrderReply &#123;</span><br><span class="line">    int64 orderId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>设计具有复杂更新操作的API很简单</li><li>具有高效、紧凑的进程间通信机制，特别是交换大量消息时</li><li>支持在远程过程调用和消息传递过程中使用双向流式消息方式</li><li>实现了客户端和各种语言编写的服务端之间的互操作性</li></ul><p>缺点：</p><ul><li>与基于REST/JSON的API机制相比，JavaScript客户端使用基于gRPC的API需要做更多工作</li><li>旧式防火墙可能不支持HTTP/2</li></ul><h3 id="2-3-使用断路器模式处理局部故障"><a href="#2-3-使用断路器模式处理局部故障" class="headerlink" title="2.3 使用断路器模式处理局部故障"></a>2.3 使用断路器模式处理局部故障</h3><p>服务间通信总是无法避免会遇到局部故障，可以通过断路器模式来应对故障。</p><p>断路器模式：<strong>远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内，这个代理会立即拒绝其他调用</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010132.jpg" alt></p><p>OrderServiceProxy会无限期阻塞，等待响应，在带来糟糕体验的同时，消耗如线程等宝贵资源，最终API Gateway 将耗尽资源无法处理请求，整个API都不可用。</p><p>解决此问题：</p><ul><li><p><strong>开发可靠的远程过程调用代理</strong>：如 Netflix Hystrix 等开源库。</p><p>当服务同步调用一个服务时，需要保证：</p><ul><li><strong>网络超时</strong>：等待请求的响应时，不要无限阻塞，设定一个超时，保证不会一直在无响应的请求上浪费资源。</li><li><strong>限制客户端向服务器发出请求的数量</strong>：对特定请求服务设置上限，达到上限后新的请求会立即失败。</li><li><strong>断路器模式</strong>：监控客户端发出请求的成功和失败数目，失败比例超过阈值，启动断路器，让后续调用立即失效。大量的请求失败表示被调服务不可用，即使再发送请求也无济于事，而是经过一段时间后再尝试，若请求成功则解除断路器。</li></ul></li><li><p><strong>从服务失效故障中恢复</strong>：</p><p>根据具体情况选择如何从无响应的远程服务中恢复服务：</p><ul><li>返回错误：如图 3-3 创建Order失败时，只能将失败返回给移动端。</li><li>返回备用值：如图 3-3 使用API组合模式实现，调用了多个服务并将结果组合在一起。结果的重要性不同，如Order服务不可用时要返回其数据的缓存版本或错误信息；其他则不重要，可以返回缓存版本或忽略。</li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010133.jpg" alt></p><h3 id="2-4-服务发现"><a href="#2-4-服务发现" class="headerlink" title="2.4 服务发现"></a>2.4 服务发现</h3><h4 id="2-4-1-为什么需要服务发现？"><a href="#2-4-1-为什么需要服务发现？" class="headerlink" title="2.4.1 为什么需要服务发现？"></a>2.4.1 为什么需要服务发现？</h4><p>发送请求需要知道服务实例的网络位置，现代基于云的微服务应用程序中，服务实例具有动态分配的IP地址，还会因为自动扩展、故障和升级等导致服务实例集动态修改。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010134.jpg" alt></p><h4 id="2-4-2-服务发现机制会做什么？"><a href="#2-4-2-服务发现机制会做什么？" class="headerlink" title="2.4.2 服务发现机制会做什么？"></a>2.4.2 服务发现机制会做什么？</h4><p>服务发现的关键组件是服务注册表，是包含服务实例网络位置信息的数据库。服务实例启动和停止时，服务发现机制都会更新服务注册表，客户端调用服务时，服务发现机制会查询服务注册表获取服务实例的列表，并将请求路由到其中一个服务实例。</p><h4 id="2-4-3-实现方式"><a href="#2-4-3-实现方式" class="headerlink" title="2.4.3 实现方式"></a>2.4.3 实现方式</h4><ul><li>服务及其客户直接与服务注册表交互；</li><li>通过部署基础设施来处理服务发现。</li></ul><h4 id="2-4-4-应用层服务发现模式"><a href="#2-4-4-应用层服务发现模式" class="headerlink" title="2.4.4 应用层服务发现模式"></a>2.4.4 应用层服务发现模式</h4><p>服务实例使用服务注册表来注册网络位置，客户端先查询表获取信息再向其中一个实例发送请求。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010135.jpg" alt></p><ul><li><strong>自注册模式</strong>：服务实例向服务注册表注册自己，服务注册表定期调用<strong>运行状况检查</strong>端点来验证服务实例是否正常且能接收请求，服务实例要定期调用心跳API以防止注册过期。</li><li><strong>客户端发现模式</strong>：客户端从服务注册表检索可用服务实例的列表，客户端可以缓存服务实例，并且使用负载均衡算法来选择服务实例。</li></ul><p>应用层服务发现工具：Spring Cloud默认使用Eureka进行服务发现。</p><ul><li>Eureka：高可用的注册中心</li><li>Ribbon：Eureka的 HTTP 客户端</li></ul><p>优点：</p><ul><li>服务发现与部署平台无关，可以解决多平台部署问题。如同时使用Kubernetes和遗留环境，基于Eureka能同时适用二者，而基于平台的服务发现只能用于Kubernetes平台。</li></ul><p>弊端：</p><ul><li>需要为每种编程语言提供服务发现库，Spring Cloud 只能服务于 Spring 开发，如 Node.js 或 Golang 需要相应的服务发现框架。</li><li>开发者负责设置和管理服务注册表，最好使用部署基础设施提供的服务发现机制。</li></ul><h4 id="2-4-5-平台层服务发现模式"><a href="#2-4-5-平台层服务发现模式" class="headerlink" title="2.4.5 平台层服务发现模式"></a>2.4.5 平台层服务发现模式</h4><p>现代部署平台，如Docker和Kubernetes都有内置的服务注册表和服务发现机制。平台为每个服务提供DNS名称、虚拟IP地址（VIP地址）和解析为VIP地址的DNS名称。客户端向DNS名称和VIP发出请求，部署平台自动将请求路由到其中一个可用实例，整个流程完全由平台处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010136.jpg" alt></p><ul><li><strong>第三方注册模式</strong>：由注册服务器（第三方）负责处理注册，服务不用再自己注册。</li><li><strong>服务端发现模式</strong>：客户端不需要查询注册表，而是向DNS名称发出请求，对此名称的请求会解析到路由器，路由器查询服务注册表并对请求进行负载均衡。</li></ul><p>优点：</p><ul><li>服务和客户端不需包含服务发现代码，不论任何语言和框架都可以使用。</li></ul><p>弊端：</p><ul><li>仅限于使用此平台部署的服务，但尽管如此还是推荐平台提供的服务发现。</li></ul><h2 id="三-基于异步消息模式的通信"><a href="#三-基于异步消息模式的通信" class="headerlink" title="三. 基于异步消息模式的通信"></a>三. 基于异步消息模式的通信</h2><p>使用消息机制时，服务之间的通信采用异步交换消息的方式完成。</p><p>实现方案：</p><ul><li>通常会使用<strong>消息代理</strong>，它充当服务之间的中介。</li><li><strong>无代理架构</strong>，直接向服务发送消息，因为通信是异步的，所有客户端不会堵塞和等待回复。</li></ul><h3 id="3-1-消息传递"><a href="#3-1-消息传递" class="headerlink" title="3.1 消息传递"></a>3.1 消息传递</h3><p>消息通过消息通道进行交换，发送方将消息写入通道，接受方从通道读取消息：</p><ul><li><p><strong>消息</strong>：</p><ul><li>组成结构：消息头部 + 消息主体。</li><li>内容：<ul><li>标题：名称与值对的集合，描述正在发送的数据的元数据。</li><li>消息ID：唯一标识。</li><li>返回地址：指定发送回复的消息通道。</li><li>正文：文本或二进制格式的数据。</li></ul></li><li>消息类型：<ul><li>文档：仅包含数据的通用消息。</li><li>命令：一条等同于RPC请求的消息，指定要调用的操作及参数。</li><li>事件：标识发送方发生了重要事件，通常是领域事件，表示领域对象状态更改。</li></ul></li></ul></li><li><p><strong>消息通道</strong>：消息传递基础设施的抽象。</p><ul><li>消息通道类型：<ul><li><strong>点对点通道</strong>：向正在从通道读取的一个消费者传递消息，实现一对一交互方式，常用于命令式消息。</li><li><strong>发布-订阅通道</strong>：将一条消息发给所有订阅的接收方，实现一对多交互方式，常用于事件式消息。</li></ul></li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010137.jpg" alt></p><h3 id="3-2-使用消息机制实现交互方式"><a href="#3-2-使用消息机制实现交互方式" class="headerlink" title="3.2 使用消息机制实现交互方式"></a>3.2 使用消息机制实现交互方式</h3><p>消息机制本质是异步的，只提供异步请求/响应，客户端和服务端通过交换一对消息来实现异步请求/响应方式的交互。</p><p>如下图，客户端发送命令式消息，内容通过服务拥有的点对点消息通道传递，服务处理请求后将包含结果的回复消息发送到客户端拥有的点对点通道。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010138.jpg" alt></p><p>客户端必须告诉服务发送回复消息的位置，并且要对回复和请求进行匹配。msgId叫相关性ID，用来匹配二者。</p><p>消息机制可以实现的交互方式：</p><ul><li><strong>实现请求/响应和异步请求/响应</strong>，前者期望立即响应。</li><li><strong>实现单向通知</strong>：客户端将消息发送到服务所拥有的点对点通道，服务订阅并处理消息，但并不回复。</li><li><strong>实现发布/订阅</strong>：客户端将消息发布到由多个接收方读取的发布/订阅通道，微服务中可以用发布/订阅来发布领域事件，如OrderService将Order事件发布到Order通道，对特定领域事件感兴趣的服务只要订阅即可。</li><li><strong>实现发布/异步响应</strong>：是发布/订阅和请求/响应两种方式的元素组合在一起，客户端发布一条消息，在消息的头部中指定<strong>回复通道</strong>（同时也是一个发布-订阅通道）。消费者将包含<strong>相关性ID</strong>的回复消息写入回复通道，客户端通过相关性ID来收集响应，以此将回复消息与请求匹配。</li></ul><h3 id="3-3-为基于消息机制的服务API创建API规范"><a href="#3-3-为基于消息机制的服务API创建API规范" class="headerlink" title="3.3 为基于消息机制的服务API创建API规范"></a>3.3 为基于消息机制的服务API创建API规范</h3><p>服务的异步API包含供客户端调用的操作和由服务对外发布的事件：</p><ul><li>记录异步操作：<ul><li>请求/异步响应式API：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式，以及服务发送的回复消息的类型和格式。</li><li>单向通知式API：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式。</li></ul></li><li>记录事件发布：服务还可以使用发布/定义的方式对外发布事件，API风格的规范包括事件通道以及服务发布到通道的事件式消息的类型和格式。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010139.jpg" alt></p><h3 id="3-4-使用消息代理"><a href="#3-4-使用消息代理" class="headerlink" title="3.4 使用消息代理"></a>3.4 使用消息代理</h3><p>消息代理，即服务通信的基础设施服务。除了消息代理架构，还有基于无代理的消息传递架构，其中服务相互通信。二者各有利弊，通常会选择消息代理架构。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010140.jpg" alt></p><ul><li><p>无代理消息：服务直接交换消息</p><ul><li>ZeroMQ是一种流行的无代理消息技术，支持各种传输协议（如TCP、UNIX）风格的套接字和多播。</li><li>优点：<ul><li>允许更轻的网络流量和更低的延迟，因为消息直接从发送方到接收方，少了一层代理；</li><li>消除了消息代理可能成为性能瓶颈或单点故障的可能性；</li><li>具有较低的操作复杂性，因为不需要设置和维护消息代理。</li></ul></li><li>缺点：<ul><li>服务需要知道彼此的位置，必须使用服务发现机制。</li><li>会导致可用性降低，因为在交换消息时，消息的发送方和接收方必须同时在线。</li><li>在实现例如确保消息能够成功投递这些复杂功能时的挑战性更大。</li></ul></li><li>这些弊端和同步请求响应的交互方式相同，所以大多数企业应用选择基于消息代理的架构。</li></ul></li><li><p>基于代理的消息：消息代理作为所有消息的中介节点。</p><ul><li><p>开源消息代理技术：</p><ul><li>Apache ActiveMQ</li><li>RabbitMQ</li><li>Apache Kafka</li><li>AWS Kinesis 和 AWS SQS ：基于云的消息服务。</li></ul></li><li><p>优点：</p><ul><li>发送方不需知道接收方的网络位置。</li><li>消息代理可以缓冲消息，直到接收方能够处理它们。</li></ul></li><li>需要考虑：<ul><li>支持的编程语言</li><li>支持的消息标准：如AMQP何STOMP</li><li>消息排序</li><li>投递保证</li><li>持久性：消息能否持久化到磁盘并在代理崩溃时恢复</li><li>耐久性：接收方重连到消息代理，是否会收到断开连接时发送的消息</li><li>可扩展性</li><li>延迟</li><li>竞争性（并发）接收方</li></ul></li><li>每种消息代理只能尽量侧重以上的几点，需要根据场景需求选择合适的消息代理。</li></ul></li></ul><p>使用消息代理实现消息通道：</p><ul><li>ActiveMQ等JMS消息代理具有队列和主题；</li><li>RabbitMQ等基于AMQP的消息代理具有交换和队列；</li><li>Kafka有主题；</li><li>AWS Kinesis有流</li><li>AWS SQS有队列。</li></ul><table><thead><tr><th>消息代理</th><th>点对点通道</th><th>发布-订阅通道</th></tr></thead><tbody><tr><td>JMS</td><td>队列</td><td>主题</td></tr><tr><td>Kafka</td><td>主题</td><td>主题</td></tr><tr><td>AMQP</td><td>队列</td><td>组播式交换和每客户端队列</td></tr><tr><td>AWS Kinesis</td><td>流</td><td>流</td></tr><tr><td>AWS SQS</td><td>队列</td><td>/</td></tr></tbody></table><p>只有AWS SQS只支持点对点通道，其余都支持发布-订阅通道。</p><p>消息代理的优点：</p><ul><li>松耦合：</li><li>消息缓存</li><li>灵活的通信</li><li>明确的进程间通信</li></ul><p>消息代理的缺点：</p><ul><li>潜在的性能瓶颈</li><li>潜在的单点故障</li><li>额外的操作复杂性</li></ul><h3 id="3-5-处理并发和消息顺序"><a href="#3-5-处理并发和消息顺序" class="headerlink" title="3.5 处理并发和消息顺序"></a>3.5 处理并发和消息顺序</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010141.jpg" alt></p><h3 id="3-6-处理重复消息"><a href="#3-6-处理重复消息" class="headerlink" title="3.6 处理重复消息"></a>3.6 处理重复消息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010142.jpg" alt></p><h3 id="3-7-事务性消息"><a href="#3-7-事务性消息" class="headerlink" title="3.7 事务性消息"></a>3.7 事务性消息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010143.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010144.jpg" alt></p><h3 id="3-8-消息相关类库和框架"><a href="#3-8-消息相关类库和框架" class="headerlink" title="3.8 消息相关类库和框架"></a>3.8 消息相关类库和框架</h3><h2 id="四-使用异步消息提供可用性"><a href="#四-使用异步消息提供可用性" class="headerlink" title="四. 使用异步消息提供可用性"></a>四. 使用异步消息提供可用性</h2><h3 id="4-1-同步消息会降低可用性"><a href="#4-1-同步消息会降低可用性" class="headerlink" title="4.1 同步消息会降低可用性"></a>4.1 同步消息会降低可用性</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010145.jpg" alt></p><h3 id="4-2-消除同步交互"><a href="#4-2-消除同步交互" class="headerlink" title="4.2 消除同步交互"></a>4.2 消除同步交互</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010146.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010147.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010148.jpg" alt></p><hr><p>参考：</p><p>🔗 《微服务架构设计模式》</p>]]></content>
    
    <summary type="html">
    
      《微服务架构设计模式》读书笔记，内容：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="microservice" scheme="http://linyishui.top/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构设计模式（二）服务的拆分策略</title>
    <link href="http://linyishui.top/2020111001.html"/>
    <id>http://linyishui.top/2020111001.html</id>
    <published>2020-11-10T12:07:16.000Z</published>
    <updated>2020-11-26T13:50:35.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="服务的拆分策略"><a href="#服务的拆分策略" class="headerlink" title="服务的拆分策略"></a>服务的拆分策略</h1><h2 id="第一节-微服务架构是什么？"><a href="#第一节-微服务架构是什么？" class="headerlink" title="第一节 微服务架构是什么？"></a>第一节 微服务架构是什么？</h2><h3 id="1-1-软件架构是什么？"><a href="#1-1-软件架构是什么？" class="headerlink" title="1.1 软件架构是什么？"></a>1.1 软件架构是什么？</h3><p><strong>软件架构</strong>是一种抽象的结构，由软件的各个组成部分和它们之间的依赖关系构成。<strong>计算机系统的软件架构是构建这个系统所需要的一组结构，包含软件元素、它们之间的关系以及两者的属性</strong>。</p><p>将软件分解成元素和定义这些元素之间的关系，决定了软件的能力。</p><p>应用程序有两个层次的需求：<strong>功能性需求</strong>和<strong>质量性需求</strong>，后者决定一个应用在运行和开发时的质量，由所选择的软件架构决定。</p><h3 id="1-2-软件架构的-4-1-视图模型"><a href="#1-2-软件架构的-4-1-视图模型" class="headerlink" title="1.2 软件架构的 4 + 1 视图模型"></a>1.2 软件架构的 4 + 1 视图模型</h3><p>软件架构可以像建筑一样有多个架构视角（+1指场景，把视图串联在一起）：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010108.jpg" alt></p><p>每个视图的目的：</p><ul><li>逻辑视图：开发人员创建的元素，在面向对象语言中是类（Class）和包（Package），关系包括继承、关联和依赖。</li><li>实现视图：构建编译系统的输出，组件是由一个或多个模块组成的可执行或可部署单元。在Java中模块是JAR文件，组件是WAR文件或可执行JAR文件；关系包括模块间的依赖关系和组件模块间的组合关系。</li><li>进程视图：运行时的组件，元素是进程，进程间关系即进程间通信。</li><li>部署视图：进程如何映射到机器，元素由计算机和进程组成，机器之间的关系即网络。</li></ul><h3 id="1-3-架构的风格"><a href="#1-3-架构的风格" class="headerlink" title="1.3 架构的风格"></a>1.3 架构的风格</h3><p>分层架构将软件元素按层的方式组织，每层都有自己的职责，上一层只能依赖于下方的层。</p><p>应用程序可以根据分层结构分为：</p><ul><li>表现层</li><li>业务逻辑层</li><li>数据持久化层</li></ul><p>但表现层无法体现应用可能由多个系统调用的情况，持久化层也无法体现多个数据库交互，业务逻辑层实际上也并不一定依赖于数据持久化层。</p><p>六边形结构是分层结构的替代架构：业务逻辑不再依赖于适配器，而是相反适配器都依赖于业务逻辑。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010109.jpg" alt></p><ul><li>入栈端口是业务逻辑公开的API，外部程序都可以调用它。</li><li><p>出栈端口是业务逻辑调用外部系统的方式，比如存储接口定义了一系列数据访问操作。</p></li><li><p>入栈适配器调用入栈端口处理外部的请求，Spring MVC Controller 或 订阅消息的消息代理客户端。</p></li><li>出栈适配器调用外部应用或服务处理业务逻辑的请求，如数据访问对象（DAO）类或调用远程服务的代理类。</li></ul><h3 id="1-4-微服务架构风格"><a href="#1-4-微服务架构风格" class="headerlink" title="1.4 微服务架构风格"></a>1.4 微服务架构风格</h3><p>单体架构是一种架构风格，实现视图是单个组件，将应用构建为单个可执行或可部署组件。</p><p>微服务架构是一种架构风格，实现视图由多个组件构成，将应用构建为松耦合、可独立部署的一组服务。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010110.jpg" alt></p><h4 id="1-4-1-什么是服务？"><a href="#1-4-1-什么是服务？" class="headerlink" title="1.4.1 什么是服务？"></a>1.4.1 什么是服务？</h4><p>单一的、可独立部署的软件组件就是服务，其API封装了内部实现，强制实现了应用程序的模块化。每个服务都有自己的架构甚至技术栈，往往都是六边形架构，业务逻辑和适配器交互。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010111.jpg" alt></p><h4 id="1-4-2-什么是松耦合？"><a href="#1-4-2-什么是松耦合？" class="headerlink" title="1.4.2 什么是松耦合？"></a>1.4.2 什么是松耦合？</h4><p>服务自身的持久化数据就像类的私有属性一样被封装，这样开发者就可以任意修改服务的数据结构而不用担心影响到别的服务。</p><h4 id="1-4-3-共享类库的角色"><a href="#1-4-3-共享类库的角色" class="headerlink" title="1.4.3 共享类库的角色"></a>1.4.3 共享类库的角色</h4><p>开发时会把常用的功能打包以便多个应用可以重用，而不必复制代码，这是减少重复代码的好方法，但有可能会意外的在服务之间引入耦合。</p><p>把可能会变更的功能作为服务来实现（如业务功能），而不变的可以打包成库。</p><h4 id="1-4-4-服务大小并不重要"><a href="#1-4-4-服务大小并不重要" class="headerlink" title="1.4.4 服务大小并不重要"></a>1.4.4 服务大小并不重要</h4><p>“微”并不特指服务很小，更多的含义应该是单一，我们需要能够识别服务，并确定它们之间如何协作。</p><h2 id="第二节-为应用程序定义微服务架构"><a href="#第二节-为应用程序定义微服务架构" class="headerlink" title="第二节 为应用程序定义微服务架构"></a>第二节 为应用程序定义微服务架构</h2><p>定义程序架构和软件开发一样，没有一个机械化的流程可以保证输出一个合理的架构，我们只能使用一些不断迭代和创新的方法：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010112.jpg" alt></p><p>大致流程：</p><ul><li>第一步将应用程序的需求提炼为各种<strong>系统操作</strong>，是程序必须要处理的请求。</li><li>第二步确定如何<strong>分解服务</strong>。</li><li>第三步<strong>确定每个服务的API</strong>。将每个系统操作分配给服务，服务可以独立或协作实现操作。</li></ul><p>服务分解的几个障碍：</p><ul><li><strong>网络延迟</strong>：服务间往返太多会出现问题。</li><li><strong>同步通信</strong>：服务间的同步通信会降低可用性，需要使用<strong>自包含服务</strong>。</li><li><strong>跨服务的数据一致性</strong>：使用<strong>Saga</strong>。</li><li><strong>上帝类</strong>（God Class）：使用<strong>领域驱动设计</strong>（DDD）消除上帝类。</li></ul><h3 id="2-1-识别系统操作"><a href="#2-1-识别系统操作" class="headerlink" title="2.1 识别系统操作"></a>2.1 识别系统操作</h3><p>第一步创建由关键类组成的抽象领域模型，关键类提供用于描述系统操作的词汇表。第二步确定系统操作，根据领域模型描述每个系统操作的行为。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010113.jpg" alt></p><p>领域模型来源于用户故事中的名词，系统操作来源于动词。</p><h4 id="（1）创建抽象领域模型"><a href="#（1）创建抽象领域模型" class="headerlink" title="（1）创建抽象领域模型"></a>（1）创建抽象领域模型</h4><p>通过需求整理用户故事，从中提炼得到：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010114.jpg" alt></p><p>每个类的作用：</p><ul><li>Consumer：下订单的用户。</li><li>Order：用户下的订单，描述订单信息并跟踪状态。</li><li>OrderLineItem：订单的一个条目。</li><li>DeliveryInfo：送餐的时间和地址。</li><li>Restaurant：餐馆，准备生产订单，同时要发起送货。</li><li>MenuItem：餐馆菜单的一个条目。</li><li>Courier：送餐员负责把订单送到用户手里，可跟踪送餐员可用性和位置。</li><li>Address：用户和餐馆的地址。</li><li>Location：送餐员当前经纬度。</li></ul><h4 id="（2）定义系统操作"><a href="#（2）定义系统操作" class="headerlink" title="（2）定义系统操作"></a>（2）定义系统操作</h4><p>系统操作包括：</p><ul><li>命令型：创建、更新或删除数据的系统操作。</li><li>查询型：查询和读取数据的系统操作。</li></ul><p>分析用户故事中的动词，识别系统指令：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010121.jpg" alt></p><p>命令规范定义了命令对应的参数、返回值和领域模型类的行为，行为规范包括前置条件和后置条件：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010122.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010123.jpg" alt></p><p>抽象的领域模型和系统操作可以回答这个应用是做什么的问题，每一个系统操作的行为都通过领域模型的方式来描述。</p><h3 id="2-2-根据业务能力进行服务拆分"><a href="#2-2-根据业务能力进行服务拆分" class="headerlink" title="2.2 根据业务能力进行服务拆分"></a>2.2 根据业务能力进行服务拆分</h3><h4 id="（1）什么是业务能力？"><a href="#（1）什么是业务能力？" class="headerlink" title="（1）什么是业务能力？"></a>（1）什么是业务能力？</h4><p>业务能力：指一些能够为公司产生价值的商业活动。</p><p>组织的业务能力指组织的业务是什么，这通常是固定的，而组织采用何种方式来实现其业务能力往往是不断变化的。每个组织有哪些业务能力，通过对组织的目标、结构和商业流程的分析得来。每个业务都可以看作是一个服务，除非只面向业务而非技术。</p><p>业务能力集中在业务对象上，如理赔业务对象是理赔管理功能的重点，能力又可以划分为子能力，理赔管理又包括理赔信息管理、理赔审核和理赔付款管理。</p><blockquote><p>FTGO的业务能力：</p><ul><li>供应商管理<ul><li>Courier management：送餐员相关信息管理</li><li>Restaurant information management：餐馆菜单和其他信息管理（如营业地址和时间）</li></ul></li><li>消费者管理<ul><li>消费者有关信息的管理</li></ul></li><li>订单获取和履行<ul><li>Order management：让消费者可以创建和管理订单</li><li>Restaurant order management：让餐馆可以管理订单的生产过程</li><li>送餐管理</li><li>Courier availability management：送餐员实时状态</li><li>Delivery management：把订单送到用户手中</li></ul></li><li>会计记账<ul><li>Consumer accounting：管理跟消费者相关的会计记账</li><li>Restaurant accounting：管理跟餐馆相关的会计记账</li><li>Courier accounting：管理跟送餐员相关的会计记账</li></ul></li><li>其他</li></ul></blockquote><h4 id="（2）根据业务能力映射到服务"><a href="#（2）根据业务能力映射到服务" class="headerlink" title="（2）根据业务能力映射到服务"></a>（2）根据业务能力映射到服务</h4><p>确定了业务能力后可以为每个能力定义服务，能力有级别划分，哪层级别映射到服务是很主观的判断，有以下理由：</p><ul><li>供应商管理映射到两个服务，因为餐馆和送餐员是完全不同的供应商。</li><li>订单获取和履行映射到三个服务，每个服务负责流程的不同阶段。其中送餐员可用性管理和交付管理结合在一起，映射到单个服务，因为二者交织在一起。</li><li>会计记账能力映射到一个独立服务，不同类型的会计也很相似。</li></ul><p>如下图所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010124.jpg" alt></p><p>架构定义流程的一个重要步骤是调查服务如何在每个关键架构服务中协作，比如你发现由于过多的进程间通信导致特定的分解效率低下，导致必须要把一些服务组合在一起。而在复杂性方面则会增长到很值得拆分的程度。</p><h3 id="2-3-根据DDD子域进行服务拆分"><a href="#2-3-根据DDD子域进行服务拆分" class="headerlink" title="2.3 根据DDD子域进行服务拆分"></a>2.3 根据DDD子域进行服务拆分</h3><p>DDD通过定义多个领域模型解决传统模型难以让所有团队保持一致的难题（如术语），每个领域模型都有明确的范围。</p><ul><li><strong>子域</strong>：领域驱动为每个子域定义单独的领域模型，领域用来描述应用程序问题域的一个术语。识别子域和识别业务能力一样，分析业务并识别业务的不同专业领域，如FTGO的子域有（订单获取、订单管理、餐馆管理、送餐与会计）</li><li><strong>限界上下文</strong>（bounded context）：领域模型的边界被称为限界上下文，包括实现这个模型的代码集合。</li></ul><p>通过DDD的方式定义一个个子域，并把每个子域对应为对应的一个服务，从而完成微服务的设计工作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010125.jpg" alt></p><h3 id="2-4-拆分的原则"><a href="#2-4-拆分的原则" class="headerlink" title="2.4 拆分的原则"></a>2.4 拆分的原则</h3><p>面向对象的设计原则也可以应用于微服务架构：</p><ul><li><strong>单一职责原则</strong>（SRP）：每个类都应该只有一个职责，这样就只有一个理由对它进行修改。多个职责就会使类变得不稳定，对于微服务而言就如FTGO中为客户获取餐食中每个方面（订单获取、订单准备、送餐）都由单一的服务承载。</li><li><strong>闭包原则</strong>（CCP）：在包中所包含的类都是对同类变化的集合，如果要对包进行修改，需要调整的类都应该在包内。若两个类的修改必须耦合的先后发生，它们应该在同一个包内，这样开发者只须对一个交付包进行修改，而不是大规模的修改整个应用。对于微服务架构，CCP是解决分布式单体的利器。</li></ul><h3 id="2-5-拆分单体应用为服务的难点"><a href="#2-5-拆分单体应用为服务的难点" class="headerlink" title="2.5 拆分单体应用为服务的难点"></a>2.5 拆分单体应用为服务的难点</h3><ul><li><strong>网络延迟</strong>：<ul><li>问题：服务分解导致两个服务间大量的往返调用。</li><li>解决：可以通过批处理一次往返多个对象，或者把多个相关服务组合用编程语言的函数调用代替高昂的进程间通信来解决。</li></ul></li><li><strong>同步进程间通信导致可用性降低</strong>：<ul><li>问题：如新增订单 <code>createOrder()</code> 通常让 OrderService 使用REST同步调用其他服务，REST这样的协议会降低服务可用性，任一被调用服务不在可用状态就导致订单无法创建。</li><li>解决：异步消息降低同步调用的紧耦合，同时提高可用性。</li></ul></li><li><strong>在服务之间维持数据一致性</strong>：<ul><li>问题：需要更新多个服务的数据时，保持服务间的数据一致性。如餐馆接受订单时，要在KitchenService和DeliveryService中同时更新，前者修改Ticket状态，后者安排订单交付，都要以原子化的方式完成更新。</li><li>解决：传统的解决方案是基于两阶段提交的分布式事务管理，但并非最好的选择；Saga是一系列使用消息协作的本地事务，唯一的限制是最终一致性，需要原子更新数据都在单个服务中。</li></ul></li><li><strong>获取一致的数据视图</strong>：<ul><li>问题：无法跨过多个数据库获得一致的真实视图。单体应用中ACID保证返回一致视图，微服务即使每个服务数据库都一致也无法得到。</li><li>解决：视图必须驻留在单个服务中。</li></ul></li><li><strong>上帝类阻碍了拆分</strong>：<ul><li>问题：整个应用程序都要使用的全局类，上帝类代表对应用至关重要的概念如银行账户、电子商务订单、保险政策等等。对于FIGO就是Order类，系统大部分服务都涉及订单。如下图2-10是传统建模创建的Order类结构。</li><li>解决：<ul><li>将Order类打包到库，创建一个中央数据库，处理订单的所有服务都要访问该库。但此方案破坏了微服务架构的原则，并导致了紧耦合。</li><li>将Order数据库封装到OrderService供其他服务调用，但OrderService将成为一个纯数据服务，成为缺乏业务逻辑的<strong>贫血领域模型</strong>。</li><li>好的方案是遵循DDD将每个服务视为领域模型的单独子域，FTGO的每个与订单相关的服务都有自己的领域模型及对应的Order类的版本。如下图2-11，对于DeliveryService，Order可以命名为更合适的Delivery。</li></ul></li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010126.jpg" alt></p><p>DeliveryService对Order的其他属性不感兴趣：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010127.jpg" alt></p><p>KitchenService的Order就是一个Ticket（后厨工单），只包含状态、请求送餐时间、准备时间等，以及告诉餐馆准备的订单项列表。而不关心如消费者、付款、交付这些无关属性。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010128.jpg" alt></p><p>每个领域模型的Order类都表示同一个订单业务实体的不同方面，应用必须维持不同服务中这些不同对象之间的一致性。比如一旦OrderService授权消费者的信用卡，必须触发KitchenService中创建Ticket。同样，如果KitchenService拒绝订单，必须在OrderService中取消订单，并为客户退款。</p><p><strong>可以通过事件驱动机制Saga来维护服务间的一致性</strong>。</p><h3 id="2-6-定义服务API"><a href="#2-6-定义服务API" class="headerlink" title="2.6 定义服务API"></a>2.6 定义服务API</h3><p>到这个阶段，我们有了一个系统操作列表和潜在服务列表，下一步是定义每个服务的API：<strong>服务的操作和事件</strong>。</p><p>定义API操作的原因：</p><ol><li>某些操作对应系统操作，由外部客户端调用，或者其他服务调用。</li><li>支持服务之间协作的操作，仅供其他服务调用。</li></ol><p>服务通过对外发布事件，使其能与其他服务协作。</p><h4 id="（1）将系统操作分配给服务"><a href="#（1）将系统操作分配给服务" class="headerlink" title="（1）将系统操作分配给服务"></a>（1）将系统操作分配给服务</h4><p>第一步，确定哪个服务是请求的初始入口点。如 <code>noteUpdateLocation()</code> 更新送餐员位置，因为与送餐员相关，所以应该分配给CourierService，但它也是需要送餐地点的DeliveryService。这种情况最好把操作分配给需要操作所提供信息的服务，其他情况下分配给具有处理它所需信息的服务更有意义。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010129.jpg" alt></p><h4 id="（2）确定支持服务协作所需要的API"><a href="#（2）确定支持服务协作所需要的API" class="headerlink" title="（2）确定支持服务协作所需要的API"></a>（2）确定支持服务协作所需要的API</h4><p>第二步，是确定在处理每个系统操作时，服务之间如何交互。</p><p>如 <code>createOrder()</code> 操作需要OrderService调用一下服务以验证其前置条件并使后置条件成立：</p><ul><li>ConsumerService：验证消费者是否可以下订单并获取付款信息。</li><li>RestaurantService：验证订单行项目，验证送货地址和时间是否在餐厅的服务区域内，验证订单最低要求，并获得订单行项目的价格。</li><li>KitchenService：创建Ticket后厨工单。</li><li>AccountingService：授权消费者的信用卡。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010130.jpg" alt></p><hr><p>参考：</p><p>🔗 《微服务架构设计模式》</p>]]></content>
    
    <summary type="html">
    
      《微服务架构设计模式》读书笔记，内容：微服务架构是什么，微服务架构风格，为应用定义微服务架构的流程（识别系统操作、根据业务能力或DDD子域进行服务拆分、拆分的原则和难点、定义服务的API）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="microservice" scheme="http://linyishui.top/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构设计模式（一）逃离单体地狱</title>
    <link href="http://linyishui.top/2020110701.html"/>
    <id>http://linyishui.top/2020110701.html</id>
    <published>2020-11-07T13:09:35.000Z</published>
    <updated>2020-11-09T14:28:37.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="逃离单体地狱"><a href="#逃离单体地狱" class="headerlink" title="逃离单体地狱"></a>逃离单体地狱</h1><h2 id="第一节-为什么要使用微服务架构"><a href="#第一节-为什么要使用微服务架构" class="headerlink" title="第一节 为什么要使用微服务架构"></a>第一节 为什么要使用微服务架构</h2><h3 id="1-1-单体架构的优点"><a href="#1-1-单体架构的优点" class="headerlink" title="1.1 单体架构的优点"></a>1.1 单体架构的优点</h3><ul><li>应用开发简单：只须构建一个项目。</li><li>方便进行大规模修改</li><li>测试简单直观：测试只须启动程序，调用REST API，使用如Selenium等测试工具。</li><li>部署简单：复制war包到Tomcat。</li><li>横向扩展容易：只须部署多个实例并进行负载均衡。</li></ul><h3 id="1-2-单体地狱"><a href="#1-2-单体地狱" class="headerlink" title="1.2 单体地狱"></a>1.2 单体地狱</h3><ul><li>程序代码规模不断壮大，复杂性越来越高。</li><li>开发速度缓慢，编译、构建、运行都十分耗时。</li><li>代码提交到实际部署周期长，且容易发生问题：代码太过复杂，一个更改所造成的影响难以预测，导致即使是微小的修改也需要测试人员全面的测试。</li><li>难以扩展：不同模块需求如内存、CPU等需要同时被满足。</li><li>缺乏可靠性：应用庞大难以进行全面的测试，错误的代码会进入生产环境；应用缺乏<strong>故障隔离</strong>，一处内存泄漏会导致应用所有实例崩溃。</li><li>长期依赖过时的技术栈：单体架构难以更新框架和语言，因为应用要被重写。</li></ul><p>架构并不影响功能性需求（业务），主要影响的是<strong>非功能性需求</strong>，也叫<strong>质量属性</strong>或其他能力。最常见的就是影响软件交付速度的<strong>可维护性</strong>、<strong>可扩展性</strong>和<strong>可测试性</strong>。</p><h3 id="1-3-扩展立方体"><a href="#1-3-扩展立方体" class="headerlink" title="1.3 扩展立方体"></a>1.3 扩展立方体</h3><ul><li>X轴扩展：<strong>水平复制</strong>，通过克隆实例的方式来扩展。<ul><li>将用户请求通过负载均衡算法路由到几个相同的应用实例。</li><li>可以提供吞吐量和可用性。</li></ul></li><li>Y轴扩展：<strong>功能性分解</strong>，通过分解不同的功能模块的方式来扩展。<ul><li><strong>将应用程序拆分为一组服务，每个服务负责特定的功能，每个服务可以进行X轴或Z轴扩展</strong>。</li><li>解决了开发问题和应用复杂性。</li></ul></li><li>Z轴扩展：<strong>数据分区</strong>，通过类似用户ID切分相似的数据分区的方式来扩展。<ul><li>每个应用实例仅负载数据的一个子集，路由器根据请求的UserId来决定路由到哪个实例。</li><li>可以提供吞吐量和可用性，适用于增长的事务和数据量。</li></ul></li></ul><h3 id="1-4-什么是微服务？"><a href="#1-4-什么是微服务？" class="headerlink" title="1.4 什么是微服务？"></a>1.4 什么是微服务？</h3><p>针对微服务的定义有很多，比如<strong>强调尺寸</strong>的如服务的代码应该在100行内，<strong>强调开发周期</strong>的如两周内；微服务可以定义为<strong>面向服务的架构，由松耦合和具有边界上下文的元素组成</strong>。</p><p>容易理解的概括：<strong>微服务是把应用程序功能性分解为一组服务的架构风格，是一种模块化的形式</strong>。</p><p>在单体应用中，模块由一组编程语言所提供的结构（如Java的 Package 或 Jar 这样的构建制品）定义。微服务则使用服务作为模块化的单元，服务的API即自身的边界，只能通过API来访问服务内部的类。</p><p>微服务架构的关键特性是<strong>每个服务之间都是松耦合的，只通过API进行通信</strong>。实现这种松耦合，需要<strong>每个服务都有自己的私有数据库</strong>。</p><h3 id="1-5-微服务与SOA的异同"><a href="#1-5-微服务与SOA的异同" class="headerlink" title="1.5 微服务与SOA的异同"></a>1.5 微服务与SOA的异同</h3><table><thead><tr><th></th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>服务间通信</td><td>智能管道如ESB，往往采用重量级协议，如SOAP或其他WS*标准</td><td>使用哑管道，如消息代理，或服务之间点对点通信，如REST或gRPC等轻量级协议</td></tr><tr><td>数据管理</td><td>全局数据模型并共享数据库</td><td>每个服务都有自己的数据模型和数据库</td></tr><tr><td>典型服务的规模</td><td>较大的单体应用（几个）</td><td>较小的服务（几百个）</td></tr></tbody></table><h3 id="1-6-微服务架构的优缺点"><a href="#1-6-微服务架构的优缺点" class="headerlink" title="1.6 微服务架构的优缺点"></a>1.6 微服务架构的优缺点</h3><p>优点：</p><ul><li><p>使大型复杂应用程序可以<strong>持续交付和持续部署</strong>：持续交付和持续部署是DevOps的一部分，</p><ul><li><p>三种实现方式：</p><ul><li>拥有可测试性：自动化测试是持续交付和持续部署的重要环节，每个服务都很小，所以易于编写和执行自动化测试。</li><li>拥有可部署性：每个服务都可以独立于其他服务进行部署，而不需要互相协调。</li><li>使开发团队可以自主且松散耦合：开发团队可以分为一个个小团队，每个团队负责一个或多个相关服务的开发与部署。</li></ul></li><li><p>三个作用：</p><ul><li>缩短产品或新功能的上市时间，更快响应客户的反馈。</li><li>提供客户所期望的可靠服务。</li><li>提高员工满意度，因为他们不用再此处担任救火队员。</li></ul></li></ul></li><li><p>每个服务都相对<strong>较小</strong>并<strong>容易维护</strong>：</p><ul><li>较小的代码规模更有利于开发者理解。</li><li>IDE等开发工具使用起来更快速，提高开发效率。</li><li>服务启动速度快很多，提高了研发、调试、部署等效率。</li></ul></li><li><p>服务可以<strong>独立部署</strong>：</p><ul><li>每次修改或新增功能后，不需要再将整个应用重新部署。</li></ul></li><li><p>服务可以<strong>独立扩展</strong>：</p><ul><li>服务可以再进行X轴、Z轴扩展。</li><li>服务可以部署在适合的硬件上，需要高内存的和需要高CPU的可以分别部署。</li></ul></li><li><p><strong>实现团队的自治</strong>：</p><ul><li>小规模团队可以自行治理，专注于解决服务内问题。</li></ul></li><li><p><strong>更易实验和接纳新技术</strong>：</p><ul><li>每一个新服务都可以自由选择适宜的语言和框架，现实往往公司会有很多限制和规范，但至少有了选择的权利。</li><li>服务更小也使用新技术重写一个服务变得可能，如果实验失败也可以承担这部分损失而不至于毁掉整个项目。</li></ul></li><li><p><strong>更好的容错性</strong>：</p></li><li>可以实现更好的故障隔离，一个服务的问题不会影响其他服务。</li></ul><p>缺点：</p><ul><li>服务的拆分和定义是一项挑战：<ul><li>没有一个具体的、优质的算法来完成服务拆分。</li><li>一旦拆分失误，可能会构建出一个分布式的单体应用，一大堆紧耦合的服务又必须部署在一起的分布式系统。</li></ul></li><li>分布式系统带来各种复杂性，使开发、测试和部署变得更困难：<ul><li>服务间必须使用进程间通信机制。</li><li>必须处理局部故障和远程服务不可用或高延迟的情况。</li><li>每个服务都有自己的数据库，跨服务的事务和查询比较复杂。</li><li>运维难度增高，需要高度自动化的技术：<ul><li><strong>自动化部署工具</strong>：如 Netflix Spinnaker。</li><li><strong>产品化的PaaS平台</strong>：如 Pivotal Cloud Foundry 或 Red Hat OpenShift。</li><li><strong>Docker容器编排平台</strong>：如 Docker Swarm 或 Kubernates。</li></ul></li></ul></li><li>当部署跨越多个服务的功能时需要谨慎的协调更多开发团队：<ul><li>需要制定一个发布计划，按照服务的依赖关系排序。</li></ul></li><li>开发者需要思考到底应该在应用的什么阶段使用微服务架构：<ul><li>项目初创阶段往往并不需要微服务架构来解决问题，此时单体架构是更高效的选择。</li><li>微服务是一把双刃剑，不过面向消费者的Web应用或SaaS类复杂程序往往适用于微服务架构。</li></ul></li></ul><h2 id="第二节-模式语言"><a href="#第二节-模式语言" class="headerlink" title="第二节 模式语言"></a>第二节 模式语言</h2><h3 id="2-1-为什么需要模式？"><a href="#2-1-为什么需要模式？" class="headerlink" title="2.1 为什么需要模式？"></a>2.1 为什么需要模式？</h3><p>1986年，《人月神话》作者曾说过：软件工程的世界没有银弹。任何技术都有其利弊，但开发人员还是会坚信新的技术会是万能钥匙，人的大脑中情绪化的部分会进行大部分的决策。所以<strong>我们需要一种客观的工具，来克服情绪化的本能</strong>，这种工具即模式（Pattern）。</p><h3 id="2-2-什么是模式和模式语言？"><a href="#2-2-什么是模式和模式语言？" class="headerlink" title="2.2 什么是模式和模式语言？"></a>2.2 什么是模式和模式语言？</h3><p><strong>模式是针对上下文中发生的问题的可重用解决方案</strong>，<strong>模式语言是解决特定领域内问题的相关模式的集合</strong>。1994年，《设计模式：可复用面向对象软件的基础》采用模式语言来解决设计和架构问题，在开发人员中普及了模式的概念。</p><p>模式需要描述其适用的上下文环境，结构：</p><ul><li>需求（Forces）</li><li>结果上下文（Resulting context）</li><li>相关模式（Related patterns）</li></ul><h4 id="2-2-1-需求-必须解决的问题"><a href="#2-2-1-需求-必须解决的问题" class="headerlink" title="2.2.1 需求-必须解决的问题"></a>2.2.1 需求-必须解决的问题</h4><p>需求需要按优先级排序，重要性取决于上下文环境。比如代码要求可读性和好的性能在一些情况下是冲突的，只能尽量满足其中一种。</p><h4 id="2-2-2-结果上下文-采用模式后可能带来的后果"><a href="#2-2-2-结果上下文-采用模式后可能带来的后果" class="headerlink" title="2.2.2 结果上下文-采用模式后可能带来的后果"></a>2.2.2 结果上下文-采用模式后可能带来的后果</h4><p>包含三个部分：</p><ul><li>好处：这个模式的好处和它解决了什么需求。</li><li>弊端：这个模式的弊端和它未解决什么需求。</li><li>问题：使用这个模式引入的新问题。 </li></ul><h4 id="2-2-3-相关模式-5种不同类型的关系"><a href="#2-2-3-相关模式-5种不同类型的关系" class="headerlink" title="2.2.3 相关模式-5种不同类型的关系"></a>2.2.3 相关模式-5种不同类型的关系</h4><p>相关模式描述该模式和其他模式间的关系：</p><ul><li><strong>前导</strong>（Predecessor）：<strong>催生这个模式的需求的模式</strong>。<ul><li>如微服务架构模式是除了单体架构模式以外整个模式语言中所有模式的前导模式。</li></ul></li><li><strong>后续</strong>（Successor）：<strong>指用来解决当前模式引入新问题的模式</strong>。<ul><li>如引入微服务模式后需要解决如服务发现、断路器等微服务带来的新问题。</li></ul></li><li><strong>替代</strong>（Alternative）：<strong>当前模式的替代模式，提供了另外的解决方案</strong>。<ul><li>如单体模式和微服务模式互为替代模式。</li></ul></li><li><strong>泛化</strong>（Generalization）：<strong>针对一个问题的一般性解决方案</strong>。<ul><li>如“每主机单个服务”这个模式存在多种不同的技术实现。</li></ul></li><li><strong>特化</strong>（Specialization）：<strong>针对特定模式的具体解决方案</strong>。<ul><li>如将服务部署为容器模式是针对“每主机单个服务”的具体解决方案。</li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010101.jpg" alt></p><p>通过这些关系可以将相关的模式集合形成所谓的模式语言，共同解决特定领域的问题。</p><h3 id="2-3-微服务架构的模式语言"><a href="#2-3-微服务架构的模式语言" class="headerlink" title="2.3 微服务架构的模式语言"></a>2.3 微服务架构的模式语言</h3><p>左侧是应用程序架构模式组，应用相关模式组解决引入微服务架构后带来的新问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010102.jpg" alt></p><h4 id="2-3-1-服务拆分的相关模式"><a href="#2-3-1-服务拆分的相关模式" class="headerlink" title="2.3.1 服务拆分的相关模式"></a>2.3.1 服务拆分的相关模式</h4><p>根据业务或子域切分服务：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010103.jpg" alt></p><h4 id="2-3-2-通信的相关模式"><a href="#2-3-2-通信的相关模式" class="headerlink" title="2.3.2 通信的相关模式"></a>2.3.2 通信的相关模式</h4><p>分布式系统中进程间通信是重要组成部分，通信模式包括：</p><ul><li><strong>通信风格</strong>：使用哪一类进程间通信机制？</li><li><strong>服务发现</strong>：客户端如何获得服务具体事例（如HTTP请求）的IP地址？</li><li><strong>可靠性</strong>：在服务不可用的情况下，如何确保服务之间的可靠通信？</li><li><strong>事务性消息</strong>：如何将消息发送、事件发布这样的动作与更新业务数据的数据库事务集成？</li><li><strong>外部API</strong>：应用程序的客户端如何与服务通信？</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010104.jpg" alt></p><h4 id="2-3-3-实现事务管理的数据一致性的相关模式"><a href="#2-3-3-实现事务管理的数据一致性的相关模式" class="headerlink" title="2.3.3 实现事务管理的数据一致性的相关模式"></a>2.3.3 实现事务管理的数据一致性的相关模式</h4><p>为什么常用的两步式提交（2PC）分布式事务机制在微服务架构场景不再适用？而是需要使用Saga来确保数据一致性？</p><h4 id="2-3-4-微服务架构查询数据的相关模式"><a href="#2-3-4-微服务架构查询数据的相关模式" class="headerlink" title="2.3.4 微服务架构查询数据的相关模式"></a>2.3.4 微服务架构查询数据的相关模式</h4><p>传统SQL JOIN在微服务场景需要从多个服务的数据源获取数据，服务的数据只能通过API访问，所以不能直接针对服务的数据库执行分布式查询：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010105.jpg" alt></p><p>API组合模式，逐一调用服务的API再把所有返回聚合在一起，即<strong>命令查询职责隔离方式</strong>（CQRS）。</p><h4 id="2-3-5-服务部署的相关模式"><a href="#2-3-5-服务部署的相关模式" class="headerlink" title="2.3.5 服务部署的相关模式"></a>2.3.5 服务部署的相关模式</h4><p>微服务架构需要高度自动化部署的基础设施，即一个部署平台，至少有一个简单的界面来部署和管理服务。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010106.jpg" alt></p><h4 id="2-3-6-可观测性的相关模式"><a href="#2-3-6-可观测性的相关模式" class="headerlink" title="2.3.6 可观测性的相关模式"></a>2.3.6 可观测性的相关模式</h4><p>理解和诊断微服务架构下的问题是一项复杂的工作，在返回结果给客户端前，请求往往会在多个服务之间跳转，只看一个日志文件是不够的。</p><p>可以通过以下模式设计具备可观测性的服务：</p><ul><li><strong>健康检查API</strong>：可以返回服务健康状态的API。</li><li><strong>日志聚合</strong>：把服务产生的日志写入一个集中式的日志服务器，这个服务器可以提供日志搜索，也可以根据日志情况触发报警。</li><li><strong>分布式追踪</strong>：为每一个外部请求分配一个唯一的ID，用于在各个服务之间追踪外部请求。</li><li><strong>异常跟踪</strong>：把程序异常发送到异常跟踪服务，这个服务会排除重复异常，给开发者发送告警并跟踪每一个异常的解决。</li><li><strong>应用指标</strong>：供维护使用的指标，例如计数器等，导出到指标服务器。</li><li><strong>审计日志</strong>：记录用户的行为。</li></ul><h4 id="2-3-7-服务自动化测试的相关模式"><a href="#2-3-7-服务自动化测试的相关模式" class="headerlink" title="2.3.7 服务自动化测试的相关模式"></a>2.3.7 服务自动化测试的相关模式</h4><p>单一的服务测试变得更容易，但还要测试不同的服务是否协同工作，避免使用复杂、缓慢和脆弱的端到端测试来测试多个服务。</p><ul><li><strong>消费端驱动的契约测试</strong>：验证服务满足客户端所期望的功能。</li><li><strong>消费端契约测试</strong>：验证服务的客户端可以正常与服务通信。</li><li><strong>服务组件测试</strong>：在隔离的环境中测试服务。</li></ul><h4 id="2-3-8-解决基础设施和边界问题的相关模式"><a href="#2-3-8-解决基础设施和边界问题的相关模式" class="headerlink" title="2.3.8 解决基础设施和边界问题的相关模式"></a>2.3.8 解决基础设施和边界问题的相关模式</h4><p>每个服务都需要实现与基础设施相关的功能，如可观测模式和服务发现模式。还必须实现外部化配置模式，在运行时向服务提供数据库凭据等配置参数。</p><h4 id="2-3-9-安全的相关模式"><a href="#2-3-9-安全的相关模式" class="headerlink" title="2.3.9 安全的相关模式"></a>2.3.9 安全的相关模式</h4><p>微服务架构中，用户身份验证的工作由API Gateway完成，它必须将用户信息传递给需要的服务。常见的解决方案是<strong>应用访问令牌模式</strong>（JWT），将Token传递给服务，服务验证Token获得用户信息。</p><h2 id="第三节-流程和组织"><a href="#第三节-流程和组织" class="headerlink" title="第三节 流程和组织"></a>第三节 流程和组织</h2><p>架构、流程和组织的关系：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010107.jpg" alt></p><p>《人月神话》提到沟通成本随着团队规模增加呈O(N^2^)速度上升，解决办法是大团队切分为一个个小团队，每个团队都是跨职能的，可以独立完成开发、测试和部署等任务，而不需要频繁和其他团队沟通或协调。</p><p>微服务架构适用于 Scrum 或 Kanban 这类敏捷开发和部署实践，需要积极实践持续交付和持续部署。</p><blockquote><p>持续交付能够以可持续的方式安全、快速的将所有类型的更改（包括新功能、配置更改、错误修复和实验）交付到生产环境或用户手中。</p></blockquote><p>持续交付依赖于高水平的自动化，包括自动化测试。持续部署有效的支持持续交付，每天多次部署到生产环境，很少发生生产中断，并且可以从任意事件中快速恢复。</p><blockquote><p>持续交付和持续部署的四个有用指标：</p><ul><li>部署频率：软件部署到生产环境的频率。</li><li>交付时间：从开发人员提交变更到变更被部署的时间。</li><li>平均恢复时间：从生产环境问题中恢复的时间。</li><li>变更失败率：导致生产环境问题的变更提交百分比。</li></ul></blockquote><hr><p>参考：</p><p>🔗 《微服务架构设计模式》</p>]]></content>
    
    <summary type="html">
    
      《微服务架构设计模式》读书笔记，内容：为什么要使用微服务架构，微服务架构的模式语言，架构、流程和组织的变化等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="microservice" scheme="http://linyishui.top/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（八）高阶</title>
    <link href="http://linyishui.top/2020101301.html"/>
    <id>http://linyishui.top/2020101301.html</id>
    <published>2020-10-13T03:20:01.000Z</published>
    <updated>2020-11-03T13:38:27.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（八）高阶"><a href="#RabbitMQ（八）高阶" class="headerlink" title="RabbitMQ（八）高阶"></a>RabbitMQ（八）高阶</h1><h2 id="第一节-存储机制"><a href="#第一节-存储机制" class="headerlink" title="第一节 存储机制"></a>第一节 存储机制</h2><h3 id="1-1-消息如何存储"><a href="#1-1-消息如何存储" class="headerlink" title="1.1 消息如何存储"></a>1.1 消息如何存储</h3><p>消息：</p><ul><li>持久化消息：到达队列时写入磁盘，允许的话在内存保留备份，内存吃紧时清除。</li><li>非持久化消息：一般保存在内存，内存吃紧时转移到磁盘。</li></ul><p>消息进入磁盘的处理在<strong>持久层</strong>完成，持久层包含：</p><ul><li><p><strong>队列索引</strong>（rabbit_queue_index）：负责维护队列中落盘消息的信息，包括消息的存储地点、是否己被交付给消费者、是否己被消费者 ack 等。每个队列都有一个对应的队列索引。</p><ul><li>存储方式：以顺序（文件名从0开始累加）的<strong>段文件</strong>来进行存储，后缀为 <code>.idx</code> ，每个段文件包含固定的 <code>SEGMENT_ENTRY_COUNT</code> 条记录，默认为16384。</li></ul></li><li><p><strong>消息存储</strong>（rabbit_msg_store）：以键值对的形式存储消息，它被所有队列共享，在每个节点中有且只有一个。</p><p>可以分为：</p><ul><li>msg_store_persistent：负责持久化消息的持久化，重启后消息不会丢失；</li><li>msg_store_transient：负责非持久化消息的持久化，重启后消息会丢失。</li></ul><p>存储方式：经过消息存储处理的消息都会以追加的方式写入到文件中，大小超过指定的限制 <code>file_size_limit</code> 后，关闭文件再创建一个新文件。<strong>在进行消息的存储时， 会在 ETS (Erlang Term Storage）表中记录消息在文件中的位置映射（Index）和文件的相关信息（FileSummary）</strong>。</p></li></ul><p>消息（包括消息体、属性和 headers ）可以直接存储在队列索引中，也可以被保存在消息存储中。一般按消息大小来划分，小消息放入前者，大消息放入后者。通过 <code>queue_index_embed_msgs_below</code> 来配置，默认为4096B（指消息体+属性+headers的整体大小）。</p><p><strong>读取消息</strong>流程：</p><ul><li>先根据消息的 ID（msg_id）找到对应存储的文件，</li><li>如果文件存在并且未被锁住，则直接打开文件，从指定位置读取消息的内容。</li><li>如果文件不存在或者被锁住了， 则发送请求由 rabbit_msg_store 进行处理。</li></ul><p><strong>删除消息</strong>只是从ETS表删除相关信息，同时更新对应的存储文件，所以不会立即对文件中的消息进行删除，只是标记为垃圾数据（类似GC？）。</p><p>触发垃圾回收的条件：</p><ul><li>一个文件全是垃圾数据，会删除此文件。</li><li>检测到前后两个文件（<strong>相邻</strong>）的有效数据可以合并在一个文件中，且所有垃圾数据的大小与文件总大小比值超过设定阈值 <code>GARBAGE_FRACTION</code>（默认0.5）时，触发垃圾回收，将文件合并。</li></ul><p>合并时先<strong>锁定</strong>两个文件，先<strong>整理前个文件</strong>的有效数据，再将后面文件的有效数据<strong>写入前个文件</strong>，同时<strong>更新ETS表</strong>的记录，最后<strong>删除后面的文件</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010152.png" alt></p><p>如果消息投递的目的队列是空的，并且有消费者订阅了这个队列，那么该消息会直接发送给消费者，不会经过队列这一步。而当消息无法直接投递给消费者时，需要暂时将消息存入队列，以便重新投递。</p><h3 id="1-2-队列的结构"><a href="#1-2-队列的结构" class="headerlink" title="1.2 队列的结构"></a>1.2 队列的结构</h3><h4 id="1-2-1-消息在队列中有四种状态"><a href="#1-2-1-消息在队列中有四种状态" class="headerlink" title="1.2.1 消息在队列中有四种状态"></a>1.2.1 消息在队列中有四种状态</h4><p>消息在队列中存在，其状态可能会不断发生变化：</p><ul><li>alpha ：消息内容（包括消息体、属性和 headers ）和消息索引都存储在内存中。</li><li>beta ：消息内容保存在磁盘中，消息索引保存在内存中。</li><li>gamma ：消息内容保存在磁盘中，消息索引在磁盘和内存中都有。<ul><li>只有持久化消息会处于此状态；</li><li>durable 属性设置为 true 的消息一定进入此状态；</li><li>在开启 publisher confirm 机制时， 只有到了 gamma 状态时才会确认该消息己被接收，若消息消费速度足够快，内存也充足，这些消息也不会继续走到下一个状态。</li></ul></li><li>delta ：消息内容和索引都在磁盘中。<strong>需要两次I/O操作才能读到消息，一次读消息索引（rabbit_queue_index），一次读消息内容（rabbit_msg_store）</strong>。前面状态则只需一次，直接读rabbit_msg_store，因为索引在内存中，而delta的索引在磁盘中。</li></ul><p>状态转换：</p><ul><li>在运行时可以根据消息的传送速度计算一个当前内存能够保存的最大消息数量 <code>target_ram_count</code> ，当 alpha 的消息数量大于此值时，会把多余的消息转为后续状态。</li><li>状态机制为了满足不同的内存和CPU需求，alpha 耗内存，但不怎么耗CPU；而如 delta 不消耗内存，但会消耗很多CPU和I/O操作。</li></ul><h4 id="1-2-2-队列子结构"><a href="#1-2-2-队列子结构" class="headerlink" title="1.2.2 队列子结构"></a>1.2.2 队列子结构</h4><p>队列结构包括：</p><ul><li>rabbit_amqqueue_process：负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认（包括生产端的 confirm 和消费端的 ack ）等。</li><li>backing_queue：是消息存储的具体形式和引擎，并向 rabbit_amqqueue_process 提供相关的接口以供调用。<ul><li>默认实现：rabbit_variable_queue，通过5个子队列Q1、Q2、Delta、Q3和Q4实现各个消息状态。</li></ul></li></ul><p>队列结构如图：Q1和Q4只包含alpha状态，Delta只包含delta状态，Q2和Q3包含beta和gamma状态；所以消息按这个顺序流动就是从内存到磁盘再回内存的过程，能够适应负载升高和降低的变化。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010153.png" alt></p><h4 id="1-2-3-从子队列消费消息"><a href="#1-2-3-从子队列消费消息" class="headerlink" title="1.2.3 从子队列消费消息"></a>1.2.3 从子队列消费消息</h4><p>消费者获取消息：</p><ul><li>尝试从Q4获取，成功则返回；</li><li>否则尝试从Q3获取，此时判断Q3是否为空，为空表示队列无消息；</li><li>Q3不为空则取出消息，再判断此时Q3和Delta的长度：<ul><li>若都为空，可以认为Q2到Q4都为空，将Q1消息转移到Q4方便下次读取。</li><li>若Q3为空，Delta不为空，将消息转移至Q3，方便下次获取。转移的过程按索引分段读取。</li></ul></li><li><strong>为什么Q3为空可以认为整个队列为空？</strong>因为若Q3为空时，Delta不为空，在取Q3取最后一条消息时必然会将Delta的消息转移过来，所有前面的子队列都可以类推。</li></ul><h4 id="1-2-4-为什么消息堆积很棘手"><a href="#1-2-4-为什么消息堆积很棘手" class="headerlink" title="1.2.4 为什么消息堆积很棘手"></a>1.2.4 为什么消息堆积很棘手</h4><p><strong>当负载较高时，消息不能很快被消费掉，就会进入到比较靠后的队列中，这就增加了处理每个消息的平均开销。因为要花更多的时间和资源来处理堆积的消息，自然处理新流入的消息的能力就会降低，新流入的消息又积压，这就构成了负循环，使情况越来越差。</strong></p><p><strong>处理方案</strong>：</p><ul><li><strong>增加 prefetch_count 的值，即一次发送多条消息给消费者，加快消息被消费的速度</strong>；</li><li><strong>采用 multiple ack ，降低处理 ack 带来的开销</strong>；</li><li><strong>流量控制</strong>。</li></ul><h3 id="1-3-惰性队列"><a href="#1-3-惰性队列" class="headerlink" title="1.3 惰性队列"></a>1.3 惰性队列</h3><p>RabbitMQ 在 3.6.0 版本引入了惰性队列，惰性队列会<strong>尽可能地将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中</strong>。</p><ul><li>设计目标：能够<strong>支持更长的队列</strong>，即<strong>支持更多的消息存储</strong>。</li><li>使用场景：当消费者由于各种各样的原因（比如消费者下线、宕机或者由于维护而关闭等）致使长时间内不能消费消息而造成堆积时，惰性队列就很有必要了。</li></ul><h4 id="1-3-1-为什么要使用惰性队列？"><a href="#1-3-1-为什么要使用惰性队列？" class="headerlink" title="1.3.1 为什么要使用惰性队列？"></a>1.3.1 为什么要使用惰性队列？</h4><p>默认情况下，消息生产到队列后会尽可能的存储到内存，以便更快速的发送给消费者。即使是持久化的消息，也在存入磁盘的同时驻留在内存一份备份。</p><p>内存占用过高时，需要释放内存将消息转移到磁盘，这一操作会耗费很长的时间，并且阻塞队列的操作，导致无法接收新的消息。</p><p>惰性队列则会将消息直接存到文件系统中，从而减少了内存的损耗。但相应的增加了I/O的使用，但其实对于持久化消息，I/O操作是无法避免的，所以<strong>持久化消息和惰性队列是绝配</strong>。</p><h4 id="1-3-2-使用惰性队列"><a href="#1-3-2-使用惰性队列" class="headerlink" title="1.3.2 使用惰性队列"></a>1.3.2 使用惰性队列</h4><p>可以在声明队列时设置惰性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-queue-mode"</span>, <span class="string">"lazy"</span>);</span><br><span class="line"><span class="comment">// 可以在声明队列时设置惰性</span></span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><p>也可以通过策略Policy的方式设置：（优先级大于前者）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy Lazy <span class="string">"^myqueue$"</span> <span class="string">'&#123;"queue-mode":"lazy"&#125;'</span> --apply-tO queues</span></span><br></pre></td></tr></table></figure><h4 id="1-3-3-惰性与普通队列的性能差距"><a href="#1-3-3-惰性与普通队列的性能差距" class="headerlink" title="1.3.3 惰性与普通队列的性能差距"></a>1.3.3 惰性与普通队列的性能差距</h4><p>假如发送1千万条消息，每条消息的大小为1KB ，并且此时没有任何的消费者，那么普通队列会消耗 1.2GB 的内存，而惰性队列只消耗 1.5MB 的内存。</p><p>对于普通队列，如果要发送1千万条消息，需要耗费 801 秒，平均发送速度约为 13000 条/秒。如果使用惰性队列，那么发送同样多的消息时，耗时是 421 秒，平 均发送速度约为 24000 条/秒。</p><p>出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近 40MB 的空间来发送消息，对于一个消费者的情况，平均的消费速度约为 14000 条/秒。</p><h2 id="第二节-内存及磁盘告警"><a href="#第二节-内存及磁盘告警" class="headerlink" title="第二节 内存及磁盘告警"></a>第二节 内存及磁盘告警</h2><p>内存有使用上限阈值，磁盘有剩余空间阈值，达到时都会使RabbitMQ暂时阻塞 客户端的连接并停止接收从客户端发来的消息，以此避免服务崩溃。心跳检测也会失效。</p><p>检测状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_connections</span></span><br></pre></td></tr></table></figure><ul><li>blocking：不发送消息的连接处于此状态。</li><li>blocked：一直有发送消息的处于此状态。</li></ul><h3 id="2-1-内存告警"><a href="#2-1-内存告警" class="headerlink" title="2.1 内存告警"></a>2.1 内存告警</h3><p>RabbitMQ 服务器会在启动或者执行 <code>rabbitmqctl set_vm_memory_high_watermark fraction</code> 命令时计算系统内存的大小，默认 <code>vm_memory_high_watermark</code> 为0.4，表示内存阈值为0.4，当RabbitMQ使用内存超过40%就会告警并阻塞。</p><p><strong>设置内存阈值</strong>：（不建议取值超过0.7）</p><ul><li><p>通过 <code>rabbitmq.config</code> 配置文件来配置：（需要重启服务器来启用）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">rabbit,</span> <span class="string">[</span></span><br><span class="line"><span class="string">&#123;vm_memory_high_watermark,</span> <span class="number">0.4</span><span class="string">&#125;</span></span><br><span class="line"><span class="comment"># 绝对值方式: &#123;vm_memory_high_watermark, &#123;absolute, 1073741824&#125;&#125; 也可以带单位&#123;absolute，"1024MiB"&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li><p>通过 rabbitmqctl 指令来配置：（服务器重启后会失效）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_vm_memory_high_watermark 0.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_vm_memory_high_watermark absolute &#123;memory_limit&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>当 Broker 节点达到内存阈值前会尝试将消息从内存换页到磁盘来释放空间</strong>（持久化和非持久化都会，持久化只须清除内存的副本即可），一般在内存阈值的50%会进行此操作。</p><p><strong>设置换页阈值</strong>：</p><ul><li><p>通过 <code>rabbitmq.config</code> 配置文件来配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">rabbit,</span> <span class="string">[</span></span><br><span class="line"><span class="string">&#123;vm_memory_high_watermark_paging_ratio,</span> <span class="number">0.75</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;vm_memory_high_watermark,</span> <span class="number">0.4</span><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-磁盘告警"><a href="#2-2-磁盘告警" class="headerlink" title="2.2 磁盘告警"></a>2.2 磁盘告警</h3><p>默认磁盘阈值为50MB，当磁盘空间低于这个值使会阻塞生产者并停止内存的换页操作。</p><p>RabbitMQ 会定期检测磁盘剩余空间，检测的频率与上一次执行检测到的磁盘剩余空间大小有关。正常情况下，每 10 秒执行一次检测，随着磁盘剩余空间与磁盘阈值的接近，检测频率会有所增加。当要到达磁盘阑值时，检测频率为每秒 10 次，这样有可能会增加系统的负载。</p><p><strong>设置磁盘阈值</strong>：（不建议取值超过0.7）</p><ul><li><p>通过 <code>rabbitmq.config</code> 配置文件来配置：（需要重启服务器来启用）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">rabbit,</span> <span class="string">[</span></span><br><span class="line"><span class="string">&#123;disk_free_limit,</span> <span class="number">1000000000</span><span class="string">&#125;</span></span><br><span class="line"><span class="comment"># &#123;disk_free_limit, "1GB"&#125; 或 &#123;disk_free_limit, &#123;mem_relative, 1.0&#125;&#125; 磁盘与内存大小的比值，建议1到2</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li><p>通过 rabbitmqctl 指令来配置：（服务器重启后会失效）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_disk_free_limit &#123;disk_limit&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_disk_free_limit mem_relative &#123;fraction&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第三节-流量控制"><a href="#第三节-流量控制" class="headerlink" title="第三节 流量控制"></a>第三节 流量控制</h2><p>RabbitMQ 从 2.8.0 版本引入流控（Flow Control）机制来保证稳定性。流控机制是用来避免消息的发送速率过快而导致服务器难以支撑的情形。</p><p><strong>内存及磁盘告警相当于全局的流控，一旦触发会阻塞集群中所有的连接；而流控则只针对单个连接。</strong></p><h3 id="3-1-流控的原理-信用证算法"><a href="#3-1-流控的原理-信用证算法" class="headerlink" title="3.1 流控的原理-信用证算法"></a>3.1 流控的原理-信用证算法</h3><p>Erlang 进程之间并不共享内存（binary 类型的除外），而是通过消息传递来通信，每个进程都有自己的进程邮箱（mailbox）。进程邮箱默认没有大小限制，所以大量消息发往某个进程会导致内存溢出并崩溃。对于RabbitMQ来说没有流控，很容易达到使邮箱大小达到内存阈值。</p><p>RabbitMQ 使用了一种<strong>基于信用证算法（credit-based algorithm）的流控机制来限制发送消息的速率</strong>以解决前面所提出的问题：它通过<strong>监控</strong>各个进程的进程邮箱，当某个进程负载过高而来不及处理消息时，这个进程的进程邮箱就会开始堆积消息。当堆积到一定量时，就会<strong>阻塞</strong>而不接收上游的新消息。从而慢慢地，上游进程的进程邮箱也会开始堆积消息。当堆积到一定量时也会阻塞而停止接收上游的消息，最后就会使负责网络数据包接收的进程阻塞而暂停接收新的数据。</p><h4 id="3-1-1-信用证算法说明"><a href="#3-1-1-信用证算法说明" class="headerlink" title="3.1.1 信用证算法说明"></a>3.1.1 信用证算法说明</h4><p>如图 9-4 ，进程A接收消息并转发至进程B，进程B接收消息并转发至进程C。<strong>每一个进程中都有一对关于收发消息的 credit 值</strong>。</p><p>以进程B为例：</p><ul><li><code>{ {credit_from, C}, value}</code> 表示能发送多少条消息给C，每发送一条消息该值减1，当为0时，进程B不再往进程C发送消息也不再接收进程A的消息。</li><li><code>{ {credit_to, A}, value}</code> 表示再接收多少条消息就向进程A发送增加 credit 值的通知，进程A接收到该通知后就增加 <code>{ {credit_from, B}, value}</code> 所对应的值，这样进程A就能持续发送消息。</li></ul><p>当上游发送速率高于下游接收速率时， credit 值就会被逐渐耗光，这时进程就会被阻塞，阻塞的情况会一直传递到最上游。当上游进程收到来自下游进程的增加 credit 值的通知时，若此时上游进程处于阻塞状态则解除阻塞，开始接收更上游进程的消息，一个一个传导最终能够解除最上游的阻塞状态。由此可知，基于信用证的流控机制最终将消息发送进程的发送速率限制在消息处理进程的处理能力范围之内。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010154.png" alt></p><p>可以通过 <code>rabbitmqctl list_connections</code> 命令或者Web管理界面来查看Connection的状态。</p><p>Connection触发流控时会处于flow状态，这个状态值并没有什么作用。</p><h4 id="3-1-2-流控链"><a href="#3-1-2-流控链" class="headerlink" title="3.1.2 流控链"></a>3.1.2 流控链</h4><p>流控机制不只是作用于 Connection ，同样作用于信道和队列。<strong>从Connection到Channel，再到队列，最后是消息持久化存储形成一个完整的流控链，对于处于整个流控链中的任意进程，只要该进程阻塞，上游的进程必定全部被阻塞</strong>。也就是说，如果某个进程达到性能瓶颈，必然会导致上游所有的进程被阻塞。所以我们可以利用流控机制的这个特点找出瓶颈之所在，处理消息的几个关键进程及其对应的顺序关系如图 9-6 所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010155.png" alt></p><ul><li>rabbit_reader：Connection 的处理进程，负责接收、解析 AMQP 协议数据包等。</li><li>rabbit_channel：Channel 的处理进程，负责处理 AMQP 协议的各种方法、进行路由解析等。</li><li>rabbit_amqqueue_process：队列的处理进程，负责实现队列的所有逻辑。</li><li>rabbit_msg_store：负责实现消息的持久化。</li></ul><h4 id="3-1-3-判断瓶颈情况"><a href="#3-1-3-判断瓶颈情况" class="headerlink" title="3.1.3 判断瓶颈情况"></a>3.1.3 判断瓶颈情况</h4><ul><li>当某个 Connection 处于flow状态，但此 Connection 中没有一个Channel处于flow状态，表示有一个或多个Channel出现了性能瓶颈。<ul><li>某些 Channel 进程的运作（比如处理路由逻辑）会使得服务器 CPU 负载过高从而导致了此种情形，尤其是在发送大量较小的非持久化消息时，此种情形最易显现。</li></ul></li><li>当某个 Connection 处于flow状态，且此 Connection 中有若干个Channel处于flow状态，但没有一个队列处于flow状态，表示有一个或多个队列出现了性能瓶颈。<ul><li>这可能是由于将消息存入队列的过程中引起服务器 CPU 负载过高，或者是将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较小的持久化消息时，此种情形最易显现。</li></ul></li><li>当某个 Connection 处于flow状态，且此 Connection 中有若干个Channel处于flow状态，且有若干个队列处于flow状态，表示在消息持久化时出现了性能瓶颈。<ul><li>在将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较大的持久化消息时，此种情形最易显现。</li></ul></li></ul><h3 id="3-2-案例：打破队列的瓶颈"><a href="#3-2-案例：打破队列的瓶颈" class="headerlink" title="3.2 案例：打破队列的瓶颈"></a>3.2 案例：打破队列的瓶颈</h3><p>通常会在rabbit_amqqueue_process即队列进程产生性能瓶颈，所以其上游的连接和信道会处于flow状态。</p><p>如何提高队列的性能？</p><ol><li>开启Erlang的HiPE功能，保守可以提升30%~40%的性能。</li><li>打破队列的瓶颈，指用多个rabbit_amqqueue_process来打破单个队列的性能上限，充分利用上游被流控的性能。</li></ol><p>如图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010156.png" alt></p><p>多个队列会导致应用复杂化，所以首先要<strong>封装</strong>，将交换器、队列、绑定关系、生成和消费的方法全部封装，使应用就像仍在操作一个队列。</p><p>封装实现步骤：</p><ol><li>声明交换器、队列、绑定关系：先与 Broker 建立连接，声明交换器一样，声明队列和绑定关系实际上是多个物理队列，先规划好分片数，分别声明对应数量的二者，如图 9-8。</li><li>封装生产者：</li><li>封装消费者：</li></ol><h4 id="（1）声明交换器、队列、绑定关系"><a href="#（1）声明交换器、队列、绑定关系" class="headerlink" title="（1）声明交换器、队列、绑定关系"></a>（1）声明交换器、队列、绑定关系</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010157.png" alt></p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * host，port，vhost，username，password值可以在rmq_cfg.properties 文件中配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmqEncapsulation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">5672</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String vhost = <span class="string">"/"</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username = <span class="string">"guest"</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"guest"</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> subdivisionNum;<span class="comment">//分片数，表示一个逻辑队列背后的实际队列数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RmqEncapsulation</span><span class="params">(<span class="keyword">int</span> subdivisionNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subdivisionNum = subdivisionNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建Connection</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(host);</span><br><span class="line">        connectionFactory.setVirtualHost(vhost);</span><br><span class="line">        connectionFactory.setPort(port);</span><br><span class="line">        connectionFactory.setUsername(username);</span><br><span class="line">        connectionFactory.setPassword(password);</span><br><span class="line">        connection = connectionFactory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Connection</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">            newConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭Connection</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明交换器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchangeDeclare</span><span class="params">(Channel channel, String exchange, String type, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        channel.exchangeDeclare(exchange, type, durable, autoDelete, autoDelete, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明队列，这里针对单个Broker设计，若集群有多个节点，需要让分片队列能均匀的散开到各个节点，达到负载均衡</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueDeclare</span><span class="params">(Channel channel, String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; subdivisionNum;i++) &#123;</span><br><span class="line">            String queueName = queue + <span class="string">"_"</span> + i;</span><br><span class="line">    channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建绑定关系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueBind</span><span class="params">(Channel channel, String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; subdivisionNum;i++) &#123;</span><br><span class="line">            String rkName = routingKey + <span class="string">"_"</span> + i;</span><br><span class="line">    channel.queueBind(queueName, exchange, rkName, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用封装工具来声明交换、队列和绑定关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RmqEncapsulation rmqEncapsulation = <span class="keyword">new</span> RmqEncapsulation(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       Connection connection = RmqEncapsulation.getConnection();</span><br><span class="line">       Channel channel = connection.createChannel();</span><br><span class="line">       rmqEncapsulation.exchangeDeclare(channel, <span class="string">"exchange"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">       rmqEncapsulation.queueDeclare(channel, <span class="string">"queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">       rmqEncapsulation.queueBind(channel, <span class="string">"queue"</span>, <span class="string">"exchange"</span>, <span class="string">"rk"</span>, <span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           RmqEncapsulation.closeConnection();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="（2）封装生产者"><a href="#（2）封装生产者" class="headerlink" title="（2）封装生产者"></a>（2）封装生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(Channel channel, String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, AMQP.BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">       <span class="comment">//随机挑选一个队列发送</span></span><br><span class="line">       Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">int</span> index = random.nextInt(subdivisionNum);</span><br><span class="line">       String rkName = routingKey + <span class="string">"_"</span> + index;</span><br><span class="line">       channel.basicPublish(exchange, rkName, mandatory, props, body); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用发送100条消息</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">       <span class="comment">// Message用来封装消息</span></span><br><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">       <span class="comment">// msgSeq表示消息的序号，有序</span></span><br><span class="line">message.setMsgSeq(i);</span><br><span class="line">       <span class="comment">// msgBody表示消息体，还有deliveryTag用于消息确认</span></span><br><span class="line">message.setMsgBody(<span class="string">"rabbitmq encapsulation"</span>);</span><br><span class="line">       <span class="comment">// 通过Serializable接口来实现序列化，实际使用建议用ProtoBuff这种性能高的序列化工具</span></span><br><span class="line">       <span class="comment">// 对象转换为字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] body = getBytesFromObject(message);</span><br><span class="line">rmqEncapsulation.basicPublish(channel, <span class="string">"exchange"</span>, <span class="string">"rk"</span>, <span class="keyword">false</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, body);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>封装4个物理队列与单个独立队列的QPS对比：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010158.png" alt></p><h4 id="（3）封装消费者"><a href="#（3）封装消费者" class="headerlink" title="（3）封装消费者"></a>（3）封装消费者</h4><p>消费分推模式和拉模式，拉模式的封装实现比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GetResponse <span class="title">basicGet</span><span class="params">(Channel channel, String queue, <span class="keyword">boolean</span> autoAck)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">       <span class="comment">// 首先随机拉取一个物理队列的数据</span></span><br><span class="line">       GetResponse getResponse = <span class="keyword">null</span>;</span><br><span class="line">       Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">int</span> index = random.nextInt(subdivisionNum);</span><br><span class="line">       getResponse = channel.basicGet(queue+<span class="string">"_"</span>+index, autoAck); </span><br><span class="line">       <span class="comment">// 若返回为空，再顺序拉取</span></span><br><span class="line">       <span class="keyword">if</span> (getResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; subdivisionNum;i++) &#123;</span><br><span class="line">               String queueName = queue + <span class="string">"_"</span> + i;</span><br><span class="line">               getResponse = channel.basicGet(queueName, autoAck); </span><br><span class="line">               <span class="keyword">if</span> (getResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> getResponse;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getResponse;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当生产者发送速度大于消费者消费速度时，顺序拉取可能只拉取到第一个物理队列的数据，而其余3个物理队列的数据可能会被长久积压。</p><p>推模式封装需要在 <code>RmqEncapsulation</code> 中添加一个 <code>ConcurrentLinkedDeque&lt;Message&gt;</code> 类型的成员变量 blockingQueue，用来缓存推送的数据以方便消费者消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmqEncapsulation</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> subdivisionNum;<span class="comment">//分片数，表示一个逻辑队列背后的实际队列数</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedDeque&lt;Message&gt; blockingQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RmqEncapsulation</span><span class="params">(<span class="keyword">int</span> subdivisionNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subdivisionNum = subdivisionNum;</span><br><span class="line">        blockingQueue = <span class="keyword">new</span> ConcurrentLinkedDeque&lt;Message&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//省略 newConnection 方法、 getConnection 方法、 closeConnect on 方法的实现</span></span><br><span class="line">    <span class="comment">//省略 exchangeDeclare 方法、 queue Declare 方法、 queueBind 方法的实现</span></span><br><span class="line">    <span class="comment">//省略 basicPublish 方法和 basicGet 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startConsume</span><span class="params">(Channel channel, String queue, <span class="keyword">boolean</span> autoAck, String consumerTag, ConcurrentLinkedDeque&lt;Message&gt; newblockingQueue)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; subdivisionNum;i++)&#123;</span><br><span class="line">String queueName = queue + <span class="string">"_"</span> + i;</span><br><span class="line">channel.basicConsume(queueName, autoAck, consumerTag + i, <span class="keyword">new</span> NewConsumer(channel, newblockingQueue));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicConsume</span><span class="params">(Channel channel, String queue, <span class="keyword">boolean</span> autoAck, String consumerTag, ConcurrentLinkedDeque&lt;Message&gt; newblockingQueue, IMsgCallback iMsgCallback)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">startConsume(channel, queue, autoAck, consumerTag, newblockingQueue);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">Message message = newblockingQueue.peekFirst();</span><br><span class="line"><span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// IMsgCallback包含一个回调函数consumeMsg(Message message)</span></span><br><span class="line">ConsumeStatus consumeStatus = iMsgCallback.consumeMsg(message);</span><br><span class="line"><span class="function">newblock ngQueue <span class="title">removeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(consumeStatus == ConsumeStatus.SUCCESS)</span> </span>&#123;</span><br><span class="line">channel.basicAck(message.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">channel.basicReject(message.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Broker中的数据然后存入blockingQueue中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedDeque&lt;Message&gt; newblockingQueue;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NewConsumer</span><span class="params">(Channel channel, ConcurrentLinkedDeque&lt;Message&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">newblockingQueue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(channel);</span><br><span class="line"><span class="keyword">this</span>.newblockingQueue = newblockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, </span></span></span><br><span class="line"><span class="function"><span class="params">AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">Message message = (Message) getObjectFromBytes(body);</span><br><span class="line">message.setDeliveryTag(envelope.getDeliveryTag());</span><br><span class="line">newblockingQueue.addLast(message);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace(); </span><br><span class="line">       &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推模式使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.basicQos(<span class="number">64</span>);</span><br><span class="line">rmqEncapsulation.basicConsume(channel, <span class="string">"queue"</span>, <span class="keyword">false</span>, <span class="string">"consumer_zzh"</span>, rmqEncapsulation.blockingQueue, <span class="keyword">new</span> IMsgCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConsumeStatus <span class="title">consumeMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">ConsumeStatus consumeStatus = ConsumeStatus.FAIL;</span><br><span class="line"><span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(message);</span><br><span class="line">consumeStatus = ConsumeStatus.SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">           <span class="keyword">return</span> consumeStatus; </span><br><span class="line">       &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>示例省去了很多的功能，局限性很强，比如没有使用 publisher confirm 机制；没有设置 mandatory mandory 参数；只能使用一个 Connection；消息没有使用 Protostuff 进行序列化等。</p><p>发送端根据 Message 的消息序号 msgSeq 对分片个数进行取模运算，之后将对应的消息发送到对应的队列中，这样消息可以均匀且顺序地在每个队列中存储。在消费端为每个队列创建一个消息槽（slot），从队列中读取的消息都存入对应的槽中，发送到下游的消息可以依次从slot0到slot3进行读取。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010159.png" alt></p><h2 id="第四节-镜像队列"><a href="#第四节-镜像队列" class="headerlink" title="第四节 镜像队列"></a>第四节 镜像队列</h2><p>如果RabbitMQ 集群中只有一个Broker节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的 durable 属性也设置为true ，但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗。通过 publisher confirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此， 一般不希望遇到因单点故障导致的服务不可用。</p><p>尽管交换器和绑定关系能够在单点故障问题上幸免于难，但是队列和其上的存储的消息却不行，这是因为队列进程及其内容仅仅维持在单个节点之上，所以一个节点的失效表现为其对应的队列不可用。</p><p>引入镜像队列（Mirror Queue）的机制，可以将队列镜像到集群中的其他Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。在通常的用法中，针对每一个配置镜像的队列（以下简称镜像队列〉都包含一个主节点(master ）和若干个从节点（ slave ），相应的结构可以参考图 9-11 ：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010160.png" alt></p><p>slave 会准确地按照 master 执行命令的顺序进行动作，故 slave 与 master 上维护的状态应该是相同的。如果 master 由于某种原因失效，那么“资历最老”的 slave 会被提升为新的 master 。根据 slave 加入的时间排序，时间最长的 slave 即为“资历最老”。发送到镜像队列的所有消息会被同时发往 master 和所有的 slave 上，如果此时 master 挂掉了，消息还会在 slave 上，这样 slave 提升为 master 的时候消息也不会丢失。除发送消息（Basic.Publish）外的所有动作都只会向 master 发送，然后再由 master 将命令执行的结果广播给各个 slave 。</p><p>如果消费者与slave 建立连接井进行订阅消费，其实质上都是从master 上获取消息，只不过看似是从slave 上消费而己。比如消费者与slave 建立了TCP 连接之后执行一个Basic.Get的操作，那么首先是由slave 将Basic.Get 请求发往master ，再由master 准备好数据返回给slave ，最后由slave 投递给消费者。</p><p>大多的读写压力都落到了master 上，那么这样是否负载会做不到有效的均衡？或者说是否可以像MySQL 一样能够实现master 写而slave 读呢？注意这里master 和slave 是针对队列而言的，而队列可以均匀地散落在集群的各个Broker 节点中以达到负载均衡的目的，因为真正的负载还是针对实际的物理机器而言的，而不是内存中驻留的队列进程。</p><p>在图 9-12 中， 集群中的每个Broker 节点都包含1 个队列的master 和2 个队列的slave, Q1的负载大多都集中在broker1 上， Q2 的负载大多都集中在broker2 上， Q3 的负载大多都集中在broker3 上，只要确保队列的master 节点均匀散落在集群中的各个Broker 节点即可确保很大程度上的负载均衡（每个队列的流量会有不同，因此均匀散落各个队列的master 也无法确保绝对的负载均衡）。至于为什么不像MySQL 一样读写分离， RabbitMQ 从编程逻辑上来说完全可以实现，但是这样得不到更好的收益，即读写分离并不能进一步优化负载，却会增加编码实现的复杂度，增加出错的可能，显得得不偿失。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010161.png" alt></p><p>RabbitMQ 的镜像队列同时支持publisher confirm 和事务两种机制．在事务机制中，只有当前事务在全部镜像中执行之后，客户端才会收到Tx.Commit-Ok 的消息。同样的，在publisherconfirm 机制中， 生产者进行当前消息确认的前提是该消息被全部进行所接收了。</p><p>不同于普通的非镜像队列（参考图9-2 ），镜像队列的backing_queue 比较特殊，其实现并非是rabbit_variable_queue ，它内部包裹了普通backing_queue 进行本地消息消息持久化处理，在此基础上增加了将消息和ack 复制到所有镜像的功能。镜像队列的结构可以参考图9-13, master 的backing_queue 采用的是rabbit_mirror_queue_master ，而slave的backing queue 实现是rabbit_mirror_queue_slave。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010162.png" alt></p><p>所有对 rabbit_mirror_queue_master 的操作都会通过组播GM (Guaranteed Multicast) 的方式同步到各个slave 中。GM 负责消息的广播， rabbit_mirror_queue_slave 负责回调处理，而master 上的回调处理是由coordinator 负责完成的。如前所述，除了 Basic.Publish ，所有的操作都是通过master 来完成的， master 对消息进行处理的同时将消息的处理通过GM 广播给所有的slave , s lave 的GM 收到消息后，通过回调交由 rabbit_mirror queue_slave 进行实际的处理。</p><p>GM 模块实现的是一种可靠的组播通信协议， 该协议能够保证组播消息的原子性，即保证组中活着的节点要么都收到消息要么都收不到，它的实现大致为：将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上：当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。在master 和slave 上的这些GM 形成一个组（gm_group），这个组的信息会记录在Mnesia 中。不同的镜像队列形成不同的组。操作命令从master 对应的GM 发出后，顺着链表传送到所有的节点。由于所有节点组成了一个循环链表， master 对应的GM 最终会收到自己发送的操作命令，这个时候master 就知道该操作命令都同步到了所有的slave 上。</p><p>新节点的加入过程可以参考图9-14 ，整个过程就像在链表中间插入一个节点。注意每当一个节点加入或者重新加入到这个镜像链路中时，之前队列保存的内容会被全部清空。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010163.png" alt></p><p>当slave 挂掉之后，除了与slave 相连的客户端连接全部断开，没有其他影响。当master 挂掉之后，会有以下连锁反应：</p><ol><li>与master 连接的客户端连接全部断开。</li><li>选举最老的slave 作为新的master ，因为最老的s lave 与旧的master 之间的同步状态应该是最好的。如果此时所有slave 处于未同步状态，则未同步的消息会丢失。</li><li>新的master 重新入队所有unack 的消息，因为新的slave 无法区分这些unack 的消息是否己经到达客户端，或者是ack 信息丢失在老的master 链路上，再或者是丢失在老的master 组播ack 消息到所有slave 的链路上，所以出于消息可靠性的考虑，重新入队所有unack 的消息，不过此时客户端可能会有重复消息。</li><li>如果客户端连接着slave ，并且Basic.Consume 消费时指定了x-cancel-on-ha-failover 参数，那么断开之时客户端会收到一个Consumer Cancellation Notification 的通知，消费者客户端中会回调Consumer 接口 handleCancel 方法。如果未指定 x-cancel-on-ha-failover 参数，那么消费者将无法感知master 岩机。</li></ol><p>x-cancel-on-ha-failover 参数的使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Channel channel= ... ;</span><br><span class="line">Consumer consumer= ... ;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap &lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-cancel-on-ha-failover"</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.basicConsume (<span class="string">"my-queue"</span>, <span class="keyword">false</span>, args, consumer);</span><br></pre></td></tr></table></figure><p>镜像队列的配置主要是通过添加相应的Policy 来完成的，<code>rabbitmqctl set_policy [-p vhost] [--priority priority] [ --apply-to apply-to] {name} {pattern} {definition}</code> 命令中的 definition 部分，对于镜像队列的配置来说， definition 中需要包含3个部分： ha-mode 、ha-params 和ha-sync-mode ：</p><ul><li>ha-mode ： 指明镜像队列的模式，有效值为all 、exactly 、nodes ，默认为all 。<ul><li>all 表示在集群中所有的节点上进行镜像；</li><li>exactly 表示在指定个数的节点上进行镜像，节点个数由ha-params 指定；</li><li>nodes 表示在指定节点上进行镜像，节点名称通过ha-params 指定，节点的名称通常类似于rabbit@hostname ，可以通过 <code>rabbitmqctl cluster_status</code> 命令查看到。</li></ul></li><li>ha-params ： 不同的ha-mode 配置中需要用到的参数。</li><li>ha-sync-mode ： 队列中消息的同步方式，有效值为automatic 和manual。</li></ul><p>ha-mode 参数对排他（exclusive）队列并不生效，因为排他队列是连接独占的，当连接断开时队列会自动删除，所以实际上这个参数对排他队列没有任何意义。</p><p>将新节点加入己存在的镜像队列时，默认情况下ha-sync-mode 取值为manual ，镜像队列中的消息不会主动同步到新的s lav e 中，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行其他操作，直到同步完成。当ha-sync-mode 设置为automatic 时，新加入的slave 会默认同步己知的镜像队列。由于同步过程的限制，所以不建议对生产环境中正在使用的队列进行操作。使用<code>rabbitrnqctl list_queues {name} slave_pids synchronised_slave_pids</code> 命令可以查看哪些slaves 已经完成同步。通过手动方式同步一个队列的命令为 <code>rabbitrnqctl sync queue {name}</code> ，同样也可以取消某个队列的同步操作：<code>rabbitrnqctl cancel sync queue {name}</code> 。</p><p>当所有slave 都出现未同步状态，并且ha-promote-on-shutdown 设置为when-synced（默认）时，如果master 因为主动原因停掉，比如通过rabbitrnqctl stop 命令或者优雅关闭操作系统，那么slave 不会接管master ，也就是此时镜像队列不可用；但是如果master 因为被动原因停掉，比如Erlang 虚拟机或者操作系统崩溃，那么slave 会接管master 。这个配置项隐含的价值取向是保证消息可靠不丢失，同时放弃了可用性。如果ha-promote-on-shutdown 设置为always ，那么不论master 因为何种原因停止， slave 都会接管master ，优先保证可用性，不过消息可能会丢失。</p><p>镜像队列中最后一个停止的节点会是master ，启动顺序必须是master 先启动。如果slave先启动，它会有30 秒的等待时间，等待master 的启动，然后加入到集群中。如果30 秒内master没有启动， slave 会自动停止。当所有节点因故（断电等）同时离线时，每个节点都认为自己不是最后一个停止的节点，要恢复镜像队列，可以尝试在30 秒内启动所有节点。</p><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第八章《高阶》，内容来自于《RabbitMQ实战指南》，内容：存储机制，内存及磁盘告警，流量控制，镜像队列等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（七）Federation与Shovel</title>
    <link href="http://linyishui.top/2020101001.html"/>
    <id>http://linyishui.top/2020101001.html</id>
    <published>2020-10-10T08:26:47.000Z</published>
    <updated>2020-10-13T03:21:57.856Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（七）集群"><a href="#RabbitMQ（七）集群" class="headerlink" title="RabbitMQ（七）集群"></a>RabbitMQ（七）集群</h1><h2 id="第一节-Federation"><a href="#第一节-Federation" class="headerlink" title="第一节 Federation"></a>第一节 Federation</h2><p>Federation 插件的设计目标是<strong>使 RabbitMQ 在不同的 Broker 节点之间进行消息传递而无须建立集群</strong>。</p><p>适用场景下：</p><ul><li>Federation 插件能够在不同管理域（可能设置了不同的用户和 vhost ，也可能运行在不同版本的 RabbitMQ Erlang 上）中的 Broker 或者集群之间传递消息。</li><li>Federation 插件基于 AMQP 0-9-1 协议在不同的 Broker 之间进行通信，并设计成能够容忍不稳定的网络连接情况。</li><li>一个 Broker 节点中可以同时存在联邦交换器（或队列）或者本地交换器（或队列），只需要对特定的交换器（或队列）创建 Federation 连接（Federation link ）</li><li>Federation 需要在 Broker 节点之间创建 O(N^2^）个连接（尽管这是最简单的使用方式），这也就意味着 Federation 在使用时更容易扩展。</li></ul><p>Federation 插件可以让多个交换器或者多个队列进行<strong>联邦</strong>。一个联邦交换器（federated exchange）或者一个联邦队列（federated queue）接收上游（upstream）的消息，这里的<strong>上游是指位于其他 Broker 上的交换器或者队列</strong>。</p><ul><li><strong>联邦交换器能够将原本发送给上游交换器（upstream exchange）的消息路由到本地的某个队列中</strong>；</li><li><strong>联邦队列则允许一个本地消费者接收到来自上游队列（upstream queue）的消息</strong>。</li></ul><h3 id="1-1-联邦交换器"><a href="#1-1-联邦交换器" class="headerlink" title="1.1 联邦交换器"></a>1.1 联邦交换器</h3><h4 id="1-1-1-案例：Federation优化服务器通信网络延迟问题"><a href="#1-1-1-案例：Federation优化服务器通信网络延迟问题" class="headerlink" title="1.1.1 案例：Federation优化服务器通信网络延迟问题"></a>1.1.1 案例：Federation优化服务器通信网络延迟问题</h4><p>例如有如下集群：broker1部署于北京，broker2部署于上海，broker3部署于广州，因为物理距离的问题，所以要考虑网络延迟问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010129.png" alt></p><p>有一个广州的业务ClientA需要连接 broker3 ，并向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，<strong>ClientA 可以迅速将消息发送至 exchangeA 中</strong>，就算在开启了 publisher confirm 机制或者事务机制的情况下，也可以迅速收到确认信息。</p><p>此时又有一个在北京的业务 ClientB 需要向 exchangeA 发送消息，那么 <strong>ClientB 与 broker3 之间有很大的网络延迟</strong>， ClientB 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisher confirm 机制或者事务机制的情况下， ClientB 会等待很长的延迟时间来接收 broker3 的确认信息，进而必然造成这条 发送线程的性能降低，甚至造成一定程度上的阻塞。</p><p>那么要<strong>怎么优化业务 ClientB </strong>呢？将业务 ClientB 部署到广州的机房中可以解决这个问题，但是如果 ClientB 调用的另一些服务都部署在北京，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？这里<strong>使用 Federation 插件就可以很好地解决这个问题</strong>。</p><p>如图 8-2 所示，在广州的 broker3 中为交换器 exchangeA（broker3 中的队列 queueA 通过 <code>rkA</code> 与 exchangeA 进行了绑定）与北京的 broker1 之间建立一条单向的 Federation link ：</p><ul><li>此时 Federation 插件会在 broker1 上建立一个同名的交换器 exchangeA（这个名称可以配置，默认同名），</li><li>同时建立一个内部的交换器 <code>exchangeA-&gt;broker3 B</code> ，并通过路由键 <code>rkA</code> 将这两个交换器绑定起来。</li><li>这个交换器 <code>exchangeA-&gt;broker3 B</code> 名字中的 <code>broker3</code> 是集群名，可以通过 <code>rabbitmqctl set_cluster_name {new name}</code> 命令进行修改。</li><li>与此同时 Federation 插件还会在 broker1 上建立一个队列 <code>federation: exchangeA-&gt;broker3 B</code> 并与交换器 <code>exchangeA-&gt;broker3 B</code> 进行绑定。 </li><li>Federation 插件会在队列 <code>federation: exchangeA-&gt;broker3 B</code> 与 broker3 中的交换器 exchangeA 之间建立一条 AMQP 连接来实时地消费队列 <code>federation: exchangeA-&gt;broker3 B</code> 中的数据。</li><li>这些操作都是内部的，对外部业务客户端来说这条 Federation link 建立在 broker1 的 exchangeA 和broker3 的 exchangeA 之间。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010130.png" alt></p><p>因此部署在北京的业务 ClientB 可以连接 broker1（北京）并向 exchangeA 发送消息，这样 ClientB 可以迅速发送完消息并收到确认信息，而之后消息通过 Federation link 转发到 broker3（广州）的交换器 exchangeA 中。最终消息会存入与 exchangeA 绑定的队列 queueA 中，消费者最终可以消费队列 queueA 中的消息。</p><p>经过 Federation link 转发的消息会带有特殊的 headers 性标记。例如向 broker1 中的交换器 exchangeA 发送一条内容为“federation test payload ”的持久化消息，之后可以在 broker3 中的队列 queueA 消费到这条消息：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010131.png" alt></p><h4 id="1-1-2-联邦交换器和普通无明显差异"><a href="#1-1-2-联邦交换器和普通无明显差异" class="headerlink" title="1.1.2 联邦交换器和普通无明显差异"></a>1.1.2 联邦交换器和普通无明显差异</h4><p>Federation 不仅便利于消息生产方，同样也便利于消息消费方。假设某生产者将消息存入 broker1 中的某个队列 queueB，在广州的业务 ClientC 想要消费 queueB 消息，消息的流转及确认必然要忍受较大的网络延迟，内部编码逻辑也会因这一因素变得更加复杂，这样不利于 ClientC 的发展。</p><p>不如将这个消息转发的过程以及内部复杂的编程逻辑交给 Federation 去完成， 而业务方在编码时不必再考虑网络延迟的问题。 Federation 使得生产者和消费者可以异地部署而又让这两方感受不到过多的差异（类似RPC的特性？）。</p><p>上个案例的队列 <code>federation: exchangeA-&gt;broker3 B</code> 是一个相对普通的队列，可以直接通过客户端进行消费。假设此时还有一个客户端 ClientD 通过 <code>Basic.Consume</code> 来消费队列 <code>federation: exchangeA-&gt;broker3 B</code> 的消息，会导致发往 broker1 的 exchangeA 中的消息会有一半被 ClientD 消费掉，另一半会发往 broker3 的 exchangeA 。<strong>如果业务方要求所有发往 broker1 的 exchangeA 中的消息都要转发到 broker3 的 exchangeA 中，要注意不要使队列 <code>federation: exchangeA-&gt;broker3 B</code> 有其他消费者</strong>。</p><p>但也可以注意到，队列 <code>federation: exchangeA-&gt;broker3 B</code> 本身就是普通的队列，天然支持“异地均摊消费”类似的需求。一个 federated exchange 同样可以成为另一个交换器的 upstream exchange 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010132.png" alt></p><p>两方的交换器可以互为 federated exchange 和 upstream exchange 其中 <code>max_hops=1</code> 表示一条消息最多被转发的次数为1。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010133.png" alt></p><p>注意：<strong>对于默认的交换器（每个 vhost 下都会默认创建一个名为“”的交换 器）和内部交换器而言，不能对其使用 Federation 功能</strong>。</p><h4 id="1-1-3-联邦交换器组成复杂的拓扑逻辑部署方式"><a href="#1-1-3-联邦交换器组成复杂的拓扑逻辑部署方式" class="headerlink" title="1.1.3 联邦交换器组成复杂的拓扑逻辑部署方式"></a>1.1.3 联邦交换器组成复杂的拓扑逻辑部署方式</h4><p>“fan-out”的多叉树形式：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010134.png" alt></p><p>“三足鼎立”形式：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010135.png" alt></p><p>环形的拓扑部署：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010136.png" alt></p><h3 id="1-2-联邦队列"><a href="#1-2-联邦队列" class="headerlink" title="1.2 联邦队列"></a>1.2 联邦队列</h3><p>联邦队列（federated queue）：可以在多个 Broker 节点（或者集群）之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列（upstream queue），并从这些上游队列中获取消息以满足本地消费者消费消息的需求。</p><p>图 8-9 演示了两个Broker中的联邦队列（灰色）和非联邦队列（白色）部署：queue1 和 queue2 位于 broker2，配置为联邦队列并设置 broker1 为上游， Federation 插件会在 broker1 创建两个同名队列，并且分别和 broker2 的队列建立单向独立的 Federation link 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010137.png" alt></p><p>当有消费者 ClientA 连接 broker2 并通过 <code>Basic.Consume</code> 消费队列 queue1 （或 queue2 ）中的消息时：</p><ul><li>如果此时队列已有消息堆积就可以直接被消费，且 broker2 的队列不会拉取 broker1 的队列中的消息；</li><li>如果此时队列没有消息，会通过 Federation link 拉取在 broker1 的上游队列中的消息，然后存储到本地，再被 ClientA 消费。</li></ul><p><strong>既可以消费联邦队列，又可以消费上游队列，这种分布式队列的部署可以提高单个队列的容量</strong>。如果上游一端部署的消费者来不及消费上游队列的消息，下游的消费者可以帮其分担消费，有一定的负载均衡的效果。</p><p><strong>与联邦交换器不同的是，一条消息可以在联邦队列间转发无限次</strong>，因为队列可以互为联邦队列：消息会转向有多余消费能力的一方，所以可能会导致消费在队列间来回转发。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010138.png" alt></p><p>如下图，broker2 的队列 queue 没有消息堆积或者消息被消费完之后并不能通过 <code>Basic.Get</code> 来获取 broker1 中队列 queue 消息。因为 <code>Basic.Get</code> 是一个异步的方法，如果要从 broker1 中队列 queue 拉取消息，必须要阻塞等待通过 Federation link 拉取消息存入 broker2 中的队列 queue 之后再消费消息，所以<strong>对于 federated queue 而言只能使用 <code>Basic.Consume</code> 进行消费</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010139.png" alt></p><p><strong>联邦队列不具备传递性</strong>：队列 queue2 作为联邦队列与 queue1 进行联邦，而队列 queue2 又作为队列 queue3 的上游队列，但是这样队列 queue1 和 queue3 之间并没有产生任何联邦的关系。如果队列 queue1 有消息堆积，消费者连接 broker3 消费 queue3 中的消息，无论 queue3 处于何种状态，这些消费者都消费不到 queue1 中的消息， 除非 queue2 有消费者。</p><h3 id="1-3-Federation的使用"><a href="#1-3-Federation的使用" class="headerlink" title="1.3 Federation的使用"></a>1.3 Federation的使用</h3><p>使用Federation前要配置两个内容：</p><ul><li>需要配置一个或多个 upstream，每个 upstream 均定义了到其他节点的 Federation link。这个配置可以通过设置运行时的参数（Runtime Parameter）来完成，也可以通过 federation management 插件来完成。</li><li>需要定义匹配交换器或者队列的一种/多种策略（Policy）。</li></ul><h4 id="1-3-1-启用Federation"><a href="#1-3-1-启用Federation" class="headerlink" title="1.3.1 启用Federation"></a>1.3.1 启用Federation</h4><p>开启Federation功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation </span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>开启Federation的管理插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation_management</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>开启后在RabbitMQ的管理界面中【Admin】右侧会多出两个Tab页：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010140.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010150.png" alt></p><p>注意：<strong>当需要在集群中使用 Federation 功能的时候，集群中所有的节点都应该开启 Federation 插件</strong>。</p><h4 id="1-3-2-相关配置和工具"><a href="#1-3-2-相关配置和工具" class="headerlink" title="1.3.2 相关配置和工具"></a>1.3.2 相关配置和工具</h4><p>有关 Federation upstream 信息全部都保存在 RabbitMQ 的 Mnesia 数据库中，包括用户信息、权限信息、队列信息等。</p><p>在Federation中有三种级别的配置：</p><ul><li>Upstreams：每个 upstream 用于定义与其他 Broker 建立连接的信息。 属于运行时参数。</li><li>Upstream sets：每个 upstream set 用于对一系列使用 Federation 功能的 upstream 行分组。 实际的简单使用场景可忽略，所有upstreambuild添加到一个名叫 <code>all</code> 且隐式定义的 upstream set 中。</li><li>Policies：每一个 Policy 会选定出一组交换器，或者队列，亦或者两者皆有而进行限定，进而作用于一个单独的 upsteam 或者 upstream set 之上。</li></ul><p>Federation 相关的运行时参数和策略都可以通过3种方式进行设置：</p><ul><li>通过 rabbitmqctl 工具；</li><li>通过 RabbitMQ Management 插件提供的 HTTP API 接口；</li><li>通过 rabbitmq federation management 插件提供的 Web 管理界面的方式（最方便且通用）。不过基于 Web 管理界面的方式不能提供全部功能，比如无法针对 upstream set 进行管理。</li></ul><h4 id="1-3-3-使用流程"><a href="#1-3-3-使用流程" class="headerlink" title="1.3.3 使用流程"></a>1.3.3 使用流程</h4><p>以图 8-2 中broker1和broker3为例描述<strong>如何建立联邦交换器</strong>：</p><ul><li><p>第一步，在 broker1 和 broker3 中开启 <code>rabbitmq_federation</code> 插件，最好同时开启 <code>rabbitmq_federation_management</code> 插件。</p></li><li><p>第二步，在 broker3 中定义一个 upstream，有三种设置方式：</p><ul><li><p>第一种是通过 rabbitmqctl 工具的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter federation-upstream f1</span></span><br><span class="line">uri '&#123;"uri":"amqp://root:root123 192.168.0.2:5672","ack-mode":"on-confirm"&#125;'</span><br></pre></td></tr></table></figure></li><li><p>第二种是通过调用 HTTP API 接口的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XPUT -d</span></span><br><span class="line">'&#123;"value":&#123;"uri":"amqp://root:root123 192.168.0.2:5672","ack-mode":"on-confirm"&#125;&#125;' </span><br><span class="line">http://192.168.0.4:15672/api/parameters/federation-upstream/%2f/f1</span><br></pre></td></tr></table></figure></li><li><p>第三种是通过在Web管理界面中添加的方式，【Admin】-&gt;【Federation Upstreams】-&gt;【Add a new upstream】，各个参数的含义：</p><ul><li><p>Name ：定义这个 upstream 的名称，必填项。</p></li><li><p>URI (uri）：定义 upstream 的 AMQP 连接，必填项。本示例中可以填写为 <code>amqp://root:root123 192.168.0.2:5672</code> 。</p></li><li><p>Prefetch count（prefetch count）：定义 Federation 内部缓存的消息条数，即在收到上游消息之后且在发送到下游之前缓存的消息条数。 </p></li><li><p>Reconnect delay（reconnect-delay）: Federation link 由于某种原因断开之后， 需要等待多少秒开始重新建立连接。 </p></li><li><p>Acknowledgement Mode（ack-mode）：定义 Federation link 的消息确认方式。共有3种： </p><ul><li>on-confirm：默认为 on-confirm，表示在接收到下游的确认消息（等待下游的 Basic.Ack ）之后再向上游发送消息确认，这个选项 可以确保网络失败或者 Broker 密机时不会丢失消息，但也是处理速度最慢的选项。</li><li>on-publish：表示消息发送到下游后（并需要等待下游的 <code>Basic.Ack</code> ) 再向上游发送消息确认，这个选项可以确保在网络失败的情况下不会丢失消息，但不能确保 Broker 岩机时不会丢失消息。</li><li>no-acko：表示无须进行消息确认，这个选项处理速度最快，但也最容易丢失消息。  </li></ul></li><li><p>Trust User-ID（trust-user-id）：设定 Federation 是否使用 <code>Validated User-ID</code> 这个功能。如果设置为 false 或者没有设置，那么 Federation 会忽略消息的 user_id 这个属性；如果设置为 true ，则 Federation 只会转发 user_id 为上游任意有效的用户的消息。</p></li><li><p>所谓的 <code>Validated User-ID</code> 功能是指发送消息时验证消息的 user_id 的属性。<code>channel.basicPublish</code> 方法中有个参数是 <code>BasicProperties</code> 有一个属性 user_id ：</p><ul><li><p>设置 user_id 属性为 root ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties();</span><br><span class="line">properties.setUserid(<span class="string">"root"</span>);</span><br><span class="line">channel.basicPublish(<span class="string">"amq.fanout"</span>,<span class="string">""</span>, properties,<span class="string">"test user id"</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>如果在连接 Broker 时所用的用户名为 root，当发送 test user id 这条消息时设置的 user_id 的属性为 guest ，那么这条消息会发送失败，具体报错为 <code>406 PRECONDITION_FAILED - user_id property set to &#39;guest&#39; but authenticated user was &#39;root&#39;</code> ，只有当 user_id 设置为 root 时，这条消息才会发送成功。</p></li></ul></li></ul></li></ul></li><li><p>第三步，定义一个 Policy 用于匹配交换器 exchangeA ，并使用第二步中所创建的 upstream ，有三种设置方式：</p><ul><li><p>第一种是通过 rabbitmqctl 工具的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义所有以exchange开头的交换器作为 federated exchange</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy --apply-to exchanges p1 <span class="string">"^exchange"</span> <span class="string">'&#123;"federation upstream":"f1"&#125;'</span></span></span><br></pre></td></tr></table></figure></li><li><p>第二种是通过调用 HTTP API 接口的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XPUT -d <span class="string">'&#123;"pattern":"^exchange","definition":&#123;"federation-upstream":"f1"&#125;,"apply-to":"exchanges"&#125;'</span> </span></span><br><span class="line">http://192.168.0.4:15672/api/policies/%2F/p1</span><br></pre></td></tr></table></figure></li><li><p>第三种是通过在Web管理界面中添加的方式，【Admin】-&gt;【Federation Upstreams】-&gt;【Add/Update a policy】，创建一个 Federation link ，可以 Web 管理界面中【Admin】-&gt;【Federation Status】-&gt;【Running Links 】查看到相应的链接（或者通过指令 <code>rabbitmqctl eval &#39;rabbit federation_status:status().</code> 查看相应的 Federation link）。</p></li></ul></li></ul><p><strong>如何建立联邦队列</strong>：</p><ul><li><p>首先同样也是定义一个 upstream 。</p></li><li><p>之后定义 Policy 的时候略微有变化，比如使用 rabbitmqctl 工具的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义所有以exchange开头的交换器作为 federated queue</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy --apply-to queues p2 <span class="string">"^queue"</span> <span class="string">'&#123;"federation upstream":"f1"&#125;'</span></span></span><br></pre></td></tr></table></figure></li><li><p>通常情况下，针对每个 upstream 会有一条 Federation link。此Federation link 对应到一个交换器上。例如， 3个交换器与2个upstream分别建立 Federation link 的情况下 ，会有6条连接。</p></li></ul><p>只适用联邦交换器的参数：</p><ul><li>Exchange (exchange）：指定 upstream exchange 的名称，默认情况下和 federated exchange 同名，即图 8-2 中的 exchangeA 。</li><li>Max hops (max-hops）：指定消息被丢弃前在 Federation link 中最大的跳转次数，默认为1。注意即使设置 <code>max-hops</code> 参数为大于1的值，同一条消息也不会在同一个 Broker 中出现2次，但是有可能会在多个节点中被复制。 </li><li>Expires (expires）：指定 Federation link 断开之后，federated queue 所对应的 upstream queue（即图 8-2 中的队列 <code>federation: exchangeA-&gt;broker3</code> ）的超时时间，默认为 none，表示为不删除，单位为 ms 。这个参数相当于设置普通队列的 <code>x-expires</code> 参数。设置这个值可以避免 Federation link 断开之后，生产者一直在向 broker1 中的 exchangeA 发送消息，这些消息又不能被转发到 broker3 中而被消费掉，进而造成 broker1 中有大量的消息堆积。</li><li>Message TTL (message-ttl）：为 federated queue 所对应的 upstream  queue （即 8-2 中的队列 <code>federation: exchangeA-&gt;broker3</code> ）设置，相当于普通队列的 <code>x-message-ttl</code> 参数，默认为 none 。表示消息没有超时时间。 </li><li>HA policy (ha-policy）：为 federated queue 所对应的 upstream queue （即 8-2 中的队列 <code>federation: exchangeA-&gt;broker3</code> ）设置，相当于普通队列的 <code>x-ha-policy</code> 参数，默认为 none，表示队列没有任何 HA。</li></ul><p>只适用联邦队列的参数：</p><ul><li>Queue (queue）：执行 upstream queue 的名称，默认情况下和 federated queue 同名。</li></ul><h2 id="第二节-Shovel"><a href="#第二节-Shovel" class="headerlink" title="第二节 Shovel"></a>第二节 Shovel</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>与 Federation 具备的数据转发功能类似， <strong>Shovel 能够可靠、持续地从一个 Broker 中的队列拉取数据并转发至另一个 Broker 中的交换器</strong>。 </p><p><strong>作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker ，也可以位于不同的 Broker 上</strong>。</p><p>Shovel 可以翻译为“铲子”，是一种比较形象的比喻，这个“铲子”可以将消息从一方“挖到”另一方。 Shovel 的行为就像优秀的客户端应用程序，能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><h4 id="2-1-1-优势"><a href="#2-1-1-优势" class="headerlink" title="2.1.1 优势"></a>2.1.1 优势</h4><p>Shovel 的主要优势在于：</p><ul><li><strong>松耦合</strong>： Shovel 可以移动位于不同管理域中的 Broker（或者集群）上的消息，这些 Broker（或者集群）可以包含不同的用户和 vhost ，也可以使用不同的 RabbitMQ Erlang 版本。 </li><li><strong>支持广域网</strong>：Shovel 插件同样基于 AMQP 协议在 Broker 之间进行通信，被设计成可以容忍时断时续的连通情形，并且能够保证消息的可靠性。</li><li><strong>高度定制</strong>：当 Shovel 成功连接后，可以对其进行配置以执行相关的 AMQP 命令。</li></ul><h3 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h3><p>Shovel 的结构示意图：两个Broker，broker1 中有交换器 exchange1 和队列 queue1 ，且这两者通过路由键 <code>rk1</code> 进行绑定；broker2 中有交换器 exchange2 和队列 queue2 ，且这两者通过路由键 <code>rk2</code> 进行绑定。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010143.png" alt></p><p>在队列 queue1 和交换器 exchange2 之间配置一个 Shovel link，当一条内容为  <code>shovel test payload</code> 的消息从客户端发送至交换器 exchange1 的时候，这条消息会经过图 8-15 中的数据流转最后存储在队列 queue2 中。</p><p>如果在配置 Shovel link 时设置了 <code>add_forward_headers</code> 参数为 true ，则在消费到队列 queue2 中这条消息的时候会有特殊的 headers 属性标记，详细内容可参考图 8-16 ：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010144.png" alt></p><p>通常情况下，使用 Shovel 时配置队列作为源端，交换器作为目的端，但同样可以<strong>将队列配置为目的端</strong>：（虽然看起来像队列queue1直接通过 Shovel link 将消息转发给queue2，但其实还经过了broker2的默认交换器转发）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010145.png" alt></p><p><strong>配置交换器为源端</strong>也可以，虽然看起来像交换器 exchange1 直接通过 Shovel link 将消息转发给 exchange2 ，但其实broker1会创建一个队列并绑定 exchange1 ，消息从 exchange1 过来后先存储在这个队列，然后Shovel再从这个队列中拉取消息并转发到exchange2。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010146.png" alt></p><p>Shovel 可以为源端或者目的端配置多个 Broker 的地址，这样可以使得源端或者目的端的 Broker 失效后能够尝试重连到其他 Broker 之上（随机挑选）。</p><p>可以设置 <code>reconnect_delay</code> 参数以避免由于重连行为导致的网络泛洪， 或者可以在重连失败后直接停止连接。针对源端和目的端的所有配置声明会在重连成功之后被重新发送。</p><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><p>开启Shovel：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel</span></span><br></pre></td></tr></table></figure><p>开启Shovel管理插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel_management</span></span><br></pre></td></tr></table></figure><p>在 RabbitMQ 的管理界面中【Admin】的右侧会多出【Shovel Status 】和【Shovel Management】两个 Tab 页：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010147.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010151.png" alt></p><p>Shovel 既可以部署在源端，也可以部署在目的端。</p><p>有两种方式可以部署 Shovel：</p><ul><li><strong>静态方式</strong>（static）：指在 <code>rabbitmq.config</code> 配置文件中设置。</li><li><strong>动态方式</strong>（dynamic）：指通过 <code>Runtime Parameter</code> 设置。</li></ul><h4 id="2-3-1-静态方式"><a href="#2-3-1-静态方式" class="headerlink" title="2.3.1 静态方式"></a>2.3.1 静态方式</h4><p>在 <code>rabbitmq.config</code> 配置文件中针对 Shovel 插件的配置信息是一种 Erlang 项式，由单条 Shovel 条目构成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;rabbitmq_shovel,</span> <span class="string">[</span> <span class="string">&#123;shovels,</span> <span class="string">[</span> <span class="string">&#123;shovel_name,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;,</span> <span class="string">...</span> <span class="string">]&#125;</span> <span class="string">]&#125;</span></span><br></pre></td></tr></table></figure><p>每一条 Shovel 条目定义了源端与目的端的转发关系，其名称（Shovel name）必须是独一无二的：（其中 sources、destination 和 queue 三项是必需的，其余的都可以默认）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;shovel_name,</span> <span class="string">[</span> <span class="string">&#123;sources,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;destinations,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;queue,</span> <span class="string">queue_name&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;prefetch_count,</span> <span class="string">count&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;ack_mode,</span> <span class="string">a_mode&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;publish_properties,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;publish_fields</span> <span class="string">,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;reconnect_delay,</span> <span class="string">reconn_delay&#125;</span></span><br><span class="line">  <span class="string">]&#125;</span></span><br></pre></td></tr></table></figure><p>详细配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[&#123;rabbitmq_shovel,</span> </span><br><span class="line"><span class="string">[&#123;shovels,</span> </span><br><span class="line"><span class="string">[&#123;hidden</span> <span class="string">shovel,</span></span><br><span class="line"><span class="string">[&#123;sources,</span></span><br><span class="line"><span class="comment"># broker项配置的是URI，定义了用于连接Shovel两端的服务器地址、用户名、密码、vhost和端口号等。</span></span><br><span class="line"><span class="string">[&#123;broker,</span> <span class="string">"amqp://root:root123@192.168.0.2:5672 "</span><span class="string">&#125;,</span></span><br><span class="line">         <span class="comment"># declarations这一项是可选的，declaration_list指定了可以使用的AMQP，声明了队列、交换器和绑定关系。</span></span><br><span class="line"> <span class="string">&#123;declarations,</span></span><br><span class="line"> <span class="string">[</span></span><br><span class="line"> <span class="comment"># 声明了队列，&lt;&lt;告诉Erlang是binary类型字符串</span></span><br><span class="line"> <span class="string">&#123;'queue.declare',</span> <span class="string">[&#123;queue,</span> <span class="string">&lt;&lt;"queue1"&gt;&gt;&#125;,</span> <span class="string">durable]&#125;,</span></span><br><span class="line"> <span class="comment"># 声明了交换器，durable需要赋值时才要加上&#123;&#125;</span></span><br><span class="line"> <span class="string">&#123;'exchange.declare',[</span></span><br><span class="line"> <span class="string">&#123;exchange,</span> <span class="string">&lt;&lt;"exchange1"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;type,</span> <span class="string">&lt;&lt;"direct"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">durable</span></span><br><span class="line"> <span class="string">]</span></span><br><span class="line"> <span class="string">&#125;,</span></span><br><span class="line"> <span class="comment"># 声明了绑定关系</span></span><br><span class="line"> <span class="string">&#123;'queue.bind',</span> <span class="string">[</span></span><br><span class="line"> <span class="string">&#123;exchange,</span> <span class="string">&lt;&lt;"exchange1"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;queue,</span> <span class="string">&lt;&lt;"queue1"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;routing_key,</span> <span class="string">&lt;&lt;"rk1"&gt;&gt;&#125;</span></span><br><span class="line"> <span class="string">&#125;]&#125;]&#125;,</span></span><br><span class="line"> <span class="string">&#123;destinations,</span></span><br><span class="line"> <span class="string">[&#123;broker，"amqp://root:root123@192.168.0.2:5672"&#125;,</span></span><br><span class="line"> <span class="string">&#123;declarations,</span></span><br><span class="line"> <span class="string">[</span></span><br><span class="line"> <span class="string">&#123;'queue.declare',</span> <span class="string">[&#123;queue,</span> <span class="string">&lt;&lt;"queue2"&gt;&gt;&#125;,</span> <span class="string">durable]&#125;,</span></span><br><span class="line"> <span class="string">&#123;'exchange.declare',[</span></span><br><span class="line"> <span class="string">&#123;exchange,</span> <span class="string">&lt;&lt;"exchange2"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;type,</span> <span class="string">&lt;&lt;"direct"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">durable</span></span><br><span class="line"> <span class="string">]</span></span><br><span class="line"> <span class="string">&#125;,</span></span><br><span class="line"> <span class="string">&#123;'queue.bind',</span> <span class="string">[</span></span><br><span class="line"> <span class="string">&#123;exchange,</span> <span class="string">&lt;&lt;"exchange2"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;queue,</span> <span class="string">&lt;&lt;"queue2"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;routing_key,</span> <span class="string">&lt;&lt;"rk2"&gt;&gt;&#125;</span></span><br><span class="line"> <span class="string">&#125;]&#125;]&#125;,</span></span><br><span class="line"> <span class="comment"># 表示源端服务器上的队列名称，&lt;&lt;&gt;&gt;则表示匿名队列</span></span><br><span class="line"> <span class="string">&#123;queue,</span> <span class="string">&lt;&lt;"queue1"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="comment"># 表示在完成转发消息时的确认模式</span></span><br><span class="line"> <span class="comment"># no_ack表示无须任何消息确认行为</span></span><br><span class="line"> <span class="comment"># no_publish表示Shovel会把每一条消息发送到目的端之后再向源端发送消息确认</span></span><br><span class="line"> <span class="comment"># no_confirm表示Shovel会使用publisher confirm机制，在收到目的端的消息确认之后再向源端发送消息确认</span></span><br><span class="line"> <span class="string">&#123;ack_mode,</span> <span class="string">no_ack&#125;,</span></span><br><span class="line"> <span class="comment"># 表示Shovel内部缓存的消息条数，Shovel的内部缓存是源端服务器和目的端服务器之间的中间缓存部分</span></span><br><span class="line"> <span class="string">&#123;prefetch_count,</span> <span class="number">64</span><span class="string">&#125;,</span></span><br><span class="line"> <span class="comment"># 指消息发往目的端时需要特别设置的属性列表</span></span><br><span class="line"> <span class="string">&#123;publish_properties,</span> <span class="string">[&#123;delivery_mode,</span> <span class="number">2</span><span class="string">&#125;]&#125;,</span></span><br><span class="line"> <span class="comment"># 设置为true，会在转发的消息内添加x-shovelled的header属性</span></span><br><span class="line"> <span class="string">&#123;add_forward_headers,</span> <span class="literal">true</span><span class="string">&#125;,</span></span><br><span class="line"> <span class="comment"># 定义了消息需要发往目的端服务器上的交换器以及标记在消息上的路由键。如果交换器和路由键没有定义，则Shovel会从原始消息上复制这些被忽略的设置。</span></span><br><span class="line"> <span class="string">&#123;publish_fields,</span> <span class="string">[&#123;exchange,</span> <span class="string">&lt;&lt;"exchange2"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;routing_key,</span> <span class="string">&lt;&lt;"rk2"&gt;&gt;&#125;]&#125;,</span></span><br><span class="line"> <span class="comment"># 指定在Shovel link失效情况下，重新建立连接前需要等待的时间。如果设置为0，则不会进行重连动作，即Shovel会在首次连接失效时停止工作。默认为5秒。</span></span><br><span class="line"> <span class="string">&#123;reconnect_delay,</span> <span class="number">5</span><span class="string">&#125;</span> <span class="string">J</span></span><br><span class="line"><span class="string">&#125;]</span> </span><br><span class="line"><span class="string">&#125;]</span></span><br><span class="line"><span class="string">&#125;].</span></span><br></pre></td></tr></table></figure><p>如果 sources 或者 destinations 是 RabbitMQ 集群，那么就使用 brokers ，并在其后用多个URI字符串以 <code>[]</code> 的形式包裹起来。</p><h4 id="2-3-2-动态方式"><a href="#2-3-2-动态方式" class="headerlink" title="2.3.2 动态方式"></a>2.3.2 动态方式</h4><p>Federation upstream 类似 Shovel 动态部署方式的配置信息会被保存 RabbitMQ Mnesia 数据库中，包括权限信息、用户信息和队列信息等内容。</p><p>每一个Shovel link都由一个相应的Parameter定义，Parameter设置方式：</p><ul><li><p>第一种，通过 rabbitmqctl 工具的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter shovel hidden_shovel \</span></span><br><span class="line">'&#123;"src-uri":"amqp://root:root123@192.168.0.2:5672",</span><br><span class="line">"src-queue":"queue1",</span><br><span class="line">"dest-uri":"amqp://root:rootl23@192.168.0.3:5672","src- exchange-key":"rk2",</span><br><span class="line">"prefetch-count":64,"reconnect-delay":5,"publish-properties":[],</span><br><span class="line">"add-forward-headers":true,"ack-mode":"on-confirm"&#125;'</span><br></pre></td></tr></table></figure></li><li><p>第二种，通过调用 HTTP API 接口的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XPUT d</span></span><br><span class="line">'&#123;"value":&#123;"src-uri":"amqp://root:root123@192.168.0.2:5672","src-queue":"queue1",</span><br><span class="line">"dest-uri":"amqp://root:rootl23@192.168.0.3:5672","src-exchange-key":"rk2",</span><br><span class="line">"prefetch-count":64, "reconnect-delay":5,"publish-properties":[],</span><br><span class="line">"add-forward-headers":true,"ack_mode":"confirm"&#125;&#125;'</span><br><span class="line">http://192.168.0.2:15672/api/parameters/shovel/%2f/hidden_shovel</span><br></pre></td></tr></table></figure></li><li><p>第三种，通过在Web管理界面中添加的方式，【Admin】-&gt;【Shovel Management】-&gt;【Add a new shovel】。</p><ul><li>在创建了一个 Shovel link 之后，可以在【Admin】-&gt;【Shovel Status】 中查看状态信息。</li><li>也可以通过 <code>rabbitmqctl eval &#39;rabbit shovel_status:status().</code> 查看相应的 Shovel link。</li></ul></li></ul><h3 id="2-4-案例：消息堆积的治理"><a href="#2-4-案例：消息堆积的治理" class="headerlink" title="2.4 案例：消息堆积的治理"></a>2.4 案例：消息堆积的治理</h3><p><strong>消息堆积</strong>是在使用消息中间件过程中遇到的最正常不过的事情。消息堆积是一把双刃剑，适量的堆积可以有削峰、缓存之用 ，但是如果堆积过于严重，就可能影响到其他队列的使用，导致整体服务质量的下降。</p><p>对于一台普通的服务器来说，在一个队列中堆积1万至10万条消息，丝毫不会影响什么。但是如果这个队列中堆积超过1千万乃至一亿条消息时，可能会引起一些严 重的问题，比如引起内存或者磁盘告警而造成所有 Connection 阻塞。</p><p>解决方案：</p><ul><li>消息堆积严重时，可以选择清空队列，或者采用空消费程序丢弃掉部分消息。不过对于重要的数据而言，丢弃消息的方案并无用武之地。</li><li>另一种方案是增加下游消费者的消费能力，这个思路可以通过后期优化代码逻辑或者增加消费者的实例数来实现。但是后期的代码优化在面临紧急情况时总归是“远水解不了近渴”，并且有些业务场景也井非可以简单地通过增加消费实例而得以增强消费能力。</li><li>当某个队列中的消息堆积严重时，比如超过某个设定的阑值，就可以通过 Shovel 将队列中的消息移交给另一个集群。</li></ul><p>几种情形：</p><ul><li>情形1：当检测到当前运行集群 cluster1 中的队列 queue1 中有严重消息堆积，比如通过 <code>/api/queues/vhost/name</code> 接口获取到队列的消息个数（messages）超过2千万或者消息占用大小（messages_bytes）超过 10GB 时，就启用 shovel1 将队列 queue1 中的消息转发至备份集群 cluster2 中的队列 queue2。</li><li>情形2：紧随情形1，当检测到队列 queue1 中的消息个数低于1百万或者消息占用大小低于1GB 时就停止 shovel1，然后让原本队列 queue1 中的消费者慢慢处理剩余的堆积。</li><li>情形3：当检测到队列 queue1 中的消息个数低于 10 万或者消息占用大小低于100MB时， 就开启 shovel2 将队列 queue2 中暂存的消息返还给队列 queue1。</li><li>情形4：紧随情形3，当检测到队列 queue1 中的消息个数超过1百万或者消息占用大小高于 1GB 时就将 shovel2 停掉。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010149.png" alt></p><p>如此，队列 queue1 就拥有了队列 queue2 这个“保镖”为它保驾护航。这里是一备一的情形，如果需要一备多，可以采用镜像队列或者引入 Federation。</p><h2 id="第三节-Federation-Shovel-与集群的区别和联系"><a href="#第三节-Federation-Shovel-与集群的区别和联系" class="headerlink" title="第三节 Federation/Shovel 与集群的区别和联系"></a>第三节 Federation/Shovel 与集群的区别和联系</h2><p>集群、Federation、Shovel这三种部署方式：</p><p>集群是最为通用的一种方式。集群将多个 Broker 节点连接起来组成逻辑上独立的单个 Broker 。集群内部借助 Erlang 进行消息传输，所以集群中的每个节点的 Erlang cookie 务必要保持一致。同时，集群内部的网络必须是可靠的，RabbitMQ Erlang 的版本也必须一致。虚拟主机、交换器、用户、权限等都会自动备份到集群中的各个节点。队列可能部署单个节点或被镜像到多个节点中。连接到任意节点的客户端能够看到集群中所有的队列，即使该队列不在所连接的节点之上。通常使用集群的部署方式来提高可靠性和吞吐量，不过集群只能部署在局域网内。</p><p>Federation，可以翻译为“联邦”。 Federation 可以通过 AMQP 协议（可配置 SSL）让原本发送到某个 Broker （或集群）中的交换器（或队列）上的消息能够转发到另一个 Broker （或集群）中的交换器（或队列）上，两方的交换器（或队列）看起来是以一种“联邦”的形式在运作。当然必须要确保这些“联邦”的交换器或者队列都具备合适的用户和权限。</p><p>联邦交换器（federated exchange）通过单向点对点的连接（Federation link）形式进行通信。默认情况下，消息只会由 Federation 连接转发一次，可以允许有复杂的路由拓扑来提高转发次数。在 Federation 连接上，消息可能不会被转发，如果消息到达了联邦交换器之后路由不到合适的队列，那么它也不会被再次转发到原来的地方（这里指上游交换器，即 upstream exchange）可以通过 Federation 连接广域网中的各个 RabbitMQ 服务器来生产和消费消息。联邦队列（federated queue）也是通过单向点对点连接进行通信的，消息可以根据具体的配置消费者的状态在联邦队列中游离任意次数。</p><p>通过 Shovel 来连接各个 RabbitMQ Broker ，概念上 Federation 的情形类似，不过 Shovel 工作在更低一层。鉴于 Federation 从一个交换器中转发消息到另一个交换器（如果必要可以确认消息是否被转发）， Shovel 只是简单地从某个 Broker 上的队列中消费消息，然后转发消息到 Broker 上的交换器而已。Shovel 也可以在单独的一台服务器上去转发消息，比如将队列中的数据移动到另一个队列中。如果想获得比 Federation 更多的控制，可以在广域网中使用 Shovel 连接各个 RabbitMQ Broker 来生产或消费消息。</p><table><thead><tr><th>Federation/Shovel</th><th>集群</th></tr></thead><tbody><tr><td>各个 Broke 节点之间逻缉分离</td><td>逻辑上是个 Broker 节点</td></tr><tr><td>各个 Broker 节点之间可以运行不同版本的 Erlang 和 RabbitMQ</td><td>各个 Broker 节点之间必须运行相同版本的 Erlang 和 RabbitMQ</td></tr><tr><td>各个 Broker 节点之间可以在广域网中相连，当然必须要授予适当的用户和权限</td><td>各个 Broker 节点之间必须在可信赖的局域网中相连，通过 Erlang 内部节点传递消息，但节点问需要有相同的 Erlang cookie</td></tr><tr><td>各个 Broker 节点之间能以任何拓扑逻辑部署，连接可以是单向的或者是双向的</td><td>所有 Broker 节点都双向连续所有其他节点</td></tr><tr><td>从 CAP 理论中选择可用性和分区耐受性，即 AP</td><td>从 CAP 理论中选择致性和可用性，CA</td></tr><tr><td>一个 Broker 中的交换器可以是 Federation 生成的或者是本地的</td><td>集群中所有 Broker 节点中的交换器都是一样的，要么全有要么全无</td></tr><tr><td>客户端所能看到它所连接的 Broker 节点上的队列</td><td>客户端连接到集群中的任何 Broker 节点都可以看到所有 的队列</td></tr></tbody></table><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第七章《Federation与Shovel》，内容来自于《RabbitMQ实战指南》，内容：RabbitMQ有3种方式实现分布式部署（集群、Federation和Shovel）可以任意组合实现拓扑部署。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（六）运维</title>
    <link href="http://linyishui.top/2020100801.html"/>
    <id>http://linyishui.top/2020100801.html</id>
    <published>2020-10-08T15:34:48.000Z</published>
    <updated>2020-10-10T08:16:55.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（六）运维"><a href="#RabbitMQ（六）运维" class="headerlink" title="RabbitMQ（六）运维"></a>RabbitMQ（六）运维</h1><h2 id="第一节-集群搭建"><a href="#第一节-集群搭建" class="headerlink" title="第一节 集群搭建"></a>第一节 集群搭建</h2><p>单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键。</p><p>RabbitMQ 集群也不能保证消息的万无一失，即将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式。当集群中一个 RabbitMQ 节点崩溃时，该节点上的所有队列中的消息也会丢失。 RabbitMQ 集群中的所有节点都会备份所有的元数据信息， 包括以下内容：</p><ul><li><strong>队列元数据</strong>：队列的名称及属性； </li><li><strong>交换器</strong>：交换器的名称及属性： </li><li><strong>绑定关系元数据</strong>：交换器与队列或者交换器与交换器之间的绑定关系； </li><li><strong>vhost 元数据</strong>：为 vhost 内的队列、交换器和绑定提供命名空间及安全属性。</li></ul><p>但是不会备份消息（当然通过特殊的配置比如镜像队列可以解决这个问题）。基于存储空间和性能的考虑，在 RabbitMQ 集群中创建队列，<strong>集群只会在单个节点而不是在所有节点上创建队列的进程并包含完整的队列信息</strong>（元数据、状态、内容）。这样只有队列的宿主节点，即所有者节点知道队列的所有信息，所有其他非所有者节点只知道队列的元数据和指向该队列存在的那个节点的指针。因此当集群节点崩溃时，该节点的队列进程和关联的绑定都会消失。附加在那些队列上的消费者也会丢失其所订阅的信息，井且任何匹配该队列绑定信息的新消息也都会消失。</p><p>不同于队列那样拥有自己的进程，交换器其实只是一个名称和绑定列表。当消息发布到交换器时，实际上是由所连接的信道将消息上的路由键同交换器的绑定列表进行比较，然后再路由消息。当创建一个新的交换器时， RabbitMQ 所要做的就是<strong>将绑定列表添加到集群中的所有节点上</strong>。这样，每个节点上的每条信道都可以访问到新的交换器了。</p><p>创建集群的过程可以看作向集群中添加节点的过程。</p><h3 id="1-1-多机多节点配置"><a href="#1-1-多机多节点配置" class="headerlink" title="1.1 多机多节点配置"></a>1.1 多机多节点配置</h3><p>多机多节点主要是指在每台机器中部署一个 RabbitMQ 服务节点，进而由多台机器组成一个 RabbitMQ 集群。</p><p>假设这里一共有三台物理主机，均己正确地安装了 RabbitMQ ，且主机名分别为 node1、node2、node3。RabbitMQ 集群对延迟非常敏感，应当只在本地局域网内使用 。<strong>在广域网中不应该使用集群，而应该使用 Federation 或者 Shovel 来代替</strong>。</p><h4 id="1-1-1-配置流程"><a href="#1-1-1-配置流程" class="headerlink" title="1.1.1 配置流程"></a>1.1.1 配置流程</h4><ul><li><p>第一步，配置各个节点的 hosts 文件，让各个节点都能互相识别对方的存在。</p><ul><li><p>比如在 Linux 系统中可以编辑 <code>/etc/hosts</code> 文件，在其上添加地址与节点名称的映射信息：</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.2</span> <span class="selector-tag">node1</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.3</span> <span class="selector-tag">node2</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.4</span> <span class="selector-tag">node3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>第二步，编辑 RabbitMQ 的 cookie 文件，以确保各个节点的 cookie 文件使用的是同一个值。</p><ul><li><p>可以读取 node1 节点的 cookie 值，然后将其复制到 node2、node3 节点中。</p></li><li><p>cookie 文件默认路径为：<code>/var/lib/rabbitmq/.erlang.cookie</code> 或者 <code>$HOME/.erlang.cookie</code> 。</p></li><li><p>集群中的 RabbitMQ 节点需要通过交换密钥令牌以获得相互认证。</p></li><li><p>如果节点的密钥令牌不一致，那么在配置节点时就会有如下的报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster rabbit@node1</span></span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1</span><br><span class="line">Error: unable to connect to nodes [rabbit@node1]: nodedown </span><br><span class="line"></span><br><span class="line">DIAGNOSTICS </span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">attempted to contact: [rabbit@node1] </span><br><span class="line"></span><br><span class="line">rabbit@node1:</span><br><span class="line">* connected to epmd (port 4369) on node1</span><br><span class="line">* epmd reports node rabbit runn ng on port 25672</span><br><span class="line">* TCP connection succeeded but Erlang distribution failed </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意此处</span></span><br><span class="line">* Authentication failed (rejected by the remote node), please check the Erlang cookie </span><br><span class="line"></span><br><span class="line">current node details:</span><br><span class="line">- node name: 'rabbitmq-cli-53@node2'</span><br><span class="line">- home dir: /root</span><br><span class="line">- cookie hash: kLtTY75JJGZnZpQF7CqnYg==</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第三步，配置集群。</p><ul><li><p>配置集群有三种方式 ：</p><ul><li>通过 rabbitmqctl 工具配置；</li><li>通过 rabbitmq.config 配置文件配置；</li><li>通过 rabbitmq-autocluster 插件配置。</li></ul></li><li><p>示例通过 rabbitmqctl 工具配置：</p><ul><li><p>首先启动 node1、node2、node3 这几个节点的 RabbitMQ 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node2 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node3 ~]# rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li><li><p>开启后这3个节点目前都是以独立节点存在的单个集群，查看各个节点的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl cluster_status </span><br><span class="line">[root@node2 ~]# rabbitmqctl cluster_status </span><br><span class="line">[root@node3 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li><li><p>接下来为了将这3个节点组成一个集群，需要以 node1 节点为基准，将 node2 和 node3 节点加入 node1 节点的集群中。这3个节点是平等的，如果想调换彼此的加入顺序也未尝不可。</p><ol><li><p>首先将 node2 节点加入 node1 节点的集群中：（此时再通过 <code>rabbitmqctl cluster_status</code> 可以看到两个节点的信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabb t@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl join cluster rabbit@node1</span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1</span><br><span class="line">[root@node2 ~]# rabbitmqctl start_ app</span><br><span class="line">Starting node rabbit@node2</span><br></pre></td></tr></table></figure></li><li><p>再将 node3 节点也加入 node1 节点所在的集群中，步骤同上。</p></li></ol></li></ul></li></ul></li></ul><h4 id="1-1-2-节点关闭的几种情况"><a href="#1-1-2-节点关闭的几种情况" class="headerlink" title="1.1.2 节点关闭的几种情况"></a>1.1.2 节点关闭的几种情况</h4><ul><li><p>如果集群中某个节点关闭了，会使集群处于怎样的状态？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭 node2 节点</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 node1 节点查看集群状态时，会发现 running_nodes 已没有 node2</span></span><br><span class="line">[root@node1 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li><li><p>如果关闭了集群中的所有节点，则<strong>需要确保在启动的时候最后关闭的那个节点是第一个启动的</strong>。</p><ul><li>如果第一个启动的不是最后关闭的节点，那么这个节点会等待最后关闭的节点启动。这个等待时间是 30 秒，如果没有等到，那么这个先启动的节点也会失败。</li><li>在最新的版本中会有重试机制，默认重试 10 次 30 秒以等待最后关闭的节点启动。</li></ul></li><li><p>如果最后一个关闭的节点最终由于某些异常而无法启动，则可以通过 <code>rabbitmqctl forget_cluster_node</code> 命令来将此节点剔出当前集群。</p></li><li><p>如果集群中的所有节点由于某些非正常因素，比如断电而关闭，那么集群中的节点都会认为还有其他节点在它后面关闭，此时需要调用 <code>rabbitmqctl force_boot</code> 命令来启动一个节点，之后集群才能正常启动。</p></li></ul><h3 id="1-2-集群节点类型"><a href="#1-2-集群节点类型" class="headerlink" title="1.2 集群节点类型"></a>1.2 集群节点类型</h3><h4 id="1-2-1-两种节点类型"><a href="#1-2-1-两种节点类型" class="headerlink" title="1.2.1 两种节点类型"></a>1.2.1 两种节点类型</h4><p>使用 <code>rabbitmqctl cluster_status</code> 命令来查看集群状态时会有 <code>{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]</code> 这一项信息，其中的 disc 标注了 RabbitMQ 点的类型。</p><p>不论是单一节点还是集群节点，有两种类型：</p><ul><li><strong>内存节点</strong>：将所有的队列、 交换器、绑定关系、用户、权限和 vhost 的元数据定义都存储在内存中；</li><li><strong>磁盘节点</strong>：存放到磁盘中。所以单节点集群只能是磁盘节点，否则重启后会丢失系统的配置信息。</li></ul><h4 id="1-2-2-如何指定或切换节点类型"><a href="#1-2-2-如何指定或切换节点类型" class="headerlink" title="1.2.2 如何指定或切换节点类型"></a>1.2.2 如何指定或切换节点类型</h4><p>将节点指定为内存节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 node2 节点加入 node1 节点的时候可以指定 node2 节点的类型为内存节点</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl join_cluster rabbit@node1 --ram</span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以在集群搭建好以后再通过 rabbitmqctl change_cluster_node_type &#123;disc, ram&#125;命令切换类型</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl stop_app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl change cluster node type disc</span><br><span class="line">Turning rabbit@node2 into a disc node</span><br><span class="line">[root@node2 ~]# rabbitmqctl start app</span><br><span class="line">Starting node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><h4 id="1-2-3-如何选择内存还是磁盘节点"><a href="#1-2-3-如何选择内存还是磁盘节点" class="headerlink" title="1.2.3 如何选择内存还是磁盘节点"></a>1.2.3 如何选择内存还是磁盘节点</h4><p>在集群中创建队列、交换器或者绑定关系的时候，这些操作直到所有集群节点都成功提交元数据变更后才会返回。对内存节点来说，这意味着将变更写入内存；而对于磁盘节点来说，这意味着昂贵的磁盘写入操作。内存节点可以提供出色的性能，磁盘节点能够保证集群配置信息的高可靠性，如何在这两者之间进行抉择呢？</p><ul><li>首先集群中至少有一个磁盘节点；</li><li>新增或删除节点时需要将变更通知到至少一个磁盘节点；</li><li>如果只有一个磁盘节点，而且它刚好崩溃了，集群可以继续发送或者接收消息，但是不能执行创建队列、交换器、绑定关系、用户，以及更改权限、添加或删除集群节点的操作了。<strong>即唯一磁盘节点崩溃时，集群可以继续运行，但不能变更</strong>。</li><li>在内存节点重启后，它们会连接到预先配置的磁盘节点，下载当前集群元数据的副本。当在集群中添加内存节点时，确保告知其所有的磁盘节点（内存节点唯一存储到磁盘的元数据信 息是集群中磁盘节点的地址）。只要内存节点可以找到至少一个磁盘节点，那么它就能在重启后重新加入集群中。</li><li>除了使用RPC功能时，大多数的操作就是生产或者消费消息。为了确保集群信息的可靠性，或者在不确定使用磁盘节点或者内存节点的时候，<strong>建议全部使用磁盘节点</strong>。</li></ul><h3 id="1-3-剔除单个节点"><a href="#1-3-剔除单个节点" class="headerlink" title="1.3 剔除单个节点"></a>1.3 剔除单个节点</h3><h4 id="1-3-1-如何从集群中删除一个节点"><a href="#1-3-1-如何从集群中删除一个节点" class="headerlink" title="1.3.1 如何从集群中删除一个节点"></a>1.3.1 如何从集群中删除一个节点</h4><p>两种方案：</p><ul><li><p>第一种：适合节点不再运行RabbitMQ的情况。</p><ul><li>首先在 node2 节点上执行 <code>rabbitmqctl stop_app</code> 或者 <code>rabbitmqctl stop</code> 命令来关闭 RabbitMQ 服务；</li><li>然后再在 node1 节点或者 node3 节点上执行 <code>rabbitmqctl forget_cluster_node rabbit@node2</code> （可以添加 <code>-offline</code> 即使非运行状态也可以生效）命令将 node2 节点剔除出去。</li></ul></li><li><p>第二种：只是简单的将节点从集群中移出，变成单一节点。</p><ul><li><p>在 node2 上执行 <code>rabbitmqctl reset</code> 命令。此命令将清空节点的状态，并将其恢复到空白状态，也会和集群中的磁盘节点进行通信，告诉它们该节点正在离开集群。</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl start app</span><br><span class="line">Starting node rabbit@node2</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-4-集群节点的升级"><a href="#1-4-集群节点的升级" class="headerlink" title="1.4 集群节点的升级"></a>1.4 集群节点的升级</h3><h4 id="1-4-1-独立节点的升级"><a href="#1-4-1-独立节点的升级" class="headerlink" title="1.4.1 独立节点的升级"></a>1.4.1 独立节点的升级</h4><p>只须先关闭原来的服务，然后解压新的版本再运行即可。不过要确保原节点的 Mnesia 中的数据不被变更，且新节点中的 Mnesia 路径的指向要与原节点中的相同。</p><h4 id="1-4-2-集群节点的升级步骤"><a href="#1-4-2-集群节点的升级步骤" class="headerlink" title="1.4.2 集群节点的升级步骤"></a>1.4.2 集群节点的升级步骤</h4><p>单个节点的升级步骤：</p><ol><li>关闭所有节点的服务，注意采用 <code>rabbitmqctl stop</code> 命令关闭。</li><li>保存各个节点的 Mnesia 数据。</li><li>解压新版本的 RabbitMQ 到指定的目录。</li><li>指定新版本的 Mnesia 路径为步骤2中保存的 Mnesia 数据路径。</li><li>启动新版本的服务，注意先重启原版本中最后关闭的那个节点。</li></ol><p>步骤4和步骤5可以一起操作，比如执行 <code>RABBITMQ_MNESIA_BASE=/opt/mnesia rabbitmq-server-detached</code> 命令，其中 <code>/opt/mnesia</code> 为原版本保存 Mnesia 数据的路径。</p><p><strong>在对不同版本升级的过程中，最好先测试两个版本互通的可能性，然后再在线上环境中实地操作。</strong></p><p>如果原集群上的配置和数据都可以舍弃，则可以删除原版本的 RabbitMQ ，然后再重新安装配置即可：如果配置和数据不可丢弃 ，则按照上面所述保存元数据，之后再关闭所有生产者，并等待消费者消费完队列中的所有数据，紧接着关闭所有消费者，然后重新安装 RabbitMQ 重建元数据等。</p><p>也可以利用集群迁移直接转为新的集群。</p><h3 id="1-5-单机多节点配置"><a href="#1-5-单机多节点配置" class="headerlink" title="1.5 单机多节点配置"></a>1.5 单机多节点配置</h3><p>有时候不得不在单台物理机器上去创建一个多 RabbitMQ 服务节点的集群，需要<strong>确保每个节点都有独立的名称、数据存储位置、端口号（包括插件的端口号）等</strong>。</p><p>我们在主机名称为 node1 的机器上创建一个由 rabbit1@node1、rabbit2@node 1 和 rabbit3@node1 这3个节点组成 RabbitMQ 集群。</p><ul><li><p>为每个 RabbitMQ 服务节点设置不同的端口号和节点名称来启动相应的服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5672 RABBITMQ NODENAME=rabbit1</span><br><span class="line">rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5673 RABBITMQ NODENAME=rabbit2</span><br><span class="line">rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5674 RABBITMQ NODENAME=rabbit3</span><br><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li><li><p>在启动 rabbit1@node1 节点的服务之后，继续启动 rabbit2@node1 和 rabbit@node1 服务节点会遇到启动失败的情况。</p><ul><li><p>这种情况大多数是由于配置发生了冲突而造成后面的服务节点启动失 败，需要进一步确认是否开启了某些功能，比如 RabbitMQ Management 插件。</p></li><li><p>如果开启了 RabbitMQ Management 插件，就需要为每个服务节点配置一个对应插件端口号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5672 RABBITMQ NODENAME=rabbit1 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [&#123;port,15672)]" rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5673 RABBITMQ NODENAME=rabbit2 RABBITMQ_SERVER_START_ARGS="- rabbitmq_management listener [&#123;port, 15673&#125;]" rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5674 RABBITMQ NODENAME=rabbit3 RABBITMQ_SERVER_START_ARGS="- rabbitmq_management listener [&#123;port,15674&#125;]" rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动各节点服务之后，将 rabbit2@node1 节点加入 rabbit1@node1 集群之中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~] # rabbitmqctl -n rabbit2@node1 stop app</span><br><span class="line">Stopping rabbit application on node rabbit2@node1</span><br><span class="line">[root@node1 ~J # rabbitmqctl -n rabbit2@node1 reset</span><br><span class="line">Resetting node rabbit2@node1</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 join_cluster rabbit1@node1</span><br><span class="line">Clustering node rabbit2@node1 with rabbit1@node1</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 start_app</span><br><span class="line">Starting node rabbit2@node1</span><br></pre></td></tr></table></figure></li><li><p>执行相似的操作将 rabbit3@node1 也加入进来，并通过 <code>rabbitmqctl cluster_status</code> 命令来查看各个服务节点的集群状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit1@node1 cluster_status</span><br><span class="line">Cluster status of de rabbit1@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit3@node1, rabbit2@node1, rabbit1@node1]&#125;,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125;,</span><br><span class="line">&#123;alarms, [&#123;rabbit3@node1, []&#125;, &#123;rabbit2@node1, []&#125;, &#123;rabbit1@node1, []&#125;]&#125;]</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 cluster_status</span><br><span class="line">Cluster status of node rabbit2@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit3@node1, rabbit1@node1, rabbit2@node1]&#125;,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125; ,</span><br><span class="line">&#123;alarms, [&#123;rabbit3@node1, []&#125; , &#123;rabbit1@node1, []&#125;, &#123;rabbit2@node1, []&#125;]&#125;]</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit3@node1 cluster_status</span><br><span class="line">Cluster status of node rabbit3@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125; ,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125; ,</span><br><span class="line">&#123;alarms, [&#123;rabbit1@node1, []&#125;, &#123;rabbit2@node1, []&#125;, &#123;rabbit3@node1, []&#125;]&#125;]</span><br></pre></td></tr></table></figure></li></ul><p>RabbitMQ 单机多节点配置大多用于实验性论证，生产环境还是选用多机多节点的集群。</p><h2 id="第二节-查看服务日志"><a href="#第二节-查看服务日志" class="headerlink" title="第二节 查看服务日志"></a>第二节 查看服务日志</h2><p>RabbitMQ 日志中包含各种类型的事件，比如<strong>连接尝试、服务启动、插件安装及解析请求时的错误等</strong>。</p><p>RabbitMQ 的日志默认存放在 <code>$RABBITMQ_HOME/var/log/rabbitmq</code> 文件夹内。在这个文件夹内 RabbitMQ 会创建两个日志文件：</p><ul><li><code>RABBITMQ_NODENAME-sasl.log</code> ：SASL (System Application Support Libraries，系统应用程序支持库）是库的集合，作为 Erlang-OTP 发行版的一部分。提供了一系列标准，其中之一是日志记录格式。<strong>当 RabbitMQ 记录 Erlang 相关信息时，它会将日志写入文件<code>RABBITMQ_NODENAME-sasl.log</code> </strong>。</li><li><code>RABBITMQ_NODENAME.log</code> ：RabbitMQ 服务日志指的就是这个文件。</li></ul><h3 id="2-1-启动RabbitMQ服务"><a href="#2-1-启动RabbitMQ服务" class="headerlink" title="2.1 启动RabbitMQ服务"></a>2.1 启动RabbitMQ服务</h3><ul><li>使用 <code>rabbitmq-server -detached</code> 命令启动RabbitMQ服务，顺带会启动 Erlang 虚拟机和RabbitMQ应用服务。</li><li>使用 <code>rabbitmqctl start_app</code> 用来启动 RabbitMQ 应用服务（启动成功的前提是 Erlang 虚拟机运转正常）。</li><li>如果使用 <code>rabbitmqctl stop_app</code> 命令关闭的 RabbitMQ 应用服务，那么在使用 <code>rabbitmqctl start_app</code> 命令开启 bbitMQ 应用服务时的启动日志和 <code>rabbitmq-server</code> 的启动日志相同。</li></ul><p>相关服务日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RabbitMQ 版本号、Erlang 的版本号</span></span><br><span class="line"><span class="string">Starting</span> <span class="string">RabbitMQ</span> <span class="number">3.6</span><span class="number">.2</span> <span class="string">on</span> <span class="string">Erlang</span> <span class="number">19.1</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2007</span><span class="bullet">-2016</span> <span class="string">Pivotal</span> <span class="string">Software,</span> <span class="string">Inc</span> <span class="string">.</span></span><br><span class="line"><span class="string">Licensed</span> <span class="string">under</span> <span class="string">the</span> <span class="string">MPL.</span> <span class="string">See</span> <span class="attr">http://www.rabbitmq.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO REPORT 和 WARNING REPORT 表示日志级别</span></span><br><span class="line"><span class="comment"># RabbitMQ 服务节点名称、cookie 的 hash 值、配置文件地址</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:08</span> <span class="string">===</span></span><br><span class="line"><span class="string">node</span> <span class="string">:</span> <span class="string">rabbit@node1</span></span><br><span class="line"><span class="string">home</span> <span class="string">dir</span> <span class="string">:</span> <span class="string">/root</span></span><br><span class="line"><span class="string">config</span> <span class="string">file(s)</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/etc/rabbitmq/rabbitmq.config</span> <span class="string">(not</span> <span class="string">found)</span></span><br><span class="line"><span class="string">cookie</span> <span class="string">hash</span> <span class="string">:</span> <span class="string">VCwbL3S9/ydrGgVsrLjVkA==</span></span><br><span class="line"><span class="string">log</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/var/log/rabbitmq/rabbit@node1.log</span></span><br><span class="line"><span class="string">sasl</span> <span class="string">log</span> <span class="string">:</span> <span class="string">pt/rabbitmq</span> <span class="string">/var/</span> <span class="string">log/rabbitmq/rabbit@node1-sasl.log</span></span><br><span class="line"><span class="string">database</span> <span class="string">dir</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存限制</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span> </span><br><span class="line"><span class="string">Memory</span> <span class="string">limit</span> <span class="string">set</span> <span class="string">to</span> <span class="number">3148</span><span class="string">MB</span> <span class="string">of</span> <span class="number">7872</span><span class="string">MB</span> <span class="string">total.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 磁盘限制</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Disk</span> <span class="string">free</span> <span class="string">limit</span> <span class="string">set</span> <span class="string">to</span> <span class="number">50</span><span class="string">MB</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Limiting</span> <span class="string">to</span> <span class="string">approx</span> <span class="number">924</span> <span class="string">file</span> <span class="string">handles</span> <span class="string">(829</span> <span class="string">sockets)</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">FHC</span> <span class="string">read</span> <span class="attr">buffering:</span> <span class="string">OFF</span></span><br><span class="line"><span class="string">FHC</span> <span class="string">write</span> <span class="attr">buffering:</span> <span class="string">ON</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Database</span> <span class="string">rectory</span> <span class="string">at</span> <span class="string">/opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node1</span> <span class="string">is</span></span><br><span class="line"><span class="string">empty.</span> <span class="string">Initialising</span> <span class="string">from</span> <span class="string">scratch...</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Priority</span> <span class="string">queues</span> <span class="string">enabled,</span> <span class="string">real</span> <span class="string">BQ</span> <span class="string">is</span> <span class="string">rabbit_variable_queue</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Adding</span> <span class="string">vhost</span> <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认账户 guest 的创建及权限配置</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">user</span> <span class="string">'guest'</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Setting</span> <span class="string">user</span> <span class="string">tags</span> <span class="string">for</span> <span class="string">user</span> <span class="string">'guest'</span> <span class="string">to</span> <span class="string">[admistrator]</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Setting</span> <span class="string">permissions</span> <span class="string">for</span> <span class="string">'guest'</span> <span class="string">in</span> <span class="string">to</span> <span class="string">'.*'</span><span class="string">,</span> <span class="string">'.*'</span><span class="string">,</span> <span class="string">'.*'</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="attr">transient:</span> <span class="string">using</span> <span class="string">rabbit_msg_store_ets_index</span> <span class="string">to</span> <span class="string">provide</span> <span class="string">index</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="string">persistent</span> <span class="string">using</span> <span class="string">rabbit_msg_store_ets_index</span> <span class="string">to</span> <span class="string">provide</span> <span class="string">index</span></span><br><span class="line"></span><br><span class="line"><span class="string">=WARNING</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="attr">persistent:</span> <span class="string">rebuilding</span> <span class="string">indices</span> <span class="string">from</span> <span class="string">scratch</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">started</span> <span class="string">TCP</span> <span class="string">Listener</span> <span class="string">on</span> <span class="string">[::]:5672</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="bullet">-Oct-2017</span> <span class="string">::10:52</span> <span class="string">:</span> <span class="number">10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Server</span> <span class="string">startup</span> <span class="string">complete;</span> <span class="number">0</span> <span class="string">plugins</span> <span class="string">started.</span></span><br></pre></td></tr></table></figure><p>日志级别：（通过 <code>rabbitmq.config</code> 配置文件中 <code>log_levels</code> 参数来设置，默认为 <code>[{connection, info}]</code> ）</p><ul><li>none</li><li>error</li><li>warning</li><li>info</li><li>debug</li></ul><h3 id="2-2-关闭RabbitMQ服务"><a href="#2-2-关闭RabbitMQ服务" class="headerlink" title="2.2 关闭RabbitMQ服务"></a>2.2 关闭RabbitMQ服务</h3><p>如果使用 <code>rabbitmqctl stop</code> 命令，会将 Erlang 虚拟机一同关闭，而 <code>rabbitmqctl stop_app</code> 只关闭 RabbitMQ 应用服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Stopping</span> <span class="string">RabbitMQ</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">stopped</span> <span class="string">TCP</span> <span class="string">Listener</span> <span class="string">on</span> <span class="string">[::]:5672</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Stopped</span> <span class="string">RabbitMQ</span> <span class="string">application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用 rabbitmqctl stop 来进行关闭操作，则会多出下面的日志信息，即关闭 Erlang 虚拟机。</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Halting</span> <span class="string">Erlang</span> <span class="string">VM</span></span><br></pre></td></tr></table></figure><h3 id="2-3-建立集群"><a href="#2-3-建立集群" class="headerlink" title="2.3 建立集群"></a>2.3 建立集群</h3><p>举例将节点 rabbit@node2 和 rabbit@node1 组成一个集群：</p><ul><li><p>首先在 rabbit@node2 中执行 <code>rabbitmq-server -detached</code> 开启 Erlang 虚拟机和 RabbitMQ 应用服务，之后再执行 <code>rabbitmqctl stop_app</code> 来关闭 RabbitMQ 应用服务，之后需要重置节点 rabbit@node2 中的数据 <code>rabbitmqctl reset</code> ，在 rabbit@node2 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:25:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Resetting</span> <span class="string">Rabbit</span></span><br></pre></td></tr></table></figure></li><li><p>在 rabbit@node2 节点上执行 <code>rabbitmqctl join_clcuster rabbit@node1</code> ，将其加 rabbit@node1 中以组成一个集群，在 rabbit@node2 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:30:46</span> <span class="string">===</span></span><br><span class="line"><span class="string">Clustering</span> <span class="string">with</span> <span class="string">[rabbit@node1]</span> <span class="string">as</span> <span class="string">disc</span> <span class="string">node</span></span><br></pre></td></tr></table></figure></li><li><p>同时在 rabbit@node1 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:30:56</span> <span class="string">===</span></span><br><span class="line"><span class="string">node</span> <span class="string">rabbit@node2</span> <span class="string">up</span></span><br></pre></td></tr></table></figure></li><li><p>如果此时在 rabbit@node2 节点上执行 <code>rabbitmqctl stop_app</code> 的动作，那么在 <code>rabbit@node1</code> 节点中会有如下信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">rabbit</span> <span class="string">on</span> <span class="string">node</span> <span class="string">rabbit@node2</span> <span class="string">down</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Keep</span> <span class="string">rabbit@node2</span> <span class="attr">listeners:</span> <span class="string">the</span> <span class="string">node</span> <span class="string">is</span> <span class="string">already</span> <span class="string">back</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h3><p>客户端与 RabbitMQ 建立连接：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">14</span><span class="bullet">-0</span><span class="attr">ct-2017:</span> <span class="string">:16:24:55</span> <span class="string">===</span></span><br><span class="line"><span class="string">accepting</span> <span class="string">AMQP</span> <span class="string">connection</span> <span class="string">&lt;0.5865.0&gt;</span> <span class="string">(192.168.0.9:61601</span> <span class="bullet">-&gt;</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span><span class="string">:5672)</span></span><br></pre></td></tr></table></figure><p>客户端强制中断连接时：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=WARNING</span> <span class="string">REPORT====</span> <span class="number">14</span><span class="attr">-Jul-2017:</span> <span class="string">:16:36:57</span> <span class="string">===</span></span><br><span class="line"><span class="string">closing</span> <span class="string">AMQP</span> <span class="string">connection</span> <span class="string">&lt;0.5909.0&gt;</span> <span class="string">(192.168.0.9:61629</span> <span class="bullet">-&gt;</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span><span class="string">:5672)</span></span><br><span class="line"><span class="string">connection_closed_abruptly</span></span><br></pre></td></tr></table></figure><h3 id="2-5-日常积累各种操作对应日志格式"><a href="#2-5-日常积累各种操作对应日志格式" class="headerlink" title="2.5 日常积累各种操作对应日志格式"></a>2.5 日常积累各种操作对应日志格式</h3><p>可以通过尝试各种的操作以收集相应的服务日志，之后组成一个知识集，这个知识集不单单指一个日志列表，需要通过后期的强化训练掌握其规律，让这个知识集了然于心 。在真正遇到异常故障的时候可以通过查看服务日志来迅速定位问题，之后再采取相应的措施以解决问题。</p><p>比如在执行任何 RabbitMQ 操作之前，都会打开一个新的窗口运 <code>tail -f $RABBITMQ_HOME/var/log/rabbitmq/rabbit@$HOSTNAME.log -n 200</code> 命令来实时查看相应操作所对应的服务日志是什么，久而久之即可在脑海中建立一个相对完备的“知识集”。</p><h3 id="2-6-日志文件管理"><a href="#2-6-日志文件管理" class="headerlink" title="2.6 日志文件管理"></a>2.6 日志文件管理</h3><p>RabbitMQ 中可以通过 <code>rabbitmqctl rotate_logs {suffix}</code> 命令来轮换日志，比如手工切换当前的日志：<code>rabbitmqctl rotate_logs.bak</code> ，之后可以看到在日志目录下会建立新的日志文件，并且将老的日志文件以添加 <code>.bak</code> 后缀的方式进行区分保存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 rabbitmq]# ls - al</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 22646 Jul 23 00:50 rabbit@node1.log.bak</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1-sasl.log</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1-sasl.log.bak</span><br></pre></td></tr></table></figure><p>也可以执行一个定时任务，比如使用 <code>Linux crontab</code> ，以当前日期为后缀，每天执行一次切换日志的任务，这样在后面需要查阅日志的时候可以根据日期快速定位到相应的日志文件。</p><p>RabbitMQ 还可以通过程序化的方式来查看相应的日志， 默认会创建一些交换器， 其中 <code>amq.rabbitmq.log</code> 就是用来收集 RabbitMQ 日志的，集群中所有的服务日志都会发往这个交换器中。这个交换器的类型为 topic ，可以收集如前面所说的 debug、info、warning、error 4个级别的日志。</p><p>首先确认是否创建 <code>amq.rabbitmq.log</code> 交换器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl list_exchanges</span><br><span class="line">Listing exchanges for vhost / ...</span><br><span class="line">name    type</span><br><span class="line">exchange_demo   direct</span><br><span class="line">amq.fanout      fanout</span><br><span class="line">amq.rabbitmq.trace      topic</span><br><span class="line">myAe    fanout</span><br><span class="line">amq.headers     headers</span><br><span class="line">amq.topic       topic</span><br><span class="line">amq.direct      direct</span><br><span class="line">normalExchange  direct</span><br><span class="line">        direct</span><br><span class="line">amq.match       headers</span><br></pre></td></tr></table></figure><p>配置文件 <code>vi /etc/rabbitmq/rabbitmq.conf</code> （没有就新建）开启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.exchange = true</span><br></pre></td></tr></table></figure><p>重启下RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmqctl stop</span><br><span class="line">Stopping and halting node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmq-server restart</span><br><span class="line">Configuring logger redirection</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##      RabbitMQ 3.8.8</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Copyright (c) 2007-2020 VMware, Inc. or its affiliates.</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#####  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Licensed under the MPL 2.0. Website: https://rabbitmq.com</span></span></span><br><span class="line"></span><br><span class="line">  Doc guides: https://rabbitmq.com/documentation.html</span><br><span class="line">  Support:    https://rabbitmq.com/contact.html</span><br><span class="line">  Tutorials:  https://rabbitmq.com/getstarted.html</span><br><span class="line">  Monitoring: https://rabbitmq.com/monitoring.html</span><br><span class="line"></span><br><span class="line">  Logs: /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">        /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ_upgrade.log</span><br><span class="line"></span><br><span class="line">  Config file(s): /etc/rabbitmq/rabbitmq.conf</span><br><span class="line"></span><br><span class="line">  Starting broker... completed with 4 plugins.</span><br></pre></td></tr></table></figure><p>可以看到交换器已启动：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010117.png" alt></p><p>分别创建四个日志队列，并采用相应的路由键来绑定 <code>amq.rabbitmq.log</code> 交换器，如果想用一个日志队列收集所有级别日志可以使用 <code>#</code> 这个路由键。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010116.png" alt></p><p>编写代码打印对应级别日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建连接</span></span><br><span class="line">            Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">            &#125;;</span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">            factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">            factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">            Connection connection = factory.newConnection(addresses);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建对应日志级别的信道</span></span><br><span class="line">            Channel channelDebug = connection.createChannel();</span><br><span class="line">            Channel channelInfo = connection.createChannel();</span><br><span class="line">            Channel channelWarn = connection.createChannel();</span><br><span class="line">            Channel channelError = connection.createChannel();</span><br><span class="line">            channelDebug.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelInfo.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelWarn.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelError.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelDebug.basicConsume(<span class="string">"queue.debug"</span>, <span class="keyword">false</span>, <span class="string">"DEBUG"</span>, <span class="keyword">new</span> ConsumerThread(channelDebug));</span><br><span class="line">            channelInfo.basicConsume(<span class="string">"queue.info"</span>, <span class="keyword">false</span>, <span class="string">"INFO "</span>, <span class="keyword">new</span> ConsumerThread(channelInfo)) ;</span><br><span class="line">            channelWarn.basicConsume(<span class="string">"queue.warning"</span>, <span class="keyword">false</span>, <span class="string">"WARNING"</span>, <span class="keyword">new</span> ConsumerThread(channelWarn)) ;</span><br><span class="line">            channelError.basicConsume(<span class="string">"queue.error"</span>, <span class="keyword">false</span>, <span class="string">"ERROR"</span>, <span class="keyword">new</span> ConsumerThread(channelError)) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String log = <span class="keyword">new</span> String(body);</span><br><span class="line">            System.out.println(<span class="string">"="</span> + consumerTag + <span class="string">" REPORT====\n"</span> + log);</span><br><span class="line">            <span class="comment">//对日志进行处理</span></span><br><span class="line">            getChannel().basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">INFO</span>  REPORT====</span><br><span class="line"><span class="number">2020</span>-<span class="number">10</span>-<span class="number">09</span> <span class="symbol">16:00</span><span class="symbol">:19</span>.<span class="number">709</span> [<span class="built_in">info</span>] &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; accepting AMQP connection &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; (<span class="number">115.236</span>.<span class="number">91.15</span><span class="symbol">:64187</span> -&gt; <span class="number">172.17</span>.<span class="number">48.148</span><span class="symbol">:5672</span>)</span><br><span class="line"></span><br><span class="line">=<span class="built_in">INFO</span>  REPORT====</span><br><span class="line"><span class="number">2020</span>-<span class="number">10</span>-<span class="number">09</span> <span class="symbol">16:00</span><span class="symbol">:19</span>.<span class="number">978</span> [<span class="built_in">info</span>] &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; connection &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; (<span class="number">115.236</span>.<span class="number">91.15</span><span class="symbol">:64187</span> -&gt; <span class="number">172.17</span>.<span class="number">48.148</span><span class="symbol">:5672</span>)<span class="symbol">:</span> user 'root' authenticated <span class="built_in">and</span> granted access to vhost '/'</span><br></pre></td></tr></table></figure><p>要注意的是各个节点对应级别的日志是交错在一起的。可以通过检索日志的 running_partitioned_network 关键字来及时地探测到<strong>网络分区</strong>的发生，之后可以迅速采取措施以保证集群服务的鲁棒性。当然对于日志的监控处理也可以采用第3方工具实现，如 Logstash 等。</p><h2 id="第三节-单点故障恢复"><a href="#第三节-单点故障恢复" class="headerlink" title="第三节 单点故障恢复"></a>第三节 单点故障恢复</h2><h3 id="3-1-什么是单点故障"><a href="#3-1-什么是单点故障" class="headerlink" title="3.1 什么是单点故障"></a>3.1 什么是单点故障</h3><p>对于集群层面来说，经常遇到的是单点故障。所谓的单点故障是指集群中单个节点发生了故障，有可能会引起集群服务不可用、数据丢失等异常。配置数据节点冗余（镜像队列）可以有效地防止由于单点故障而降低整个集群的可用性、可靠性。</p><h3 id="3-2-四种常见的单点故障"><a href="#3-2-四种常见的单点故障" class="headerlink" title="3.2 四种常见的单点故障"></a>3.2 四种常见的单点故障</h3><p>单节点故障包括：</p><ul><li><strong>机器硬件故障</strong>：包括机器硬盘、内存、主板等故障造成的死机，无法从软件角度来恢复。<ul><li>此时需要在集群中的其他节点中执行 <code>rabbitmqctl forget_cluster_node {nodename}</code> 命令来将故障节点剔除，其中 nodename 表示故障机器节点名称。</li><li>如果之前有客户端连接到此故障节点上，在故障发生时会有异常报出，此时需要将故障节点的IP地址从连接列表里删除，并让客户端重新与集群中的节点建立连接，以恢复整个应用。</li></ul></li><li><strong>机器掉电</strong>：需要等待电源接通之后重启机器。<ul><li>此时这个机器节点上的 RabbitMQ 处于 stop 状态，但是此时不要盲目重启服务，否则可能会引起<strong>网络分区</strong>。</li><li>此时需要在集群中的其他节点中执行 <code>rabbitmqctl forget_cluster_node {nodename}</code> 命令来将故障节点剔除。</li><li>然后删除当前故障机器的 RabbitMQ 中的 Mnesia 数据（相当于重置）。</li><li>然后再重启 RabbitMQ 服务。</li><li>最后再将此节点作为一个新的节点加入到当前集群中。</li></ul></li><li><strong>网络异常</strong>：网线松动或者网卡损坏都会引起网络故障的发生。<ul><li>对于网线松动，无论是彻底断开，还是“藕断丝连”，只要它不降速， RabbitMQ 集群就没有任何影响。但是为了保险起见，建议先关闭故障机器的 RabbitMQ 进程，然后对网线进行更换或者修复操作，之后再考虑是否重新开启 RabbitMQ 进程。</li><li>网卡故障极易引起<strong>网络分区</strong>的发生，如果监控到网卡故障而网络分区尚未发生时，理应第一时间关闭此机器节点上的 RabbitMQ 进程，在网卡修复之前不建议再次开启。 如果己经发生了网络分区，可以参考 10.5 节进行手动恢复网络分区。</li></ul></li><li><strong>服务进程异常</strong>：如 RabbitMQ 进程非预期终止，需要预先思考相关风险是否在可控范围之内。如果风险不可控，可以选择抛弃这个节点。一般情况下，重新启动 RabbitMQ 服务进程即可。</li></ul><h2 id="第四节-集群迁移"><a href="#第四节-集群迁移" class="headerlink" title="第四节 集群迁移"></a>第四节 集群迁移</h2><p>扩容比较简单，一般向集群中加入新的集群节点即可，不过新的机器节点中是没有队列创建的，只有后面新创建的队列才有可能进入这个新的节点中。或者如果集群配置了镜像队列，可以通过系列操作将原先队列“漂移”到这个新的节点中，具体可以参考第 10.5 节。</p><p>迁移同样可以解决扩容的问题，将旧的集群中的数据（包括元数据信息和消息）迁移到新的且容量更大的集群中即可。 RabbitMQ 中的集群迁移更多的是<strong>用来解决集群故障不可短时间内修复而将所有的数据、客户端连接等迁移到新的集群中，以确保服务的可用性</strong>。相比于单点故障而言，集群故障的危害性就大得多，比如 IDC 整体停电、网线被挖断等。这时候就需要通过集群迁移重新建立起一个新的集群。</p><h3 id="4-1-准备阶段-元数据重建"><a href="#4-1-准备阶段-元数据重建" class="headerlink" title="4.1 准备阶段-元数据重建"></a>4.1 准备阶段-元数据重建</h3><p>元数据重建是指在新的集群中创建原集群的队列交换器、绑定关系、 host、用户、权限 Parameter 等数据信息。元数据重建是集群迁移前的准备工作，之后才可将原集群中的消息及客户端连接迁移过来。</p><p>实现方式：</p><ul><li>手工创建：</li><li>客户端创建：</li></ul><p>元数据的整理十分繁琐，需要如Web管理工具的辅助：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010118.png" alt></p><p>可以在原集群上点击 <code>Download broker definitions</code> 按钮下载集群的元数据信息文件，此文件是 JSON 文件，比如叫 metadata.json 。</p><p>之后再在新集群上的 Web 管理界面中点击 <code>Upload broker definitions</code> 按钮上传 metadata.json 文件。</p><p>如果导入成功则会跳转到成功页面，这样就迅速在新集群中创建了元数据信息。如果新集群有数据与 metadata.json 中的数据相冲突，对于交换器、队列及绑定关系这类非可变对象而言会报错，而对于其他可变对象如 Parameter、用户等则会被覆盖，没有发生冲突的则不受影响。如果过程中发生错误，则导入过程终止，导致 metadata.json 中只有部分数据加载成功。</p><p>三个问题：</p><ol><li><p>如果原集群突发故障，又或者开启 RabbitMQ Management 插件的那个节点机器故障不可修复，就无法获取原集群的元数据 metadata.json。</p><ul><li>这个问题很好解决，采取一个通用的备份任务，在元数据有变更或者达到某个存储周期时将最新的 metadata.json 备份至另一处安全的地方。这样在遇 到需要集群迁移时，可以获取到最新的元数据。</li></ul></li><li><p>如果新旧集群的 RabbitMQ 版本不一致时会出现异常情况。一般情况下 RabbitMQ 是能够做到向下兼容的，在高版本的 RabbitMQ 中可以上传低版本的元数据文件。然而如果在低版本中上传高版本的元数据文件就没有那么顺利了。</p><ul><li>比如 3.5.7 版本与 3.6.10 版本的加密算法不一样，就会出现用户登录失败的情况，可以简单地在 Shell 控制台输入变更密码的方式来解决这个问题：<code>rabbitmqctl change_password {username} {new_password}</code> 。</li><li>如果还是不能成功上传元数据，我们要先清楚对于用户、策略、权限这种元数据来说内容相对固定，且内容较少，手工重建的代价较小。集群中元数据最多且最复杂的要数队列、交换器和绑定这三项的内容，如果采用人工重建的方式代价太大，重建元数据的意义其实就在于重建队列、交换器及绑定这三项的相关信息。</li><li>可以将 3.6.10 的元数据从 queues 这一项前面的内容，包括 rabbit_version、users、vhosts、permissions、parameters、global_parameters 和 policies 这几项内容复制后替换 3.5.7 版本中的 queues 这一项前面的所有内容，然后再保存。之后将修改并保存过后的 3.5.7 版本的元数据 JSON 文件上传到新集群 3.6.10 版本的 Web 管理界面中，至此就完成了集群的元数据重建。</li></ul></li><li><p>第三个问题就是如果采用上面的方法将元数据在新集群上重建，则所有的队列都只会落到同一个集群节点上，而其他节点处于空置状态，这样所有的压力将会集中到这单台节点之上。</p><p>两种解决方案，都是通过程序或脚本的形式在新集群上建立元数据：</p><ul><li><p>通过 HTTP API 接口创建相应的数据：</p><ul><li><p>引入gson：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>三个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> Boolean durable;</span><br><span class="line"><span class="keyword">private</span> Boolean auto_delete;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchange</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="keyword">private</span> Boolean durable;</span><br><span class="line"><span class="keyword">private</span> Boolean auto_delete;</span><br><span class="line"><span class="keyword">private</span> Boolean internal;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binding</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String source;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> String destination;</span><br><span class="line"><span class="keyword">private</span> String destination_type;</span><br><span class="line"><span class="keyword">private</span> String routing_key;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String , Object&gt; arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析原集群的 metadata.json 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Queue&gt; queueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Exchange&gt; exchangeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Binding&gt; bindingList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseJson</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JsonObject json = (JsonObject) parser.parse(<span class="keyword">new</span></span><br><span class="line">                    FileReader(filename));</span><br><span class="line">            JsonArray jsonQueueArray = json.get(<span class="string">"queues"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonQueueArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonQueueArray.get(i).getAsJsonObject();</span><br><span class="line">                Queue queue = parseQueue(subObject);</span><br><span class="line">                queueList.add(queue);</span><br><span class="line">            &#125;</span><br><span class="line">            JsonArray jsonExchangeArray =</span><br><span class="line">                    json.get(<span class="string">"exchanges"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonExchangeArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonExchangeArray.get(i).getAsJsonObject();</span><br><span class="line">                Exchange exchange = parseExchange(subObject);</span><br><span class="line">                exchangeList.add(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">            JsonArray jsonBindingArray = json.get(<span class="string">"bindings"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonBindingArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonBindingArray.get(i).getAsJsonObject();</span><br><span class="line">                Binding binding = parseBinding(subObject);</span><br><span class="line">                bindingList.add(binding);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析队列信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Queue <span class="title">parseQueue</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.setName(subObject.get(<span class="string">"name"</span>).getAsString());</span><br><span class="line">        queue.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        queue.setDurable(subObject.get(<span class="string">"durable"</span>).getAsBoolean());</span><br><span class="line">        queue.setAuto_delete(subObject.get(<span class="string">"auto_delete"</span>).getAsBoolean());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        queue.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析交换器信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Exchange <span class="title">parseExchange</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略，具体参考 parseQueue 方法进行推演</span></span><br><span class="line">        Exchange exchange = <span class="keyword">new</span> Exchange();</span><br><span class="line">        exchange.setName(subObject.get(<span class="string">"name"</span>).getAsString());</span><br><span class="line">        exchange.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        exchange.setType(subObject.get(<span class="string">"type"</span>).getAsString());</span><br><span class="line">        exchange.setDurable(subObject.get(<span class="string">"durable"</span>).getAsBoolean());</span><br><span class="line">        exchange.setInternal(subObject.get(<span class="string">"internal"</span>).getAsBoolean());</span><br><span class="line">        exchange.setAuto_delete(subObject.get(<span class="string">"auto_delete"</span>).getAsBoolean());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        exchange.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析绑定信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Binding <span class="title">parseBinding</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        Binding binding = <span class="keyword">new</span> Binding();</span><br><span class="line">        binding.setSource(subObject.get(<span class="string">"source"</span>).getAsString());</span><br><span class="line">        binding.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        binding.setDestination(subObject.get(<span class="string">"destination"</span>).getAsString());</span><br><span class="line">        binding.setDestination_type(subObject.get(<span class="string">"destination_type"</span>).getAsString());</span><br><span class="line">        binding.setRouting_key(subObject.get(<span class="string">"routing_key"</span>).getAsString());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        binding.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> binding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析参数 arguments 项内容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">parseArguments</span><span class="params">(JsonObject argsObject)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;Map.Entry&lt;String, JsonElement&gt;&gt; entrySet = argsObject.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, JsonElement&gt; mapEntry : entrySet) &#123;</span><br><span class="line">            map.put(mapEntry.getKey(), mapEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在解析完队列、交换器及绑定关系之后，只需要遍历 queueList、exchangeList、bindingList ，然后调用 HTTP API 创建相应的数据即可。随机挑选一个节点并明确指明了 node 节点这一参数来创建队列，如此便可解决集群内部队列分布不均匀的问题。当然首先需要确定新集群中节点名称的列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ip = <span class="string">"192.168.0.2"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String username = <span class="string">"root "</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String password = <span class="string">"rootl23"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; nodeList =<span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"rabbit@node1"</span>);</span><br><span class="line">    add(<span class="string">"rabbit@node2"</span>);</span><br><span class="line">    add(<span class="string">"rabbit@node3"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createQueues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queueList.size(); i++) &#123;</span><br><span class="line">            Queue queue = queueList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = String.format(<span class="string">"http://%s:l5672/api/queues/%s/%s"</span>, ip,</span><br><span class="line">                    encode(queue.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                    encode(queue.getName(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"auto_delete"</span>, queue.getAuto_delete());</span><br><span class="line">            map.put(<span class="string">"durable"</span>, queue.getDurable());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, queue.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建交换器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createExchanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exchangeList.size(); i++) &#123;</span><br><span class="line">            Exchange exchange = exchangeList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = String.format(<span class="string">"http://%s:l5672/api/exchanges/%s/%s"</span>, ip,</span><br><span class="line">                    encode(exchange.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                    encode(exchange.getName(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"auto_delete"</span>, exchange.getAuto_delete());</span><br><span class="line">            map.put(<span class="string">"durable"</span>, exchange.getDurable());</span><br><span class="line">            map.put(<span class="string">"type"</span>, exchange.getType());</span><br><span class="line">            map.put(<span class="string">"internal"</span>, exchange.getInternal());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, exchange.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建绑定关系</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略, 具体参考 createQueues 方法进行推演, 关键信息如 url</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bindingList.size(); i++) &#123;</span><br><span class="line">            Binding binding = bindingList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//绑定有两种 交换器与队列, 交换器与交换器</span></span><br><span class="line">            <span class="keyword">if</span> (binding.getDestination_type().equals(<span class="string">"queue"</span>) )&#123;</span><br><span class="line">                url = String.format(<span class="string">"http://%s:l5672/api//bindings/%s/e/%s/q/%s"</span>, ip,</span><br><span class="line">                        encode(binding.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getSource(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getDestination(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                url = String.format(<span class="string">"http://%s:l5672/api//bindings/%s/e/%s/e/%s"</span>, ip,</span><br><span class="line">                        encode(binding.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getSource (), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getDestination(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"destination"</span>, binding.getDestination());</span><br><span class="line">            map.put(<span class="string">"destination_type"</span>, binding.getDestination_type());</span><br><span class="line">            map.put(<span class="string">"routing_key"</span>, binding.getRouting_key());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, binding.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// http post</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">httpPut</span><span class="params">(String url, String data, String username, String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">            <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">    PutMethod putMethod = <span class="keyword">new</span> PutMethod(url);</span><br><span class="line">    putMethod.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">    putMethod.setRequestEntity(<span class="keyword">new</span> StringRequestEntity(data, <span class="string">"application/json"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">    <span class="keyword">int</span> statusCode = client.executeMethod(putMethod);</span><br><span class="line">    <span class="comment">//System.out.println(statusCode);</span></span><br><span class="line">    <span class="keyword">return</span> statusCode;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">httpPost</span><span class="params">(String url, String data, String username, String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//省略, 具体参考 httpPut 方法进行推演</span></span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">            <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">    PostMethod postMethod = <span class="keyword">new</span> PostMethod(url);</span><br><span class="line">    postMethod.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">    postMethod.setRequestEntity(<span class="keyword">new</span> StringRequestEntity(data, <span class="string">"application/json"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">    <span class="keyword">int</span> statusCode = client.executeMethod(postMethod);</span><br><span class="line">    <span class="comment">//System.out.println(statusCode);</span></span><br><span class="line">    <span class="keyword">return</span> statusCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 Gson 解析 metadata.json 文件，进而使用 HttpClient 调用相应的 HTTP API 在随机的节点上创建相应的队列进程，从而达到了集群节点负载均衡的目的。</p></li><li><p>HttpClient需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-httpclient<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过随机连接集群中不同的节点的IP地址，然后再创建队列。与前一种方式需要节点名称的列表不同，这里需要的是节点IP地址列表：</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ipList = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="string">"192.168.0.2"</span>);</span><br><span class="line">    add(<span class="string">"192.168.0.3"</span>);</span><br><span class="line">    add(<span class="string">"192.168.0.4"</span>); </span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>客户端通过连接不同的IP地址来创建不同的 connection 和 channel ，然后将 channel 存入一个缓冲池，之后从 channelList 中获取一个 channel ，再根据 queueList 中的信息创建相应的队列。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010119.png" alt></p></li><li><p>每一个 channel 对应一个 connection，而每一个 connection 又对应一个 IP ，这样串起来就能保证 channelList 中不会遗留任何节点，最终实现与第一种方式相同的功能。对应的队列创建代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createQueuesNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Channel&gt; channelList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Connection&gt; connectionList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ipList.size();i++) &#123;</span><br><span class="line">            String ip = ipList.get(i);</span><br><span class="line">            ConnectionFactory connectionFactory =<span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">            connectionFactory.setUsername(username);</span><br><span class="line">            connectionFactory.setPassword(password);</span><br><span class="line">            connectionFactory.setHost(ip);</span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            Connection connection = connectionFactory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            channelList.add(channel) ;</span><br><span class="line">            connectionList.add(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        createQueueByChannel(channelList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace() ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connection connection : connectionList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createQueueByChannel</span><span class="params">(List&lt;Channel&gt; channelList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queueList.size(); i++) &#123;</span><br><span class="line">        Queue queue = queueList.get(i);</span><br><span class="line">        <span class="comment">//随机获取相应的 channel</span></span><br><span class="line">        Collections.shuffle(channelList);</span><br><span class="line">        Channel channel = channelList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, Object&gt; mapArgs = queue.getArguments();</span><br><span class="line">            <span class="comment">//do something with mapArgs.</span></span><br><span class="line">            channel.queueDeclare(queue.getName(), queue.getDurable(),</span><br><span class="line">                    <span class="keyword">false</span>, queue.getAuto_delete(), mapArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="4-2-数据迁移和客户端连接的切换"><a href="#4-2-数据迁移和客户端连接的切换" class="headerlink" title="4.2 数据迁移和客户端连接的切换"></a>4.2 数据迁移和客户端连接的切换</h3><p>首先需要将生产者的客户端与原 RabbitMQ 集群的连接断开，然后再与新的集群建立新的连接，这样就可以将新的消息流转入到新的集群中。</p><p>之后就需要考虑消费者客户端的事情，一 种是等待原集群中的消息全部消费完之后再将连接断开，然后与新集群建立连接进行消费作业。</p><p>当原集群服务不可用或者出现故障造成服务质量下降而需要迅速将消息流切换到新的集群中时，此时就不能等待消费完原集群中的消息，这里需要及时将消费者客户端的连接切换到新的集群中，那么在原集群中就会残留部分未被消费的消息，此时需要做进一步的处理。如果原集群损坏，可以等待修复之后将数据迁移到新集群中，否则会丢失数据。</p><p><strong>数据迁移的主要原理</strong>是先从原集群中将数据消费出来，然后存入一个缓存区中，另一个线程读取缓存区中的消息再发布到新的集群中，如此便完成了数据迁移的动作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010120.png" alt></p><p>RabbitMQ提供的 Federation 和 Shovel 都可以实现 ForwardMaker 功能。</p><h3 id="4-3-自动化迁移"><a href="#4-3-自动化迁移" class="headerlink" title="4.3 自动化迁移"></a>4.3 自动化迁移</h3><p>要实现集群自动化迁移，需要在使用相关资源时就做好一些准备工作，方便在自动化迁移过程中进行无缝切换。</p><h4 id="4-3-1-使用资源的3个部分"><a href="#4-3-1-使用资源的3个部分" class="headerlink" title="4.3.1 使用资源的3个部分"></a>4.3.1 使用资源的3个部分</h4><p>与生产者和消费者客户端相关的是交换器、队列及集群的信息，如果这种类型的资源发生改变时需要让客户端迅速感知，以便进行相应的处理，则可以通过将相应的资源加载到 ZooKeeper 的相应节点中，然后在客户端为对应的资源节点加入 watcher 来感知变化， 当然这个功能使用 etcd 或者集成到公司层面的资源配置中心中会更加标准、高效。</p><p>如图将整个 RabbitMQ 集群资源的使用分为3个部分：</p><ul><li>客户端、</li><li>集群、</li><li>ZooKeeper 配置管理。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010121.png" alt></p><h4 id="4-3-2-自动化迁移过程"><a href="#4-3-2-自动化迁移过程" class="headerlink" title="4.3.2 自动化迁移过程"></a>4.3.2 自动化迁移过程</h4><p>在集群中<strong>创建元数据资源</strong>时都需要在 ZooKeeper 中生成相应的配置：</p><ul><li><p>比如在 cluster1 集群中创建交换器 exchange1 之后，需要在 /rmqNode/exchanges 路径下创建实节点 exchange1。并赋予节点的数据内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cluster=cluster1</span> <span class="comment"># 表示此交换器所在的集群名称</span></span><br><span class="line"><span class="string">exchangeType=direct</span> <span class="comment"># 表示此交换器的类型</span></span><br><span class="line"><span class="string">vhost=vhost1</span> <span class="comment"># 表示此交换器所在的 vhost</span></span><br><span class="line"><span class="string">username=root</span> <span class="comment"># 表示用户名</span></span><br><span class="line"><span class="string">password=root123</span> <span class="comment"># 表示密码</span></span><br></pre></td></tr></table></figure></li><li><p>在 cluster1 集群中创建队列 queue1 之后，需要在 /rmqNode/queues 路径下创建实节点 queue1 ，并赋予节点的数据内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cluster=cluster1</span></span><br><span class="line"><span class="string">bindings=exchange1</span> <span class="comment"># 表示此队列所绑定的交换器</span></span><br><span class="line"><span class="comment"># 如果有需要，也可以添加一些其他信息，比如路由键等</span></span><br><span class="line"><span class="string">vhost=vhost1</span></span><br><span class="line"><span class="string">username=root</span></span><br><span class="line"><span class="string">password=root123</span></span><br></pre></td></tr></table></figure></li><li><p>对应集群的数据在 /rmqNode/clusters 路径下，比如 cluster 集群，其对应节点的数据内容包含 IP 地址列表信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ipList=192.168.0.2,</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span><span class="string">,</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span> <span class="comment"># 集群中各个节点的 IP 地址信息</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>客户端程序</strong>如果与其上的交换器或者队列进行交互，那么需要在相应的 <strong>ZooKeeper 节点中添加 watcher</strong> ，以便在数据发生变更时进行相应的变更，从而达到自动化迁移的目的。</p><p><strong>生产者客户端</strong>：</p><ul><li>在发送消息之前需要先连接 ZooKeeper，</li><li>然后根据指定的交换器名称如 exchange1 找到相应的路径 /rmqNode/exchanges 中寻找 exchange1 的节点，</li><li>之后再读取节点中的数据，井同时对此节点添加 watcher 。</li><li>在节点的数据第一条 <code>cluster=cluster1</code> 中找到交换器所在的集群名称，</li><li>然后再从路径 /rmqNode/clusters 中寻找 cluster1 节点，</li><li>然后读取其对应 IP 地址列表信息。</li><li>这样整个发送端所需要的连接串数据 (IP地址列表、vhost、usemame、password 等）都己获取，接下就可以与 RabbitMQ 集群 cluster 建立连接然后发送数据了。 </li></ul><p>对于<strong>消费者客户端</strong>而言：</p><ul><li>同样需要连接 ZooKeeper ，</li><li>之后根据指定的队列名称（queue1) 到相应的路径 /rmqNode/queues 中寻找 queue1 节点，</li><li>继而找到相应的连接串，</li><li>然后与 RabbitMQ 集群 cluster1 建立连接进行消费。</li><li>当然对 /rmqNode/queues/queue1 节点的 watcher 必不可少。</li></ul><p>当 cluster1 集群需要迁移到 cluster2 集群时：</p><ul><li>首先需要将 cluster1 集群中的元数据在 cluster2 集群中重建。</li><li>之后通过修改 channel 和 queue 元数据信息：<ul><li>比如原 cluster1 集群中有交换 exchange1、exchange2 和队列 queue1、queue2 ，</li><li>现在通过脚本或者程序将其中的 <code>cluster=cluster1</code> 数据修改为 <code>cluster=cluster2</code> 。</li><li>客户端会立刻感知节点的变化，然后迅速关闭当前连接之后再与新集群 cluster2 建立新的连接后生产和消费消息，在此切换客户端连接的过程中是可以保证数据零丢失的。</li></ul></li><li>迁移之后，生产者和消费者都会与 cluster2 集群进行互通，此时原 cluster 集群中可能还有未被消费完的数据，此时需要使用 RabbitMQ ForwardMaker 工具将 cluster1 集群中未被消费完的数据同步到 cluster2 集群中。</li></ul><p>如果没有准备 RabbitMQ ForwardMaker 工具，也不想使用 Federation 或者 Shovel 插件，那么在变更完交换器相关的 ZooKeeper 中的节点数据之后，需要等待原集群中的所有队列都消费完全之后，再将队列相关的 ZooKeeper 中的节点数据变更，进而使得消费者的连接能够顺利迁移到新的集群之上。可以通过下面的命令来查看是否有队列中的消息未被消费完：</p><p><code>rabbitmqctl list_queues -p / -q | awk &#39;{if($2&gt;0) print $0 }&#39;</code></p><h4 id="4-3-3-空闲备份集群解决方案"><a href="#4-3-3-空闲备份集群解决方案" class="headerlink" title="4.3.3 空闲备份集群解决方案"></a>4.3.3 空闲备份集群解决方案</h4><p>上面的自动化迁移立足于将现有集群迁移到空闲的备份集群，如果由于原集群硬件升级等原因迁移也无可厚非。很多情况下，自动化迁移作为容灾手段中的一种，如果有很多个正在运行的 RabbitMQ 集群，为每个集群都配备一个空闲的备份集群无疑是一种资源的浪费。当然可以采取几个集群共用一个备份集群来减少这种浪费，那么有没有更优的解决方案呢？</p><p>就以4个 RabbitMQ 集群为例，其被分配4个独立的业务使用。如图 7-8 所示， 当 cluster1 集群中的元数据备份到 cluster2 集群中，而 cluster2 集群中的元数据备份到 cluster3 集群中，如此可以两两互备。<strong>比如在 cluster1 集群中创建了一个交换器 exchange1 ，此时需要在 cluster2 集群中同样创建一个交换器 exchange1</strong> 。在正常情况下，使用的是 cluster1 集群中的 exchange1 ，而 exchange1 在 cluster2 集群中只是一份记录，并不消耗 cluster2 集群的任何性能。而当需要将 cluster1 迁移时，只需要将交换器及队列相对应的 ZooKeeper 节点数据项变更即可完成迁移的工作。如此既不用耗费额外的硬件资源，又不用再迁移的时候重新建立元数据信息。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010122.png" alt></p><p>为了更加稳妥起见，也可以准备一个空闲的备份集群以备后用。当 cluster1 集群需要迁移 cluster2 集群中时， cluster2 集群己经发生故障被关闭或者被迁移到 cluster3 集群中了，那么这个空闲的备份集群可以当作 Plan B 来增强整体服务的可靠性。如果既想不浪费多余的硬件资源又想具备更加稳妥的措施，可以参考图 7-9 ，将 cluster1 中的元数据备份到 cluster2、cluster3 中，这样以1备2的方式即可解决这个难题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010123.png" alt></p><p>对于上面介绍的多集群间互备的解决方案需要配套一个完备的实施系统，比如具备资源管理、执行下发、数据校对等功能，并且对于 ZooKeepe 节点中的数据项设计也需要细细斟酌，最好能够根据实际使用情况将这些整合到一个大的平台化系统之中。</p><h2 id="第五节-集群监控"><a href="#第五节-集群监控" class="headerlink" title="第五节 集群监控"></a>第五节 集群监控</h2><p>监控不仅可以提供运行时的数据为应用提供依据参考，还可以迅速定位问题、提供预防及告警等功能，很大程度上增强了整体服务的鲁棒性。</p><p>RabbitMQ Management 插件就能提供一定的监控功能：如发送速度、确认速度、消费速度、消息总数、磁盘读写速度、句柄数、Socket 连接数、 Connection 数、 Channel 数、内存信息等。但是有一个遗憾就是其难以和公司内部系统平台关联，对于业务资源的使用情况、相应的预防及告警的联动无法顺利贯通。如果在人力、物力等条件允许的情况下，自定义一套监控系统非常有必要。</p><h3 id="5-1-通过HTTP-API接口提供监控数据"><a href="#5-1-通过HTTP-API接口提供监控数据" class="headerlink" title="5.1 通过HTTP API接口提供监控数据"></a>5.1 通过HTTP API接口提供监控数据</h3><p>RabbitMQ Management 插件提供了HTTP API接口来提供监控数据。</p><p>假设集群中一共有4个节点：nod1、node2、node3、node4 。有一个交换器 exchange 通过同一个路由键“rk”绑定了3个队列 quue1、queue2 和 queue3。</p><p>首先可以通过 /api/nodes 接口来收集集群节点的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> diskFree;<span class="comment">//磁盘空闲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> diskFreeLimit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fdUsed;<span class="comment">//句柄使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fdTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> socketsUsed;<span class="comment">//Socket 使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> socketsTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> memoryUsed;<span class="comment">//内存使用值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> memoryLimit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> procUsed;<span class="comment">//Erlang 进程使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> procTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;disk_free="</span> + diskFree + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"disk_free_limit="</span> + diskFreeLimit + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"fd_used= "</span> + fdUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"fd_total = "</span> + fdTotal + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"sockets_used= "</span> + socketsUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"sockets_total= "</span> + socketsTotal + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"mem_used= "</span> + memoryUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"mem_limit= "</span> + memoryLimit + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"proc_used="</span> + procUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"proc_total="</span> + procTotal + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装一下HTTP GET，方便后续程序直接调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">httpGet</span><span class="params">(String url, String username, String password)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">        GetMethod getMethod = <span class="keyword">new</span> GetMethod(url) ;</span><br><span class="line">        <span class="keyword">int</span> ret = client.executeMethod(getMethod);</span><br><span class="line">        String data = getMethod.getResponseBodyAsString();</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 HTTP GET 方法获取 <code>http://xx.xxx.xxx.xxx:15672/api/nodes</code> 的 JSON 数据，然后通过 GSON 进行解析， 之后即可采集到感兴趣的数据项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ClusterNode&gt; <span class="title">getClusterData</span><span class="params">(String ip, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               String username, String password)</span> </span>&#123;</span><br><span class="line">    List&lt;ClusterNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String url = <span class="string">"http://"</span> + ip + <span class="string">":"</span> + port + <span class="string">"/api/nodes"</span>;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String urlData = HttpUtils.httpGet(url, username, password);</span><br><span class="line">        parseClusters(urlData, list);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseClusters</span><span class="params">(String urlData, List&lt;ClusterNode&gt; list)</span> </span>&#123;</span><br><span class="line">    JsonParser parser= <span class="keyword">new</span> JsonParser();</span><br><span class="line">    JsonArray jsonArray =(JsonArray) parser.parse(urlData);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ;i &lt; jsonArray.size(); i++) &#123;</span><br><span class="line">        JsonObject jsonObjectTemp = jsonArray.get(i).getAsJsonObject();</span><br><span class="line">        ClusterNode cluster = <span class="keyword">new</span> ClusterNode();</span><br><span class="line">        cluster.setDiskFree(jsonObjectTemp.get(<span class="string">"disk_free"</span>).getAsLong());</span><br><span class="line">        cluster.setDiskFreeLimit(jsonObjectTemp.get(<span class="string">" disk_free_limit"</span>).</span><br><span class="line">                getAsLong());</span><br><span class="line">        cluster.setFdUsed(jsonObjectTemp.get(<span class="string">"fd_used"</span>).getAsLong());</span><br><span class="line">        cluster.setFdTotal(jsonObjectTemp.get(<span class="string">"fd_total"</span>).getAsLong() );</span><br><span class="line">        cluster.setSocketsUsed(jsonObjectTemp.get(<span class="string">"sockets_used"</span>).getAsLong());</span><br><span class="line">        cluster.setSocketsTotal(jsonObjectTemp.get(<span class="string">"sockets_total"</span>).getAsLong());</span><br><span class="line">        cluster.setMemoryUsed(jsonObjectTemp.get(<span class="string">"mem_used"</span>).getAsLong() );</span><br><span class="line">        cluster.setMemoryLimit(jsonObjectTemp.get(<span class="string">"mem_limit"</span>).getAsLong() );</span><br><span class="line">        cluster.setProcUsed(jsonObjectTemp.get(<span class="string">"proc_used"</span>).getAsLong());</span><br><span class="line">        cluster.setProcTotal(jsonObjectTemp.get(<span class="string">" proc_total"</span>).getAsLong() );</span><br><span class="line">        list.add(cluster);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据来集完之后并没有结束，图 7-10 中简单囊括了从数据采集到用户使用的过程：</p><ul><li>首先采集程序通过定时调用 HTTP API 接口获取 JSON 数据，</li><li>然后进行 JSON 解析之后再进行持久化处理。</li><li>对于这种基于时间序列的数据非常适合使用 OpenTSDB（基于 Hbase 的分布式的、可伸缩的时间序列数据库。主要用途就是做监控系统，比如收集大规模集群，包括网络设备、操作系统、应用程序的监控数据并进行存储、查询）来进行存储。</li><li>监控管理系统可以根据用户的检索条件来从 OpenTSDB 获取相应的数据并展示到页面之中。</li><li>监控管理系统本身还可以具备报表、权限管理等功能，同时也可以实时读取所采集的数据，对其进行分析处理，对于异常的数据需要及时报告给相应的人员。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010124.png" alt></p><p>对于集群的各节点信息展示可以参考下方，图 7-11 展示了各个节点实时的内存占用情况，图 7-12 展示了各个节点实时的磁盘使用情况。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010125.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010126.png" alt></p><p>对于交换器而言的数据采集可以调用 /api/exchanges/vhost/name 接口，比如需要调用虚拟主机为默认的 <code>/</code> 、交换器名称为 exchange 的数据，只需要使用 HTTP GET 方法获取 <code>http://xxx.xxx.xxx.xxx:15672/api/exchanges/%2F/exchange</code> 的数据即可。注意，这里需要将 <code>/</code> 进行 HTML 转义成 <code>%2F</code> ，否则会出错。对应的数据内容可以参考下方：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message_stats"</span>:&#123;</span><br><span class="line"><span class="attr">"publish_in_details"</span>: &#123;</span><br><span class="line"><span class="attr">"rate"</span>: <span class="number">0.4</span> //数据流入的速率</span><br><span class="line">&#125;,</span><br><span class="line">"publish_in": 9,//数据流入的总量</span><br><span class="line">"publish_out_details": &#123;</span><br><span class="line">"rate": 1.2 //数据流出的速率</span><br><span class="line">&#125;,</span><br><span class="line">"publish_out": 27//数据流出的总量</span><br><span class="line">&#125;,</span><br><span class="line">"outgoing": [],</span><br><span class="line">"incoming": [],</span><br><span class="line">"arguments": &#123;&#125;,</span><br><span class="line">"internal": false,</span><br><span class="line">"auto_delete": false,</span><br><span class="line">"durable": true,</span><br><span class="line">"type": "direct",</span><br><span class="line">"vhost": "/",</span><br><span class="line">"name": "exchange" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于1个交换器绑定3个队列的情况，向交换器发送1条消息，那么流入就是1条，而流出就是3条。在应用的时候根据实际情况挑选数据流入速率或者数据流出速率作为发送数量， 以及挑选数据流入的量还是数据流出的量作为发送量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JQExchange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> publishInRate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> publishIn;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> publishOutRate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> publishOut;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;publish_in_rate="</span> + publishInRate +</span><br><span class="line">                <span class="string">", publish_in"</span> + publishIn +</span><br><span class="line">                <span class="string">", publish_out_rate="</span> + publishOutRate +</span><br><span class="line">                <span class="string">", publish_out="</span> + publishOut + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeMonitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getExchangeData(<span class="string">"192.168.0.2"</span>, <span class="number">15672</span>, <span class="string">"root"</span>, <span class="string">"rootl23"</span>, <span class="string">"/"</span>, <span class="string">"exchange"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JQExchange <span class="title">getExchangeData</span><span class="params">(String ip, <span class="keyword">int</span> port, String username,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String password, String vhost , String exchange)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String url = <span class="string">"http://"</span> + ip + <span class="string">":"</span> + port + <span class="string">"/api/exchanges"</span></span><br><span class="line">                + encode(vhost, <span class="string">"UTF-8"</span>) + <span class="string">"/"</span> + encode(exchange, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        String urlData = HttpUtils.httpGet(url, username, password);</span><br><span class="line">        System.out.println(urlData);</span><br><span class="line">        JQExchange exchangeAns = parseExchange(urlData);</span><br><span class="line">        System.out.println(exchangeAns);</span><br><span class="line">        <span class="keyword">return</span> exchangeAns;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JQExchange <span class="title">parseExchange</span><span class="params">(String urlData)</span> </span>&#123;<span class="comment">//解析程序</span></span><br><span class="line">        JQExchange exchange = <span class="keyword">new</span> JQExchange();</span><br><span class="line">        JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">        JsonObject jsonObject = (JsonObject) parser.parse(urlData);</span><br><span class="line">        JsonObject msgStats =</span><br><span class="line">                jsonObject.get(<span class="string">"message_stats"</span>).getAsJsonObject();</span><br><span class="line">        <span class="keyword">double</span> publish_in_details_rate =</span><br><span class="line">                msgStats.get(<span class="string">"publish_in_details"</span>)</span><br><span class="line">                        .getAsJsonObject().get(<span class="string">"rate"</span>).getAsDouble();</span><br><span class="line">        <span class="keyword">double</span> publish_out_details_rate =</span><br><span class="line">                msgStats.get(<span class="string">"publish_out_details"</span>).</span><br><span class="line">                        getAsJsonObject().get(<span class="string">"rate"</span>).getAsDouble();</span><br><span class="line">        <span class="keyword">long</span> publish_in = msgStats.get(<span class="string">"publish_in"</span>).getAsLong();</span><br><span class="line">        <span class="keyword">long</span> publish_out = msgStats.get(<span class="string">"publish_out"</span>).getAsLong();</span><br><span class="line">        exchange.setPublishInRate(publish_in_details_rate);</span><br><span class="line">        exchange.setPublishOutRate(publish_out_details_rate);</span><br><span class="line">        exchange.setPublishIn(publish_in);</span><br><span class="line">        exchange.setPublishOut(publish_out);</span><br><span class="line">        <span class="keyword">return</span> exchange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于队列而言的数据来集相关的接口为 /api/queues/vhost/name 。</p><h3 id="5-2-通过客户端提供监控数据"><a href="#5-2-通过客户端提供监控数据" class="headerlink" title="5.2 通过客户端提供监控数据"></a>5.2 通过客户端提供监控数据</h3><p>除了 HTTP API 接口可以提供监控数据，Java 版客户端从 3.6.x 版本开始，也在 <code>Channel</code> 接口中提供了两个方法来获取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">messageCount</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">consumerCount</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>messageCount：用来查询队列中的消息个数，可以为监控消息堆积的情况提供数据。</li><li>consumerCount：用来查询队列中的消费者个数，可以为监控消费者的情况提供数据。</li></ul><p>相应监控视图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010127.png" alt></p><p>还可以通过连接的状态进行监控，<code>Connection</code> 接口提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBlockedListener</span><span class="params">(BlockedListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BlockedListener <span class="title">addBlockedListener</span><span class="params">(BlockedCallback var1, UnblockedCallback var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeBlockedListener</span><span class="params">(BlockedListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBlockedListeners</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>addBlockedListener：用来监昕连接阻塞信息。</li><li>addShutdownListener：用来监昕连接关闭信息。</li></ul><p>用户客户端还可以自行定义一些数据进行埋点 ，比如客户端成功发送的消息个数和发送失败的消息个数，进一步可以计算发送消息的成功率等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> successCount = <span class="number">0</span>; <span class="comment">//记录发送成功的次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> failureCount = <span class="number">0</span>; <span class="comment">//记录发送失败的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XXXXXX</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                failureCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>,</span><br><span class="line">                MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                <span class="string">"msg"</span> .getBytes());</span><br><span class="line">        <span class="keyword">if</span> (channel.waitForConfirms() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            successCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            failureCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        failureCount++;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        failureCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里推荐引入 metrics 工具（比如 <code>com.codahale.metrics.*</code>）来进行埋点，这样既方便又高效。同样的方式也可以统计消费者消费成功的条数和消费失败的条数。</p><h3 id="5-3-检测RabbitMQ服务是否健康"><a href="#5-3-检测RabbitMQ服务是否健康" class="headerlink" title="5.3 检测RabbitMQ服务是否健康"></a>5.3 检测RabbitMQ服务是否健康</h3><p>上述两种方式都要基于 RabbitMQ 服务运行正常的情况下，但无法判断 RabbitMQ 是否具备服务外部请求的能力。</p><p>三种检查方式：</p><ul><li>检查RabbitMQ是否运行：<code>ps aux | grep rabbitmq</code> 。</li><li>检查5672端口是否开启：<code>telnet xxx.xxx.xxx.xxx 5672</code> 。</li><li>使用 AMQP 协议来构建一个类似于 TCP 协议中的 Ping 的检测程序。当这个测试程序与 RabbitMQ 服务无法建立 TCP 协议层面的连接，或者无法构建 AMQP 协议层面的连接，再或者构建连接超时时，则可判定 RabbitMQ 服务处于异常状态而无法正常为外部应用提供相应的服务。</li></ul><p>AMQPPing实现代码可以参考《RabbitMQ实战指南 7.5.3》。</p><p>RabbitMQ Management 插件提供了 /api/aliveness-test/vhost 的 HTTP API 形式的接口，通过3个步骤来验证 RabbitMQ 服务的健康性：</p><ul><li>创建1个以 <code>aliveness-test</code> 为名称的队列来接收测试消息。</li><li>用队列名称 <code>aliveness-test</code> 作为消息的路由键，将消息发往默认交换器。 </li><li>到达队列时就消费该消息，否则就报错。</li></ul><p>检测程序 <code>aliveness-test</code> 运行在 Erlang 虚拟机内部， 因此它不会受到网络问题的影响。</p><h3 id="5-4-元数据管理与监控"><a href="#5-4-元数据管理与监控" class="headerlink" title="5.4 元数据管理与监控"></a>5.4 元数据管理与监控</h3><p>确保 RabbitMQ 能够健康运行还不足以让人放松警惕。比如在生产环境误删了一个队列（或者删除交换器、修改绑定信息等），若业务方正在使用这个队列，返回了异常后即使处理还能尽量的减少影响。但如果是深夜执行的定时任务，处理起来就很麻烦了。</p><p>许多应用场景是在业务逻辑代码中创建相应的元数据资源（交换器、队列及绑定关系）并使用对于排他的、自动删除的这类非高可靠性要求的元数据资源可以在一定程度上忽略元数据变更的影响。但是对于两个非常重要的且通过消息中间件交互的业务应用，在使用相应的元数据资源时最好进行相应的管控，如果一方或者其他方肆意变更所使用的元数据，必然对另一方造成不小的损失。管控的介入自然会降低消息中间件的灵活度，但是可以增强系统的可靠性。 比如通过专用的“元数据审核系统”来配置相应的元数据资源，提供给业务方使用的用户只有 可读和可写的权限，这样可以进一步降低风险。</p><p>RabbitMQ 在创建元数据资源的时候是以一种声明的形式完成的：无则创建、有则不变，不过在对应的元数据存在的情况下，对其再次声明时使用不同的属性会报出相应的错误信息。 我们可以利用这一特性来监控元数据的变更，通过定时程序来将记录中的元数据信息重新声明一次，查看是否有异常报出。不过这种方法非常具有局限性，只能增加元数据的信息而不能减少。比如有一个队列没有消费者且以后也不会被使用，我们对其进行了解绑操作，这样就没有更多的消息流入而造成消息堆积，不过这一变更由于某些局限性没有及时将记录变更以通知到那个定时程序，此时又重新将此队列绑定到原交换器中。</p><p>如图 7-15 所示，所有的业务应用都需要通过元数据审核系统来申请创建（当然也可以包含查询、修改及删除）相应的元数据信息。在申请动作完成之后，由专门的人员进行审批，之后在数据库中存储和在 RabbitMQ 集群中创建相应的元数据，这两个步骤可以同时进行，而且也无须为这两个动作添加强一致性的事务逻辑。在数据库和 RabbitMQ 集群之间会有一个元数据一致性校验程序来检测元数据不一致的地方，然后将不一致的数据上送到监控管理系统。监控管理系统中可以显示元数据不一致的记录信息，也可以以告警的形式推送出来，然后相应的管 理人员可以选择手动或者自动地进行元数据修正。这里的不一致有可能是由于数据库的记录未被正确及时地更新，有可能是 RabbitMQ 集群中元数据被异常篡改 元数据修正需慎之又慎，在整个系统修正逻辑完备之前，建议优先采用人工的方式，毕竟不一致的元数据仅占少数，人工修正的工作量并不太大。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010128.png" alt></p><p>主要的元数据是：queues、exchanges、bindings ，可以分别建立三张表。元数据一致性检测程序可以通过 /api/definitions 的 HTTP API 接口获取集群的元数据信息，通过解析之后与数据库中的记录一一比对，查看是否有不一致的地方。</p><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第六章《运维》，内容来自于《RabbitMQ实战指南》，内容：在 RabbitMQ 使用过程中难免会出现各式各样的异常情况，客户端的异常一般是由于应用代码的缺陷造成的，对于服务端的异常，虽然不能完全杜绝，但是可以采取一些有效的手段去监测、管控、修正等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（五）配置</title>
    <link href="http://linyishui.top/2020100601.html"/>
    <id>http://linyishui.top/2020100601.html</id>
    <published>2020-10-06T13:00:41.000Z</published>
    <updated>2020-10-07T15:40:06.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（五）配置"><a href="#RabbitMQ（五）配置" class="headerlink" title="RabbitMQ（五）配置"></a>RabbitMQ（五）配置</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><p>一般情况下，只需要使用默认的内建配置来运行 RabbitMQ，也可以利用调节系统范围内的参数来达到定制化的需求。</p><p>RabbitMQ 提供了三种方式来定制化服务：</p><ol><li>环境变量（Enviroment Variables）：RabbitMQ 服务端参数可以通过环境变量进行配置，例如：节点名称、 RabbitMQ 配直文件的地址、节点内部通信端口等。</li><li>配置文件（ Configuration File）：可以定义 RabbitMQ 服务和插件设置，例如：TCP 听端口，以及其他网络相关的设直、内存限制、磁盘限制等。</li><li>运行时参数和策略（ Runtime Parameters and Policies）：可以在运行时定义集群层面的服务设置。</li></ol><h2 id="第二节-环境变量"><a href="#第二节-环境变量" class="headerlink" title="第二节 环境变量"></a>第二节 环境变量</h2><h3 id="2-1-配置方式"><a href="#2-1-配置方式" class="headerlink" title="2.1 配置方式"></a>2.1 配置方式</h3><p>RabbitMQ 的环境变量都是以 <code>RABBITMQ_</code> 开头的，可以在 Shell 环境中设置，也可以在 <code>rabbitmq-env.conf</code> 这个 RabbitMQ 环境变量的定义文件中设置。在非 Shell 环境中配置，则需要将 <code>RABBITMQ_</code> 这个前缀去除。</p><p>指令 <code>rabbitmq-server -detached</code> 启动 RabbitMQ 服务的时候，此服务节点默认以 <code>rabbit＠</code> 加上当前的 Shell 环境的 hostname（主机名）来命名，即 <code>rabbit@$HOSTNAME</code> 。可以在 <code>rabbitmq-server</code> 命令前添 <code>RABBITMQ_NODENAME</code> 变量来设定指定的名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> RABBITMQ_NODENAME=rabbit@node2 rabbitmq-server -detached</span></span><br><span class="line">Warning: PIO file not written; -detached was passed.</span><br></pre></td></tr></table></figure><p>优先级顺序：Shell环境 &gt; <code>rabbitmq-env.conf</code> 配置文件 &gt; 默认配置。</p><p>配置 <code>rabbitmq-env.conf</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RabbitMQ 环境变量的定义文件</span></span><br><span class="line"><span class="comment"># 定义节点名称</span></span><br><span class="line"><span class="string">NODENAME=rabbit@node1</span></span><br><span class="line"><span class="comment"># 定义 RabbitMQ 的对外通信端口号</span></span><br><span class="line"><span class="string">NODE_PORT=5672</span></span><br><span class="line"><span class="comment"># 定义 RabbitMQ 配置文件的目录，注意对于 rabbitmq.config</span></span><br><span class="line"><span class="comment"># 文件来说这里不用添加".config后缀"</span></span><br><span class="line"><span class="string">CONFIG_FILE=/opt/rabbitmq/etc/rabbitmq/rabbitmq</span></span><br></pre></td></tr></table></figure><p>默认配置记录在 <code>$RABBITMQ HOME/sbin/rabbitmq-defaults</code> 文件。</p><h3 id="2-2-常见的RabbitMQ变量"><a href="#2-2-常见的RabbitMQ变量" class="headerlink" title="2.2 常见的RabbitMQ变量"></a>2.2 常见的RabbitMQ变量</h3><table><thead><tr><th>变量名称</th><th>描述</th></tr></thead><tbody><tr><td>RABBITMQ_NODE_IP_ADDRESS</td><td>绑定某个特定的网络接口。默认值是空字符串，即绑定到所有网络接口上。如果要绑定两个或者更多的网络接口，可以参考 rabbitmq.config 中的 tcp_listeners 配置</td></tr><tr><td>RABBITMQ_NODE_PORT</td><td>监听客户端连接的端口号，默认为 5672</td></tr><tr><td>RABBITMQ_DIST_PORT</td><td>RabbitMQ 节点内部通信的端口号，默认值为 RABBITMQ_NODE_PORT+20000, 即25672。如果设置了 kernel.inet_dist_listen_min 或者 kemel.inect_dist_listen_max</td></tr><tr><td>RABBITMQ_NODENAME</td><td>RabbitMQ 的节点名称，默认为 rabbit@$HOSTNAME 。在每个 Erlang 节点和机器的组合中，节点名称必须唯一</td></tr><tr><td>RABBITMQ_CONF_ENV_FILE</td><td>RabbitMQ 环境变量的配置文件（rabbitmq-env.conf）的地址，默认值为 $RABBITMQ_HOME/etc/rabbitmq/rabbi tmq-env.conf 注意这里与 RabbitMQ 配置文件 rabbitmq.config 的区别</td></tr><tr><td>RABBITMQ_USE_LONGNAME</td><td>如果当前的 hostname 为 node1.longname ，那么默认情况下创建的节点名称为 rabbit@node1 ，将此参数设置为 true 时，创建的节点名称就为 <a href="mailto:rabbit@node1.longname" target="_blank" rel="noopener">rabbit@node1.longname</a>，即使用了长名称命名，默认值为空</td></tr><tr><td>RABBITMQ_CONFIG_FILE</td><td>RabbitMQ 配置文件（rabbitmq.config）的路径，注意没有“.config”的后缀．默认值为 $RABBITMQ_HOME/etc/rabbitmq/rabbitmq</td></tr><tr><td>RABBITMQ_MNESIA_BASE</td><td>RABBITMQ_MNESIA_DIR 的父目录。除非明确设置了 RABBITMQ_MNESIA _DIR 目录，否则每个节点都应该配置这个环境变量。默认值为 $RABBITMQ_HOME/var/lib/rabbitmq/mnesia  注意对于 RabbitMQ 的操作用户来说，需要有对当前目录可读、可写、可创建文件及子目录的权限</td></tr><tr><td>RABBITMQ_MNESA_DIR</td><td>包含 RabbitMQ 服务节点的数据库、数据存储及集群状态等目录，默认值为 <code>$RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME</code></td></tr><tr><td>RABBITMQ_LOG_BASE</td><td>RabbitMQ 服务日志所在基础目录．默认值为$RABBITMQ_HOME/var/log/rabbitmq</td></tr><tr><td>RABBITMQ_LOGS</td><td>RabbitMQ 服务与 Erlang 相关的日志，默认值为 <code>$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log</code></td></tr><tr><td>RABBITMQ_SASL_LOGS</td><td>RabbitMQ 服务于 Erlang 的 SASL(System Application Support Libraries）相关的日志，默认值为 <code>$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME-sasl.log</code></td></tr><tr><td>RABBITMQ_PLUGINS_DIR</td><td>插件所在路径。默认值为$RABBITMQ_HOME/plugins</td></tr></tbody></table><p>一般不建议修改环境变量，如果生产环境有特殊要求，可以参考：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件的地址</span></span><br><span class="line"><span class="string">CONFIG_FILE=/apps/conf/rabbitmq/rabbitmq</span></span><br><span class="line"><span class="comment"># 环境变量的配置文件的地址</span></span><br><span class="line"><span class="string">CONF_ENV_FILE=/apps/conf/rabbitmq/rabbitmq-env.conf</span></span><br><span class="line"><span class="comment"># 服务日志的地址</span></span><br><span class="line"><span class="string">LOG_BASE=/apps/logs/rabbitmq</span></span><br><span class="line"><span class="comment"># Mnesia 的路径</span></span><br><span class="line"><span class="string">MNESIA_BASE=/apps/dbdat/rabbitmq/mnesia</span></span><br></pre></td></tr></table></figure><h2 id="第三节-配置文件"><a href="#第三节-配置文件" class="headerlink" title="第三节 配置文件"></a>第三节 配置文件</h2><p>在启动 RabbitMQ 服务的时候会打印相关信息，可以检查服务日志来判断配置文件地址。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010112.png" alt></p><p>配置失效的情况：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="keyword">file</span>(s) : <span class="regexp">/opt/</span>rabbitmq<span class="regexp">/sbin/</span>..<span class="regexp">/etc/</span>rabbitmq<span class="regexp">/rabbitmq. config(not found)</span></span><br></pre></td></tr></table></figure><p>检查对应路径下是否有相关配置文件，以及配置文件地址是否设置正确（通过 RABBITMQ_CONFIG_FILE 变量或者 <code>rabbitmq-env.conf</code> 文件设置）。</p><p>还可以通过查看进程信息的方式来检查配直文件的位置。通过 <code>ps aux|grep rabbitmq</code> 命令查看到 RabbitMQ 进程的信息，如果 <code>rabbitmq.config</code> 文件不处于默认的路径中，则会有 <code>-config</code> 选项标记正在使用的路径。</p><h3 id="3-1-配置项"><a href="#3-1-配置项" class="headerlink" title="3.1 配置项"></a>3.1 配置项</h3><p>极简的 <code>rabbitmq.config</code> 文件：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listeners, [<span class="number">5673</span>]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>上面的配置将 RabbitMQ 监听 AMQP 0-9-1 客户端连接的默认端口号从 5672 修改为 5673。</p><p>RabbitMQ 服务相关配置表格暂略。</p><h3 id="3-2-配置加密"><a href="#3-2-配置加密" class="headerlink" title="3.2 配置加密"></a>3.2 配置加密</h3><p>配置文件中有些敏感的配置项可以被加密，在 RabbitMQ 启动时可以对这些项进行解密。在配置文件中将加密之后的值以 <code>{encrypted, 加密的值}</code> 形式包裹。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;default_user,&lt;&lt;<span class="string">"guest"</span>&gt;&gt;&#125;,</span><br><span class="line">&#123;default_pass,</span><br><span class="line">&#123;</span><br><span class="line">&#123;encrypted,&lt;&lt;<span class="string">"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="</span>&gt;&gt;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;loopback_users,[]&#125;,</span><br><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,&lt;&lt;<span class="string">"zzhpassphrase"</span>&gt;&gt;&#125;</span><br><span class="line">]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>config_entry_decoder 项中的 passphrase 配置的就是口令。注意这里将 loopback_users 项配置为 <code>[]</code> ，就可以使用非本地网络访问 RabbitMQ 了，如果开启了 RabbitMQ Management 插件，就可以使用 guest/guest 的用户及密码来访问 Web 管理界面了。</p><p>passphrase 内容可以以单独的文件来赋值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,<span class="string">"/path/to/passphrase/file"</span>&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>加密解密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode &lt;&lt;<span class="string">"guest"</span>&gt;&gt; zzhpassphrase </span></span><br><span class="line">&#123;encrypted,&lt;&lt;"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="&gt;&gt;&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode --DECODE &lt;&lt;<span class="string">"guest"</span>&gt;&gt; <span class="string">'&#123;encrypted,&lt;&lt;"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="&gt;&gt;&#125;'</span> zzhpassphrase</span></span><br></pre></td></tr></table></figure><p>默认情况下，加密机制 PBKDF2 用来从口令中派生出密钥。默认的 Hash 算法是 SHA512，默认的迭代次数是 1000 ，以及默认的加密算法为 AES_256_CBC。可以在配置文件中进行修改：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,<span class="string">"zzhpassphrase"</span>&#125;,</span><br><span class="line">&#123;cipher, blowfish_cfb64&#125;,</span><br><span class="line">&#123;hash, sha256&#125;,</span><br><span class="line">&#123;iterations, <span class="number">10000</span>&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>或者通过 rabbitmqctl encode 命令设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode --cipher blowfish_cfb64 --<span class="built_in">hash</span> sha256 --iterations 10000 <span class="string">'&lt;&lt;"guest"&gt;&gt;'</span> zzhpassphrase</span></span><br></pre></td></tr></table></figure><h3 id="3-3-优化网络配置"><a href="#3-3-优化网络配置" class="headerlink" title="3.3 优化网络配置"></a>3.3 优化网络配置</h3><p>RabbitMQ 支持的所有协议都是基于 TCP 层面的，除了操作系统内核参数和 DNS，所有的 RabbitMQ 设置都可以通过在 rabbitmq.config 配置文件中配置来实现。</p><h4 id="3-3-1-监听端口"><a href="#3-3-1-监听端口" class="headerlink" title="3.3.1 监听端口"></a>3.3.1 监听端口</h4><p>RabbitMQ 在等待接收客户端连接时需要绑定一个或者多个网络接口（可以理解成IP地址)，井监听特定的端口。网络接口使用 rabbit.tcp_listeners 选项来配置。默认情况下，RabbitMQ 会在所有可用的网络接口上监听 5672 端口。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line"># 在一个指定的地址和端口上进行监听，同时在 <span class="symbol">IPv4</span> 和 <span class="number">1</span><span class="symbol">Pv6</span> 上监听</span><br><span class="line">&#123;tcp_listeners, [&#123;<span class="string">"192.168.0.2"</span>, <span class="number">5672</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"::1"</span>, <span class="number">5672</span>&#125;]&#125;</span><br><span class="line"> </span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><h4 id="3-3-2-提高吞吐量"><a href="#3-3-2-提高吞吐量" class="headerlink" title="3.3.2 提高吞吐量"></a>3.3.2 提高吞吐量</h4><p>优化网络配置的一个重要目标就是提高吞吐量，比如禁用 Nagle 算法、增大 TCP 缓冲区的大小。每个 TCP 连接都分配了缓冲区。一般来说，缓冲区越大，吞吐量也会越高，但是每个连接上耗费的内存也就越多，从而使总体服务的内存增大，这是一个权衡的问题。在 Linux 操作系统中，默认会自动调节 TCP 缓冲区的大小，通常会设置为 80KB 到 120KB 之间。</p><p>要提高吞吐量可以使用 rabbit.tcp_listen_options 来加大配置：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listen_options, [</span><br><span class="line">                 &#123;backlog, <span class="number">128</span>&#125;,</span><br><span class="line">                 &#123;nodelay, true&#125;,</span><br><span class="line">                 &#123;linger, &#123;true,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">                 &#123;exit_on_close, false&#125;,</span><br><span class="line">                 &#123;sndbuf, <span class="number">196608</span>&#125;,</span><br><span class="line">                 &#123;recbuf, <span class="number">196608</span>&#125;]&#125; </span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>大部分操作系统都限制了同一时间可以打开的文件句柄数。在优化并发连接数的时候，需要确保系统有足够的文件句柄数来支撑客户端和 Broker 的交互。可以用每个节点上连接的数目乘以1.5来粗略的估算限制。例如，要支撑 10 万个 TCP 连接，需要设置文件句柄数为 15 万。当 然，略微增加文件句柄数可以增加闲置机器内存的使用量，但这需要合理权衡。</p><p>如上所述，增大 TCP 缓冲区的大小可以提高吞吐量，如果减小 TCP 缓冲区的大小，这样 就可以减小每个连接上的内存使用量。如果并发量比吞吐量更重要，可以修改此值。</p><p>禁用 Nagle 算法可以提高吞吐量，但是其主要还是用于减少延迟。RabbitMQ 内部节点交互时可以在 kernel.inet_default_connect_options 和 kernel.inet_default_listen_options 配置项中配置 {nodelay, true} 来禁用 Nagle 算法。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">kernel, [</span><br><span class="line">&#123;inet_default_connect_options, [&#123;nodelay, true&#125;]&#125;,</span><br><span class="line">&#123;inet_default_listen_options, [&#123;nodelay, true&#125;]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listen_options, [</span><br><span class="line">                 &#123;backlog, <span class="number">4096</span>&#125;,</span><br><span class="line">                 &#123;nodelay, true&#125;,</span><br><span class="line">                 &#123;linger, &#123;true,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">                 &#123;exit_on_close, false&#125;]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><h4 id="3-3-3-设置线程池大小"><a href="#3-3-3-设置线程池大小" class="headerlink" title="3.3.3 设置线程池大小"></a>3.3.3 设置线程池大小</h4><p>Erlang 在运行时使用线程池来异步执行 IO 操作。线程池的大小可以通过 RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS 这个环境变量来调节。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</span>=<span class="string">"+A 128"</span></span><br></pre></td></tr></table></figure><p>当机器的内核个数大于等于8时，建议将此值设置为大于等于 96 ，这样可以确保每个内核上可以运行大于等于 12 个 I/O 线程。</p><h4 id="3-3-4-连接量大"><a href="#3-3-4-连接量大" class="headerlink" title="3.3.4 连接量大"></a>3.3.4 连接量大</h4><p>当只有少量的客户端时，新建立的连接分布是非常不均匀的，但是由于数量足够小，所以没有太大的差异。当连接数量到达数万或者更多时，重要的是确保服务器能够接受入站连接。未接受的 TCP 连接将会放在有长度限制的队列中。这个通过 rabbit.tcp_listen_options.backlog 参数来设置，默认值为 128 ，当挂起的连接队列的长度超过此值时，连接将被操作系统拒绝。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010113.png" alt></p><h4 id="3-3-5-一些可配置的内核选项"><a href="#3-3-5-一些可配置的内核选项" class="headerlink" title="3.3.5 一些可配置的内核选项"></a>3.3.5 一些可配置的内核选项</h4><p>与操作系统有关的网络设置也会影响到 RabbitMQ 的运行，注意这一类型的内核参数在 <code>/etc/sysctl.conf</code> 文件（Linux 操作系统）中配置，而不是 rabbitmq.config 这个文件中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010114.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010115.png" alt></p><h2 id="第四节-参数及策略"><a href="#第四节-参数及策略" class="headerlink" title="第四节 参数及策略"></a>第四节 参数及策略</h2><p>有些配置不太适合在 rabbitmq.config 中实现，比如某项配置不需要同步到集群中的其他节点中，或者某项配置需要在运行时更改，因为 rabbitmq.config 需要重启 Broker 才能生效。 这种类型的配置在 RabbitMQ 中的另一种称呼为参数（ Paramter），也可以称之为运行时参数（Runtime Parameter）。</p><p>Parameter的设置方式：</p><ul><li>通过 rabbitmqctl 工具；</li><li>通过 RabbitMQ Management 插件提供的 HTTP API 接口来设置。</li></ul><p>RabbitMQ 一共有两种类型的 Parameter:：</p><ul><li>vhost 级别的 Parameter ，由一个组件名称（component name）、名称（name）和值 (value）组成。</li><li>global 级别的 Parameter ，由一个名称和值组成。</li></ul><p>不管什么类型，值都是JSON类型的。例如 Federation upstream 是一个 vhost 级别的 Parameter ，它用来定义 Federation link 的上游信息，其对应的 Parameter 的组件名称为 “federation-upstream” ，名称对应于其自身的名称，而值对应于与上游的相关的连接参数等；对 Shovel 而言也可以通过 Parameter 设置，其对应组件名称为 “shovel”。</p><h3 id="4-1-vhost级别Parameter"><a href="#4-1-vhost级别Parameter" class="headerlink" title="4.1 vhost级别Parameter"></a>4.1 vhost级别Parameter</h3><p>vhost 级别的参数对应的 rabbitmqctl 相关的命令有3种：</p><ul><li><p>set_parameter：用来设置一个参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter [-p vhost] &#123;component_name&#125; &#123;name&#125; &#123;value&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation </span></span><br><span class="line">The following plugins have been enabled: </span><br><span class="line">  rabbitmq_federation </span><br><span class="line">Applying plugin configuration to rabbit@node1... started 1 plugin. </span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter federation-upstream f1 <span class="string">'&#123;"uri":"amqp://root:root123@192.168.0.2:5672","ack-mode":"on-confirm"&#125;'</span></span></span><br><span class="line">Setting runtime parameter "f1" for component "federation-upstream" to "&#123;\"uri\":\"amqp://root:root123@192.168.0.2:5672\",\"ack-mode\":\"on-confirm\"&#125;"</span><br></pre></td></tr></table></figure></li><li><p>list_parameters：用来列出指定虚拟主机上所有的Parameter。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters [-p vhost] </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters -p /</span></span><br><span class="line">Listing runtime parameters </span><br><span class="line">federation-upstream f1 &#123;"uri":"amqp://root:root123@192.168.0.2:5672","ack-mode":"on-confirm"&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear_parameter：用来清除指定的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_parameter [-p vhost] &#123;componenet_name&#125; &#123;key&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_parameter -p / federation-upstream f1 </span></span><br><span class="line">Clearing runtime parameter "fl" for component "federation-upstream"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters -p /</span></span><br><span class="line">Listing runtime parameters</span><br></pre></td></tr></table></figure></li></ul><p>HTTP API接口：</p><ul><li>设置一个参数：PUT /api/parameters/{componenet_name}/vhost/name</li><li>清除一个参数：DELETE /api/parameters/{componenet_name}/vhost/name</li><li>列出指定 vhost 中的所有参数：GET /api/parameters</li></ul><h3 id="4-2-global级别Parameter"><a href="#4-2-global级别Parameter" class="headerlink" title="4.2 global级别Parameter"></a>4.2 global级别Parameter</h3><p>global 级别的 Parameter 的操作：</p><table><thead><tr><th>方式</th><th>详细内容</th></tr></thead><tbody><tr><td>rabbitmqctl</td><td>rabbitmqctl set_global_parameter name value<br>rabbitmqctl list_global_parameters<br>rabbitmqctl clear_global_parameter name</td></tr><tr><td>HTTP API接口</td><td>PUT /api/global-parameters/name<br>DELETE /api/global-parameters/name<br>GET /api/global-parameters/</td></tr></tbody></table><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list global parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_global_parameter name1 <span class="string">'&#123;&#125;'</span></span></span><br><span class="line">Setting global runtime parameter "name1" to "&#123;&#125;"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_global_parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br><span class="line">name1        []</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_global_parameter name1</span></span><br><span class="line">Clearing global runtime parameter "name1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_global_parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br></pre></td></tr></table></figure><h3 id="4-3-Policy"><a href="#4-3-Policy" class="headerlink" title="4.3 Policy"></a>4.3 Policy</h3><p>除了一些固定参数（ 比如 durable 或者 exclusive），客户端在创建交换器或者队列的时候可以配置一些可选参数来获得一些不同的功能，比如 x-message-ttl 或 x-expires 或 x-max-length 等。通过客户端设定的这些属性参数一旦设置成功就不能再改变（不能修改也不能添加），除非删除原来的交换器或队列之后再重新创建新的。</p><p>Policy 的介入就可以很好的解决这类问题，是一种特殊的Parameter的用法。</p><ul><li>Policy 是 vhost 级别的，一个 Policy 可以匹配多个队列或交换器，便于批量管理。</li><li>Policy 也支持动态的修改一些属性参数，提高了应用的灵活度。</li><li>一般用来配置Federation、镜像、备份交换器、死信等功能。</li></ul><p>rabbitmq_managemet 本身就提供了 Policy 的支持。可以在 【Admin】-&gt;【Policies】-&gt; 【Add / update a policy】中添加一个 Policy 。</p><p>参数： </p><ul><li>Virtual host ：表示当前 Policy 所在的 vhost 是哪个。 </li><li>Name ：表示当前 Policy 的名称。</li><li>Pattern ：一个正则表达式，用来匹配相关的队列或者交换器。 </li><li>Apply to ：用来指定当前 Policy 作用于哪一方。 共有三个选项：<ul><li>Exchanges and queues：表示作用与 Pattern 所匹配的所有队列和交换器；</li><li>Exchanges：表示作用于 Pattern 所匹配的所有交换器；</li><li>Queues：表示作用于与 Pattern 所匹配的所有队列。 </li></ul></li><li>Priority ：定义优先级，如果有多个 Policy 作用于同一个交换器或者队列，那么 Priority 最大的那个 Policy 才会有用 。</li><li>Definition ：定义一组或者多组键值对，为匹配的交换器或者队列附加相应的功能。</li></ul><p>作为一种 Paramter, Policy 也可以通过 rabbitmqctl 工具或者 HTTP API 接口来操 。与前面所讲的 Parameter 对应， rabbitmqctl 工具或者 HTTP API 接口各种都有 set、clear、list 的功能。</p><ul><li><p>用来设置一个 Policy：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy [-p vhost] [--priority priority] [--apply-to apply-to] &#123;name&#125; &#123;pattern&#125; &#123;definition&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例，设置默认的 vhost 中所有以<span class="string">"^amq."</span>开头的交换器为联邦交换器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy --apply-to exchanges --priority 1 p1 <span class="string">"^amq."</span> <span class="string">'&#123;"federation-upstream":"f1"&#125;'</span></span></span><br><span class="line">Setting policy</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root123 -XPUT -d <span class="string">'&#123;"pattern":"^amq\.","definition":&#123;"federation-upstream":"f1"&#125;,"priority":1,"apply-to":"exchanges"&#125;'</span> http://192.168.0.2:15672/api/policies/%2F/p1</span></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:36:20 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type : application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure></li><li><p>列出默认 vhost 所有的 Policy ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_policies [-p vhost] </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_policies </span></span><br><span class="line">Listing policies </span><br><span class="line">/  p1 exchanges ^amq. &#123;"federation-upstream":"f1"&#125;1</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XGET http://192.168.0.2:15672/api/policies/%2F</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:37:30 GMT</span><br><span class="line">content-length: 125</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">[&#123;"vhost":"/","name":"pl","pattern":"^amq\\.","apply-to":"exchanges","definition":&#123;"federation-upstream":"f1"&#125;,"priority":1&#125;]</span><br></pre></td></tr></table></figure></li><li><p>清除指定的 Policy ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_policy [-p vhost] &#123;name&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_policy p1</span></span><br><span class="line">Clearing policy "p1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XDELETE http://192.168.0.2:15672/api/policies/%2F/p1</span></span><br><span class="line"></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:38:55 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure><p>如果两个或多个 Policy 都作用到同一个交换器或者队列上，且这些 Policy 的优先级都是一样的，则参数项最多的 Policy 具有决定权。如果参数一样多，则最后添加的 Policy 具有决定权。</p></li></ul><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第五章《配置》，内容来自于《RabbitMQ实战指南》，内容包括：环境变量，配置文件，参数及策略。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（四）管理</title>
    <link href="http://linyishui.top/2020100201.html"/>
    <id>http://linyishui.top/2020100201.html</id>
    <published>2020-10-02T07:08:31.000Z</published>
    <updated>2020-10-06T12:41:01.662Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（四）管理"><a href="#RabbitMQ（四）管理" class="headerlink" title="RabbitMQ（四）管理"></a>RabbitMQ（四）管理</h1><h2 id="第一节-多租户与权限"><a href="#第一节-多租户与权限" class="headerlink" title="第一节 多租户与权限"></a>第一节 多租户与权限</h2><h3 id="1-1-什么是vhost？"><a href="#1-1-什么是vhost？" class="headerlink" title="1.1 什么是vhost？"></a>1.1 什么是vhost？</h3><p>每个 RabbitMQ 服务器都能创建虚拟的消息服务器，我们称之为虚拟主机（virtual host，简称为 vhost)。</p><ul><li>每一个 vhost 本质上是一个独立的小型 RabbitMQ 服务器；</li><li>拥有自己独立的队列、交换器及绑定关系等；</li><li>井且它拥有自己独立的权限。 </li><li>vhost 之间是绝对隔离的，无法将 vhostl 中的交换器与 vhost2 中的队列进行绑定，既保证了安全性，又可以确保可移植性。</li><li>建议用户对业务功能、场景进行归类 区分，并为之分配独立的 vhost。</li><li>vhost 是 AMQP 概念的基础，客户端在连接的时候必须制定一个 vhost。</li><li>默认的 vhost 是 <code>/</code> ，使用默认的用户名 guest 和密码 guest 就可以访问它。</li></ul><h3 id="1-2-常用指令"><a href="#1-2-常用指令" class="headerlink" title="1.2 常用指令"></a>1.2 常用指令</h3><p>创建新 vhost ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_vhost &#123;vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_vhost vhost1</span></span><br></pre></td></tr></table></figure><p>列表当前所有  vhost ：</p><ul><li>name：vhost名称；</li><li>tracing：是否使用trace功能。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts &#123;vhostinfoitem...&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts name tracing</span></span><br><span class="line">Listing vhosts</span><br><span class="line">vhost1 false</span><br><span class="line">/      false</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl trace_on</span></span><br><span class="line">Starting tracing for host "/"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts name tracing</span></span><br><span class="line">Listing vhosts</span><br><span class="line">vhost1 false</span><br><span class="line">/      true</span><br></pre></td></tr></table></figure><p>删除 vhost ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_vhost &#123;vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_vhost vhost1</span></span><br><span class="line">Deleting vhost "vhost1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts</span></span><br><span class="line">Listing vhosts</span><br></pre></td></tr></table></figure><p>vhost 授予用户权限：</p><ul><li>vhost：授予用户权限的vhost名称；</li><li>user：可以访问vhost的用户名；</li><li>conf：用于匹配用户在哪些资源上拥有可配置权限的正则表达式（指队列和交换器的创建和删除操作）；</li><li>write：用于匹配用户在哪些资源上拥有可写权限的正则表达式（指发布消息）；</li><li>read：用于匹配用户在哪些资源上拥有可读权限的正则表达式（指与消息有关的操作，如读取消息或清空队列）；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions &#123;-p vhost&#125; &#123;user&#125; &#123;conf&#125; &#123;write&#125; &#123;<span class="built_in">read</span>&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授予root：可访问vhost1，所有资源可配置 + 可写 + 可读权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions -p vhost1 root <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span></span><br><span class="line">Setting permissions for user "root" in vhost "vhost1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 授予root：可访问vhost2，<span class="string">"queue"</span>开头资源上可配置，所有资源可写 + 可读权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions -p vhost2 root <span class="string">"^queue.*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span></span><br><span class="line">Setting permissions for user "root" in vhost "vhost2"</span><br></pre></td></tr></table></figure><p>不同AMQP命令的列表和对应权限：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010101.png" alt></p><p>vhost 清除用户权限：禁止用户访问vhost</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_permissions &#123;-p vhost&#125; &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_permissions -p vhost1 root</span></span><br><span class="line">Clearing permissions for user "root" in vhost "vhost1"</span><br></pre></td></tr></table></figure><p>列表查询权限信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显式虚拟主机上的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_permissions &#123;-p vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显式用户的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_user_permissions &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_permissions -p vhost1</span></span><br><span class="line">Listing permissions in vhost "vhost1"</span><br><span class="line">root .* .* .*</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_user_permissions root</span></span><br><span class="line">Listing permissions for user "root"</span><br><span class="line">/      .* .* .*</span><br><span class="line">vhost1 .* .* .*</span><br></pre></td></tr></table></figure><p>rabbitmqctl 工具是用来管理 RabbitMQ 中间件的命令行工具，它通过连接各个 RabbitMQ 节点来执行所有操作。如果有节点没有运行，将显示诊断信息：不能到达或因不匹配的 Erlang cookie 而拒绝连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 标准语法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl [-n node] [-t timeout] [-q] &#123;<span class="built_in">command</span>&#125; [<span class="built_in">command</span> options]</span></span><br></pre></td></tr></table></figure><ul><li><code>[-n node]</code> ：默认节点 <code>rabbit@hostname</code> ，通常 <code>hostname -s</code> 命令输出是 <code>@</code> 标志后的东西。</li><li><code>[-t timeout]</code> ：操作超时时间。</li><li><code>[-q]</code> ：启用quiet模式，可以屏蔽一些消息。</li></ul><h2 id="第二节-用户管理"><a href="#第二节-用户管理" class="headerlink" title="第二节 用户管理"></a>第二节 用户管理</h2><p>在 RabbitMQ 中，用户是访问控制（Access Control) 的基本单元，且单个用户可以跨越多个 vhost 进行授权，同个用户针对多个 vhost 可以被赋予不同级别的访问权限。</p><h3 id="2-1-常用指令"><a href="#2-1-常用指令" class="headerlink" title="2.1 常用指令"></a>2.1 常用指令</h3><p>创建用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_user &#123;username&#125; &#123;password&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_user root root123</span></span><br><span class="line">Creating user "root"</span><br></pre></td></tr></table></figure><p>修改密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_password root root321</span></span><br></pre></td></tr></table></figure><p>清除密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_password &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_password root</span></span><br></pre></td></tr></table></figure><p>密码验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl authenticate_user &#123;username&#125; &#123;password&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl authenticate_user root root321</span></span><br></pre></td></tr></table></figure><p>删除用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_user &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_user root</span></span><br></pre></td></tr></table></figure><p>列表查询用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_users</span></span><br></pre></td></tr></table></figure><p>用户包括5种角色类型：</p><ul><li>none：无任何角色，新用户默认为none。</li><li>management：允许访问Web管理界面。</li><li>policymaker：可以管理策略和参数。</li><li>monitoring：可以看到所有连接、信道及节点的相关信息。</li><li>administrator：可以管理用户、虚拟主机、权限、策略、参数等。</li></ul><p>设置用户角色：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_user_tags &#123;username&#125; &#123;tag ...&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_user_tags root monitoring</span></span><br></pre></td></tr></table></figure><h2 id="第三节-Web端管理"><a href="#第三节-Web端管理" class="headerlink" title="第三节 Web端管理"></a>第三节 Web端管理</h2><h3 id="3-1-RabbitMQ-management"><a href="#3-1-RabbitMQ-management" class="headerlink" title="3.1 RabbitMQ management"></a>3.1 RabbitMQ management</h3><p>为了能够运行 rabbitmqctl 工具，当前的用户需要拥有访问 Erlang cookie 的权限，由于服务器可能是 guest 或者 root 用户身份来运行的，因此你需要获得这些文件的访问权限，这样就引申出来一些权限管理的问题。</p><p>RabbitMQ 开发了 RabbitMQ management ，由 Erlang 言编写，并且和 RabbitMQ 服务运行在同一个 Erlang 虚拟机中。提供了 Web 管理界面用来管理如前面所述的虚拟主机、用户等，也可以用来管理队列、交换器、绑定关系、策略、 参数等，还可以用来监控 RabbitMQ 服务的状态及一些数据统计类信息，可谓是功能强大，基本上能够涵盖所有 RabbitMQ 管理的功能。</p><h3 id="3-2-指令开启和关闭"><a href="#3-2-指令开启和关闭" class="headerlink" title="3.2 指令开启和关闭"></a>3.2 指令开启和关闭</h3><p>RabbitMQ插件的默认存放目录：<code>$RABBITMQ_HOME/plugins</code> ，格式为 <code>.ez</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rabbitmq-plugins语法格式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins [-n node] &#123;<span class="built_in">command</span>&#125; [<span class="built_in">command</span> options...]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> [plugin-name]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">disable</span> [plugin-name]</span></span><br></pre></td></tr></table></figure><p>开启 rabbitmq_management 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span></span><br><span class="line">Enabling plugins on node rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">rabbitmq_management</span><br><span class="line">The following plugins have been configured:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">Applying plugin configuration to rabbit@iZ2zeet6kto8eqx1w7sluzZ...</span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line"></span><br><span class="line">started 3 plugins.</span><br></pre></td></tr></table></figure><p>查看当前插件的使用情况：<code>[E*]</code> 表示显示启动，<code>[e*]</code> 表示隐式启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins list</span></span><br><span class="line">Listing plugins with pattern ".*" ...</span><br><span class="line"> Configured: E = explicitly enabled; e = implicitly enabled</span><br><span class="line"> | Status: * = running on rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line"> |/</span><br><span class="line">[  ] rabbitmq_amqp1_0                  3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_cache       3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_http        3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_ldap        3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_oauth2      3.8.8</span><br><span class="line">[  ] rabbitmq_auth_mechanism_ssl       3.8.8</span><br><span class="line">[  ] rabbitmq_consistent_hash_exchange 3.8.8</span><br><span class="line">[  ] rabbitmq_event_exchange           3.8.8</span><br><span class="line">[  ] rabbitmq_federation               3.8.8</span><br><span class="line">[  ] rabbitmq_federation_management    3.8.8</span><br><span class="line">[  ] rabbitmq_jms_topic_exchange       3.8.8</span><br><span class="line">[E*] rabbitmq_management               3.8.8</span><br><span class="line">[e*] rabbitmq_management_agent         3.8.8</span><br><span class="line">[  ] rabbitmq_mqtt                     3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_aws       3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_common    3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_consul    3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_etcd      3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_k8s       3.8.8</span><br><span class="line">[  ] rabbitmq_prometheus               3.8.8</span><br><span class="line">[  ] rabbitmq_random_exchange          3.8.8</span><br><span class="line">[  ] rabbitmq_recent_history_exchange  3.8.8</span><br><span class="line">[  ] rabbitmq_sharding                 3.8.8</span><br><span class="line">[  ] rabbitmq_shovel                   3.8.8</span><br><span class="line">[  ] rabbitmq_shovel_management        3.8.8</span><br><span class="line">[  ] rabbitmq_stomp                    3.8.8</span><br><span class="line">[  ] rabbitmq_top                      3.8.8</span><br><span class="line">[  ] rabbitmq_tracing                  3.8.8</span><br><span class="line">[  ] rabbitmq_trust_store              3.8.8</span><br><span class="line">[e*] rabbitmq_web_dispatch             3.8.8</span><br><span class="line">[  ] rabbitmq_web_mqtt                 3.8.8</span><br><span class="line">[  ] rabbitmq_web_mqtt_examples        3.8.8</span><br><span class="line">[  ] rabbitmq_web_stomp                3.8.8</span><br><span class="line">[  ] rabbitmq_web_stomp_examples       3.8.8</span><br></pre></td></tr></table></figure><p>还要再重启 RabbitMQ 服务使之生效。</p><p>关闭 <code>rabbitmq_management</code> 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_management</span></span><br></pre></td></tr></table></figure><h3 id="3-3-简单使用图形化工具"><a href="#3-3-简单使用图形化工具" class="headerlink" title="3.3 简单使用图形化工具"></a>3.3 简单使用图形化工具</h3><p>注意：阿里云服务器要在管理端配置入方向规则，开放15672端口。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010102.png" alt></p><p>尝试使用 guest 账号登录，但被拦截（如下），只允许本地地址访问。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010103.png" alt></p><p>使用 root 登录：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010104.png" alt></p><p>用户管理可以实现上节所有指令的功能：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010105.png" alt></p><p>可以指定用户角色：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010106.png" alt></p><p>新增了用户 <code>user01</code> ：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010107.png" alt></p><p>点击一个用户名，进入详情界面：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010108.png" alt></p><p>新用户没有指定虚拟主机，可以设置一个：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010109.png" alt></p><p>注意：有时Web管理界面可以正常登陆，但进入后显式部分页面，这种情况清空一下浏览器缓存即可。</p><h2 id="第四节-应用与集群管理"><a href="#第四节-应用与集群管理" class="headerlink" title="第四节 应用与集群管理"></a>第四节 应用与集群管理</h2><h3 id="4-1-应用管理"><a href="#4-1-应用管理" class="headerlink" title="4.1 应用管理"></a>4.1 应用管理</h3><p>停止 Erlang 虚拟机和 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop [pid_file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl shutdown</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop /opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@nodel.pid</span></span><br></pre></td></tr></table></figure><ul><li><code>stop [pid_file]</code> ：<ul><li>如果指定了 pid_file, 还需要等待指定进程的结束。</li><li>pid_file 是通过调用 <code>rabbitmq-server</code> 命令启动 RabbitMQ 服务时创建的，默认情况下存放于 Mnesia 目录中，可以通过 <code>RABBITMQ_PID_FILE</code> 这个环境变量来改变存放路径。</li><li>使用 <code>rabbitmq-server -detach</code> 这个带有 <code>-detach</code> 后缀的命令来启动 RabbitMQ 服务则不会生成 pid_file 文件。</li></ul></li><li><code>shutdown</code> ：<ul><li>执行这个命令会阻塞直到 Erlang 虚拟机进程退出。</li><li>和stop不同的是，不需要指定pid_file即可阻塞等待指定进程的关闭。</li></ul></li></ul><p>停止 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br></pre></td></tr></table></figure><ul><li>只停止 RabbitMQ 服务应用，Erlang 虚拟机还处于运行状态。</li></ul><p>启动 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app</span></span><br></pre></td></tr></table></figure><p>等待 RabbitMQ 应用的启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">wait</span> [pid_file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">wait</span></span></span><br><span class="line">/opt/rabbitmq/var/lib/rabbitmq/mnes a/rabbit\@nodel.pid</span><br></pre></td></tr></table></figure><ul><li>等待 pid_file 的创建，和对应进程启动。</li></ul><p>重置 RabbitMQ 节点（以及强制重置）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl reset</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl force_reset</span></span><br></pre></td></tr></table></figure><ul><li>重置操作将节点还原至最初状态。<ul><li>从所在集群删除此节点</li><li>从管理数据库中删除所有配置数据，如已配置的用户、vhost等</li><li>删除所有持久化消息。</li></ul></li><li>重置前要先停止 RabbitMQ 应用。</li><li>强制重置不同的是不会考虑集群和管理数据库的状态</li></ul><p>指示 RabbitMQ 节点轮换日志文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl rotate_logs &#123;suffix&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span> </span></span><br><span class="line">/opt/rabbitmq/var/log/rabbitmq</span><br><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br><span class="line">-rw-r--r-- 1 root root 1024127 Oct 18 11:56 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 720553 Oct 17 19:16 rabbit@node1-sasl.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原日志文件为 rabbit@node1.log 和 rabbit@node1-sasl.log</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl rotate_logs .1</span></span><br><span class="line">Rotating logs to files with suffix ".1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 轮换日志之后，原日志文件中的内容就被迫加到 rabbit@nodel.log.1 rabbit@node1-sasl.log.1 日志中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 18 12:05 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 1024202 Oct 18 12:05 rabbit@node1.log.1</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 18 12:05 rabbit@node1-sasl.log</span><br><span class="line">-rw-r--r-- 1 root root 720553 Oct 18 12:05 rabbit@node1-sasl.log.1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后重新建立 rabbit@node1.log 和 rabbit@node1-sasl.log 文件用来接收新的日志。</span></span><br></pre></td></tr></table></figure><ul><li>将原日志文件的内容追加到“原始名称+后缀”的日志文件中；</li><li>将新日志内容记录到新创建的日志中（同名），不存在会创建文件；</li><li>若不指定后缀，只会打开文件而不进行轮换。</li></ul><p>将 RabbitMQ 代码用 HiPE 编译，生成的 <code>.beam</code> 文件保存到指定文件目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl hipe_compile &#123;directory&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl hipe compile</span></span><br><span class="line">/opt/rabbitmq/tmp/rabbit-hipe/ebin</span><br><span class="line">HiPE compiling: |-----------------------------------------------|</span><br><span class="line">                |###############################################|</span><br><span class="line">Compiled 57 modules in 55s</span><br></pre></td></tr></table></figure><ul><li>如果要使用预编译的这些文件，则需要设置 RABBITMQ_SERVER_CODE_PATH 这个环境变量来指定 hipe_compile 调用的路径。</li></ul><h3 id="4-2-集群管理"><a href="#4-2-集群管理" class="headerlink" title="4.2 集群管理"></a>4.2 集群管理</h3><p>将节点加入指定集群中：（在这个命令执行前需要停止 RabbitMQ 应用并重置节点）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster &#123;cluster_node&#125; [--ram]</span></span><br></pre></td></tr></table></figure><p>显式集群的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure><p>修改集群节点的类型：（在这个命令执行前需要停止 RabbitMQ 应用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_cluster_node_type &#123;disc|ram&#125;</span></span><br></pre></td></tr></table></figure><p>将节点从集群中删除，允许离线执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl forget_cluster_node [--offline]</span></span><br></pre></td></tr></table></figure><p>在集群中的节点应用启动前咨询 clusternode 节点的最新信息，并更新相应的集群信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl update_cluster_nodes &#123;clusternode&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>和 join_cluster 不同 ，它不加入集群。</p></li><li><p>使用案例：考虑这样一种情况，节点A和节点B都在集群 中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B但是这样会失败，因为节点B经不在集群中了。 <code>Rabbitmqctl update_cluster_nodes -n A C</code> 可以解决这种场景下出现的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 假设己有 node1 和 node 组成的集群</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1. 初始状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br><span class="line">[</span><br><span class="line"> &#123;nodes, [&#123;disc , [rabbit@node1, rabbit@node2]&#125;]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;running_nodes, [rabbit@node2, rabbit@node1]&#125;,</span><br><span class="line"> &#123;cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions, []&#125;,</span><br><span class="line"> &#123;alarms, [</span><br><span class="line">     &#123;rabbit@node2, []&#125;, </span><br><span class="line">           &#123;rabbit@node1, []&#125; </span><br><span class="line">          ]</span><br><span class="line"> &#125; </span><br><span class="line">]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#2. 关闭 node1 节点的应用</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#3. 之后将 node3 加入到集群中 </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster rabbit@node2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#4. 再将 node2 节点的应用关闭</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#5. 最后启动 node1 节点的应用，此时会报错</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app </span></span><br><span class="line">Starting node rabbit@node1</span><br><span class="line">BOOT FAILED</span><br><span class="line">==========</span><br><span class="line">Timeout contacting cluster nodes : [rabbit@node2] . </span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#6. 如果在启动 node1 节点的应用之前咨询 node3 并更新相关集群信息则可以解决这个问题</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl update_cluster_nodes rabbit@node3</span></span><br><span class="line">Updating cluster nodes for rabbit@node1 from rabbit@node3</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app </span></span><br><span class="line">Starting node rabbit@node1</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#7. 查看最终集群状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure></li></ul><p>确保节点可以启动，即使它不是最后一个关闭的节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl force_boot</span></span><br></pre></td></tr></table></figure><ul><li>通常情况下，当关闭整个 RabbitMQ 集群时，重启的第一个节点应该是最后关闭的节点，因为它可以看到其他节点所看不到的事情。</li><li>有时会有一些异常情况出现，比如整个集群都掉电而所有节点都认为它不是最后关闭 的。</li><li>这时可以调用 <code>rabbitmqctl force_boot</code> 命令，告诉节点可以无条件地启动节点 。在此节点关闭后，集群的任何变化，它都会丢失。</li><li>如果最后一个关闭的节点永久 丢失了，那么需要优先使用 <code>rabbitmqctl forget_cluster_node --offline</code> 命令，因 为它可以确保镜像队列的正常运转。</li></ul><p>指示未同步队列 queue 的 slave 镜像可以同步 master 镜像行的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl sync_queue [-p vhost] &#123;queue&#125;</span></span><br></pre></td></tr></table></figure><ul><li>同步期间此队列会被阻塞（所有此队列的生产消费者都会被阻塞），直到同步完成。</li><li>执行成功的前提是队列 queue 配置了镜像。</li><li>未同步队列中的消息被耗尽后，最终也会变成同步，此命令主要用于未耗尽的队列。</li></ul><p>取消队列 queue 同步镜像的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cancel_sync_queue [-p vhost] &#123;queue&#125;</span></span><br></pre></td></tr></table></figure><p>设置集群名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_cluster_name &#123;name&#125;</span></span><br></pre></td></tr></table></figure><ul><li>集群名称在客户端连接时会通报给客户端。</li><li>默认是集群中第一个节点的名称。</li></ul><h2 id="第五节-服务端状态"><a href="#第五节-服务端状态" class="headerlink" title="第五节 服务端状态"></a>第五节 服务端状态</h2><p>服务器状态的查询会返回一个以制表符分隔的列表，此类命令接受一个可选 vhost 参数以显示其结果， 默认值为 <code>/</code> ：</p><ul><li>list_queues </li><li>list_exchanges </li><li>list_bindings </li><li>list_consumers </li></ul><h3 id="5-1-list-queues"><a href="#5-1-list-queues" class="headerlink" title="5.1 list_queues"></a>5.1 list_queues</h3><p>此命令返回队列的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_queues [-p vhost] [queueinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>queueinfoitem</code> 参数用于指示哪些队列的信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>name ：队列名称。</li><li>durable ：队列是否持久化。</li><li>auto_delete ：队列是否自动删除。</li><li>arguments ：队列的参数。</li><li>policy ：应用到队列上的策略名称。</li><li>pid：队列关联的 Erlang 进程的 ID。</li><li>owner_pid ：处理排他队列连接的 Erlang 进程。如果此队列是非排他的，此值将为空。 </li><li>exclusive ：队列是否是排他的。</li><li>exclusive_consumer_pid ：订阅到此排他队列的消费者相关的信道关联的 Erlang 进程。如果此队列是非排他的，此值将为空。</li><li>exclusive_consumer_tag ：订阅到此排他队列的消费者的 consumerTag 如果此队列是非排他的，此值将为空。 </li><li>messages_ready ：准备发送给客户端的消息个数。</li><li>messages_unacknowledged ：发送给客户端但尚未应答的消息个数。messages ：准备发送给客户端和未应答消息的总和。</li><li>messages_ready_ram ：驻留在内存中 messages_ready 的消息个数。</li><li>messages_unacknowledged_ram ：驻留在内存中。messages_unacknowledged 的消息个数。</li><li>messages ram ：驻留在内存中的消息总数。</li><li>messages_persistent ：队列中持久化消息的个数，对于非持久化队列来说总是0。</li><li>messages_bytes ：队列中所有消息的大小总和。不包括消息属性或者任何其他开销。 </li><li>messages_bytes_ready ：准备发送给客户端的消息的大小总和。 </li><li>messages_bytes_unacknowledged ：发送给客户端但尚未应答的消息的大小总和。</li><li>messages_bytes_ram：驻留在内存中的 messages_bytes。</li><li>messages_bytes_persiste ：队列中持久化的 messages_bytes。</li><li>disk_reads ：从队列启动开始，己从磁盘中读取该队列的消息总次数。 </li><li>disk_writes ：从队列启动开始，己向磁盘队列写消息的总次数。 </li><li>consumer ：消费者数目。 </li><li>consumer_utilisation ：队列中的消息能够立刻投递给消费者的比率，介于0或1之间 。这个受网络拥塞或者 Basic.Qos 的影响而小于1。</li><li>memory ：与队列相关的 Erlang 进程所消耗的内存字节数，包括栈、堆及内部结构。</li><li>slave_pids ：如果队列是镜像的，列出所有 slave 镜像的 pid。</li><li>synchronised_slave_pids ：如果队列是镜像的，列出所有己经同步的 slave 镜像 pid。</li><li>state ：队列状态。正常情况下是 running ；如果队列正常同步数据可能会有 <code>{syncing, MsgCount}</code> 的状态；如果队列所在的节点掉线了，则队列显示状态为 down （此时大多数的 queueinfoitems 也将不可用）。</li></ul><p>如果没有指定 queueinfoitems ，那么此命令将显示队列的名称和消息的个数。</p><h3 id="5-2-list-exchanges"><a href="#5-2-list-exchanges" class="headerlink" title="5.2 list_exchanges"></a>5.2 list_exchanges</h3><p>返回交换器的详细细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_exchanges [-p vhost] [exchangeinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>exchangeinfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>name ：交换器的名称。 </li><li>type ：交换器的类型。 </li><li>durable ：设置是否持久化。 durable 设置为 true 表示持久化，反之是非持久化。持久化可以将交换器信息存盘而在服务器重启的时候不会丢失相关信息。 </li><li>auto_delete ：设直是否自动删除。 </li><li>internal ：是否是内置的。 </li><li>arguments ：其他一些结构化参数，比如 alternate-exchange </li><li>policy ：应用到交换器上的策略名称。</li></ul><p><code>exchangeinfoitem</code> 的内容和客户端中的 <code>channel.exchangeDeclare</code> 方法的参数基本一致。</p><h3 id="5-3-list-bindings"><a href="#5-3-list-bindings" class="headerlink" title="5.3 list_bindings"></a>5.3 list_bindings</h3><p>返回绑定关系的细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_bindings [-p vhost] [bindinginfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>bindinginfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>source_name ：绑定中消息来源的名称。 </li><li>source_kind ：绑定中消息来源的类别。 </li><li>destination_name ：绑定中消息目的地的名称。 </li><li>destination_kind ：绑定中消息目的地的种类。 </li><li>routing_key ：绑定的路由键。 </li><li>arguments ：绑定的参数。</li></ul><h3 id="5-4-list-connections"><a href="#5-4-list-connections" class="headerlink" title="5.4 list_connections"></a>5.4 list_connections</h3><p>返回 TCP/IP 连接的统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_connections [connectioninfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>connectioninfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>pid ：与连接相关的 Erlang 进程 ID </li><li>name ：连接的名称。 </li><li>port ：服务器端口。</li><li>host ：返回反向 DNS 获取的服务器主机名称，或者 IP 地址，或者未启用。</li><li>peer_port ：服务器对端端口。当一个客户端与服务器连接时，这个客户端的端口就是 peer_port 。</li><li>peer_host ：返回反向 DNS 获取的对端主机名称，或者 IP 地址， 或者未启用。 </li><li>ssl ：是否启用 SSL 。</li><li>ssl_protocol ：SSL 协议，如 tlsvl 。</li><li>ssl_key_exchange ：SSL 密钥交换算法，如 rsa 。</li><li>ssl_cipher ：SSL 加密算法，如 aes_256_cbc 。</li><li>ssl_hash ：SSL 哈希算法，如 sha 。</li><li>peer_cert_subject ：对端的 SSL 安全证书的主题，基于 RFC4514 的形式。 peer_cert_issuer ：对端 SSL 安全证书的发行者， 基于 RFC4514 的形式。 </li><li>peer_cert_validity ：对端 SSL 安全证书的有效期。 </li><li>state ：连接状态，包括 starting、tuning、opening、running、flow、blocking、blocked、closing、closed 这几种。 </li><li>channels ：该连接中的信道个数。 </li><li>protocol ：使用的 AMQP 协议的版本，当前是｛0,9,1｝或者｛0,8,0｝。注意，如果客户端请求的是 AMQP 0-9 的连接， RabbitMQ 也会将其视为 0-9-1 。</li><li>auth_mechanism ：使用的 SASL 认证机制，如 PLAIN、AMQPLAIN、EXTERNAL、RABBIT-CR-DEMO 等。</li><li>user ：与连接相关的用户名。 </li><li>vhost ：与连接相关的 vhost 的名称。 </li><li>timeout ：连接超时／协商的心跳间隔，单位为秒。 </li><li>frame_max ：最大传输帧的大小，单位为 B 。</li><li>channel_max ：此连接上信道的最大数量。如果值 0，则表示无上限，但客户端一般会将0转变为 65535 。</li><li>client_properties ：在建立连接期间由客户端发送的信息属性。 </li><li>recv_oct ：收到的字节数。 </li><li>recv_cnt ：收到的数据包个数。</li><li>send_oct ：发送的字节数。 </li><li>send_cnt ：发送的数据包个数。 </li><li>send_pend ：发送队列大小。 </li><li>connected_at ：连接建立的时间戳。</li></ul><h3 id="5-5-list-channels"><a href="#5-5-list-channels" class="headerlink" title="5.5 list_channels"></a>5.5 list_channels</h3><p>返回当前所有信道的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_channels [channelinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>channelinfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>pid ：与连接相关的 Erlang 进程 ID 。</li><li>connection ：信道所属连接的 Erlang 进程 ID 。</li><li>name ：信道的名称。 </li><li>number ：信道的序号。 </li><li>user ：与信道相关的用户名称。 </li><li>vhost ：与信道相关的 vhost 。</li><li>transactional ：信道是否处于事务模式。 </li><li>confirm ：信道是否处于 publiser confirm 模式。 </li><li>consumer_count ：信道中的消费者的个数。 </li><li>messages_unacknowledged ：已投递但是还未被 ack 的消息个数。</li><li>messages_uncommitted ：已接收但是还未提交事务的消息个数。</li><li>acks_uncommitted ：已 ack 收到但是还未提交事务的消息个数。</li><li>messages_unconfirmed ：已发送但是还未确认的消息个数。如果信道不处于 publisher confirm 模式下，则此值为 0 。</li><li>perfetch_count ：新消费者的 Qos 个数限制，0 表示无上限。</li><li>global_prefetch_count ：整个信道的 Qos 个数限制，0 表示无上限。</li></ul><h3 id="5-6-list-consumers"><a href="#5-6-list-consumers" class="headerlink" title="5.6 list_consumers"></a>5.6 list_consumers</h3><p>列举消费者信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_consumers [-p vhost]</span></span><br></pre></td></tr></table></figure><p>每行将显示由制表符分隔的己订阅队列的名称、相关信道的进程标识、 consumerTag、是否需要消费端确认、 prefetch_count 及参数列表这些信息。</p><h3 id="5-7-其它"><a href="#5-7-其它" class="headerlink" title="5.7 其它"></a>5.7 其它</h3><p>显示 Broker 状态，比如当前 Erlang 节点上运行的应用程序、RabbitMQ/Erlang 的版本信息、 OS 的名称、内存及文件描述符等统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl status</span></span><br></pre></td></tr></table></figure><p>对 RabbitMQ 节点进行健康检查，确认应用是否正常运行、list_queues 和 list_channels 是否能够正常返回等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl node_health_check</span></span><br></pre></td></tr></table></figure><p>显示每个运行程序环境中每个变量的名称和值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl environment</span></span><br></pre></td></tr></table></figure><p>为所有服务器状态生成一个服务器状态报告，井将输出重定向到一个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl report</span></span><br></pre></td></tr></table></figure><p>执行任意 Erlang 表达式：（此处暂时不作eval扩展）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">eval</span> &#123;expr&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第六节-HTTP-API接口管理"><a href="#第六节-HTTP-API接口管理" class="headerlink" title="第六节 HTTP API接口管理"></a>第六节 HTTP API接口管理</h2><h3 id="6-1-HTTP-API接口功能"><a href="#6-1-HTTP-API接口功能" class="headerlink" title="6.1 HTTP API接口功能"></a>6.1 HTTP API接口功能</h3><p>RabbitMQ Management 插件不仅提供了 Web 管理界面，还提供了 HTTP API 接口来方便调用。比如创建一个队列，就可以通过 PUT 方法调用 <code>/api/queues/vhost/name</code> 接口来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root123 -H <span class="string">"content-type:application/json"</span></span></span><br><span class="line">-XPUT -d '&#123;"auto_delete":false,"durable":true,"node":"rabbit@node2"&#125;' </span><br><span class="line">http://192.168.0.2:15672/api/queues/%2F/queue</span><br><span class="line"></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Fri, 25 Aug 2017 06:03:17 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure><p><code>%2F</code> 即 <code>/</code> 默认的 vhost，特殊字符需要在HTTP URL中进行转义。</p><p>完全基于 RESTful 风格：</p><ul><li>GET 方法一般用来获取如集群、节点、队列、交换器等信息。</li><li>PUT 方法用来创建资源，如交换器、队列之类的。</li><li>DELETE 方法用来删除资源。</li><li>POST 方法也是用来创建资源的，与 PUT 不同的是，POST 创建的是无法用具体名称的资源。比如绑定关系（bindings）和发布消息（publish）无法指定一个具体的名称。</li></ul><h3 id="6-2-接口列表"><a href="#6-2-接口列表" class="headerlink" title="6.2 接口列表"></a>6.2 接口列表</h3><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 10%;}table th:nth-of-type(3){width: 10%;}table th:nth-of-type(4){width: 10%;}table th:nth-of-type(5){width: 60%;}</style><table><thead><tr><th style="text-align:center">GET</th><th style="text-align:center">PUT</th><th style="text-align:center">DELETE</th><th style="text-align:center">POST</th><th>Path &amp; Description</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/overview <br>描述整个系统的各种信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/cluster-name <br>集群的名称</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/nodes <br>集群中节点的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/nodes/name <br>集群中单个节点的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/extensions <br>管理插件的扩展列表</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/definitions <br>GET 方法列出集群中所有的元数据信息，包括交换器、队列、绑定关系、用户、 host 权限及参数。<br>POST 方法用来加载新的元数据信息，不过需要注意如下内容： <br>(1）新的原数据信息会与原本的合并，如果旧的元数据信息中某些项在新加载的 元数据中没有定义， 则不受任何影响<br> (2）对于交换器、队列及绑定关系等不可变的内容，如果新旧元数据有冲突，则会报错 <br>(3）对于其他的可变的内容，如果新旧元数据有冲突，则新的会替换旧的<br> (4）如果在加载过程中发生错误，加载过程会停止，最终只能加载到部分新的元数据信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/definitions/vhost<br>将/api/definitions 接口细化到 vhost 级别，其余内容同上</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/connections<br>所有的连接信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/vhost/connections<br>指定的 vhost 中所有连接信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/connections/name<br>GET 方法列出指定连接的信息<br>DELETE 方法可以 close 指定的连接</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/connections/name/channels<br>指定连接的所有信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/channels<br>所有信道的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/vhost/channels <br>指定的 vhost 中所有信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/channels/channel <br>指定的信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/consumers <br>所有的消费者信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/consumers/vhost <br>指定 vhost 中的所有消费者信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges <br>所有交换器信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost <br>指定 vhost 中所有交换器信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/exchanges/vhost/name<br>GET 方法列出一个指定的交换器信息。<br>PUT 方法可以声明一个交换器，对应的内容可以参考如下： <br>{“type”:”direct”,”auto_ delete”:false,”durable”:true ,”internal”:false,”arguments”:{}} <br>其中 type 是必需的，其他都是可选的。 <br>DELETE 方法可以删除指定的交换器，其中可以添加 if-unused=true 参数用来防止有队列与其绑定时能够被删除</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost/name/bindings/source<br>列出指定交换器的所有绑定关系，此交换器需为绑定关系的源端</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost/name/bindings/destination<br>列出指定交换器的所有绑定关系，此交换器帘为绑定关系的目的端</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/exchanges/vhost/name/publish<br>向指定的交换器中发送一条消息，对应的内容可以参考： <br>{“properties”:{},”routing_key”,”my key”,”payload:”my body”,”payload_ encoding”:”string”} <br>这里所有的项都是必需的，如果发送成功，会返回 ｛”routed”:true} 。这个接口不适合做稳定、高效的发送之用 ，以采用其他的方式比如通过 AMQP 协议或者其他长连接的协议</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues<br>列出所有的队列信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues/vhost<br>列出指定的 vhost 下所有的队列信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/queues/vhost/name<br>GET 方法列出执行的队列信息<br>PUT 方法可声明一个队列，对应的内容可以参考： <br>{“auto_delete”:false,”durable”:true,”arguments”:{},”node”:”rabbit@smacmullen”} <br>其中所有的项都是可选的。 <br>DELETE 方法用来删除一个队列，当然可以指定 if-empty 或 if-unused 参数</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues/vhost/name/bindings<br>列出指定队列的所有绑定关系</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/queues/vhost/name/contents<br>清空（purge）指定的队列</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/queues/vhost/name/actions<br>对指定的队列附加一些动作，对应的内容可以参考：<br>{“action”:”sync”｝ <br>目前仅支持 sync 和 cancel_sync</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/queues/vhost/name/get<br>从指定队列中获取消息，对应的内容可以参考： <br>{“count”:5,”requeue”:true,”encoding”:”auto”,”truncate”:50000}<br>count 表示最大能获取的消息个数，实际可能小于这个值；requeue 表示获取到这些消息时是否从队列中删除，如果 requeue 为 true ，则消息不会被删除，但是消息的 redelivered 标示会被设置；encoding 表示编码格式，两种取值：auto 和 base64，auto 指如果消息符合 UTF-8 格式则返回 string 类型，否则为 base64 类型； truncate表示如果消息的 payload 过指定大小会被截断。除了 truncate 其余项都是必需的。注意这个接口是用来做测试用的，如果要持续的消费队列的消息，需要采用其他的方法</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/bindings<br>列出所有绑定关系的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/bindings/vhost<br>列出指定的 vhost 中所有绑定关系的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/bindings/vhost/e/exchange/q/queue<br>GET 方法列出一个指定的交换器和一个指定的队列中的所有绑定关系的信息。注意一个交换器和一个队列之间可以绑定多次.。<br>POST 用来添加绑定关系，对应的内容可以参考：<br> {“routing_ key”:”my_routing_ key”,”arguments”:{}} 其中所有的项都是可选的</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/bindings/vhost/e/exchange/q/queue/props<br>GET 方法列出一个交换器和一个队列的一个单独的绑定关系的信息 <br>DELETE 方法用来解绑相应的绑定关系，其中 props 表示的是 /api/bindings 返回的绑定关系列表里的 properties_key 的值，具体是指绑定时 routingkey 与 arguments 的哈希值的组合，一般 arguments 为空，此时 properties_key 等于 routingkey</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/bindings/vhost/e/source/e/destination<br>GET 方法用来列出两个交换器的所有绑定关系的信息<br>POST 方法用来添加绑定关系，与接口 /api/bindings/vhost/e/exchange/q/queue 相似</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/bindings/vhost/e/source/e/destination/props<br>与接口/api/bindings/vhost/e/exchange/q/queue/props 相似，只不过是两个交换器之间的关系</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts<br>列出所有 vhost 的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/vhosts/name <br>GET 方法列出指定 vhost 的信息<br>PUT 方法用来添加 vhost，host 通常只有一个名字，所以不需要任何内容以做请求之用。<br>DELETE 方法用来删除 vhost</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/name/permissions<br>列出指定 vhost 的所有权限信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/users<br>列出所有的用户信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/users/name<br>GET 方法列出指定的用户信息<br>POST 方法用来添加一个用户，对应的内容参考：<br>{“password”:”secret”,”tags”:”administrator”} <br>或者<br>{“password_hash”:”2lmotb814HODViLaK9Fxi619ds8=”,”tags”:”administrator”} <br>其中 tags 是必需的，用来标识用户角色。对于 password 或者 password_hash，两者可以择其一。 如果 password_hash 为“”，则用户可以无密码登录。<br>DELETE 方法用来删除指定的用户</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/users/user/permissions<br>用来获取指定用户的所有权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/wboami<br>当前的登录用户</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/perrnissions<br>列出所有用户的所有权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/permissions/vhost/user<br>GET 方法列出指定的权限<br>PUT 方法添加指定的权限，对应的内容惨考：<br>{“configure”:”.*“,”write”:”.*“,”read”:”.*“} <br>所有项都是必需的，对应 configure、write、read 的细节可以参考 5.1节 <br>DELETE 方法用来删除指定的权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters<br>列出所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters/component<br>列出指定组件（比如 federation-upstream、shovel 等）的所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters/component/vhost<br>列出指定 vhost 和组件的所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/parameters/component/vhost/name<br>GET 方法列出一个指定的 vbost 级别的 Parameter<br>PUT 方法用来设置一个 Parameter ，对应的内容参考如下：<br> {“vhost”:”/“,”component”:”federation”,”name”:”local_username”,”value”:”guest”} <br>DELETE 方法用来删除一个指定的 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/global-parameters<br>列出所有的 global 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/global-parameters/name<br>GET 方法列出一个指定的 global 级别的 Parameter<br>PUT 方法用来设置一个指定的 global 级别的 Parameter，对应的内容参考：<br>{“name”:”user_ vhost_mapping”,”value”:{“guest”:”/“,”rabbit”:”warren”}}<br>DELETE 方法用来删除一个指定的 global 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/policies<br>列出所有的 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/policies/vhost<br>列出指定 vhost 下的所有 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/policies/vhost/name<br>GET 方法列出指定的 Policy<br>PUT 方法用来设置 Policy 对应的内容可以参考：<br>{“pattern”:”^amq.”,”definition”: {“federation-upstream-set”:”all”}, “priority”:0, “apply-to”:”all”} <br>其中 pattern 和 definition 是必需的，其余可选。<br>DELETE 方法用来删除一个指定的 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>api/aliveness-test/vhost<br>声明一个队列，并基于其上生产和消费一条消息，用来测试系统是否运行完好。这个接口可以方便一些监控工具〈如 Zabbix ）的调用。如果系统运行完好，调用这接口会返回 {“status”:”ok”}，状态码为 200</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/healthchecks/node<br>对当前节点中进行基本的健康检查，包括 RabbitMQ 应用、信道、队列是否正常运行且无告警。如果一切正常则接口返回：<br>{“status”:”ok”} <br>如果有异常则接口返回： <br>{“status”:”failed”,”reason”,”string”} <br>不管正常与否，状态都是 200</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/healthchecks/node/node<br>对指定节点进行基本的健康检查，其余同 /api/healthchecks/node</td></tr></tbody></table><p>创建、显示和删除队列 queue 可以这样实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin -u root -p rootl23 <span class="built_in">declare</span> queue name=queue1</span></span><br><span class="line">queue declared </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin list queues</span></span><br><span class="line">+--------+----------+</span><br><span class="line">|  name  | messages |</span><br><span class="line">+--------+----------+</span><br><span class="line">| queue1 |  0       |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin -u root -p rootl23 delete queue name=queue1</span></span><br><span class="line">queue deleted</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin list queues</span></span><br><span class="line">No items</span><br></pre></td></tr></table></figure><p>rabbitmqadmin 需要安装，可以通过Web管理界面左下角 【Command Line】进行下载，或者如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://192.168 0.2:15672/cli/rabbitmqadmin</span></span><br><span class="line">--2017-08-25 17:32:50-- http://192.168.0.2:15672/cli/rabbitmqadmin</span><br><span class="line">Connecting to 192.168.0.2:15672 ... connected.</span><br><span class="line">HTTP request sent, awaiting response ... 200 OK</span><br><span class="line">Length: 36192 (35K) [application/octet-stream]</span><br><span class="line">Saving to "rabbitmqadmin"</span><br><span class="line"><span class="meta">100%</span><span class="bash">［＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＞］ 36,192 --.-K/s .<span class="keyword">in</span> 0s</span></span><br><span class="line">2017-08-25 17:32:50 (372 MB/s) - "rabbitmqadmin" saved [36192/36192]</span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x rabbitmqadmin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保已安装python</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python </span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取使用方式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第四章《管理》，内容来自于《RabbitMQ实战指南》，从服务端的角度介绍 RabbitMQ 的一些工具应用，内容包括：rabbitmqctl 工具和 rabbitmq management 插件。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（三）进阶</title>
    <link href="http://linyishui.top/2020092801.html"/>
    <id>http://linyishui.top/2020092801.html</id>
    <published>2020-09-28T05:34:23.000Z</published>
    <updated>2020-10-02T07:58:24.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="第一节-消息何去何从"><a href="#第一节-消息何去何从" class="headerlink" title="第一节 消息何去何从"></a>第一节 消息何去何从</h2><h3 id="1-1-消息不可达时返回给生产者"><a href="#1-1-消息不可达时返回给生产者" class="headerlink" title="1.1 消息不可达时返回给生产者"></a>1.1 消息不可达时返回给生产者</h3><p> <code>channel.basicPublish</code> 两个容易混淆的参数：都可以在消息传递过程不可达目的地时将消息返回给生产者。</p><ul><li><p>mandatory：为 true 时，且交换器无法根据自身的类型和路由键找到一个符合条件的队列，调用 <code>Basic.Return</code> 命令将消息返回给生产者。为 false 时，消息直接被丢弃。</p><p>如下代码，输出 <code>&quot;Basic.Return 返回的结果是：mandatory test&quot;</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">true</span>,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        <span class="string">"mandatory test"</span>.getBytes());</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用channel.addReturnListener添加ReturnListener监听器来使生产者获取是否被正确路由到合适队列</span></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 AMQP.BasicProperties basicProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">"Basic.Return 返回的结果是："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMQP协议中对应的流转过程：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010165.png" alt></p></li><li><p>immediate：为true时，若交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时， 该消息会通过 <code>Basic.Return</code> 返回至生产者。</p><ul><li>RabbitMQ 3.0 时去除了对此参数的支持，会影响镜像队列的性能，建议用TTL和DLX方法替代。</li></ul></li></ul><p>概括来说， mandatory 参数告诉服务器至少将该消息路由到一个队列中，否则将消息返回给生产者。 immediate 参数告诉服务器，如果该消息关联的队列上有消费者，则立刻投递；如果所有匹配的队列上都没有消费者，则直接将消息返还给生产者，不用将消息存入队列而等待消费者了。</p><h3 id="1-2-备份交换器"><a href="#1-2-备份交换器" class="headerlink" title="1.2 备份交换器"></a>1.2 备份交换器</h3><p><strong>备份交换器</strong>，英文名称为 <strong>Alternate Exchange</strong> ，简称<strong>AE</strong>，或者更直白地称之为“备胎交换器”。</p><p>生产者在发送消息的时候如果不设置 mandatory 参数，那么消息在未被路由的情况下将会丢失；如果设置了 mandatory 参数，那么需要添加 ReturnListener 的编程逻辑，生产者的代码将变得复杂。</p><p><strong>既不想复杂化生产者的编程逻辑，又不想消息丢失，可以使用备份交换器</strong>，这样可以将未被路由的消息存储在 RabbitMQ 中，再在需要的时候去处理这些消息。</p><p><strong>消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。</strong></p><h4 id="1-2-1-实现方式"><a href="#1-2-1-实现方式" class="headerlink" title="1.2.1 实现方式"></a>1.2.1 实现方式</h4><p><strong>实现方式</strong>：</p><ul><li>调用 <code>channel.exchangeDeclare()</code> 时添加 <code>alternate-exchange</code> 参数实现；</li><li>通过策略（Policy）方式实现。默认第一种优先级高。</li></ul><p>添加 <code>alternate-exchange</code> 参数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"alternate-exchange"</span>, <span class="string">"myAe"</span>);</span><br><span class="line"><span class="comment">// 声明两个交换器，分别绑定相应队列</span></span><br><span class="line"><span class="comment">// 并且设置myAe为normalExchange的备份交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"normalExchange"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">channel.exchangeDeclare(<span class="string">"myAe"</span>, <span class="string">"fanout"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"normalQueue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"normalQueue"</span>, <span class="string">"normalExchange"</span>, <span class="string">"normalKey"</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"unroutedQueue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"unroutedQueue"</span>, <span class="string">"myAe"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>此时发送一条消息到交换器normalExchange，当路由键等于normalKey时，消息可以正确路由到队列normalQueue；否则消息会发送给备份交换器myAe，并发送到队列unroutedQueue。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010166.png" alt></p><p>策略实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy AE <span class="string">"^normalExchange$"</span> <span class="string">'&#123;"alternate-exchange": "myAE"&#125;'</span></span></span><br></pre></td></tr></table></figure><p><strong>建议设置备份交换器为 fanout 类型</strong>：如果备份交换器的类型是 direct 并且有一个与其绑定的队列，假设绑定的路由键是 key1 当某条携带路由键为 key2 的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失。如果消息携带的路由键为 key1 ，则可以存储到队列中。</p><h4 id="1-2-2-特殊情况"><a href="#1-2-2-特殊情况" class="headerlink" title="1.2.2 特殊情况"></a>1.2.2 特殊情况</h4><ul><li>如果设置的备份交换器不存在，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li><li>如果备份交换器没有绑定任何队列，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li><li>如果备份交换器没有任何匹配的队列，客户端和 RabbitMQ 服务端都不会有异常出现， 此时消息会丢失。</li><li>如果备份交换器和 mandatory 参数一起使用，那么 mandatory 参数无效。</li></ul><h2 id="第二节-过期时间-TTL"><a href="#第二节-过期时间-TTL" class="headerlink" title="第二节 过期时间(TTL)"></a>第二节 过期时间(TTL)</h2><p>过期时间（Time to Live，TTL），可以对消息和队列设置TTL。</p><h3 id="2-1-设置消息的TTL"><a href="#2-1-设置消息的TTL" class="headerlink" title="2.1 设置消息的TTL"></a>2.1 设置消息的TTL</h3><p>设置方式：</p><ul><li><p><strong>通过队列属性设置</strong>，队列内所有消息都有相同的TTL；</p><ul><li><p>在 <code>channel.queueDeclare()</code> 中加入 <code>x-message-ttl</code> 参数，单位毫秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"x-message-ttl"</span>, <span class="number">6000</span>);</span><br><span class="line">channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);</span><br></pre></td></tr></table></figure></li><li><p>通过策略-Policy来设置TTL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy TTL <span class="string">".*"</span> <span class="string">'&#123;"message-ttl":60000&#125;'</span> --apply-to queues</span></span><br></pre></td></tr></table></figure></li><li><p>通过调用HTTP API接口设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root -H <span class="string">"content-type:application/json"</span>-X PUT -d<span class="string">'&#123;"auto_delete":false,"durable":true,"arguments":&#123;"x-message-ttl": 60000&#125;&#125;'</span> http://localhost:15672/api/queues/&#123;vhost&#125;/&#123;queuename&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>对消息本身进行单独设置</strong>，两种一起使用以较小的值为准。</p><ul><li><p>在 <code>channel.basicPublish()</code> 中加入 expiration 属性参数，单位毫秒：(消息过期后马上从队列抹去，因为过期消息都在队列头部，只要定期扫描头部并删除即可)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line"><span class="comment">// 持久化消息</span></span><br><span class="line">builder.deliveryMode(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 设置TTL=60000ms</span></span><br><span class="line">builder.expiration(<span class="string">"60000"</span>);</span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties. <span class="string">"ttlTestMessage"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties;</span><br><span class="line"><span class="comment">// 持久化消息</span></span><br><span class="line">properties.setDeliveryMode(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 设置TTL=60000ms</span></span><br><span class="line">properties.setExpiration(<span class="string">"60000"</span>);</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties. <span class="string">"ttlTestMessage"</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>通过调用HTTP API接口设置：（消息过期不会马上抹去，因为每条消息过期时间不同，需要扫描整个队列，不如等被消费时再做判断）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root -H <span class="string">"content-type:application/json"</span>-X POST -d<span class="string">'&#123;"properties":&#123;"expiration":"60000"&#125;,"routing_key":"routingKey","payload":"my body","payload_encoding":"string"&#125;'</span> http://localhost:15672/api/queues/&#123;vhost&#125;/&#123;exchange</span></span><br><span class="line">name&#125;/publish</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>消息在队列中生存时间超过TTL时，会变成“死信”（Dead Message）。不设置TTL，默认不会过期；若设置为0，则表示直接投递到消费者，否则直接丢弃，可以部分替代上文所提 immediate 参数，但没有 <code>Basic.Return</code> 返回消息（可以通过死信队列来实现）。</p><h3 id="2-2-设置队列的TTL"><a href="#2-2-设置队列的TTL" class="headerlink" title="2.2 设置队列的TTL"></a>2.2 设置队列的TTL</h3><p>通过 <code>channel.queueDeclare()</code> 方法中的 <code>x-expires</code> 参数可以控制队列被自动删除前处于未使用状态的时间。未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过 <code>Basic.Get</code> 命令。</p><p>设置队列里的 TTL 可以应用于类似 <strong>RPC 方式的回复队列</strong>，在 RPC 中，许多队列会被创建出来，但是却是未被使用的。RabbitMQ 会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时 。</p><p>创建一个过期时间为30分钟的队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"x-expires"</span>, <span class="number">1800000</span>);</span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><h2 id="第三节-死信队列"><a href="#第三节-死信队列" class="headerlink" title="第三节 死信队列"></a>第三节 死信队列</h2><h3 id="3-1-死信交换器和死信队列"><a href="#3-1-死信交换器和死信队列" class="headerlink" title="3.1 死信交换器和死信队列"></a>3.1 死信交换器和死信队列</h3><p>死信交换器（Dead-Letter-Exchange，DLX）也可称为死信邮箱。当消息在一个队列中变成死信（dead message），能被重新被发送到另一交换器，这个交换器就是DLX，绑定DLX的队列就是死信队列。</p><p>DLX和普通交换器没区别，当设置的队列存在死信时，会自动的被发布到设置的DLX上，进而路由到死信队列，这个特性可以和TTL为0配合替代 immediate 参数。</p><h3 id="3-2-消息变为死信的原因"><a href="#3-2-消息变为死信的原因" class="headerlink" title="3.2 消息变为死信的原因"></a>3.2 消息变为死信的原因</h3><ul><li>消息被拒绝（ <code>Basic.Reject</code> / <code>Basic.Nack</code> ），井且设置 requeue 参数为 false;</li><li>消息过期；</li><li>队列达到最大长度。</li></ul><h3 id="3-3-实现方式"><a href="#3-3-实现方式" class="headerlink" title="3.3 实现方式"></a>3.3 实现方式</h3><ul><li><p>通过 <code>channel.queueDeclare()</code> 方法中设置 <code>x-dead-letter-exchange</code> 参数来为队列添加DLX：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建DLX</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"dlx_exchange"</span>, <span class="string">"direct"</span>);</span><br><span class="line"><span class="comment">//通过</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;;</span><br><span class="line">args.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">" dlx_exchange "</span>);</span><br><span class="line"><span class="comment">//也可以为DLX指定路由键，默认为原队列的路由键</span></span><br><span class="line">args.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"dlx-routing-key"</span>);</span><br><span class="line"><span class="comment">//为队列myqueue添加DLX</span></span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过策略-Policy来设置TTL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy DLX <span class="string">".*"</span> <span class="string">'&#123;"dead-letter-exchange":" dlx_exchange "&#125;'</span> --apply-to queues</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-过程"><a href="#3-4-过程" class="headerlink" title="3.4 过程"></a>3.4 过程</h3><p>生产者首先发送一条携带路由键为 <code>rk</code> 的消息，然后经过交换器 <code>exchange.normal</code> 顺利地存储到队列 <code>queue.normal</code> 。由于队列 <code>queue.normal</code> 设置了过期时间为 10s ，在这 10s 内没有消费者消费这条消息，那么判定这条消息为过期。由于设置了 DLX ，过期之时，消息被丢给交换器 <code>exchange.dlx</code> 中，这时找到与 <code>exchange.dlx</code> 匹配的队列 <code>queue.dlx</code> 后消息被存储在 <code>queue.dlx</code> 这个死信队列中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010167.png" alt></p><h3 id="3-5-作用"><a href="#3-5-作用" class="headerlink" title="3.5 作用"></a>3.5 作用</h3><p>DLX 是一个非常有用的特性，它可以处理异常情况下，消息不能够被消费者正确消费（消费者调用了 <code>Basic.Nack</code> 或者 <code>Basic.Reject</code> ）而被置入死信队列中的情况，后续分析程序可以<strong>通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以改善和优化系统</strong>。</p><p><strong>DLX 配合 TTL 使用还可以实现延迟队列的功能</strong>。</p><h2 id="第四节-延迟队列"><a href="#第四节-延迟队列" class="headerlink" title="第四节 延迟队列"></a>第四节 延迟队列</h2><h3 id="4-1-延迟消息"><a href="#4-1-延迟消息" class="headerlink" title="4.1 延迟消息"></a>4.1 延迟消息</h3><p>延迟队列存储的对象是对应的延迟消息，所谓<strong>“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费</strong>。</p><h3 id="4-2-使用场景"><a href="#4-2-使用场景" class="headerlink" title="4.2 使用场景"></a>4.2 使用场景</h3><ul><li><strong>支付超时</strong>：在订单系统中， 一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些订单了。</li><li><strong>定时功能</strong>：用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将用户指令发送到延迟队列，当指令设定的时间到了再将指令推送到智能设备。</li></ul><h3 id="4-3-实现方式"><a href="#4-3-实现方式" class="headerlink" title="4.3 实现方式"></a>4.3 实现方式</h3><p>在 AMQP 协议中，或者 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面所介绍的 <strong>DLX + TTL 模拟出延迟队列的功能</strong>。</p><p>图4-4不仅展示的是死信队列的用法，也是延迟队列的用法， <code>queue.dlx</code> 这个死信队列可以看作延迟队列。假设一个应用中需要将每条消息都设置为 10 秒的延迟， 生产者通过 <code>exchange.normal</code> 这个交换器将发送的消息存储在 <code>queue.normal</code> 这个队列中。消费者订阅的并非是 <code>queue.normal</code> 这个队列，而是 <code>queue.dlx</code> 这个队列 。当消息从 <code>queue.normal</code> 这个队列中过期之后被存入 <code>queue.dlx</code> 这个队列中，消费者就恰巧消费到了延迟 10 秒的这条消息。</p><p>在真实应用中，对于延迟队列可以根据延迟时间的长短分为多个等级，一般分为 5秒、10 秒、30 秒、 1分钟、5分钟、10 分钟、30 分钟、 1小时这几个维度，当然也可以再细化一下。</p><p>图4-5为了简化说明，这里只设置了5秒、10 秒、30 秒、1分钟这四个等级。根据应用需求的不同，生产者在发送消息的时候通过设置不同的路由键，以此将消息发送到与交换器绑定的不同的队列中。这里队列分别设置了过期时间为5秒、10 秒、30 秒、1分钟，同时也分别配置了 DLX 和相应的死信队列。</p><p>当相应的消息过期时，就会转存到相应的死信队列（即延迟队列〉中，这样消费者根据业务自身的情况，分别选择不同延迟等级的延迟队列进行消费。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010168.png" alt></p><h2 id="第五节-优先级队列"><a href="#第五节-优先级队列" class="headerlink" title="第五节 优先级队列"></a>第五节 优先级队列</h2><p>优先级队列，顾名思义，具有高优先级的队列具有高的优先权，优先级高的消息具备优先被消费的特权。</p><p>可以通过设置队列的 <code>x-max-priority</code> 参数来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置一个队列的最大优先级</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-rnax-priority"</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"queue.priority"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args); </span><br><span class="line"><span class="comment">// 需要在发送时在消息中设置消息当前的优先级</span></span><br><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">builder.priority(<span class="number">5</span>);</span><br><span class="line">AMQP.BasicProperties properties = bulder.build();</span><br><span class="line">channel.basicPublish(<span class="string">"exchange_priority"</span>, <span class="string">"rk_priority"</span>, properties, (<span class="string">"messages"</span>).getBytes());</span><br></pre></td></tr></table></figure><p>上面的代码中设置消息的优先级为5。默认最低为0，最高为队列设置的最大优先级。优先级高的消息可以被优先消费，这个也是有前提的；如果在消费者的消费速度大于生产者的速度且 Broker 中没有消息堆积的情况下，对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</p><h2 id="第六节-RPC实现"><a href="#第六节-RPC实现" class="headerlink" title="第六节 RPC实现"></a>第六节 RPC实现</h2><h3 id="6-1-什么是RPC？"><a href="#6-1-什么是RPC？" class="headerlink" title="6.1 什么是RPC？"></a>6.1 什么是RPC？</h3><p>远程过程调用（Remote Procedure Call，RPC），它是一种通过网络从远程计算机上请求服务，而不需要了解底层网络的技术。 RPC的主要功用是让构建分布式计算更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</p><p>通俗点来说，假设有两台服务器A和B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在同一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><p>RPC的协议有很多，比如最早的 CORBA、Java RMI、WebService的RPC风格、 Hessian、Thrift、Dubbo等，甚至还有 Restful API。</p><h3 id="6-2-RabbitMQ如何进行RPC"><a href="#6-2-RabbitMQ如何进行RPC" class="headerlink" title="6.2 RabbitMQ如何进行RPC"></a>6.2 RabbitMQ如何进行RPC</h3><p>一般在 RabbitMQ 中进行 RPC 是很简单。客户端发送请求消息，服务端回复响应的消息。为了接收响应的消息，我们需<strong>要在请求消息中发送一个回调队列</strong>（参考下面代码中的 replyTo 可以使用默认的队列）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String callbackQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">BasicProperties props = <span class="keyword">new</span> BasicProperties.Bulder().replyTo(callbackQueueName).build();</span><br><span class="line">channel.basicPublish (<span class="string">""</span>,<span class="string">"rpc_queue"</span>, props, message.getBytes());</span><br><span class="line"><span class="comment">// then code to read a response message from the callback_queue ...</span></span><br></pre></td></tr></table></figure><p>BasicProperties包含14个属性，这里主要用到两个：</p><ul><li>replyTo：通常用来设置一个回调队列；</li><li>correlationId：用来关联请求（request）和其调用 RPC 之后的回复（response）。</li></ul><p>上述代码中为每个 RPC 请求创建一个回调队列是非常低效的。通用的解决方案一一<strong>可以为每个客户端创建一个单一的回调队列</strong>。</p><p>这样就产生了一个新的问题，对于回调队列而言，在其接收到一条回复的消息之后，它并不知道这条消息应该和哪一个请求匹配。这里就用到 correlationId 这个属性了，我们应该<strong>为每一个请求设置一个唯一的 correlationId</strong> 。之后<strong>在回调队列接收到回复的消息时，可以根据这个属性匹配到相应的请求</strong>。如果回调队列接收到一条未知 correlationId 的回复消息，可以简单地将其丢弃。</p><p>疑问：</p><ul><li>为什么要将回调队列中的位置消息丢弃而不是仅仅将其看作失败？</li><li><strong>这样可以针对这个失败做一些弥补措施</strong>。</li></ul><p>参考图 4-7 考虑这样一种情况：RPC 服务器可能在发送给回调队列（ <code>amq.gen-LhQzlgv3GhDOv8PIDabOXA</code> ）并且在确认接收到请求消息（rpc_queue中的消息）之后挂掉了，那么只需重启下 RPC 服务器即可，RPC 服务会重新消费 rpc_queue 队列中的请求，这样就不会出现 RPC 服务端未处理请求的情况。这里的回调队列可能会收到重复消息的情况，这需要客户端能够优雅地处理这种情况，并且 RPC 请求需要保证其本身是幂等的（补充：<strong>消费者消费消息一般是先处理业务逻辑，再使用 <code>Basic.Ack</code> 确认己接收到消息以防止消息不必要地丢失</strong>）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010169.png" alt></p><h3 id="6-3-RPC处理流程"><a href="#6-3-RPC处理流程" class="headerlink" title="6.3 RPC处理流程"></a>6.3 RPC处理流程</h3><p>RPC的处理流程如下：</p><ol><li>当客户端启动时，创建一个匿名的回调队列（名称由 RabbitMQ 自动创建，如图4-7的回调队列为 <code>amq.gen-LhQzlgv3GhDOv8PIDabOXA</code> ）。</li><li>客户端为 RPC 请求设置2个属性：replyTo-用来告知 RPC 服务端回复请求时的目的队列，即回调队列； correlationId-用来标记一个请求。</li><li>请求被发送到 rpc_queue 队列中。</li><li>RPC 服务端监听 rpc_queue 队列中的请求，当请求到来时，服务端会处理并且把带有结果的消息发送给客户端，接收的队列就是 replyTo 设定的回调队列。</li><li>客户端监听回调队列，当有消息时，检查 correlationId 属性，如果与请求匹配， 那就是结果了。</li></ol><h3 id="6-4-示例"><a href="#6-4-示例" class="headerlink" title="6.4 示例"></a>6.4 示例</h3><p>示例：RPC客户端通过 RPC 来调用服务端的方法以便得到相应斐波那契值。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE_NQME = <span class="string">"rpc_queue"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(IP_ADDRESS);</span><br><span class="line">        factory.setPort(PORT);</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">        Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(RPC_QUEUE_NQME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [x] Awaiting RPC requests"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                AMQP.BasicProperties replyProps = <span class="keyword">new</span> AMQP.BasicProperties()</span><br><span class="line">                        .builder()</span><br><span class="line">                        .correlationId(properties.getCorrelationId())</span><br><span class="line">                        .build();</span><br><span class="line">                String response = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                    <span class="keyword">int</span> n = Integer.parseInt(message);</span><br><span class="line">                    System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [.] fib("</span> + message + <span class="string">")"</span>);</span><br><span class="line">                    response += fib(n);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [.] "</span> + e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">""</span>, properties.getReplyTo(),</span><br><span class="line">                            replyProps, response.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(RPC_QUEUE_NQME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> String requestQueueName = <span class="string">"rpc_queue"</span>;</span><br><span class="line">    <span class="keyword">private</span> String replyQueueName;</span><br><span class="line">    <span class="keyword">private</span> MyConsumer consumer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RPCClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"></span><br><span class="line">        replyQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">        consumer = <span class="keyword">new</span> MyConsumer(channel);</span><br><span class="line">        channel.basicConsume(replyQueueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ShutdownSignalException, ConsumerCancelledException,</span></span><br><span class="line"><span class="function">            InterruptedException </span>&#123;</span><br><span class="line">        String response = <span class="keyword">null</span>;</span><br><span class="line">        String corrId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties()</span><br><span class="line">                .builder()</span><br><span class="line">                .correlationId(corrId)</span><br><span class="line">                .replyTo(replyQueueName)</span><br><span class="line">                .build();</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, requestQueueName, properties, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            MyConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            <span class="keyword">if</span>(delivery.getProperties().getCorrelationId().equals(corrId))&#123;</span><br><span class="line">                response = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RPCClient fibRpc = <span class="keyword">new</span> RPCClient();</span><br><span class="line">        System.out.println(<span class="string">"RPCClient "</span> + LocalTime.now() + <span class="string">" [x] Requesting fib(30)"</span>);</span><br><span class="line">        String response = fibRpc.call(<span class="string">"30"</span>);</span><br><span class="line">        System.out.println(<span class="string">"RPCClient "</span> + LocalTime.now() + <span class="string">" [.] Got '"</span> + response + <span class="string">"'"</span>);</span><br><span class="line">        fibRpc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前版本MQ已废弃QueueingConsumer，自定义一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Delivery&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//TODO someting</span></span><br><span class="line">        Delivery delivery = <span class="keyword">new</span> Delivery();</span><br><span class="line">        delivery.setBody(body);</span><br><span class="line">        delivery.setProperties(properties);</span><br><span class="line">        delivery.setEnvelope(envelope);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(delivery);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Delivery <span class="title">nextDelivery</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException, ShutdownSignalException, ConsumerCancelledException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Delivery <span class="title">nextDelivery</span><span class="params">(<span class="keyword">long</span> timeout)</span><span class="keyword">throws</span> InterruptedException, ShutdownSignalException, ConsumerCancelledException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delivery</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BasicProperties properties;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line">        <span class="keyword">private</span> Envelope envelope;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BasicProperties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(BasicProperties properties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(<span class="keyword">byte</span>[] body)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.body = body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Envelope <span class="title">getEnvelope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> envelope;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvelope</span><span class="params">(Envelope envelope)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.envelope = envelope;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">RPCServer</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">01.198</span> [x] <span class="symbol">Awaiting</span> <span class="symbol">RPC</span> requests</span><br><span class="line"><span class="symbol">RPCClient</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">06.135</span> [x] <span class="symbol">Requesting</span> fib(<span class="number">30</span>)</span><br><span class="line"><span class="symbol">RPCServer</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">07.315</span> [.] fib(<span class="number">30</span>)</span><br><span class="line"><span class="symbol">RPCClient</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">07.364</span> [.] <span class="symbol">Got</span> <span class="string">'832040'</span></span><br></pre></td></tr></table></figure><h2 id="第七节-持久化"><a href="#第七节-持久化" class="headerlink" title="第七节 持久化"></a>第七节 持久化</h2><h3 id="7-1-RabbitMQ的持久化"><a href="#7-1-RabbitMQ的持久化" class="headerlink" title="7.1 RabbitMQ的持久化"></a>7.1 RabbitMQ的持久化</h3><p>持久化可以提高 RabbitMQ 的可靠性，以防在异常情况（重启、关闭、宿机等）下的数据丢失。</p><p> RabbitMQ 的持久化分为三个部分：</p><ul><li>交换器的持久化；</li><li>队列的持久化；</li><li>消息的持久化。</li></ul><h3 id="7-2-实现方式"><a href="#7-2-实现方式" class="headerlink" title="7.2 实现方式"></a>7.2 实现方式</h3><h4 id="7-2-1-交换器的持久化"><a href="#7-2-1-交换器的持久化" class="headerlink" title="7.2.1 交换器的持久化"></a>7.2.1 交换器的持久化</h4><p>交换器的持久化是<strong>通过在声明队列时将 durable 参数置为 true 实现的</strong>。如果交换器不设置持久化，那么在 RabbitMQ 服务重启之后，相关的交换器元数据会丢失， 不过消息不会丢失，只是不能将消息发送到这个交换器中了。对于一个长期使用的交换器来说， 建议将其置为持久化的。</p><h4 id="7-2-2-队列的持久化"><a href="#7-2-2-队列的持久化" class="headerlink" title="7.2.2 队列的持久化"></a>7.2.2 队列的持久化</h4><p>队列的持久化是<strong>通过在声明队列时将 durable 参数置为 true 实现的</strong>。如果队列不设置持久化，那么在 RabbitMQ 服务重启之后，相关队列的元数据会丢失， 此时数据也会丢失 。正所谓 “皮之不存，毛将焉附”，队列都没有了，消息又能存在哪里呢？</p><h4 id="7-2-3-消息的持久化"><a href="#7-2-3-消息的持久化" class="headerlink" title="7.2.3 消息的持久化"></a>7.2.3 消息的持久化</h4><p>队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。</p><p><strong>通过将消息的投递模式 (BasicProperties 中的 deliveryMode 属性）设置为2,即可实现消息的持久化</strong>。前面示例中多次提及的 <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 实际上是封装了这个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BasicProperties PERSISTENT_TEXT_PLAIN = <span class="keyword">new</span> BasicProperties(<span class="string">"text/plain"</span>, (String)<span class="keyword">null</span>, (Map)<span class="keyword">null</span>, <span class="number">2</span>, <span class="number">0</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (Date)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>设置了队列和消息的持久化，当 RabbitMQ 服务重启之后，消息依旧存在。单单只设置队列持久化，重启之后消息会丢失；单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</p><p>注意要点：可以将所有的消息都设直为持久化，但是这样会严重影响 RabbitMQ 的性能（随机）。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一 个权衡。</p><h3 id="7-3-为何持久化不能保证数据不会丢失？"><a href="#7-3-为何持久化不能保证数据不会丢失？" class="headerlink" title="7.3 为何持久化不能保证数据不会丢失？"></a>7.3 为何持久化不能保证数据不会丢失？</h3><p>将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗？答案是否定的。</p><p>首先从消费者来说，如果在订阅消费队列时将 autoAck 参数设置为 true ，那么当消费者接收到相关消息之后，还没来得及处理就看宕机了，这样也算数据丢失。这种情况很好解决，将 autoAck 参数设置为 false ，并进行手动确认。</p><p>其次，在持久化的消息正确存入 RabbitMQ 之后，还需要有一段时间（虽然很短，但是不可忽视〉才能存入磁盘之中。 RabbitMQ 并不会为每条消息都进行同步存盘（调用内核的 <code>fsync</code> 方法）的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内 RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。</p><p>这个问题怎么解决呢？这里可以<strong>引入 RabbitMQ 镜像队列机制</strong>，相当于配置了副本，如果主节点（ master ）在此特殊时间内挂掉，可以自动切换到从节点（slave), 这样有效地保证了高可用性，除非整个集群都挂掉。虽然这样也不能完全保证 RabbitMQ 消息不丢失，但是配置了镜像队列要比没有配置镜像队列的可靠性要高很多，在实际生产环境中的关键业务队列一般都会设置镜像队列。</p><p>还可以<strong>在发送端引入事务机制</strong>或者<strong>发送方确认机制</strong>来保证消息己经正确地发送并存储至 RabbitMQ 中，前提还要保证在调用 <code>channel.basicPublish</code> 方法的时候交换器能够将消息正确路由到相应的队列之中。</p><h2 id="第八节-生产者确认"><a href="#第八节-生产者确认" class="headerlink" title="第八节 生产者确认"></a>第八节 生产者确认</h2><p>在使用 RabbitMQ 的时候，可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失，除此之外，我们还会遇到一个问题，<strong>当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢？</strong></p><p>如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化？</p><p>RabbitMQ 针对这个问题，提供了两种解决方式：</p><ul><li>通过事务机制实现；</li><li>通过发送方确认（publisher confirm）机制实现。</li></ul><h3 id="8-1-事务机制"><a href="#8-1-事务机制" class="headerlink" title="8.1 事务机制"></a>8.1 事务机制</h3><p>RabbitMQ 客户端中与事务机制相关的方法有 个：</p><ul><li><code>channel.txSelect</code> ：用于将当前的信道设置成事务模式；</li><li><code>channel.txCommit</code> ：用于提交事务；</li><li><code>channel.txRollback</code> ：用于事务回滚。</li></ul><p>在通过 channel.txSelect 方法开启事务之后，我们便可以发布消息给 RabbitMQ 了， 如果事务提交成功，则消息一定到达了 RabbitMQ 中，如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行 channel.txRollback 方法来实现事务回滚。注意这里的 RabbitMQ 中的事务机制与大多数数据库中的事务概念井不相同，需要注意区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"transaction messages"</span>.getBytes());</span><br><span class="line">channel.txCommit();</span><br></pre></td></tr></table></figure><p>上面代码对应的 AMQP 协议流转过程如图 4-8 示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010170.png" alt></p><p>可以发现开启事务机制与不开启（参考图2-10）相比多了四个步骤：</p><ul><li>客户端发送 <code>Tx.Select</code> ，将信道置为事务模式；</li><li>Broker 回复 <code>Tx Select-Ok</code> ，确认己将信道置为事务模式：</li><li>在发送完消息之后，客户端发送 <code>Tx.Commit</code> 提交事务</li><li>Broker回复 <code>Tx.Commit-Ok</code> ，确认事务提交。</li></ul><p>上面所陈述的是正常的情况下的事务机制运转过程，而事务回滚是什么样子呢？我们先来 参考下面一段示例代码（代码清单 4-15 ），来看看怎么使用事务回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       channel.txSelect();</span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">       channel.txCommit();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       channel.txRollback();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面代码中很明显有一个 <code>java.lang.ArithmeticException</code> ，在事务提交之前捕获到异常，之后显式地提交事务回滚，其 AMQP 议流转过程如图 4-9 所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010171.png" alt></p><p>如果要发送多条消息，则将 <code>channel.basicPublish</code> 和 <code>channel.txCommit</code> 等方法包裹进循环内即可，可以参考如下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; LOOP_TIMES;i++)&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, (<span class="string">"messages"</span> + i).getBytes());</span><br><span class="line">           channel.txCommit();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           channel.txRollback();</span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>事务确实能够解决消息发送方和 RabbitMQ 之间消息确认的问题，只有消息成功被 RabbitMQ 接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。</p><p>但是使用事务机制会“吸干” RabbitMQ 的性能，那么有没有更好的方法既能保证消息发送方确认消息已经正确送达，又能基本上不带来性能上的损失呢？从 AMQP 协议层面来看并没有更好的办法，但是 RabbitMQ 提供了一个改进方案，即发送方确认机制。</p><h3 id="8-2-发送方确认机制"><a href="#8-2-发送方确认机制" class="headerlink" title="8.2 发送方确认机制"></a>8.2 发送方确认机制</h3><p>前面介绍了 RabbitMQ 可能会遇到的一个问题，即消息发送方（生产者）并不知道消息是否真正地到达了 RabbitMQ 。随后了解到在 AMQP 协议层面提供了事务机制来解决这个问题， 但是采用事务机制实现会严重降低 RabbitMQ 的消息吞吐量，这里就引入了一种<strong>轻量级的方式</strong>一<strong>发送方确认</strong>（publisher confirm）机制。</p><p>生产者将信道设置成 confirm （确认）模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的ID （从1开始），一旦消息被投递到所有匹配的队列之后， RabbitMQ 会发送一个确认（ <code>Basic.Ack</code> ）给生产者（包含消息的唯一ID ），这就使得生产者知晓消息已经正确到达了目的地了。</p><p>如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。 RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号，此外 RabbitMQ 可以设置 <code>channel.basicAck</code> 方法中的 multiple 参数，表示到这个序号之前的所有消息都己经得到了处理，可以参考图 4-10 。注意辨别这里的确认和消费时候的确认之间的异同。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010172.png" alt></p><p>事务机制在一条消息发送之后会使发送端阻塞，以等待 RabbitMQ 的回应，之后才能继续发送下一条消息。相比之下，<strong>发送方确认机制最大的好处在于它是异步的</strong>，一旦发布一条消息， 生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用程序便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack ( <code>Basic.Nack</code> ）命令，生产者应用程序同样可以在回调方法中处理该 nack 命令。</p><p>生产者通过调用 <code>channel.confirmSelect</code> 方法（即 <code>Confirm.Select</code> 命令）将信道 设置为 confirm 模式，之后 RabbitMQ 会返回 <code>Confirm.Select-Ok</code> 命令表示同意生产者将当前信道设置为 confirm 模式。所有被发送的后续消息都被 ack 或者 nack 一次，不会出现一条消息既被 ack 又被 nack 情况，并且 RabbitMQ 并没有对消息被 confirm 的快慢做任何保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">// 将信道置为 publisher confirm 模式</span></span><br><span class="line">       channel.confirmSelect();</span><br><span class="line">       <span class="comment">// 之后正常发送消息</span></span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, <span class="string">"publisher confirm test"</span>.getBytes());</span><br><span class="line">       <span class="keyword">if</span>(!channel.waitFormConfirms()) &#123;</span><br><span class="line">           System.out.println(<span class="string">"send message failed"</span>);</span><br><span class="line">           <span class="comment">// do something else</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果发送多条消息，只需要将 <code>channel.basicPubish</code> 和 <code>channel. waitForConfirms</code> 方法包裹在循环里面即可，参考事务机制，不过不需要 <code>channel.confirmSelect</code> 方法包裹在循环内部。</p><p>在 <code>publisher confirm</code> 模式下发送多条消息的 AMQP 协议流转过程可参考图 4-11：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010173.png" alt></p><p>对于 <code>channel.waitForConfirms</code> 而言，在 RabbitMQ 客户端中它有4个同类 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForConfirmsOrDie</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForConfirmsOrDie</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException, InterruptedException, TimeoutException</span>;</span><br></pre></td></tr></table></figure><p>如果信道没有开启 <code>publisher confirm</code> 模式，则调用任何 <code>waitForConfirms</code> 方法都会报出 <code>java.lang.IllegalStateException</code> 。对于没有参数的 <code>waitForConfirms</code> 方法来说， 其返回的条件是客户端收到了相应的 <code>Basic.Ack / .Nack</code> 或者被中断。</p><p>参数 timeout 表示超时时间， 一旦等待 RabbitMQ 回应超时就会抛出 <code>java.util.concurrent.TimeoutException</code> 的异常。</p><p>两个 <code>waitForConfirmsOrDie</code> 方法在接收到 RabbitMQ 返回 <code>Basic.Nack</code> 之后会抛出 <code>java.io.IOException</code> 业务代码可以根据自身的特性灵活地运用这四种方法来保障消息的可靠发送。</p><p>前面提到过 RabbitMQ 引入了 <code>publisher confirm</code> 机制来弥补事务机制的缺陷，提高了整体的吞吐量，那么来对比下两者之间的QPS ，测试代码可以参考上面的示例代码。</p><p>测试环境：客户端和 Broker 机器配置一CPU 24 核、主频为 2600Hz 、内存为 64GB、硬盘为 1TB 。客户端发送的消息体大小为 10B ，单线程发送，并且消息都进行持久化处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010174.png" alt></p><p>图中的横坐标表示测试的次数，纵坐标表示 QPS，可以发现 publisher confirm 与事务机制相比， QPS 并没有提高多少，难道是 RabbitMQ 欺骗了我们？</p><p>我们再来回顾下前面的示例代码，可以发现 publisher confirm 模式是每发送一条消息后就调用 <code>channe.waitForConfirms</code> 方法，之后等待服务端的确认，这实际上是一种串行同步等待的方式。事务机制和它一样，发送消息之后等待服务端确认，之后再发送消息。两者的存储确认原理相同，尤其对于持久化的消息来说，两者都需要等待消息确认落盘之后才会返回（调 Linux 内核的 <code>fsync</code> 方法） 。在同步等待的方式下， publisher confirm 机制发送一条消息需要通信交互的命令是 <code>Basic.Publish</code> 、<code>Basic.Ack</code> ；事务机制是3条： <code>Basic.Publish</code> 、<code>Tx.Commmit/.Commit-Ok</code> （或者 <code>Tx Rollback/. Rollback-Ok</code> ），事务机制多了一个命令帧报文的交互，所以 QPS 会略微下降。</p><p>注意要点：</p><ol><li>事务机制和 <code>publisher confirm</code> 机制两者是互斥的，不能共存。如果企图将已开启事务模式的信道再设置为 <code>publisher confirm</code> 模式，RabbitMQ 会报错：<code>{amqp_error, precondition_failed, &quot;cannot switch from tx to confirm mode&quot;, &#39;confirm.select&#39;};</code> 或者如果企图将已开启 <code>publisher confirm</code> 模式的信道再设置为事务模式，RabbitMQ 也会报错： <code>{amqp_error, precondition_failed, &quot;cannot switch from tx to confirm mode&quot;, &#39;tx.select&#39; }</code> 。 </li><li>事务机制和 <code>publisher confirm</code> 机制确保的是消息能够正确地发送至 RabbitMQ ，这里的“发送至 RabbitMQ”的含义是指消息被正确地发往至 RabbitMQ 的交换器，如果此交换器没有匹配的队列，那么消息也会丢失。所以在使用这两种机制的时候要确保所涉及的交换器能够有匹配的队列，更进一步地讲，发送方要配合 mandatory 参数或者备份交换器一起使用来提高 消息传输的可靠性。</li></ol><p><code>publisher confirm</code> 的优势在于并不一定需要同步确认。这里我们改进了一下使用方式，总结有如下两种：</p><ul><li>批量confirm方法：每发送一批消息后，调用 <code>channel.waitForConfirms</code> 方法，等待服务器的确认返回；</li><li>异步confirm方法：提供一个回调方法，服务端确认了一条或者多条消息后客户端会因调这个方法进行处理。</li></ul><p>在批量 confirm 方法中，客户端程序需要定期或者定量（达到多少条），亦或者两者结合起来调用 <code>channel.waitForConfirms</code> 来等待 RabbitMQ 确认返回。相比于前面示例中的普通 confirm 方法，批量极大地提升了 confirm 效率，但是问题在于出现返回 <code>Basic.Nack</code> 或者超时情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且当消息经常丢失时，批量 confirm 性能应该是不升反降的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">// 将信道置为 publisher confirm 模式</span></span><br><span class="line">       channel.confirmSelect();</span><br><span class="line">       <span class="keyword">int</span> MsgCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, <span class="string">"batch confirm test"</span>.getBytes());</span><br><span class="line">           <span class="comment">// 将发送出去的消息存入缓存，缓存可以是ArrayList或BlockingQueue等</span></span><br><span class="line">           <span class="keyword">if</span>(++MsgCount &gt;= BATCH_COUNT) &#123;</span><br><span class="line">               MsgCount = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(channel.waitForConfirms()) &#123;</span><br><span class="line">                       <span class="comment">// 将缓存中的消息清空</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 将缓存中的消息重新发送</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                   <span class="comment">// 将缓存中的消息重新发送</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>异步 confirm 方法的编程实现最为复杂，在客户端 Channel 接口中提供的 <code>addConfirmListener</code> 方法可以添加 <code>ConfirmListener</code> 这个回调接口，这个 <code>ConfirmListener</code> 接口包含两个方法： <code>handleAck</code> 、<code>handleNack</code> ，分别用来处理 RabbitMQ 回传的 <code>Basic.Ack</code> 和 <code>Basic.Nack</code> 。在这两个方法中都包含有 个参数 <code>deliveryTag</code> （在 <code>publisher confirm</code> 模式下用来标记消息的唯一有序序号）。我们需要为每个信道维护一个“unconfirm ”的消息序号集合，每发送一条消息，集合中的元素加1。每当调 <code>ConfirmListener</code> 中的 <code>handleAck</code> 方法时，“ unconfirm ”集合中删掉相应的一条 ( multiple 设置为 false ）或者多条（ multiple 设置为 true ）记录。从程序运行效率上来看， 这个“unconfrrm ”集合最好采用有序集合 <code>SortedSet</code> 的存储结构。事实上， Java 客户端 SDK 中的 <code>waitForConfirms</code> 方法也是通过 SortedSet 维护消息序号的。</p><p>演示异步 confirm 的编码实现，其中的 confirmSet 就是一个 SortedSet 类型的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener()&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"Nack, SeqNo: "</span> + deliveryTag +</span><br><span class="line">                             <span class="string">", multiple: "</span> + multiple);</span><br><span class="line">           <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">               confirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               confirmSet.remove(deliveryTag);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">               confirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               confirmSet.remove(deliveryTag);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 注意这里需要添加处理消息重发的场景</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"><span class="comment">// 下面是演示一直发送消息的场景</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">       <span class="keyword">long</span> nextSeqNo = channel.getNextPublishSeqNo();</span><br><span class="line">       channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">       confirmSet.add(nextSeqNo);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后我们将事务、普通 confirm、批量 confirm 和异步 confirm 这4种方式放到一起来比较下彼此的 QPS。测试环境和数据和图 4-12 中的测试相同，具体测试对比如图 4-13 所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010175.png" alt></p><p>可以看到批量 confirm 和异步 confirm 这两种方式所呈现的性能要比其余两种好得多。</p><ul><li>事务机制和普通 confirm 的方式吐吞量很低，但是编程方式简单，不需要在客户端维护状态（这里指的是维护 deliveryTag 及缓存未确认的消息）。</li><li>批量 confirm 方式的问题在于遇到 RabbitMQ 服务端返回 <code>Basic.Nack</code> 需要重发批量消息而导致的性能降低。</li><li>异步 confirm 方式编程模型最为复杂，而且和批量 confirm 方式一样需要在客户端维护状态。</li></ul><p>在实际生产环境中采用何种方式，这里就仁者见仁智者见智了，不过<strong>强烈建议使用异步 confirm 的方式</strong>。</p><h2 id="第九节-消费端要点介绍"><a href="#第九节-消费端要点介绍" class="headerlink" title="第九节 消费端要点介绍"></a>第九节 消费端要点介绍</h2><p>消费者客户端可以通过推模式或者拉模式的方式来获取井消费消息，当消费者处理完业务逻辑需要手动确认消息己被接收，这样 RabbitMQ 才能把当前消息从队列中标记清除。当然如果消费者由于某些原因无法处理当前接收到的消息， 可以通过 <code>channel.basicNack</code> 或者 <code>channel.basicReject</code> 来拒绝掉。</p><p>这里对于 RabbitMQ 消费端来说，还有几点需要注意：</p><ul><li>消息分发；</li><li>消息顺序性；</li><li>弃用 <code>QueueingConsumer</code> 。</li></ul><h3 id="9-1-消息分发"><a href="#9-1-消息分发" class="headerlink" title="9.1 消息分发"></a>9.1 消息分发</h3><p>当 RabbitMQ 队列拥有多个消费者时，队列收到的消息将以轮询（ <code>round-robin</code> ）的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。</p><p>很多时候轮询的分发机制也不是那么优雅。默认情况下，如果有n个消费者，那么 RabbitMQ 会将第m条消息分发给第 <code>m%n</code>（取余的方式）个消费者，RabbitMQ 不管消费者是否消费并己经确认（ <code>Basic.Ack</code> ）了消息。试想一下，如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因（比如业务逻辑简单、机器性能卓越等）很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降。</p><p>那么该如何处理这种情况呢？这里就要用到 <code>channel.basicQos(int prefetchCount)</code> 这个方法，如前面章节所述， <code>channel.basicQos</code> 方法允许限制信道上的消费者所能保持的最大未确认消息的数量。</p><p>举例说明，在订阅消费队列之前，消费端程序调用了 <code>channel.basicQos(5)</code> ，之后订阅了某个队列进行消费。 RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么 RabbitMQ 就不会向这个消费者再发送任何消息。 直到消费者确认了某条消息之后 RabbitMQ 将相应的计数减1 ，之后消费者可以继续接收消息， 直到再次到达计数上限。这种机制可以类比于 TCP/IP 中的“滑动窗口”。</p><p>注意要点：<code>Basic.Qos</code> 的使用对于拉模式的消费方式无效。</p><p>channel.basicQos 有三种类型的重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchSize, <span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> gl bal)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>前面介绍的都只用到了 prefetchCount 这个参数，当 prefetchCount 设置为0则表示没有上限。还有 prefetchSize 这个参数表示消费者所能接收未确认消息的总体大小的上限， 单位为B，设置为0则表示没有上限。</p><p>对于一个信道来说，它可以同时消费多个队列，当设置了 prefetchCount 大于0时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的 prefetchCount 的值，这样会 RabbitMQ 的性能降低，尤其是这些队列分散在集群中的多个 Broker 节点之中。 RabbitMQ 为了提升相关的性能，在 AMQP 0-9-1 协议之上重新定义了 global 这个参数，对比如表 4-1 所示。</p><table><thead><tr><th>global 参数</th><th>AMQP 0-9-1</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>false</td><td>信道上所有的消费者都需要遵从 prefetch Count 的限定值</td><td>信道上新的消费者需要遵从 prefetchCount 的限定值</td></tr><tr><td>true</td><td>当前通信链路（ Connection ）上所有的消费者都需要遵从 prefetchCount 的限定值</td><td>信道上所有的消费者都需要遵从 prefetchCount 的限定值</td></tr></tbody></table><p>前面章节中的 <code>channel.basicQos</code> 方法的示例都是针对单个消费者的，而对于同一个信道上的多个消费者而言，如果设置了 prefetchCount 的值，那么都会生效。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例中有两个消费者，各自的能接收到的未确认消息的上限都为10</span></span><br><span class="line">Channel channel = ...;</span><br><span class="line">Consumer consumer1 = ...;</span><br><span class="line">Consumer consumer2 = ...;</span><br><span class="line"><span class="comment">// Per consumer limit</span></span><br><span class="line">channel.basicQos(<span class="number">10</span>);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue1"</span>, <span class="keyword">false</span>, consumer1);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue2"</span>, <span class="keyword">false</span>, consumer2);</span><br></pre></td></tr></table></figure><p>如果在订阅消息之前，既设置了 global 为 true 的限制，又设置了 global 为 false 的限制，那么哪个会生效呢？ RabbitMQ 会确保两者都会生效。举例说明，当前有两个队列 queue1 和 queue2：queue1 有 10 条消息，分别为1到10; queue2 也有10条消息，分别为11到20 。有两个消费者分别消费这两个队列，如代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">Consumer consumer1 = ...;</span><br><span class="line">Consumer consumer2 = ...;</span><br><span class="line"><span class="comment">// Per consumer limit</span></span><br><span class="line">channel.basicQos(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Per Channel limit</span></span><br><span class="line">channel.basicQos(<span class="number">5</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue1"</span>, <span class="keyword">false</span>, consumer1);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue2"</span>, <span class="keyword">false</span>, consumer2);</span><br></pre></td></tr></table></figure><p>那么这里每个消费者最多只能收到3个未确认的消息，两个消费者能收到的未确认的消息个数之和的上限为5。在未确认消息的情况下，如果 consumer1 接收到了消息 ，那么 consumer2 至多只能收到 11 到 12 。如果像这样同时使用两种 global 的模式，则会增加 RabbitMQ 的负载，因为 RabbitMQ 需要更多的资源来协调完成这些限制。如无特殊需要，最好只使用 global 为 false 设置，这也是默认的设置。</p><h3 id="9-2-消息顺序性"><a href="#9-2-消息顺序性" class="headerlink" title="9.2 消息顺序性"></a>9.2 消息顺序性</h3><p>消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。举个例子，不考虑消息重复的情况，如果生产者发布的消息分别为 msg1、msg2、msg3 ，那么消费者必然也是按照此顺序进行消费的。</p><p>目前很多资料显示 RabbitMQ 的消息能够保障顺序性，这是不正确的，或者说这个观点有很大的局限性。在不使用任何 RabbitMQ 高级特性，也没有消息丢失、网络故障之类异常的情况发生，并且只有一个消费者的情况下，最好也只有一个生产者的情况下可以保证消息的顺序性。如果有多个生产者同时发送消息，无法确定消息到达 Broker 的前后顺序，也就无法验证消息的顺序性。</p><p>那么哪些情况下 RabbitMQ 的消息顺序性会被打破呢？</p><p>常见情形：</p><ul><li>如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补偿发送这条消息，如果补偿发送是在另一个线程实现的，那么消息在生产者这个源头就出现了错序。同样，如果启用 publisher confirm 时，在发生超时、中断，又或者是收到 RabbitMQ 的 <code>Basic.Nack</code> 命令时，那么同样需要补偿发送，结果与事务机制一样会错序。或者这种说法有 些牵强，我们可以固执地认为消息的顺序性保障是从存入队列之后开始的，而不是在发迭的时候开始的。</li><li>考虑另一种情形，如果生产者发送的消息设置了不同的超时时间，井且也设置了死信队列， 整体上来说相当于一个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致。</li><li>再考虑一种情形，如果消息设置了优先级，那么消费者消费到的消息也必然不是顺序性的。</li><li>如果一个队列按照前后顺序分有 msg1、msg2、msg3、msg4 这4个消息，同时有 ConsumerA 和 ConsumerB 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中， ConsumerA 中的消息为 msg1 和 msg3, ConsumerB 中的消息为 msg2 和 msg4。ConsumerA 收到消息 msg1 之后并不想处理而调用了 <code>Basic Nack/.Reject</code> 将消息拒绝，与此同时将 requeue 设置为 true ，这样这条消息就可以重新存入队列中。消息 msg1 之后被发送到了 ConsumerB 中，此时 ConsumerB 己经消费了 msg2 和 msg4 ，之后再消费 msg1 ，这样消息顺序性也就错乱了。或者消息 msg1 又重新发往 ConsumerA 中，此时 ConsumerA 消费了 msg3, 那么再消费 msg1 ，消息顺序性也无法得到保障。同样可以用在 <code>Basic.Recover</code> 这个 AMQP 命令中。</li></ul><p>包括但不仅限于以上几种情形会使 RabbitMQ 消息错序。如果要保证消息的顺序性，需要业务方使用 RabbitMQ 之后做进一步的处理，比如在消息体内添加全局有序标识（类似 Sequence ID ）来实现。</p><h3 id="9-3-弃用QueueingConsumer"><a href="#9-3-弃用QueueingConsumer" class="headerlink" title="9.3 弃用QueueingConsumer"></a>9.3 弃用QueueingConsumer</h3><p>在前面的章节中所介绍的订阅消费的方式都是通过继承 <code>DefaultConsumer</code> 类来实现的，建议不要使用 <code>QueueingConsumer</code> 这个类来实现订阅消费，在 4.x 版本开始被标记为 <code>＠Deprecated</code> ，想必这个类中有些无法弥补的缺陷：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"><span class="comment">//channel.basicQos(64); //使用QueueingConsumer一定要添加</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, <span class="string">"consumer_zzh"</span>, consumer);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">       String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">       System.out.println(<span class="string">" [X] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">       channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>乍一看没什么问题，而且实际生产环境中如果不是太“傲娇”地使用也不会造成什么大问题。QueueingConsumer 本身有几个大缺陷，需要在使用时特别注意 ：</p><ul><li>首当其冲的就是内存溢出的问题，如果由于某些原因，队列之中堆积了比较多的消息，就可能导致消费者客户端内存溢出假死，于是发生恶性循环，队列消息不断堆积而得不到消化。</li><li>QueueingConsumer 会拖累同一个 Connection 下的所有信道，使其性能降低；</li><li>同步递归调用 QueueingConsumer 会产生死锁：</li><li>RabbitMQ 的自动连接恢复机制（ automatic connection recove可）不支持 Queueing Consumer 的这种形式：</li><li>QueueingConsumer 不是事件驱动的。</li></ul><p>采用代码清单 4-22 中的代码进行演示 首先向一个队列发送 200多MB 的消息，然后进行消费。在客户端调用 channel.basicConsume 方法订阅队列的时候， RabbitMQ 会持续地将消息发往 QueueingConsumer 中， QueueingConsumer 内部使用 LinkedBlockingQueue 来缓存这些消息。通过 JVisualVM 可以看到堆内存的变化，如图 4-14 示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010176.png" alt></p><p>可以看到堆内存一直在增加，这里只测试了发送 200MB 左右的消息，如果发送更多的消息，那么这个堆内存会变得更大，直到出现 <code>java.lang.OutOfMemoryError</code> 的报错。</p><p>这个内存溢出的问题可以使用 <code>Basic.Qos</code> 来得到有效的解决，<code>Basic.Qos</code> 可以限制某个消费者所保持未确认消息的数量，也就是间接地限制了 QueueingConsumer 中的 LinkedBlockingQueue 的大小。注意一定要在调用 <code>Basic.Consume</code> 之前调用 <code>Basic.Qos</code> 才能生效。</p><p>为了避免不必要的麻烦，建议在消费的时候尽量使用继承 DefaultConsumer 的方式。</p><h2 id="第十节-消息传输保障"><a href="#第十节-消息传输保障" class="headerlink" title="第十节 消息传输保障"></a>第十节 消息传输保障</h2><p>消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题， 一般消息中间件的消息传输保障分为三个层级：</p><ul><li>At most once：最多一次。消息可能会丢失，但绝不会重复传输。</li><li>At least once：最少一次。消息绝不会丢失，但可能会重复传输。</li><li>Exactly once：恰好一次。每条消息肯定会被传输一次且仅传输一次。</li></ul><p>RabbitMQ 支持其中的“最多一次”和“最少一次”。其中“最少一次”投递实现需要考虑以下这个几个方面的内容：</p><ol><li>消息生产者需要开启事务机制或者 publisher confirm 机制，以确保消息可以可靠地传输到 RabbitMQ 中。</li><li>消息生产者需要配合使用 mandatory 参数或者备份交换器来确保消息能够从交换器路由到队列中，进而能够保存下来而不会被丢弃。</li><li>消息和队列都需要进行持久化处理，以确保 RabbitMQ 务器在遇到异常情况时不会造成消息丢失。</li><li>消费者在消费消息的同时需要将 autoAck 设置为 false ，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。</li></ol><p>“最多一次”的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这样很难确保消息不会丢失。</p><p>“恰好一次”是 RabbitMQ 目前无法保障的。考虑这样一种情况，消费者在消费完一条消息之后向 RabbitMQ 发送确认 <code>Basic.Ack</code> 命令，此时由于网络断开或者其他原因造成 RabbitMQ 并没有收到这个确认命令，那么 RabbitMQ 不会将此条消息标记删除。在重新建立连接之后， 消费者还是会消费到这一条消息，这就造成了重复消费。再考虑一种情况，生产者在使用 publisher confirm 机制的时候，发送完一条消息等待 RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送，这样 RabbitMQ 中就有两条同样的消息，在消费的时候，消费者就会重复消费。</p><p>那么 RabbitMQ 有没有去重的机制来保证“恰好一次”呢？答案是并没有，不仅是 RabbitMQ, 目前大多数主流的消息中间件都没有消息去重机制，也不保障“恰好一次”。去重处理一般是在业务客户端实现，比如引入 GUID (Globally Unique Identifier）的概念。针对 GUID ，如果从客户端的角度去 ，那么需要引入集中式缓存，必然会增加依赖复杂度，另外缓存的大小也难以界定。建议在实际生产环境中，业务方根据自身的业务特性进行去重，比如业务消息本身具备幂等性，或者借助 Redis 等其他产品进行去重处理。</p><hr><p>参考：<br>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第三章《进阶》，内容来自于《RabbitMQ实战指南》，内容包括：消息何去何从，过期时间，死信队列，延迟队列，优先级队列，RPC实现，持久化，生产者确认，消费端要点，消息传输保障等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>数据备份mysqldump</title>
    <link href="http://linyishui.top/2020092601.html"/>
    <id>http://linyishui.top/2020092601.html</id>
    <published>2020-09-27T06:46:17.000Z</published>
    <updated>2020-10-02T08:15:15.627Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据备份mysqldump"><a href="#数据备份mysqldump" class="headerlink" title="数据备份mysqldump"></a>数据备份mysqldump</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-什么是mysqldump？"><a href="#1-1-什么是mysqldump？" class="headerlink" title="1.1 什么是mysqldump？"></a>1.1 什么是mysqldump？</h3><p> <code>mysqldump</code> 是用于转存储 <code>mysql</code> 数据库的实用程序。生成一个 <code>SQL</code> 脚本，其中包含从头重新创建数据库的所有命令。</p><p>导出脚本的大概过程：创建数据库判断语句、删除表、创建表、锁表、禁用索引、插入数据、启用索引、解锁表。</p><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a>1.2 简单使用</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># game 是库名</span><br><span class="line"></span><br><span class="line"># 完整导出一个库</span><br><span class="line"># 包括建库语句、表结构、数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 --databases game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 只导出表结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -d game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 只导出数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -t game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 导出一个数据库中多个表的数据和结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game --tables articles users &gt; test.sql</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 恢复导出数据</span><br><span class="line">mysql -u username -proot databse &lt; backup.sql</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>--user=user_name, -u user_name</code> ：连接数据库的用户名。</li><li><code>--password=password, -p[password]</code> ：连接数据库的密码，如果使用 <code>-p</code> 缩写，和密码之间不能有空格。</li><li><code>--opt or --compact</code> ：<ul><li>使用 <code>--opt</code> 等于使用这些参数 <code>--add-drop-table, --add-locks, --create-options, --disable-keys, --extended-insert, --lock-tables, --quick, and --set-charset</code>，默认情况下即使不加 <code>--opt</code> 参数也是开启的。</li><li>使用 <code>--compact</code> 等于使用这些参数 <code>--skip-add-drop-table, --skip-add-locks, --skip-comments, --skip-disable-keys, and --skip-set-charset</code>，默认不开启。</li></ul></li><li><code>--databases, -B</code> ：指定导出的库名。</li><li><code>--all-databases</code> ：表示导出所有的库。</li><li><code>--tables</code> ：会覆盖 –databases or -B 选项，指定导出某个表就会忽略库选项。</li><li><code>--no-data, -d</code> ：不导出数据，只导出表结构。</li><li><code>--no-create-info, -t</code> ：只导出数据，不导出表结构，不添加 <code>CREATE TABLE</code> 语句。</li><li><code>--no-create-db, -n</code> ：不添加 <code>CREATE DATABASE</code> 建库语句。</li><li><code>--routines, -R</code> ：导出存储过程以及自定义函数。</li></ul><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><p>实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 导出一个数据库</span><br><span class="line">// 包括建库语句、删表语句、建表语句、插入数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 --databases game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="comment">/*!32312 IF NOT EXISTS*/</span> <span class="string">`game`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> <span class="string">`game`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `address`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`address`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`address`</span> (</span><br><span class="line">        ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`address`</span> WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ...</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` ENABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// -d 不导出数据，导出所有的建表删表语句，不包括建库语句，</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -d game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`address`</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = utf8 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`address`</span> (</span><br><span class="line">        ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// -t 不导出结构，导出所有表中的数据，不包括建库语句，都是插入语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -t game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`address`</span> WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` DISABLE KEYS */</span>;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` ENABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line"></span><br><span class="line">// 导出一个数据库的表结构以及数据，不包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的表结构以及数据，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -B game game2 &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的结构，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -d -B game game2 &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的数据，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -t -B game game2 &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>导出某张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 导出一个数据库中一个表的结构，导出 articles 表的结构和数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的数据和结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game --tables articles users &gt; test.sql</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -d game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -t game articles users &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>数据表条件导出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出 articles 表 id = 1 的数据</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --where='id=1' game articles &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>忽略某张表：多次添加忽略多张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--ignore-table database.tableName</span></span><br></pre></td></tr></table></figure><p>导入某个表数据脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 数据来源</span><br><span class="line">src_user="root" # 用户名</span><br><span class="line">src_password="root" # 密码</span><br><span class="line">src_host="localhost" # Host</span><br><span class="line">src_port="3306" # 端口</span><br><span class="line">src_database="test" # 数据库名</span><br><span class="line">src_table="edu" # 表名</span><br><span class="line"></span><br><span class="line"># 数据导入的数据库配置</span><br><span class="line">dst_user="root" # 用户名</span><br><span class="line">dst_password="root" # 密码</span><br><span class="line">dst_host="localhost" # Host</span><br><span class="line">dst_port="3306" # 端口</span><br><span class="line">dst_database="test" # 数据库名</span><br><span class="line"></span><br><span class="line">mysqldump <span class="comment">--host=$src_host --port=$src_port -u$src_user -p$src_password $src_database --tables $src_table | mysql --host=$dst_host --port=$dst_port -u$dst_user -p$dst_password $dst_database</span></span><br></pre></td></tr></table></figure><p>备份脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 以下配置信息请自己修改</span><br><span class="line">mysql_user="root" #MySQL备份用户</span><br><span class="line">mysql_password="root" #MySQL备份用户的密码</span><br><span class="line">mysql_host="localhost"</span><br><span class="line">mysql_port="3306"</span><br><span class="line">mysql_charset="utf8mb4" #MySQL编码</span><br><span class="line">backup_db_arr=("db1" "db2") #要备份的数据库名称，多个用空格分开隔开 如("db1" "db2" "db3")</span><br><span class="line">backup_location=/var/www/mysql  #备份数据存放位置，末尾请不要带"/",此项可以保持默认，程序会自动创建文件夹</span><br><span class="line">expire_backup_delete="OFF" #是否开启过期备份删除 ON为开启 OFF为关闭</span><br><span class="line">expire_days=3 #过期时间天数 默认为三天，此项只有在expire_backup_delete开启时有效</span><br><span class="line"></span><br><span class="line"># 本行开始以下不需要修改</span><br><span class="line">backup_time=`date +%Y%m%d%H%M`  #定义备份详细时间</span><br><span class="line">backup_Ymd=`date +%Y-%m-%d` #定义备份目录中的年月日时间</span><br><span class="line">backup_3ago=`date -d '3 days ago' +%Y-%m-%d` #3天之前的日期</span><br><span class="line">backup_dir=$backup_location/$backup_Ymd  #备份文件夹全路径</span><br><span class="line">welcome_msg="Welcome to <span class="keyword">use</span> MySQL <span class="keyword">backup</span> tools!<span class="string">" #欢迎语</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 判断MYSQL是否启动,mysql没有启动则备份退出</span></span><br><span class="line"><span class="string">mysql_ps=`ps -ef |grep mysql |wc -l`</span></span><br><span class="line"><span class="string">mysql_listen=`netstat -an |grep LISTEN |grep $mysql_port|wc -l`</span></span><br><span class="line"><span class="string">if [ [$mysql_ps == 0] -o [$mysql_listen == 0] ]; then</span></span><br><span class="line"><span class="string">        echo "</span><span class="keyword">ERROR</span>:MySQL <span class="keyword">is</span> <span class="keyword">not</span> running! <span class="keyword">backup</span> <span class="keyword">stop</span>!<span class="string">"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">        echo $welcome_msg</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 连接到mysql数据库，无法连接则备份退出</span></span><br><span class="line"><span class="string">mysql -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password &lt;&lt;end</span></span><br><span class="line"><span class="string">use mysql;</span></span><br><span class="line"><span class="string">select host,user from user where user='root' and host='localhost';</span></span><br><span class="line"><span class="string">exit</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">flag=`echo $?`</span></span><br><span class="line"><span class="string">if [ $flag != "</span><span class="number">0</span><span class="string">" ]; then</span></span><br><span class="line"><span class="string">        echo "</span><span class="keyword">ERROR</span>:Can<span class="string">'t connect mysql server! backup stop!"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">        echo "MySQL connect ok! Please wait......"</span></span><br><span class="line"><span class="string">        # 判断有没有定义备份的数据库，如果定义则开始备份，否则退出备份</span></span><br><span class="line"><span class="string">        if [ "$backup_db_arr" != "" ];then</span></span><br><span class="line"><span class="string">                #dbnames=$(cut -d '</span>,<span class="string">' -f1-5 $backup_database)</span></span><br><span class="line"><span class="string">                #echo "arr is ($&#123;backup_db_arr[@]&#125;)"</span></span><br><span class="line"><span class="string">                for dbname in $&#123;backup_db_arr[@]&#125;</span></span><br><span class="line"><span class="string">                do</span></span><br><span class="line"><span class="string">                        echo "database $dbname backup start..."</span></span><br><span class="line"><span class="string">                        `mkdir -p $backup_dir`</span></span><br><span class="line"><span class="string">                        `mysqldump -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password $dbname --default-character-set=$mysql_charset | gzip &gt; $backup_dir/$dbname-$backup_time.sql.gz`</span></span><br><span class="line"><span class="string">                        flag=`echo $?`</span></span><br><span class="line"><span class="string">                        if [ $flag == "0" ];then</span></span><br><span class="line"><span class="string">                                echo "database $dbname success backup to $backup_dir/$dbname-$backup_time.sql.gz"</span></span><br><span class="line"><span class="string">                        else</span></span><br><span class="line"><span class="string">                                echo "database $dbname backup fail!"</span></span><br><span class="line"><span class="string">                        fi</span></span><br><span class="line"><span class="string">                        </span></span><br><span class="line"><span class="string">                done</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">                echo "ERROR:No database to backup! backup stop"</span></span><br><span class="line"><span class="string">                exit</span></span><br><span class="line"><span class="string">        fi</span></span><br><span class="line"><span class="string">        # 如果开启了删除过期备份，则进行删除操作</span></span><br><span class="line"><span class="string">        if [ "$expire_backup_delete" == "ON" -a  "$backup_location" != "" ];then</span></span><br><span class="line"><span class="string">                 #`find $backup_location/ -type d -o -type f -ctime +$expire_days -exec rm -rf &#123;&#125; \;`</span></span><br><span class="line"><span class="string">                 `find $backup_location/ -type d -mtime +$expire_days | xargs rm -rf`</span></span><br><span class="line"><span class="string">                 echo "Expired backup data delete complete!"</span></span><br><span class="line"><span class="string">        fi</span></span><br><span class="line"><span class="string">        echo "All database backup success! Thank you!"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">fi</span></span><br></pre></td></tr></table></figure><p>修改shell脚本的属性：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">600</span> <span class="regexp">/root/my</span>sql_backup.sh</span><br><span class="line">chmod +x <span class="regexp">/root/my</span>sql_backup.sh</span><br></pre></td></tr></table></figure><p>设置好属性之后，把命令加入 <code>crontab</code>，设置每天 <code>00:00</code> 定时自动备份。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00 </span><span class="number">00</span> * * * /path/<span class="keyword">to</span>/mysql_backup.sh</span><br></pre></td></tr></table></figure><p>恢复备份：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql -u username -proot databse &lt; backup.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和建库语句一起导入</span></span><br><span class="line">mysql -u root -p root --host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port=<span class="number">33006</span>  &lt; global.sql</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">use dbname;</span><br><span class="line"></span><br><span class="line">source dbname.sql</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 <a href="https://juejin.im/post/6844903653183062030" target="_blank" rel="noopener">mysqldump 深入浅出</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据迁移</title>
    <link href="http://linyishui.top/2020092701.html"/>
    <id>http://linyishui.top/2020092701.html</id>
    <published>2020-09-27T06:06:40.000Z</published>
    <updated>2020-10-02T08:14:17.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-什么是数据迁移？"><a href="#1-1-什么是数据迁移？" class="headerlink" title="1.1 什么是数据迁移？"></a>1.1 什么是数据迁移？</h3><p><strong>数据迁移</strong>（英语：data migration）是指<strong>选择、准备、提取和转换数据</strong>，并<strong>将数据从一个计算机存储系统永久地传输到另一个计算机存储系统</strong>的过程。此外，<strong>验证迁移数据的完整性</strong>和<strong>退役原来旧的数据存储</strong>，也被认为是整个数据迁移过程的一部分。数据迁移是任何系统实现、升级或集成的关键考虑因素，通常以尽可能自动化的方式执行，从而将人力资源从繁琐的任务中解放出来。数据迁移有多种原因，包括服务器或存储设备更换、维护或升级、应用程序迁移、网站集成、灾难恢复和数据中心迁移。</p><h3 id="1-2-为什么需要迁移数据？"><a href="#1-2-为什么需要迁移数据？" class="headerlink" title="1.2 为什么需要迁移数据？"></a>1.2 为什么需要迁移数据？</h3><ul><li>数据备份</li><li>数据转换</li><li>业务需求</li><li>……</li></ul><h3 id="1-3-常见方案"><a href="#1-3-常见方案" class="headerlink" title="1.3 常见方案"></a>1.3 常见方案</h3><ul><li>mysqldump：导出一个SQL文件，再在新数据库中执行。效率低耗时高，失败率高。<ul><li>参考：《<a href="../2020092601.html" title="Title">数据备份mysqldump</a>》</li></ul></li><li>脚本迁移：<ul><li><strong>实现一个迁移脚本</strong>，远程连接源数据库，分块读取后再写入目标数据库。可以通过切分然后多线程执行的方式进行优化，但<strong>只能先读后写</strong>。</li><li><strong>通过 Redis 搭建一个生产者+ 消费者的迁移方案</strong>，在源数据服务器运行一个多线程脚本，并行读取数据，并生产到Redis队列；在目标服务器也运行一个多线程脚本，远程连接Redis，并行读取队列中的数据，并把数据写入目标数据库。相比前一个方案，这种方式是<strong>异步</strong>的，<strong>读和写可以同时进行</strong>。</li></ul></li><li>文件迁移：SqlLoader（Oracle）或 <code>load data infile</code>（MySql）如： <code>select data into outfile file.txt</code>、<code>load data infile file.txt into table</code> 的命令。<ul><li>参考：《<a href="../2020092401.html" title="Title">SqlLoader</a>》</li></ul></li></ul><h2 id="第二节-方案实战"><a href="#第二节-方案实战" class="headerlink" title="第二节 方案实战"></a>第二节 方案实战</h2><p>数据准备，一张日志表：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010163.png" alt></p><p>数据量为一千万：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010164.png" alt></p><p>将其从 test 库迁移到 test_b 库。</p><h3 id="2-1-mysqldump"><a href="#2-1-mysqldump" class="headerlink" title="2.1 mysqldump"></a>2.1 mysqldump</h3><h3 id="2-MySql-SqlLoader"><a href="#2-MySql-SqlLoader" class="headerlink" title="2. MySql SqlLoader"></a>2. MySql SqlLoader</h3><p>1.在源数据库导出数据文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'logs1.txt'</span>;</span><br></pre></td></tr></table></figure><p>执行耗时：（只需半分钟）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010160.png" alt></p><p>文件大小：676MB</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010161.png" alt></p><p>生成文件格式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1811</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span>首页</span><br><span class="line"><span class="selector-tag">1812</span><span class="selector-tag">2</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:01</span>首页</span><br><span class="line"><span class="selector-tag">1813</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span>首页</span><br><span class="line"><span class="selector-tag">1814</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:03</span>首页</span><br><span class="line"><span class="selector-tag">1815</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:04</span>首页</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>2.复制数据文件到目标服务器：（如果是在服务器端操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip fans.zip /data/fans.txt</span><br><span class="line">scp fans.zip root@ip:/data/ </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在目标数据库导入文件</span></span><br><span class="line">unzip /data/fans.zip</span><br></pre></td></tr></table></figure><p>3.目标数据库执行命令：（需要先导入表结构）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'logs1.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> logs1(<span class="keyword">id</span>, logtype, logurl, logip, logdz, ladduser, lfadduser, laddtime, htmlname);</span><br></pre></td></tr></table></figure><p>执行耗时：（只需5分钟左右）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010162.png" alt></p><p>对比导出SQL文件，耗时从将近1小时缩短到5分钟。</p><p>在mysql执行 <code>load data infile</code> 和 <code>into outfile</code> 命令都需要在mysql开启了 <code>secure_file_priv</code> 选项， 可以通过 <code>show global variables like &#39;%secure%&#39;;</code> 查看mysql是否开启了此选项，默认值Null标识不允许执行导入导出命令。通过 <code>vim /etc/my.cnf</code> （Windows修改 <code>my.ini</code> ）修改mysql配置项，将 <code>secure_file_priv</code> 的值设置为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">  secure_file_priv=&apos;&apos;</span><br></pre></td></tr></table></figure><p>在导入数据的时候，可以通过设置字段名来匹配目标字段的数据，可以通过<code>@dummy</code>丢弃掉不需要的目标字段数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/data/fans.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> wxa_fans(<span class="keyword">id</span>,appid,openid,unionid,@dummy,created_at,@dummy,nickname,gender,avatar_url,@dummy,@dummy,@dummy,@dummy,<span class="keyword">language</span>,country,province,city,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy);</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 <a href="https://juejin.im/post/6844903630227636237" target="_blank" rel="noopener">Mysql百万级数据迁移实战笔记</a></p><p>🔗 <a href="https://cloud.google.com/solutions/database-migration-concepts-principles-part-1?hl=zh-cn" target="_blank" rel="noopener">数据库迁移：概念和原则（第 1 部分）</a></p>]]></content>
    
    <summary type="html">
    
      简单整理一下数据库中数据迁移相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>SqlLoader</title>
    <link href="http://linyishui.top/2020092401.html"/>
    <id>http://linyishui.top/2020092401.html</id>
    <published>2020-09-24T07:26:04.000Z</published>
    <updated>2020-10-02T08:17:02.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SqlLoader"><a href="#SqlLoader" class="headerlink" title="SqlLoader"></a>SqlLoader</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-常见的几种数据迁移方式"><a href="#1-1-常见的几种数据迁移方式" class="headerlink" title="1.1 常见的几种数据迁移方式"></a>1.1 常见的几种数据迁移方式</h3><p>日常开发中会经常遇到这样的需求，大批量的数据需要在不同的数据库间迁移，一般会有如下几种方式（不一定涵盖所有）：</p><ul><li>源数据库直接导出SQL文件，目标数据库执行；<ul><li>数据量大时效率很低，甚至可能会卡死客户端。</li></ul></li><li>创建数据库间的DBLink，用 <code>create table B as select * from A@dblink where ...</code> ，或 <code>insert into B select * from A@dblink where ...</code> ；</li><li>exp A 表，再 imp 到 B 表，exp 时可加查询条件；</li><li>程序实现 <code>select from A ..</code> ，然后 <code>insert into B ...</code> ，也要分批提交；</li><li>SqlLoader导入数据。</li></ul><h3 id="1-2-什么是SqlLoader"><a href="#1-2-什么是SqlLoader" class="headerlink" title="1.2 什么是SqlLoader"></a>1.2 什么是SqlLoader</h3><p>Oracle提供了 <code>sqlldr</code> 命令，参数：</p><ul><li>userid：username/password[@servicename]；</li><li>control：控制文件，可能包含表的数据；</li><li>log：记录导入时的日志文件，默认为 控制文件(去除扩展名).log；</li><li>bad：坏数据文件，默认为 控制文件(去除扩展名).bad；</li><li>data：数据文件，一般在控制文件中指定。用参数控制文件中不指定数据文件更适于自动操作；</li><li>errors：允许的错误记录数，可以用他来控制一条记录都不能错；</li><li>rows：多少条记录提交一次，默认为 64；</li><li>skip：跳过的行数，比如导出的数据文件前面几行是表头或其他描述。</li></ul><p>sqlldr是在处理大数据量的操作中建议采用的方式，它有许多性能相关的开关，能最大程度的减少 redo，undo 的生成。</p><p>MySql中对应的语句：<code>load data infile</code> 。</p><h3 id="1-3-SqlLoader用法"><a href="#1-3-SqlLoader用法" class="headerlink" title="1.3 SqlLoader用法"></a>1.3 SqlLoader用法</h3><p>控制文件 <code>.ctl</code> 格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 控制文件标识</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 要导入的数据文件名</span></span><br><span class="line"><span class="keyword">INFILE</span> <span class="string">'xxx.txt'</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 将文件插入到数据库的 test 表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 用于分割一行中各个属性值的符号（例如每个属性值用逗号分割， 那么就把 X'09' 改为','）</span></span><br><span class="line"><span class="keyword">Fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> X<span class="string">'09'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. test表中对应的属性名</span></span><br><span class="line">(<span class="keyword">id</span>, username, passwprd, ......)</span><br></pre></td></tr></table></figure><p>操作类型有：</p><ol><li>insert：为缺省方式，在数据装载开始时要求表为空；</li><li>append：在表中追加新记录；</li><li>replace：删除旧记录(用 delete from table 语句)，替换成新装载的记录；</li><li>truncate：删除旧记录(用 truncate table 语句)，替换成新装载的记录。</li></ol><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此文件格式是.log，用文本文件的方法可以导入进去</span></span><br><span class="line"><span class="keyword">infile</span> <span class="string">'D:/xxx/xxx.log'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- insert为缺省方式，插入时要求表为空</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> database_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据文件每个字段也就是属性是按照|来分割的</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'|'</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据中某些属性可能是null值 ， 如果不加入这行导入到数据库的时候就会自动跳过null值的列, 这样数据插入后就会属性和值对应不上</span></span><br><span class="line">trailing nullcols </span><br><span class="line"></span><br><span class="line"><span class="comment">-- content运用的类型是clob，当使用sqlldr加载很长的字符串(超过4000)到表中的clob类型中时会报错：数据文件的字段超出最大长度；sqlldr每次读入文件中数据流的数据类型默认为CHAR ,长度为 255 .所以只要超过255字符的段都会报这个错，所以char(10000)用来控制上限</span></span><br><span class="line">(<span class="keyword">time</span>, user_id, <span class="keyword">type</span>, longitude, latitude, height, <span class="keyword">content</span> <span class="built_in">char</span>(<span class="number">10000</span>))</span><br></pre></td></tr></table></figure><p>接下来可以直接通过 <code>sqlldr</code> 语句导入，一般项目会通过一个数据文件和一个控制文件来实现此功能，这样可以将模板和数据分离，可以重复使用：</p><ul><li>数据文件：可以是PL/SQL或Toad导出、SqlPlus的Spool格式化产出、UTL_FILE包生成。</li></ul><h3 id="1-4-LOAD-DATA-INFILE用法"><a href="#1-4-LOAD-DATA-INFILE用法" class="headerlink" title="1.4 LOAD DATA INFILE用法"></a>1.4 LOAD DATA INFILE用法</h3><p><code>LOAD DATA INFILE</code> 是  <code>SELECT ... INTO OUTFILE</code> 的相对语句。把表的数据备份到文件使用 <code>SELECT ... INTO OUTFILE</code> ，从备份文件恢复表数据，使用  <code>LOAD DATA INFILE</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">CONCURRENT</span>] [<span class="keyword">LOCAL</span>] <span class="keyword">INFILE</span> <span class="string">'file_name.txt'</span></span><br><span class="line">    [<span class="keyword">REPLACE</span> | <span class="keyword">IGNORE</span>]</span><br><span class="line">    <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tbl_name</span><br><span class="line">    [<span class="keyword">FIELDS</span></span><br><span class="line">        [<span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">        [[<span class="keyword">OPTIONALLY</span>] <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'char'</span>]</span><br><span class="line">        [<span class="keyword">ESCAPED</span> <span class="keyword">BY</span> <span class="string">'char'</span> ]</span><br><span class="line">    ]</span><br><span class="line">    [<span class="keyword">LINES</span></span><br><span class="line">        [<span class="keyword">STARTING</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">        [<span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">    ]</span><br><span class="line">    [<span class="keyword">IGNORE</span> <span class="built_in">number</span> <span class="keyword">LINES</span>]</span><br><span class="line">    [(col_name_or_user_var,...)]</span><br><span class="line">    [<span class="keyword">SET</span> col_name = expr,...)]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'data.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tbl_name </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> </span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span> </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只载入部分列</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'persondata.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> persondata (col1,col2)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p>LOW_PRIORITY：适用于表锁存储引擎，比如MyISAM, MEMORY, 和 MERGE，在写入过程中如果有客户端程序读表，写入将会延后，直至没有任何客户端程序读表再继续写入。</p></li><li><p>CONCURRENT：使用该参数，允许在写入过程中其它客户端程序读取表内容。</p></li><li><p>LOCAL：关键字影响数据文件定位和错误处理，影响在哪里找到数据文件。只有当 mysql-server 和 mysql-client 同时在配置中指定允许使用，LOCAL关键字才会生效。</p><ul><li><p>LOCAL load operations：如果指定了LOCAL，数据文将被客户端程序从客户端主机读取，然后发送给服务器主机。将在服务器主机的临时目录创建一个数据文件的副本，如果临时目录剩余空间不足，将导致语句执行失败。</p></li><li><p>Non-LOCAL load operations：如果没有指定LOCAL，数据文件必须位于服务器值机上，直接由 mysql-server 读取。mysql-serve 使用如下规则来定位文件：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>数据文件使用绝对路径，直接使用</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>数据文件使用相对路径并且有前导的部分，将相对于 mysql-server 的数据目录查找，例如 ./myfile.txt</span><br><span class="line"></span><br><span class="line"><span class="bullet">3. </span>数据文件使用相对路径并且没有前导的部分，将相对于默认数据库的数据文件目录查找,例如 myfile.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>根据上面的规则，./myfile.txt  将被定位到 mysql-server 的 data directory,而 myfile.txt 将被定位到 default database 的  database directory。如果 db1 时默认数据库，则下面的语句将从 db1 的数据库目录读取 data.txt,即使明确指定把数据装载到 db2：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'data.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> db2.my_table;</span><br></pre></td></tr></table></figure>Non-LOCAL load operations 从服务器主机上读取数据文将。出于安全原因，这个操作需要文件权限。 如果secure_file_priv 系统变量的value 不为空，数据文件必须放在该变量指定的目录。如果该变量为空，数据文件必须可读。使用LOCAL将比让服务器直接存取文件慢些，因为文件的内容必须从客户主机传送到服务器主机。在另一方面，你不需要file权限装载本地文件。</code></pre><ul><li><p>LOCAL关键字对错误处理的影响：</p><ol><li>使用 LOAD DATA INFILE,data-interpretation 和 duplicate-key 错误会终止操作；</li><li>使用 LOAD DATA LOCAL INFILE，data-interpretation 和 duplicate-key 错误会发出警告，操作将继续执行。对于duplicate-key错误，效果和指定了 IGNORE 关键字一样。</li></ol></li></ul><ul><li><p>REPLACE | IGNORE：控制对现有的唯一键记录的重复的处理。</p><ul><li>指定REPLACE，新行将代替有相同的唯一键值的现有行。</li><li>指定IGNORE，跳过有唯一键的现有行的重复行的输入。</li><li>不指定任何一个选项，当找到重复键键时，出现一个错误，并且文本文件的余下部分被忽略时。</li></ul></li><li><p>FIELDS：</p><ul><li><p>基本用法：如果指定一个FIELDS子句，它的每一个子句(TERMINATED BY, [OPTIONALLY] ENCLOSED BY和ESCAPED BY)也是可选的，但是必须至少指定一个。</p><p>如果你指定 FIELDS 或 LINES ，缺省值为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'</span><br><span class="line">LINES TERMINATED BY '\n' STARTING BY ''</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>缺省值导致读取输入时，LOAD DATA INFILE表现如下：1. 在 \n 处寻找行边界2. 在 \t 处将行分进字段3. 不要期望字段由任何引号字符封装4. 将由“\”开头的定位符、换行符或“\”解释成转义序列。例如 \t, \n, and \ 分别解释成 定位符，换行，反斜杠。相反，缺省值导致在写入输出时，SELECT ... INTO OUTFILE表现如下：1. 在字段之间写 \t2. 不用任何引号字符封装字段3. 使用“\”转义出现在字段中的 定位符、换行符或“\”字符4. 在行尾处写换行符</code></pre><ul><li><p>FIELDS [OPTIONALLY] ENCLOSED BY：控制哪些字段应该包裹在引号里面。</p><p>对于SELECT … INTO OUTFILE 输出，如果不包含OPTIONALLY选项，所有的字段将会被ENCLOSED BY指定的字符包裹，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1"</span>,<span class="string">"a string"</span>,<span class="string">"100.20"</span>  </span><br><span class="line"><span class="string">"2"</span>,<span class="string">"a string containing a , comma"</span>,<span class="string">"102.20"</span>  </span><br><span class="line"><span class="string">"3"</span>,<span class="string">"a string containing a \" quote"</span>,<span class="string">"102.20"</span>  </span><br><span class="line"><span class="string">"4"</span>,<span class="string">"a string containing a \", quote and comma"</span>,<span class="string">"102.20"</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>如果我们指定OPTIONALLY，只有string数据类型（如 CHAR, BINARY, TEXT, 或 ENUM）的字段才会被ENCLOSED BY指定的字符包裹，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a \" quote"</span>,102.20  </span><br><span class="line">4,<span class="string">"a string containing a \", quote and comma"</span>,102.20</span><br></pre></td></tr></table></figure>注意，如果在字段值内出现ENCLOSED BY字符，则通过使用ESCAPED BY字符作为前缀，对ENCLOSED BY字符进行转义。另外，要注意，如果指定了一个空ESCAPED BY值，则可能会生成不能被LOAD DATAINFILE 正确读取的输出值。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a "</span> quote<span class="string">",102.20  </span></span><br><span class="line"><span class="string">4,"</span>a string containing a <span class="string">", quote and comma"</span>,102.20</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>FIELDS ESCAPED BY：用来控制如何对特殊字符进行读写。</p><p>如上面一个例子，导出和导入时指定FIELDS ESCAPED BY为双引号[“]才能被正确的导入，导出的格式如下，对字段内的双引号[“]进行了转义。</p></li></ul><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a #"</span> quote<span class="string">",102.20  </span></span><br><span class="line"><span class="string">4,"</span>a string containing a <span class="comment">#", quote and comma",102.20</span></span><br></pre></td></tr></table></figure>对于输入： 假如FIELDS ESCAPED BY指定字符非空，则输入时该字符被移除，后续的内容被添加到字段里。一些两个字符的字符串序列且第一个字符是转义字符的例外 。这些字符序列见下表：| Character | Escape Sequence                || :-------: | ------------------------------ ||    \0     | An ASCII NUL (X&apos;00&apos;) character ||    \b     | A backspace character          ||    \n     | A newline (linefeed) character ||    \r     | A carriage return character    ||    \t     | A tab character.               ||    \Z     | ASCII 26 (Control+Z)           ||    \N     | NULL                           |假如FIELDS ESCAPED BY指定字符为空，将不会发生转义序列的解释。对于输出，如果FIELDS ESCAPED BY指定字符非空，字符作为以下输出的前缀：1. FIELDS ESCAPED BY 字符，例如 \2. FIELDS [OPTIONALLY] ENCLOSED BY 字符，例如 &quot;3. FIELDS TERMINATED BY and LINES TERMINATED BY 的 value 的第一个字符,例如\n4. ASCII 0如果LINES TERMINATED BY是空字符串，FIELDS TERMINATED BY非空,字符将不会被转义，NULL 将输出为 NULL而不是 \N。指定LINES TERMINATED BY为空字符串并不是个好主意，特别当内容中包含上表列出的特殊字符时。</code></pre><ul><li><p>LINES STARTING BY：如果所有希望读入的行都含有一个我们希望忽略的共用前缀，则可以使用 LINES STARTING BY ‘prefix_string’  来跳过前缀（以及该前缀前的所有字符）。如果某行不包括前缀，则整个行被跳过。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> </span><br><span class="line">   <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>  <span class="keyword">LINES</span> <span class="keyword">STARTING</span> <span class="keyword">BY</span> <span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure></li></ul><pre><code>假如/tmp/test.txt文件内容如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx"abc",1  </span><br><span class="line">something xxx"def",2  </span><br><span class="line">"ghi",3</span><br></pre></td></tr></table></figure>则我们读入的内容包括(&quot;abc&quot;,1) 和 (&quot;def&quot;,2)，第三行直接被跳过。</code></pre><ul><li><p>IGNORE number LINES：该选项可以被用于在文件的开始处忽略行。例如，我们可以使用IGNORE 1 LINES来跳过一个包含列名称的起始标题行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">IGNORE</span> <span class="number">1</span> <span class="keyword">LINES</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在特定情况下，field-和line-handling选项相互影响：</p><ol><li>如果LINES TERMINATED BY是空字符串，FIELDS TERMINATED BY非空,行以FIELDS TERMINATED BY指定的字符串作为结尾。</li><li>如果FIELDS TERMINATED BY 与 FIELDS ENCLOSED BY值均为空(‘’)，将使用固定行（无分割）格式。使用固定行格式，字段之间将没有分隔符（行终止符依然可使用），列字段数据的读取和写入均按照字段定义的宽度去操作，如 TINYINT, SMALLINT, MEDIUMINT, INT, 和 BIGINT, 字段宽度分别为4, 6, 8, 11, 和 20。</li></ol></li><li><p>不适合使用 LOAD DATA INFILE 的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用固定行格式（即FIELDS TERMINATED BY 和 FIELDS ENCLOSED BY 均为空）,列字段类型为BLOB或TEXT。</span><br><span class="line">2. 指定分隔符与其它选项前缀一样，<span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>不能对输入做正确的解释。例如：</span><br><span class="line">   <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'"'</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span>  </span><br><span class="line"><span class="number">3.</span> 如果 <span class="keyword">FIELDS</span> <span class="keyword">ESCAPED</span> <span class="keyword">BY</span> 为空，字段值包含 <span class="keyword">FIELDS</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> 指定字符，或者 <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> 的字符在 <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> 之前，都会导致过早的停止 <span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>操作。因为<span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>不能准确的确定行或列的结束。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>IGNORE number LINES 选项：IGNORE number LINES选项可以被用于在文件的开始处忽略行。<br>您可以使用IGNORE 1 LINES来跳过一个包含列名称的起始标题行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span>  <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">IGNORE</span> <span class="number">1</span> <span class="keyword">LINES</span>;</span><br></pre></td></tr></table></figure></li><li><p>选择导入的列：</p><p>下面的语句会导入文件的所有列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'persondata.txt'</span> INTO TABLE persondata;</span><br></pre></td></tr></table></figure><p>如果我们想导入表的某些列，需要指定列的列表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'persondata.txt'</span> <span class="function">INTO TABLE <span class="title">persondata</span> (<span class="params">col1,col2,...</span>)</span>;</span><br></pre></td></tr></table></figure><p>如果输入文件与表的列顺序不同，我们必须指定一个列清单，否则mysql不能把输入文件的字段与表的列匹配起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA INFILE <span class="string">'/tmp/loadtest.txt'</span> INTO TABLE loadtest </span><br><span class="line">   FIELDS TERMINATED BY <span class="string">','</span> </span><br><span class="line">   OPTIONALLY ENCLOSED BY <span class="string">'"'</span> </span><br><span class="line">   ESCAPED BY <span class="string">'#'</span> </span><br><span class="line">   LINES TERMINATED BY <span class="string">'\n'</span> </span><br><span class="line">   (c1, c2, c4, c3);</span><br></pre></td></tr></table></figure><p>列的清单可以包含列名或者用户变量，在写入列前我们需要使用SET语句对用户变量进行转换。对set语句及用户变量有如下使用方法：</p><p>方法1：在用户变量用于第一列之前，先把第一列的值赋予用户变量，进行除法操作后输入到c1。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, <span class="meta">@var</span>1)</span><br><span class="line">  SET column2 = <span class="meta">@var</span>1/<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>方法2The SET clause can be used to supply values not derived from the input file. 。使用下面例子把c3列设为当前时间</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, column2)</span><br><span class="line">  SET column3 = CURRENT_TIMESTAMP;</span><br></pre></td></tr></table></figure><p>方法3：把输入赋予用户变量，而不把用户变量赋予表中的列，来丢弃此输入值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, <span class="meta">@dummy</span>, column2, <span class="meta">@dummy</span>, column3);</span><br></pre></td></tr></table></figure></li><li><p>通过管道导入数据：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在unix系统中，如果我们想要从管道（pipe）中load data，需要用如下方法：</span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># mkfifo /tmp/ls.dat  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># chmod 666 /tmp/ls.dat  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># find / -ls &gt; /tmp/ls.dat &amp;  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># mysql -e <span class="string">"LOAD DATA INFILE '/tmp/ls.dat' INTO TABLE test.tb1 FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"</span><span class="string">' ESCAPED BY '</span>#<span class="string">' LINES TERMINATED BY '</span>\n<span class="string">'"</span></span></span><br></pre></td></tr></table></figure><p>注意：sql-mode使用严格事物模式STRICT_TRANS_TABLES会报错</p><p>在另一窗口将数据写入管道</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> <span class="regexp">/]# cat /</span>tmp<span class="regexp">/loadtest.txt &gt; /</span>tmp/ls.dat</span><br></pre></td></tr></table></figure><p>注：可以先读或者先写管道，谁先谁后都可以，在写入管道的数据被全部读出前，处于阻塞状态。</p></li></ul><h2 id="第二节-实战"><a href="#第二节-实战" class="headerlink" title="第二节 实战"></a>第二节 实战</h2><h3 id="2-1-导出SQL"><a href="#2-1-导出SQL" class="headerlink" title="2.1 导出SQL"></a>2.1 导出SQL</h3><p>导出一千万条数据，耗时-5分钟，sql文件大小-1.17 GB</p><p>直接执行SQL文件，耗时54分41秒</p><h3 id="2-2-load-data-infile"><a href="#2-2-load-data-infile" class="headerlink" title="2.2 load data infile"></a>2.2 load data infile</h3><p>1.在源数据库导出数据文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'logs1.txt'</span>;</span><br></pre></td></tr></table></figure><p>执行耗时：（只需半分钟）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010160.png" alt></p><p>文件大小：676MB</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010161.png" alt></p><p>生成文件格式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1811</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span>首页</span><br><span class="line"><span class="selector-tag">1812</span><span class="selector-tag">2</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:01</span>首页</span><br><span class="line"><span class="selector-tag">1813</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span>首页</span><br><span class="line"><span class="selector-tag">1814</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:03</span>首页</span><br><span class="line"><span class="selector-tag">1815</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:04</span>首页</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>3.目标数据库执行命令：（需要先导入表结构）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'logs1.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> logs1(<span class="keyword">id</span>, logtype, logurl, logip, logdz, ladduser, lfadduser, laddtime, htmlname);</span><br></pre></td></tr></table></figure><p>执行耗时：（只需5分钟左右）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010162.png" alt></p><p>对比导出SQL文件，耗时从将近1小时缩短到5分钟。</p><h3 id="2-3-SqlLoader"><a href="#2-3-SqlLoader" class="headerlink" title="2.3 SqlLoader"></a>2.3 SqlLoader</h3><p>1.导出数据文件，可以是任意支持格式，如 <code>.txt</code>，<code>.csv</code> 等。</p><p>2.创建控制文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS (skip=1,rows=128) <span class="comment">-- sqlldr 命令显示的 选项可以写到这里边来,skip=1 用来跳过数据中的第一行  </span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span>  </span><br><span class="line"><span class="keyword">INFILE</span> <span class="string">"users_data.csv"</span> <span class="comment">--指定外部数据文件，可以写多 个 INFILE "another_data_file.csv" 指定多个数据文件  </span></span><br><span class="line"><span class="comment">--这里还可以使 用 BADFILE、DISCARDFILE 来指定坏数据和丢弃数据的文件，  </span></span><br><span class="line"><span class="keyword">truncate</span> <span class="comment">--操作类型，用 truncate table 来清除表中原有 记录  </span></span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> <span class="comment">-- 要插入记录的表  </span></span><br><span class="line"><span class="keyword">Fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">","</span> <span class="comment">-- 数据中每行记录用 "," 分隔  </span></span><br><span class="line"><span class="keyword">Optionally</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">'"'</span> <span class="comment">-- 数据中每个字段用 '"' 框起，比如字段中有 "," 分隔符时  </span></span><br><span class="line">trailing nullcols <span class="comment">--表的字段没有对应的值时允 许为空  </span></span><br><span class="line">(  </span><br><span class="line">  virtual_column FILLER, <span class="comment">--这是一个虚拟字段，用来跳 过由 PL/SQL Developer 生成的第一列序号  </span></span><br><span class="line">  user_id <span class="built_in">number</span>, <span class="comment">--字段可以指定类型，否则认 为是 CHARACTER 类型, log 文件中有显示  </span></span><br><span class="line">  user_name,  </span><br><span class="line">  login_times,  </span><br><span class="line">  last_login <span class="built_in">DATE</span> <span class="string">"YYYY-MM-DD HH24:MI:SS"</span> <span class="comment">-- 指定接受日期的格式，相当用 to_date() 函数转换  </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行完 sqlldr 后可以留意一下生成的几个文件，如 users.log 日志文件、users.bad 坏数据文件等。特别是要看看日志文件，从中可让你更好的理解 Sql Loader，里面有对控制文件的解析、列出每个字段的类型、加载记录的统计、出错原因等信息。</p><h2 id="第三节-SqlLoader细节"><a href="#第三节-SqlLoader细节" class="headerlink" title="第三节 SqlLoader细节"></a>第三节 SqlLoader细节</h2><p>SqlLoader 的性能与并发操作：</p><ol><li><p>ROWS 的默认值为 64，可以根据实际指定更合适的 ROWS 参数来指定每次提交记录数。</p></li><li><p>常规导入可以通过使用 INSERT语句来导入数据。Direct 导入可以跳过数据库的相关逻辑(DIRECT=TRUE)，而直接将数据导入到数据文件中，可以提高导入数据的性能。当然，在很多情况下，不能使用此参数(如果主键重复的话会使索引的状态变成UNUSABLE!)。</p></li><li><p>通过指定 UNRECOVERABLE选项，可以关闭数据库的日志(是否要 alter table table1 nologging 呢?)。这个选项只能和 direct 一起使用。</p></li><li><p>对于超大数据文件的导入就要用并发操作了，即同时运行多个导入任务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlldr userid=/ control=result1.ctl direct=true parallel=true   </span><br><span class="line">sqlldr userid=/ control=result2.ctl direct=true parallel=true   </span><br><span class="line">sqlldr userid=/ control=result2.ctl direct=true parallel=true</span><br></pre></td></tr></table></figure></li><li><p>当加载大量数据时（大约超过10GB），最好抑制日志的产生：  <code>SQL&gt;ALTER  TABLE  RESULTXT  nologging;</code> 这样不产生REDO LOG，可以提高效率。然后在 CONTROL 文件中 load data 上面加一行：unrecoverable， 此选项必须要与DIRECT共同应用。</p></li><li><p>在并发操作时，ORACLE声称可以达到每小时处理100GB数据的能力！其实，估计能到 1－10G 就算不错了，开始可用结构相同的文件，但只有少量数据，成功后开始加载大量数据，这样可以避免时间的浪费。（注意：一般只能用ASCII码形式，切记要转换编码，不然导入数据为空）</p></li></ol><p><a href="https://cloud.tencent.com/developer/article/1059843" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1059843</a></p><hr><p>参考：</p><p>🔗 <a href="https://blog.csdn.net/shadow_zed/article/details/82661118" target="_blank" rel="noopener">oracle sqlldr 用法详解</a></p><p>🔗 <a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">MySql官方文档-LOAD DATA Statement</a></p><p>🔗 <a href="https://www.jianshu.com/p/bcafd8f3ad8e" target="_blank" rel="noopener">LOAD DATA INFILE 导入数据</a></p>]]></content>
    
    <summary type="html">
    
      简单整理一下SqlLoader相关内容，简单使用，实战案例等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
      <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（二）客户端开发</title>
    <link href="http://linyishui.top/2020092001.html"/>
    <id>http://linyishui.top/2020092001.html</id>
    <published>2020-09-20T04:34:35.000Z</published>
    <updated>2020-10-02T08:15:29.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a><strong>客户端开发</strong></h1><h2 id="第一节-连接RabbitMQ"><a href="#第一节-连接RabbitMQ" class="headerlink" title="第一节 连接RabbitMQ"></a><strong>第一节 连接RabbitMQ</strong></h2><p>客户端给定参数（IP地址、端口号、用户名、密码等）连接RabbitMQ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUsername(USERNAME);</span><br><span class="line">factory.setPassword(PASSWORD);</span><br><span class="line">factory.setVirtualHost(virtualHost);</span><br><span class="line">factory.setHost(IP_ADDRESS);</span><br><span class="line">factory.setPort(PORT);</span><br><span class="line">Connection conn = factory.newConnection();</span><br></pre></td></tr></table></figure><p>也可以用URL的方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUri(<span class="string">"amqp://userName:password@ipAddress:portNumber/virtualHost"</span>);</span><br><span class="line">Connection conn = factory.newConnection();</span><br><span class="line"><span class="comment">//Connection 接口被用来创建一个 Channel:</span></span><br><span class="line">Channel channel= conn.createChannel();</span><br><span class="line"><span class="comment">//在创建之后，Channel可以用来发送或者接收消息了</span></span><br></pre></td></tr></table></figure><p>Connection 可以用来创建多个 Channel 实例，但是 Channel 实例不能在线程问共享， 应用程序应该为每一个线程开辟一个 Channel 。多线程问共享 Channel 实例是非线程安全的。</p><p>Channel 或者 Connection 中有个 <code>isOpen</code> 方法可以用来检测其是否己处于开启状态，这个方法的返回值依赖于 <code>shutdownCause</code> ，不推荐在生产环境使用，可能会产生竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.shutdownCause == <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误地使用 <code>isOpen</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brokenMethod</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.isOpen())&#123;</span><br><span class="line">        <span class="comment">//The following code depends on the channel being in opeηstate.</span></span><br><span class="line">        <span class="comment">//However there is a possibility of the change in the channel state</span></span><br><span class="line">        <span class="comment">//between isOpen() and basicQos(l) call</span></span><br><span class="line">        ...</span><br><span class="line">        channel.basicQos(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，在调用 <code>createXXX</code> 或者 <code>newXXX</code> 方法之后，我们可以简单地认为 Connection 或者 Channel 已经成功地处于开启状态，而并不会在代码中使用 <code>isOpen</code> 这个检测方法。如果在使用 Channel 的时候其己经处于关闭状态，那么程序会抛出一个 <code>com.rabbitmq.client.ShutdownSignalException</code> ，我们只需捕获这个异常即可。当然同时也要试着捕获 <code>IOException</code> 或者 <code>SocketException</code> ，以防 Connection 意外关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validMethod</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">channel.basicQos(l);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ShutdownSignalException sse) &#123;</span><br><span class="line">        <span class="comment">//possibly check if channel was closed</span></span><br><span class="line">        <span class="comment">//by the time we started action and reasons for</span></span><br><span class="line">        <span class="comment">//closing it</span></span><br><span class="line">        ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="comment">//check why connection was closed </span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-使用交换器和队列"><a href="#第二节-使用交换器和队列" class="headerlink" title="第二节 使用交换器和队列"></a><strong>第二节 使用交换器和队列</strong></h2><p>交换器和队列是 AMQP high-level 层面的构建模块，应用程序需确保在使用它们的时候就已经存在了，在使用之前需要先声明（declare）它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个持久化的、非自动删除的、绑定类型为 direct 交换器</span></span><br><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//同时也创建一个非持久化的、排他的、自动删除的队列（此队列的名称由 RabbitMQ 自动生成）</span></span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//使用路由键将队列和交换器绑定起来</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure><p>上面声明的队列具备如下特性：只对当前应用中同一个 Connection 层面可用，同一个 Connection 的不同 Channel 可共用，并且也会在应用连接断开时自动删除。</p><p>如果要在应用中共享一个队列，可以做如下声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上</span></span><br><span class="line">channel.exchangeDeclare(exchangeName , <span class="string">"direct"</span>, <span class="keyword">true</span>) ;</span><br><span class="line"><span class="comment">//队列被声明为持久化的 非排他的、非自动删除的，而且也被分配另一个确定的己知的名称（由客户端分配而非 RabbitMQ 自动生成）</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(queueName , exchangeName , routingKey) ;</span><br></pre></td></tr></table></figure><p>生产者和消费者都可以声明一个交换器或者队列。</p><h3 id="2-1-exchangeDeclare"><a href="#2-1-exchangeDeclare" class="headerlink" title="2.1 exchangeDeclare()"></a><strong>2.1 exchangeDeclare()</strong></h3><p><code>exchangeDeclare()</code> 用来声明交换器，有多种重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> autoDelete, <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String , Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li><code>Exchange.DeclareOk</code> ：用来标识成功声明了一个交换器。</li><li>exchange：交换器的<strong>名称</strong>。</li><li>type：交换器的<strong>类型</strong>。<ul><li>常见的如fanout，direct，topic。</li></ul></li><li>durable：设置<strong>是否持久化</strong>。<ul><li>持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li></ul></li><li>autoDelete：设置<strong>是否自动删除</strong>。<ul><li>自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。</li><li>注意不能错误地把这个参数理解为：当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器。</li></ul></li><li>internal：设置<strong>是否是内置的的交换器</strong>。<ul><li>客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li></ul></li><li>argument：其他一些<strong>结构化参数</strong>，比如 <code>alternate-exchange</code> </li></ul><p>类似的方法：</p><ul><li>exchangeDeclareNoWait：无返回值，不建议使用，刚声明完交换器紧接着就使用，可能导致因交换器未创建而发生异常。</li><li>exchangeDeclarePassive：用来检测相应的交换器是否存在，不存在抛出异常 <code>404 channel exception</code> 同时关闭 Channel 。</li><li>exchangeDelete：删除交换器。</li><li>exchangeDeleteNoWait：无返回删除。</li></ul><h3 id="2-2-queueDeclare"><a href="#2-2-queueDeclare" class="headerlink" title="2.2 queueDeclare()"></a><strong>2.2 queueDeclare()</strong></h3><p><code>queueDeclare()</code> 创建一个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>无参方法默认构建一个 RabbitMQ命名的、排他的、自动删除的、非持久化的队列。</li><li>queue：队列<strong>名称</strong></li><li>durable：设置<strong>是否持久化</strong>。<ul><li>持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li></ul></li><li>exclusive：设置<strong>是否排他</strong>。<ul><li>如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。</li><li>这里需要注意三点：<ul><li>排他队列是基于连接（ Connection ）可见的，同一个连接的不同信道（Channel) 是可以同时访问同一连接创建的排他队列；</li><li>“首次”是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；</li><li>即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。</li></ul></li></ul></li><li>autoDelete：设置是否自动删除。<ul><li>自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为：“当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li></ul></li><li>arguments：设置队列的其他一些参数。<ul><li>如 <code>x-message-ttl</code> <code>x-expires</code> <code>x-max-length</code> <code>x-max-length-bytes</code> <code>x-dead-letter-exchange</code> <code>x-dead-letter-routing-key</code> , <code>x-max-priority</code> 等。</li></ul></li></ul><p>注意：生产者和消费者都能够使用 queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道置为“传输”模式，之后才能声明队列。</p><p>类似的方法这里不再赘述。</p><h3 id="2-3-queueBind"><a href="#2-3-queueBind" class="headerlink" title="2.3 queueBind()"></a><strong>2.3 queueBind()</strong></h3><p><code>queueBind()</code> 将队列与交换器绑定/解绑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">BindOk <span class="title">queueBind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Queue.<span class="function">UnbindOk <span class="title">queueUnbind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>queue：队列名称；</li><li>exchange：交换器的名称；</li><li>routingKey：用来绑定队列和交换器的路由键；</li><li>arguments：定义绑定的一些参数。</li></ul><h3 id="2-4-exchangeBind"><a href="#2-4-exchangeBind" class="headerlink" title="2.4 exchangeBind()"></a><strong>2.4 exchangeBind()</strong></h3><p><code>exchangeBind()</code> 将交换器与交换器绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">BindOk <span class="title">exchangeBind</span><span class="params">(String destination, String source , String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>绑定之后，消息从 source 交换器转发到 destination 交换器，后者可以看作是一个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别声明source和destination交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"source"</span>, <span class="string">"direct"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>) ;</span><br><span class="line">channel.exchangeDeclare(<span class="string">"destination"</span>, <span class="string">"fanout"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//绑定两者</span></span><br><span class="line">channel.exchangeBind(<span class="string">"destination"</span>, <span class="string">"source"</span>, <span class="string">"exKey"</span>);</span><br><span class="line"><span class="comment">//声明队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">"queue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//绑定destination交换器和队列</span></span><br><span class="line">channel.queueBind(<span class="string">"queue"</span>, <span class="string">"destination"</span>，<span class="string">""</span>);</span><br><span class="line"><span class="comment">//source推送消息</span></span><br><span class="line">channel.basicPublish(<span class="string">"source"</span>, <span class="string">"exKey"</span>, <span class="keyword">null</span>, <span class="string">"exToExDemo"</span>. getBytes());</span><br></pre></td></tr></table></figure><p>生产者发送消息至交换器 source 中，交换器 source 根据路由键找到与其匹配 的另一个交换器 destination 井把消息转发到 destination 中，进而存储在 destination 绑定的队列 queue 中：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010156.png" alt></p><h3 id="2-5-何时创建"><a href="#2-5-何时创建" class="headerlink" title="2.5 何时创建"></a><strong>2.5 何时创建</strong></h3><p>RabbitMQ 的<strong>消息存储在队列中</strong>，交换器的使用并不真正耗费服务器的性能，而队列会。 如果要衡量 RabbitMQ 当前的 QPS ，只需看队列的即可。<strong>在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值</strong>，以便在固定硬件资源的情况下能够进行合理有效的分配。 </p><p>按照 RabbitMQ 官方建议，<strong>生产者和消费者都应该尝试创建（这里指声明操作）队列</strong>。这是一个很好的建议，但不适用于所有的情况。如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好（<strong>比如通过页面管理、 RabbitMQ 命令或者更好的是从配置中心下发</strong>），这样业务程序也可以免去声明的过程，直接使用即可。 </p><p>预先创建好资源还有一个好处是，<strong>可以确保交换器和队列之间正确地绑定匹配</strong>。很多时候， 由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失；或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。 当然<strong>可以配合 mandatory 参数或者备份交换器来提高程序的健壮性</strong>。 </p><p>与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。 </p><p>如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，<strong>也完全可以在业务程序中声明队列</strong>。 至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。</p><hr><h2 id="第三节-发送消息"><a href="#第三节-发送消息" class="headerlink" title="第三节 发送消息"></a><strong>第三节 发送消息</strong></h2><p><code>channel.basicPublish()</code> 可以用来发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送一条持久化的消息 hello world!</span></span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//mandatory参数可以更好的控制发送</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes) ; </span><br><span class="line"></span><br><span class="line"><span class="comment">//这条消息的投递模式（delivery mode）为2，消息会被持久化到服务器中</span></span><br><span class="line"><span class="comment">//消息的优先级设置为1，contentType为text/plain</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQPBasicProperties.Builder()</span><br><span class="line">                           .contentType(<span class="string">"text/plain"</span>)</span><br><span class="line">                           .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                           .priority(<span class="number">1</span>)</span><br><span class="line">                           .userld(<span class="string">"hidden"</span>)</span><br><span class="line">                           .build()), messageBodyBytes); </span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以设置消息的headers</span></span><br><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;String Object&gt;();</span><br><span class="line">headers.put(<span class="string">"localtion"</span>，<span class="string">"here"</span>);</span><br><span class="line">headers.put(<span class="string">"time"</span>, <span class="string">"today"</span>);</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                           .headers(headers)</span><br><span class="line">                           .build()), messageBodyBytes); </span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以带过期时间</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                           .expiration(<span class="string">"60000"</span>) </span><br><span class="line">                           .build()), messageBodyBytes);</span><br></pre></td></tr></table></figure><p>包括各种重载方法，有以下具体参数：</p><ul><li>exchange：交换器的名称，指明消息需要发送到哪个交换器中，如果设置为空字符串， 则消息会被发送到 RabbitMQ 默认的交换器中。 </li><li>routingKey：路由键，交换器根据路由键将消息存储到相应的队列之中 </li><li>props：消息的基本属性集，其包含 14 个属性成员，分别有 <code>contentType</code> 、<code>contentEncoding</code> 、 <code>headers(Map&lt;String, Object&gt;)</code> 、<code>deliveryMode</code> 、<code>priority</code> 、<code>correlationId</code> 、<code>replyTo</code> 、<code>expiration</code> 、<code>messageId</code> 、<code>timestamp</code> 、<code>type</code> 、<code>userId</code> 、<code>appId</code> 、<code>clusterId</code> </li><li>byte[] body：消息体，真正要发送的消息。</li><li>mandatory：为 true 时，且交换器无法根据自身的类型和路由键找到一个符合条件的队列，调用 <code>Basic.Return</code> 命令将消息返回给生产者。为 false 时，消息直接被丢弃。</li><li>immediate：为true时，若交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时， 该消息会通过 <code>Basic.Return</code> 返回至生产者。</li></ul><hr><h2 id="第四节-消费消息"><a href="#第四节-消费消息" class="headerlink" title="第四节 消费消息"></a><strong>第四节 消费消息</strong></h2><p>两种模式：</p><ul><li>推模式：采用 <code>Basic.Consume</code> 进行消费；</li><li>拉模式：采用 <code>Basic.Get</code> 进行消费。</li></ul><h3 id="4-1-推模式"><a href="#4-1-推模式" class="headerlink" title="4.1 推模式"></a>4.1 推模式</h3><p>通过持续订阅的方式消费消息，接收消息一般通过实现 <code>Consumer</code> 接口或者继承 <code>DefaultConsumer</code> 类来实现。不同的订阅采用不同的消费者标签（ConsumerTag）来区分彼此。</p><p>主要通过方法 <code>channel.basicConsume()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">      <span class="comment">//接收到消息之后进行显式 ack 操作 channel.basicAck 对于消费者很必要，防止消息不必要的消失</span></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">      channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">      channel.basicConsume(QUEUE_NAME, autoAck, <span class="string">"myConsumerTag"</span>,</span><br><span class="line">              <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                      String routingKey = envelope.getRoutingKey();</span><br><span class="line">                      String contentType = properties.getContentType();</span><br><span class="line">                      <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                      <span class="comment">// process the message components here ...</span></span><br><span class="line">                      channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>queue：队列的名称；</li><li>autoAck：设置是否自动确认。建议设成 false ，即不自动确认；</li><li>consumerTag：消费者标签，用来区分多个消费者；</li><li>noLocal 设置为 true 则表示不能将同一个 Connection 中生产者发送的消息传送给这个 Connection 中的消费者；</li><li>exclusive：设置是否排他 ；</li><li>arguments：设置消费者的其他参数；</li><li>callback：设置消费者的回调函数。用来处理 RabbitMQ 推送过来的消息，比如 DefaultConsumer 使用时需要客户端重写其中的方法。</li></ul><p>消费者客户端可以重写多种方法：</p><ul><li><code>handleDelivery()</code></li><li><code>handleConsumerOk()</code> ：会在其他方法之前调用，返回消费者标签。</li><li><code>handleCancelOk()</code> ：消费端可以在显式地取消订阅的时候调用。</li><li><code>handleCancel()</code> ：消费端可以在隐式地取消订阅的时候调用</li><li><code>handleShutdownSignal()</code> ：当 Channel 或者 Connection 关闭的时候会调用。</li><li><code>handleRecoverOk()</code></li></ul><p>通过 <code>channel.basicCancel()</code> 显式地取消一个消费者的订阅，先触发 <code>handleConsumerOk()</code> ，然后是 <code>handleDelivery()</code> ，最后是 <code>handleCancelOk()</code> 。</p><p>和生产者一样，消费者客户端同样需要考虑线程安全的问题。消费者客户端的这些 callback 会被分配到与 Channel 不同的线程池上，这意味着消费者客户端可以安全地调用这些阻塞方法，比如 <code>channel.queueDeclare</code> ， <code>channel.basicCancel</code> 等。 </p><p>每个 Channel 都拥有自己独立的线程。最常用的做法是一个 Channel 对应一个消费者， 也就是意味着消费者彼此之间没有任何关联。当然也可以在一个 Channel 中维持多个消费者， 但是要注意一个问题，如果 Channel 中的一个消费者一直在运行，那么其他消费者的 callback 会被“耽搁”。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png" alt></p><h3 id="4-2-拉模式"><a href="#4-2-拉模式" class="headerlink" title="4.2 拉模式"></a>4.2 拉模式</h3><p>通过 <code>channel.basicGet()</code> 可以单条的获取消息，当 autoAck 设置为false，需要用 <code>channel.basicAck()</code> 来确认消息已被成功接收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out,println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010158.png" alt></p><p><code>Basic.Consume</code> 将信道（Channel）置为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 <code>Basic.Qos</code> 的限制．如果只想从队列获得单条消息而不是持续订阅，建议还是使用 <code>Basic.Get</code> 进行消费．但是不能将 <code>Basic.Get</code> 放在一个循环里来代替 <code>Basic.Consume</code> ，这样做会严重影响 RabbitMQ 的性能．如果要实现高吞吐量，消费者理应使用 <code>Basic.Consume</code> 方法。</p><hr><h2 id="第五节-消费端的确认与拒绝"><a href="#第五节-消费端的确认与拒绝" class="headerlink" title="第五节 消费端的确认与拒绝"></a><strong>第五节 消费端的确认与拒绝</strong></h2><p>为了保证消息从队列可靠地达到消费者， RabbitMQ 提供了消息确认机制 （message acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false 时， RabbitMQ 会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。当 autoAck 等于 true 时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息。</p><p>采用消息确认机制后，只要设置 autoAck 参数为 false ，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题 因为 RabbitMQ 会一直等待持有消息直到消费者显式调 <code>Basic.Ack</code> 命令为止。</p><p>当 autoAck 参数置为 false ，对于 RabbitMQ 服务端而言，队列中的消息分成了两个部分：一部分是等待投递给消费者的消息；一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p><p>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。 </p><p>RabbtiMQ 的 Web 管理平台上可以看到当前队列中的“Ready ”状态 和“Unacknowledged ＂状态的消息数，分别对应上文中的等待投递给消费者的消息数和己经投递给消费者但是未收到确认信号的消息数：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010159.png" alt></p><p>也可以通过相应的命令来查看上述信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_queues name message_ready messages_unacknowledged</span></span><br><span class="line">Listing queues ...</span><br><span class="line">queue         1   0</span><br><span class="line">queue_demo    0</span><br></pre></td></tr></table></figure><p>在消费者接收到消息后，如果想明确拒绝当前的消息而不是确认，那么应该怎么做呢？通过 <code>Basic.Reject</code> 这个命令，消费者客户端可以调用与其对应的 <code>channel.basicReject</code> 方法来告诉 RabbitMQ 拒绝这个消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>deliveryTag：消息编号，64位的长整型值。</li><li>requeue：当为true时，RabbitMQ会重新将此条消息存入队列，以便可以发送给下一个订阅的消费者；当为false时，立即将消息从队列中移除。</li></ul><p>批量拒绝消息需要 <code>Basic.Nack</code> ，客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>multiple：为false时，表示拒绝单条消息；为true时，拒绝编号前所有未被消费者确认的消息。</li></ul><p><code>channel.basicRecover()</code> 请求RabbitMQ重新发送还未被确认的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Basic.<span class="function">RecoverOk <span class="title">basicRecover</span><span class="params">(<span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>requeue：为true，未被确认的消息会被重新加入到队列，可能会被分配给另外一个消费者；为false，同一条消息会被分配给之前相同的消费者。</li></ul><hr><h2 id="第六节-关闭连接"><a href="#第六节-关闭连接" class="headerlink" title="第六节 关闭连接"></a><strong>第六节 关闭连接</strong></h2><p>在应用程序使用完之后，需要关闭连接，释放资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>在 Connection 关闭的时候， Channel 也会自动关闭。</p><p>Connection Channel 所具备的生命周期如下所述：</p><ul><li>Open：开启状态，代表当前对象可以使用。 </li><li>Closing：正在关闭状态。当前对象被显式地通知调用关闭方法（shutdown），这样就产生了一个关闭请求让其内部对象进行操作并等待这些关闭操作的完成。 </li><li>Closed：已经关闭状态。当前对象己经接收到所有的内部对象己完成关闭动作的通知，并且其也关闭了自身。</li></ul><p>当 Connection 或者 Channel 的状态转变为 Closed 的时候会调用  <code>ShutdownListener</code> 。而且如果将一个 <code>ShutdownListener</code> 注册到一个己经处于 Closed 状态的对象（这里特指 Connection 和 Channel 对象），会立刻调用  <code>ShutdownListener</code> 。</p><p><code>getCloseReason</code> 方法可以让你知道对象关闭的原因 <code>isOpen</code> 方法检测对象当前是否处于开启状态： <code>close(int closeCode , String closeMessage)</code> 方法显式地通知当前对象执行关闭操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.addShutdownListener(<span class="keyword">new</span> ShutdownListener()&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownCompleted</span><span class="params">(ShutdownSignalException cause)</span></span>&#123;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>当触发 ShutdownListener 的时候，就可以获取到 ShutdownSignalException ，这个 ShutdownSignalException 包含了关闭的原因，可以通过<code>getCloseReason</code> 方法获取。 <code>isHardError</code> 方法 可以知道是 <code>Connection</code> 的还是 <code>Channel</code> 的错误； <code>getReason</code> 方法可以获取 cause 相关的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownCompleted</span><span class="params">(ShutdownSignal cause)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(cause.isHardError())&#123;</span><br><span class="line">           Connection conn = (Connection) cause.getReference();</span><br><span class="line">           <span class="keyword">if</span>(!cause.isInitiatedByApplication())&#123;</span><br><span class="line">               Method reason = cause.getReason();</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Channel ch = (Channel) cause.getReference();</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第二章《客户端开发》，内容来自于《RabbitMQ实战指南》，内容包括：连接RabbitMQ，使用交换器和队列，发送消息，消费消息，消费端的确认与拒绝，关闭连接。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
</feed>
