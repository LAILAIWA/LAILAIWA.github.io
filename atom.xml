<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-12-20T10:46:14.051Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法复习 (二) 查找-平衡查找树</title>
    <link href="http://linyishui.top/2019110801.html"/>
    <id>http://linyishui.top/2019110801.html</id>
    <published>2019-11-08T10:44:43.000Z</published>
    <updated>2019-12-20T10:46:14.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a><strong>平衡查找树</strong></h1><p>&emsp;&emsp;一棵有N个节点的树，我们希望它的树高为lgN，这样可以保证所有查找都在lgN次比较内结束，但可惜在动态插入中保证树的完美平衡代价太高了。</p><h2 id="第一节-2-3查找树"><a href="#第一节-2-3查找树" class="headerlink" title="第一节 2-3查找树"></a><strong>第一节 2-3查找树</strong></h2><p>&emsp;&emsp;二叉树中的节点可以称作2-结点：含有一个键和两个链接，现在我们引入3-结点，含有两个键和三个链接。每条链接都对应着其中保存的键所分割产生的一个区间。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010101.png" alt="2-3查找树示意图"></p><p>&emsp;&emsp;一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。</p><h3 id="1-1-查找"><a href="#1-1-查找" class="headerlink" title="1.1 查找"></a><strong>1.1 查找</strong></h3><p>&emsp;&emsp;将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。具体查找过程如图 3.3.2 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010102.png" alt="2-3树中的查找命中（左）和未命中（右）">　</p><h3 id="1-2-向2-结点中插入新键"><a href="#1-2-向2-结点中插入新键" class="headerlink" title="1.2 向2-结点中插入新键"></a><strong>1.2 向2-结点中插入新键</strong></h3><p>&emsp;&emsp;要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用2-3树的主要原因就在于它能够在插入后继续保持平衡。如果未命中的查找结束于一个2-结点，事情就好办了：我们<strong>只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可</strong>。如果未命中的查找结束于一个3-结点，事情就要麻烦一些。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010103.png" alt="向2-结点中插入新的键"></p><h3 id="1-3-向一棵只含有一个3-结点的树中插入新键"><a href="#1-3-向一棵只含有一个3-结点的树中插入新键" class="headerlink" title="1.3 向一棵只含有一个3-结点的树中插入新键"></a><strong>1.3 向一棵只含有一个3-结点的树中插入新键</strong></h3><p>&emsp;&emsp;在考虑一般情况之前，先假设我们需要向一棵只含有一个3-结点的树中插入一个新键。这棵树中有两个键，所以在它唯一的结点中已经没有可插入新键的空间了。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。它很自然地扩展了以前的结点并含有3个键和4条链接。创建一个4-结点很方便，因为很容易将它转换为一棵由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点的右链接相连）。这棵树既是一棵含有3个结点的二叉查找树，同时也是一棵完美平衡的2-3树，因为其中所有的空链接到根结点的距离都相等。插入前树的高度为0，插入后树的高度为1。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010104.png" alt="向一棵只含有一个3-结点的树中插入新键"></p><h3 id="1-4-向一个父结点为2-结点的3-结点中插入新键"><a href="#1-4-向一个父结点为2-结点的3-结点中插入新键" class="headerlink" title="1.4 向一个父结点为2-结点的3-结点中插入新键"></a><strong>1.4 向一个父结点为2-结点的3-结点中插入新键</strong></h3><p>&emsp;&emsp;作为第二轮热身，假设未命中的查找结束于一个3-结点，而它的父结点是一个2-结点。在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间。我们先像刚才一样构造一个临时的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。你可以将这次转换看成将指向原3-结点的一条链接替换为新父结点中的原中键左右两边的两条链接，并分别指向两个新的2-结点。根据我们的假设，父结点中是有空间的：父结点是一个2-结点（一个键两条链接），插入之后变为了一个3-结点（两个键3条链接）。另外，这次转换也并不影响（完美平衡的）2-3树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同。请确认你完全理解了这次转换——它是2-3 树的动态变化的核心，其过程如图 3.3.5 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010105.png" alt="向一个父结点为2-结点的3-结点中插入新键"></p><h3 id="1-5-向一个父结点为3-结点的3-结点中插入新键"><a href="#1-5-向一个父结点为3-结点的3-结点中插入新键" class="headerlink" title="1.5 向一个父结点为3-结点的3-结点中插入新键"></a><strong>1.5 向一个父结点为3-结点的3-结点中插入新键</strong></h3><p>&emsp;&emsp;现在假设未命中的查找结束于一个父结点为3-结点的结点。我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此我们再用这个中键构造一个新的临时4-结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，我们就这样一直向上不断分解临时的4-结点并将中键插入更高层的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。该过程如图 3.3.6 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010106.png" alt="向一个父结点为3-结点的3-结点中插入新键"></p><h3 id="1-6-分解根结点"><a href="#1-6-分解根结点" class="headerlink" title="1.6 分解根结点"></a><strong>1.6 分解根结点</strong></h3><p>&emsp;&emsp;如果从插入结点到根结点的路径上全都是3-结点，我们的根结点最终变成一个临时的4-结点。此时我们可以按照向一棵只有一个3-结点的树中插入新键的方法处理这个问题。我们将临时的4-结点分解为3个2-结点，使得树高加1，如图 3.3.7 所示。请注意，这次最后的变换仍然保持了树的完美平衡性，因为它变换的是根结点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010107.png" alt="分解根结点"></p><h3 id="1-7-局部变换"><a href="#1-7-局部变换" class="headerlink" title="1.7 局部变换"></a><strong>1.7 局部变换</strong></h3><p>&emsp;&emsp;将一个4-结点分解为一棵2-3树可能有6种情况，都总结在了图 3.3.8 中。这个4-结点可能是根结点，可能是一个2-结点的左子结点或者右子结点，也可能是一个3-结点的左子结点、中子结点或者右子结点。23树插入算法的根本在于这些变换都是局部的：<strong>除了相关的结点和链接之外不必修改或者检查树的其他部分</strong>。每次变换中，变更的链接数量不会超过一个很小的常数。需要特别指出的是，不光是在树的底部，树中的任何地方只要符合相应的模式，变换都可以进行。每个变换都会将4结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010108.png" alt="在一棵2-3树中分解一个4-结点的情况汇总"></p><h3 id="1-8-全局性质"><a href="#1-8-全局性质" class="headerlink" title="1.8 全局性质"></a><strong>1.8 全局性质</strong></h3><p>&emsp;&emsp;这些局部变换不会影响树的全局有序性和平衡性：<strong>任意空链接到根结点的路径长度都是相等的</strong>。作为参考，图 3.3.9 所示的是当一个4-结点是一个 3-结点的中子结点时的完整变换情况。如果在变换之前根结点到所有空链接的路径长度为h，那么变换之后该长度仍然为h。所有的变换都具有这个性质，即使是将一个4-结点分解为两个2-结点并将其父结点由2-结点变为3-结点，或是由3-结点变为一个临时的4-结点时也是如此。当根结点被分解为3个2-结点时，所有空链接到根结点的路径长度才会加1。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010109.png" alt="4-结点的分解是一次局部变换，不会影响树的有序性和平衡性"></p><p>&emsp;&emsp;和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。 如果你花点时间仔细研究一下图 3.3.10，就能很好地理解2-3树的构造方式。它给出了我们的标准索引测试用例中产生的一系列2-3树，以及一系列由同一组键按照升序依次插入到树中时所产生的所有2-3树。还记得在二叉查找树中，按照升序插入10 个键会得到高度为9的一棵最差查找树吗？如果使用2-3树，树的高度是2。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010110.png" alt="2-3树的构造轨迹"></p><h3 id="1-9-性能分析"><a href="#1-9-性能分析" class="headerlink" title="1.9 性能分析"></a><strong>1.9 性能分析</strong></h3><p>&emsp;&emsp;2-3树的分析和二叉查找树的分析大不相同，因为我们主要感兴趣的是最坏情况下的性能，而非一般情况（这种情况下我们会用随机键模型分析预期的性能）。在符号表的实现中，一般我们无法控制用例会按照什么顺序向表中插入键，因此对最坏情况的分析是唯一能够提供性能保证的办法。</p><blockquote><ul><li>命题 F。在一棵大小为的2-3树中，查找和插入操作访问的结点必然不超过lgN个。</li><li>证明。一棵含有N个结点的2-3树的高度在log3(N)=[lgN / lg3]（如果树中全是3-结点）和[lgN]（如果树中全是2-结点）之间。</li></ul></blockquote><p>&emsp;&emsp;因此我们可以确定2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。通过对比图 3.3.11 中的2-3树和图 3.2.8 中由相同的键构造的二叉查找树，你也可以看到，完美平衡的 2-3树要平展得多。例如，含有 10 亿个结点的一棵2-3树的高度仅在19到30之间。我们最多只需 访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是相当惊人的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010111.png" alt="由随机键构造的一棵典型的2-3树"></p><p>&emsp;&emsp;但是，我们和真正的实现还有一段距离。尽管我们可以用不同的数据类型表示2-结点和3-结点并写出变换所需的代码，但用这种直白的表示方法实现大多数的操作并不方便，因为需要处理的情况实在太多。我们需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。幸运的是你将看到，我们只需要一点点代价就能用一种统一的方式完成所有变换。</p><hr><h2 id="第二节-红黑查找树"><a href="#第二节-红黑查找树" class="headerlink" title="第二节 红黑查找树"></a><strong>第二节 红黑查找树</strong></h2><h3 id="2-1-替换3-结点"><a href="#2-1-替换3-结点" class="headerlink" title="2.1 替换3-结点"></a><strong>2.1 替换3-结点</strong></h3><p>&emsp;&emsp;红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。我们将树中的链接分为两种类型：<strong>红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接</strong>。确切地说，我们<strong>将3-结点表示为由一条左斜的红色链接相连的两个2-结点</strong>，如图 3.3.12 所示。这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。我们将用这种方式表示2-3树的二叉查找树称为红黑二叉查找树（以下简称为红黑树）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010112.png" alt="由一条红色左链接相连的两个2-结点表示一个3-结点"></p><h3 id="2-2-一种等价的定义"><a href="#2-2-一种等价的定义" class="headerlink" title="2.2 一种等价的定义"></a><strong>2.2 一种等价的定义</strong></h3><p>&emsp;&emsp;红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：</p><blockquote><ul><li>红链接均为左链接；</li><li>没有任何一个结点同时和两条红链接相连； </li><li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li></ul></blockquote><p>&emsp;&emsp;满足这样定义的红黑树和相应的 2-3 树是<strong>一一对应</strong>的。</p><h3 id="2-3-一一对应"><a href="#2-3-一一对应" class="headerlink" title="2.3 一一对应"></a><strong>2.3 一一对应</strong></h3><p>&emsp;&emsp;如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相同的（如图 3.3.13 所示）。如果我们将由红链接相连的结点合并，得到的就是一棵2-3树。相反，如果将一棵2-3树中的3-结点画作由红色左链接相连的两个2-结点，那么不会存在能够和两条红链接相连的结点，且树必然是完美黑色平衡的，因为黑链接即2-3树中的普通链接，根据定义这些链接必然是完美平衡的。无论我们选择用何种方式去定义它们，红黑树都既是二叉查找树，也是2-3树，如图 3.3.14 所示。因此，如果我们能够在保持一一对应关系的基础上实现2-3树的插入算法，那么我们就能够将两个算法的优点结合起来：二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010113.png" alt="将红链接画平时，一棵红黑树就是一棵2-3树"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010114.png" alt="红黑树和2-3树的一一对应关系"></p><h3 id="2-4-颜色表示"><a href="#2-4-颜色表示" class="headerlink" title="2.4 颜色表示"></a><strong>2.4 颜色表示</strong></h3><p>&emsp;&emsp;方便起见，因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量 color 中。如果指向它的链接是红色的，那么该变量为true，黑色则为false。我们约定空链接为黑色。为了代码的清晰我们定义了两个常量 RED 和 BLACK 来设置和测试这个变量。我们使用私有方法 isRed() 来测试一个结点和它的父结点之间的链接的颜色。颜色表示的代码实现如图 3.3.15 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010115.png" alt="红黑树的结点表示"></p><h3 id="2-5-旋转"><a href="#2-5-旋转" class="headerlink" title="2.5 旋转"></a><strong>2.5 旋转</strong></h3><p>&emsp;&emsp;在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地旋转并修复。旋转操作会改变红链接的指向。首先，假设我们有一条红色的右链接需要被转化为左链接（请见图 3.3.16）。这个操作叫做<strong>左旋转</strong>，它对应的方法接受一条指向红黑树中的某个结点的链接作为参<br>数。假设被指向的结点的右链接是红色的，这个方法会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根结点的链接。<strong>我们只是将用两个键中的较小者作为根结点变为将较大者作为根结点</strong>。实现将一个红色左链接转换为一个红色右链接的一个右旋转的代码完全相同，只需要将 left 和 right 互换即可（如图 3.3.17 所示）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010116.png" alt="左旋转h的右链接"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010117.png" alt="右旋转h的左链接"></p><h3 id="2-6-在旋转后重置父结点的链接"><a href="#2-6-在旋转后重置父结点的链接" class="headerlink" title="2.6 在旋转后重置父结点的链接"></a><strong>2.6 在旋转后重置父结点的链接</strong></h3><p>&emsp;&emsp;无论左旋转还是右旋转，旋转操作都会返回一条链接。我们总是会用rotateRight()或rotateLeft()的返回值重置父结点（或是根结点）中相应的链接。返回的链接可能是左链接也可能是右链接，但是我们总会将它赋予父结点中的链接。这个链接可能是红色也可能是黑色——rotateLeft()和rotateRight()都通过将x.color设为h.color保留它原来的颜色。这可能会产生两条连续的红链接，但我们的算法会继续用旋转操作修正这种情况。例如，代码h = rotateLeft(h); 将旋转结点h的红色右链接，使得h指向了旋转后的子树的根结点（组成该子树中的所有键和旋转前相同，只是根结点发生了变化）。这种简洁的代码是我们使用递归实现二叉查找树的各种方法的主要原因。你会看到，它使得旋转操作成为了普通插入操作的一个简单补充。</p><p>&emsp;&emsp;在插入新的键时我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：有序性和完美平衡性。也就是说，我们在红黑树中进行旋转时无需为树的有序性或者完美平衡性担心。下面我们来看看应该如何使用旋转操作来保持红黑树的另外两个重要性质（不存在两条连续的红链接和不存在红色的右链接）。我们先用一些简单的情况热热身。</p><h3 id="2-7-向单个2-结点中插入新键"><a href="#2-7-向单个2-结点中插入新键" class="headerlink" title="2.7 向单个2-结点中插入新键"></a><strong>2.7 向单个2-结点中插入新键</strong></h3><p>&emsp;&emsp;一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键之后，我们马上就需要将它们旋转。如果新键小于老键，我们只需要新增一个红色的结点即可，新的红黑树和单个3-结点完全等价。如果新键大于老键，那么新增的红色结点将会产生一条红色的右链接。我们需要使用 root = rotateLeft(root); 来将其旋转为红色左链接并修正根结点的链接，插入操作才算完成。两种情况的结果均为一棵和单个3- 结点等价的红黑树，其中含有两个键，一条红链接，树的黑链接高度为1， 如图 3.3.18 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010118.png" alt="向单个2-结点中插入一个新键"></p><h3 id="2-8-向树底部的2-结点插入新键"><a href="#2-8-向树底部的2-结点插入新键" class="headerlink" title="2.8 向树底部的2-结点插入新键"></a><strong>2.8 向树底部的2-结点插入新键</strong></h3><p>&emsp;&emsp;用和二叉查找树相同的方式向一棵红黑树中插入一个新键会在树的底部新增一个结点（为了保证有序性），但总是用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种处理方法仍然适用。如果指向新结点的是父结点的左链接，那么父结点就直接成为了一个3-结点；如果指向新结点的是父结点的右链接，这就是一个错误的3-结点，但一次左旋转就能够修正它，如图 3.3.19 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010119.png" alt="向树底部的2-结点插入一个新键"></p><h3 id="2-9-向一棵双键树（即一个3-结点）中插入新键"><a href="#2-9-向一棵双键树（即一个3-结点）中插入新键" class="headerlink" title="2.9 向一棵双键树（即一个3-结点）中插入新键"></a><strong>2.9 向一棵双键树（即一个3-结点）中插入新键</strong></h3><p>&emsp;&emsp;这种情况又可分为三种子情况：<strong>新键小于树中的两个键</strong>，<strong>在两者之间</strong>，<strong>或是大于树中的两个键</strong>。每种情况中都会产生一个同时连接到两条红链接的结点，而我们的目标就是修正这一点。</p><blockquote><ul><li>三者中最简单的情况是新键大于原树中的两个键，因此它被连接到3-结点的右链接。此时树是平衡的，根结点为中间大小的键，它有两条红链接分别和较小和较大的结点相连。如果我们将两条链接的颜色都由红变黑，那么我们就得到了一棵由三个结点组成、高为2的平衡树。它正好能够对应一棵2-3树，如图 3.3.20（左）。其他两种情况最终也会转化为这种情况。 </li><li>如果新键小于原树中的两个键，它会被连接到最左边的空链接，这样就产生了两条连续的红链接，如图 3.3.20（中）。此时我们只需要将上层的红链接右旋转即可得到第一种情况（中值键为根结点并和其他两个结点用红链接相连）。 </li><li>如果新键介于原树中的两个键之间，这又会产生两条连续的红链接，一条红色左链接接一条红色右链接，如图 3.3.20（右）。此时我们只需要将下层的红链接左旋转即可得到第二种情况（两条连续的红色左链接）。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010120.png" alt="向一棵双键树（即一个3-结点）中插入一个新键的三种情况"></p><p>&emsp;&emsp;总的来说，我们通过 0 次、1 次和 2 次旋转以及颜色的变化得到了期望的结果。在 2-3 树中，请确认你完全理解了这些转换，它们是红黑树的动态变化的关键。</p><h3 id="2-10-颜色转换"><a href="#2-10-颜色转换" class="headerlink" title="2.10 颜色转换"></a><strong>2.10 颜色转换</strong></h3><p>&emsp;&emsp;如图 3.3.21 所示，我们专门用一个方法 flipColors() 来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将父结点的颜色由黑变红。这项操作最重要的性质在于它和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性。根据这一点，我们马上能够在下面完整地实现红黑树。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010121.png" alt="通过转换链接的颜色来分解4-结点"></p><h3 id="2-11-根结点总是黑色"><a href="#2-11-根结点总是黑色" class="headerlink" title="2.11 根结点总是黑色"></a><strong>2.11 根结点总是黑色</strong></h3><p>&emsp;&emsp;在 3.3.2.9 所述的情况中，颜色转换会使根结点变为红色。这也可能出现在很大的红黑树中。严格地说，红色的根结点说明根结点是一个3结点的一部分，但实际情况并不是这样。因此我们在每次插入后都会将根结点设为黑色。注意，每当根结点由红变黑时树的黑链接高度就会加1。</p><h3 id="2-12-向树底部的3-结点插入新键"><a href="#2-12-向树底部的3-结点插入新键" class="headerlink" title="2.12 向树底部的3-结点插入新键"></a><strong>2.12 向树底部的3-结点插入新键</strong></h3><p>&emsp;&emsp;现在假设我们需要在树的底部的一个3-结点下加入一个新结点。前面讨论过的三种情况都会出现，如图 3.3.22 所示。指向新结点的链接可能是3-结点的右链接（此时我们只需要转换颜色即可），或是左链接（此时我们需要进行右旋转然后再转换颜色），或是中链接（此时我们 需要先左旋转下层链接然后右旋转上层链接，最后再转换颜色）。颜色转换会使到中结点的链接变红，相当于将它送入了父结点。这意味着在父结点中继续插入一个新键，我们也会继续用相同的办法解决这个问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010122.png" alt="向树底部的3-结点插入一个新键"></p><h3 id="2-13-将红链接在树中向上传递"><a href="#2-13-将红链接在树中向上传递" class="headerlink" title="2.13 将红链接在树中向上传递"></a><strong>2.13 将红链接在树中向上传递</strong></h3><p>&emsp;&emsp;2-3 树中的插入算法需要我们分解 3- 结点，将中间键插入父结点，如此这般直到遇到一个2-结点或是根结点。我们所考虑过的所有情况都正是为了达成这个目标：每次必要的旋转之后我们都会进行颜色转换，这使得中结点变红。在父结点看来，处理这样一个红色结点的方式和处理一个新插入的红色结点完全相同，即继续把红链接转移到中结点上去。图 3.3.23 中总结的三种情况显示了在红黑树中实现2-3树的插入算法的 关键操作所需的步骤：要在一个3-结点下插入新键，先创建一个临时 的4-结点，将其分解并将红链接由中间键传递给它的父结点。重复这个过程，我们就能将红链接在树中向上传递，直至遇到一个2-结点或者根结点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010123.png" alt="红黑树中红链接向上传递"></p><p>&emsp;&emsp;总之，只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作，我们就能够保证插入操作后红黑树和2-3树的一一对应关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：</p><blockquote><ul><li>如果右子结点是红色的而左子结点是黑色的，进行左旋转； </li><li>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；</li><li>如果左右子结点均为红色，进行颜色转换。</li></ul></blockquote><p>&emsp;&emsp;你应该花点时间确认以上步骤处理了前文描述的所有情况。请注意，第一个操作表示将一个2-结点变为一个3-结点和插入的新结点与树底部的3-结点通过它的中链接相连的两种情况。</p><hr><h2 id="第三节-实现"><a href="#第三节-实现" class="headerlink" title="第三节 实现"></a><strong>第三节 实现</strong></h2><p>&emsp;&emsp;因为保持树的平衡性所需的操作是由下向上在每个所经过的结点中进行的，将它们植入我们已有的实现中十分简单：只需要在递归调用之后完成这些操作即可，如算法 3.4 所示。上一段中列出的三种操作都可以通过一个检测两个结点的颜色的if语句完成。尽管实现所需的代码量很小，但如果没有我们学习过的两种抽象数据结构（2-3 树和红黑树）作为铺垫，这段实现仍然会非常难以理解。在检查了三到五个结点的颜色之后（也许还需要进行一两次旋转以及颜色转换），我们就可以得到一棵近乎完美平衡的二叉查找树。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST&lt;Key</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;Key&gt;</span>, <span class="title">Value&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> root;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="title">//</span> <span class="title">含有color变量的Node对象（请见3</span>.3.2.4<span class="title">节）</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">boolean</span> <span class="title">isRed</span>(<span class="params"><span class="type">Node</span> h</span>)    <span class="title">//</span> <span class="title">请见3</span>.3.2.4<span class="title">节</span>   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Node</span> <span class="title">rotateLeft</span>(<span class="params"><span class="type">Node</span> h</span>)  <span class="title">//</span> <span class="title">请见图3</span>.3.16   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Node</span> <span class="title">rotateRight</span>(<span class="params"><span class="type">Node</span> h</span>) <span class="title">//</span> <span class="title">请见图3</span>.3.17   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">void</span> <span class="title">flipColors</span>(<span class="params"><span class="type">Node</span> h</span>)  <span class="title">//</span> <span class="title">请见图3</span>.3.21</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">int</span> <span class="title">size</span>(<span class="params"></span>)               <span class="title">//</span> <span class="title">请见算法3</span>.3</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">put</span>(<span class="params"><span class="type">Key</span> key, <span class="type">Value</span> val</span>)</span>&#123;  </span><br><span class="line">       <span class="comment">// 查找key，找到则更新其值，否则为它新建一个结点      </span></span><br><span class="line">       root = put(root, key, <span class="keyword">val</span>);      </span><br><span class="line">       root.color = <span class="type">BLACK</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> put(<span class="type">Node</span> h, <span class="type">Key</span> key, <span class="type">Value</span> <span class="keyword">val</span>)   &#123;     </span><br><span class="line">        <span class="comment">// 标准的插入操作，和父结点用红链接相连    </span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>)       </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Node</span>(key, <span class="keyword">val</span>, <span class="number">1</span>, <span class="type">RED</span>);</span><br><span class="line"></span><br><span class="line">        int cmp = key.compareTo(h.key);      </span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">            h.left  = put(h.left,  key, <span class="keyword">val</span>);      </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">            h.right = put(h.right, key, <span class="keyword">val</span>);      </span><br><span class="line">        <span class="keyword">else</span> h.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))  h = rotateLeft(h);             </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left))  h = rotateRight(h);             </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right))  flipColors(h);</span><br><span class="line">            </span><br><span class="line">        h.<span class="type">N</span> = size(h.left) + size(h.right) + <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">return</span> h;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了递归调用后的三条 if 语句，红黑树中 put() 的递归实现和二叉查找树中 put() 的实现完全相同。它们在查找路径上保证了红黑树和2-3树的一一对应关系，使得树的平衡性接近完美。第一条 if 语句会将任意含有红色右链接的3-结点（或临时的4-结点）向左旋转；第二条 if 语句会将临时的4-结点中两条连续红链接中的上层链接向右旋转；第三条 if 语句会进行颜色转换并将红链接在树中向上传递（详情请见正文）。</p><p>&emsp;&emsp;图 3.3.24 给出了使用我们的标准索引测试用例进行测试的轨迹和用同一组键按照升序构造一棵红黑树的测试轨迹。仅从红黑树的三种标准操作的角度分析这些例子对我们理解问题很有帮助，之前我们也是这样做的。另一个基本练习是检查它们和2-3树的一一对应关系（可以对比图 3.3.10 中由同一组键构造的2-3树）。在两种情况中你都能通过思考将 P 插入红黑树所需的转换来检验你对算法的理解程度（请见练习 3.3.12）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010124.png" alt="红黑树的构造轨迹"></p><hr><h2 id="第四节-删除操作"><a href="#第四节-删除操作" class="headerlink" title="第四节 删除操作"></a><strong>第四节 删除操作</strong></h2><p>&emsp;&emsp;算法3.4中的 put() 方法是本书中最复杂的实现之一，而红黑树的 deleteMin()、deleteMax() 和 delete() 的实现更麻烦，我们将它们的完整实现留做练习，但这里仍然需要学习它们的基本原理。要描述删除算法，首先我们要回到2-3树。和插入操作一样，我们也可以定义一系列局部变换来在删除一个结点的同时保持树的完美平衡性。这个过程比插入一个结点更加复杂，因为我们不仅要在（为了删除一个结点而）构造临时4-结点时沿着查找路径向下进行变换，还要在分解遗留的4-结点时沿着查找路径向上进行变换（同插入操作）。</p><h3 id="4-1-自顶向下的2-3-4树"><a href="#4-1-自顶向下的2-3-4树" class="headerlink" title="4.1 自顶向下的2-3-4树"></a><strong>4.1 自顶向下的2-3-4树</strong></h3><p>&emsp;&emsp;作为第一轮热身，我们先学习一个沿查找路径既能向上也能向下进行变换的稍简单的算法：2-3-4树的插入算法，2-3-4树中允许存在我们以前见过的4-结点。它的插入算法沿查找路径向下进行变换是为了保证当前结点不是4-结点（这样树底才有空间来插入新的键），沿查找路径向上进行变换是为了将之前创建的4-结点配平，如图 3.3.25 所示。向下的变换和我们在2-3树中分解4-结点所进行的变换完全相同。如果 根结点是4-结点，我们就将它分解成三个2-结点，使得树高加1。在向下查找的过程中，如果遇到一个父结点为2-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点 变为一个3-结点；如果遇到一个父结点为3-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点变为一个4-结点；我们不必担心会遇到父结点为4-结点的4-结点，因为插入算法本身就保证了这种情况不会出现。到达树的底部之后，我们也只会遇到2-结点或者3-结点，所以我们可以插入新的键。要用红黑树实现这个算法，我们需要：</p><blockquote><ul><li>将4-结点表示为由三个2-结点组成的一棵平衡的子树，根结点和两个子结点都用红链接相连； </li><li>在向下的过程中分解所有4-结点并进行颜色转换； </li><li>和插入操作一样，在向上的过程中用旋转将4-结点配平 。</li></ul></blockquote><p>&emsp;&emsp;因为4-结点可以存在，所以可以允许一个结点同时连接到两条链接。——译者注</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010125.png" alt="自顶向下的2-3-4树的插入算法中的变换"></p><p>&emsp;&emsp;令人惊讶的是，你只需要移动算法3.4的 put() 方法中的一行代码就能实现2-3-4树中的插入操作：将 colorFlip() 语句（及其 if 语句）移动到递归调用之前（null 测试和比较操作之间）。在多个进程可以同时访问同一棵树的应用中这个算法优于2-3树，因为它操作的总是当前结点的一个或两个链接。我们下面要讲的删除算法和它的插入算法类似，而且也适用于2-3树。</p><h3 id="4-2-删除最小键"><a href="#4-2-删除最小键" class="headerlink" title="4.2 删除最小键"></a><strong>4.2 删除最小键</strong></h3><p>&emsp;&emsp;在第二轮热身中我们要学习2-3树中删除最小键的操作。我们注意到从 树底部的3-结点中删除键是很简单的，但2-结点则不然。从2-结点中删除一个键会留下一个空结点，一般我们会将它替换为一个空链接，但这样会破坏树的完美平衡性。所以我们需要这样做：为了保证我们不会 删除一个2-结点，我们沿着左链接向下进行变换，确保当前结点不是2-结点（可能是3-结点，也可能是临时的4-结点）。首先，根结点可 能有两种情况。如果根是2-结点且它的两个子结点都是2-结点，我们可以直接将这三个结点变成一个4-结点；否则我们需要保证根结点的左子结点不是2-结点，如有必要可以从它右侧的兄弟结点“借”一个键 来。以上情况如图 3.3.26 所示。在沿着左链接向下的过程中，保证以下情况之一成立：</p><blockquote><ul><li>如果当前结点的左子结点不是2-结点，完成； </li><li>如果当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移动到左子结点中； </li><li>如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个 4结点，使父结点由3-结点变为2-结点或者由4-结点变为3-结点。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010126.png" alt="删除最小键操作中的变换"></p><p>&emsp;&emsp;在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接从中将其删除，将3-结点变为2结点，或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。</p><h3 id="4-3-删除操作"><a href="#4-3-删除操作" class="headerlink" title="4.3 删除操作"></a><strong>4.3 删除操作</strong></h3><p>&emsp;&emsp;在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后继结点交换，就和二叉查找树一样。因为当前结点必然不是 2-结点，问题已经转化为在一棵根结点不是2-结点的子树中删除最小的键，我们可以在这棵子树中使用前文所述的算法。和以前一样，删除之后我们需要向上回溯并分解余下的4-结点。</p><p>&emsp;&emsp;本节末尾的练习中有几道是关于这些删除算法的例子和实现的。有兴趣理解或实现删除算法的读者应该掌握这些练习中的细节。对算法研究感兴趣的读者应该认识到这些方法的重要性，因为这是我们见过的第一种能够同时实现高效的查找、插入和删除操作的符号表实现。下面我们将会验证这一点。</p><hr><h2 id="第五节-红黑树的性质"><a href="#第五节-红黑树的性质" class="headerlink" title="第五节 红黑树的性质"></a><strong>第五节 红黑树的性质</strong></h2><p>&emsp;&emsp;研究红黑树的性质就是要检查对应的2-3树并对相应的2-3树进行分析的过程。我们的最终结论是所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别（范围查找除外，它所需的额外时间和返回的键的数量成正比）。我们重复并强调这一点是因为它十分重要。</p><h3 id="5-1-性能分析"><a href="#5-1-性能分析" class="headerlink" title="5.1 性能分析"></a><strong>5.1 性能分析</strong></h3><p>&emsp;&emsp;首先，无论键的插入顺序如何，红黑树都几乎是完美平衡的（请见图 3.3.27）。这从它和2-3树的一一对应关系以及 2-3 树的重要性质可以得到。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010127.png" alt="使用随机键构造的典型红黑树，没有画出空链接"></p><p>&emsp;&emsp;命题 G。一棵大小为N的红黑树的高度不会超过2lgN。</p><p>&emsp;&emsp;简略的证明。红黑树的最坏情况是它所对应的 2-3 树中构成最左边 的路径结点全部都是 3- 结点而其余均为 2- 结点。最左边的路径长 度是只包含 2- 结点的路径长度（~lgN）的两倍。要按照某种顺序 构造一棵平均路径长度为2lgN的最差红黑树虽然可能，但并不容 易。如果你喜欢数学，你也许会喜欢在练习 3.3.24 中探究这个问题 的答案。</p><p>&emsp;&emsp;这个上界是比较保守的。使用随机的键序列和典型应用中常见的键序列 进行的实验都证明，在一棵大小为N的红黑树中一次查找所需的比较 次数约为（1.00lgN - 0.5）。另外，在实际情况下你不太可能遇到比这个数字高得多的平均比较次数，如表 3.3.1 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010128.png" alt="使用RedBlackBST的FrequencyCounter的每次put()操作平均所需的比较次数"></p><p>&emsp;&emsp;命题H。一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。</p><p>&emsp;&emsp;例证。和典型的二叉查找树（例如图 3.2.8 中所示的树）相比，一棵典型的红黑树的平衡性是很好的，例如图 3.3.27 所示（甚至是图 3.3.28 中由升序键列构造的红黑树）。表 3.3.1 显示的数据表明FrequencyCounter在运行中构造的红黑树的路径长度（即查找成本）比初等二叉查找树低40%左右，和预期相符。自红黑树的发明以来，无数的实验和实际应用都印证了这种性能改进。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010129.png" alt="使用升序键列构造的一棵红黑树，没有画出空链接"></p><p>&emsp;&emsp;以使用 FrequencyCounter 在处理长度大于等于8的单词时put()操作的成本为例，我们可以看到平均成本降低得更多（如图 3.3.29 所示）。这又一次验证了理论模型所预测的对数级别的运行时间，只不过这次的惊喜比二叉查找树的小，因为性质G已经向我们保证了这一点。节约的总成本低于在查找上节约的40%的成本，因为除了比较我们也统计了旋转和颜色变换的次数。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010130.png" alt="使用RedBlackBST，运行java FrequencyCounter 8 &lt; tale.txt的成本"></p><p>&emsp;&emsp;红黑树的get()方法不会检查结点的颜色，因此平衡性相关的操作不会产生任何负担；因为树是平衡的，所以查找比二叉查找树更快。每个键只会被插入一次，但却可能被查找无数次，因此最后我们只用了很小的代价（和二分查找不同，我们可以保证插入操作是对数级别的）就取得了和最优情况近似的查找时间（因为树是接近完美平衡的，且查找过程中不会进行任何平衡性的操作）。查找的内循环只会进行一次比较并更新一条链接，非常简短，和二分查找的内循环类似（只有比较和索引运算）。这是我们见到的第一个能够保证对数级别的查找和插入操作的实现，它的内循环更紧凑。它通过了各种应用的考验，包括许多库实现。</p><h3 id="5-2-有序符号表API"><a href="#5-2-有序符号表API" class="headerlink" title="5.2 有序符号表API"></a><strong>5.2 有序符号表API</strong></h3><p>&emsp;&emsp;红黑树最吸引人的一点是它的实现中最复杂的代码仅限于 put()（和删除）方法。二叉查找树中的查找最大和最小 键、select()、rank()、floor()、ceiling() 和范围查找方法不做任何变动即可继续使用，因为红黑树也是二叉查找树而这些操作也不会涉及结点的颜色。算法 3.4 和这些方法（以及删除方法）一起完整地实现了我们的有序符号表 API。这些方法都能从红黑树近乎完美的平衡性中受益，因为它们最多所需的时间都和树高成正比。因此命题G和命题E一起保证了所有操作的运行时间是对数级别的。</p><p>&emsp;&emsp;命题I。在一棵红黑树中，以下操作在最坏情况下所需的时间是对数级别的：查找（get()）、插入（put()）、查找最小键、查找最大键、floor()、ceiling()、rank()、select()、删除最小键（deleteMin()）、删除最大键（deleteMax()）、删除（delete()）和范围查询（range()）。</p><p>&emsp;&emsp;证明。我们已经讨论过 put()、get() 和 delete() 方法。对于其他方法，代码可以从3.2节中照搬（它们不涉及结点颜色）。命题G和命题E可以保证算法是对数级别的，所有操作在所经过的结点上只会进行常数次数的操作也说明了这一点。</p><p>&emsp;&emsp;各种符号表实现的性能总结如表 3.3.2 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010131.png" alt="各种符号表实现的性能总结"></p><p>&emsp;&emsp;想想看，这样的保证是一个非凡的成就。在信息世界的汪洋大海中，表的大小可能上千亿，但我们仍能够确保在几十次比较之内就完成这些操作。</p><h3 id="5-3-答疑"><a href="#5-3-答疑" class="headerlink" title="5.3 答疑"></a><strong>5.3 答疑</strong></h3><blockquote><ul><li>问　为什么不允许存在红色右链接和4-结点？</li><li>答　它们都是可用的，并且已经应用了几十年了。在练习中你会遇到它们。只允许红色左链接的存在能够减少可能出现的情况，因此实现所需的代码会少得多。</li></ul></blockquote><blockquote><ul><li>问　为什么不在Node类型中使用一个Key类型的数组来表示2-结点、 3-结点和4-结点？</li><li>答　问得好。这正是我们在B-树（请见第６章）的实现中使用的方案，它的每个结点中可以保存更多的键。因为2-3树中的结点较少，数组所带来的额外开销太高了。</li></ul></blockquote><blockquote><ul><li>问　在分解一个4-结点时，我们有时会在 rotateRight() 中将右结点的颜色设为RED（红）然后立即在 flipColors() 中将它的颜色变为BLACK（黑）。这不是浪费时间吗？</li><li>答　是的，有时我们还会不必要地反复改变中结点的颜色。从整体来看，多余的几次颜色变换和将所有方法的运行时间的增长数量级从线性级别提升到对数级别不是一个级别的。当然，在有性能要求的应用中，你可以将 rotateRight() 和 flipColors() 的代码在所需要的地方展开来消除那些额外的开销。我们在删除中也会使用这两个方法。在能够保证树的完美平衡的前提下，它们更加容易使用、理解和维护。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      算法复习 (二) 查找-平衡查找树，主要内容包括：2-3查找树（查找、向2-结点中插入新键、向一棵只含有一个3-结点的树中插入新键、向一个父结点为2-结点的3-结点中插入新键、向一个父结点为3-结点的3-结点中插入新键、分解根结点、局部变换、全局性质、性能分析），红黑查找树（替换3-结点、一种等价的定义、一一对应、颜色表示、旋转、在旋转后重置父结点的链接、向单个2-结点中插入新键、向树底部的2-结点插入新键、向一棵双键树（即一个3-结点）中插入新键、颜色转换、根结点总是黑色、向树底部的3-结点插入新键、将红链接在树中向上传递），实现，删除操作（自顶向下的2-3-4树、删除最小键、删除操作）红黑树的性质（性能分析、有序符号表API、答疑）等
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码解读-1.8版</title>
    <link href="http://linyishui.top/2019110601.html"/>
    <id>http://linyishui.top/2019110601.html</id>
    <published>2019-11-06T02:37:13.000Z</published>
    <updated>2019-12-19T07:19:13.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentHashMap源码解读"><a href="#ConcurrentHashMap源码解读" class="headerlink" title="ConcurrentHashMap源码解读"></a><strong>ConcurrentHashMap源码解读</strong></h1><h2 id="第一节-结构"><a href="#第一节-结构" class="headerlink" title="第一节 结构"></a><strong>第一节 结构</strong></h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a><strong>1.1 基本结构</strong></h3><p>&emsp;&emsp;继承抽象类AbstractMap，实现ConcurrentMap和Serializable接口。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ConcurrentHashMap&lt;K,V&gt; <span class="keyword">extends</span> AbstractMap&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 散列表即桶数组，首次put时延迟初始化，大小总是2的幂，由迭代器直接访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下个要用的表，仅在resize时不为空，也就是用于扩容，扩容后更新为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础计数器，主要在没有线程竞争时使用，但也在表初始化竞争中当作备用方案，通过CAS更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表的初始化和resize控制器数，也用来作扩容阈值。</span></span><br><span class="line"><span class="comment">     * 如果为负数，表示散列表正在初始化或扩容(-1：表示初始化，-n：表示负的活跃的resize线程数+1)。</span></span><br><span class="line"><span class="comment">     * 当table为空时将保留创建时要使用的初始表大小，默认为0，会大概设置为0.75s左右，通过sc = n - (n &gt;&gt;&gt; 2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容时用来转移的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建或resize CounterCells时要用的自旋锁（通过CAS锁定）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数单元的数组，非空时大小是2的幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// views</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Node单向链表节点"><a href="#1-2-Node单向链表节点" class="headerlink" title="1.2 Node单向链表节点"></a><strong>1.2 Node单向链表节点</strong></h3><p>&emsp;&emsp;通过Node链表来应对哈希冲突，在结构上和1.8版本的HashMap的Node类似，但val和next是volatile修饰的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-主要方法"><a href="#第二节-主要方法" class="headerlink" title="第二节 主要方法"></a><strong>第二节 主要方法</strong></h2><h3 id="2-1-get"><a href="#2-1-get" class="headerlink" title="2.1 get"></a><strong>2.1 get</strong></h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//高位异或到低位，更多哈希冲突的场景用红黑树来优化，所以采用这种即方便又能解决问题的方案。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> spread(<span class="built_in">int</span> h) &#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定下标在哈希表中的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, <span class="built_in">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//先把hashcode再散列得到h</span></span><br><span class="line">    <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="comment">//散列表不为空，获取节点e，通过(n - 1) &amp; h与运算定位下标</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//e不为空且hash值等于h，且key相等，则直接返回对应的值</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash值不等于h，且为负数，表示此时结构为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//则尝试遍历树查询key并返回</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//e还有后续节点，则遍历链表查询key并返回</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未能找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-put"><a href="#2-2-put" class="headerlink" title="2.2 put"></a><strong>2.2 put</strong></h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Encodings for Node hash fields. 特殊的哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MOVED     = <span class="number">-1</span>; <span class="comment">// hash for forwarding nodes 转移节点的hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TREEBIN   = <span class="number">-2</span>; <span class="comment">// hash for roots of trees 树根的hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> RESERVED  = <span class="number">-3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V putVal(K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent) &#123;</span><br><span class="line">    <span class="comment">//首先不允许新增空键或空值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//把hashcode再散列得到hash</span></span><br><span class="line">    <span class="built_in">int</span> hash = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="comment">//初始化binCount，用来记录修改的长度</span></span><br><span class="line">    <span class="built_in">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//死循环，直到操作成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="built_in">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//首次执行putVal()调用initTable进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//已有哈希表，并且hash对应下标节点还未赋值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过Unsafe实现CAS新增链表节点，完成任务跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已有哈希表，节点也已存在，但f处于MOVED状态表示正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);<span class="comment">//帮助扩容</span></span><br><span class="line">        <span class="comment">//已有哈希表，链表也已初始化，且节点不在移动状态，则加锁进行操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//oldVal用来记录旧值</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//代码块加锁同步f节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//如果f此时未被修改</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//节点hash&gt;=0表示正常态</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//binCount记录为1，至少已有一个</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历节点链表，直到完成操作显式终止循环，计算链表长度</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//当前节点hash相等，key也相等，表示找到键，完成操作后跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//记录oldVal，此时表示map中此键已对应有值</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//当onlyIfAbsent为false时才进行覆盖</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="comment">//跳出循环</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点还不是，e移到下个节点next</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//已遍历完链表，未找到则新增节点，尾插法，完成跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//非正常态，而是TreeBin节点，则向红黑树插入节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//binCount更新为2，没必要+</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//插入树节点，完成操作</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同步块结束</span></span><br><span class="line">            <span class="comment">//binCount不为0表示put已对数据产生了影响，不管是否有覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//若达到链表阈值，就转链表为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);<span class="comment">//转换红黑树</span></span><br><span class="line">                <span class="comment">//oldVal不为空，表示是一次更新操作，没有对元素个数产生影响，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="comment">//跳出死循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//binCount还为0，put操作未成功，继续死循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新计数值，并继续判断是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1</span>L, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="built_in">int</span> sc;</span><br><span class="line">    <span class="comment">//当哈希表为空或长度为0时循环</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//正在被其他线程处理</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin 自旋等待</span></span><br><span class="line">        <span class="comment">//否则CAS更新sizeCtl为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, <span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//确认此时还未初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//初始化时sizeCtl可能会自定义，若未自定义则取默认值</span></span><br><span class="line">                    <span class="built_in">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//新建节点数组，初始化table</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//sizeCtl取和无符号右移2位后的差，即每隔n个4，就要减去n，也就是合理的取阈值0.75</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//更新sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-size"><a href="#2-3-size" class="headerlink" title="2.3 size"></a><strong>2.3 size</strong></h3><p>&emsp;&emsp;CounterCell是一个计数单元，无并发时只要用baseCount就足以，但一旦并发时CAS修改baseCount失败，就要启用counterCells，计算size时会将所有计数单元数组中元素累加。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 8提供了mappingCount返回long，因为int可能会限制size最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0</span>L) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">final <span class="keyword">long</span> <span class="title">sumCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="comment">//若计数单元数组counterCells不为空，即已初始化，就遍历其中元素，并得到元素和</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder and Striped64. </span></span><br><span class="line"><span class="comment"> * @sun.misc.Contended会影响计数单元性能，用于防止伪共享，即本应独立的缓存变量却共享一个缓存行，从而影响各自的性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@sun.misc.Contended <span class="keyword">static</span> final <span class="keyword">class</span> <span class="title">CounterCell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> <span class="keyword">value</span>;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; <span class="keyword">value</span> = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addCount源码解读"><a href="#addCount源码解读" class="headerlink" title="addCount源码解读"></a><strong>addCount源码解读</strong></h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 增加哈希表计数值</span></span><br><span class="line"><span class="comment">  * 若表需要扩容且未在扩容，则开始transfer，若已经在扩容，则在可以时帮助transfer</span></span><br><span class="line"><span class="comment">  * 重新检查占用，确认会不会已要进行另一次resize，因为resize远远滞后于add</span></span><br><span class="line"><span class="comment">  * @param x the count to add</span></span><br><span class="line"><span class="comment">  * @param check if &lt;0, don't check resize, if &lt;= 1 only check if uncontended</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> final <span class="keyword">void</span> <span class="title">addCount</span>(<span class="params"><span class="keyword">long</span> x, <span class="keyword">int</span> check</span>) </span>&#123;</span><br><span class="line">     CounterCell[] <span class="keyword">as</span>; <span class="keyword">long</span> b, s;</span><br><span class="line">     <span class="comment">//counterCells计数单元数组不为空，或CAS对baseCount原子操作 +x 时失败</span></span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">as</span> = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">         !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">         CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">         <span class="comment">//标识没有竞争</span></span><br><span class="line">         boolean uncontended = <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">//如果counterCells为空，或其中元素为0，表示尚未出现并发</span></span><br><span class="line">         <span class="comment">//如果本地线程随机取余对应counterCells下标为空</span></span><br><span class="line">         <span class="comment">//如果CAS对取到的元素进行原子操作 +x 失败了，表示出现并发情况</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">as</span> == <span class="literal">null</span> || (m = <span class="keyword">as</span>.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">             (a = <span class="keyword">as</span>[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">             !(uncontended =</span><br><span class="line">               U.compareAndSwapLong(a, CELLVALUE, v = a.<span class="keyword">value</span>, v + x))) &#123;</span><br><span class="line">             <span class="comment">//总之就是未成功执行计数单元数组counterCells更新计数值</span></span><br><span class="line">             <span class="comment">//执行fullAddCount，其会一直执行直到成功，并直接返回</span></span><br><span class="line">             fullAddCount(x, uncontended);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//若check小于等于1，直接返回</span></span><br><span class="line">         <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">//若check大于1，更新一下s</span></span><br><span class="line">         s = sumCount();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果需要检查，即检查是否需要扩容，putVal调用时所给check必然&gt;=0</span></span><br><span class="line">     <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">         <span class="comment">//当map的size达到sizeCtl扩容阈值，哈希表不为空，且哈希表还未到最大值，则进行扩容</span></span><br><span class="line">         <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             <span class="comment">//通过哈希表长度获得一个resize标识，得到一个低16位首位为1的大数。</span></span><br><span class="line">             <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">             <span class="comment">//若此时正在扩容</span></span><br><span class="line">             <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//开启扩容后会把sizeCtl替换为(rs &lt;&lt; 16) + 2</span></span><br><span class="line">                 <span class="comment">//1.若sizeCtl右移16位，其高16位不等于rs，表示sizeCtl被改变了（2这些低位值会被右移掉）</span></span><br><span class="line">                 <span class="comment">//2.此处rs + 1应该是BUG，应该改为(rs &lt;&lt; 16) + 1，表示所有线程都完成了扩容工作</span></span><br><span class="line">                 <span class="comment">//   默认第一个线程设置sizeCtl = (rs &lt;&lt; 16) + 2，之后的线程会+1</span></span><br><span class="line">                 <span class="comment">//   所以没有线程时基础值就为(rs &lt;&lt; 16) + 1</span></span><br><span class="line">                 <span class="comment">//   此处读源码时隐隐感觉有BUG，去sof搜了一下，果然有人已经发过类似的题问，还是一位国人</span></span><br><span class="line">                 <span class="comment">//   看描述已经被JDK BUG审核通过了，省去大麻烦，十分感谢</span></span><br><span class="line">                 <span class="comment">//3.此处rs + MAX_RESIZERS应该是BUG，改为(rs &lt;&lt; 16)+MAX_RESIZERS，表示帮助线程数已达到最大值</span></span><br><span class="line">                 <span class="comment">//4.若nextTable为空，表示扩容已结束</span></span><br><span class="line">                 <span class="comment">//5.若transferIndex &lt;= 0，表示所有区间都已分配或完成了，不再需要线程协助</span></span><br><span class="line">                 <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                     sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                     transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">break</span>;<span class="comment">//结束循环</span></span><br><span class="line">                 <span class="comment">//CAS原子操作sizeCtl++，表示帮助线程+1，并执行扩容</span></span><br><span class="line">                 <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                     transfer(tab, nt);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//此时不在扩容</span></span><br><span class="line">             <span class="comment">//CAS原子操作将sizeCtl更新为resize标识左移16位并+2</span></span><br><span class="line">             <span class="comment">//因为resize得到了一个低16位首尾为1的整型，这样就变成一个负数</span></span><br><span class="line">             <span class="comment">//所以开始扩容后sizeCtl的初始值为(rs &lt;&lt; 16) + 2，此时一个线程在进行扩容</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                          (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                 transfer(tab, <span class="literal">null</span>);<span class="comment">//更新sizeCtl为负数后开始扩容</span></span><br><span class="line">             <span class="comment">//更新size，即使已经在扩容了，也可能马上迎来下次扩容</span></span><br><span class="line">             s = sumCount();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取用来调整大小为n的哈希表的标记位，得到低16位，符号位为1</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> final <span class="keyword">int</span> <span class="title">resizeStamp</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//n自左连续0的位数x 和 后续二进制数进行或运算</span></span><br><span class="line">     <span class="comment">// x | 1000 0000 0000 0000</span></span><br><span class="line">     <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span>(<span class="params"><span class="keyword">int</span> i</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// HD, Figure 5-6</span></span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">     <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//高16位为0，n为17，i左移16位</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">16</span> == <span class="number">0</span>) &#123; n += <span class="number">16</span>; i &lt;&lt;= <span class="number">16</span>; &#125;</span><br><span class="line">     <span class="comment">//高8位为0，n为9，i左移8位</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">24</span> == <span class="number">0</span>) &#123; n +=  <span class="number">8</span>; i &lt;&lt;=  <span class="number">8</span>; &#125;</span><br><span class="line">     <span class="comment">//高4位为0，n为5，i左移4位</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">28</span> == <span class="number">0</span>) &#123; n +=  <span class="number">4</span>; i &lt;&lt;=  <span class="number">4</span>; &#125;</span><br><span class="line">     <span class="comment">//高2位为0，n为3，i左移2位</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">30</span> == <span class="number">0</span>) &#123; n +=  <span class="number">2</span>; i &lt;&lt;=  <span class="number">2</span>; &#125;</span><br><span class="line">     <span class="comment">//此时n是左移位数+1</span></span><br><span class="line">     <span class="comment">//此时i是左移(n-1)后的值</span></span><br><span class="line">     <span class="comment">//将i无符号右移31位，并从n中去掉</span></span><br><span class="line">     n -= i &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">     <span class="comment">//最后得到从左到右连续0的个数</span></span><br><span class="line">     <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;addCount将哈希表元素数+1，对baseCount和counterCells进行了修改，当counterCells被初始化就优先使用。并检查当前是否需要扩容，若需要扩容就开启扩容，若正在扩容就帮助进行扩容。</p><h3 id="helpTransfer源码解读"><a href="#helpTransfer源码解读" class="headerlink" title="helpTransfer源码解读"></a><strong>helpTransfer源码解读</strong></h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当扩容正在进行时，帮忙进行transfer</span></span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] <span class="keyword">tab</span>, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="comment">//若节点f为转发节点，且节点为转移类型，且新表不为空，则尝试帮助扩容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">tab</span> != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; </span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">        <span class="comment">//通过表长获得一个resize标识，低16位首位为1，以便左移后得到一个负数</span></span><br><span class="line">        int rs = resizeStamp(<span class="keyword">tab</span>.length);</span><br><span class="line">        <span class="comment">//当nextTable和table还未被修改，且正在扩容</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; <span class="keyword">table</span> == <span class="keyword">tab</span> &amp;&amp;</span><br><span class="line">               (<span class="keyword">sc</span> = sizeCtl) &lt; 0) &#123;</span><br><span class="line">            <span class="comment">//开启扩容后会把sizeCtl替换为(rs &lt;&lt; 16) + 2</span></span><br><span class="line">            <span class="comment">//1.若sizeCtl右移16位，其高16位不等于rs，表示sizeCtl被改变了（2这些低位值会被右移掉）</span></span><br><span class="line">            <span class="comment">//2.此处rs + 1应该是BUG，应该改为(rs &lt;&lt; 16) + 1，表示所有线程都完成了扩容工作</span></span><br><span class="line">            <span class="comment">//   默认第一个线程设置sizeCtl = (rs &lt;&lt; 16) + 2，之后的线程会+1</span></span><br><span class="line">            <span class="comment">//   所以没有线程时基础值就为(rs &lt;&lt; 16) + 1</span></span><br><span class="line">            <span class="comment">//   此处读源码时隐隐感觉有BUG，去sof搜了一下，果然有人已经发过类似的题问，还是一位国人</span></span><br><span class="line">            <span class="comment">//   看描述已经被JDK BUG审核通过了，省去大麻烦，十分感谢</span></span><br><span class="line">            <span class="comment">//3.此处rs + MAX_RESIZERS应该是BUG，改为(rs &lt;&lt; 16)+MAX_RESIZERS，表示帮助线程数已达到最大值</span></span><br><span class="line">            <span class="comment">//4.若nextTable为空，表示扩容已结束</span></span><br><span class="line">            <span class="comment">//5.若transferIndex &lt;= 0，表示所有区间都已分配或完成了，不再需要线程协助</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">sc</span> &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || <span class="keyword">sc</span> == rs + 1 ||</span><br><span class="line">                <span class="keyword">sc</span> == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//这些情况不需要再协助了，直接跳出循环</span></span><br><span class="line">            <span class="comment">//CAS原子操作使sizeCtl++，表示增加了一个帮助线程</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, <span class="keyword">sc</span> + 1)) &#123;</span><br><span class="line">                <span class="comment">//进行转移</span></span><br><span class="line">                transfer(<span class="keyword">tab</span>, nextTab);</span><br><span class="line">                <span class="comment">//并跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;<span class="comment">//返回新表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">table</span>;<span class="comment">//返回旧表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transfer源码解读"><a href="#transfer源码解读" class="headerlink" title="transfer源码解读"></a><strong>transfer源码解读</strong></h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//CPU核心数大于1时，除以8得到结果如果小于MTS，就直接使用MTS</span></span><br><span class="line">    <span class="comment">//MTS是每次transfer最小绑定数为16，同来限制哈希表被分的太小，所以默认情况下一个线程要处理16块桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range 细分范围</span></span><br><span class="line">    <span class="comment">//若所给的参数新表还未初始化，则创建新表进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//扩容2倍，创建哈希表</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//赋值给nextTab</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            <span class="comment">//扩容失败，sizeCtl直接采用int最大值</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容初始化成功，更新nextTable</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//更新转移下标，指向除了旧表长度后的首位</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新表的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//创建一个转移节点，用于占位，其他线程看到转移节点会知道对应区域正在进行扩容转移</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//推进标识，</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//结束标识，指扩容过程</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//最外层死循环，</span></span><br><span class="line">    <span class="comment">//i是指向桶数组的指针</span></span><br><span class="line">    <span class="comment">//bound则是指向当前线程可以处理的桶区间最小下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">//循环推进，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//i减1，说明是对桶集合倒序处理</span></span><br><span class="line">            <span class="comment">//如果大于等于bound，说明指针还未移出划分区域，表示之前分配的区间还未结束，跳出循环，继续工作</span></span><br><span class="line">            <span class="comment">//若结束标识为真，则表示表示扩容结束，跳出循环，扩容结束</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;<span class="comment">//防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">            <span class="comment">//若转移索引小于0，表示没有区间了，跳出循环，扩容结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//更新i为-1，表示扩容结束</span></span><br><span class="line">                i = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">//防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS原子操作更新transferIndex为nextIndex和stride的差</span></span><br><span class="line">            <span class="comment">//比如旧表64扩容，区间16，第一次分配区间为48-63，下一次为32-47</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                <span class="comment">//值为当前线程可以处理的当前区间的最小下标 |nextBound ... nextIndex-1|</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">//初次对i赋值，当前线程可以处理的当前区间的最大下标</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i &lt; 0，表示已经没有区间了，扩容任务都已完成或分配出去了</span></span><br><span class="line">        <span class="comment">//i &gt;= n，当前下标超过旧表容量，表示i异常</span></span><br><span class="line">        <span class="comment">//i + n &gt;= nextn，当前下标+旧表长超过新表长度，表示i异常</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//若已完成了扩容，则进行收尾工作</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">//重置新表为空</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//将当前表指向新表</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">//更新sizeCtl为2n-n/2</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//直接结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若还未未完成扩容任务</span></span><br><span class="line">            <span class="comment">//CAS原子操作更新sizeCtl--，表示当前线程要结束帮助任务了</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//若(sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//若相等，表示已无帮助线程，说明此次扩容已结束</span></span><br><span class="line">                <span class="comment">//更新结束标识为true，表示已完成这次扩容任务</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//重置i，还不急return，再检查一下再返回</span></span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果旧表i对应节点为空，不用操作了，就用转移节点来占位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);<span class="comment">//占位并恢复推进标识</span></span><br><span class="line">        <span class="comment">//如果旧表i对应节点不为空，且已被标注为转移节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed 说明其他线程已经处理过了，不用管，恢复推进标识</span></span><br><span class="line">        <span class="comment">//以上都不满足，表示下标对应节点有值，且不是占位符，则开始操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//先对节点加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//如果f此时未被修改</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//声明低位节点和高位节点</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//节点f的hash&gt;=0表示这是正常链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//首节点hash值和旧表长进行与运算，因为表长都是只有一位是1其他位是0的二进制</span></span><br><span class="line">                        <span class="comment">//所以与运算结果只有1或0，分别对应高位和低位</span></span><br><span class="line">                        <span class="comment">//目的是将链表重新散列，放到对应的位置上，让新的取余算法能够击中他。</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        <span class="comment">//lastRun用来标记最后一次变化的节点</span></span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">//遍历当前桶，即节点对应链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">//和旧表长与运算，得到此节点的“命运”</span></span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="comment">//不等于runBit则更新</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                <span class="comment">//更新runBit，用于判断赋值低位还是高位</span></span><br><span class="line">                                runBit = b;</span><br><span class="line">                                <span class="comment">//更新lastRun，纪录变化的节点，后续节点自然和此节点相同</span></span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果最后更新的runBit为0，放置到低位节点</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果最后更新的runBit为1，放置到高位节点</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//再次遍历链表，生成高位和低位链表，lastRun纪录的最后一次变化节点作为结束标记</span></span><br><span class="line">                        <span class="comment">//未被遍历到的节点保持原样，避免不必要的循环操作</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//类似于HashMap，低位链表放置于i，高位链表放置于i+n</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//旧链表设为转移节点占位，提醒其他线程</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//这样就完成了这个桶/链表的转移工作，恢复推进标识，继续推进</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树优化</span></span><br><span class="line">                    <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(f <span class="keyword">instanceof</span> TreeBin)</span> </span>&#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fullAddCount源码解读"><a href="#fullAddCount源码解读" class="headerlink" title="fullAddCount源码解读"></a><strong>fullAddCount源码解读</strong></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程的探测值，注意调用ThreadLocalRandom.current()会在返回0时强制进行初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> getProbe() &#123;</span><br><span class="line">    <span class="keyword">return</span> U.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See LongAdder version for explanation</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> fullAddCount(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended) &#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//从本地获取探测值，若为0，则强制进行初始化并再获取，更新无竞争标识符为true</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty 若最后一个插槽为空则为true</span></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] <span class="keyword">as</span>; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//若counterCells不为空，且有元素，则不断尝试新增或更新对应计数单元</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">as</span> = counterCells) != <span class="literal">null</span> &amp;&amp; (n = <span class="keyword">as</span>.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若探测值对应计数单元为空，(length-1) &amp; probe定位元素，则尝试创建新的计数单元</span></span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//自旋锁cellsBusy=0</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">//乐观的创建一个新计数单元，计数值即为参数x</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">//若自旋锁cellsBusy依旧=0</span></span><br><span class="line">                    <span class="comment">//且尝试CAS更新自旋锁为1</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="literal">false</span>;</span><br><span class="line">                        <span class="comment">//更新成功，锁死后复查</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">//counterCells已创建，且已有元素，且探测值对应计数单元为空，则将创建的计数单元赋予</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;<span class="comment">//恢复自旋锁</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//若成功添加就跳出死循环</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//添加失败，说明对应计数单元不为空</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计数单元不为空，且若有竞争，表示CAS操作失败，重置标识，等待再散列后重试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//计数单元不为空，重新尝试CAS更新计数值，若成功则跳出循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//计数单元不为空，重新尝试CAS失败，且counterCells已被修改或元素数超过CPU核数，更新collide继续循环尝试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != <span class="keyword">as</span> || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale 表示此时已达到最大值或计数单元是旧数据</span></span><br><span class="line">            <span class="comment">//以上都不符合，且collide依然为false，更新collide继续循环尝试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//collide为true，可能另外的线程完成了对这个计数单元的操作，尝试获得自旋锁，并扩大计数单元数组容量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == <span class="keyword">as</span>) &#123;<span class="comment">// Expand table unless stale 只要表还未被修改就把它展开</span></span><br><span class="line">                    <span class="comment">//创建一个新计数单元数组，扩大一倍容量</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="comment">//拷贝旧值</span></span><br><span class="line">                            rs[i] = <span class="keyword">as</span>[i];</span><br><span class="line">                        counterCells = rs;<span class="comment">//更新</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table 用新的数组重试</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新探测值</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计数单元数组为空或还未有元素，获取自旋锁，并占用成功，则尝试初始化计数单元数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == <span class="keyword">as</span> &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="comment">//初始化计数单元数组，创建首个计数单元</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == <span class="keyword">as</span>) &#123;</span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自旋锁正在被占用，重新尝试更新baseCount，若更新成功就跳出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-总结"><a href="#第三节-总结" class="headerlink" title="第三节 总结"></a><strong>第三节 总结</strong></h2><h3 id="怎么获取元素？"><a href="#怎么获取元素？" class="headerlink" title="怎么获取元素？"></a><strong>怎么获取元素？</strong></h3><p>&emsp;&emsp;先对哈希码进行再散列，并定位到散列表坐标，找到桶对应的首节点，如果是链表实现就遍历链表查询，如果是红黑树，就遍历树查询。</p><h3 id="怎么放置元素？"><a href="#怎么放置元素？" class="headerlink" title="怎么放置元素？"></a><strong>怎么放置元素？</strong></h3><p>&emsp;&emsp;首先校验不允许空值或空键，先对哈希码进行再散列，然后进行死循环，不断尝试后续操作。</p><p>&emsp;&emsp;哈希表还未初始化，则会先进行初始化，然后继续循环。</p><p>&emsp;&emsp;已有哈希表，且桶还未创建，CAS新增节点完成任务。</p><p>&emsp;&emsp;已有哈希表，桶也存在，但对应桶正在扩容，则先协助扩容，然后继续循环。</p><p>&emsp;&emsp;已有哈希表，桶也存在，桶可正常使用，则锁住链表，并遍历链表完成放置任务，操作若成功则判断是否达到链表长阈值，若达到就把链表转为红黑树；若操作未成功就继续循环。</p><p>&emsp;&emsp;最后调用addCount更新计数器值，并在这个过程中继续判断是否需要扩容。</p><h3 id="怎么获取元素数目？"><a href="#怎么获取元素数目？" class="headerlink" title="怎么获取元素数目？"></a><strong>怎么获取元素数目？</strong></h3><p>&emsp;&emsp;若计数单元数组counterCells不为空，就遍历其内元素求和，得到总数</p><p>&emsp;&emsp;若为空则直接返回baseCount</p><p>&emsp;&emsp;无并发时只要用baseCount就足以，但一旦并发时CAS修改baseCount失败，就要启用counterCells，计算size时会将所有计数单元数组累加</p><p>&emsp;&emsp;两种技术器都是通过addCount来更新，但可能会因为并发而更新失败，会采用备用方法fullAddCount，死循环不断尝试。</p><h3 id="怎么协助扩容？"><a href="#怎么协助扩容？" class="headerlink" title="怎么协助扩容？"></a><strong>怎么协助扩容？</strong></h3><p>&emsp;&emsp;ConcurrentHashMap如果正在扩容，其余线程可以参与扩容流程帮助进行扩容，每个线程会被分配一定的工作区间。</p><p>&emsp;&emsp;首先判断节点处是否是转移节点以及新表是否也已经创建，则不是则直接返回旧表</p><p>&emsp;&emsp;如果是则先通过resizeStamp获得一个低16位首位为1的大数作为rs标识，默认第一个线程开启扩容后会把sizeCtl置为(rs &lt;&lt; 16) + 2，所以(rs &lt;&lt; 16) + 1可以用来判断是否所有扩容线程都已结束任务。</p><p>&emsp;&emsp;如果此时还在扩容流程，即sizeCtl&lt;0，则进行循环，先判断几种转移或扩容流程已结束的情况，如果满足就直接跳出循环，返回新表</p><p>&emsp;&emsp;如果不满足则循环尝试进行CAS操作使sizeCtl++，代表着增加一个协助线程，调用transfer进行协助，成功后跳出循环，返回新表</p><h3 id="怎么更新计数器？"><a href="#怎么更新计数器？" class="headerlink" title="怎么更新计数器？"></a><strong>怎么更新计数器？</strong></h3><p>&emsp;&emsp;首先判断计数单元数组是否已创建，或CAS对baseCount计数更新是否可以成功</p><p>&emsp;&emsp;如果不满足，则根据check参数是否&gt;=0判断是否需要扩容检查，如果不需要则结束。</p><p>&emsp;&emsp;如果满足，则表示baseCount不可靠，需要更新计数单元数组，</p><p>&emsp;&emsp;若当前计数单元数组为空，或不含元素，或CAS更新失败，则调用备案fullAddCount，然后结束。</p><p>&emsp;&emsp;若非上述情况，则CAS更新成功，若所给check&lt;=1，则直接返回，不进行扩容检查</p><p>&emsp;&emsp;若check&gt;1，先算一下此时的总数，然后进入扩容检查</p><p>&emsp;&emsp;扩容检查部分和put放置元素雷同，区别就是当前线程可能是第一个发现要扩容的线程，所以当此时不在扩容状态，但需要扩容时，要重置sizeCtl为(rs &lt;&lt; 16) + 2，rs左移后变成一个大的负数，所以用来标识正在扩容以及当前正在扩容的线程数</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://stackoverflow.com/questions/53493706/how-the-conditions-sc-rs-1-sc-rs-max-resizers-can-be-achieved-in" target="_blank" rel="noopener">https://stackoverflow.com/questions/53493706/how-the-conditions-sc-rs-1-sc-rs-max-resizers-can-be-achieved-in</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      对JDK 1.8版本中ConcurrentHashMap的源码进行分析，内容包括：结构（基本结构、Node单向链表节点），主要方法（get、put、size、addCount、helpTransfer、transfer、fullAddCount源码解读），总结（怎么获取元素、怎么放置元素、怎么获取元素数目、怎么协助扩容、怎么更新计数器）等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>页面置换算法</title>
    <link href="http://linyishui.top/2019110301.html"/>
    <id>http://linyishui.top/2019110301.html</id>
    <published>2019-11-03T03:28:48.000Z</published>
    <updated>2019-12-15T06:36:29.789Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a><strong>页面置换算法</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;页面置换算法：操作系统中内存内没有空闲页面，而又需要加载一个未载入内存的页面时，需要有一个置换算法可以淘汰出页面以便腾出空间。最理想的算法是发生缺页时，把当前所存页面中最晚被访问的页面淘汰，但操作系统并不能预知页面下一次被访问的时间，所以无法实现。</p><blockquote><ul><li>FIFO: 先进先出，总是置换掉最先进入也就是停留最久的一页，理由是最早被存入的比刚被存入的页面被调用的几率小。</li><li>LRU: 最近最久未使用，总是置换掉过去最久未被使用的一页。</li><li>LFU: 最近最少使用，总是置换掉过去被使用次数最少的一页。</li></ul></blockquote><p>&emsp;&emsp;假设我们内存已存页面[1,2,3]，过去访问顺序依次为：2，1，1，1，3，2。那么按照三种算法分别选出的淘汰页是？<br>&emsp;&emsp;使用FIFO：淘汰2，因为它最新进入内存。</p><p>&emsp;&emsp;使用LRU：淘汰1，因为它最近未被用过。</p><p>&emsp;&emsp;使用LFU：淘汰3，因为它被使用的次数最少。</p><hr><h2 id="第二节-FIFO"><a href="#第二节-FIFO" class="headerlink" title="第二节 FIFO"></a><strong>第二节 FIFO</strong></h2><p>&emsp;&emsp;FIFO（first input first output），即<strong>先进先出算法</strong>。这种算法只有在按线性顺序访问地址空间时才是理想的，否则效率不高。因为那些常被访问的页，往往在主存中也停留得最久，结果它们因变“老”而不得不被置换出去。</p><p>&emsp;&emsp;缺点：判断一个页面置换算法优劣的指标就是<strong>缺页率</strong>，而FIFO算法的一个显著的缺点是，在某些特定的时刻，缺页率反而会随着分配页面的增加而增加，这称为<strong>Belady现象</strong>。产生Belady现象现象的原因是：FIFO置换算法与进程访问内存的动态特征是不相容的，被置换的内存页面往往是被频繁访问的，或者没有给进程分配足够的页面，因此FIFO算法会使一些页面频繁地被替换和重新申请内存，从而导致缺页率增加。因此，现在不再使用FIFO算法。</p><hr><h2 id="第三节-LRU"><a href="#第三节-LRU" class="headerlink" title="第三节 LRU"></a><strong>第三节 LRU</strong></h2><p>&emsp;&emsp;LRU（Least recently used），即<strong>最近最久未使用算法</strong>，是页面置换算法的其中一种，用于很多分布式缓存系统，其设计思想是：<strong>如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）</strong>。</p><p>&emsp;&emsp;因为要找出最近最久未使用的页面，就必须为每一页设置相关记录项，用于记录页面的访问情况，并且每访问一次页面都须更新该信息。这将使系统的开销加大，所以在实际系统中往往使用该算法的近似算法。</p><p>&emsp;&emsp;实现方案：最朴素的思想就是用数组+时间戳的方式，不过这样做效率较低。因此，我们可以用双向链表（LinkedList）+哈希表（HashMap）实现（链表用来表示位置，哈希表用来存储和查找），在Java里有对应的数据结构LinkedHashMap。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用LinkedHashMap实现LRU置换算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="keyword">public</span> LRUCache(<span class="keyword">int</span> cacheSize) &#123;</span><br><span class="line">        super(<span class="number">16</span>, (<span class="keyword">float</span>) <span class="number">0.75</span>, true);</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">size</span>() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class LRUCacheTest &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LRUCache&lt;<span class="keyword">String</span>, Integer&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cache.<span class="built_in">put</span>(<span class="string">"k"</span> + i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"all cache :'&#123;&#125;'"</span> + cache);</span><br><span class="line">        cache.<span class="built_in">get</span>(<span class="string">"k3"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"get k3 :'&#123;&#125;'"</span>+ cache);</span><br><span class="line">        cache.<span class="built_in">get</span>(<span class="string">"k4"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"get k4 :'&#123;&#125;'"</span>+ cache);</span><br><span class="line">        cache.<span class="built_in">get</span>(<span class="string">"k4"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"get k4 :'&#123;&#125;'"</span>+ cache);</span><br><span class="line">        cache.<span class="built_in">put</span>(<span class="string">"k"</span> + <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"After running the LRU algorithm cache :'&#123;&#125;'"</span>+ cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打印结果如下</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all cache :'&#123;&#125;'&#123;<span class="attr">k0=0,</span> <span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k3=3,</span> <span class="attr">k4=4,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9&#125;</span></span><br><span class="line">get k3 :'&#123;&#125;'&#123;<span class="attr">k0=0,</span> <span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k4=4,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9,</span> <span class="attr">k3=3&#125;</span></span><br><span class="line">get k4 :'&#123;&#125;'&#123;<span class="attr">k0=0,</span> <span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9,</span> <span class="attr">k3=3,</span> <span class="attr">k4=4&#125;</span></span><br><span class="line">get k4 :'&#123;&#125;'&#123;<span class="attr">k0=0,</span> <span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9,</span> <span class="attr">k3=3,</span> <span class="attr">k4=4&#125;</span></span><br><span class="line">After running the LRU algorithm cache :'&#123;&#125;'&#123;<span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9,</span> <span class="attr">k3=3,</span> <span class="attr">k4=4,</span> <span class="attr">k10=10&#125;</span></span><br></pre></td></tr></table></figure><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a><strong>算法题</strong></h3><p>&emsp;&emsp;运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>&emsp;&emsp;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。</p><p>&emsp;&emsp;当缓存容量达到上限时，它应该在写入新数据之前删除最长时间未使用的数据值，从而为新的数据值留出空间。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们根据存储键值对知道要选择Map，但一般映射的Key是无序的，所以我们应该要实现一个有序的哈希映射，一般用双向链表来实现有序Key。</p><p>&emsp;&emsp;用Java语言可以自己实现一个LinkedHashMap来解答，可以参考<a href="../2019041501.html" title="Title">Java集合(五) Map</a>。</p><hr><h2 id="第四节-LFU"><a href="#第四节-LFU" class="headerlink" title="第四节 LFU"></a><strong>第四节 LFU</strong></h2><p>&emsp;&emsp;LFU（Least Frequently Used），即<strong>最近最少使用算法</strong>。LFU算法的思想是：如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。</p><p>&emsp;&emsp;算法实现策略：考虑到 LFU 会淘汰访问频率最小的数据，我们需要一种合适的方法按大小顺序维护数据访问的频率。LFU 算法本质上可以看做是一个 top K 问题(K = 1)，即选出频率最小的元素，因此我们很容易想到可以用二项堆来选择频率最小的元素，这样的实现比较高效。最终实现策略为小顶堆+哈希表。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.cnblogs.com/hongdada/p/10406902.html" title="Title" target="_blank" rel="noopener">缓存算法（FIFO 、LRU、LFU三种算法的区别）</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      内容：等
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>死亡会是解脱吗</title>
    <link href="http://linyishui.top/2019110201.html"/>
    <id>http://linyishui.top/2019110201.html</id>
    <published>2019-11-02T10:03:51.000Z</published>
    <updated>2019-12-16T09:01:18.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-xtrSQtiK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-xtrSQtiK"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "曾经我也想过一了百了",              author: "中島美嘉",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/%E4%B8%AD%E5%B3%B6%E7%BE%8E%E5%98%89%20-%20%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp3",              pic: "http://p1.music.126.net/HE-K4mxyNGF84xlyuxx9Wg==/109951163825342747.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-PdikKMBO" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-PdikKMBO"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "僕らの手には何もないけど、",              author: "RAM WIRE",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/RAM%20WIRE%20-%20%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81.mp3",              pic: "http://p2.music.126.net/V1o9XDhAnI1ayWW5elJwFQ==/109951163338252165.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-wvWMEavf" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-wvWMEavf"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "ごはんを食べよう",              author: "Goose house",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/Goose%20house%20-%20%E3%81%94%E3%81%AF%E3%82%93%E3%82%92%E9%A3%9F%E3%81%B9%E3%82%88%E3%81%86.mp3",              pic: "http://p1.music.126.net/niXAzTEt2zlFpcLiPedX3g==/5754843859843186.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>&emsp;&emsp;可能会有那么一刻感叹自己的人生很空虚，世界好像和我无关，就算在这里死掉也不会有人会发现吧。</p><p>&emsp;&emsp;可能会有那么一刻觉得活着好累，死了就会好一些吧。</p><p>&emsp;&emsp;可能会有那么一刻无力反抗背上的压力，想着死了就轻松了吧。</p><p>&emsp;&emsp;活着似乎总是要担负一些东西，嘴里说着要放下一切，只有死去的那一刻才能真的放下吧。</p><p>&emsp;&emsp;世界是这样吗，不像幻想中那么美好、那么宽容，我好像也没那么坚强。</p><p>&emsp;&emsp;也曾想向世界传递善意，但身边的世界好像是空空的，是不是只有坏的记忆才能留在人的心里。</p><p>&emsp;&emsp;也曾想对世界倾诉，但好像没人有在乎，渐渐的也不知道该怎么说话了。</p><p>&emsp;&emsp;是啊，大家活着都很累啊，慢慢地封闭了自己的内心。</p><p>&emsp;&emsp;为了不受伤害而戴上的面具，也遮挡住了阳光，勉强才能维持着正常人的姿态。</p><p>&emsp;&emsp;“你没事吧”，“休息一下就好了”，“为家人考虑一下”，“再多坚强一些”，“还是内心不够强大”，“看不起这种自私的人”</p><p>&emsp;&emsp;说什么把握当下，生命要活得精彩，只是漂亮话罢了。</p><p>&emsp;&emsp;永别的时候告诉自己这不是放弃，是放下了。</p><p>&emsp;&emsp;好像这一生积攒的勇气终于释放了，好像扮演了一生的舞台剧终于谢幕了。</p><p>&emsp;&emsp;黑暗中死的无声无息，似乎从来没有存在过，直到最后也没有选择在阳光下，是担心围观的人肆意评论吗，人的恶意从来不会消失吧。</p><p>&emsp;&emsp;曾经也活着啊，匆匆的这一生有什么意义？</p><p>&emsp;&emsp;可能最后时刻的你也曾许愿，如果有来生，希望和能相互拥抱的人相遇。</p><p>&emsp;&emsp;哪怕一直聊着没有营养的话题，只想这样呆在一起。</p><p>&emsp;&emsp;就算还是一样活的辛苦，至少能感受到温暖。</p><p>&emsp;&emsp;希望那时可以相信这世界一切美好的存在，希望我也能成为温暖别人的存在。</p><p>&emsp;&emsp;但死了就什么都没有了，如果坚持到明天会不会有不同？</p><p>&emsp;&emsp;已放下所有的你，也许在明天的街头，可以邂逅一个阳光一样的人，也许再尝试一次就能找到一个同样孤独的人相拥取暖。</p><p>&emsp;&emsp;也许是一个多年未联系的老友，敞开心扉后，发现被社会打磨的油滑的他内心也还保留着一颗温热的心。</p><p>&emsp;&emsp;即便因奔忙无法相见，即便相互已无法变得坦率，但只要能够回到每个人都怀念的那个地方的话，是能让时光从那个时候开始延续吧</p><p>&emsp;&emsp;找到一个活下去的理由，只要能继续努力的活着，一切都还有重来的机会。</p><p>&emsp;&emsp;原本以为做不到的事情实际却可以做到的，世界渐渐变得广阔，因为相信现在所处的世界，即使一无所有仍可以顽强的活下去。</p><p>&emsp;&emsp;是啊，活着就是一件麻烦的事情，觉得不行了就暂停一下，无法面对了就逃避一下，总有一天，我们会从所有束缚我们的事之中，从肉眼看不到的微痛之中，得以解放。</p>        <div id="aplayer-IXUpfMJr" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-IXUpfMJr"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "面会菜",              author: "林生祥",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/OM/%E6%9E%97%E7%94%9F%E7%A5%A5%20-%20%E9%9D%A2%E4%BC%9A%E8%8F%9C.mp3",              pic: "http://p2.music.126.net/cLoAM3X8pIuCil_oJpxjWw==/18511377767183768.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><blockquote><p>&emsp;&emsp;这篇博客算是记录一下最近几年的一些感想吧，经历了一些生活中、网络中发生的事情会有些感受，这些碎片式的感受还挺难整理的，很多回忆融合到一起，写的时候有些混乱了，写着写着也搞不清想要说什么了。<br>&emsp;&emsp;有些事情发生了，可能并没有一个简单的答案，局外人却可以随心所欲的谈论自己的观点，虽然他们可能什么都不知道，却能没有责任的随便开口。事情已经发生了，当事人也没办法为自己辩护了。<br>&emsp;&emsp;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日志" scheme="http://linyishui.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="diary" scheme="http://linyishui.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Spring和SpringMVC</title>
    <link href="http://linyishui.top/2019110101.html"/>
    <id>http://linyishui.top/2019110101.html</id>
    <published>2019-11-01T09:42:38.000Z</published>
    <updated>2019-12-12T09:44:08.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h1><!--说说Spring的生命周期吧Spring的单例是怎么实现的？SpringMVC不同用户登录的信息怎么保证线程安全的？AOPspringmvc执行流程。3. ioc与aop的原理与流程4. aop实现原理？动态代理与CGlib的区别？5. bean对象的生命周期？6. bean成员变量的参数注入有哪种方式？7. spring常用的注解有哪些？8. @Autowired和@Resource的区别？9. spring提供的扩展组件有用过吗？比如拦截器？说下这个拦截器的api（疯狂问还有没用过其它的组件）10. 登录态怎么去处理的？11. 用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？12. SpringBoot的自动配置流程？Spring IOC是怎么管理bean的？给你spring的jar包你要怎么让它启动20.假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？21.Spring Bean是如何注入的？单例的情况下怎么实例化，什么时候，多例呢？22.Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库基本上涉及到框架的，都是问里面怎么实现的，回答得太表层没什么用，感觉不是他想要的答案，有时搞不清他要问框架的整个处理流程还是底层怎么实现，知道的点很多但是不知道怎么回答，而且情景不是应用在web项目里的，而是一个普通的Java项目你怎么使用。--><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a><strong>SpringMVC</strong></h1><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Spring和SpringMVC相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——数据库</title>
    <link href="http://linyishui.top/2019102901.html"/>
    <id>http://linyishui.top/2019102901.html</id>
    <published>2019-10-29T08:24:25.000Z</published>
    <updated>2019-12-13T02:53:06.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：查询姓名，课程名，成绩-（自定义设计表，写出sql）？"><a href="#问：查询姓名，课程名，成绩-（自定义设计表，写出sql）？" class="headerlink" title="问：查询姓名，课程名，成绩?（自定义设计表，写出sql）？"></a><strong>问：查询姓名，课程名，成绩?（自定义设计表，写出sql）？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？"><a href="#问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？" class="headerlink" title="问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？"></a><strong>问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？</strong></h3><details><br><br>&emsp;&emsp;脏读、幻影读、不可重复读？<br><br></details><h3 id="问：你们生产用的是哪种事务隔离级别，为什么？"><a href="#问：你们生产用的是哪种事务隔离级别，为什么？" class="headerlink" title="问：你们生产用的是哪种事务隔离级别，为什么？"></a><strong>问：你们生产用的是哪种事务隔离级别，为什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么是索引覆盖？"><a href="#问：什么是索引覆盖？" class="headerlink" title="问：什么是索引覆盖？"></a><strong>问：什么是索引覆盖？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：你们数据库的高可用架构是怎么样的？"><a href="#问：你们数据库的高可用架构是怎么样的？" class="headerlink" title="问：你们数据库的高可用架构是怎么样的？"></a><strong>问：你们数据库的高可用架构是怎么样的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何保证数据库主从一致性？"><a href="#问：如何保证数据库主从一致性？" class="headerlink" title="问：如何保证数据库主从一致性？"></a><strong>问：如何保证数据库主从一致性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库存储引擎特点与区别-还有应用场景"><a href="#问：数据库存储引擎特点与区别-还有应用场景" class="headerlink" title="问：数据库存储引擎特点与区别?还有应用场景"></a><strong>问：数据库存储引擎特点与区别?还有应用场景</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库的存储引擎有哪几种？有什么区别？"><a href="#问：数据库的存储引擎有哪几种？有什么区别？" class="headerlink" title="问：数据库的存储引擎有哪几种？有什么区别？"></a><strong>问：数据库的存储引擎有哪几种？有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么时候该用索引-（字段查询过多时）除了这个还有吗"><a href="#问：什么时候该用索引-（字段查询过多时）除了这个还有吗" class="headerlink" title="问：什么时候该用索引?（字段查询过多时）除了这个还有吗?"></a><strong>问：什么时候该用索引?（字段查询过多时）除了这个还有吗?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：聚簇和非聚簇又可细分哪一些？"><a href="#问：聚簇和非聚簇又可细分哪一些？" class="headerlink" title="问：聚簇和非聚簇又可细分哪一些？"></a><strong>问：聚簇和非聚簇又可细分哪一些？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：B-树与B树的区别？索引为什么选择B-树？说下索引结构，为什么使用B-树？"><a href="#问：B-树与B树的区别？索引为什么选择B-树？说下索引结构，为什么使用B-树？" class="headerlink" title="问：B+树与B树的区别？索引为什么选择B+树？说下索引结构，为什么使用B+树？"></a><strong>问：B+树与B树的区别？索引为什么选择B+树？说下索引结构，为什么使用B+树？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：组合索引？"><a href="#问：组合索引？" class="headerlink" title="问：组合索引？"></a><strong>问：组合索引？</strong></h3><details><br><br>&emsp;&emsp;（写了一个例子，选择会走索引的sql）。like索引的例子？(就是以like %李%和like 李%为例子讲)有没有其它例子也是这样跳过索引的？<br><br></details><h3 id="问：主从的模式有哪些？实现同步的方式？"><a href="#问：主从的模式有哪些？实现同步的方式？" class="headerlink" title="问：主从的模式有哪些？实现同步的方式？"></a><strong>问：主从的模式有哪些？实现同步的方式？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有考虑过大数据量优化的情况吗？"><a href="#问：有考虑过大数据量优化的情况吗？" class="headerlink" title="问：有考虑过大数据量优化的情况吗？"></a><strong>问：有考虑过大数据量优化的情况吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Innodb中索引的实现？"><a href="#问：Innodb中索引的实现？" class="headerlink" title="问：Innodb中索引的实现？"></a><strong>问：Innodb中索引的实现？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a><strong>MySql</strong></h2><h3 id="问：知道mysql的索引算法么？"><a href="#问：知道mysql的索引算法么？" class="headerlink" title="问：知道mysql的索引算法么？"></a><strong>问：知道mysql的索引算法么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：为什么mongodb的索引用了B树，而mysql用B-树？"><a href="#问：为什么mongodb的索引用了B树，而mysql用B-树？" class="headerlink" title="问：为什么mongodb的索引用了B树，而mysql用B+树？"></a><strong>问：为什么mongodb的索引用了B树，而mysql用B+树？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql索引的执行计划有了解过吗？"><a href="#问：mysql索引的执行计划有了解过吗？" class="headerlink" title="问：mysql索引的执行计划有了解过吗？"></a><strong>问：mysql索引的执行计划有了解过吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有用过explain吗？它执行的结果重要的参数是什么？"><a href="#问：有用过explain吗？它执行的结果重要的参数是什么？" class="headerlink" title="问：有用过explain吗？它执行的结果重要的参数是什么？"></a><strong>问：有用过explain吗？它执行的结果重要的参数是什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql的主从复制有了解过吗？"><a href="#问：mysql的主从复制有了解过吗？" class="headerlink" title="问：mysql的主从复制有了解过吗？"></a><strong>问：mysql的主从复制有了解过吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql常用的索引类型有哪些？"><a href="#问：mysql常用的索引类型有哪些？" class="headerlink" title="问：mysql常用的索引类型有哪些？"></a><strong>问：mysql常用的索引类型有哪些？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：MySQL有哪些锁？"><a href="#问：MySQL有哪些锁？" class="headerlink" title="问：MySQL有哪些锁？"></a><strong>问：MySQL有哪些锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：MySQL行锁是否会有死锁的情况？"><a href="#问：MySQL行锁是否会有死锁的情况？" class="headerlink" title="问：MySQL行锁是否会有死锁的情况？"></a><strong>问：MySQL行锁是否会有死锁的情况？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：AUTO-INCREMENT原理（考察并发情况）？"><a href="#问：AUTO-INCREMENT原理（考察并发情况）？" class="headerlink" title="问：AUTO_INCREMENT原理（考察并发情况）？"></a><strong>问：AUTO_INCREMENT原理（考察并发情况）？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库的索引有哪几种？"><a href="#问：数据库的索引有哪几种？" class="headerlink" title="问：数据库的索引有哪几种？"></a><strong>问：数据库的索引有哪几种？</strong></h3><details><br><br>&emsp;&emsp;为什么要用B+树来做索引？<br><br>&emsp;&emsp;组合索引和几个单个的索引有什么区别？<br><br>&emsp;&emsp;数据库的大表查询优化了解吗？<br><br>&emsp;&emsp;MVCC机制了解不？<br><br>&emsp;&emsp;MVCC机制有什么问题？<br><br>&emsp;&emsp;怎么去解决这个问题？<br><br>&emsp;&emsp;mysql慢语句调优做过吗？<br><br>&emsp;&emsp;说说你是怎么做的？<br><br></details><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h2><h3 id="问：redis了解吗？你说说怎么用redis实现分布式锁？"><a href="#问：redis了解吗？你说说怎么用redis实现分布式锁？" class="headerlink" title="问：redis了解吗？你说说怎么用redis实现分布式锁？"></a><strong>问：redis了解吗？你说说怎么用redis实现分布式锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构-分别用在什么场景-zset底层怎么实现的"><a href="#问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构-分别用在什么场景-zset底层怎么实现的" class="headerlink" title="问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构? 分别用在什么场景? zset底层怎么实现的?"></a><strong>问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构? 分别用在什么场景? zset底层怎么实现的?</strong></h3><details><br><br>&emsp;&emsp;既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树。你们用了redis，redis的底层数据结构了解多少？<br><br></details><h3 id="问：如何解决-Redis-的并发竞争-Key-问题？"><a href="#问：如何解决-Redis-的并发竞争-Key-问题？" class="headerlink" title="问：如何解决 Redis 的并发竞争 Key 问题？"></a><strong>问：如何解决 Redis 的并发竞争 Key 问题？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何保证缓存与数据库双写时的数据一致性？"><a href="#问：如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="问：如何保证缓存与数据库双写时的数据一致性？"></a><strong>问：如何保证缓存与数据库双写时的数据一致性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：项目用到了redis，讲讲你项目用到了redis的哪些特性？"><a href="#问：项目用到了redis，讲讲你项目用到了redis的哪些特性？" class="headerlink" title="问：项目用到了redis，讲讲你项目用到了redis的哪些特性？"></a><strong>问：项目用到了redis，讲讲你项目用到了redis的哪些特性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；"><a href="#问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；" class="headerlink" title="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；"></a><strong>问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis支持哪些数据类型？"><a href="#问：redis支持哪些数据类型？" class="headerlink" title="问：redis支持哪些数据类型？"></a><strong>问：redis支持哪些数据类型？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis中的字符串类型是怎么实现的？"><a href="#问：redis中的字符串类型是怎么实现的？" class="headerlink" title="问：redis中的字符串类型是怎么实现的？"></a><strong>问：redis中的字符串类型是怎么实现的？</strong></h3><details><br><br>&emsp;&emsp;(SDS)注:sds为redis底层数据结构之一<br><br></details><h3 id="问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？"><a href="#问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？" class="headerlink" title="问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？"></a><strong>问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？</strong></h3><details><br><br>&emsp;&emsp;（共有4个优点，前不久刚看过，当时只回忆起1个优点。。）<br><br></details><h3 id="问：关于redis对象系统的一个问题？"><a href="#问：关于redis对象系统的一个问题？" class="headerlink" title="问：关于redis对象系统的一个问题？"></a><strong>问：关于redis对象系统的一个问题？</strong></h3><details><br><br>&emsp;&emsp;（我说忘记了，记得redis设计与实现有写，面试小哥：忘记了那就不问了）<br><br></details><h3 id="问：Redis高并发快的原因？"><a href="#问：Redis高并发快的原因？" class="headerlink" title="问：Redis高并发快的原因？"></a><strong>问：Redis高并发快的原因？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis主从机制了解么？怎么实现的？"><a href="#问：redis主从机制了解么？怎么实现的？" class="headerlink" title="问：redis主从机制了解么？怎么实现的？"></a><strong>问：redis主从机制了解么？怎么实现的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何利用Redis处理热点数据？"><a href="#问：如何利用Redis处理热点数据？" class="headerlink" title="问：如何利用Redis处理热点数据？"></a><strong>问：如何利用Redis处理热点数据？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈Redis哨兵、复制、集群？"><a href="#问：谈谈Redis哨兵、复制、集群？" class="headerlink" title="问：谈谈Redis哨兵、复制、集群？"></a><strong>问：谈谈Redis哨兵、复制、集群？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：你们怎么解决缓存击穿问题的？"><a href="#问：你们怎么解决缓存击穿问题的？" class="headerlink" title="问：你们怎么解决缓存击穿问题的？"></a><strong>问：你们怎么解决缓存击穿问题的？</strong></h3><details><br><br>&emsp;&emsp;注:估计答了Hystrix<br><br></details><h3 id="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"><a href="#问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？" class="headerlink" title="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"></a><strong>问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？</strong></h3><details><br><br>&emsp;&emsp;注:估计答了Hystrix<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的数据库相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——分布式</title>
    <link href="http://linyishui.top/2019102801.html"/>
    <id>http://linyishui.top/2019102801.html</id>
    <published>2019-10-28T08:24:18.000Z</published>
    <updated>2019-12-13T02:35:30.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>zookeeper怎么保证数据一致性的</p><p>讲讲你对zk的理解吧</p><p>Spring Cloud用到什么东西？<br>如何实现负载均衡？<br>服务挂了注册中心怎么判断？</p><p>分布式锁的实现你知道的有哪些？具体详细谈一种实现方式</p><p>高并发的应用场景，技术需要涉及到哪些？怎样来架构设计？</p><p>接着高并发的问题，谈到了秒杀等的技术应用：kafka、redis、mycat等</p><p>最后谈谈你参与过的项目，技术含量比较高的，相关的架构设计以及你负责哪些核心编码</p><p>部门组织结构是怎样的？<br>系统有哪些模块，每个模块用了哪些技术，数据怎么流转的？给了我一张纸，我在上面简单画了下系统之间的流转情况<br>链路追踪的信息是怎么传递的？</p><p>SpanId怎么保证唯一性？<br>RpcContext是在什么维度传递的？<br>Dubbo的远程调用怎么实现的？</p><p>为什么要单独实现一个服务治理框架？<br>谁主导的？内部还在使用么？<br>逆向有想过怎么做成通用么？</p><p>说下Dubbo的原理?</p><p>分布式追踪的上下文是怎么存储和传递的？</p><p>Dubbo的RpcContext是怎么传递的？主线程的ThreadLocal怎么传递到线程池？你说的内存泄漏具体是怎么产生的？<br>线程池的线程是不是必须手动remove才可以回收value？那你说的内存泄漏是指主线程还是线程池？</p><p>介绍一下自己对 Netty 的认识，为什么要用。说说业务中，Netty 的使用场景。什么是TCP 粘包/拆包,解决办法。Netty线程模型。Dubbo 在使用 Netty 作为网络通讯时候是如何避免粘包与半包问题？讲讲Netty的零拷贝？巴拉巴拉问了好多，我记得有好几个我都没回答上来，心里想着凉凉了啊。</p><p>NginX如何做负载均衡、常见的负载均衡算法有哪些、一致性哈希的一致性是什么意思、一致性哈希是如何做哈希的</p><p>你们项目中微服务是怎么划分的，划分粒度怎么确定？<br>那在实践微服务架构中，有遇到什么问题么？<br>你们在关于微服务间数据一致性问题，是如何解决的？<br>你们为什么不用其他的MQ,最终选择了RocketMQ？<br>为什么RocketMQ没有选择ZooKeeper，而是自己实现了一个NameServer集群？<br>嗯，理解的不错，Zookeeper在选举的过程中，还能对外提供服务么？<br>对Paxos算法了解多少？<br>如果让你来设计一个春晚抢红包架构，你会怎么设计？</p><p>你们在微服务中用RPC通信还是REST？<br>RPC和HTTP的关系是什么？</p><p>谈一谈你对微服务架构的理解</p><p>你用过哪些RPC框架，讲讲他们优缺点</p><p>用过docker么，对容器了解多少</p><p>RPC是什么，如何实现？发送请求之后如何阻塞？让你来设计你会怎么做？这里讨巧，回答用restful做，但是同样问了发送之后怎么确定收到了这个请求的数据</p><h2 id="消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现"><a href="#消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现" class="headerlink" title="消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现"></a>消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现</h2><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的分布式相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——操作系统</title>
    <link href="http://linyishui.top/2019102701.html"/>
    <id>http://linyishui.top/2019102701.html</id>
    <published>2019-10-27T08:24:13.000Z</published>
    <updated>2019-12-13T02:34:28.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：说一下操作系统的内存管理机制？"><a href="#问：说一下操作系统的内存管理机制？" class="headerlink" title="问：说一下操作系统的内存管理机制？"></a><strong>问：说一下操作系统的内存管理机制？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：页面置换算法有哪些，介绍一下？"><a href="#问：页面置换算法有哪些，介绍一下？" class="headerlink" title="问：页面置换算法有哪些，介绍一下？"></a><strong>问：页面置换算法有哪些，介绍一下？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：试着实现一下LRU算法？"><a href="#问：试着实现一下LRU算法？" class="headerlink" title="问：试着实现一下LRU算法？"></a><strong>问：试着实现一下LRU算法？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><strong>进程和线程</strong></h2><h3 id="问：fork和exec有深入了解吗？"><a href="#问：fork和exec有深入了解吗？" class="headerlink" title="问：fork和exec有深入了解吗？"></a><strong>问：fork和exec有深入了解吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？"><a href="#问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？" class="headerlink" title="问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？"></a><strong>问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？</strong></h3><details><br><br>&emsp;&emsp;答：只有一个线程<br><br>&emsp;&emsp;为什会只fork一个线程？会带来什么问题？<br><br>&emsp;&emsp;答：扯了一下unix设计fork接口那会还没有多线程的概念，所以就没考虑复制多个线程，会带来线程安全性问题，略去。<br><br></details><hr><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><strong>Linux</strong></h2><h3 id="问：linux中有哪些常见的指令？"><a href="#问：linux中有哪些常见的指令？" class="headerlink" title="问：linux中有哪些常见的指令？"></a><strong>问：linux中有哪些常见的指令？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：select、poll、epoll有没有了解过，讲解一下？区别？"><a href="#问：select、poll、epoll有没有了解过，讲解一下？区别？" class="headerlink" title="问：select、poll、epoll有没有了解过，讲解一下？区别？"></a><strong>问：select、poll、epoll有没有了解过，讲解一下？区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何查看Linux系统运行状态？"><a href="#问：如何查看Linux系统运行状态？" class="headerlink" title="问：如何查看Linux系统运行状态？"></a><strong>问：如何查看Linux系统运行状态？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一下Linux软链接以及和硬链接的区别？"><a href="#问：说一下Linux软链接以及和硬链接的区别？" class="headerlink" title="问：说一下Linux软链接以及和硬链接的区别？"></a><strong>问：说一下Linux软链接以及和硬链接的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一下Linux进程间通信的方式？"><a href="#问：说一下Linux进程间通信的方式？" class="headerlink" title="问：说一下Linux进程间通信的方式？"></a><strong>问：说一下Linux进程间通信的方式？</strong></h3><p>&emsp;&emsp;答：管道，信号量，消息队列，共享内存，套接字。</p><h3 id="问：说一下命名管道和匿名管道的特点和区别？"><a href="#问：说一下命名管道和匿名管道的特点和区别？" class="headerlink" title="问：说一下命名管道和匿名管道的特点和区别？"></a><strong>问：说一下命名管道和匿名管道的特点和区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的操作系统相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——网络</title>
    <link href="http://linyishui.top/2019102601.html"/>
    <id>http://linyishui.top/2019102601.html</id>
    <published>2019-10-26T08:23:48.000Z</published>
    <updated>2019-12-13T02:34:13.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：说一下dns的原理？"><a href="#问：说一下dns的原理？" class="headerlink" title="问：说一下dns的原理？"></a><strong>问：说一下dns的原理？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：cookie、session、token三者区别以及优缺点？"><a href="#问：cookie、session、token三者区别以及优缺点？" class="headerlink" title="问：cookie、session、token三者区别以及优缺点？"></a><strong>问：cookie、session、token三者区别以及优缺点？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a><strong>TCP/IP</strong></h2><h3 id="问：OSI七层模型都是什么？"><a href="#问：OSI七层模型都是什么？" class="headerlink" title="问：OSI七层模型都是什么？"></a><strong>问：OSI七层模型都是什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：举例网络协议，都在哪个层？"><a href="#问：举例网络协议，都在哪个层？" class="headerlink" title="问：举例网络协议，都在哪个层？"></a><strong>问：举例网络协议，都在哪个层？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TCP和UDP的区别？udp为什么要比tcp快？"><a href="#问：TCP和UDP的区别？udp为什么要比tcp快？" class="headerlink" title="问：TCP和UDP的区别？udp为什么要比tcp快？"></a><strong>问：TCP和UDP的区别？udp为什么要比tcp快？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TCP如何实现可靠连接-传输？"><a href="#问：TCP如何实现可靠连接-传输？" class="headerlink" title="问：TCP如何实现可靠连接/传输？"></a><strong>问：TCP如何实现可靠连接/传输？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：为什么要有TimeWait状态？"><a href="#问：为什么要有TimeWait状态？" class="headerlink" title="问：为什么要有TimeWait状态？"></a><strong>问：为什么要有TimeWait状态？</strong></h3><details><br><br>&emsp;&emsp;TimeWait的等待时长一般是多少？为什么Time_Wait中2*msl？<br><br></details><h3 id="问：如果TCP突然接收方故障会发生什么？"><a href="#问：如果TCP突然接收方故障会发生什么？" class="headerlink" title="问：如果TCP突然接收方故障会发生什么？"></a><strong>问：如果TCP突然接收方故障会发生什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：一个url从输入到访问经过了哪些过程？"><a href="#问：一个url从输入到访问经过了哪些过程？" class="headerlink" title="问：一个url从输入到访问经过了哪些过程？"></a><strong>问：一个url从输入到访问经过了哪些过程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一说TCP三次握手和四次挥手？"><a href="#问：说一说TCP三次握手和四次挥手？" class="headerlink" title="问：说一说TCP三次握手和四次挥手？"></a><strong>问：说一说TCP三次握手和四次挥手？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TCP怎么计算网络延迟？"><a href="#问：TCP怎么计算网络延迟？" class="headerlink" title="问：TCP怎么计算网络延迟？"></a><strong>问：TCP怎么计算网络延迟？</strong></h3><details><br><br>&emsp;&emsp;网络延迟的采样方法。<br><br></details><h3 id="问：TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？"><a href="#问：TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？" class="headerlink" title="问：TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？"></a><strong>问：TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TCP有哪些状态，相应状态的含义？"><a href="#问：TCP有哪些状态，相应状态的含义？" class="headerlink" title="问：TCP有哪些状态，相应状态的含义？"></a><strong>问：TCP有哪些状态，相应状态的含义？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><strong>HTTP</strong></h2><h3 id="问：简单谈谈对HTTP的了解？"><a href="#问：简单谈谈对HTTP的了解？" class="headerlink" title="问：简单谈谈对HTTP的了解？"></a><strong>问：简单谈谈对HTTP的了解？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一下post和put的数据是放在哪个字段？"><a href="#问：说一下post和put的数据是放在哪个字段？" class="headerlink" title="问：说一下post和put的数据是放在哪个字段？"></a><strong>问：说一下post和put的数据是放在哪个字段？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：HTTP状态码含义：503，504，505，403，200？"><a href="#问：HTTP状态码含义：503，504，505，403，200？" class="headerlink" title="问：HTTP状态码含义：503，504，505，403，200？"></a><strong>问：HTTP状态码含义：503，504，505，403，200？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：GET和POST区别？"><a href="#问：GET和POST区别？" class="headerlink" title="问：GET和POST区别？"></a><strong>问：GET和POST区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：知道HTTP1-0和1-1的区别么？"><a href="#问：知道HTTP1-0和1-1的区别么？" class="headerlink" title="问：知道HTTP1.0和1.1的区别么？"></a><strong>问：知道HTTP1.0和1.1的区别么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈什么是HTTP的长连接和短连接？"><a href="#问：谈谈什么是HTTP的长连接和短连接？" class="headerlink" title="问：谈谈什么是HTTP的长连接和短连接？"></a><strong>问：谈谈什么是HTTP的长连接和短连接？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的网络相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——算法</title>
    <link href="http://linyishui.top/2019102501.html"/>
    <id>http://linyishui.top/2019102501.html</id>
    <published>2019-10-25T08:23:37.000Z</published>
    <updated>2019-12-13T02:51:12.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><h3 id="问：讲讲红黑树、二叉树的算法？红黑树了解么，时间复杂度"><a href="#问：讲讲红黑树、二叉树的算法？红黑树了解么，时间复杂度" class="headerlink" title="问：讲讲红黑树、二叉树的算法？红黑树了解么，时间复杂度?"></a><strong>问：讲讲红黑树、二叉树的算法？红黑树了解么，时间复杂度?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲下跳表怎么实现的-哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树？"><a href="#问：讲下跳表怎么实现的-哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树？" class="headerlink" title="问：讲下跳表怎么实现的?哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树？"></a><strong>问：讲下跳表怎么实现的?哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲下常见的排序算法及其复杂度？怎么实现一个快排？树一般怎么实现，链表怎么实现？"><a href="#问：讲下常见的排序算法及其复杂度？怎么实现一个快排？树一般怎么实现，链表怎么实现？" class="headerlink" title="问：讲下常见的排序算法及其复杂度？怎么实现一个快排？树一般怎么实现，链表怎么实现？"></a><strong>问：讲下常见的排序算法及其复杂度？怎么实现一个快排？树一般怎么实现，链表怎么实现？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：堆是怎么实现？小根堆如何插入数据，讲一下过程？"><a href="#问：堆是怎么实现？小根堆如何插入数据，讲一下过程？" class="headerlink" title="问：堆是怎么实现？小根堆如何插入数据，讲一下过程？"></a><strong>问：堆是怎么实现？小根堆如何插入数据，讲一下过程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a><strong>算法题</strong></h2><h3 id="问：使用O-N-复杂度完成GBDT分裂？"><a href="#问：使用O-N-复杂度完成GBDT分裂？" class="headerlink" title="问：使用O(N)复杂度完成GBDT分裂？"></a><strong>问：使用O(N)复杂度完成GBDT分裂？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：找出无序数组中相隔距离最长的逆序对？"><a href="#问：找出无序数组中相隔距离最长的逆序对？" class="headerlink" title="问：找出无序数组中相隔距离最长的逆序对？"></a><strong>问：找出无序数组中相隔距离最长的逆序对？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：给出一个rand5-，实现一个分布均匀的rand7-生成器？"><a href="#问：给出一个rand5-，实现一个分布均匀的rand7-生成器？" class="headerlink" title="问：给出一个rand5()，实现一个分布均匀的rand7()生成器？"></a><strong>问：给出一个rand5()，实现一个分布均匀的rand7()生成器？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有一个点，向北走5公里、东走10km、向南走5公里，回到原点。这样的点有几个，证明？"><a href="#问：有一个点，向北走5公里、东走10km、向南走5公里，回到原点。这样的点有几个，证明？" class="headerlink" title="问：有一个点，向北走5公里、东走10km、向南走5公里，回到原点。这样的点有几个，证明？"></a><strong>问：有一个点，向北走5公里、东走10km、向南走5公里，回到原点。这样的点有几个，证明？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有一个n克的物体、一个天平和若干砝码，这个天平没有刻度，试问最少用多少个什么样的砝码可以将这个物体的质量称出。砝码的质量和个数自行指定。"><a href="#问：有一个n克的物体、一个天平和若干砝码，这个天平没有刻度，试问最少用多少个什么样的砝码可以将这个物体的质量称出。砝码的质量和个数自行指定。" class="headerlink" title="问：有一个n克的物体、一个天平和若干砝码，这个天平没有刻度，试问最少用多少个什么样的砝码可以将这个物体的质量称出。砝码的质量和个数自行指定。"></a><strong>问：有一个n克的物体、一个天平和若干砝码，这个天平没有刻度，试问最少用多少个什么样的砝码可以将这个物体的质量称出。砝码的质量和个数自行指定。</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：实现堆排序"><a href="#问：实现堆排序" class="headerlink" title="问：实现堆排序"></a><strong>问：实现堆排序</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：给了长度为N的有重复元素的数组，要求输出第10大的数。需要在2小时内完成"><a href="#问：给了长度为N的有重复元素的数组，要求输出第10大的数。需要在2小时内完成" class="headerlink" title="问：给了长度为N的有重复元素的数组，要求输出第10大的数。需要在2小时内完成"></a><strong>问：给了长度为N的有重复元素的数组，要求输出第10大的数。需要在2小时内完成</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：手写一个对象池"><a href="#问：手写一个对象池" class="headerlink" title="问：手写一个对象池"></a><strong>问：手写一个对象池</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="手撕"><a href="#手撕" class="headerlink" title="手撕"></a><strong>手撕</strong></h2><h3 id="问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。"><a href="#问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。" class="headerlink" title="问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。"></a><strong>问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。</strong></h3><details><br><br>&emsp;&emsp;一开始以为这道题是道动态规划的题目，但是老想不出递推关系式。问了下是不是贪心的思路，面试官说是贪心，然后给了个例子以及一波暗示，我才终于发现其实每次都跳到加血的蘑菇位置就行了。然后赶紧写了波代码，就这样过去了<br><br></details><h3 id="问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？"><a href="#问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？" class="headerlink" title="问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？"></a><strong>问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？"><a href="#问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？" class="headerlink" title="问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？"></a><strong>问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？</strong></h3><details><br><br>&emsp;&emsp;答：用字典树来做，省略100字。<br><br></details><h3 id="问：url很长，字典树很占空间怎么办？"><a href="#问：url很长，字典树很占空间怎么办？" class="headerlink" title="问：url很长，字典树很占空间怎么办？"></a><strong>问：url很长，字典树很占空间怎么办？</strong></h3><details><br><br>&emsp;&emsp;答：对url进行分段哈希，然后再放到树节点中，而不是直接把每一个字符作为一个树节点。<br><br></details><h3 id="问：你刚才提到了哈希，那说一下哈希的实现？"><a href="#问：你刚才提到了哈希，那说一下哈希的实现？" class="headerlink" title="问：你刚才提到了哈希，那说一下哈希的实现？"></a><strong>问：你刚才提到了哈希，那说一下哈希的实现？</strong></h3><details><br><br>&emsp;&emsp;答：说了下STL里面unordered_map的大概实现原理，哈希函数，二次探测，开链，省略100字。<br><br>&emsp;&emsp;哈希在什么情况下需要扩容？怎么扩容？<br><br>&emsp;&emsp;答：说了下饱和度过大时需要扩容，每次容量翻一倍。<br><br>&emsp;&emsp;为什么扩容时是翻一倍呢？而不是两倍，三倍？<br><br>&emsp;&emsp;答：（这我就真不知道了😖，一顿乱猜）于是说了下STL内存分配器的特点以及里面内存池的结构可能更适合这样分配，才算糊弄过去😅。<br><br>&emsp;&emsp;服务器中有大量数据需要迁移，如何在不停止对外服务的情况下安全的迁移数据？<br><br>&emsp;&emsp;答：一开始没明白意思，说这个直接复制就行噻😃，<br><br>&emsp;&emsp;然后面试官提醒要是复制的过程中数据被改动了怎么办？<br><br>&emsp;&emsp;答：需要对数据加锁。<br><br>&emsp;&emsp;加锁了不就没法对外服务了吗？<br><br>&emsp;&emsp;答：可以把数据分成许多段，复制某一段的时候就把这一段数据加锁。<br><br>&emsp;&emsp;面试官觉得我越扯越远，就没继续问了。😌<br><br>&emsp;&emsp;谈一下你的职业规划？答略<br><br></details><h3 id="问：找出数组中只出现一次的那个数，其他都出现两次；-异或"><a href="#问：找出数组中只出现一次的那个数，其他都出现两次；-异或" class="headerlink" title="问：找出数组中只出现一次的那个数，其他都出现两次；(异或)"></a><strong>问：找出数组中只出现一次的那个数，其他都出现两次；(异或)</strong></h3><details><br><br>&emsp;&emsp;接上面，如果数组中有两个数只出现一次呢？<br><br></details><h3 id="问：BST中任意两个节点差的最小值"><a href="#问：BST中任意两个节点差的最小值" class="headerlink" title="问：BST中任意两个节点差的最小值"></a><strong>问：BST中任意两个节点差的最小值</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：判断二叉树是否中心对称"><a href="#问：判断二叉树是否中心对称" class="headerlink" title="问：判断二叉树是否中心对称"></a><strong>问：判断二叉树是否中心对称</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：大数相乘"><a href="#问：大数相乘" class="headerlink" title="问：大数相乘"></a><strong>问：大数相乘</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路"><a href="#问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路" class="headerlink" title="问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路"></a><strong>问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数组A，2-n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路"><a href="#问：数组A，2-n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路" class="headerlink" title="问：数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路"></a><strong>问：数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：统计一个字符串的字符出现字数并打印-除了这个还有别的办法吗"><a href="#问：统计一个字符串的字符出现字数并打印-除了这个还有别的办法吗" class="headerlink" title="问：统计一个字符串的字符出现字数并打印?除了这个还有别的办法吗?"></a><strong>问：统计一个字符串的字符出现字数并打印?除了这个还有别的办法吗?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：全排列"><a href="#问：全排列" class="headerlink" title="问：全排列?"></a><strong>问：全排列?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？"><a href="#问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？" class="headerlink" title="问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？"></a><strong>问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？"><a href="#问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？" class="headerlink" title="问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？"></a><strong>问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：判断数组里是否有和为指定值的两个数？"><a href="#问：判断数组里是否有和为指定值的两个数？" class="headerlink" title="问：判断数组里是否有和为指定值的两个数？"></a><strong>问：判断数组里是否有和为指定值的两个数？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：对笔试题进行提问？有没找到更好的解法吗？"><a href="#问：对笔试题进行提问？有没找到更好的解法吗？" class="headerlink" title="问：对笔试题进行提问？有没找到更好的解法吗？"></a><strong>问：对笔试题进行提问？有没找到更好的解法吗？</strong></h3><details><br><br>&emsp;&emsp;(题目大概是一个数组里除了一个数字出现一次，其它数字都出现了两次，给一个最优解法？我说可以用map，key为数字，value为该数字出现次数？面试官给了一个异或的方法，提示两次异或是本身）<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的算法相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——JVM</title>
    <link href="http://linyishui.top/2019102401.html"/>
    <id>http://linyishui.top/2019102401.html</id>
    <published>2019-10-24T08:06:28.000Z</published>
    <updated>2019-12-13T02:52:58.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：Java为什么要设计双亲委派模型？"><a href="#问：Java为什么要设计双亲委派模型？" class="headerlink" title="问：Java为什么要设计双亲委派模型？"></a><strong>问：Java为什么要设计双亲委派模型？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行"><a href="#问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行" class="headerlink" title="问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行"></a><strong>问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a><strong>内存模型</strong></h2><h3 id="问：简单介绍一下JVM内存模型？"><a href="#问：简单介绍一下JVM内存模型？" class="headerlink" title="问：简单介绍一下JVM内存模型？"></a><strong>问：简单介绍一下JVM内存模型？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲解新生代和老年代？"><a href="#问：讲解新生代和老年代？" class="headerlink" title="问：讲解新生代和老年代？"></a><strong>问：讲解新生代和老年代？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><p>说一下JVM的线程模型？这些区域都分别是干啥用的？java线程模型和jvm线程模型注意区分</p><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h2><h3 id="问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？"><a href="#问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？" class="headerlink" title="问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？"></a><strong>问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：简单介绍一下GC垃圾回收算法？说说GC的过程"><a href="#问：简单介绍一下GC垃圾回收算法？说说GC的过程" class="headerlink" title="问：简单介绍一下GC垃圾回收算法？说说GC的过程"></a><strong>问：简单介绍一下GC垃圾回收算法？说说GC的过程</strong></h3><details><br><br>&emsp;&emsp;垃圾回收。如何通知gc回收?（System.gc）除了这个方法还有吗?（将不用的对象赋值为null）<br><br></details><h3 id="问：常见的垃圾回收器？"><a href="#问：常见的垃圾回收器？" class="headerlink" title="问：常见的垃圾回收器？"></a><strong>问：常见的垃圾回收器？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Java-GC机制？GC-Roots有哪些？"><a href="#问：Java-GC机制？GC-Roots有哪些？" class="headerlink" title="问：Java GC机制？GC Roots有哪些？"></a><strong>问：Java GC机制？GC Roots有哪些？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有过GC调优的经历么？"><a href="#问：有过GC调优的经历么？" class="headerlink" title="问：有过GC调优的经历么？"></a><strong>问：有过GC调优的经历么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：强制young-gc会有什么问题？"><a href="#问：强制young-gc会有什么问题？" class="headerlink" title="问：强制young gc会有什么问题？"></a><strong>问：强制young gc会有什么问题？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：知道G1么？回收过程是怎么样的？"><a href="#问：知道G1么？回收过程是怎么样的？" class="headerlink" title="问：知道G1么？回收过程是怎么样的？"></a><strong>问：知道G1么？回收过程是怎么样的？</strong></h3><details><br><br>&emsp;&emsp;你提到的Remember Set底层是怎么实现的？CMS GC有什么问题？怎么避免产生浮动垃圾？<br><br></details><h3 id="问：Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优？"><a href="#问：Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优？" class="headerlink" title="问：Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优？"></a><strong>问：Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a><strong>类加载</strong></h2><h3 id="问：说下类加载的过程？"><a href="#问：说下类加载的过程？" class="headerlink" title="问：说下类加载的过程？"></a><strong>问：说下类加载的过程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么时候需要自定义类加载器？"><a href="#问：什么时候需要自定义类加载器？" class="headerlink" title="问：什么时候需要自定义类加载器？"></a><strong>问：什么时候需要自定义类加载器？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Class-forName-是否会初始化类？"><a href="#问：Class-forName-是否会初始化类？" class="headerlink" title="问：Class.forName 是否会初始化类？"></a><strong>问：Class.forName 是否会初始化类？</strong></h3><details><br><br>&emsp;&emsp;这里我智障了，振振有词地说说不会初始化<br><br></details><h3 id="问：static-块会执行几次？怎么让它执行第二次？"><a href="#问：static-块会执行几次？怎么让它执行第二次？" class="headerlink" title="问：static 块会执行几次？怎么让它执行第二次？"></a><strong>问：static 块会执行几次？怎么让它执行第二次？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java虚拟机相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Java网络编程</title>
    <link href="http://linyishui.top/2019102301.html"/>
    <id>http://linyishui.top/2019102301.html</id>
    <published>2019-10-23T08:06:22.000Z</published>
    <updated>2019-12-12T08:12:12.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java网络编程相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Java并发编程</title>
    <link href="http://linyishui.top/2019102201.html"/>
    <id>http://linyishui.top/2019102201.html</id>
    <published>2019-10-22T08:06:16.000Z</published>
    <updated>2019-12-13T02:41:04.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><hr><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a><strong>锁</strong></h2><h3 id="问：讲讲你知道的锁？"><a href="#问：讲讲你知道的锁？" class="headerlink" title="问：讲讲你知道的锁？"></a><strong>问：讲讲你知道的锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈一下悲观锁和乐观锁？"><a href="#问：谈一下悲观锁和乐观锁？" class="headerlink" title="问：谈一下悲观锁和乐观锁？"></a><strong>问：谈一下悲观锁和乐观锁？</strong></h3><details><br><br>&emsp;&emsp;JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？<br><br></details><h3 id="问：讲讲ReentrantLock实现原理？"><a href="#问：讲讲ReentrantLock实现原理？" class="headerlink" title="问：讲讲ReentrantLock实现原理？"></a><strong>问：讲讲ReentrantLock实现原理？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲讲AQS？讲讲AQS怎么实现的Fair和NoFair？"><a href="#问：讲讲AQS？讲讲AQS怎么实现的Fair和NoFair？" class="headerlink" title="问：讲讲AQS？讲讲AQS怎么实现的Fair和NoFair？"></a><strong>问：讲讲AQS？讲讲AQS怎么实现的Fair和NoFair？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：synchronized-和-ReentranLock的区别？"><a href="#问：synchronized-和-ReentranLock的区别？" class="headerlink" title="问：synchronized 和 ReentranLock的区别？"></a><strong>问：synchronized 和 ReentranLock的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：sychronized和lock有什么区别？"><a href="#问：sychronized和lock有什么区别？" class="headerlink" title="问：sychronized和lock有什么区别？"></a><strong>问：sychronized和lock有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：CAS和synchronize有什么区别？都用synchronize不行么？"><a href="#问：CAS和synchronize有什么区别？都用synchronize不行么？" class="headerlink" title="问：CAS和synchronize有什么区别？都用synchronize不行么？"></a><strong>问：CAS和synchronize有什么区别？都用synchronize不行么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：ConcurrentHashMap的get需要加锁么，为什么？"><a href="#问：ConcurrentHashMap的get需要加锁么，为什么？" class="headerlink" title="问：ConcurrentHashMap的get需要加锁么，为什么？"></a><strong>问：ConcurrentHashMap的get需要加锁么，为什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：volatile的作用是什么？"><a href="#问：volatile的作用是什么？" class="headerlink" title="问：volatile的作用是什么？"></a><strong>问：volatile的作用是什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：用过CountDownLatch么？什么场景下用的？"><a href="#问：用过CountDownLatch么？什么场景下用的？" class="headerlink" title="问：用过CountDownLatch么？什么场景下用的？"></a><strong>问：用过CountDownLatch么？什么场景下用的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：死锁产生的原因？如何预防？"><a href="#问：死锁产生的原因？如何预防？" class="headerlink" title="问：死锁产生的原因？如何预防？"></a><strong>问：死锁产生的原因？如何预防？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：加锁会带来哪些性能问题。如何解决？"><a href="#问：加锁会带来哪些性能问题。如何解决？" class="headerlink" title="问：加锁会带来哪些性能问题。如何解决？"></a><strong>问：加锁会带来哪些性能问题。如何解决？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h2><h3 id="问：线程和进程的区别？"><a href="#问：线程和进程的区别？" class="headerlink" title="问：线程和进程的区别？"></a><strong>问：线程和进程的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么时候用线程？"><a href="#问：什么时候用线程？" class="headerlink" title="问：什么时候用线程？"></a><strong>问：什么时候用线程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何创建子进程？"><a href="#问：如何创建子进程？" class="headerlink" title="问：如何创建子进程？"></a><strong>问：如何创建子进程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈一下线程切换，并引申到Java阻塞，运行？"><a href="#问：谈一下线程切换，并引申到Java阻塞，运行？" class="headerlink" title="问：谈一下线程切换，并引申到Java阻塞，运行？"></a><strong>问：谈一下线程切换，并引申到Java阻塞，运行？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈一下ThreadLocal？应用场景？"><a href="#问：谈一下ThreadLocal？应用场景？" class="headerlink" title="问：谈一下ThreadLocal？应用场景？"></a><strong>问：谈一下ThreadLocal？应用场景？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"><a href="#问：谈一下对线程安全的理解？用什么方法保证线程的安全？" class="headerlink" title="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"></a><strong>问：谈一下对线程安全的理解？用什么方法保证线程的安全？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：CAS了解么？还了解其他同步机制么？"><a href="#问：CAS了解么？还了解其他同步机制么？" class="headerlink" title="问：CAS了解么？还了解其他同步机制么？"></a><strong>问：CAS了解么？还了解其他同步机制么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Thread类里有哪些常用方法？wait和sleep有什么区别？"><a href="#问：Thread类里有哪些常用方法？wait和sleep有什么区别？" class="headerlink" title="问：Thread类里有哪些常用方法？wait和sleep有什么区别？"></a><strong>问：Thread类里有哪些常用方法？wait和sleep有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"><a href="#问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？" class="headerlink" title="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"></a><strong>问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"></a><strong>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？</strong></h3><details><br><br>&emsp;&emsp;如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度?<br><br></details><h3 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"></a><strong>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"><a href="#问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？" class="headerlink" title="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"></a><strong>问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？</strong></h3><details><br><br>&emsp;&emsp;答了CountdownLatch和CyclicBarrier，之后提示可以利用Thread的join方法<br><br></details><h3 id="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"><a href="#问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？" class="headerlink" title="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"></a><strong>问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？</strong></h3><details><br><br>&emsp;&emsp;答了synchronized和Object的wait和notify，强调了notify是随机，All是全部，然后问All怎么个全部法，全部唤醒都开始执行不就不安全了吗？<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java并发编程相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Java集合</title>
    <link href="http://linyishui.top/2019102101.html"/>
    <id>http://linyishui.top/2019102101.html</id>
    <published>2019-10-21T08:06:06.000Z</published>
    <updated>2019-12-20T10:44:47.157Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：平常用到哪些集合类？"><a href="#问：平常用到哪些集合类？" class="headerlink" title="问：平常用到哪些集合类？"></a><strong>问：平常用到哪些集合类？</strong></h3><details><br><br>&emsp;&emsp;答：ArrayList，LinkedList，HashSet，HashMap，TreeMap等（补充：ArrayQueue，PriorityQueue，TreeSet，EnumSet，LinkedHashSet，EnumMap，LinkedHashMap，WeakHashMap，IdentityHashMap）<br><br>&emsp;&emsp;<a href="../2019040901.html" title="Title">Java集合(一) 概述</a><br><br></details><h3 id="问：了解了哪些并发安全集合，从list到map都讲一下？"><a href="#问：了解了哪些并发安全集合，从list到map都讲一下？" class="headerlink" title="问：了解了哪些并发安全集合，从list到map都讲一下？"></a><strong>问：了解了哪些并发安全集合，从list到map都讲一下？</strong></h3><details><br><br>&emsp;&emsp;答：vector，HashTable。（前两个被弃用）Collections对集合的安全封装（如Collections.synchronizedList），以及concurrent包提供的：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue，还有加了写锁的CopyOnWriteArrayList和CopyOnWriteArraySet<br><br></details><hr><h2 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h2><h3 id="问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？"><a href="#问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？" class="headerlink" title="问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？"></a><strong>问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？</strong></h3><details><br><br>&emsp;&emsp;ArrayList底层通过数组来存放元素，但因为实现了自动扩容所以也叫作动态数组。扩容、插入和删除操作都通过grow函数调用数组浅复制库函数（System.arraycopy），其中扩容通过复制生成副本返回一个新的数组，非尾部插入和删除则是对当前数组进行覆盖式的复制，删除操作最后会移除末尾元素。<br><br>&emsp;&emsp;对于ArrayList，删除元素时，后续元素会前移，所以如果遍历方向是正向，会漏掉删除操作后一位的元素判断，如果使用for-each循环遍历会因为修改了操作数而直接抛出异常。<br><br>&emsp;&emsp;对于LinkedList，删除元素时会先后断开要元素和前后节点的链接，然后重新链接前后节点，根据情况更新链表首尾节点，并清空元素值。<br><br></details><h3 id="问：ArrayList和LinkedList区别？链表和数组的优缺点？"><a href="#问：ArrayList和LinkedList区别？链表和数组的优缺点？" class="headerlink" title="问：ArrayList和LinkedList区别？链表和数组的优缺点？"></a><strong>问：ArrayList和LinkedList区别？链表和数组的优缺点？</strong></h3><details><br><br>&emsp;&emsp;答：ArrayList是动态索引数组，LinkedList则是有序链表。前者可以快速随机访问，后者则会较慢。但链表更方便删除，因为只要局部变动，而数组则会影响到后续所有元素。所以数组易查难改，链表易改难查。LinkedList也通过迭代器进行插入操作。<br><br></details><hr><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h2><h3 id="问：能讲讲HashMap的实现原理吗？hashmap的底层是什么？HashMap内部数据结构？HashMap如何存值？解决hash冲突的方法有哪些？"><a href="#问：能讲讲HashMap的实现原理吗？hashmap的底层是什么？HashMap内部数据结构？HashMap如何存值？解决hash冲突的方法有哪些？" class="headerlink" title="问：能讲讲HashMap的实现原理吗？hashmap的底层是什么？HashMap内部数据结构？HashMap如何存值？解决hash冲突的方法有哪些？"></a><strong>问：能讲讲HashMap的实现原理吗？hashmap的底层是什么？HashMap内部数据结构？HashMap如何存值？解决hash冲突的方法有哪些？</strong></h3><details><br><br>&emsp;&emsp;HashMap是通过散列函数把元素均匀的分散到不同的散列值上，也就是对应的数组下标上。底层实现就是数组+链表，因为散列是不可靠的，会出现哈希冲突，所以采用链表来存放因为哈希冲突而产生的相同哈希值但不同的元素。<br><br>&emsp;&emsp;HashMap通过计算元素的哈希码，来决定其在集合中的存放位置。解决哈希冲突的方法有两种：开放定址法和链地址法（拉链法）。开发地址法会在发生哈希碰撞时通过探测技术继续在哈希表中找到空闲位置来存放，根据探测方式的不同有线性探测、二次探测和双散列探测。链地址法就是将每个散列表元素都对应一个链表。<br><br></details><h3 id="问：hashmap查询的时间复杂度能达到O-1-是什么实现的？里面的索引是怎么计算的？"><a href="#问：hashmap查询的时间复杂度能达到O-1-是什么实现的？里面的索引是怎么计算的？" class="headerlink" title="问：hashmap查询的时间复杂度能达到O(1)是什么实现的？里面的索引是怎么计算的？"></a><strong>问：hashmap查询的时间复杂度能达到O(1)是什么实现的？里面的索引是怎么计算的？</strong></h3><details><br><br>&emsp;&emsp;HashMap查询时根据哈希映射计算得到哈希码，直接走数组索引找到对应链表，不考虑哈希冲突的情况，可以达到O(1)。<br><br>&emsp;&emsp;索引通过调用对象的hashcode方法获取原始哈希码，然后右移16位使高区16位和低区16位进行异或运算，保留原高区16位，因为高区16位基本用不到，这样融合高区和低区的特征。在计算数组索引时再通过(n - 1) &amp; hash来得到相应下标。<br><br></details><h3 id="问：HashMap什么时候会进行rehash？"><a href="#问：HashMap什么时候会进行rehash？" class="headerlink" title="问：HashMap什么时候会进行rehash？"></a><strong>问：HashMap什么时候会进行rehash？</strong></h3><details><br><br>&emsp;&emsp;当所存键值对超过阈值，即容量和装填因子的积时，HashMap需要扩容并因为容量的变更而对元素进行再散列。<br><br></details><h3 id="问：HashMap的初始容量设置成多少比较合适呢？"><a href="#问：HashMap的初始容量设置成多少比较合适呢？" class="headerlink" title="问：HashMap的初始容量设置成多少比较合适呢？"></a><strong>问：HashMap的初始容量设置成多少比较合适呢？</strong></h3><details><br><br>&emsp;&emsp;一般设置为预测元素数的75%到150%，因为一般装填因子为0.75，扩容和再散列会比较影响哈希表性能，所以要尽量保证不会发生多次再散列。<br><br></details><h3 id="问：HashMap多线程有什么问题？怎么解决？"><a href="#问：HashMap多线程有什么问题？怎么解决？" class="headerlink" title="问：HashMap多线程有什么问题？怎么解决？"></a><strong>问：HashMap多线程有什么问题？怎么解决？</strong></h3><details><br><br>&emsp;&emsp;在Java 8之前的版本，HashMap底层实现是数组+链表，在put元素时会检查此时容量是否超过阈值，若不足则会扩大为之前2倍，当多线程同时操作时可能会导致形成循环链表，从而在get元素时无限循环。也可能会因为多个线程得到相同的哈希码去放置时发生覆盖，导致元素丢失。<br><br>&emsp;&emsp;用JDK提供的ConcurrentHashMap替代HashMap即可。虽然Hashtable有加锁，但synchronized会大大降低效率，而ConcurrentHashMap使用了分段锁技术，效率会更高。当然单线程的HashMap的效率更高，能使用就尽量使用。多线程环境下，也可以运用栈封闭、ThreadLocal类、UnmodifiableMap类等方式使用HashMap。<br><br></details><h3 id="问：结合源码说说HashMap在高并发场景中为什么会出现死循环？"><a href="#问：结合源码说说HashMap在高并发场景中为什么会出现死循环？" class="headerlink" title="问：结合源码说说HashMap在高并发场景中为什么会出现死循环？"></a><strong>问：结合源码说说HashMap在高并发场景中为什么会出现死循环？</strong></h3><details><br><br>&emsp;&emsp;高并发场景中多线程间会发生竞争，HashMap在put时会因为容量不足而进行扩容，旧版本新增元素是头插法，新元素会插在前面链接老元素，而在扩容后新数组链表会倒置，多线程环境下，线程间竞争一个线程读取数据后挂起，另一个线程执行使链表倒置，线程恢复后继续执行形成循环链表，所以形成了死循环。<br><br></details><h3 id="问：HashMap和HashTable有何不同？"><a href="#问：HashMap和HashTable有何不同？" class="headerlink" title="问：HashMap和HashTable有何不同？"></a><strong>问：HashMap和HashTable有何不同？</strong></h3><details><br><br>&emsp;&emsp;Hashtable对部分方法有线程安全优化，而HashMap非线程安全。HashMap的键值允许为空，Hashtable则都不能为空。Hashtable因为使用synchronized效率不高，而HashMap在单线程环境下效率很高。<br><br></details><h3 id="问：HashMap-和-WeakHashMap-的区别？"><a href="#问：HashMap-和-WeakHashMap-的区别？" class="headerlink" title="问：HashMap 和 WeakHashMap 的区别？"></a><strong>问：HashMap 和 WeakHashMap 的区别？</strong></h3><details><br><br>&emsp;&emsp;WeakHashMap通过弱引用来保存键，如果没有普通对象引用只剩弱引用在使用对象（忽略映射中value对对象的强引用），GC会在周期性的垃圾回收中收回这些无用对象。当只剩弱引用在使用对象时WeakHashMap就相当于退化为了HashMap。<br><br></details><h3 id="问：HashMap-和-ConcurrentHashMap-的区别？"><a href="#问：HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="问：HashMap 和 ConcurrentHashMap 的区别？"></a><strong>问：HashMap 和 ConcurrentHashMap 的区别？</strong></h3><details><br><br>&emsp;&emsp;ConcurrentHashMap线程安全，HashMap非线程安全。ConcurrentHashMap插入前判断是否需要扩容，HashMap则是插入元素后。<br><br></details><h3 id="问：jdk1-8中，对HashMap和ConcurrentHashMap做了哪些优化？"><a href="#问：jdk1-8中，对HashMap和ConcurrentHashMap做了哪些优化？" class="headerlink" title="问：jdk1.8中，对HashMap和ConcurrentHashMap做了哪些优化？"></a><strong>问：jdk1.8中，对HashMap和ConcurrentHashMap做了哪些优化？</strong></h3><details><br><br>&emsp;&emsp;HashMap优化了高位运算；引入了红黑树来处理链表太长的极端情况；头插法变为尾插法，链表顺序不会改变，从而优化了多线程的死循环问题。<br><br>&emsp;&emsp;ConcurrentHashMap做了哪些优化，舍弃了臃肿的Segment + HashEntry，改为Node + CAS + Synchronized；引入了红黑树来处理链表太长的极端情况等<br><br></details><h3 id="问：ConcurrentHashMap怎么实现线程安全的？"><a href="#问：ConcurrentHashMap怎么实现线程安全的？" class="headerlink" title="问：ConcurrentHashMap怎么实现线程安全的？"></a><strong>问：ConcurrentHashMap怎么实现线程安全的？</strong></h3><details><br><br>&emsp;&emsp;ConcurrentHashMap通过将数据分割，对每块数据添加一块分段锁，这样对一段数据的操作不会影响到另一段数据的操作。<br><br>&emsp;&emsp;在读操作时，用volatile修饰数据，保证了多线程的可见性，Java内存模型的happen-before原则保证了有happen-before关系的操作即使在多线程也可见，所以读操作时不需要加锁即能保证线程安全。<br><br>&emsp;&emsp;在写操作时，会对共享变量加锁，写操作的过程为定位分段，判断分段中的数组是否需要扩容，定位到添加元素的位置并插入元素。<br><br></details><h3 id="问：ConcurrentHashMap分段锁？"><a href="#问：ConcurrentHashMap分段锁？" class="headerlink" title="问：ConcurrentHashMap分段锁？"></a><strong>问：ConcurrentHashMap分段锁？</strong></h3><details><br><br>&emsp;&emsp;当对ConcurrentHashMap的节点链表进行写操作时，会获得对应节点的私有锁，这样写操作的线程不会影响到其他操作或其他节点链表的操作。<br><br></details><h3 id="问：ConcurrentHashMap如何进行散列？"><a href="#问：ConcurrentHashMap如何进行散列？" class="headerlink" title="问：ConcurrentHashMap如何进行散列？"></a><strong>问：ConcurrentHashMap如何进行散列？</strong></h3><details><br><br>&emsp;&emsp;ConcurrentHashMap会先在Segment分段时对获得的hashcode进行一次再散列，保证元素能均匀的分布在不同分段上，此阶段定位为(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask。再确定分段后，还会再一次散列，分配到不同的HashEntry中，此阶段定位为 hash &amp; (tab.length - 1)。两次散列方式不同，这样可以避免一次散列后得到的值过于雷同，导致第二次散列时聚集。<br><br></details><h3 id="问：ConcurrentHashMap和LinkedHashMap有什么区别？"><a href="#问：ConcurrentHashMap和LinkedHashMap有什么区别？" class="headerlink" title="问：ConcurrentHashMap和LinkedHashMap有什么区别？"></a><strong>问：ConcurrentHashMap和LinkedHashMap有什么区别？</strong></h3><details><br><br>&emsp;&emsp;LinkedHashMap的节点链表是双向，ConcurrentHashMap则是单向，未完待续<br><br></details><h3 id="问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？"><a href="#问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？" class="headerlink" title="问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？"></a><strong>问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？</strong></h3><details><br><br>&emsp;&emsp;红黑树的占用空间是普通链表的两倍，如果哈希表的离散性足够好，各个节点的分布应该很均衡，所以很难会出现某个节点链表聚集的情况，但离散性较差时，就可能出现某个节点频繁哈希碰撞，所以根据概率统计得出随机哈希案例中桶达到8的概率很小仅为0.00000006，置换为红黑树就是为了防止糟糕的设计，使哈希表失去其效率，不如直接替换为红黑树来提升性能。<br><br></details><h3 id="问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？"><a href="#问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？" class="headerlink" title="问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？"></a><strong>问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：LinkedHashMap用过吗？存进集合如何比较大小保证顺序？"><a href="#问：LinkedHashMap用过吗？存进集合如何比较大小保证顺序？" class="headerlink" title="问：LinkedHashMap用过吗？存进集合如何比较大小保证顺序？"></a><strong>问：LinkedHashMap用过吗？存进集合如何比较大小保证顺序？</strong></h3><details><br><br>&emsp;&emsp;答：用过，LinkedHashMap会在每次访问元素后把元素放置到节点链表的尾部，也就记录了链表的访问顺序，可以用来实现LRU。<br><br>&emsp;&emsp;重写removeEldestEntry方法，使其判断当此时链表达到限制地阈值大小时，返回true，这样put方法被调用时会自动删除最老元素即此时链表的首节点。<br><br></details><h3 id="问：讲讲TreeMap？"><a href="#问：讲讲TreeMap？" class="headerlink" title="问：讲讲TreeMap？"></a><strong>问：讲讲TreeMap？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TreeMap查询写入的时间复杂度多少？"><a href="#问：TreeMap查询写入的时间复杂度多少？" class="headerlink" title="问：TreeMap查询写入的时间复杂度多少？"></a><strong>问：TreeMap查询写入的时间复杂度多少？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java集合相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Java基础</title>
    <link href="http://linyishui.top/2019102002.html"/>
    <id>http://linyishui.top/2019102002.html</id>
    <published>2019-10-20T08:05:59.000Z</published>
    <updated>2019-12-13T07:51:34.677Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="问：java的基本类型有哪几个？各自占了多少位？"><a href="#问：java的基本类型有哪几个？各自占了多少位？" class="headerlink" title="问：java的基本类型有哪几个？各自占了多少位？"></a><strong>问：java的基本类型有哪几个？各自占了多少位？</strong></h3><details><br><br>&emsp;&emsp;答：8个：byte，short，int，long，float，double，boolean，char<br><br>&emsp;&emsp;byte是8位，short是16位，int是32位，long是64位，float是32位（单精度），double是64位（双精度），boolean是1位，char则是16位Unicode字符<br><br></details><h3 id="问：货币用哪种数据类型？"><a href="#问：货币用哪种数据类型？" class="headerlink" title="问：货币用哪种数据类型？"></a><strong>问：货币用哪种数据类型？</strong></h3><details><br><br>&emsp;&emsp;答：BigDecimal，因为浮点数表示近似值，而BigDecimal则可以表示精确的浮点数。<br><br></details><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><h3 id="问：String是不是java的基本类型？"><a href="#问：String是不是java的基本类型？" class="headerlink" title="问：String是不是java的基本类型？"></a><strong>问：String是不是java的基本类型？</strong></h3><details><br><br>&emsp;&emsp;答：不是，String是引用类型，虽然有常量的一些特性。<br><br></details><h3 id="问：String为什么要是final类型的？"><a href="#问：String为什么要是final类型的？" class="headerlink" title="问：String为什么要是final类型的？"></a><strong>问：String为什么要是final类型的？</strong></h3><details><br><br>&emsp;&emsp;答：要保证字符串的不可变性，而字符串常量池的设计采用享元模式，需要字符串的不可变性。假如字符串可变，共享元素在一处被改变，所有使用者都会感知到变化。如果字符串可变性会使软件安全性降低，不可变就意味着不会被篡改，同样也意味着线程安全。<br><br></details><hr><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：面向对象的三大特性-分别是怎么使用的，给个例子"><a href="#问：面向对象的三大特性-分别是怎么使用的，给个例子" class="headerlink" title="问：面向对象的三大特性?分别是怎么使用的，给个例子?"></a><strong>问：面向对象的三大特性?分别是怎么使用的，给个例子?</strong></h3><details><br><br>&emsp;&emsp;答：封装，继承和多态。<br><br>&emsp;&emsp;比如类把属性和行为封装起来，只提供公共方法被外界访问。<br><br>&emsp;&emsp;比如父子类间的继承关系，子类继承父类的属性方法。<br><br>&emsp;&emsp;比如子类通过继承并重写父类方法，同样的方法会有不同的实现。<br><br></details><h3 id="问：讲一下重载和重写"><a href="#问：讲一下重载和重写" class="headerlink" title="问：讲一下重载和重写?"></a><strong>问：讲一下重载和重写?</strong></h3><details><br><br>&emsp;&emsp;答：重载是：同一类中，用相同的方法名，但参数个数或数据类型不同，返回值、访问修饰和抛出异常可以相同也可以不同，<br><br>&emsp;&emsp;重写则是：不同类中，子类继承父类方法，有相同的方法描述，但会受限于父类的访问修饰类型，且子类的访问修饰要更大。<br><br></details><h3 id="问：谈下hashcode和equals的用法及区别？为什么重写equals方法时还要重写hashcode方法？"><a href="#问：谈下hashcode和equals的用法及区别？为什么重写equals方法时还要重写hashcode方法？" class="headerlink" title="问：谈下hashcode和equals的用法及区别？为什么重写equals方法时还要重写hashcode方法？"></a><strong>问：谈下hashcode和equals的用法及区别？为什么重写equals方法时还要重写hashcode方法？</strong></h3><details><br><br>&emsp;&emsp;hashcode方法用于创建散列表时获取对象的哈希码值，equals则用于对象的等值判断。<br><br>&emsp;&emsp;equals相等则hashcode必定相等，hashcode相等equals未必相等。前者是散列表取值时需要先判断hashcode（hashcode比较效率较高），所以只有hashcode相等才能取到正确的值。哈希值相等的两个对象未必是相等的（哈希冲突），因为哈希码并不是百分百可靠。<br><br>&emsp;&emsp;重写equals方法时还要重写hashcode方法是因为，重写equals后很可能导致equals相等时hashcode却不相同，会在许多散列表的使用场景下出错（Set或HashMap取值），所以重写equals时也要重写hashcode。<br><br>&emsp;&emsp;<a href="../2018123101.html" title="Title">equals和hashCode异同</a><br><br></details><h3 id="问：说下如何操控文件-（输入输出）怎么关闭呢-发生异常怎么办"><a href="#问：说下如何操控文件-（输入输出）怎么关闭呢-发生异常怎么办" class="headerlink" title="问：说下如何操控文件?（输入输出）怎么关闭呢? 发生异常怎么办?"></a><strong>问：说下如何操控文件?（输入输出）怎么关闭呢? 发生异常怎么办?</strong></h3><details><br><br>&emsp;&emsp;答：通过I/O流来对文件进行操作，为了确保流的关闭会在finally语句块中进行close，Java 7后增加了带资源的try语句，try块退出后会自动关闭资源。这样即使发生异常，也能确保不会因为流未关闭而造成内存泄漏或一直占用文件的情况。<br><br></details><h3 id="问：讲讲序列化？"><a href="#问：讲讲序列化？" class="headerlink" title="问：讲讲序列化？"></a><strong>问：讲讲序列化？</strong></h3><details><br><br>&emsp;&emsp;Java通过序列化把对象写入和读出流，也就是转为字节序列，方便在网络中传输或者传递对象。Java序列化基于两个接口：Serializable和Externalizable，Serializable接口有默认序列化机制。序列化也可以用来实现深拷贝。<br><br>&emsp;&emsp;<a href="../2019032101.html" title="Title">对象流和序列化</a><br><br></details><h3 id="问：深拷贝与浅拷贝？"><a href="#问：深拷贝与浅拷贝？" class="headerlink" title="问：深拷贝与浅拷贝？"></a><strong>问：深拷贝与浅拷贝？</strong></h3><details><br><br>&emsp;&emsp;深拷贝和浅拷贝主要区别在是否支持引用类型的拷贝，浅拷贝对于可变对象无法保证数据安全，深拷贝会把对象里面嵌套对象这种结构完整的拷贝下来。<br><br>&emsp;&emsp;<a href="../2018083001.html" title="Title">Java对象克隆</a><br><br></details><h3 id="问：java8有了解吗？"><a href="#问：java8有了解吗？" class="headerlink" title="问：java8有了解吗？"></a><strong>问：java8有了解吗？</strong></h3><details><br><br>&emsp;&emsp;有了解，Lambda表达式，函数式编程，流这些都有用过。<br><br>&emsp;&emsp;<a href="../2019091901.html" title="Title">Java8的新特性</a><br><br></details><h3 id="问：讲讲Lambda表达式？使用场景？优点？"><a href="#问：讲讲Lambda表达式？使用场景？优点？" class="headerlink" title="问：讲讲Lambda表达式？使用场景？优点？"></a><strong>问：讲讲Lambda表达式？使用场景？优点？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈流？和集合对比？"><a href="#问：谈谈流？和集合对比？" class="headerlink" title="问：谈谈流？和集合对比？"></a><strong>问：谈谈流？和集合对比？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java基础相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面经整理——导航页</title>
    <link href="http://linyishui.top/2019102001.html"/>
    <id>http://linyishui.top/2019102001.html</id>
    <published>2019-10-20T07:53:31.000Z</published>
    <updated>2019-12-12T10:52:02.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;答案基本上是博主自答，受限于当前知识水平和闲暇时间，如果有错误或纰漏请包涵。</p><h1 id="Java面试题目"><a href="#Java面试题目" class="headerlink" title="Java面试题目"></a><strong>Java面试题目</strong></h1><h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a><strong>Java语言</strong></h2><p>&emsp;&emsp;<a href="../2019102002.html" title="Title">面试整理——Java基础</a></p><p>&emsp;&emsp;<a href="../2019102101.html" title="Title">面试整理——Java集合</a></p><p>&emsp;&emsp;<a href="../2019102201.html" title="Title">面试整理——Java并发编程</a></p><p>&emsp;&emsp;<a href="../2019102301.html" title="Title">面试整理——Java网络编程</a></p><p>&emsp;&emsp;<a href="../2019102401.html" title="Title">面试整理——JVM</a></p><hr><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h2><p>&emsp;&emsp;<a href="../2019102501.html" title="Title">面试整理——算法</a></p><hr><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h2><p>&emsp;&emsp;<a href="../2019102601.html" title="Title">面试整理——网络</a></p><hr><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><strong>操作系统</strong></h2><p>&emsp;&emsp;<a href="../2019102701.html" title="Title">面试整理——操作系统</a></p><hr><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>&emsp;&emsp;<a href="../2019102801.html" title="Title">面试整理——分布式</a></p><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><p>&emsp;&emsp;<a href="../2019102901.html" title="Title">面试整理——数据库</a></p><hr><h2 id="Java框架"><a href="#Java框架" class="headerlink" title="Java框架"></a><strong>Java框架</strong></h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h3><p>&emsp;&emsp;<a href="../2019110101.html" title="Title">面试整理——Spring</a></p><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a><strong>Spring Boot</strong></h3><p>&emsp;&emsp;未完待续</p><h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a><strong>Spring Cloud</strong></h3><p>&emsp;&emsp;未完待续</p><!--Hashmap源码级掌握，扩容，红黑树，最小树化容量，hash 冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么 8 的时候树化，4 不可以吗，等等concureentHashMap，段锁，如何分段，和 hashmap 在 hash 上的区别，性能，等等HashTable，同步锁，这块可能会问你 synchronized 关键字 1.6 之后提升了什么，怎么提升的这些ArrayList 优势，扩容，什么时候用LinkedList 优势，什么时候用，和 arraylist 的区别 等等基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理String，StringBuffer，StringBuilder哪个是安全的字符串编码的区别，被问到过，我觉得比较容易被忽视的一个点什么是泛型，怎么用泛型static 能不能修饰 threadLocal，为什么，这道题我当时一听到其实挺懵逼的Comparable 和 Comparator 接口是干什么的，其区别多态的原理是什么，感觉这个很容易被问到接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板~ 然后又交流了一下各自的想法如何通过反射和设置对象私有字段的值快速失败(fail-fast)和安全失败(fail-safe)的区别是什么synchronized 的实现原理以及锁优化？volatile 的实现原理？Java 的信号灯？synchronized 在静态方法和普通方法的区别？怎么实现所有线程在等待某个事件的发生才会去执行？CAS ？ CAS 有什么缺陷，如何解决？synchronized 和 lock 有什么区别？Hashtable 是怎么加锁的 ？List，Map，Set 接口在取元素师，各有什么特点如何线程安全的实现一个计数器生产者消费者模式，要求手写过代码，还是要知道的单例模式，饿汉式，懒汉式，线程安全的做法，两次判断 instance 是否为空，每次判断的作用是什么。线程池，这个还是很重要的，在生产中用的挺多，四个线程池类型，其参数，参数的理解很重要，corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的，和美团面试官探讨过阻塞队列在生产中的设置，他说他一般设置为 0，防止用户阻塞cyclicbarrier 和 countdownlatch 的区别，个人理解 赛马和点火箭线程回调，这块 被问过让我设计一个 RPC，怎么实现，其实用到了回调这块的东西sleep 和 yeild 方法有什么区别volatile 关键字，可见性。乐观锁和悲观锁的使用场景悲观锁的常见实现方式：lock synchronized retreentlock乐观锁：CAS MVCC读写锁的实现方式，16 位 int 的前八位和后八位分别作为读锁和写锁的标志位死锁的条件，怎么解除死锁，怎么观测死锁。希望大家能够好好看一下反射的原理，怎么确定类，怎么调方法RPC 框架，同步异步，响应时间，这些都被问到过，还让设计过同步，异步，阻塞，非阻塞 在深信服的面试中遇到过，最好再找一些应用场景加以理解下面这些开个胃先## JAVA 基础1. HashMap 的源码，实现原理； JDK8 做了什么优化2. HashMap 扩容机制，为什么都是 2 的 N 次幂3. ArrayList 和 Vector 的区别，扩容机制等4. CopyOnWriteArrayList 原理5. HashSet 和 TreeSet 原理6. ArrayBlockingQueue 和 LinkedBlockingQueue 区别7. 集合迭代器的原理8. 传值和传引用的区别9. 动态代理10. JDK8 ConcurrentHashMap 的原理## 多线程1. 创建多线程的方式，以及线程的状态转换2. 线程的中断机制3. ThreadPoolExecutor 初始化参数； Executors 静态方法4. synchronized 的使用方式及原理5. 偏向锁、轻量级锁、自旋锁等优化6. ReentrantLock 的特点及 AQS 原理7. Semaphore、CountDownLatch、CyclicBarrier 等使用8. ThreadLocal 的原理、与 Thread 类的关系、以及内存泄漏问题9. volatile 的原理及内存屏障相关10. Lock 接口有哪些实现类，使用场景是什么11. 悲观锁，乐观锁，优缺点，CAS 有什么缺陷，该如何解决12. ABC 三个线程如何保证顺序执行13. 生产者消费者模式的实现方式14. 如何实现控制线程在某段时间内完成，不完成就撤销## JVM1. JVM 的内存区域2. 字符串常量池相关3. 对象的内存布局，涉及到锁的部分4. 类加载的过程，以及双亲委派机制、自定义类加载器5. GC 常见算法，CMS 以及 G1 的垃圾回收过程，CMS 的各个阶段哪两个是 Stop the world 的，CMS 会不会产生碎片，G1 的优势6. 标记清除、复制和标记整理算法的理解以及优缺点7. eden survivor 区的比例，为什么是这个比例，eden survivor 的工作过程8. JVM 如何判断一个对象是否该被 GC，可以视为 root 的都有哪几种类型9. 强软弱虚引用的区别以及 GC 对他们执行怎样的操作10. Java 是否可以 GC 直接内存11. 常用的 JVM 调优参数12. GC 优化的步骤13. 当出现了内存泄漏或内存溢出，怎么排错14. CMS 和 G1 收集过程## 数据库相关1. 常见的数据库优化手段2. 索引的优缺点，以及索引选择3. B+树索引的原理4. 数据库连接池5. MySQL 的锁机制6. MVCC 和 ReadView7. InnoDB 的一些特性8. 数据库三范式## 计算机网络、操作系统1. TCP，UDP 区别2. 三次握手，四次挥手，为什么要四次挥手3. 长连接和短连接，连接池适合长连接还是短连接4. OSI 七层模型5. 用户态和内核态## 数据结构和算法1. 红黑树、AVL 树2. B 树、B+树3. 排序算法4. 一致性 Hash 算法，一致性 Hash 算法的应用5. TopK 问题6. 判断链表是否有环## 缓存相关1. redis 支持的数据类型及使用场景2. redis 单线程为什么还那么快3. redis 如何存储一个 String 的4. redis 的过期策略5. redis 的部署方式，主从，集群6. redis 的哨兵模式，一个 key 值如何在 redis 集群中找到存储在哪7. redis 持久化策略8. 缓存穿透、缓存击穿、缓存雪崩问题及解决方法9. 缓存和数据库一致性问题## 框架相关1. Spring 的常用注解及作用2. Spring Bean 的生命周期3. Spring 怎么解决单例 Bean 的循环依赖问题4. Spring 对于 IOC 的扩展点有哪些5. Spring AOP 的原理，及代理对象调用过程（责任链+递归调用）6. Spring 的事务机制，及执行流程7. Spring 使用了哪些设计模式8. Mybatis 基于接口完成查询的过程及原理9. Mybatis 的一级缓存和二级缓存10. Quartz 是如何完成定时任务的；集群同步机制## 分布式相关1. 分布式事务的控制2. 分布式锁如何设计3. 分布式 session 如何设计4. dubbo 的组件有哪些，及其作用5. dubbo SPI 机制；远程接口调用过程6. dubbo 支持的协议及序列化方式7. dubbo 的负载均衡和容错策略8. zookeeper 的 ZAB 协议工作原理9. zookeeper 的 Watcher 机制10. zookeeper 的 Watcher 机制11. zookeeper 的数据存储12. zookeeper 的负载均衡算法13. rocketmq 的模块功能14. rocketmq 的高可用及高性能15. elasticsearch 的系统架构及读写过程16. elasticsearch 在数据量很大的情况下（数十亿级别）如何提高查询效率啊17. eureka 的相关原理，和 zookeeper 的比较--><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      通过在各个平台收集面试相关问题，再进行分类、整理和收集，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="others" scheme="http://linyishui.top/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>Docker（五）应用的容器化</title>
    <link href="http://linyishui.top/2019101301.html"/>
    <id>http://linyishui.top/2019101301.html</id>
    <published>2019-10-13T08:40:00.000Z</published>
    <updated>2019-12-12T07:39:11.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker（五）应用的容器化"><a href="#Docker（五）应用的容器化" class="headerlink" title="Docker（五）应用的容器化"></a><strong>Docker（五）应用的容器化</strong></h1><h2 id="第一节-应用的容器化"><a href="#第一节-应用的容器化" class="headerlink" title="第一节 应用的容器化"></a><strong>第一节 应用的容器化</strong></h2><p>&emsp;&emsp;Docker的核心思想就是如何将应用整合到容器中，并且能在容器中实际运行。将应用整合到容器中并且运行起来的这个过程，称为“容器化”（Containerizing），有时也叫作“Docker化”（Dockerizing）。</p><p>&emsp;&emsp;本节将逐步介绍容器化一个简单的Linux Web应用的过程。如果没有一个Linux的Docker环境来跟进练习，那么可以免费使用Play With Docker。只需使用浏览器打开Play With Docker的页面，并启动若干Linux Docker节点即可。</p><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>&emsp;&emsp;容器是为应用而生！具体来说，<strong>容器能够简化应用的构建、部署和运行过程</strong>。</p><blockquote><p>完整的应用容器化过程主要分为以下几个步骤。</p><ol><li>编写应用代码。</li><li>创建一个Dockerfile，其中包括当前应用的描述、依赖以及该如何运行这个应用。</li><li>对该Dockerfile执行docker image build命令。</li><li>等待Docker将应用程序构建到Docker镜像中。</li></ol></blockquote><p>&emsp;&emsp;一旦应用容器化完成（即应用被打包为一个Docker镜像），就能以镜像的形式交付并以容器的方式运行了。图8.1展示了上述步骤。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010128.png" alt="容器化的基本过程"></p><hr><h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a><strong>1.2 详解</strong></h3><h4 id="1-2-1-单体应用容器化"><a href="#1-2-1-单体应用容器化" class="headerlink" title="1.2.1 单体应用容器化"></a><strong>1.2.1 单体应用容器化</strong></h4><p>&emsp;&emsp;接下来逐步展示如何将一个简单的单节点Node.js Web应用容器化。本部分主要完成单节点应用的容器化，采用Docker Compose去完成多节点应用容器化，使用Docker Stack去处理更复杂应用的容器化场景。接下来通过以下几个步骤，来介绍具体的过程。</p><h5 id="（1）获取应用代码"><a href="#（1）获取应用代码" class="headerlink" title="（1）获取应用代码"></a><strong>（1）获取应用代码</strong></h5><p>&emsp;&emsp;应用代码可以从作者的GitHub主页获取，将代码克隆到本地，创建一个名为psweb的文件夹。（本人直接用PC端DFW克隆到本地，后续环境即Windows 10）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">https</span>://github.com/nigelpoulton/psweb.git</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;跳转项目根目录，查看项目文件结构。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd psweb</span><br><span class="line"></span><br><span class="line">$ ls -l </span><br><span class="line">total<span class="number"> 28 </span></span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 341 </span>Sep<span class="number"> 29 </span>16:26 app.js </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 216 </span>Sep<span class="number"> 29 </span>16:26 circle.yml </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 338 </span>Sep<span class="number"> 29 </span>16:26 Dockerfile </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 421 </span>Sep<span class="number"> 29 </span>16:26 package.json </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 370 </span>Sep<span class="number"> 29 </span>16:26 README.md </span><br><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>16:26 test/</span><br><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>16:26 views/</span><br></pre></td></tr></table></figure><h5 id="（2）分析Dockerfile"><a href="#（2）分析Dockerfile" class="headerlink" title="（2）分析Dockerfile"></a><strong>（2）分析Dockerfile</strong></h5><p>&emsp;&emsp;在代码目录当中，有个名称为Dockerfile的文件。这个文件包含了对当前应用的描述，并且能指导Docker完成镜像的构建。<br>在Docker当中，包含应用文件的目录通常被称为构建上下文（Build Context）。通常将Dockerfile放到构建上下文的根目录下。</p><p>&emsp;&emsp;另外很重要的一点是，文件开头字母是大写D，这里是一个单词。 像“dockerfile”或者“Docker file”这种写法都是不允许的。</p><p>&emsp;&emsp;接下来了解一下Dockerfile文件当中都包含哪些具体内容。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test web-app to use with Pluralsight courses and Docker Deep Dive book</span></span><br><span class="line"><span class="comment"># Linux x64</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"nigelpoulton@hotmail.com"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install Node and NPM</span></span></span><br><span class="line"><span class="bash">RUN apk add --update nodejs nodejs-npm</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Copy app to /src</span></span></span><br><span class="line"><span class="bash">COPY . /src</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /src</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install dependencies</span></span></span><br><span class="line"><span class="bash">RUN  npm install</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"./app.js"</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>Dockerfile主要包括两个用途：</p><ul><li>对当前应用的描述。 </li><li>指导Docker完成应用的容器化（创建一个包含当前应用的镜像）。</li></ul></blockquote><p>&emsp;&emsp;Dockerfile能实现开发和部署两个过程的无缝切换。同时Dockerfile还能帮助新手快速熟悉这个项目。Dockerfile对当前的应用及其依赖有一个清晰准确的描述，并且非常容易阅读和理解。因此，要像重视你的代码一样重视这个文件，并且将它纳入到源控制系统当中。</p><p>&emsp;&emsp;下面是这个文件中的一些关键步骤概述：以alpine镜像作为当前镜像基础，指定维护者（maintainer）为“<a href="mailto:nigelpoultion@hotmail.com" target="_blank" rel="noopener">nigelpoultion@hotmail.com</a>”，安装Node.js和NPM，将应用的代码复制到镜像当中，设置新的工作目录，安装依赖包，记录应用的网络端口，最后将app.js设置为默认运行的应用。</p><p>&emsp;&emsp;具体分析一下每一步的作用：每个Dockerfile文件第一行都是FROM指令。FROM指令指定的镜像，会作为当前镜像的一个基础镜像层，当前应用的剩余内容会作为新增镜像层添加到基础镜像层之上。本例中的应用基于Linux操作系统，所以在FROM指令当中所引用的也是一个Linux基础镜像；如果要容器化的应用是一个基于Windows操作系统的应用，就需要指定一个像microsoft/aspnetcore-build这样的Windows基础镜像了。当前基础镜像的结构如图8.2所示</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010129.png" alt="基础镜像的结构"></p><p>&emsp;&emsp;接下来，Dockerfile中通过标签（LABLE）方式指定了当前镜像的维护者为“<a href="mailto:nigelpoulton@hotmail.com" target="_blank" rel="noopener">nigelpoulton@hotmail.com</a>”。每个标签其实是一个键值对（Key-Value），在一个镜像当中可以通过增加标签的方式来为镜像添加自定义元数据。备注维护者信息有助于为该镜像的潜在使用者提供沟通途径，这是一种值得提倡的做法。</p><p>&emsp;&emsp;RUN apk add –update nodejs nodejs-npm指令使用alpine的apk包管理器将nodejs和nodejs-npm安装到当前镜像之中。RUN指令会在FROM指定的alpine基础镜像之上，新建一个镜像层来存储这些安装内容。当前镜像的结构如图8.3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010130.png" alt="当前镜像的结构"></p><p>&emsp;&emsp;COPY. / src指令将应用相关文件从构建上下文复制到了当前镜像中，并且新建一个镜像层来存储。COPY执行结束之后，当前镜像共包含3层，如图8.4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010131.png" alt="当前的3层镜像"></p><p>&emsp;&emsp;下一步，Dockerfile通过WORKDIR指令，为Dockerfile中尚未执行的指令设置工作目录。该目录与镜像相关，并且会作为元数据记录到镜像配置中，但不会创建新的镜像层。</p><p>&emsp;&emsp;然后，RUN npm install指令会根据package.json中的配置信息，使用npm来安装当前应用的相关依赖包。npm命令会在前文设置的工作目录中执行，并且在镜像中新建镜像层来保存相应的依赖文件。目前镜像一共包含4层，如图8.5所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010132.png" alt="当前的4层镜像"></p><p>&emsp;&emsp;因为当前应用需要通过TCP端口8080对外提供一个Web服务，所以在Dockerfile中通过EXPOSE 8080指令来完成相应端口的设置。这个配置信息会作为镜像的元数据被保存下来，并不会产生新的镜像层。</p><p>&emsp;&emsp;最终，通过ENTRYPOINT指令来指定当前镜像的入口程序。ENTRYPOINT指定的配置信息也是通过镜像元数据的形式保存下来，而不是新增镜像层。</p><h5 id="（3）构建应用镜像"><a href="#（3）构建应用镜像" class="headerlink" title="（3）构建应用镜像"></a><strong>（3）构建应用镜像</strong></h5><p>&emsp;&emsp;下面的命令会构建并生成一个名为web:latest的镜像。命令最后的点（.）表示Docker在进行构建的时候，使用当前目录作为构建上下文。一定要在命令最后包含这个点，并且在执行命令前，要确认当前目录是psweb（包含Dockerfile和应用代码的目录）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image build -t web:latest .</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;命令执行结束后，检查本地Docker镜像库是否包含了刚才构建的镜像。可以通过docker image inspect web:latest来确认刚刚构 建的镜像配置是否正确。这个命令会列出Dockerfile中设置的所有配置 项。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPO    <span class="keyword">TAG</span>       <span class="title">IMAGE</span> ID          CREATED              SIZE </span><br><span class="line">web     latest    fc69fdc4c18e      <span class="number">10</span> seconds ago       <span class="number">64.4M</span>B</span><br></pre></td></tr></table></figure><h5 id="（4）推送镜像到仓库"><a href="#（4）推送镜像到仓库" class="headerlink" title="（4）推送镜像到仓库"></a><strong>（4）推送镜像到仓库</strong></h5><p>&emsp;&emsp;在创建一个镜像之后，将其保存在一个镜像仓库服务是一个不错的方式。这样存储镜像会比较安全，并且可以被其他人访问使用。Docker Hub就是这样的一个开放的公共镜像仓库服务，并且这也是docker image push命令默认的推送地址。</p><p>&emsp;&emsp;在推送镜像之前，需要先使用Docker ID登录Docker Hub（xxx表示docker id）。除此之外，还需要为待推送的镜像打上合适的标签。因为Docker在镜像推送的过程中需要如下信息：Registry（镜像仓库服务），Repository（镜像仓库），Tag（镜像标签）。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker login </span><br><span class="line">Login <span class="keyword">with</span> **your** Docker ID <span class="keyword">to</span> push <span class="keyword">and</span> pull images <span class="keyword">from</span> Docker Hub... </span><br><span class="line">Username: xxx </span><br><span class="line">Password: Login Succeeded</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Docker会默认Registry=docker.io、Tag=latest。但是 Docker并没有给Repository提供默认值，而是从被推送镜像中的REPOSITORY属性值获取。</p><p>&emsp;&emsp;执行docker image push命令，会尝试将镜像推送到docker.io/web:latest中。但是xxx用户并没有web这个镜像仓库的访问权限，所以只能尝试推送到xxx这个二级命名空间（Namespace）之下。因此需要使用xxx这个ID，为当前镜像重新打一个标签。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="keyword">tag</span> <span class="title">web</span>:latest nigelpoulton/web:latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次执行docker image ls命令，可以看到这个镜像现在有了两个标签，其中一个包含Docker ID nigelpoulton。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPO                TAG       IMAGE ID        CREATED       SIZE </span><br><span class="line">web                 latest    fc69fdc4c18e    <span class="number">10</span> secs ago   <span class="number">64.4</span>MB </span><br><span class="line">xxx/web             latest    fc69fdc4c18e    <span class="number">10</span> secs ago   <span class="number">64.4</span>MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在将该镜像推送到Docker Hub。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">image</span> <span class="built_in">push</span> xxx/web:latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;图8.6展示了Docker如何确定镜像所要推送的目的仓库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010133.png" alt="确定镜像所要推送的目的仓库"></p><h5 id="（5）运行该应用"><a href="#（5）运行该应用" class="headerlink" title="（5）运行该应用"></a><strong>（5）运行该应用</strong></h5><p>&emsp;&emsp;前文中容器化的这个应用程序其实很简单，从app.js这个文件内容中可以看出，这其实就是一个在8080端口提供Web服务的应用程序。下面的命令会基于web:latest这个镜像，启动一个名为c1的容器。该容器将内部的8080端口与Docker主机的80端口进行映射。这意味我们可以打开一个浏览器，在地址栏输入Docker主机的DNS名称或者IP地址，然后就能直接访问这个Web应用了。</p><blockquote><p>如果Docker主机已经运行了某个使用80端口的应用程序，可以在执行docker container run命令时指定一个不同的映射端口。例如，可以使用-p 5000:8000参数，将Docker内部应用程序的8080端口映射到主机的5000端口。</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">run</span><span class="bash"> -d --name c1 \  </span></span><br><span class="line"><span class="bash">  -p 80:8080 \  </span></span><br><span class="line"><span class="bash">  web:latest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来验证一下程序是否真的成功运行，并且对外提供服务的端口是否正常工作。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line">ID    IMAGE       COMMAND           STATUS      PORTS </span><br><span class="line"><span class="number">49</span>．.  web:latest  <span class="string">"node ./app.js"</span>   <span class="meta">UP</span> <span class="number">6</span> secs   <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:<span class="number">80</span>-&gt;<span class="number">8080</span>/tcp</span><br></pre></td></tr></table></figure><h5 id="（6）测试应用"><a href="#（6）测试应用" class="headerlink" title="（6）测试应用"></a><strong>（6）测试应用</strong></h5><p>&emsp;&emsp;打开浏览器，在地址栏输入DNS名称或者IP地址，就能访问到正在运行的应用程序了。</p><p>&emsp;&emsp;如果没有出现正常的界面，尝试执行下面的检查来确认原因所在。</p><blockquote><ul><li>使用docker container ls指令来确认容器已经启动并且正常运行。容器名称是c1，并且从输出内容中能看到0.0.0.0:80&gt;8080/tcp。 </li><li>确认防火墙或者其他网络安全设置没有阻止访问Docker主机的80端口。</li></ul></blockquote><h5 id="（7）容器应用化细节"><a href="#（7）容器应用化细节" class="headerlink" title="（7）容器应用化细节"></a><strong>（7）容器应用化细节</strong></h5><p>&emsp;&emsp;一些细节部分的回顾和总结。</p><p>&emsp;&emsp;Dockerfile中的注释行，都是以#开头的。除注释之外，每一行都是一条指令（Instruction）。指令的参数格式如下：INSTRUCTION argument，指令是不区分大小写的，但是通常都采用大写的方式，这样Dockerfile的可读性会高一些。</p><p>&emsp;&emsp;Docker image build命令会按行来解析Dockerfile中的指令并顺序执行。部分指令会在镜像中创建新的镜像层，其他指令只会增加或修改镜像的元数据信息。在上面的例子当中，新增镜像层的指令包括FROM、RUN以及COPY，而新增元数据的指令包括EXPOSE、WORKDIR、ENV以及ENTERPOINT。 关于如何区分命令是否会新建镜像层，一个基本的原则是，如果指令的作用是向镜像中增添新的文件或者程序，那么这条指令就会新建镜像层；如果只是告诉Docker如何完成构建或者如何运行应用程序，那么就只会增加镜像的元数据。</p><p>&emsp;&emsp;可以通过docker image history来查看在构建镜像的过程中都执行了哪些指令。</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker image history web:latest</span><br><span class="line"></span><br><span class="line">IMAGE     CREATED BY                                       SIZE </span><br><span class="line">fc6..18e  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span>  ENTRYPOINT ["node" "./a...    0B </span><br><span class="line">334．.bf0  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span>  EXPOSE 8080/tcp               0B </span><br><span class="line">b27..eae  /bin/sh -c npm install                           14.1MB </span><br><span class="line">932．.749  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span> WORKDIR /src                   0B </span><br><span class="line">052．.2dc  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span> COPY dir:2a6ed1703749e80...    22.5kB </span><br><span class="line">c1d..81f  /bin/sh -c apk add --update nodejs nodejs-npm    46.1MB </span><br><span class="line">336．.b92  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span>  LABEL maintainer=nigelp...    0B</span><br><span class="line">3fd..f02  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span>  CMD ["/bin/sh"]               0B </span><br><span class="line"> /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span> ADD file:093f0723fa46f6c...    4.15MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的输出内容当中，有两点是需要注意的。首先，每行内容都对应了Dockerfile中的一条指令（顺序是自下而上）。CREATE BY这一列中还展示了当前行具体对应Dockerfile中的哪条指令。其次，从这个输出内容中，可以观察到只有4条指令会新建镜像层 （就是那些SIZE列对应的数值不为零的指令），分别对应Dockerfile中的FROM、RUN以及COPY指令。虽然其他指令看上去跟这些新建镜像层的指令并无区别，但实际上它们只在镜像中新增了元数据信息。这些指令之所以看起来没有区别，是因为Docker对之前构建镜像层方式的兼容。</p><p>&emsp;&emsp;可以通过执行docker image inspect指令来确认确实只有4个层被创建了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect we<span class="variable">b:latest</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line">&#125;, <span class="string">"RootFS"</span>: &#123;    </span><br><span class="line">    <span class="string">"Type"</span>: <span class="string">"layers"</span>,    </span><br><span class="line">    <span class="string">"Layers"</span>: [        </span><br><span class="line">        <span class="string">"sha256:cd7100...1882bd56d263e02b6215"</span>,        </span><br><span class="line">        <span class="string">"sha256:b3f88e...cae0e290980576e24885"</span>,        </span><br><span class="line">        <span class="string">"sha256:3cfa21...cc819ef5e3246ec4fe16"</span>,        </span><br><span class="line">        <span class="string">"sha256:4408b4...d52c731ba0b205392567"</span>    </span><br><span class="line">    ] </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用FROM指令引用官方基础镜像是一个很好的习惯，官方的镜像通常会遵循一些最佳实践，并且能帮助使用者规避一些已知的问<br>题。除此之外，使用FROM的时候选择一个相对较小的镜像文件通常也能避免一些潜在的问题。</p><p>&emsp;&emsp;我们也可以观察docker image build命令具体的输出内容，了解镜像构建的过程。在下面的片段中，可以看到基本的构建过程是，运行临时容器&gt;在该容器中运行Dockerfile中的指令&gt;将指令运行结果保存为 一个新的镜像层&gt;删除临时容器。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Step <span class="number">3</span>/<span class="number">8</span> : RUN apk add --update nodejs nodejs-npm </span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e690ddca785f    &lt;&lt; Run inside of temp container </span><br><span class="line">fetch <span class="string">http:</span><span class="comment">//dl-cdn...APKINDEX.tar.gz </span></span><br><span class="line">fetch <span class="string">http:</span><span class="comment">//dl-cdn...APKINDEX.tar.gz </span></span><br><span class="line">(<span class="number">1</span>/<span class="number">10</span>) Installing ca-certificates (<span class="number">20171114</span>-r0) </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line"><span class="string">OK:</span> <span class="number">61</span> MiB <span class="keyword">in</span> <span class="number">21</span> packages ---&gt; c1d31d36b81f                &lt;&lt; Create <span class="keyword">new</span> layer </span><br><span class="line">Removing intermediate container   &lt;&lt; Remove temp container </span><br><span class="line">Step <span class="number">4</span><span class="regexp">/8 : COPY . /</span>src</span><br></pre></td></tr></table></figure><h4 id="1-2-2-生产环境中的多阶段构建"><a href="#1-2-2-生产环境中的多阶段构建" class="headerlink" title="1.2.2 生产环境中的多阶段构建"></a><strong>1.2.2 生产环境中的多阶段构建</strong></h4><p>&emsp;&emsp;对于Docker镜像来说，体积越大则越慢，就意味着更难使用，而且可能更加脆弱，更容易遭受攻击。对于生产环境镜像来说，目标是将其缩小到仅包含运行应用所必需的内容即可，但生成较小的镜像并非易事。</p><p>&emsp;&emsp;例如，不同的Dockerfile写法就会对镜像的大小产生显著影响。常见的例子是，每一个RUN指令会新增一个镜像层。因此，通过使用 &amp;&amp; 连接多个命令以及使用反斜杠（\）换行的方法，将多个命令包含在一个RUN指令中，通常来说是一种值得提倡的方式。这并不难掌握，多加练习即可。</p><p>&emsp;&emsp;另一个问题是开发者通常不会在构建完成后进行清理。当使用RUN执行一个命令时，可能会拉取一些构建工具，这些工具会留在镜像中移交至生产环境。这是不合适的！</p><p>&emsp;&emsp;有多种方式来改善这一问题——比如常见的是采用<strong>建造者模式</strong>（Builder Pattern）。但无论采用哪种方式，通常都需要额外的培训，并且会增加构建的复杂度。建造者模式需要至少两个Dockerfile——一个用于开发环境，一个用于生产环境。首先需要编写Dockerfile.dev，它基于一个大型基础镜像（Base Image），拉取所需的构建工具，并构建应用。接下来，需要基于Dockerfile.dev构建一个镜像，并用这个镜像创建一个容器。这时再编写Dockerfile.prod，它基于一个较小的基础镜像开始构建，并从刚才创建的容器中将应用程序相关的部分复制过来。整个过程需要编写额外的脚本才能串联起来。这种方式是可行的，但是比较复杂。</p><p>&emsp;&emsp;<strong>多阶段构建</strong>（Multi-Stage Build）是一种更好的方式！多阶段构建是随Docker 17.05版本新增的一个特性，用于构建精简的生产环境镜像。多阶段构建能够在不增加复杂性的情况下优化构建过程。多阶段构建方式使用一个Dockerfile，其中包含多个FROM指令。每一个FROM指令都是一个新的构建阶段（Build Stage），并且可以方便地复制之前阶段的构件。示例源码可从作者GitHub主页中atsea-sample-shopapp仓库获得，Dockerfile位于app目录。这是一个基于Linux系统的应用，因此只能运行在Linux容器环境上。</p><p>&emsp;&emsp;Dockerfile如下所示。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:latest AS storefront </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/atsea/app/react-app </span></span><br><span class="line"><span class="bash">COPY react-app . </span></span><br><span class="line"><span class="bash">RUN npm install </span></span><br><span class="line"><span class="bash">RUN npm run build</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM maven:latest AS appserver </span></span><br><span class="line"><span class="bash">WORKDIR /usr/src/atsea </span></span><br><span class="line"><span class="bash">COPY pom.xml . </span></span><br><span class="line"><span class="bash">RUN mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependen </span></span><br><span class="line"><span class="bash">cy </span></span><br><span class="line"><span class="bash">\:resolve </span></span><br><span class="line"><span class="bash">COPY . . </span></span><br><span class="line"><span class="bash">RUN mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM java:8-jdk-alpine AS production </span></span><br><span class="line"><span class="bash">RUN adduser -Dh /home/gordon gordon </span></span><br><span class="line"><span class="bash">WORKDIR /static </span></span><br><span class="line"><span class="bash">COPY --from=storefront /usr/src/atsea/app/react-app/build/ . </span></span><br><span class="line"><span class="bash">WORKDIR /app </span></span><br><span class="line"><span class="bash">COPY --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar . </span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"/app/AtSea-0.0.1-SNAPSHOT.jar"</span>] </span></span><br><span class="line"><span class="bash">CMD [<span class="string">"--spring.profiles.active=postgres"</span>]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先注意到，Dockerfile中有3个FROM指令。每一个FROM指令构成一个单独的构建阶段。各个阶段在内部从0开始编号。不过，示例中针对每个阶段都定义了便于理解的名字。阶段0叫作storefront，阶段1叫作appserver，阶段2叫作production。</p><p>&emsp;&emsp;storefront阶段拉取了大小超过600MB的node:latest镜像，然后设置了工作目录，复制一些应用代码进去，然后使用2个RUN指令来执行npm操作。这会生成3个镜像层并显著增加镜像大小。指令执行结束后会得到一个比原镜像大得多的镜像，其中包含许多构建工具和少量应用程序代码。</p><p>&emsp;&emsp;appserver阶段拉取了大小超过700MB的maven:latest镜像。然后通过2个COPY指令和2个RUN指令生成了4个镜像层。这个阶段同样会构建出一个非常大的包含许多构建工具和非常少量应用程序代码的镜像。</p><p>&emsp;&emsp;production阶段拉取java:8-jdk-alpine镜像，这个镜像大约150MB，明显小于前两个构建阶段用到的node和maven镜像。这个阶段会创建一个用户，设置工作目录，从storefront阶段生成的镜像中复制一些应用代码过来。之后，设置一个不同的工作目录，然后从 appserver阶段生成的镜像中复制应用相关的代码。最后，production设置当前应用程序为容器启动时的主程序。</p><p>&emsp;&emsp;重点在于COPY –from指令，它从之前的阶段构建的镜像中仅复制生产环境相关的应用代码，而不会复制生产环境不需要的构件。</p><p>&emsp;&emsp;还有一点也很重要，多阶段构建这种方式仅用到了一个Dockerfile，并且docker image build命令不需要增加额外参数。</p><p>&emsp;&emsp;下面就进行一下构建，首先克隆代码库并切换到app目录，并确保其中有Dockerfile。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd atsea-sample-shop-app/app</span><br><span class="line"></span><br><span class="line">$ ls -l </span><br><span class="line">total<span class="number"> 24 </span></span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 682 </span>Oct<span class="number"> 1 </span>22:03 Dockerfile </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 4365 </span>Oct<span class="number"> 1 </span>22:03 pom.xml </span><br><span class="line">drwxr-xr-x<span class="number"> 4 </span>root root<span class="number"> 4096 </span>Oct<span class="number"> 1 </span>22:03 react-app </span><br><span class="line">drwxr-xr-x<span class="number"> 4 </span>root root<span class="number"> 4096 </span>Oct<span class="number"> 1 </span>22:03 src</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行构建（这可能会花费几分钟）。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t multi:stage .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon <span class="number">3.658M</span>B </span><br><span class="line">Step <span class="number">1</span>/<span class="number">19</span> : FROM <span class="keyword">node</span><span class="title">:latest</span> AS storefront </span><br><span class="line">latest: Pulling from library/<span class="keyword">node</span> <span class="title"></span></span><br><span class="line"><span class="title">aa18ad1a0d33</span>: Pull complete </span><br><span class="line"><span class="number">15</span>a33158a136: Pull complete </span><br><span class="line"><span class="tag">&lt;Snip&gt;</span> </span><br><span class="line">Step <span class="number">19</span>/<span class="number">19</span> : CMD --spring.profiles.<span class="attr">active=</span>postgres </span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> b4df9850f7ed </span><br><span class="line"> ---&gt; <span class="number">3</span>dc0d5e6223e </span><br><span class="line">Removing intermediate container b4df9850f7ed </span><br><span class="line">Successfully built <span class="number">3</span>dc0d5e6223e </span><br><span class="line">Successfully tagged multi:stage</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行docker image ls命令查看由构建命令拉取和生成的镜像。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPO    TAG            IMAGE ID         CREATED        SIZE </span><br><span class="line">node    latest         <span class="number">9</span>ea1c3e33a0b     <span class="number">4</span> days ago     <span class="number">673</span>MB </span><br><span class="line">&lt;none&gt;  &lt;none&gt;         <span class="number">6598</span>db3cefaf     <span class="number">3</span> mins ago     <span class="number">816</span>MB </span><br><span class="line">maven   latest         cbf114925530     <span class="number">2</span> weeks ago    <span class="number">750</span>MB </span><br><span class="line">&lt;none&gt;  &lt;none&gt;         d5b619b83d9e     <span class="number">1</span> min ago      <span class="number">891</span>MB </span><br><span class="line">java    <span class="number">8</span>-jdk-alpine   <span class="number">3</span>fd9dd82815c     <span class="number">7</span> months ago   <span class="number">145</span>MB </span><br><span class="line">multi   stage          <span class="number">3</span>dc0d5e6223e     <span class="number">1</span> min ago      <span class="number">210</span>MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一行显示了在storefront阶段拉取的node:latest镜像，第二行内容为该阶段生成的镜像（通过添加代码，执行npm安装和构建操作生成该镜像）。这两个都包含许多的构建工具，因此镜像体积非常大。</p><p>&emsp;&emsp;第3～4行是在appserver阶段拉取和生成的镜像，它们也都因为包含许多构建工具而导致体积较大。</p><p>&emsp;&emsp;最后一行是Dockerfile中的最后一个构建阶段（stage2/production）生成的multi:stage镜像。可见它明显比之前阶段拉取和生成的镜像要小。这是因为该镜像是基于相对精简的java:8-jdk-alpine镜像构建的，并且仅添加了用于生产环境的应用程序文件。</p><p>&emsp;&emsp;最终，无须额外的脚本，仅对一个单独的Dockerfile执行docker image build命令，就创建了一个精简的生产环境镜像。</p><h4 id="1-2-3-最佳实践"><a href="#1-2-3-最佳实践" class="headerlink" title="1.2.3 最佳实践"></a><strong>1.2.3 最佳实践</strong></h4><h5 id="（1）利用构建缓存"><a href="#（1）利用构建缓存" class="headerlink" title="（1）利用构建缓存"></a><strong>（1）利用构建缓存</strong></h5><p>&emsp;&emsp;Docker的构建过程利用了<strong>缓存机制</strong>。观察缓存效果的一个方法，就是在一个干净的Docker主机上构建一个新的镜像，然后再重复同样的构建。第一次构建会拉取基础镜像，并构建镜像层，构建过程需要花费一定时间；第二次构建几乎能够立即完成。这就是因为第一次构建的内容（如镜像层）能够被缓存下来，并被后续的构建过程复用。</p><p>&emsp;&emsp;docker image build命令会从顶层开始解析Dockerfile中的指令并逐行执行。而对每一条指令，Docker都会检查缓存中是否已经有与该指令对应的镜像层。如果有，即为<strong>缓存命中</strong>（Cache Hit），并且会使用这个镜像层；如果没有，则是<strong>缓存未命中</strong>（Cache Miss），Docker会基于该指令构建新的镜像层。缓存命中能够显著加快构建过程。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--告诉Docker使用alpine:latest作为基础镜像，如果镜像不存在，会从Docker Hub（docker.io）拉取。</span><br><span class="line"><span class="keyword">FROM</span> alpine </span><br><span class="line"></span><br><span class="line">--对镜像执行一条命令，Docker会检查构建缓存中是否存在基于同一基础镜像，并且执行了相同指令的镜像层</span><br><span class="line">--如果找到该镜像层，Docker会跳过这条指令，并链接到这个已经存在的镜像层，然后继续构建；</span><br><span class="line">--如果无法找到符合要求的镜像层，则设置缓存无效（后续不再取缓存）并构建该镜像层</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --update nodejs nodejs-npm </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">--假设Docker已经在缓存中找到了该指令对应的镜像层（缓存命中），并且假设这个镜像层的ID是AAA</span></span><br><span class="line"><span class="bash">--下一条指令会复制一些代码到镜像中</span></span><br><span class="line"><span class="bash">--因为上一条指令命中了缓存，Docker会继续查找是否有一个缓存的镜像层也是基于AAA层并执行了COPY . /src命令。</span></span><br><span class="line"><span class="bash">--如果有，Docker会链接到这个缓存的镜像层并继续执行后续指令；</span></span><br><span class="line"><span class="bash">--如果没有，则构建镜像层，并对后续的构建操作设置缓存无效。</span></span><br><span class="line"><span class="bash">COPY . /src </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /src </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080 </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"./app.js"</span>]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一旦有指令在缓存中未命中（没有该指令对应的镜像层），则后续的整个构建过程将不再使用缓存。在编写Dockerfile时须特别注意这一点，尽量将易于发生变化的指令置于Dockerfile文件的后方执行。通过对docker image build命令加入–nocache=true参数可以强制忽略对缓存的使用。</p><p>&emsp;&emsp;COPY和ADD指令会检查复制到镜像中的内容自上一次构建之后是否发生了变化。例如，有可能Dockerfile中的COPY . /src指令没有发生变化，但是被复制的目录中的内容已经发生变化了。为了应对这一问题，Docker会计算每一个被复制文件的Checksum值，并与缓存镜像层中同一文件的checksum进行对比。如果不匹配，那么就认为缓存无效并构建新的镜像层。</p><h5 id="（2）合并镜像"><a href="#（2）合并镜像" class="headerlink" title="（2）合并镜像"></a><strong>（2）合并镜像</strong></h5><p>&emsp;&emsp;合并镜像并非一个最佳实践，因为这种方式利弊参半。总体来说，Docker会遵循正常的方式构建镜像，但之后会增加一个额外的步骤，将所有的内容合并到一个镜像层中。当镜像中层数太多时，合并是一个不错的优化方式。例如，当创建一个新的基础镜像，以便基于它来构建其他镜像的时候，这个基础镜像就最好被合并为一层。缺点是，合并的镜像将无法共享镜像层。这会导致存储空间的低效利用，而且push和pull操作的镜像体积更大。</p><p>&emsp;&emsp;执行docker image build命令时，可以通过增加–squash参数来创建一个合并的镜像。</p><p>&emsp;&emsp;图8.8阐释了合并镜像层带来的存储空间低效利用的问题。两个镜像的内容是完全一样的，区别在于是否进行了合并。在使用docker image push命令发送镜像到Docker Hub时，合并的镜像需要发送全部字节，而不合并的镜像只需要发送不同的镜像层即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010134.png" alt="合并的与不合并的镜像"></p><h5 id="（3）使用no-install-recommends"><a href="#（3）使用no-install-recommends" class="headerlink" title="（3）使用no-install-recommends"></a><strong>（3）使用no-install-recommends</strong></h5><p>&emsp;&emsp;在构建Linux镜像时，若使用的是APT包管理器，则应该在执行apt-get install命令时增加no-install-recommends参数。这能够确保APT仅安装核心依赖（Depends中定义）包，而不是推荐和建议的包。这样能够显著减少不必要包的下载数量。</p><h5 id="（4）不要安装MSI包（Windows）"><a href="#（4）不要安装MSI包（Windows）" class="headerlink" title="（4）不要安装MSI包（Windows）"></a><strong>（4）不要安装MSI包（Windows）</strong></h5><p>&emsp;&emsp;在构建Windows镜像时，尽量避免使用MSI包管理器。因其对空间的利用率不高，会大幅增加镜像的体积。</p><hr><h3 id="1-3-命令"><a href="#1-3-命令" class="headerlink" title="1.3 命令"></a><strong>1.3 命令</strong></h3><blockquote><ul><li>docker image build命令会读取Dockerfile，并将应用程序容器化。使用-t参数为镜像打标签，使用-f参数指定Dockerfile的路径和名称，使用-f参数可以指定位于任意路径下的任意名称的Dockerfile。构建上下文是指应用文件存放的位置，可能是本地Docker主机上的一个目录或一个远程的Git库。 </li><li>Dockerfile中的FROM指令用于指定要构建的镜像的基础镜像。它通常是Dockerfile中的第一条指令。 </li><li>Dockerfile中的RUN指令用于在镜像中执行命令，这会创建新的镜像层。每个RUN指令创建一个新的镜像层。 </li><li>Dockerfile中的COPY指令用于将文件作为一个新的层添加到镜像中。通常使用COPY指令将应用代码赋值到镜像中。 </li><li>Dockerfile中的EXPOSE指令用于记录应用所使用的网络端口。 </li><li>Dockerfile中的ENTRYPOINT指令用于指定镜像以容器方式启动后默认运行的程序。 </li><li>其他的Dockerfile指令还有LABEL、ENV、ONBUILD、HEALTHCHECK、CMD等。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker（五）应用的容器化，内容包括：简介，详解（单体应用容器化、生产环境中的多阶段构建、最佳实践/优化），命令等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker（四）容器</title>
    <link href="http://linyishui.top/2019101201.html"/>
    <id>http://linyishui.top/2019101201.html</id>
    <published>2019-10-12T06:03:27.000Z</published>
    <updated>2019-12-12T06:55:21.424Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker（四）容器"><a href="#Docker（四）容器" class="headerlink" title="Docker（四）容器"></a><strong>Docker（四）容器</strong></h1><h2 id="第一节-Docker容器"><a href="#第一节-Docker容器" class="headerlink" title="第一节 Docker容器"></a><strong>第一节 Docker容器</strong></h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>&emsp;&emsp;容器是镜像的运行时实例。正如从虚拟机模板上启动VM一样，用户也同样可以从单个镜像上启动一个或多个容器。虚拟机和容器最大的区别是容器更快并且更轻量级——与虚拟机运行在完整的操作系统之上相比，容器会共享其所在主机的操作系统/内核。</p><p>&emsp;&emsp;启动容器的简便方式是使用docker container run命令。该命令可以携带很多参数，在其基础的格式docker container run \&lt; image&gt; \&lt; app&gt;中，指定了启动所需的镜像以及要运行的应用。docker container run -it ubuntu /bin/bash则会启动某个Ubuntu Linux容器，并运行Bash Shell作为其应用；如果想启动 PowerShell并运行一个应用，则可以使用命令docker container run -it microsoft- /powershell:nanoserver pwsh.exe。</p><p>&emsp;&emsp;-it参数可以将当前终端连接到容器的Shell终端之上。</p><p>&emsp;&emsp;容器随着其中运行应用的退出而终止。在上面两个示例中，Linux容器会在Bash Shell退出后终止，而Windows容器会在PowerShell进程终止后退出。一个简单的验证方法就是启动新的容器，并运行sleep命令休眠10s。容器会启动，然后运行休眠命令，在10s后退出。如果在Linux主机（或者在Linux容器模式下的Windows主机上）运行docker container run alpine:latest sleep 10命令，Shell会连接到容器Shell 10s的时间，然后退出；可以在Windows容器上运行docker container run microsoft/powershell:nanoserver StartSleep -s 10来验证这一点。可以使用docker container stop命令手动停止容器运行，并且使用docker container start再次启动该容器。如果再也不需要该容器，则使用docker container rm命令来删除容器。</p><hr><h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a><strong>1.2 详解</strong></h3><h4 id="1-2-1-容器vs虚拟机"><a href="#1-2-1-容器vs虚拟机" class="headerlink" title="1.2.1 容器vs虚拟机"></a><strong>1.2.1 容器vs虚拟机</strong></h4><p>&emsp;&emsp;容器和虚拟机都依赖于宿主机才能运行。宿主机可以是笔记本，是数据中心的物理服务器，也可以是公有云的某个实例。假设宿主机是一台需要运行4个业务应用的物理服务器。在虚拟机模型中，首先要开启物理机并启动Hypervisor引导程序（跳过了BIOS和Bootloader代码等）。一旦Hypervisor启动，就会占有机器上的全部物理资源，如CPU、RAM、存储和NIC。Hypervisor接下来就会将这些物理资源划分为虚拟资源，并且看起来与真实物理资源完全一致。然后Hypervisor会将这些资源打包进一个叫作虚拟机（VM）的软件结构当中。这样用户就可以使用这些虚拟机，并在其中安装操作系统和应用。前面提到需要在物理机上运行4个应用，所以在Hypervisor之上需要创建4个虚拟机并安装4个操作系统，然后安装4个应用。当操作完成后，结构如图7.2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010126.png" alt="运行4个业务应用的物理服务器"></p><p>&emsp;&emsp;而容器模型则略有不同。服务器启动之后，所选择的操作系统会启动。在Docker世界中可以选择Linux，或者内核支持内核中的容器原语的新版本Windows。与虚拟机模型相同，OS也占用了全部硬件资源。在OS层之上，需要安装容器引擎（如Docker）。容器引擎可以获取系统资源，比如进程树、文件 系统以及网络栈，接着将资源分割为安全的互相隔离的资源结构，称之为容器。每个容器看起来就像一个真实的操作系统，在其内部可以运行应用。按照前面的假设，需要在物理机上运行4个应用。因此，需要划分出4个容器并在每个容器中运行一个应用，如图7.3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010127.png" alt="划分4个容器"></p><p>&emsp;&emsp;从更高层面上来讲，<strong>Hypervisor是硬件虚拟化</strong>（Hardware Virtualization）——Hypervisor将硬件物理资源划分为虚拟资源；另外，<strong>容器是操作系统虚拟化</strong>（OS Virtualization）——容器将系统资源划分为虚拟资源。</p><h4 id="1-2-2-虚拟机的额外开销"><a href="#1-2-2-虚拟机的额外开销" class="headerlink" title="1.2.2 虚拟机的额外开销"></a><strong>1.2.2 虚拟机的额外开销</strong></h4><p>&emsp;&emsp;接下来着重探讨Hypervisor模型的一个主要问题。</p><p>&emsp;&emsp;首先我们的目标是在一台物理机上运行4个业务相关应用。每种模型示例中都安装了一个操作系统或者Hypervisor（一种针对虚拟机高度优化后的操作系统）。截至目前，两个模型还很相似，但是也就到此为止了。</p><p>&emsp;&emsp;虚拟机模型将底层硬件资源划分到虚拟机当中。每个虚拟机都是包含了虚拟CPU、虚拟RAM、虚拟磁盘等资源的一种软件结构。因此，每个虚拟机都需要有自己的操作系统来声明、初始化并管理这些虚拟资源。但不幸的是，操作系统本身是有其额外开销的。例如，每个操作系统都消耗一点CPU、一点RAM、一点存储空间等。每个操作系统都需要独立的许可证，并且都需要打补丁升级，每个操作系统也都面临被攻击的风险。通常将这种现象称作OS Tax或者VM Tax，<strong>每个操作系统都占用一定的资源</strong>。</p><p>&emsp;&emsp;容器模型具有在宿主机操作系统中运行的单个内核。在一台主机上 运行数十个甚至数百个容器都是可能的，容器共享一个操作系统/内核，意味着只有一个操作系统消耗CPU、RAM和存储资源，只有一个操作系统需要授权，只有一个操作系统需要升级和打补丁，同时只有一个操作系统面临被攻击的风险。简言之就是只有一份OS损耗！</p><p>&emsp;&emsp;因为容器并不是完整的操作系统，所以其启动要远比虚拟机快。在容器内部并不需要内核，也就没有定位、解压以及初始化的过程——更不用提在内核启动过程中对硬件的遍历和初始化了。唯一需要的是位于下层操作系统的共享内核是启动了的！最终结果就是，容器可以在1s内启动。唯一对容器启动时间有影响的就是容器内应用启动所花费的时间。</p><p>&emsp;&emsp;这些就是容器模型要比虚拟机模型简洁并且高效的原因了。使用容器可以在更少的资源上运行更多的应用，启动更快，并且支付更少的授权和管理费用，同时面对未知攻击的风险也更小。</p><h4 id="1-2-3-检查Docker-daemon"><a href="#1-2-3-检查Docker-daemon" class="headerlink" title="1.2.3 检查Docker daemon"></a><strong>1.2.3 检查Docker daemon</strong></h4><p>&emsp;&emsp;通常登录Docker主机后的第一件事情是检查Docker是否正在运行。当命令输出中包含Client和Server的内容时，可以继续下面的示例。如果在Server部分中包含了错误码，这表示Docker daemon很可能没有运行，或者当前用户没有权限访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果在Linux中遇到无权限访问的问题，需要确认当前用户是否属于本地Docker UNIX组。如果不是，可以通过usermod -aG docker \&lt; user&gt;来添加，然后退出并重新登录Shell，改动即可生效。如果当前用户已经属于本地docker用户组，那么问题可能是Docker daemon没有运行导致。根据下列指令检查Docker daemon的状态。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Systemd在Linux系统中执行该命令 </span></span><br><span class="line">$ service docker status docker start/<span class="built_in">running</span>, <span class="built_in">process</span> <span class="number">29393</span></span><br><span class="line"><span class="comment">//使用Systemd在Linux系统中执行该命令 </span></span><br><span class="line">$ systemctl is-active docker active</span><br></pre></td></tr></table></figure><h4 id="1-2-4-启动一个简单容器"><a href="#1-2-4-启动一个简单容器" class="headerlink" title="1.2.4 启动一个简单容器"></a><strong>1.2.4 启动一个简单容器</strong></h4><p>&emsp;&emsp;启动容器的一个简单的方式是通过docker container run命令。下面的命令启动了一个简单的容器，其中运行了容器化版本的centos Linux。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu:latest /bin/bash </span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">'ubuntu:latest'</span> locally</span><br><span class="line">lates<span class="variable">t:</span> Pulling from library/ubuntu </span><br><span class="line"><span class="number">952132</span>ac251<span class="variable">a:</span> Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">82659</span>f8f1b76:  Pull <span class="built_in">complete</span> </span><br><span class="line">c19118ca682d:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">8296858250</span>fe:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">24</span>e0251a0e2c:  Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:f4691c96e6bbaa99d9...e95a60369c506dd6e6f6ab </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> ubuntu:latest </span><br><span class="line">root@<span class="number">3027</span>eb644874:/#</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;命令的基础格式为docker container run \&lt; options&gt; \&lt; image&gt;:\&lt; tag&gt; \&lt; app&gt;。</p><p>&emsp;&emsp;使用docker container run来启动容器，这也是启动新容器的标准命令。命令中使用了-it参数使容器具备交互性并与终端进行连接。接下来，命令中指定了具体镜像ubuntu:latest。最终，在命令中指定了运行在容器中的程序Bash Shell。</p><p>&emsp;&emsp;当敲击回车键之后，Docker客户端选择合适的API来调用Docker daemon。Docker daemon接收到命令并搜索Docker本地缓存，观察是否有命令所请求的镜像。在上面引用的示例中，本地缓存并未包含该镜像，所以Docker接下来查询在Docker Hub中是否存在对应镜像。找到该镜像后，Docker将镜像拉取到本地，存储在本地缓存当中。</p><p>&emsp;&emsp;一旦镜像拉取到本地，daemon就创建容器并在其中运行指定的应用。在上面的示例中，Shell提示符已经变为root@3027eb644874:/#，说明目前已经位于容器内部了。@之后的一长串数字就是容器唯一ID的前12个字符。</p><p>&emsp;&emsp;若尝试在容器内执行一些基础命令，可能会发现某些指令无法正常工作。这是因为大部分容器镜像都是经过高度优化的。这意味着某些命令或者包可能没有安装。下面的示例展示了两个命令——一条执行成功，一条执行失败。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@3027eb644874:/# ls -l</span><br><span class="line">root@3027eb644874:/#<span class="built_in"> ping </span>www.docker.com</span><br></pre></td></tr></table></figure><h4 id="1-2-5-容器进程"><a href="#1-2-5-容器进程" class="headerlink" title="1.2.5 容器进程"></a><strong>1.2.5 容器进程</strong></h4><p>&emsp;&emsp;启动Ubuntu容器之时，让容器运行Bash Shell（/bin/bash）。这使得Bash Shell成为容器中运行的且唯一运行的进程。可以通过ps -elf命令在容器内部查看（ps -elf进程在输出后即结束）。</p><p>&emsp;&emsp;这意味着如果通过输入exit退出Bash Shell，那么容器也会退出（终止）。原因是容器如果不运行任何进程则无法存在——杀死Bash Shell即杀死了容器唯一运行的进程，导致这个容器也被杀死。</p><p>&emsp;&emsp;按下Ctrl-PQ组合键则会退出容器但并不终止容器运行。这样做会切回到Docker主机的Shell，并保持容器在后台运行。可以使用docker container ls命令来观察当前系统正在运行的容器列表。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">ls</span> </span><br><span class="line">CNTNR ID  IMAGE          COMMAND    CREATED   STATUS     NAMES </span><br><span class="line">302．<span class="string">..74</span>  ubuntu<span class="function">:latest</span>  <span class="string">/bin/bash</span>  6 mins    Up 6mins   sick_montalcini</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当前容器仍然在运行，并且可以通过docker container exec命令将终端重新连接到Docker，理解这一点很重要。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker container exec -it <span class="number">3027</span>eb644874 bash </span><br><span class="line">root<span class="variable">@3027eb644874</span><span class="symbol">:/</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Shell提示符切换到了容器，如果再次运行ps命令，会看到两个Bash或者PowerShell进程，这是因为docker container exec命令创建了新的Bash或者PowerShell进程并且连接到容器。这意味着在当前Shell输入exit并不会导致容器终止，因为原Bash或者PowerShell进程还在运行当中。</p><p>&emsp;&emsp;输入exit退出容器，并通过命令docker container ps来确认容器依然在运行中。如果在自己的Docker主机上运行示例，则需要使用下面两个命令来停止并删除容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container stop 3027eb64487 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container rm 3027eb64487</span></span><br></pre></td></tr></table></figure><h4 id="1-2-6-容器生命周期"><a href="#1-2-6-容器生命周期" class="headerlink" title="1.2.6 容器生命周期"></a><strong>1.2.6 容器生命周期</strong></h4><p>&emsp;&emsp;通常会认为容器不擅长持久化工作或者持久化数据，很大程度上是因为容器在非持久化领域上表现得太出色。但是在一个领域做得很好并不意味着不擅长其他的领域。很多虚拟机管理员会记得微软或者Oracle告诉他们不能在虚拟机中运行他们的应用，至少他们不会支持这么做。</p><p>&emsp;&emsp;容器的生命周期——从创建、运行、休眠，直至销毁的整个过程。</p><p>&emsp;&emsp;新建容器，命名为“percy”，意指持久化（persistent）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">run</span><span class="bash"> --name percy -it ubuntu:latest /bin/bash</span></span><br><span class="line"><span class="bash">root@9cb2d2fd1d65:/<span class="comment">#</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来将一部分数据写入容器中。在新容器内部Shell中，执行下面的步骤来将部分数据写入到tmp目录下的某个文件中，并确认数据是否写入成功。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># cd tmp</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/tmp</span><span class="comment"># ls -l </span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/tmp</span><span class="comment"># echo "DevOps FTW" &gt; newfile</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/tmp</span><span class="comment"># ls -l </span></span><br><span class="line">total <span class="number">4</span> </span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">14</span> May <span class="number">23</span> <span class="number">11</span><span class="symbol">:</span><span class="number">22</span> newfile</span><br><span class="line"></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/tmp</span><span class="comment"># cat newfile </span></span><br><span class="line">DevOps FTW</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;按Ctrl-PQ组合键退出当前容器。现在使用docker container stop命令来停止容器运行，切换到暂停（vacation）状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container stop percy</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在运行docker container ls命令列出全部处于运行中状态的容器。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> ls </span><br><span class="line"><span class="keyword">CONTAINER</span> ID   IMAGE   COMMAND   CREATED  STATUS  PORTS   NAMES</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建的容器没有列表中出现，原因是docker container stop命令使该容器停止运行。加上-a参数再次运行前面的命令，就会显示出全部的容器，包括处于停止状态的。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">ls</span> -a </span><br><span class="line">CNTNR ID  IMAGE          COMMAND    CREATED   STATUS       NAMES </span><br><span class="line">9cb.<span class="string">..65</span>  ubuntu<span class="function">:latest</span>  <span class="string">/bin/bash</span>  4 mins    Exited <span class="params">(0)</span>   perc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在可以看到该容器显示当前状态为Exited(0)。停止容器就像停止虚拟机一样。尽管已经停止运行，容器的全部配置和内容仍然保存在Docker主机的文件系统之中，并且随时可以重新启动。</p><p>&emsp;&emsp;使用docker container start命令可以将容器重新启动。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">start</span> percy </span><br><span class="line">percy</span><br><span class="line"></span><br><span class="line">$ docker <span class="keyword">container</span> ls </span><br><span class="line"><span class="keyword">CONTAINER</span> <span class="keyword">ID</span>  IMAGE          COMMAND      CREATED  <span class="keyword">STATUS</span>     <span class="keyword">NAMES</span> </span><br><span class="line"><span class="number">9</span>cb2d2fd1d65  ubuntu:latest  <span class="string">"/bin/bash"</span>  <span class="number">4</span> mins   Up <span class="number">3</span> secs  percy</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在停止的容器已经重新启动了，此时可以确认之前创建的文件是否还存在。使用docker container exec命令连接到重启后的容器。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker container exec -it percy bash </span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Shell提示符发生变化，提示正在容器内部空间进行操作。确认之前创建的文件依然存在，并且文件中仍包含之前写入的数据。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># cd tmp </span></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># ls -l </span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">14</span> Sep <span class="number">13</span> <span class="number">04</span><span class="symbol">:</span><span class="number">22</span> newfile </span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># </span></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># cat newfile </span></span><br><span class="line">DevOps FTW</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之前创建的文件依然存在，数据也是当时的状态，这证明停止容器运行并不会损毁容器或者其中的数据。</p><p>&emsp;&emsp;尽管上面的示例阐明了容器的持久化特性，还是需要指出<strong>卷</strong>（volume）才是在容器中存储持久化数据的首选方式。到目前为止，我们应该对容器和虚拟机之间的主要区别有了深刻的印象。</p><p>&emsp;&emsp;现在停止该容器并从系统中删除它。通过在docker container rm命令后面添加-f参数来一次性删除运行中的容器是可行的。但是，删除容器的最佳方式还是分两步，先停止容器然后删除。这样可以给容器中运行的应用/进程一个停止运行并清理残留数据的机会。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">stop</span> percy percy</span><br><span class="line"></span><br><span class="line">$ docker <span class="keyword">container</span> rm percy percy</span><br><span class="line"></span><br><span class="line">$ docker <span class="keyword">container</span> ls -a </span><br><span class="line"><span class="keyword">CONTAINER</span> <span class="keyword">ID</span>    IMAGE      COMMAND      CREATED   <span class="keyword">STATUS</span>   PORTS     <span class="keyword">NAME</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总结一下容器的生命周期。可以根据需要多次停止、启动、暂停以及重启容器，并且这些操作执行得很快。但是容器及其数据是安全的。直至明确删除容器前，容器都不会丢弃其中的数据。就算容器被删除了，如果将容器数据存储在卷中，数据也会被保存下来。</p><h4 id="1-2-7-优雅地停止容器"><a href="#1-2-7-优雅地停止容器" class="headerlink" title="1.2.7 优雅地停止容器"></a><strong>1.2.7 优雅地停止容器</strong></h4><p>&emsp;&emsp;Linux中的大部分容器都会运行单一进程；在Windows中可能运行若干个，但是下面的原则对于两者都适用。</p><p>&emsp;&emsp;前面的示例中容器正在运行/bin/bash应用。当使用docker container rm \&lt; container&gt; -f来销毁运行中的容器时，不会发出任何告警。这个过程相当暴力，但是，docker container stop命令就有礼貌多了。该命令给容器内进程发送将要停止的警告信息，给进程机会来有序处理停止前要做的事情。一旦docker stop命令返回后，就可以使用docker container rm命令删除容器了。</p><p>&emsp;&emsp;这背后的原理可以通过Linux/POSIX信号来解释。stop命令向容器内的PID 1进程发送了SIGTERM这样的信号。就像前文提到的一样，会为进程预留一个清理并优雅停止的机会。如果10s内进程没有终止，那么就会收到SIGKILL信号。这是致命一击。但是，进程起码有10s的时间来“解决”自己。而rm命令会直接发出SIGKILL。</p><h4 id="1-2-8-利用重启策略进行容器的自我修复"><a href="#1-2-8-利用重启策略进行容器的自我修复" class="headerlink" title="1.2.8 利用重启策略进行容器的自我修复"></a><strong>1.2.8 利用重启策略进行容器的自我修复</strong></h4><p>&emsp;&emsp;通常建议在运行容器时配置好重启策略。这是容器的一种自我修复能力，可以在指定事件或者错误后重启来完成自我修复。</p><p>&emsp;&emsp;重启策略应用于每个容器，可以作为参数被强制传入docker container run命令中，或者在Compose文件中声明（在使用Docker Compose以及Docker Stacks的情况下）。容器支持的重启策略包括always、unless stopped和on-failed。</p><p>&emsp;&emsp;<strong>always策略</strong>是一种简单的方式。除非容器被明确停止，比如通过docker container stop命令，否则该策略会一直尝试重启处于停止状态的容器。</p><p>&emsp;&emsp;一种简单的证明方式是启动一个新的交互式容器，并在命令后面指定–restart always策略，同时在命令中指定运行Shell进程。当容器启动的时候，会登录到该Shell。退出Shell时会杀死容器中PID为1的进程，并且杀死这个容器。但是因为指定了–restart always策略，所以容器会自动重启。如果运行docker container ls命令，就会看到容器的启动时间小于创建时间。下面请看示例。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run <span class="params">--name</span> neversaydie -it <span class="params">--restart</span> always alpine sh</span><br><span class="line"></span><br><span class="line"><span class="string">//</span>等待几秒后输入exit</span><br><span class="line"></span><br><span class="line">/<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line">$ docker container <span class="keyword">ls</span> </span><br><span class="line">CONTAINER ID    IMAGE     COMMAND     CREATED           STATUS </span><br><span class="line">0901afb84439    alpine    <span class="string">"sh"</span>        35 seconds ago    Up 1 second</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，容器于35s前被创建，但却在1s前才启动。这是因为在容器中输入退出命令的时候，容器被杀死，然后Docker又重新启动了该容器。</p><p>&emsp;&emsp;<strong>–restart always策略</strong>有一个很有意思的特性，当daemon重启的时候，停止的容器也会被重启。例如，新创建一个容器并指定-restart always策略，然后通过docker container stop命令停止该容器。现在容器处于Stopped (Exited)状态。但是，如果重启Docker daemon，当daemon启动完成时，该容器也会重新启动。</p><p>&emsp;&emsp;always和unless-stopped的最大区别，就是那些指定了-restart unless-stopped并处于Stopped (Exited)状态的容器，不会在Docker daemon重启的时候被重启。</p><p>&emsp;&emsp;下面创建两个新容器，其中“always”容器指定–restart always策略，另一个“unless- stopped”容器指定了–restart unlessstopped策略。两个容器均通过docker container stop命令停止，接着重启Docker。结果“always”容器会重启，但是“unless-stopped”容器不会。</p><p>&emsp;&emsp;（1）创建两个新容器。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d --<span class="built_in">name</span> always \  </span><br><span class="line">  --restart always \  </span><br><span class="line">  alpine <span class="built_in">sleep</span> <span class="number">1</span>d</span><br><span class="line"></span><br><span class="line">$ docker container run -d --<span class="built_in">name</span> unless-<span class="built_in">stopped</span> \  </span><br><span class="line">  --restart unless-<span class="built_in">stopped</span> \  </span><br><span class="line">  alpine <span class="built_in">sleep</span> <span class="number">1</span>d</span><br><span class="line"></span><br><span class="line">$ docker container ls </span><br><span class="line">CONTAINER ID   <span class="built_in">IMAGE</span>    COMMAND      STATUS        NAMES </span><br><span class="line"><span class="number">3142</span>bd91ecc4   alpine   <span class="string">"sleep 1d"</span>   Up <span class="number">2</span> secs     unless-<span class="built_in">stopped</span> </span><br><span class="line"><span class="number">4</span>f1b431ac729   alpine   <span class="string">"sleep 1d"</span>   Up <span class="number">17</span> secs    always</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在有两个运行的容器了。一个叫作“always”，另一个叫作“unlessstopped”。</p><p>&emsp;&emsp;（2）停止两个容器。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">stop</span> <span class="keyword">always</span> unless-stopped</span><br><span class="line"></span><br><span class="line">$ docker <span class="keyword">container</span> ls -a </span><br><span class="line"><span class="keyword">CONTAINER</span> <span class="keyword">ID</span>   IMAGE     <span class="keyword">STATUS</span>                        <span class="keyword">NAMES</span></span><br><span class="line"><span class="number">3142</span>bd91ecc4   alpine    Exited (<span class="number">137</span>) <span class="number">3</span> seconds ago    unless-stopped </span><br><span class="line"><span class="number">4</span>f1b431ac729   alpine    Exited (<span class="number">137</span>) <span class="number">3</span> seconds ago    <span class="keyword">always</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;（3）重启Docker。重启Docker的过程在不同的操作系统上可能不同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemlctl restart docker</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;（4）一旦Docker重启成功，检查两个容器的状态。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a </span><br><span class="line">CONTAINER   CREATED           STATUS                        NAMES </span><br><span class="line"><span class="number">314</span>．.cc4    <span class="number">2</span> minutes ago    Exited (<span class="number">137</span>) <span class="number">2</span> minutes ago     unless-stoppe d </span><br><span class="line"><span class="number">4</span>f1.<span class="number">.729</span>    <span class="number">2</span> minutes ago    Up <span class="number">9</span> seconds                   always</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意到“always”容器已经重启了，但是“unless-stopped”容器并没有重启。<strong>on-failure策略</strong>会在退出容器并且返回值不是0的时候，重启容器。就算容器处于stopped状态，在Docker daemon重启的时候，容器也会被重启。</p><p>&emsp;&emsp;如果使用Docker Compose或者Docker Stack，可以在service对象中配置重启策略，示例如下。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">"3.5"</span> </span><br><span class="line"><span class="symbol">services:</span>  </span><br><span class="line"><span class="symbol">  myservice:</span></span><br><span class="line">    <span class="params">&lt;Snip&gt;</span>    </span><br><span class="line"><span class="symbol">    restart_policy:</span>      </span><br><span class="line"><span class="symbol">      condition:</span> always | unless-stopped | on-failure</span><br></pre></td></tr></table></figure><h4 id="1-2-9-Web服务器示例"><a href="#1-2-9-Web服务器示例" class="headerlink" title="1.2.9 Web服务器示例"></a><strong>1.2.9 Web服务器示例</strong></h4><p>&emsp;&emsp;在该示例中，会使用到作者用于Pluralsight视频教程网站中的一个镜像。这个镜像会在8080端口启动一个相当简单的Web服务。</p><p>&emsp;&emsp;使用docker container stop以及docker container rm命令清理当前系统中的全部容器，然后运行下面的docker container run命令。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d --name webserver -<span class="keyword">p</span> <span class="number">80</span>:<span class="number">8080</span> \  </span><br><span class="line">  nigelpoulton/pluralsight-docker-ci</span><br><span class="line"></span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">'nigelpoulton/pluralsight-docker-ci:latest'</span> locally </span><br><span class="line">lates<span class="variable">t:</span> Pulling from nigelpoulton/pluralsight-docker-ci </span><br><span class="line">a3ed95caeb02: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">3</span>b231ed5aa2f:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">7</span>e4f9cd54d46:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">929432235</span>e51:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">6899</span>ef41c594:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">0</span>b38fccd0da<span class="variable">b:</span>  Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:<span class="number">7</span>a6b0125fe7893e70dc63b2...<span class="number">9</span>b12a28e2c38bd8d3d </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> nigelpoulton/plur...docker-ci:latest <span class="number">6</span>efa1838cd51b92a4817e0e7483d103bf72a7ba7ffb5855080128d85043fef21</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，当前Shell提示符并未发生变化。这是因为使用了-d参数启动容器，并在后台运行。这种后台启动的方式不会将当前终端连接到容器当中。</p><p>&emsp;&emsp;该示例在docker container run命令中抛出了一些额外的参数，已知docker container run会启动一个新容器，但是这次使 用-d参数替换了-it。-d表示后台模式，告知容器在后台运行。然后为容器命名，并且指定了-p 80:8080。-p参数将Docker主机的端口映射到容器内。本例中，将Docker主机的80端口映射到了容器内的8080端口。这意味着当有流量访问主机的80端口的时候，流量会直接映射到容器内的8080端口。之所以如此是因为当前使用的镜像，其Web服务监听了8080端口。这意味着容器启动时会运行一个Web服务，监听8080端口。</p><p>&emsp;&emsp;最终，命令中还指定Docker所使用的镜像：nigelpoulton/pluralsight-docker-ci。这个镜像不一定保持更新，并且可能存在缺陷。使用docker container ls命令可以查看当前运行的容器以及端口的映射情况。端口信息按照host-port:container-port的格式显 示，明确这一点很重要。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls </span><br><span class="line">CONTAINER ID  COMMAND         STATUS       PORTS               NAMES </span><br><span class="line"><span class="number">6</span>efa1838cd51  /bin/sh -c...   Up <span class="number">2</span> mins  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">80</span>-&gt;<span class="number">8080</span>/tcp  webserver</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在容器已经运行，端口也映射成功，可以通过浏览器来访问该容器，需要在浏览器中指定Docker主机的IP地址或DNS名称，端口号是80。</p><h4 id="1-2-10-查看容器详情"><a href="#1-2-10-查看容器详情" class="headerlink" title="1.2.10 查看容器详情"></a><strong>1.2.10 查看容器详情</strong></h4><p>&emsp;&emsp;在前面的示例当中，我们可能发现当运行docker container run命令的时候，并没有指定容器中的具体应用。但是容器却启动了一个简单的Web服务，这是如何发生的？</p><p>&emsp;&emsp;当构建Docker镜像的时候，可以通过嵌入指令来列出希望容器运行时启动的默认应用。如果运行docker image inspect命令来查看运行容器时使用的镜像，就能看到容器启动时将要运行的应用列表了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image inspect nigelpoulton/pluralsight-docker-ci</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Cmd一项中展示了容器将会执行的命令或应用，除非在启动的时候指定另外的应用。如果去掉示例脚本中的转义字符，可以得到这样的命令：/bin/sh -c “cd /src &amp;&amp; node ./app.js。这是基于该镜像的容器会默认运行的应用。在构建镜像时指定默认命令是一种很普遍的做法，因为这样可以简化容器的启动。这也为镜像指定了默认的行为，并且从侧面阐述了镜像的用途——可以通过Inspect镜像的方式来了解所要运行的应用。</p><h4 id="1-2-11-快速清理"><a href="#1-2-11-快速清理" class="headerlink" title="1.2.11 快速清理"></a><strong>1.2.11 快速清理</strong></h4><p>&emsp;&emsp;接下来了解一种简单且快速的清理Docker主机上全部运行容器的方法。这种处理方式会强制删除所有的容器，并且不会给容器 完成清理的机会。<strong>这种操作一定不能在生产环境系统或者运行着重要容器的系统上执行</strong>。</p><p>&emsp;&emsp;在Docker主机的Shell中运行下面的命令，可以删除全部容器。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> rm $(docker <span class="keyword">container</span> <span class="keyword">ls</span> -aq) -f </span><br><span class="line"><span class="number">6</span>efa1838cd51</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在本例中，因为只有一个运行中的容器，所以只有一个容器被删除（6efa1838cd51）。如果将$(docker container ls -aq)作为参数传递给docker container rm命令，等价于将系统中每个容器的ID传给该命令。-f标识表示强制执行，所以即使是处于运行状态的容器也会被删除。</p><hr><h3 id="1-3-命令"><a href="#1-3-命令" class="headerlink" title="1.3 命令"></a><strong>1.3 命令</strong></h3><p>&emsp;&emsp;容器中常用命令。</p><blockquote><ul><li>docker container run是启动新容器的命令。该命令的最简形式接收镜像和命令作为参数。镜像用于创建容器，而命令则是希望容器运行的应用。docker container run -it ubuntu /bin/bash命令会在前台启动一个Ubuntu容器，并运行Bash Shell。 </li><li>Ctrl-PQ会断开Shell和容器终端之间的链接，并在退出后保持容器在后台处于运行（UP）状态。 </li><li>docker container ls用于列出所有在运行（UP）状态的容器。如果使用-a标记，还可以看到处于停止（Exited）状态的容器。 </li><li>docker container exec允许用户在运行状态的容器中，启动一个新进程。该命令在将Docker主机Shell连接到一个运行中容器终端时非常有用。docker container exec -it \&lt; container-name or container-id&gt; bash命令会在容器内部启动一个Bash Shell进程，并连接到该Shell。为了使该命令生效，用于创建容器的镜像必须包含Bash Shell。 </li><li>docker container stop命令会停止运行中的容器，并将状态置为Exited(0)。该命令通过发送SIGTERM信号给容器内PID为1的进程达到目的。如果进程没有在10s之内得到清理并停止运行，那么会接着发送SIGKILL信号来强制停止该容器。docker container stop可以接收容器ID以及容器名称作为参数。 </li><li>docker container start会重启处于停止（Exited）状态的容器。可以在docker container start命令中指定容器的名称或者ID。 </li><li>docker container rm会删除停止运行的容器。可以通过容器名<br>称或者ID来指定要删除的容器。推荐首先使用docker container stop命令停止容器，然后使用docker container rm来完成删除。 </li><li>docker container inspect命令会显示容器的配置细节和运行时信息。该命令接收容器名称和容器ID作为主要参数。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker（四）容器，内容包括：简介，详解（容器vs虚拟机、虚拟机的额外开销、检查Docker daemon、启动一个简单容器、容器进程、容器生命周期、优雅地停止容器、利用重启策略进行容器的自我修复、Web服务器示例、查看容器详情、快速清理），命令等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker（三）镜像</title>
    <link href="http://linyishui.top/2019101101.html"/>
    <id>http://linyishui.top/2019101101.html</id>
    <published>2019-10-11T02:14:38.000Z</published>
    <updated>2019-12-11T06:14:20.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker（三）镜像"><a href="#Docker（三）镜像" class="headerlink" title="Docker（三）镜像"></a><strong>Docker（三）镜像</strong></h1><h2 id="第一节-Docker镜像"><a href="#第一节-Docker镜像" class="headerlink" title="第一节 Docker镜像"></a><strong>第一节 Docker镜像</strong></h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>&emsp;&emsp;如果读者之前曾经是VM管理员，则可以把Docker镜像理解为<strong>VM模板</strong>，VM模板就像停止运行的VM，而Docker镜像就像停止运行的容器； 如果读者是一名研发人员，可以将镜像理解为<strong>类</strong>（Class）。</p><p>&emsp;&emsp;需要先从<strong>镜像仓库服务</strong>中拉取镜像。常见的镜像仓库服务是Docker Hub，但是也存在其他镜像仓库服务。拉取操作会将镜像下载到本地Docker主机，可以使用该镜像启动一个或者多个容器。</p><p>&emsp;&emsp;镜像由多个层组成，每层叠加之后，从外部看来就如一个独立的对象。镜像内部是一个精简的操作系统（OS），同时还包含应用运行所必须的文件和依赖包。因为容器的设计初衷就是快速和小巧，所以镜像通常都比较小。</p><hr><h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a><strong>1.2 详解</strong></h3><p>&emsp;&emsp;前面多次提到镜像就像停止运行的容器（类）。实际上，我们可以停止某个容器的运行，并从中创建新的镜像。所以镜像可以理解为一种构建时（build-time）结构，而容器可以理解为一种运行时（run-time）结构。</p><h4 id="1-2-1-镜像和容器"><a href="#1-2-1-镜像和容器" class="headerlink" title="1.2.1 镜像和容器"></a><strong>1.2.1 镜像和容器</strong></h4><p>&emsp;&emsp;通常使用docker container run和docker service create命令从某个镜像启动一个或多个容器。一旦容器从镜像启动后，二者之间就变成了互相依赖的关系，并且在镜像上启动的容器全部停止之前，镜像是无法被删除的。尝试删除镜像而不停止或销毁使用它的容器，会导致下面的错误。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm </span><br><span class="line"><span class="keyword">Error </span>response from daemon: conflict: unable to remove repository referenc </span><br><span class="line">e \ </span><br><span class="line">"" (must force) - container  is using its referenc\ </span><br><span class="line">ed image</span><br></pre></td></tr></table></figure><h4 id="1-2-2-镜像通常比较小"><a href="#1-2-2-镜像通常比较小" class="headerlink" title="1.2.2 镜像通常比较小"></a><strong>1.2.2 镜像通常比较小</strong></h4><p>&emsp;&emsp;容器目的就是运行应用或者服务，这意味着<strong>容器的镜像中必须包含应用/服务运行所必需的操作系统和应用文件</strong>。但是，容器又追求快速和小巧，这意味着构建镜像的时候通常需要裁剪掉不必要的部分，保持较小的体积。例如，Docker镜像通常不会包含6个不同的Shell让用户选择——通常Docker镜像中只有一个精简的Shell，甚至没有Shell。镜像中还不包含内核——容器都是共享所在Docker主机的内核。所以有时会说容器仅包含必要的操作系统（通常只有操作系统文件和文件系统对象）。<em>Hyper-V容器运行在专用的轻量级VM上，同时利用VM内部的操作系统内核。</em></p><p>&emsp;&emsp;Windows镜像要比Linux镜像大一些，这与Windows OS工作原理相关。比如，未压缩的最新Microsoft .NET镜像 （microsoft/dotnet:latest）超过1.7GB。Windows Server 2016 Nano Server镜像（microsoft/nanoserver:latest）在拉取并解压后，其体积略大于1GB。</p><h4 id="1-2-3-拉取镜像"><a href="#1-2-3-拉取镜像" class="headerlink" title="1.2.3 拉取镜像"></a><strong>1.2.3 拉取镜像</strong></h4><p>&emsp;&emsp;Docker主机安装之后，本地并没有镜像。Linux Docker主机本地镜像仓库通常位于/var/lib/docker/\<storage-driver>，Windows Docker主机则是C:\ProgramData\docker\windowsfilter。可以使用以下命令检查Docker主机的本地仓库中是否包含镜像。</storage-driver></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPOSITORY  <span class="keyword">TAG</span>      <span class="title">IMAGE</span> ID      CREATED      SIZE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将镜像取到Docker主机本地的操作是拉取。通过下面的命令可以将镜像拉取到本地，并观察其大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image pull ubuntu:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image pull alpine:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br></pre></td></tr></table></figure><h4 id="1-2-4-镜像仓库服务"><a href="#1-2-4-镜像仓库服务" class="headerlink" title="1.2.4 镜像仓库服务"></a><strong>1.2.4 镜像仓库服务</strong></h4><p>&emsp;&emsp;Docker镜像存储在镜像仓库服务（Image Registry）当中。Docker客户端的镜像仓库服务是可配置的，默认使用Docker Hub。镜像仓库服务包含多个<strong>镜像仓库</strong>（Image Repository）。同样，一个镜像仓库中可以包含多个镜像。图6.2展示了包含3个镜像仓库的镜像仓库服务，其中每个镜像仓库都包含一个或多个镜像。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010118.png" alt="包含3个镜像仓库的镜像仓库服务"></p><p>&emsp;&emsp;顾名思义，官方仓库中的镜像是由Docker公司审查的。这意味着其中的镜像会及时更新，由高质量的代码构成，这些代码是安全的，有完善的文档和最佳实践。非官方仓库更像江湖侠客，其中的镜像不一定具备官方仓库的优点，但这并不意味着所有非官方仓库都是不好的！非官方仓库中也有一些很优秀的镜像。用户需要做的是在信任非官方仓库镜像代码之前保持谨慎。</p><h4 id="1-2-5-镜像命名和标签"><a href="#1-2-5-镜像命名和标签" class="headerlink" title="1.2.5 镜像命名和标签"></a><strong>1.2.5 镜像命名和标签</strong></h4><p>&emsp;&emsp;只需要给出镜像的名字和标签，就能在官方仓库中定位一个镜像（采用“:”分隔）。从官方仓库拉取镜像时，docker image pull命令的格式如下。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull &lt;repository&gt;<span class="symbol">:&lt;tag&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在之前的Linux示例中，通过下面的两条命令完成Alpine和Ubuntu镜像的拉取。这两条命令从alpine和ubuntu仓库拉取了标有“latest”标签的镜像。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">image</span> pull alpine:latest docker <span class="built_in">image</span> pull ubuntu:latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，如果没有在仓库名称后指定具体的镜像标签，则Docker会假设用户希望拉取标签为latest的镜像。</p><p>&emsp;&emsp;其次，标签为latest的镜像不保证这是仓库中最新的镜像。例如，Alpine仓库中最新的镜像通常标签是edge。通常来讲，使用latest标签时需要谨慎！</p><p>&emsp;&emsp;从非官方仓库拉取镜像也是类似的，用户只需要在仓库名称面前加上Docker Hub的用户名或者组织名称。下面的示例展示了如何从tudemo仓库中拉取v2这个镜像，其中镜像的拥有者是Docker Hub账户nigelpoulton，一个不应该被信任的账户。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">image</span> pull nigelpoulton/tu-<span class="built_in">demo</span>:v2 </span><br><span class="line">//该命令会从以书作者的Docker Hub账号为命名空间的tu-<span class="built_in">demo</span>库中下载标签为v2的镜像</span><br></pre></td></tr></table></figure><h4 id="1-2-6-为镜像打多个标签"><a href="#1-2-6-为镜像打多个标签" class="headerlink" title="1.2.6 为镜像打多个标签"></a><strong>1.2.6 为镜像打多个标签</strong></h4><p>&emsp;&emsp;<strong>一个镜像可以根据用户需要设置多个标签</strong>。这是因为标签是存放在镜像元数据中的任意数字或字符串。</p><p>&emsp;&emsp;在docker image pull命令中指定-a参数来拉取仓库中的全部镜像。接下来可以通过运行docker image ls查看已经拉取的镜像。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull -<span class="keyword">a</span> nigelpoulton/<span class="keyword">tu</span>-demo</span><br><span class="line"></span><br><span class="line">lates<span class="variable">t:</span> Pulling from nigelpoulton/<span class="keyword">tu</span>-demo </span><br><span class="line"><span class="number">237</span>d5fcd25cf: Pull <span class="built_in">complete</span> </span><br><span class="line">a3ed95caeb02: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:<span class="number">42</span>e34e546cee61adb1...<span class="number">3</span>a0c5b53f324a9e1c1aae451e9 </span><br><span class="line">v1: Pulling from nigelpoulton/<span class="keyword">tu</span>-demo </span><br><span class="line"><span class="number">237</span>d5fcd25cf: Already <span class="built_in">exists</span> </span><br><span class="line">a3ed95caeb02: Already <span class="built_in">exists</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:<span class="number">9</span>ccc0c67e5c5eaae4b...<span class="number">624</span>c1d5c80f2c9623cbcc9b59a </span><br><span class="line">v2: Pulling from nigelpoulton/<span class="keyword">tu</span>-demo </span><br><span class="line"><span class="number">237</span>d5fcd25cf: Already <span class="built_in">exists</span> </span><br><span class="line">a3ed95caeb02: Already <span class="built_in">exists</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:d3c0d8c9d5719d31b7...<span class="number">9</span>fef58a7e038cf0ef2ba5eb74c </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> nigelpoulton/<span class="keyword">tu</span>-demo</span><br><span class="line"></span><br><span class="line">$ docker image <span class="keyword">ls</span> </span><br><span class="line">REPOSITORY              TAG     IMAGE ID       CREATED     SIZE </span><br><span class="line">nigelpoulton/<span class="keyword">tu</span>-demo     v2     <span class="number">6</span>ac21e..bead   <span class="number">1</span> yr ago    <span class="number">211.6</span> MB </span><br><span class="line">nigelpoulton/<span class="keyword">tu</span>-demo     latest <span class="number">9</span>b915a..<span class="number">1</span>e29   <span class="number">1</span> yr ago    <span class="number">211.6</span> MB </span><br><span class="line">nigelpoulton/<span class="keyword">tu</span>-demo     v1     <span class="number">9</span>b915a..<span class="number">1</span>e29   <span class="number">1</span> yr ago    <span class="number">211.6</span> MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;刚才发生了如下几件事情：首先，该命令从nigelpoulton/tu-demo仓库拉取了3个镜像：latest、v1以及v2。其次，注意看docker image ls命令输出中的IMAGE ID这一列。可以发现只有两个不同的Image ID。这是因为实际只下载了两个镜像，其中一个镜像拥有两个标签。</p><p>&emsp;&emsp;这个示例也完美证明了前文中关于latest标签使用的警告。在本例中，latest标签指向了v1标签的镜像。这意味着latest实际指向了两个镜像中较早的那个版本，而不是最新的版本！latest是一个非强制标签，不保证指向仓库中最新的镜像！</p><h4 id="1-2-7-过滤docker-image-ls的输出内容"><a href="#1-2-7-过滤docker-image-ls的输出内容" class="headerlink" title="1.2.7 过滤docker image ls的输出内容"></a><strong>1.2.7 过滤docker image ls的输出内容</strong></h4><p>　<br>&emsp;&emsp;Docker提供–filter参数来过滤docker image ls命令返回的镜像列表内容。</p><p>&emsp;&emsp;下面的示例只会返回悬虚（dangling）镜像。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --filter <span class="attr">dangling=</span><span class="literal">true</span> </span><br><span class="line">REPOSITORY    <span class="keyword">TAG</span>       <span class="title">IMAGE</span> ID       CREATED      SIZE </span><br><span class="line"><span class="tag">&lt;none&gt;</span>        <span class="tag">&lt;none&gt;</span>    <span class="number">4</span>fd34165afe0   <span class="number">7</span> days ago   <span class="number">14.5M</span>B</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那些没有标签的镜像被称为悬虚镜像，在列表中展示为\<none>: \<none>。通常出现这种情况，是因为构建了一个新镜像，然后为该镜像打了一个已经存在的标签。当此情况出现，Docker会构建新的镜像，然后发现已经有镜像包含相同的标签，接着Docker会移除旧镜像上面的标签，将该标签标在新的镜像之上。</none></none></p><p>&emsp;&emsp;例如，首先基于alpine:3.4构建一个新的镜像，并打上dodge:challenger标签。然后更新Dockerfile， 将alpine:3.4替换为alpine:3.5，并且再次执行docker image build命令。该命令会构建一个新的镜像，并且标签为dodge:challenger，同时移除了旧镜像上面对应的标签，旧镜像就变成了悬虚镜像。</p><p>&emsp;&emsp;可以通过docker image prune命令移除全部的悬虚镜像。如果添加了-a参数，Docker会额外移除没有被使用的镜像（那些没有被任何容器使用的镜像）。</p><blockquote><p>Docker目前支持如下的过滤器: </p><ul><li>dangling：可以指定true或者false，仅返回悬虚镜像（true），或者非悬虚镜像（false）。 </li><li>before：需要镜像名称或者ID作为参数，返回在之前被创建的全部镜像。 </li><li>since：与before类似，不过返回的是指定镜像之后创建的全部镜 像。 </li><li>label：根据标注（label）的名称或者值，对镜像进行过滤。docker image ls命令输出中不显示标注内容。</li></ul></blockquote><p>&emsp;&emsp;其他的过滤方式可以使用reference。下面就是使用reference完成过滤并且仅显示标签为latest的示例。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --filter=reference="*:latest" </span><br><span class="line">REPOSITORY   TAG      IMAGE ID        CREATED      SIZE </span><br><span class="line">alpine       latest   3fd9065eaf02    8 days ago   4.15MB </span><br><span class="line"><span class="keyword">test         </span>latest   8426e7efb777    3 days ago   122MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也可以使用–format参数来通过Go模板对输出内容进行格式化。例如，下面的指令将只返回Docker主机上镜像的大小属性。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">image</span> <span class="keyword">ls</span> --<span class="keyword">format</span> <span class="string">"&#123;&#123;.Size&#125;&#125;"</span> </span><br><span class="line"><span class="number">99.3</span>MB </span><br><span class="line"><span class="number">111</span>MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用下面命令返回全部镜像，但是只显示仓库、标签和大小信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">image</span> <span class="string">ls</span> <span class="bullet">--format</span> <span class="string">"<span class="template-variable">&#123;&#123;.Repository&#125;&#125;</span>: <span class="template-variable">&#123;&#123;.Tag&#125;&#125;</span>: <span class="template-variable">&#123;&#123;.Size&#125;&#125;</span>"</span> </span><br><span class="line"><span class="attr">dodge:</span>  <span class="attr">challenger:</span> <span class="number">99.3</span><span class="string">MB</span> </span><br><span class="line"><span class="attr">ubuntu:</span> <span class="attr">latest:</span>     <span class="number">111</span><span class="string">MB</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果需要更复杂的过滤，可以使用OS或者Shell自带的工具，比如Grep或者AWK。</p><h4 id="1-2-8-通过CLI方式搜索Docker-Hub"><a href="#1-2-8-通过CLI方式搜索Docker-Hub" class="headerlink" title="1.2.8 通过CLI方式搜索Docker Hub"></a><strong>1.2.8 通过CLI方式搜索Docker Hub</strong></h4><p>&emsp;&emsp;docker search命令允许通过CLI的方式搜索Docker Hub。可以通过“NAME”字段的内容进行匹配，并且基于返回内容中任意列的值进 行过滤。</p><p>&emsp;&emsp;简单模式下，该命令会搜索所有“NAME”字段中包含特定字符串的仓库。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker search nigelpoulton </span><br><span class="line">NAME                         DESCRIPTION                STARS    AUTOMATED </span><br><span class="line">nigelpoulton/pluralsight..   Web app used in...         <span class="number">8</span>        [OK] </span><br><span class="line">nigelpoulton/tu-demo                                    <span class="number">7</span> </span><br><span class="line">nigelpoulton/k8sbook         Kubernetes Book web app    <span class="number">1</span> </span><br><span class="line">nigelpoulton/web-fe1         Web front end example      <span class="number">0</span></span><br><span class="line">nigelpoulton/hello-cloud     Quick hello-world image    <span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以使用–filter “is-official=true”，使命令返回内容只显示官方镜像。通过”is-automated=true”只显示自动创建的仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search alpine --filter <span class="string">"is-official=true"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker search alpine --filter <span class="string">"is-automated=true"</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下，Docker只返回25行结果。但是可以指定–limit参数来增加返回内容行数，最多为100行。</p><h4 id="1-2-9-镜像和分层"><a href="#1-2-9-镜像和分层" class="headerlink" title="1.2.9 镜像和分层"></a><strong>1.2.9 镜像和分层</strong></h4><p>&emsp;&emsp;Docker镜像由一些松耦合的只读镜像层组成。如图6.3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010119.png" alt="Docker镜像"></p><p>&emsp;&emsp;Docker负责堆叠这些镜像层，并且将它们表示为单个统一的对象。有多种方式可以查看和检查构成某个镜像的分层，在前面已经展示了其中一种。回顾一下docker image pull ubuntu:latest命令的输出内容。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull <span class="string">ubuntu:</span>latest </span><br><span class="line"><span class="string">latest:</span> Pulling from library/ubuntu </span><br><span class="line"><span class="number">952132</span><span class="string">ac251a:</span> Pull  complete </span><br><span class="line"><span class="number">82659</span><span class="string">f8f1b76:</span> Pull  complete </span><br><span class="line"><span class="string">c19118ca682d:</span> Pull  complete </span><br><span class="line"><span class="number">8296858250</span><span class="string">fe:</span> Pull  complete </span><br><span class="line"><span class="number">24e0251</span><span class="string">a0e2c:</span> Pull complete</span><br><span class="line"><span class="string">Digest:</span> <span class="string">sha256:</span>f4691c96e6bbaa99d..<span class="number">.28</span>ae95a60369c506dd6e6f6ab </span><br><span class="line"><span class="string">Status:</span> Downloaded newer image <span class="keyword">for</span> <span class="string">ubuntu:</span>latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以Pull complete结尾的每一行都代表了镜像中某个被拉取的镜像层。可以看到，这个镜像包含5个镜像层。图6.4以图片形式将镜像层ID作为标识展示了这些分层。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010120.png" alt="镜像层"></p><p>&emsp;&emsp;另一种查看镜像分层的方式是通过docker image inspect命令。缩减之后的输出也显示该镜像包含5个镜像层。只不过这次的输出 内容中使用了镜像的SHA256散列值来标识镜像层。不过，两中命令都显示了镜像包含5个镜像层。</p><p>&emsp;&emsp;所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>&emsp;&emsp;举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。该镜像当前已经包含3个镜像层，如图6.5所示（这只是一个用于演示的很简单的例子）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010121.png" alt="基于Ubuntu Linux 16.04创建镜像"></p><p>&emsp;&emsp;在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。图6.6中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010122.png" alt="添加额外的镜像层后的镜像"></p><p>&emsp;&emsp;图6.7中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得 文件的更新版本作为一个新镜像层添加到镜像当中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010123.png" alt="三层镜像"></p><p>&emsp;&emsp;Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p><p>图6.8展示了从系统角度看三层镜像，与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010124.png" alt="从系统角度看三层镜像"></p><h4 id="1-2-10-共享镜像层"><a href="#1-2-10-共享镜像层" class="headerlink" title="1.2.10 共享镜像层"></a><strong>1.2.10 共享镜像层</strong></h4><p>&emsp;&emsp;多个镜像之间可以并且确实会共享镜像层。这样可以有效节省空间并提升性能。再回顾一下之前用于拉取nigelpoulton/tu-demo仓库下全部包含标签的docker image pull命令（包含-a参数）。</p><p>&emsp;&emsp;注意那些以Already exists结尾的行。由这几行可见，Docker很聪明，可以识别出要拉取的镜像中，哪几层已经在本地存在。在本例中，Docker首先尝试拉取标签为latest的镜像。然后，当拉取标签为v1和v2的镜像时，Docker注意到组成这两个镜像的镜像层，有一部分已经存在了。出现这种情况的原因是前面3个镜像相似度很高，所以共享了很多镜像层。</p><p>&emsp;&emsp;Docker在Linux上支持很多存储引擎（Snapshotter）。每个存储引擎都有自己的镜像分层、镜像层共享以及写时复制（CoW）技术的具体实现。但是其最终效果和用户体验是完全一致的。</p><h4 id="1-2-11-根据摘要拉取镜像"><a href="#1-2-11-根据摘要拉取镜像" class="headerlink" title="1.2.11 根据摘要拉取镜像"></a><strong>1.2.11 根据摘要拉取镜像</strong></h4><p>&emsp;&emsp;到目前为止介绍了如何通过标签来拉取镜像，但问题是标签是可变的！这意味着可能偶尔出现给镜像打错标签的情况，有时甚至会给新镜像打一个已经存在的标签。</p><p>&emsp;&emsp;假设镜像golftrack:1.5存在一个已知的Bug。因此可以拉取该镜像后修复它，并使用相同的标签将更新的镜像重新推送回仓库。</p><p>&emsp;&emsp;镜像golftrack:1.5存在Bug，这个镜像已经应用于生产环境。如果创建一个新版本的镜像，并修复了这个Bug。那么问题来了，构建新镜像并将其推送回仓库时使用了与问题镜像相同的标签！原镜像被覆盖，但在生产环境中遗留了大量运行中的容器，没有什么好办法区分正在使用的镜像版本是修复前还是修复后的，因为两个镜像的标签是相同的！<br>是时候轮到<strong>镜像摘要</strong>（Image Digest）出马了。</p><p>&emsp;&emsp;Docker 1.10中引入了新的<strong>内容寻址存储模型</strong>。作为模型的一部分，每一个镜像现在都有一个基于其内容的密码散列值（后文用摘要代指这个散列值）。因为摘要是镜像内容的一个散列值，所以镜像内容的变更一定会导致散列值的改变。这意味着摘要是不可变的。这种方式可以解决前面讨论的问题。</p><p>&emsp;&emsp;每次拉取镜像，摘要都会作为docker image pull命令返回代码的一部分。只需要在docker image ls命令之后添加–digests参数即可在本地查看镜像摘要。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull alpine </span><br><span class="line">Using<span class="built_in"> default </span>tag: latest </span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/alpine </span><br><span class="line">e110a4a17941: Pull complete </span><br><span class="line">Digest: sha256:3dcdb92d7432d56604d<span class="built_in">..</span>.6d99b889d0626de158f73a </span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> alpine:latest</span><br><span class="line"></span><br><span class="line">$ docker image ls --digests alpine </span><br><span class="line">REPOSITORY  TAG     DIGEST              IMAGE ID      CREATED        SIZE </span><br><span class="line">alpine      latest  sha256:3dcd<span class="built_in">..</span>.f73a  4e38e38c8ce0  10 weeks ago   4.8 MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的代码片段中可知，Alpine镜像的签名值：sha256:3dcdb92d7432d56604d… 6d99b889d0626de158f73a。</p><p>&emsp;&emsp;已知镜像的摘要，可以使用摘要值再次拉取这个镜像，确保准确拉取想要的镜像。截止当前没有原生Docker命令支持从远端镜像仓库服务（如Docker Hub）中获取镜像签名了。这意味着只能先通过标签方式拉取镜像到本地，然后自己维护镜像的摘要列表。</p><p>&emsp;&emsp;下面的例子首先在Docker主机上删除alpine:latest镜像，然后显示如何通过摘要（而不是标签）来再次拉取该镜像。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm alpine:latest </span><br><span class="line">Untagged: alpine:latest </span><br><span class="line">Untagged: alpine<span class="title">@sha256</span>:<span class="keyword">c</span><span class="number">0537</span>...<span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">7726</span><span class="keyword">c</span><span class="number">88e2</span>bb<span class="number">7584</span>dc<span class="number">96</span> </span><br><span class="line">Deleted: sha<span class="number">256</span>:<span class="number">02674</span>b<span class="number">9</span>cb<span class="number">179</span>d...abff<span class="number">0</span><span class="keyword">c</span><span class="number">2</span>bf<span class="number">5</span>ceca<span class="number">5</span>bad<span class="number">72</span>cd<span class="number">9</span> </span><br><span class="line">Deleted: sha<span class="number">256</span>:e<span class="number">154057080</span>f<span class="number">40</span>...<span class="number">3823</span>bab<span class="number">1</span>be<span class="number">5</span>b<span class="number">86926</span><span class="keyword">c</span><span class="number">6</span>f<span class="number">860</span></span><br><span class="line"></span><br><span class="line">$ docker image pull alpine<span class="title">@sha256</span>:<span class="keyword">c</span><span class="number">0537</span>...<span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">7726</span><span class="keyword">c</span><span class="number">88e2</span>bb<span class="number">7584</span>dc<span class="number">96</span> </span><br><span class="line">sha<span class="number">256</span>:<span class="keyword">c</span><span class="number">0537</span>...<span class="number">7726</span><span class="keyword">c</span><span class="number">88e2</span>bb<span class="number">7584</span>dc<span class="number">96</span>: Pulling from library/alpine </span><br><span class="line">cfc<span class="number">728</span><span class="keyword">c</span><span class="number">1</span><span class="keyword">c</span><span class="number">558</span>: Pull complete </span><br><span class="line">Digest: sha<span class="number">256</span>:<span class="keyword">c</span><span class="number">0537</span>ff<span class="number">6</span>a<span class="number">5218</span>...<span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">7726</span><span class="keyword">c</span><span class="number">88e2</span>bb<span class="number">7584</span>dc<span class="number">96</span> </span><br><span class="line">Status: Downloaded newer image for alpine<span class="title">@sha256</span>:<span class="keyword">c</span><span class="number">0537</span>...bb<span class="number">7584</span>dc<span class="number">96</span></span><br></pre></td></tr></table></figure><h4 id="1-2-12-镜像散列值（摘要）"><a href="#1-2-12-镜像散列值（摘要）" class="headerlink" title="1.2.12 镜像散列值（摘要）"></a><strong>1.2.12 镜像散列值（摘要）</strong></h4><p>&emsp;&emsp;从Docker 1.10版本开始，镜像就是一系列松耦合的独立层的集合。镜像本身就是一个配置对象，其中包含了镜像层的列表以及一些元数据信息。<strong>镜像层</strong>才是实际数据存储的地方（比如文件等，镜像层之间是完全独立的，并没有从属于某个镜像集合的概念）。</p><p>&emsp;&emsp;镜像的唯一标识是一个加密ID，即配置对象本身的散列值。每个镜像层也由一个加密ID区分，其值为镜像层本身内容的散列值。这意味着修改镜像的内容或其中任意的镜像层，都会导致加密散列值的变化。所以，<strong>镜像和其镜像层都是不可变的</strong>，任何改动都能很轻松地被辨别。这就是所谓的<strong>内容散列</strong>（Content Hash）。</p><p>&emsp;&emsp;在推送和拉取镜像的时候，都会对镜像层进行压缩来节省网络带宽以及仓库二进制存储空间。但是压缩会改变镜像内容，这意味着镜像的内容散列值在推送或者拉取操作之后，会与镜像内容不相符！这显然是个问题。例如，在推送镜像层到Docker Hub的时候，Docker Hub会尝试确认接收到的镜像没有在传输过程中被篡改。为了完成校验，Docker Hub会根据镜像层重新计算散列值，并与原散列值进行比较。因为镜像在传输过程中被压缩（发生了改变），所以散列值的校验也会失败。为避免该问题，每个镜像层同时会包含一个<strong>分发散列值</strong> （Distribution Hash）。这是一个压缩版镜像的散列值，当从镜像仓库服务拉取或者推送镜像的时候，其中就包含了分发散列值，<strong>该散列值会用于校验拉取的镜像是否被篡改过</strong>。</p><p>&emsp;&emsp;这个内容寻址存储模型极大地提升了镜像的安全性，因为在拉取和推送操作后提供了一种方式来确保镜像和镜像层数据是一致的。该模型也解决了随机生成镜像和镜像层ID这种方式可能导致的ID冲突问题。</p><h4 id="1-2-13-多层架构的镜像"><a href="#1-2-13-多层架构的镜像" class="headerlink" title="1.2.13 多层架构的镜像"></a><strong>1.2.13 多层架构的镜像</strong></h4><p>&emsp;&emsp;Docker最值得称赞的一点就是使用方便。例如，运行一个应用就像拉取镜像并运行容器这么简单。无须担心安装、依赖或者配置的问题。但是，随着Docker的发展，事情开始变得复杂——尤其是在添加了新平台和架构之后，例如Windows、ARM以及s390x。在拉取镜像并运行之前，需要考虑镜像是否与当前运行环境的架构匹配，这破坏了Docker的流畅体验。</p><p>&emsp;&emsp;<strong>多架构镜像</strong>（Multi-architecture Image）的出现解决了这个问题！</p><p>&emsp;&emsp;Docker（镜像和镜像仓库服务）规范目前支持多架构镜像。这意味着某个镜像仓库标签（repository:tag）下的镜像可以同时支持64位 Linux、PowerPC Linux、64位Windows和ARM等多种架构。简单地说，就是一个镜像标签之下可以支持多个平台和架构。</p><p>&emsp;&emsp;为了实现这个特性，镜像仓库服务API支持两种重要的结构： Manifest列表（新）和Manifest。Manifest列表是指某个镜像标签支持的架构列表。其支持的每种架构，都有自己的Mainfest定义，其中列举了该镜像的构成。</p><p>&emsp;&emsp;图6.9使用Golang官方镜像作为示例。图左侧是Manifest列表，其中包含了该镜像支持的每种架构。Manifest列表的每一项都有一个箭头，指向具体的Manifest，其中包含了镜像配置和镜像层数据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010125.png" alt="Golang官方镜像"></p><p>&emsp;&emsp;在具体操作之前，先来了解一下原理：假设要在Raspberry Pi（基于ARM架构的Linux）上运行Docker。在拉取镜像的时候，Docker客户端会调用Docker Hub镜像仓库服务相应的API完成拉取。如果该镜像有Mainfest列表，并且存在Linux on ARM这一项，则Docker Client就会找到ARM架构对应的Mainfest并解析出组成 该镜像的镜像层加密ID。然后从Docker Hub二进制存储中拉取每个镜像层。</p><p>&emsp;&emsp;下面的示例就展示了多架构镜像是如何在拉取官方Golang镜像时工作的，并且通过一个简单的命令展示了Go的版本和所在主机的CPU架构。需要注意的是，两个例子都使用相同的命令 docker container run。不需要告知Docker具体的镜像版本是64位Linux还是64位Windows。示例中只运行了普通的命令，选择当前平台和架构所需的正确镜像版本是有由Docker完成的。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm golang <span class="keyword">go</span> <span class="keyword">version</span></span><br><span class="line"></span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">'golang:latest'</span> locally</span><br><span class="line">lates<span class="variable">t:</span> Pulling from library/golang </span><br><span class="line"><span class="number">723254</span>a2c089: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line"><span class="number">39</span>cd5f38ffb8: Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:<span class="number">947826</span>b5b6bc4... </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> golan<span class="variable">g:latest</span> </span><br><span class="line"><span class="keyword">go</span> <span class="keyword">version</span> go1.<span class="number">9.2</span> linux/amd64</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面的操作包括从Docker Hub拉取Golang镜像，以容器方式启动，执行go version命令，并且输出Go的版本和主机OS / CPU架构信息。最后一行展示了go version命令的输出内容。</p><p>&emsp;&emsp;全面支持各种架构的工作仍在推进当中。创建支持多架构的镜像需要镜像的发布者做更多的工作。同时，某些软件也并非跨平台的。在这个前提下，Manifest列表是可选的——在没有Manifest列表的情况下，镜像仓库服务会返回普通的Manifest。</p><h4 id="1-2-14-删除镜像"><a href="#1-2-14-删除镜像" class="headerlink" title="1.2.14 删除镜像"></a><strong>1.2.14 删除镜像</strong></h4><p>&emsp;&emsp;当不再需要某个镜像的时候，可以通过docker image rm命令从Docker主机删除该镜像。其中，rm是remove的缩写。</p><p>&emsp;&emsp;删除操作会在当前主机上删除该镜像以及相关的镜像层。这意味着无法通过docker image ls命令看到删除后的镜像，并且对应的包含镜像层数据的目录会被删除。但是，如果某个镜像层被多个镜像共享，那只有当全部依赖该镜像层的镜像都被删除后，该镜像层才会被删除。如果被删除的镜像上存在运行状态的容器，那么删除操作不会被允许。再次执行删除镜像命令之前，需要停止并删除该镜像相关的全部容器。</p><p>&emsp;&emsp;下面通过镜像ID来删除镜像。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm <span class="number">02674</span>b9cb179 </span><br><span class="line"><span class="string">Untagged:</span> alpine<span class="meta">@sha</span><span class="number">256:</span>c0537ff6a5218...c0a7726c88e2bb7584dc96 </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">02674</span>b9cb179d57..<span class="number">.31</span>ba0abff0c2bf5ceca5bad72cd9 </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span>e154057080f4063..<span class="number">.2</span>a0d13823bab1be5b86926c6f860</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一种删除某Docker主机上全部镜像的快捷方式是在docker image rm命令中传入当前系统的全部镜像ID，可以通过docker image ls获取全部镜像ID（使用-q参数）。如果是在Windows环境中，那么只有在PowerShell终端中执行才会 生效。在CMD中执行并不会生效。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">image</span> rm $(docker <span class="keyword">image</span> <span class="keyword">ls</span> -q) -f</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了理解具体工作原理，首先下载一组镜像，然后通过运行docker image ls -q。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull alpine </span><br><span class="line">Using<span class="built_in"> default </span>tag: latest </span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/alpine </span><br><span class="line">e110a4a17941: Pull complete </span><br><span class="line">Digest: sha256:3dcdb92d7432d5<span class="built_in">..</span>.3626d99b889d0626de158f73a </span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> alpine:latest</span><br><span class="line"></span><br><span class="line">$ docker image pull ubuntu </span><br><span class="line">Using<span class="built_in"> default </span>tag: latest </span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/ubuntu </span><br><span class="line">952132ac251a: Pull complete </span><br><span class="line">82659f8f1b76:  Pull complete </span><br><span class="line">c19118ca682d:  Pull complete </span><br><span class="line">8296858250fe:  Pull complete </span><br><span class="line">24e0251a0e2c:  Pull complete </span><br><span class="line">Digest: sha256:f4691c96e6bba<span class="built_in">..</span>.128ae95a60369c506dd6e6f6ab </span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line">$ docker image ls -q </span><br><span class="line">bd3d4369aebc </span><br><span class="line">4e38e38c8ce0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到docker image ls -q命令只返回了系统中本地拉取的全部镜像的ID列表。将这个列表作为参数传给docker image rm会删除本地系统中的全部镜像。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q) -f </span><br><span class="line"><span class="string">Untagged:</span> <span class="string">ubuntu:</span>latest </span><br><span class="line"><span class="string">Untagged:</span> ubuntu<span class="meta">@sha</span><span class="number">256:</span>f4691c9..<span class="number">.2128</span>ae95a60369c506dd6e6f6ab </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span>bd3d4369aebc494...fa2645f5699037d7d8c6b415a10 </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span>cd10a3b73e247dd...c3a71fcf5b6c2bb28d4f2e5360b </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">4</span>d4de39110cd250..<span class="number">.28</span>bfe816393d0f2e0dae82c363a </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">6</span>a89826eba8d895...cb0d7dba1ef62409f037c6e608b </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">33</span>efada9158c32d..<span class="number">.195</span>aa12859239d35e7fe9566056 </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span>c8a75145fcc4e1a..<span class="number">.4129005e461</span>a43875a094b93412 </span><br><span class="line"><span class="string">Untagged:</span> <span class="string">alpine:</span>latest </span><br><span class="line"><span class="string">Untagged:</span> alpine<span class="meta">@sha</span><span class="number">256:</span><span class="number">3</span>dcdb92..<span class="number">.313626</span>d99b889d0626de158f73a </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">4e38</span>e38c8ce0b8d..<span class="number">.6225e13</span>b0bfe8cfa2321aec4bba </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">4</span>fe15f8d0ae69e1...eeeeebb265cd2e328e15c6a869f</span><br><span class="line"></span><br><span class="line">$ docker image ls </span><br><span class="line">REPOSITORY     TAG    IMAGE ID    CREATED    SIZE</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-命令"><a href="#1-3-命令" class="headerlink" title="1.3 命令"></a><strong>1.3 命令</strong></h3><p>&emsp;&emsp;操作Docker镜像常用到的命令。</p><blockquote><ul><li><strong>docker image pull</strong> 是下载镜像的命令。镜像从远程镜像仓库服务的仓库中下载。默认情况下，镜像会从Docker Hub的仓库中拉取。docker image pull alpine:latest命令会从Docker Hub的alpine仓库中拉取标签为latest的镜像。 </li><li><strong>docker image ls</strong> 列出了本地Docker主机上存储的镜像。可以通过–digests参数来查看镜像的SHA256签名。 </li><li><strong>docker image inspect</strong> 命令非常有用！该命令完美展示了镜像的细节，包括镜像层数据和元数据。</li><li><strong>docker image rm</strong> 用于删除镜像。docker image rm alpine:latest命令的含义是删除alpine:latest镜像。当镜像存在关联的容器，并且容器处于运行（Up）或者停止（Exited）状态时，不允许删除该镜像。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker（三）镜像，内容包括：简介，详解（镜像和容器、镜像通常比较小、拉取镜像、镜像仓库服务、镜像命名和标签、为镜像打多个标签、过滤docker image ls的输出内容、通过CLI方式搜索Docker Hub、镜像和分层、共享镜像层、根据摘要拉取镜像、镜像散列值（摘要）、多层架构的镜像、删除镜像），命令等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker（二）引擎</title>
    <link href="http://linyishui.top/2019101001.html"/>
    <id>http://linyishui.top/2019101001.html</id>
    <published>2019-10-10T10:21:48.000Z</published>
    <updated>2019-12-11T02:20:03.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker（二）引擎"><a href="#Docker（二）引擎" class="headerlink" title="Docker（二）引擎"></a><strong>Docker（二）引擎</strong></h1><h2 id="第一节-Docker引擎"><a href="#第一节-Docker引擎" class="headerlink" title="第一节 Docker引擎"></a><strong>第一节 Docker引擎</strong></h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>&emsp;&emsp;Docker引擎是用来运行和管理容器的核心软件。如果有对VMware略知一二，可以将Docker引擎理解为ESXi的角色。基于开放容器计划（OCI）相关标准的要求，Docker引擎采用了<strong>模块化</strong>的设计原则，其组件是可替换的。可以把Docker引擎看作汽车引擎——二者都是模块化的，并且由许多可交换的部件组成。</p><p>&emsp;&emsp;Docker引擎由如下主要的组件构成：Docker客户端 （Docker Client）、Docker守护进程（Docker daemon）、containerd以及runc，它们共同负责容器的创建和运行。总体逻辑如图所示。之后的整理中提到runc和containerd时，将一律使用小写的“r”和“c”。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010114.png" alt="Docker总体逻辑"></p><hr><h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a><strong>1.2 详解</strong></h3><p>&emsp;&emsp;Docker首次发布时，引擎由两个核心组件构成：LXC 和 Docker daemon。</p><p>&emsp;&emsp;Docker daemon是单一的二进制文件，包含诸如Docker客户端、 Docker API、容器运行时、镜像构建等。</p><p>&emsp;&emsp;LXC提供了对诸如命名空间（Namespace）和控制组（CGroup）等基础工具的操作能力，它们是基于Linux内核的容器虚拟化技术。</p><p>&emsp;&emsp;图5.2阐释了在Docker旧版本中，Docker daemon、LXC和操作系统之间的交互关系。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010115.png" alt="先前的Docker架构"></p><h4 id="1-2-1-摆脱LXC"><a href="#1-2-1-摆脱LXC" class="headerlink" title="1.2.1 摆脱LXC"></a><strong>1.2.1 摆脱LXC</strong></h4><p>&emsp;&emsp;对LXC的依赖自始至终都是个问题。首先，LXC是基于Linux的。这对于一个想要跨平台的项目来说是个问题。其次，如此核心的组件依赖于外部工具，这会给项目带来巨大风险，甚至影响其发展。因此，Docker公司开发了名为Libcontainer的自研工具，用于替代LXC。Libcontainer的目标是成为与平台无关的工具，可基于不同内核为Docker上层提供必要的容器交互功能。在Docker 0.9版本中，Libcontainer取代LXC成为默认的执行驱动。</p><h4 id="1-2-2-摒弃大而全的Docker-daemon"><a href="#1-2-2-摒弃大而全的Docker-daemon" class="headerlink" title="1.2.2 摒弃大而全的Docker daemon"></a><strong>1.2.2 摒弃大而全的Docker daemon</strong></h4><p>&emsp;&emsp;随着时间的推移，Docker daemon的整体性带来了越来越多的问题。</p><blockquote><ul><li>难于变更。 </li><li>运行越来越慢。 </li><li>这并非生态（或Docker公司）所期望的。</li></ul></blockquote><p>&emsp;&emsp;Docker公司意识到了这些问题，开始努力着手拆解这个大而全的Docker daemon进程，并将其模块化。这项任务的目标是尽可能拆解出其中的功能特性，并用小而专的工具来实现它。这些小工具可以是可替换的，也可以被第三方拿去用于构建其他工具。这一计划遵循了在UNIX中得以实践并验证过的一种软件哲学：小而专的工具可以组装为大型工具。</p><p>&emsp;&emsp;这项拆解和重构Docker引擎的工作仍在进行中。不过，所有容器执行和容器运行时的代码已经完全从daemon中移除，并重构为小而专的工具。</p><p>&emsp;&emsp;目前Docker引擎的架构示意图如图5.3所示，图中有简要的描述。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010116.png" alt="Docker引擎的架构"></p><h4 id="1-2-3-开放容器计划（OCI）的影响"><a href="#1-2-3-开放容器计划（OCI）的影响" class="headerlink" title="1.2.3 开放容器计划（OCI）的影响"></a><strong>1.2.3 开放容器计划（OCI）的影响</strong></h4><p>&emsp;&emsp;当Docker公司正在进行Docker daemon进程的拆解和重构的时候，OCI也正在着手定义两个容器相关的规范（或者说标准）。</p><blockquote><ul><li>镜像规范。 </li><li>容器运行时规范</li></ul></blockquote><p>&emsp;&emsp;从Docker 1.11版本（2016年初）开始，Docker引擎尽可能实现了OCI的规范。如Docker daemon不再包含任何容器运行时的代码——<strong>所有的容器运行代码在一个单独的OCI兼容层中实现</strong>。</p><p>&emsp;&emsp;默认情况下，Docker使用runc来实现这一点。runc是OCI容器运行时标准的参考实现。如上面图5.3中的runc容器运行时层。runc项目的目标之一就是与OCI规范保持一致。目前OCI规范均为1.0版本，我们不希望它们频繁地迭代，毕竟稳定胜于一切。除此之外，Docker引擎中的containerd组件确保了Docker镜像能够以正确的OCI Bundle的格式传递给runc。</p><h4 id="1-2-4-runc"><a href="#1-2-4-runc" class="headerlink" title="1.2.4 runc"></a><strong>1.2.4 runc</strong></h4><p>&emsp;&emsp;runc是OCI容器运行时规范的参考实现。去粗取精，会发现runc实质上是一个轻量级的、针对Libcontainer进行了包装的命令行交互工具（Libcontainer取代了早期Docker架构中的LXC）。</p><p>&emsp;&emsp;runc生来只有一个作用——<strong>创建容器</strong>，这一点它非常拿手，速度很快！不过它是一个CLI包装器，实质上就是一个独立的容器运行时工具。因此直接下载它或基于源码编译二进制文件，即可拥有一个全功能的runc。但它只是一个基础工具，并不提供类似Docker引擎所拥有的丰富功能。有时也将runc所在的那一层称为“OCI层”，如图5.3所示。</p><h4 id="1-2-5-containerd"><a href="#1-2-5-containerd" class="headerlink" title="1.2.5 containerd"></a><strong>1.2.5 containerd</strong></h4><p>&emsp;&emsp;在对Docker daemon的功能进行拆解后，所有的容器执行逻辑被重构到一个新的名为containerd（发音为container-dee）的工具中。它的主要任务是容器的生命周期管理——start | stop | pause | rm….</p><p>&emsp;&emsp;containerd在Linux和Windows中以daemon的方式运行，从1.11版本之后Docker就开始在Linux上使用它。Docker引擎技术栈中，containerd位于daemon和runc所在的OCI层之间。Kubernetes也可以通过cricontainerd使用containerd。</p><p>&emsp;&emsp;如前所述，containerd最初被设计为轻量级的小型工具，仅用于容器的生命周期管理。然而，随着时间的推移，它被赋予了更多的功能， 比如镜像管理。<br>其原因之一在于，这样便于在其他项目中使用它。比如，在Kubernetes中，containerd就是一个很受欢迎的容器运行时。然而在Kubernetes这样的项目中，如果containerd能够完成一些诸如push和pull镜像这样的操作就更好了。因此，如今containerd还能够完成一些除容器生命周期管理之外的操作。不过，所有的额外功能都是模块化的、可选的，便于自行选择所需功能。所以，Kubernetes这样的项目在使用containerd时，可以仅包含所需的功能。</p><h4 id="1-2-6-启动一个新的容器"><a href="#1-2-6-启动一个新的容器" class="headerlink" title="1.2.6 启动一个新的容器"></a><strong>1.2.6 启动一个新的容器</strong></h4><p>&emsp;&emsp;现在我们对Docker引擎已经有了一个总体认识，下面介绍一下创建新容器的过程。</p><p>&emsp;&emsp;常用的启动容器的方法就是使用Docker命令行工具。下面的docker container run命令会基于alpine:latest镜像启动一个新容器。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">run</span> <span class="comment">--name ctr1 -it alpine:latest sh</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当使用Docker命令行工具执行如上命令时，Docker客户端会将其转换为合适的API格式，并发送到正确的API端点。API是在daemon中实现的。这套功能丰富、基于版本的REST API已经成为Docker的标志，并且被行业接受成为事实上的容器API。</p><p>&emsp;&emsp;一旦daemon接收到创建新容器的命令，它就会向containerd发出调用。daemon已经不再包含任何创建容器的代码了！daemon使用一种CRUD风格的API，通过gRPC与containerd进行通信。虽然名叫containerd，但是它并不负责创建容器，而是指挥runc去做。containerd将Docker镜像转换为OCI bundle，并让runc基于此创建一个新的容器。</p><p>&emsp;&emsp;然后，runc与操作系统内核接口进行通信，基于所有必要的工具（Namespace、CGroup等）来创建容器。容器进程作为runc的子进程启动，启动完毕后，runc将会退出。</p><p>&emsp;&emsp;现在，容器启动完毕了。整个过程如图5.4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010117.png" alt="启动新容器的过程"></p><h4 id="1-2-7-该模型的显著优势"><a href="#1-2-7-该模型的显著优势" class="headerlink" title="1.2.7 该模型的显著优势"></a><strong>1.2.7 该模型的显著优势</strong></h4><p>&emsp;&emsp;将所有的用于启动、管理容器的逻辑和代码从daemon中移除，意味着容器运行时与Docker daemon是解耦的，有时称之为“无守护进程的容器（daemonless container）”，如此，对Docker daemon的维护和升级工作不会影响到运行中的容器。</p><p>&emsp;&emsp;在旧模型中，所有容器运行时的逻辑都在daemon中实现，启动和停止daemon会导致宿主机上所有运行中的容器被杀掉。这在生产环境中是一个大问题——想一想新版Docker的发布频次吧，每次daemon的升级都会杀掉宿主机上所有的容器。</p><h4 id="1-2-8-shim"><a href="#1-2-8-shim" class="headerlink" title="1.2.8 shim"></a><strong>1.2.8 shim</strong></h4><p>&emsp;&emsp;shim是实现无daemon的容器（用于将运行中的容器与daemon解耦，以便进行daemon升级等操作）不可或缺的工具。</p><p>&emsp;&emsp;前面提到，containerd指挥runc来创建新容器。事实上，每次创建容器时它都会fork一个新的runc实例。不过，一旦容器创建完毕，对应的runc进程就会退出。因此，即使运行上百个容器，也无须保持上百个运行中的runc实例。一旦容器进程的父进程runc退出，相关联的containerd-shim进程就会成为容器的父进程。作为容器的父进程，shim的部分职责如下。</p><blockquote><ul><li>保持所有STDIN和STDOUT流是开启状态，从而当daemon重启的时候，容器不会因为管道（pipe）的关闭而终止。 </li><li>将容器的退出状态反馈给daemon。</li></ul></blockquote><h4 id="1-2-9-在Linux中的实现"><a href="#1-2-9-在Linux中的实现" class="headerlink" title="1.2.9 在Linux中的实现"></a><strong>1.2.9 在Linux中的实现</strong></h4><p>&emsp;&emsp;在Linux系统中，前面谈到的组件由单独的二进制来实现，具体包括dockerd(Docker daemon)、docker-containerd(containerd)、docker<br>containerd-shim (shim)和docker-runc (runc)。通过在Docker宿主机的Linux系统中执行ps命令可以看到以上组件的进程。当然，有些进程只有在运行容器的时候才可见。</p><h4 id="1-2-10-daemon的作用"><a href="#1-2-10-daemon的作用" class="headerlink" title="1.2.10 daemon的作用"></a><strong>1.2.10 daemon的作用</strong></h4><p>&emsp;&emsp;当所有的执行逻辑和运行时代码都从daemon中剥离出来之后，问题出现了——daemon中还剩什么？显然，随着越来越多的功能从daemon中拆解出来并被模块化，这一问题的答案也会发生变化。不过，当本书撰写时，daemon的主要功能包括镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker（二）引擎，内容包括：简介，详解，摆脱LXC，摒弃大而全的Docker daemon，开放容器计划（OCI）的影响，runc，containerd，启动一个新的容器，该模型的显著优势，shim，在Linux中的实现，daemon的作用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
</feed>
