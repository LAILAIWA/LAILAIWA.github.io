<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-08-15T09:19:59.361Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Speciosity</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ConcurrentSkipListMap</title>
    <link href="http://linyishui.top/2020070801.html"/>
    <id>http://linyishui.top/2020070801.html</id>
    <published>2020-07-08T08:56:37.000Z</published>
    <updated>2020-08-15T09:19:59.361Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a><strong>ConcurrentSkipListMap</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是ConcurrentSkipListMap"><a href="#1-1-什么是ConcurrentSkipListMap" class="headerlink" title="1.1 什么是ConcurrentSkipListMap"></a><strong>1.1 什么是ConcurrentSkipListMap</strong></h3><p>ConcurrentSkipListMap是由并发包提供的一种线程安全的并发容器，（优点）使我们能够<strong>以无锁方式实现线程安全</strong>，<strong>底层是通过跳表来实现</strong>的能够保证<strong>元素有序</strong>。</p><p>跳表是一个链表，但是通过使用<strong>“跳跃式”</strong>查找的方式使得插入、读取数据时复杂度变成了 <strong>O(logn)</strong> 。注意：<code>size()</code> 由于多个线程可以同时对映射进行操作，所以需要遍历整个映射才能返回元素个数，这是个 <strong>O(logn)</strong> 的操作。</p><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a><strong>1.2 简单使用</strong></h3><p>一个简单的实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ConcurrentSkipListMap&lt;Integer, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(</span><br><span class="line">            Comparator.comparingInt(v -&gt; v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过put添加</span></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(-<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">600</span>);</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//遍历线程集合，构建每个线程，每个线程都分别调用线程安全和不安全的计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="comment">//分别调用安全和不安全的计数器</span></span><br><span class="line">                    map.put(i, i + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历执行所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待所有线程执行完成</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印最终结果</span></span><br><span class="line">    map.forEach((k,v) -&gt; &#123;System.out.println(<span class="string">"k: "</span> + k + <span class="string">" v: "</span> + v);&#125;);</span><br><span class="line">    System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">98</span> <span class="string">v:</span> <span class="number">98</span></span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">82</span></span><br></pre></td></tr></table></figure><p>把 ConcurrentSkipListMap 替换为 TreeMap 。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line"><span class="string">k:</span> <span class="number">3</span> <span class="string">v:</span> <span class="number">3</span></span><br><span class="line"><span class="string">k:</span> <span class="number">4</span> <span class="string">v:</span> <span class="number">4</span></span><br><span class="line"><span class="string">k:</span> <span class="number">5</span> <span class="string">v:</span> <span class="number">5</span></span><br><span class="line"><span class="string">k:</span> <span class="number">6</span> <span class="string">v:</span> <span class="number">6</span></span><br><span class="line"><span class="string">k:</span> <span class="number">7</span> <span class="string">v:</span> <span class="number">7</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line"><span class="string">k:</span> <span class="number">8</span> <span class="string">v:</span> <span class="number">8</span></span><br><span class="line"><span class="string">k:</span> <span class="number">9</span> <span class="string">v:</span> <span class="number">9</span></span><br><span class="line"><span class="string">k:</span> <span class="number">10</span> <span class="string">v:</span> <span class="number">10</span></span><br><span class="line"><span class="string">k:</span> <span class="number">11</span> <span class="string">v:</span> <span class="number">11</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">50</span> <span class="string">v:</span> <span class="number">50</span></span><br><span class="line"><span class="string">k:</span> <span class="number">51</span> <span class="string">v:</span> <span class="number">51</span></span><br><span class="line"><span class="string">k:</span> <span class="number">52</span> <span class="string">v:</span> <span class="number">52</span></span><br><span class="line"><span class="string">k:</span> <span class="number">53</span> <span class="string">v:</span> <span class="number">53</span></span><br><span class="line"><span class="string">k:</span> <span class="number">54</span> <span class="string">v:</span> <span class="number">54</span></span><br><span class="line"><span class="string">k:</span> <span class="number">55</span> <span class="string">v:</span> <span class="number">55</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">56</span> <span class="string">v:</span> <span class="number">56</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">58</span> <span class="string">v:</span> <span class="number">58</span></span><br><span class="line"><span class="string">k:</span> <span class="number">59</span> <span class="string">v:</span> <span class="number">59</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">46</span></span><br></pre></td></tr></table></figure><p>可以得到一个初印象：TreeMap 多线程环境下非线程安全，但单线程的有序映射有较好的性能，而 ConcurrentSkipListMap 则可以在相同需求的多线程场景作为替代品。  </p><hr><h2 id="第二节-跳表"><a href="#第二节-跳表" class="headerlink" title="第二节 跳表"></a><strong>第二节 跳表</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h3><p> 跳表（SkipList）：是一种优秀的数据结构，<strong>使得包含n个元素的有序序列的查找和插入操作的平均时间复杂度都是 O(logn) ，要优于数组的 O(n) </strong>。</p><p>快速的查询效果是<strong>通过维护一个多层次的链表实现的</strong>，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少（见下图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择或确定性选择，其中前者更为常见。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010118.png" alt></p><p><em>一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。</em></p><h3 id="2-2-算法"><a href="#2-2-算法" class="headerlink" title="2.2 算法"></a><strong>2.2 算法</strong></h3><p>跳跃列表是按层建造的。<strong>底层是一个普通的有序链表</strong>。每个更高层都充当下面列表的<strong>“快速通道”</strong>，这里在第 i 层中的元素按某个固定的概率 p（通常为 1/2 或 1/4 ）出现在第 i+1 层中。每个元素平均出现在 1 / 1-p 个列表中，而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）在 log~1/p~n 个列表中出现。</p><p>在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾。如果该元素等于目标元素，则表明该元素已被找到；如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。每层链表中预期的查找步数最多为 1/p ，而层数为 log~1/p~n ，所以查找的总体步数为 -log~p~n / p，由于 p 是常数，查找操作总体的时间复杂度为 O(log n) 。而通过选择不同 p 值，就可以在查找代价和存储代价之间获取平衡。</p><p>跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。跳跃列表在并行计算中也很有用：插入可以在跳跃列表不同的部分并行地进行，而不用对数据结构进行全局的重新平衡。</p><h3 id="2-3-实现细节"><a href="#2-3-实现细节" class="headerlink" title="2.3 实现细节"></a><strong>2.3 实现细节</strong></h3><p>因为跳跃列表中的元素可以在多个列表中，所以每个元素可以有多于一个指针。</p><p>跳跃列表的插入和删除的实现与普通的链表操作类似，但高层元素必须在进行多个链表中进行插入或删除。</p><p>跳跃列表的最坏时间性能具有一定随机性，但是可以通过时间复杂度为 O(n) 的遍历操作（例如在打印列表全部内容时）以无随机的算法重整列表的结构，从而使跳跃列表的实际查找时间复杂度尽量符合理论平均值 O(log n) 。</p><h4 id="（1）插入操作"><a href="#（1）插入操作" class="headerlink" title="（1）插入操作"></a><strong>（1）插入操作</strong></h4><p>往跳跃列表中插入一个元素，如图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/Skip_list_add_element-en.gif" alt></p><ol><li>新节点和各层索引节点逐一比较，确定原链表的插入位置，O(log n)。</li><li>把索引插入到原链表，O(1)。</li><li>利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止，O(log n)。</li></ol><p>总体上，跳跃表插入操作的时间复杂度是 O(log n) ，而这种数据结构所占空间是2N，既空间复杂度是 O(n) 。</p><h4 id="（2）删除操作"><a href="#（2）删除操作" class="headerlink" title="（2）删除操作"></a><strong>（2）删除操作</strong></h4><p>在索引层找到要删除的节点，依次删除每层相同节点即可。若某层索引在删除后只剩下一个节点，可以删除此层。</p><ol><li>自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点，O(log n) 。</li><li>删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外），O(log n) 。</li></ol><p>总体上，跳跃表删除操作的时间复杂度是 O(log n) 。</p><h3 id="2-4-跳跃表和二叉树的区别"><a href="#2-4-跳跃表和二叉树的区别" class="headerlink" title="2.4 跳跃表和二叉树的区别"></a><strong>2.4 跳跃表和二叉树的区别</strong></h3><ul><li>跳表维持结构平衡的成本较低，完全依靠随机；二叉树则在多次插入删除后，通过再平衡操作来重新调整结构平衡。</li><li>跳表非树结构，分索引节点和底层链表节点，索引节点只有右边和下边两条索引，链表节点则只有下个节点索引，而二叉树节点则有左右子结点。</li></ul><p>补充：Redis通过跳跃表的优化实现Sorted-set维护有序集合，而关系型数据库则采用B+树。</p><hr><h2 id="第三节-源码解析"><a href="#第三节-源码解析" class="headerlink" title="第三节 源码解析"></a><strong>第三节 源码解析</strong></h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a><strong>1.1 基本结构</strong></h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank" rel="noopener">ConcurrentSkipListMap</a> 中包括 Node 和 Index 两种节点，其中 Node 即普通链表节点，而 Index 则是索引节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳表的最高头索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护映射内元素顺序的比较器，可以为空表示自然顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 延迟初始化的键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; keySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的条目集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet&lt;K,V&gt; entrySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的值集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Values&lt;V&gt; values;</span><br><span class="line">    <span class="comment">/** 延迟初始化的降序键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ConcurrentNavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> Object value;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个新的标记节点. 标记的区别在于其值字段指向自身。标记节点也具有空键，这一事实在一些地方得到了利用，但这并不能将标记与也具有空键的基本级别标头节点（head.node）区分开。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置value字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置next字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//重新检查链接，然后在每个调用中仅执行一个help-out阶段，这样可以最大程度地减少帮助线程之间的CAS干扰</span></span><br><span class="line">            <span class="comment">//如果f是此节点的下个节点，b是此节点的前个节点</span></span><br><span class="line">            <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">                <span class="comment">//如果f为空或f的value字段不等于f，则尝试CAS将新Node节点插入f前</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">                    casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">                <span class="comment">//否则，用f的下个节点覆盖f</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; node;<span class="comment">//对应链表节点，即value</span></span><br><span class="line">        <span class="keyword">final</span> Index&lt;K,V&gt; down;<span class="comment">//下层索引节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Index&lt;K,V&gt; right;<span class="comment">//右边索引节点</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置right字段，CAS set right value</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casRight</span><span class="params">(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, rightOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否已删除此索引的节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">indexesDeletedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS索引节点newSucc作为当前节点的新右边节点（插入），并将原右边节点succ右移一位</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; n = node;</span><br><span class="line">            newSucc.right = succ;</span><br><span class="line">            <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS覆盖当前节点的右边节点succ。如果已知已删除此节点，则失败(强制调用者进行遍历) </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> rightOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = Index.class;</span><br><span class="line">                rightOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"right"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-get"><a href="#1-2-get" class="headerlink" title="1.2 get"></a><strong>1.2 get</strong></h3><p>通过 <code>get()</code> 获取键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//键不允许为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">//outer配合break，外层循环</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，找到所给键的前驱节点b，并找到键对应节点n</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="comment">//找到节点已为null，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">//若此时数据已发生改变，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//n节点的值已为null，说明已被删除，调用helpDelete删掉此节点，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//b已被删除，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若命中，则返回value</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所给键小于找到的n节点键，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">//否则右移，继续循环判断</span></span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-put"><a href="#1-3-put" class="headerlink" title="1.3 put"></a><strong>1.3 put</strong></h3><p>通过 <code>put()</code> 放置键值对，前面和 <code>get()</code> 流程类似，当新增节点时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非只覆盖value，新增了节点，通过随机数维持平衡</span></span><br><span class="line">    <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">        <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            ++level;</span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">            level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                h = head;</span><br><span class="line">                <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                    newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                    h = newh;</span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find insertion points and splice in</span></span><br><span class="line">        splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = h.level;</span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> splice;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                    <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        findNode(key);</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-remove"><a href="#1-4-remove" class="headerlink" title="1.4 remove"></a><strong>1.4 remove</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-findPredecessor"><a href="#1-5-findPredecessor" class="headerlink" title="1.5 findPredecessor"></a><strong>1.5 findPredecessor</strong></h3><p>通过 <code>findPredecessor()</code> 查找给定键和比较器的前驱节点（小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个其键严格小于给定键的base-level节点，如果没有这样的节点，则返回base-level header。</span></span><br><span class="line"><span class="comment"> * 通过不断右移和下移索引，找到对应链表节点，过程中会unlink发现到的已删除节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    <span class="comment">//外层循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，从头索引开始</span></span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            <span class="comment">//右边还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                K k = n.key;</span><br><span class="line">                <span class="comment">//右边索引对应Node所存值为空，则删掉它，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r)) <span class="comment">//删掉右边索引节点</span></span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    r = q.right;         <span class="comment">// 更新右边索引节点（原右边节点的右边节点）</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若所给键大于右边节点的键，则指针右移，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前索引节点没有下层索引，直接返回其Node节点</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">            <span class="comment">//否则指针q下移到下层索引，同时更新d</span></span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-findNode"><a href="#1-6-findNode" class="headerlink" title="1.6 findNode"></a><strong>1.6 findNode</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns node holding key or null if no such, clearing out any</span></span><br><span class="line"><span class="comment"> * deleted nodes seen along the way.  Repeatedly traverses at</span></span><br><span class="line"><span class="comment"> * base-level looking for key starting at predecessor returned</span></span><br><span class="line"><span class="comment"> * from findPredecessor, processing base-level deletions as</span></span><br><span class="line"><span class="comment"> * encountered. Some callers rely on this side-effect of clearing</span></span><br><span class="line"><span class="comment"> * deleted nodes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Restarts occur, at traversal step centered on node n, if:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (1) After reading n's next field, n is no longer assumed</span></span><br><span class="line"><span class="comment"> *       predecessor b's current successor, which means that</span></span><br><span class="line"><span class="comment"> *       we don't have a consistent 3-node snapshot and so cannot</span></span><br><span class="line"><span class="comment"> *       unlink any subsequent deleted nodes encountered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (2) n's value field is null, indicating n is deleted, in</span></span><br><span class="line"><span class="comment"> *       which case we help out an ongoing structural deletion</span></span><br><span class="line"><span class="comment"> *       before retrying.  Even though there are cases where such</span></span><br><span class="line"><span class="comment"> *       unlinking doesn't require restart, they aren't sorted out</span></span><br><span class="line"><span class="comment"> *       here because doing so would not usually outweigh cost of</span></span><br><span class="line"><span class="comment"> *       restarting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (3) n is a marker or n's predecessor's value field is null,</span></span><br><span class="line"><span class="comment"> *       indicating (among other possibilities) that</span></span><br><span class="line"><span class="comment"> *       findPredecessor returned a deleted node. We can't unlink</span></span><br><span class="line"><span class="comment"> *       the node because we don't know its predecessor, so rely</span></span><br><span class="line"><span class="comment"> *       on another call to findPredecessor to notice and return</span></span><br><span class="line"><span class="comment"> *       some earlier predecessor, which it will do. This check is</span></span><br><span class="line"><span class="comment"> *       only strictly needed at beginning of loop, (and the</span></span><br><span class="line"><span class="comment"> *       b.value check isn't strictly needed at all) but is done</span></span><br><span class="line"><span class="comment"> *       each iteration to help avoid contention with other</span></span><br><span class="line"><span class="comment"> *       threads by callers that will fail to be able to change</span></span><br><span class="line"><span class="comment"> *       links, and so will retry anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The traversal loops in doPut, doRemove, and findNear all</span></span><br><span class="line"><span class="comment"> * include the same three kinds of checks. And specialized</span></span><br><span class="line"><span class="comment"> * versions appear in findFirst, and findLast and their</span></span><br><span class="line"><span class="comment"> * variants. They can't easily share code because each uses the</span></span><br><span class="line"><span class="comment"> * reads of fields held in locals occurring in the orders they</span></span><br><span class="line"><span class="comment"> * were performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node holding key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findNode</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">跳跃列表</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/java-concurrent-skip-list-map" target="_blank" rel="noopener">Guide to the ConcurrentSkipListMap</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中ConcurrentSkipListMap的实现原理，包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>算法复习 (二) 查找-散列表</title>
    <link href="http://linyishui.top/2020070501.html"/>
    <id>http://linyishui.top/2020070501.html</id>
    <published>2020-07-05T09:35:09.000Z</published>
    <updated>2020-08-06T16:34:57.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><strong>散列表</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是散列表"><a href="#1-1-什么是散列表" class="headerlink" title="1.1 什么是散列表"></a><strong>1.1 什么是散列表</strong></h3><p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<strong>键</strong>（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><p>通过散列表我们可以在一般应用中拥有（均摊后）<strong>常数级别</strong>的查找和插入操作。</p><p>散列表的查找分为两步：</p><ol><li>通过<strong>散列函数</strong>将被查找的键转化为数组的一个索引。</li><li>处理<strong>碰撞冲突</strong>的情况。</li></ol><h3 id="1-2-散列函数"><a href="#1-2-散列函数" class="headerlink" title="1.2 散列函数"></a><strong>1.2 散列函数</strong></h3><p>散列函数的计算过程将键转化为数组的索引：如果我们有一个能保持M个键值对的数组，就需要一个能够将任意键转化为该数组范围内的索引（[0,M-1]）的<strong>散列函数</strong>。</p><p>严格来说，<strong>对于每种类型的键都需要一个与之对应的散列函数</strong>。</p><ul><li>正整数：常用<strong>除留余数法</strong>，数组大小为素数M，任意整数k除以M获得余数。选用素数的原因是避免无法均匀的散列。</li><li>浮点数：0到1间的实数，可以乘以M并四舍五入得到一个0至M-1间的索引值。但这种方法使键的高位占更大作用，低位则没什么影响，Java中采用的修正方法是<strong>将键表示为二进制再使用除留余数法</strong>。</li><li>字符串：也可以使用<strong>除留余数法</strong>，Java中有 <code>charAt()</code> 函数能返回一个char值，即一个非负16位整数。把字符串当作一个N位的R进制值，除以M并取余。Java默认使用类似 <code>Horner</code> 方法的算法，用N次乘法、加法和取余计算一个字符串的散列值。</li><li>组合键：键类型包含多种类型，如多个整型变量组合，比如Date类型，可以通过 <code>int hash = (((day * R + month) % M ) * R + year) % M</code> 来计算散列值。只要R足够小，就可以得到一个0至M-1间的散列值。</li></ul><p>Java为很多常用的数据类型重写了 <code>hashcode()</code> 方法（如String、Integer、Double、File和URL）。</p><h3 id="1-3-哈希碰撞"><a href="#1-3-哈希碰撞" class="headerlink" title="1.3 哈希碰撞"></a><strong>1.3 哈希碰撞</strong></h3><p>对不同的关键字可能得到同一散列地址，即 k~1~ != k~2~ ，而 f(k~1~) == f(k~2~) ，这种现象称为<strong>冲突</strong>（英语：Collision），也叫哈希冲突/碰撞。</p><p>两种处理哈希碰撞的方法：</p><ul><li><strong>开放地址法</strong>：当遇到哈希冲突时，依照增量规则向后取地址直到有未被占用地址为止。实例公式：<code>Hash(key) = (Hash(key) + di) mod TableSize</code> ，di表示增量序列，di不同的增长可分为：<ul><li><strong>线性探测法</strong>：di = i++ [1,2,3……，TableSize-1] ，即依次按地址后取，当一个键散列值被占用时，直接检查散列表的下一个位置（索引值加1），弊端是元素积聚，没有均匀的分布元素，导致性能降低，多查询了越来越多的无关项。</li><li><strong>二次探测法</strong>：di = (i++)^2^ * (di  / |di|) [1,-1,4,-4,9,-9……] ，弊端是当剩余空间较少时，在还有空间的情况下会极有可能插入失败。</li><li><strong>双散列探测法</strong>：di = (i++) * Hash2(key) [1H,2H,3H……] ，<code>Hash2(key) = p – (key mod p)</code> ，<code>Hash2(key) = (key % 97) + 1</code> ，其中p为小于表长的任意素数。通过另外一个散列函数来减少积聚问题，第二个函数需要排出散列值为0的情况，计算的散列值要和表长互素。</li></ul></li><li><strong>链地址法/拉链法</strong>：即将散列表每一个地址都对应一个链表，似乎链表会占用更多的空间，但实际使用中，因为装填因子的存在所以链地址法可能会更节省空间。通常情况下哈希表都非常高效，插入或查询都是O(1)，最差情况是集中映射到少量地址上，就会退化为链表查询，若被人通过Hash攻击的方式产生大量的碰撞，会导致本来高效的服务处理变得异常缓慢，可以通过限制表单提交长度等方法来防止此类攻击。</li></ul><hr><h2 id="第二节-实现"><a href="#第二节-实现" class="headerlink" title="第二节 实现"></a><strong>第二节 实现</strong></h2><h3 id="2-1-基于拉链法的散列表"><a href="#2-1-基于拉链法的散列表" class="headerlink" title="2.1 基于拉链法的散列表"></a><strong>2.1 基于拉链法的散列表</strong></h3><p>下面这个简单的符号表维护了一条链表数组，通过散列函数来为每个键选择链表。创建 <code>st[]</code> 时需要进行类型转换，因为 Java 不允许泛型的数组。默认构造器会使用997条链表，此段简单的代码已经可以在已知符号表大小时得到不错的性能，当然还可以添加<strong>动态调整链表数组的大小</strong>（rehash-再散列）的功能，从而能在任意大小都能保证链表的短小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表大小</span></span><br><span class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st;<span class="comment">//存放链表对象的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建M条链表</span></span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">            st[i] = <span class="keyword">new</span> SequentialSearchST();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value) st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-基于线性探测法的散列表"><a href="#2-2-基于线性探测法的散列表" class="headerlink" title="2.2 基于线性探测法的散列表"></a><strong>2.2 基于线性探测法的散列表</strong></h3><p>线性探测表<strong>通过空（null）来表示一簇键的结束</strong>，对于删除操作来说，直接将对应元素值设置为 <code>null</code> 是不行的，会导致此位置之后的元素无法被查找。正确的做法是将右侧所有键重新插入散列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">16</span>;<span class="comment">//线性探测表大小</span></span><br><span class="line">    <span class="keyword">private</span> key[] keys;<span class="comment">//键数组</span></span><br><span class="line">    <span class="keyword">private</span> value[] vals;<span class="comment">//值数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = (key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        vals = (value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;<span class="comment">//散列函数</span></span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;<span class="comment">//再散列</span></span><br><span class="line">        <span class="comment">//实例化新的线性探测表</span></span><br><span class="line">        LinearProbingHashST&lt;Key, Value&gt; t;</span><br><span class="line">        t = <span class="keyword">new</span> LinearProbingHashST&lt;Key, Value&gt;(cap);</span><br><span class="line">        <span class="comment">//循环遍历拷贝旧表元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">        <span class="keyword">if</span>(keys[i] != <span class="keyword">null</span>)</span><br><span class="line">                t.put(keys[i], vals[i]);</span><br><span class="line">        <span class="comment">//更新当前引用，t为局部变量</span></span><br><span class="line">        keys = t.keys;</span><br><span class="line">        vals = t.vals;</span><br><span class="line">        M = t.M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N &gt;= M/<span class="number">2</span>) resize(M*<span class="number">2</span>); <span class="comment">//M加倍扩容散列表</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//i散列得到索引，若键相等则替换值，否则检查下一个位置，直到对应key为空</span></span><br><span class="line">        <span class="keyword">for</span>(i = hash(key);keys[i] != <span class="keyword">null</span>;i = (i + <span class="number">1</span>) % M)</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))&#123;</span><br><span class="line">                vals[i] = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//将键值放入当前i</span></span><br><span class="line">        keys[i] = key;</span><br><span class="line">        vals[i] = val;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key);keys[i] != <span class="keyword">null</span>;i = (i + <span class="number">1</span>) % M)</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))</span><br><span class="line">                <span class="keyword">return</span> vals[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = hash(key);</span><br><span class="line">        <span class="comment">//遍历键簇直到找到对应key</span></span><br><span class="line">        <span class="keyword">while</span>(!key.equals(key[i]))</span><br><span class="line">            i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先将对应索引置空</span></span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        vals[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新i到下一个位置</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环将后面元素重新加入散列表，直到遍历到下一个空</span></span><br><span class="line">        <span class="keyword">while</span>(keys[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Key keyToRedo = keys[i];</span><br><span class="line">            Value valueToRedo = vals[i];</span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        vals[i] = <span class="keyword">null</span>;</span><br><span class="line">            N--;</span><br><span class="line">            put(keyToRedo, valueToRedo);</span><br><span class="line">            i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">//若此时键值对总数达到1/8表大小，则再散列缩小</span></span><br><span class="line">        <span class="keyword">if</span>(N &gt; <span class="number">0</span> &amp;&amp; N == M/<span class="number">8</span>) </span><br><span class="line">            resize(M/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-查找总结"><a href="#第三节-查找总结" class="headerlink" title="第三节 查找总结"></a><strong>第三节 查找总结</strong></h2><h3 id="3-1-各种符号表渐进性能的总结"><a href="#3-1-各种符号表渐进性能的总结" class="headerlink" title="3.1 各种符号表渐进性能的总结"></a><strong>3.1 各种符号表渐进性能的总结</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010117.jpg" alt></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了散列表的相关内容，内容包括：概述（什么是散列表、散列函数、哈希碰撞），实现（基于拉链法的散列表、基于线性探测法的散列表），查找总结。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="hash" scheme="http://linyishui.top/tags/hash/"/>
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>B树和B+树</title>
    <link href="http://linyishui.top/2020070201.html"/>
    <id>http://linyishui.top/2020070201.html</id>
    <published>2020-07-02T08:40:04.000Z</published>
    <updated>2020-08-05T16:11:59.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><strong>B树和B+树</strong></h1><h2 id="第一节-B树"><a href="#第一节-B树" class="headerlink" title="第一节 B树"></a><strong>第一节 B树</strong></h2><h3 id="1-1-什么是B树"><a href="#1-1-什么是B树" class="headerlink" title="1.1 什么是B树"></a><strong>1.1 什么是B树</strong></h3><p>B树是一种<strong>自平衡</strong>的树，能够保持数据<strong>有序</strong>。保证查找数据、顺序访问、插入数据、删除等操作都能在<strong>对数时间</strong>内完成。</p><p>B树也属于二叉查找树，<strong>一个节点允许拥有两个以上的子节点</strong>。与平衡二叉树不同的是，B树适用于读写相对较大的数据块的存储系统，如磁盘。</p><p>B树减少定位记录时所经历的中间过程，从而加快存取速度。</p><p><strong>2-3树、红黑树都是常见的B树</strong>。</p><h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a><strong>1.2 应用场景</strong></h3><p>B树这种数据结构可以用来描述外部存储。常被应用在<strong>数据库</strong>和<strong>文件系统</strong>的实现上。</p><h3 id="1-3-描述"><a href="#1-3-描述" class="headerlink" title="1.3 描述"></a><strong>1.3 描述</strong></h3><p>几个定义：</p><ul><li><strong>内部节点</strong>：内部节点是除叶子节点和根节点之外的所有节点。它们通常被表示为一组有序的元素和指向子节点的指针。</li><li><strong>根节点</strong>：根节点拥有的子节点数量的上限和内部节点相同，但是没有下限。</li><li><strong>叶子节点</strong>：叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。</li></ul><p>B树的内部结点（非叶子）可以拥有可变数量的子结点。因为子结点可变数量这一特性，B树不需要像其他平衡二叉树那样频繁的进行重新保持平衡的操作，但相应的也造成了空间浪费（以空间换时间）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/400px-B-tree.svg.png" alt></p><p>子节点数量的上界和下界依特定的实现而设置。例如，在一个2-3 B树（通常简称<a href="https://zh.wikipedia.org/wiki/2-3树" target="_blank" rel="noopener">2-3树</a>），每一个内部节点只能有2或3个子节点。</p><h3 id="1-4-操作"><a href="#1-4-操作" class="headerlink" title="1.4 操作"></a><strong>1.4 操作</strong></h3><h4 id="（1）搜索"><a href="#（1）搜索" class="headerlink" title="（1）搜索"></a><strong>（1）搜索</strong></h4><p>B树的搜索和二叉搜索树类似：从根节点开始，从上到下<strong>递归的遍历树</strong>。在每一层上，搜索的范围被减小到包含了搜索值的子树中（左小右大）。子树值的范围被它的父节点的键确定。</p><h4 id="（2）插入"><a href="#（2）插入" class="headerlink" title="（2）插入"></a><strong>（2）插入</strong></h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/B_tree_insertion_example.png" alt></p><p>所有的插入都从根节点开始。要插入一个新的元素，首先搜索这棵树找到新元素应该被添加到的对应节点。将新元素插入到这一节点中的步骤如下：</p><ol><li>如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序。</li><li>否则的话这一节点已经满了，将它平均地分裂成两个节点：<ol><li>从该节点的原有元素和新的元素中选择出中位数。</li><li>小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值。</li><li>分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）。</li></ol></li></ol><h4 id="（3）删除叶子节点中的元素"><a href="#（3）删除叶子节点中的元素" class="headerlink" title="（3）删除叶子节点中的元素"></a><strong>（3）删除叶子节点中的元素</strong></h4><ol><li>搜索要删除的元素。</li><li>如果它在叶子节点，将它从中删除。</li><li>如果发生了下溢出，按照后面<strong>删除后重新平衡</strong>部分的描述重新调整树。</li></ol><h4 id="（4）删除内部节点中的元素"><a href="#（4）删除内部节点中的元素" class="headerlink" title="（4）删除内部节点中的元素"></a><strong>（4）删除内部节点中的元素</strong></h4><p>内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：</p><ol><li>选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。</li><li>前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。</li></ol><h4 id="（5）删除后的重新平衡"><a href="#（5）删除后的重新平衡" class="headerlink" title="（5）删除后的重新平衡"></a><strong>（5）删除后的重新平衡</strong></h4><p>重新平衡从叶子节点开始向根节点进行，直到树重新平衡（自底向上）。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点<strong>合并</strong>。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：</p><ul><li>如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转：<ol><li>将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）。</li><li>将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）。</li><li>树又重新平衡。</li></ol></li><li>否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转：<ol><li>将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）。</li><li>将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）。</li><li>树又重新平衡。</li></ol></li><li>否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并：<ol><li>将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）。</li><li>将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）。</li><li>将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）。<ul><li>如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）。</li><li>否则，如果父节点的元素数量小于最小值，重新平衡父节点。</li></ul></li></ol></li></ul><h3 id="1-5-变体"><a href="#1-5-变体" class="headerlink" title="1.5 变体"></a><strong>1.5 变体</strong></h3><p>B树在内部结点上存储键值，但不需要在叶子结点上存储这些键值的记录。</p><ul><li><strong>B+树</strong>：<ul><li>这些键值的拷贝被存储在内部结点；</li><li>键值和记录存储在叶子结点；</li><li>一个叶子结点可以包含一个指针，指向另一个叶子结点以加速顺序存取。</li></ul></li><li><strong>B*树</strong>：分支出更多的内部邻居节点以保持内部节点更密集地填充。此变体要求非根节点至少2/3填充，而不是1/2。为了维持这样的结构，当一个节点填满之后将不会再立即分割节点，而是将它的键值与下一个节点共享。当两个节点都填满之后，分割成3个节点。</li><li>计数B树存储，每一树都带有一个指针和其指向子树的节点数目。这就允许了以键值为序快速查找第N笔记录，或是统计2笔记录之间的记录数目，还有其他很多相关的操作。</li></ul><h3 id="1-6-B树与平衡二叉树的区别"><a href="#1-6-B树与平衡二叉树的区别" class="headerlink" title="1.6 B树与平衡二叉树的区别"></a><strong>1.6 B树与平衡二叉树的区别</strong></h3><p>平衡二叉树通常是指查找路径只有两种（即只有二叉），而B树则不仅仅二叉，所以也叫<strong>平衡多路查找树</strong>。</p><p>B树相比平衡二叉树在每个结点所包含的内容更多，在应用到数据库中的时候，充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把结点大小限制和充分使用在磁盘块大小范围。所以树的结点能包含更多的内容后，树的层级比原来的二叉树少了，就可以减少数据查找的次数和复杂度。</p><hr><h2 id="第二节-B-树"><a href="#第二节-B-树" class="headerlink" title="第二节 B+树"></a><strong>第二节 B+树</strong></h2><h3 id="2-1-什么是B-树"><a href="#2-1-什么是B-树" class="headerlink" title="2.1 什么是B+树"></a><strong>2.1 什么是B+树</strong></h3><p><strong>B+ 树</strong>是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是<strong>能够保持数据稳定有序</strong>，其<strong>插入与修改拥有较稳定的对数时间复杂度</strong>。B+ 树元素<strong>自底向上插入</strong>，这与二叉树恰好相反。</p><p>B+ 树在节点访问时间远远超过节点内部访问时间的时候，比其他可作为替代的实现有着实在的优势。这通常在多数节点在次级存储比如硬盘中的时候出现。<strong>通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了</strong>。通常需要每个节点在次级存储中占据完整的磁盘块或近似的大小。</p><p>B+ 背后的设计思想是<strong>内部节点可以有在预定范围内的可变量目的子节点</strong>。因此，B+ 树不需要像其他自平衡二叉查找树那样经常的重新平衡。对于特定的实现在子节点数目上的低和高边界是固定的。</p><p>B+ 树的创造者 <code>Rudolf Bayer</code> 没有解释 <code>B</code> 代表什么。最常见的观点是 <code>B</code> 代表<strong>平衡</strong>(balanced)，因为所有的叶子节点在树中都在相同的级别上。<code>B</code> 也可能代表 <code>Bayer</code>，或者是<a href="https://zh.wikipedia.org/wiki/波音" target="_blank" rel="noopener">波音</a>（Boeing），因为他曾经工作于<em>波音科学研究实验室</em>。</p><p>如下图，把键 <code>1-7</code> 连接到值 <code>d1-d7</code> 的B+树。链表（红色）用于快速顺序遍历叶子节点。树的分叉因子 <code>b=4</code> 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/400px-Bplustree.png" alt></p><h3 id="2-2-节点结构"><a href="#2-2-节点结构" class="headerlink" title="2.2 节点结构"></a><strong>2.2 节点结构</strong></h3><p>在B+树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的阶数是 <code>m</code> ，则除了根之外的每个节点都包含最少 <code>m/2</code> 个元素最多 <code>m-1</code> 个元素，对于任意的结点有最多 <code>m</code> 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。</p><p>如下图所示，非叶子结点的关键字不保存数据，只用来索引，所有数据都保存在叶子节点。所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010115.png" alt></p><h3 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a><strong>2.3 算法</strong></h3><h4 id="2-3-1-查找"><a href="#2-3-1-查找" class="headerlink" title="2.3.1 查找"></a><strong>2.3.1 查找</strong></h4><p>查找以典型的方式进行，类似于<a href="https://zh.wikipedia.org/wiki/二叉查找树" target="_blank" rel="noopener">二叉查找树</a>。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是<a href="https://zh.wikipedia.org/wiki/二分查找" target="_blank" rel="noopener">二分查找</a>来确定这个位置。</p><h4 id="2-3-2-插入"><a href="#2-3-2-插入" class="headerlink" title="2.3.2 插入"></a><strong>2.3.2 插入</strong></h4><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。</p><ol><li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li></ol><h4 id="2-3-3-删除"><a href="#2-3-3-删除" class="headerlink" title="2.3.3 删除"></a><strong>2.3.3 删除</strong></h4><ol><li>首先，查找要删除的值。接着从包含它的节点中删除这个值。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果节点处于违规状态则有两种可能情况：<ol><li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。</li><li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li></ol></li></ol><h3 id="2-4-实例说明"><a href="#2-4-实例说明" class="headerlink" title="2.4 实例说明"></a><strong>2.4 实例说明</strong></h3><p>假设B+树结点最多容纳存放3个键和4个指针， <code>m = 3</code> 为奇数，<code>d = 1</code> ，叶子结点至少2个条目（d + 1），非叶子结点至少2个指针（d + 1），1个条目。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010101.png" alt></p><p>首先插入1：判断根结点为空直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010102.png" alt></p><p>接着连续插入3、5：根结点未满，连续放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010103.png" alt></p><p>接着插入7：此时根结点达到max，判断需要分裂：<strong>当节点元素数量大于m-1的时候，从中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，当然本身中间元素还是分裂右边这一部分的，保证左小右大的规则</strong>。所以分裂成两个子结点，1和3下沉到左边，5和7下沉到右边，内部结点只保存索引，最底层叶子结点连成有序链表。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010104.png" alt></p><p>接着插入9：找到位置，还有空间，直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010105.png" alt></p><p>接着插入2：如上放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010106.png" alt></p><p>接着插入4：此时对应叶子结点已放满，需要再度分裂成两个结点，1和2保留在左结点，3和4则移到新结点，并将新结点首个元素指向父结点（此时父结点仍有空间）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010107.png" alt></p><p>接着插入6：对应叶子结点同样已满，继续相同分裂操作，并将新结点首个元素指向父结点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010108.png" alt></p><p>接着插入8：仍有空间，直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010109.png" alt></p><p>接着插入10：此时对应叶子结点已满，所以先分裂开，7和8保留，9和10生成新叶子结点，将新叶子结点首个元素指向父结点，此时父结点超过上限（已是根结点，递归向上分裂，直到根结点分裂，增加高度），所以根结点分裂，中间元素7成为新的根结点，左小右大，新的结构仍是稳定的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010110.png" alt></p><p>接下来我们看B+树的删除操作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010111.png" alt></p><p>首先删除9：查找9所在结点，把它删除，然后判断此时树状态，发现叶子结点违规：叶子结点至少2个条目（d + 1），非叶子结点至少2个指针（d + 1），1个条目。合并兄弟结点，10、11和12合并，此时父结点因为少了一个子结点违规，所以需要继续处理。（此处为何为9还未搞懂）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010112.png" alt></p><p>接着删除7：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010113.png" alt></p><p>接着删除8：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010114.png" alt></p><h3 id="2-5-B-树的特点"><a href="#2-5-B-树的特点" class="headerlink" title="2.5 B+树的特点"></a><strong>2.5 B+树的特点</strong></h3><ol><li>B+树的非叶子结点不保存关键字记录的指针，只进行数据索引，这样可以使B+树每个非叶子结点所能保存的关键字数大大增加。</li><li>B+树叶子结点保存了父结点的所有关键字记录的指针，所有数据地址必须到叶子结点才能获取到，所以每次数据查询的次数都相同。</li><li>B+树叶子结点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li><strong>非叶子节点的子节点数</strong> = <strong>关键字数</strong>，或者<strong>非叶节点的关键字数</strong> = <strong>子节点数</strong> - 1，虽然他们数据排列结构不一样，但其原理还是一样的，Mysql 的B+树是用第一种方式实现。</li></ol><h3 id="2-6-B-树与B树的区别"><a href="#2-6-B-树与B树的区别" class="headerlink" title="2.6 B+树与B树的区别"></a><strong>2.6 B+树与B树的区别</strong></h3><ol><li>B+树的<strong>层级更少</strong>：相较于B树，B+树的每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li><li>B+树<strong>查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li><li>B+树<strong>天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li></ol><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><table><thead><tr><th style="text-align:center">S.NO</th><th style="text-align:center">B TREE</th><th style="text-align:center">B+ TREE</th></tr></thead><tbody><tr><td style="text-align:center">1.</td><td style="text-align:center">所有的内部和叶子结点都有数据指针</td><td style="text-align:center">只有叶子结点有数据指针</td></tr><tr><td style="text-align:center">2.</td><td style="text-align:center">由于叶子结点上的所有键都不可用，所以搜索通常更费时</td><td style="text-align:center">所有键都在叶节点上，因此搜索更快，更准确</td></tr><tr><td style="text-align:center">3.</td><td style="text-align:center">树中没有重复的键</td><td style="text-align:center">允许重复的键，并且所有结点都存在于叶子上</td></tr><tr><td style="text-align:center">4.</td><td style="text-align:center">插入会花费更多时间，有时无法预测</td><td style="text-align:center">插入更容易，结果始终相同</td></tr><tr><td style="text-align:center">5.</td><td style="text-align:center">内部结点的删除非常复杂，并且树必须进行大量转换</td><td style="text-align:center">删除任何节点都很容易，因为所有结点都可以在叶子上找到</td></tr><tr><td style="text-align:center">6.</td><td style="text-align:center">叶子结点不存储为结构链表</td><td style="text-align:center">叶子结点存储为结构链表</td></tr><tr><td style="text-align:center">7.</td><td style="text-align:center">没有多余的搜索键</td><td style="text-align:center">可能存在多余的搜索键</td></tr></tbody></table><h3 id="2-7-B-树与B-树的区别"><a href="#2-7-B-树与B-树的区别" class="headerlink" title="2.7 B+树与B*树的区别"></a><strong>2.7 B+树与B*树的区别</strong></h3><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ol><li><p>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是 <code>cei(m/2)</code> ，<code>b*</code> 树的初始化个数为<code>cei(2/3*m)</code> 。</p></li><li><p>B+树节点满时就会分裂，而B<em>树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</em></p></li><li>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</li></ol><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/B树" target="_blank" rel="noopener">B树-维基百科</a></p></blockquote><blockquote><p><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B+树-维基百科</a></p></blockquote><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了B树和B+树的相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="http://linyishui.top/2020070101.html"/>
    <id>http://linyishui.top/2020070101.html</id>
    <published>2020-07-01T09:28:50.000Z</published>
    <updated>2020-08-06T09:30:27.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a><strong>Redis底层数据结构</strong></h1><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80bc35b4da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="第一节-动态字符串-SDS"><a href="#第一节-动态字符串-SDS" class="headerlink" title="第一节 动态字符串-SDS"></a><strong>第一节 动态字符串-SDS</strong></h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a><strong>1.1 概述</strong></h3><p>Redis 是由 <strong>C 语言</strong>作为底层编程语言实现的，而 <strong>C 语言中的字符串是一个以空字符结尾的字符数组</strong>，这种结构对于 Redis 而言过于简单了，主要缺点如下：</p><ol><li><strong>C 字符串不记录自身长度信息，为了获取字符串长度必须遍历整个字符串，时间复杂度为 O(n)</strong>。</li><li>由于 C 字符串不记录自身长度，<strong>稍有不小心就会造成缓冲区溢出</strong>。</li><li>对于 Redis 这种缓存类型数据库，对于缓存的 Value 是有可能经常的更改的。但是 <strong>C 字符串每次的增长或是缩小都需要一次内存的重分配操作</strong>。</li><li>Redis 数据库中缓存的内容不是特定的，有可能会是图片、音频等等文件的二进制数据，但是 <strong>C 字符串中的字符必须符合某种编码，且字符串中不能包含空格</strong>，这些限制也导致了 Redis 不能使用 C 字符串来作为自身字符串的实现。</li></ol><p>于是 Redis 实现了 SDS 这种简单动态字符串结构，它其实和 Java 中 ArrayList 的实现是很类似的。</p><p>Redis 源代码中 <code>sds.h</code> 文件下，有五种 <code>sdshdr</code> ，它们分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，sdshdr5 的注释表明，<strong>sdshdr5  is never used</strong>。sdshdr5 这种数据结构一般用于存储长度小于 32 个字符的字符串，但现在也已经不再使用这种结构了，再小长度的字符串也建议使用 sdshdr8 进行存储，因为 sdshdr5 少了两个关键字段，因此不具备动态扩容操作，一旦预分配的内存空间使用完，就需要重新分配内存并完成数据的复制迁移，在实际的生产环境中对于性能的影响还是很大的，所以进行了一个抛弃，但其实有些比较小的键依然会采用这种结构存储。</p><p>关于 sdshdr5 我们不再多说，我们看其他四种结构的各个字段，len 字段表示当前字符串总长度，也即当前字符串已使用内存大小，alloc 表示为当前字符串分配的总内存大小（不包括len以及flags字段本身分配的内存），因为每一个结构在预分配的时候都会多分配一段内存空间，主要是为了方便以后的扩容。flags 的低三位表示当前 sds 的类型，高五位无用。低三位取值如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure><p>实际上，redis 对 sdshdr 内存分配是禁用内存对齐的，也就是说每个字段分配的内存地址是紧紧排列在一起的， 所以 redis 中字符串参数的传递直接使用 <strong>char*</strong> 指针。</p><p>可能有人会疑问，仅仅通过一个 <strong>char</strong> 指针如何确定当前字符串的类型，其实由于 sdshdr 内存分配禁止内存对齐，所以 sds[-1] 其实指向的就是 flags 字段的内存地址，通过 flags 字段又可以得到当前 sds 属于哪种类型，进而可以读取头部字段确定 sds 的相关属性。</p><p>接下来我们讲讲 sdshdr 相对于传统的 C 语言字符串，性能的提升在哪，以及具有哪些便捷的点。</p><p><strong>首先</strong>，对于传统的 C 字符串，我想要获取字符串的长度，至少需要 O(n) 遍历一遍数组才行，而我们 sds 只需要 O(1) 的取 len 字段的值即可。</p><p><strong>其次</strong>，也是非常重要的一个设计，如果我们初始分配了一个字符串对象，那么如果我要在这个字符串后面追加内容的话，限制于数组的长度一经初始化是不能修改的，我们至少需要分配一个足够大的数组，然后将原先的字符串进行一个拷贝。</p><p><strong>sdshdr 每次为一个 sds 分配内存的时候都会额外分配一部分暂不使用的内存空间，一般额外的内存会等同于当前字符串占用的内存大小，如果超过 1MB，那么额外空间的内存大小就是 1MB</strong>。每当执行 sdscat 这种方法的时候，程序会用 alloc-len 比较下剩下的空余内存是否足够分配追加的内容，如果不够自然触发内存重分配，而如果剩余未使用内存空间足够放下，那么将直接进行分配，无需内存重分配。</p><p><strong>通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次</strong>。</p><p><strong>最后</strong>，对于常规的 C 语言字符串，它通过判断当前字符是否是空字符来决定字符串的结尾，所以就要求你的字符串中不能包含甚至一个空字符，否则空字符后面的字符都不能作为有效字符被读取。而对于某些具有特殊格式要求的，需要使用空字符进行分隔作用的，那么传统的 C 字符串就无法存储了，而我们的 <strong>sds 不是通过空字符判断字符串结尾，而是通过 len 字段的值判断字符串的结尾</strong>，所以说，sds 还具备<strong>二进制安全</strong>这个特性，即它可以安全的存储具备特殊格式要求的二进制数据。</p><p>关于 sds 我们就简单说到这，它是一种改良版的 C 字符串，兼容 C 语言中既有的函数 API，也通过一些手段提升了某些操作的性能，值得大家借鉴。</p><hr><h2 id="第二节-链表"><a href="#第二节-链表" class="headerlink" title="第二节 链表"></a><strong>第二节 链表</strong></h2><p>链表这种数据结构相信大家也不陌生，有很多类型，比如单向链表，双向链表，循环链表等，链表相对于数组来说，<strong>一是不需要连续的内存块地址，二是删除和插入的时间复杂度是 O(1) 级别的</strong>，非常的高效，但<strong>比不上数组的随机访问查询方式</strong>。</p><p>一样的那句话，没有最好的数据结构，只有恰到好处的数据结构，比如我们后面要介绍的更高层次的数据结构，字典，它的底层其实就依赖的链表规避哈希冲突，具体的我们后面再说。</p><p>redis 中借助 C 语言实现了一个双向链表结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>pre 指针指向前一个节点，next 指针指向后一个节点，value 指向当前节点对应的数据对象。盗一张图描述整个串联起来的链表结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80c4f8982b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>虽然通过链表的第一个头节点就可以遍历整个链表，但在 <strong>redis 向上封装了一层结构，专门用于表示一个链表结构</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><ul><li>head 指向链表的头节点</li><li>tail 指向链表的尾节点</li><li>dup 函数用于链表转移复制时对节点 value 拷贝的一个实现，一般来说用等于号足以，但某些特殊情况下可能会用到节点转移函数，默认可以给这个函数赋值 NULL 即表示使用等于号进行节点转移。</li><li>free 函数用于释放一个节点所占用的内存空间，默认赋值 NULL 的话，即使用 redis 自带的 zfree 函数进行内存空间释放，我们也可以来看一下这个 zfree 函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会涉及到一个<strong>内存对齐</strong>的概念，就比如一个 64 位的操作系统，一次内存 IO 会固定取出 8 个字节的内存数据出来，如果某个变量横跨了两个八字节段，那么 CPU 需要进行两次的 IO 才能完整取出该变量的数据，引入内存对齐，是为了保证任意变量的内存分配不会出现上述的横跨情况，具体的操作手法就是填充无用的内存位，当然这必然会造成内存碎片，不过这也是一种以空间换时间的策略，你也可以禁用它。</p><p>函数的上半部分是做一些判断，如果确定了该指针指向的数据结构占用的总内存，则直接调用 free 函数进行内存的释放，否则需要进行一个计算。redis 中的 zmalloc 在每一次内存数据分配的时候都会追加一个 PREFIX_SIZE 的头部数据块，它的值等于当前系统的最大寻址空间，比如 64 CPU的话，PREFIX_SIZE 就会占用到 8 个字节，并且这 8 个字节内部存储的是当前数据实际占用内存大小。</p><p>所以这里的话，ptr 指针向低位移动就是指向头部 PREFIX_SIZE 字段首地址，然后取出里面保存的值，也就是当前数据结构实际占用的内存大小，最后加上它自身传入 update_zmalloc_stat_free 函数中修改 used_memory 内存记录指针的值，并在最后调用 free 函数释放内存，包括头部的部分。</p><p>其实我们扯远了，继续看数据结构，这里如果还不是很明白的话，没关系，后面我们还会继续讲的。</p><p>match 函数依然是一个多态的实现，只给出了定义，具体实现由你来决定，你也可以选择不实现，它用于比较两个链表节点的 value 值是否相等。返回 0 表示不相等，返回 1 表示相等。</p><p>最后一个 len 字段描述的是，整个链表中所包含的节点数量。以上就是 redis 中链表的一个基本的定义，加上 list，最终链表结构在 redis 中呈现的抽象图大概是这样的，依然盗的图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80bc798df0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>综上，我们介绍了 redis 中链表的一个基本实现情况，总结一下，它是一个双端链表，也就是查找某个节点的前后节点的时间复杂度都在 O(1)，也是一个无环并具有首尾节点指针的链表，初次之外，还具有三个多态函数，用于节点间的复制、比较以及内存释放，需要使用者自行实现。</p><hr><h2 id="第三节-字典"><a href="#第三节-字典" class="headerlink" title="第三节 字典"></a><strong>第三节 字典</strong></h2><p>字典相对于数组，链表来说，是一种较高层次的数据结构，像我们的汉语字典一样，可以通过拼音或偏旁唯一确定一个汉字，在程序里我们管<strong>每一个映射关系叫做一个键值对</strong>，<strong>很多个键值对放在一起就构成了我们的字典结构</strong>。</p><p>有很多高级的字典结构实现，例如我们 <strong>Java 中的 HashMap 底层实现，根据键的 Hash 值均匀的将键值对分散到数组中，并在遇到哈希冲突时，冲突的键值对通过单向链表串联，并在链表结构超过八个节点裂变成红黑树</strong>。</p><p>那么 redis 中是怎么实现的呢？我们一起来看一看。</p><h3 id="一、字典结构定义"><a href="#一、字典结构定义" class="headerlink" title="一、字典结构定义"></a>一、字典结构定义</h3><p>Redis 中的字典相关结构都定义在 dict.h 文件中，dict 表示一个字典结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><ul><li>type 字段指向 dictType 结构，这个结构中定义几个多态方法。</li><li>privdata 指针存储了字典结构一些附属额外信息。</li><li>ht 是一个 dictht 结构的数组，dictht 就是一个哈希表结构。</li><li>rehashidx 字段用于 rehash 过程中记录正在转移的键。</li><li>iterators 字段记录了当前字典正在进行中的迭代器。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010116.png" alt></p><p>dictType 具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><ul><li>hashFunction 哈希函数指针，当我们通过 set 命令往字典中存储数据时，会先用键值对的键作为参数传入哈希函数，得到一个较为散列均匀的值，然后才会实际的进行数据的存储。这里就会用到哈希函数，如果你需要为你的字典结构提供不同的散列方式，在初始化字典的时候为 dictType 中哈希函数进行一个实现就好。</li><li>keyDup 是一个键的复制函数。</li><li>valDup是一个键值对的值的复制函数。</li><li>keyCompare 是一个键的比较大小的函数。</li><li>keyDestructor 销毁一个键。</li><li>valDestructor 销毁一个键值对的值。都是一个多态的呈现，具体实现需要使用者自行提供。</li></ul><p>接着看 dict 结构，具体的再看。</p><p>dictht 就是我们的哈希表结构，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table 是一个指向 dictEntry 的二维数组，每个 dictEntry 其实就表述一个键值对，为什么是一个二维的结构呢？</p><p>其实正常情况下，我们的字典是这样保存数据的：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800ede0c3b2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>每个 dictEntry 内部会保存一个 key/value 的键值对，然后我们通过 table 指针可以遍历所有的键值对，但是如果某个键值对的键进行哈希之后并计算得到应该存储的位置被别的节点捷足先登了，也就是我们常说的哈希冲突了，怎么办？</p><p>redis 中的做法，甚至于大部分字典结构实现都是选择将冲突的节点串联成链表，于是字典结构就变成这样了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800ecf48bcfe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p><strong>同一条链表上的节点键的哈希值必定是相同的，也正是因为相同才会被串在一起</strong>，从逻辑上看，字典结构如上图所展示的那样，但抽象到我们的代码层，就是一个二维数组的结构，第一维放的就是节点指针的指针，第二维指向的就是指向我们键值对结构的指针，每一个 dictEntry 结构都会有一个 next 指针，在遇到哈希冲突的时候可以串联所有冲突节点。</p><p>除此之外，dictht 中的 size 属性用于描述整个哈希字典表最大可寻址大小，也就是二维数组中第一维度的最大长度，sizemask 属性始终等于 size-1 表述的是一种大小掩码的概念，用于确定节点最初在数组中的位置，used 记录了整张哈希表中已经存储的键值对节点数量。</p><p>其中，dict 字典结构中 ht 是一个只有两个元素的数组，<strong>正常情况下我们使用 ht[0] 字典表，ht[1] 用在我们渐进 rehash 过程中转移 ht[0] 中所有节点中</strong>。</p><p>最后，我们再来看这个 dictEntry 键值对结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>key 是一个指向任意结构的指针，代表我们的 key 可以使用我们 redis 中任意对象类型，v 是一个 union 类型，它可以是一个指针，也可以是 uint64_t 或 int64_t 类型，也可以是一个 double 类型。根据实际使用中，value 的不同值，使用不同的字段属性。</p><p>next 指针指向另一个 dictEntry 结构，用于发生哈希冲突时，链接下一个键值对节点。</p><p>以上就是 redis 中字典结构主要结构类型，从里至外封装了三层，dict 描述一个字典，其中的 dictht 描述哈希表，其中的 dictEntry 描述键值对结构。迭代器回头我们单独说说。</p><h3 id="二、渐进式-rehash-迁移数据"><a href="#二、渐进式-rehash-迁移数据" class="headerlink" title="二、渐进式 rehash 迁移数据"></a>二、渐进式 rehash 迁移数据</h3><p>redis 的 rehash 和 Java 以及其他哈希的实现稍微可能有点不同，由于 redis 是单线程的，不需要写大量的并发语句来保证数据一致性，但是单线程处理也会导致一次 rehash 过程会非常缓慢，客户端阻塞太久。那么 redis 具体是怎么做的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rehashidx 的值默认为 -1，表示当前字典未处于 rehash 阶段，其他场合该字段的值等于当前正在转移桶的索引。</p><p>新版本的 dictRehash 需要多传一个参数 n，这个参数用于控制单次最多转移空桶数量。什么意思呢，具体我们看一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800edea0e859?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>有这么一个字典结构，其中索引值为 2 和 3 的两个桶是空的，即里面没有放我们的键值对节点。正常情况下，一次 rehash 只会转移一个桶，但如果上一次转移了索引为 1 的那个桶，下一次来会遍历后面一个桶，如果继续为空就继续向后遍历，直到找到一个存储了我们节点的非空桶，极端情况下，如果字典表中只有最后一个桶有节点，那么一次的 rehash 就要遍历所有的桶，时间复杂度 O(n)，这会导致客户端等待过长时间，所以新版本中额外传一个参数 n 用于控制最多遍历的空桶数。</p><p>相关代码段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    d-&gt;rehashidx++;</span><br><span class="line">    <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的尾部会进行一个校验，如果当前桶转移结束后，当前字典的 rehash 过程完全结束，那么修改 ht[0] 指针引用，让他指向新的字典表 ht[1]，并设置 rehashidx 为 -1，标记整个字典 rehash 结束。</p><p>以上就是 redis 中 rehash 的全过程，还是比较简单的，那为什么说它是渐进式的呢，我们看一下添加和查询键值对的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们调用 set 命令，底层为我们添加键值对的方法，函数的最开头逻辑就是调用 dictIsRehashing 方法判断当前的字典表是否处于 rehash 状态，也即判断 rehashidx 是否不等于 -1 了。_dictRehashStep 方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，一次 rehash 过程，redis 允许最多 10 空桶的访问就要返回，不得逗留。<strong>值得注意的是，方法的后续逻辑会判断当前字典如果正在进行 rehash，那么新的键值对将不再向 ht[0] 中添加，而直接转而添加到 ht[1] 中</strong>。</p><p>我们再看看查询键值对的 get 命令底层 API 调用，底层会调用 dictFind 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，同样也是有 dictIsRehashing 方法的判断，如果字典处于 rehash 状态，即需要去完成一个桶的转移，然后才能返回。<strong>值得注意的是，方法的中间逻辑是嵌套在一个 for 循环中的，供两次循环，第一次从 ht[0] 中搜索我们给定 key 的键值对，如果没有找到，第二次循环将从 ht[1] 中搜索我们要查询的键值对。</strong></p><p>之所以说 redis 的 rehash 是渐进式的，就是因为即便它处于 rehash 状态下，所有节点的插入、查询甚至于删除都是不受影响的，直至整个 rehash 结束，redis 释放原先 ht[0] 占用无用内存。</p><p><em>ps：redis 中的字典实现相对于 Java 中的实现要简单不少，主要还是因为 redis 是单线程调用的，不需要使用额外的并发语句控制。</em></p><h3 id="三、字典迭代器"><a href="#三、字典迭代器" class="headerlink" title="三、字典迭代器"></a>三、字典迭代器</h3><p>迭代器是用于迭代遍历字典中所有的节点的一个工具，有两种，一种是安全迭代器，一种是不安全迭代器。安全迭代器就是指，你在迭代的过程中，允许你对字典结构进行修改，也即允许你添加、删除、修改字典中的键值对节点。不安全迭代器即不允许对字典中任何节点进行修改。</p><p>dictIterator 结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure><p>字段 d 指向一个即将被迭代的字典结构，index 记录了当前迭代到字典中的桶索引，table 取值为 0 或 1，表示当前迭代的是字典中哪个哈希表，safe 标记当前迭代器是安全的或是不安全的。 entry 记录的是当前迭代的节点，nextEntry 的值等于 entry 的 next 指针，用于防止当前节点接受删除操作后续节点丢失情况。fingerprint 保存了 dictFingerprint 函数根据当前字典的基本信息计算的一个指纹信息，稍有一丁点变动，指纹信息就会发生变化，用于不安全迭代器检验。</p><p>安全迭代器获取方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不安全迭代器获取方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看看迭代器的核心方法，dictNext 用于获取字典中下一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果迭代器初次工作，entry 必定为 null</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到迭代器 d 字段保存的字典</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    <span class="comment">//给字典的 iterators 字段自增，禁止 rehash操作</span></span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//计算并保存指纹信息</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//迭代器开始工作，指向 0 号桶</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">//如果 index 大于等于 size，即最后一个桶迭代结束</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//当前字典结构正在 rehash 且 ht[0] 已经遍历结束</span></span><br><span class="line">                    <span class="comment">//继续遍历 ht[1]</span></span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则表示迭代工作确实全部结束</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据 index 取出节点</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果 entry 不等于 null，尝试遍历它的后续节点</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里，迭代器已经拿到下一个节点了</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">//记录 nextEntry 节点的值</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分逻辑都已经注释上了，整个方法是一个死循环，如果 entry 等于 null，要么是迭代器初次工作，要么是迭代到一个桶的最后节点处了。如果是后者，会进入 if 逻辑中，判断是否整个字典全部迭代结束，如果不是取下一个桶。</p><p>如果字典未处于 rehash 状态，自增 iterators 属性的操作会禁止后续节点操作触发 rehash，如果已经处于 rehash 过程了，也不慌，当前 ht[0] 迭代结束后，再去迭代早于迭代器工作前已经被转移到 ht[1] 的那些节点。因为如果你是安全迭代器的话，iterators 一自增之后，后续节点就不会触发 rehash 迁移节点，所以不会重复迭代数据。</p><p>迭代器迭代结束之后需要释放关闭释放迭代器，redis 中对应方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">            iter-&gt;d-&gt;iterators--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d));</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是安全的迭代器，自减 iterators，不安全迭代器会重新计算指纹并与迭代器最开始工作时计算的指纹比较，并通过 assert 断言判断指纹是否一致，如果不一致则说明你在不安全的迭代器中执行了修改字典结构的方法，程序报错并退出。</p><p>以上就是 redis 字典中基础的两个安全与非安全迭代器用法及其原理，终究是不允许边 rehash 边遍历的，其实 redis 中还有一种高级遍历方式，大家叫它 scan 遍历，它允许边 rehash 边迭代，比较高级，我们后续会分析它的源码，敬请期待！</p><hr><h2 id="第四节-跳跃表"><a href="#第四节-跳跃表" class="headerlink" title="第四节 跳跃表"></a><strong>第四节 跳跃表</strong></h2><p>我们都知道单链表有一个致命的弱点，查找任一节点都至少 O(n) 的时间复杂度，它需要遍历一遍整个链表，那么有没有办法提升链表的搜索效率？</p><p>跳跃表（SkipList）这种数据结构使用空间换时间的策略，通过给链表建立多层索引来加快搜索效率，我们先介绍跳跃表的基本理论，再来看看 redis 中的实现情况。</p><h3 id="一、跳跃表（SkipList）"><a href="#一、跳跃表（SkipList）" class="headerlink" title="一、跳跃表（SkipList）"></a>一、跳跃表（SkipList）</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbffe59b8e16ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>这是一条带哨兵的双端链表，大部分场景下的链表都是这种结构，它的好处是，无论是头插法还是尾插法，插入操作都是常量级别的时间复杂度，删除也是一样。但缺点就是，如果想要查询某个节点，则需要 O(n)。</p><p>那如果我们给链表加一层索引呢？当然前提是最底层的链表是有序的，不然索引也没有意义了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbffe5a1111a7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>让 HEAD 头指针指向最高索引，我抽出来一层索引，这样即便你查找节点 2222 三次比较。</p><p>第一次：与 2019 节点比较，发现大于 2019，往后继续</p><p>第二次：与 2100 节点比较，发现依然大于，往后继续</p><p>第三次：本层索引到头了，指向低层索引的下一个节点，继续比较，找到节点</p><p>而无索引的链表需要四次，效率看起来不是很明显，但是随着链表节点数量增多，索引层级增多，效率差距会很明显。图就不自己画了，取自极客时间王争老师的一张图。</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;&quot; version=&quot;1.1&quot; width=&quot;1142&quot; height=&quot;636&quot;&gt;&lt;/svg" alt="image"></p><p>你看，原本需要 62 次比较操作，通过五层索引，只需要 4 次比较，跳跃表的效率可见一瞥。</p><p>想要知道具体跳跃表与链表差距多少，我们接下来进行它们各个操作的时间复杂度分析对比。</p><p><strong>1、插入节点操作</strong></p><p>双端链表（以下我们简称链表）的原本插入操作是 O(1) 的时间复杂度，但是这里我们讨论的是有序链表，所以插入一个节点至少还要找到它该插入的位置，然后才能执行插入操作，所以链表的插入效率是 O(n)。</p><p>跳跃表（以下我们简称跳表）也依然是需要两个步骤才能完成插入操作，先找到该插入的位置，再进行插入操作。我们设定一个具有 N 个节点的链表，它建有 K 层索引并假设每两个节点间隔就向上分裂一层索引。</p><p>k 层两个节点，k-1 层 4 个节点，k-2 层 8 个节点 … 第一层 n 个节点，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：n</span><br><span class="line"><span class="number">2</span>：<span class="number">1</span>/<span class="number">2</span> * n</span><br><span class="line"><span class="number">3</span>：<span class="number">1</span>/<span class="number">2</span>^<span class="number">2</span> * n</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">k：<span class="number">1</span>/<span class="number">2</span>^(k<span class="number">-1</span>) * n</span><br></pre></td></tr></table></figure><p>1/2^(k-1) <em> n 表示第 k 层节点数，1/2^(k-1) </em> n=2 可以得到，k 等于 logn，也就是说 ，N 个节点构建跳表将需要 logn 层索引，包括自身那层链表层。</p><p>而当我们要搜索某个节点时，需要从最高层索引开始，按照我们的构建方式，某个节点必然位于两个索引节点之间，所以每一层都最多访问三个节点。这一点你可能需要理解理解，因为每一层索引的搜索都是基于上一层索引的，从上一层索引下来，要么是大于（小于）当前的索引节点，但不会大于（小于）其往后两个位置的节点，也就是当前索引节点的上一层后一索引节点，所以它最多访问三个节点。</p><p>有了这一结论，我们向跳表中插入一个元素的时间复杂度就为：O(logn)。这个时间复杂度等于二分查找的时间复杂度，所有有时我们又称跳表是实现了二分查找的链表。</p><p>很明显，插入操作，跳表完胜链表。</p><p><strong>2、修改删除查询</strong></p><p>这三个节点操作其实没什么可比性，修改删除操作，链表等效于跳表。而查询，我们上面也说了，链表至少 O(n)，跳表在 O(logn)。</p><p>除此之外，我们都知道红黑树在每次插入节点后会自旋来进行树的平衡，那么跳表其实也会有这么一个问题，就是不断的插入，会导致底层链表节点疯狂增长，而索引层依然那么多，极端情况所有节点都新增到最后一级索引节点的右边，进而使跳表退化成链表。</p><p>简单一句话来说，就是大量的节点插入之后，而不更新索引的话，跳表将无法一如既往的保证效率。解决办法也很简单，就是每一次节点的插入，触发索引节点的更新，我们具体来看一下更新策略。</p><p>一般跳表会使用一个随机函数，这个随机函数会在跳表新增了一个节点后，根据跳表的目前结构生成一个随机数，这个数值当然要小于最大的索引层值，假定这个值等于 m，那么跳表会生成从 1 到 m 层的索引。所以这个随机函数的选择或者说实现就显得很重要了，关于它我们这里不做讨论，大家可以看看各种跳表的实现中是如何实现这个随机函数的，典型的就是 Java 中 ConcurrentSkipListMap 内部实现的 SkipList 结构，当然还有我们马上要介绍的 redis 中的实现。</p><p>以上就是跳表这种数据结构的基本理论内容，接下来我们看 redis 中的实现情况。</p><h3 id="二、Redis-中的跳跃表"><a href="#二、Redis-中的跳跃表" class="headerlink" title="二、Redis 中的跳跃表"></a>二、Redis 中的跳跃表</h3><p>说在前面的是，redis 自己实现了跳表，但目的是为它的有序集合等高层抽象数据结构提供服务，所以等下我们分析源代码的时候其中必然会涉及到一些看似无用的结构和代码逻辑，但那些也是非常重要的，我们也会提及有序集合相关的内容，但不会拆分细致，重点还是看跳表的实现。</p><p>跳表的数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳表中的每个节点用数据结构 zskiplistNode 表示，head 和 tail 分别指向最底层链表的头尾节点。length 表示当前跳表最底层链表有多少个节点，level 记录当前跳表最高索引层数。</p><p>zskiplistNode 结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>我这里摘取的 redis 源码是 4.0 版本的，以前版本 ele 属性是一个 RedisObject 类型，现在是一个字符串类型，也即表示跳表现在只用于存储字符串数据。</p><p>score 记录当前节点的一个分值，最底层的链表就是按照分值大小有序的串联的，并且我们查询一个节点，一般也会传入该节点的 score 值，毕竟数值类型比较起来方便。</p><p>backward 指针指向前一个节点，为什么是倒着往前，我们待会会说。</p><p>level 是比较关键的一个点，这里面是一个 level 数组，而每个元素又都是一个 zskiplistLevel 类型的结构，zskiplistLevel 类型包括一个 forward 前向指针，一个 span 跨度值，具体是什么意思，我们一点点说。</p><p>跳表理论上在最底层是一条双端链表，然后基于此建立了多层索引节点以实现的，但在实际的代码实现上，这种结构是不好表述的，所以你要打破既有的惯性思维，然后才能好理解 redis 中的实现。实际上正如我们上述介绍的 zskiplistNode 结构一样，<strong>每个节点除了存储节点自身的数据外，还通过 level 数组保存了该节点在整个跳表各个索引层的节点引用</strong>，具体结构就是这样的：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;216&quot; height=&quot;367&quot;&gt;&lt;/svg" alt="image"></p><p>而整张跳表基本就是这样的结构：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;554&quot;&gt;&lt;/svg" alt="image"></p><p>每一个节点的 backward 指针指向自己前面的一个节点，而每个节点中的 level 数组记录的就是当前节点在跳表的哪些索引层出现，并通过其 forward 指针顺序串联这一层索引的各个节点，0 表示第一层，1 表示第二层，等等以此类推。span 表示的是当前节点与后面一个节点的跨度，我们等下还会在代码里说到，暂时不理解也没关系。</p><p>基本上跳表就是这样一个结构，上面那张图还是很重要的，包括我们等下介绍源码实现，也对你理解有很大帮助的。（毕竟我画了半天。。）</p><p>这里多插一句，与跳表相关结构定义在一起的还有一个有序集合结构，很多人会说 redis 中的有序集合是跳表实现的，这句话不错，但有失偏驳。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    <span class="keyword">dict </span>*<span class="keyword">dict;</span></span><br><span class="line"><span class="keyword"> </span>   zskiplist *zsl<span class="comment">;</span></span><br><span class="line">&#125; zset<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>准确来说，redis 中的有序集合是由我们之前介绍过的字典加上跳表实现的，字典中保存的数据和分数 score 的映射关系，每次插入数据会从字典中查询，如果已经存在了，就不再插入，有序集合中是不允许重复数据。</p><p>下面我们看看 redis 中跳表的相关代码的实现情况。</p><p><strong>1、跳表初始化</strong></p><p>redis 中初始化一个跳表的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    <span class="comment">//分配内存空间</span></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">//默认只有一层索引</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//0 个节点</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1、创建一个 node 节点，这是个哨兵节点</span></span><br><span class="line">    <span class="comment">//2、为 level 数组分配 ZSKIPLIST_MAXLEVEL=32 内存大小</span></span><br><span class="line">    <span class="comment">//3、也即 redis 中支持索引最大 32 层</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//为哨兵节点的 level 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zslCreate 用于初始化一个跳表，比较简单，我也给出了基本的注释，这里不再赘述了，强调一点的是，redis 中实现的跳表最高允许 32 层索引，这么做也是一种性能与内存之间的衡量，过多的索引层必然占用更多的内存空间，32 是一个比较合适值。</p><p><strong>2、插入一个节点</strong></p><p>插入一个节点的代码比较多，也稍微有点复杂，希望你也有耐心和我一起来分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//update数组将用于记录新节点在每一层索引的目标插入位置</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">//rank数组记录目标节点每一层的排名</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">//指向哨兵节点</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//这一段就是遍历每一层索引，找到最后一个小于当前给定score值的节点</span></span><br><span class="line">    <span class="comment">//从高层索引向底层索引遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//rank记录的是节点的排名，正常情况下给它初始值等于上一层目标节点的排名</span></span><br><span class="line">        <span class="comment">//如果当前正在遍历最高层索引，那么这个初始值暂时给0</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//我们说过level结构中，span表示的是与后面一个节点的跨度</span></span><br><span class="line">            <span class="comment">//rank[i]最终会得到我们要找的目标节点的排名，也就是它前面有多少个节点</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            <span class="comment">//挪动指针</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此，update数组中已经记录好，每一层最后一个小于给定score值的节点</span></span><br><span class="line">    <span class="comment">//我们的新节点只需要插在他们后即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//random算法获取一个平衡跳表的level值，标志着我们的新节点将要在哪些索引出现</span></span><br><span class="line">    <span class="comment">//具体算法这里不做分析，你也可以私下找我讨论</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">//如果产生值大于当前跳表最高索引</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="comment">//为高出来的索引层赋初始值，update[i]指向哨兵节点</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据score和ele创建节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="comment">//每一索引层得进行新节点插入，建议对照我之前给出的跳表示意图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">//断开指针，插入新节点</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rank[0]等于新节点再最底层链表的排名，就是它前面有多少个节点</span></span><br><span class="line">        <span class="comment">//update[i]-&gt;level[i].span记录的是目标节点与后一个索引节点之间的跨度，即跨越了多少个节点</span></span><br><span class="line">        <span class="comment">//得到新插入节点与后一个索引节点之间的跨度</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        <span class="comment">//修改目标节点的span值</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果上面产生的平衡level大于跳表最高使用索引，我们上面说会为高出部分做初始化</span></span><br><span class="line">    <span class="comment">//这里是自增他们的span值，因为新插入了一个节点，跨度自然要增加</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改 backward 指针与 tail 指针</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个方法我都已经给出了注释，具体的不再细说，欢迎你与我交流讨论，整体的逻辑分为三个步骤。</p><ol><li>从最高索引层开始遍历，根据 score 找到它的前驱节点，用 update 数组进行保存</li><li>每一层得进行节点的插入，并计算更新 span 值</li><li>修改 backward 指针与 tail 指针</li></ol><p>删除节点也是类似的，首先需要根据 score 值找到目标节点，然后断开前后节点的连接，完成节点删除。</p><p><strong>3、特殊的查询操作</strong></p><p>因为 redis 的跳表实现中，增设了 span 这个跨度字段，它记录了与当前节点与后一个节点之间的跨度，所以就具有以下一些查询方法。</p><p><strong>a、zslGetRank</strong></p><p>返回包含给定成员和分值的节点在跳跃表中的排位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，这个方法的核心代码其实就是我们插入节点方法的一个部分，通过累计 span 得到目标节点的一个排名值。</p><p><strong>b、zslGetElementByRank</strong></p><p>通过给定排名查询元素。这个方法就更简单了。</p><p><strong>c、zslIsInRange</strong></p><p>给定一个分值范围（range）， 比如 0 到 10， 如果给定的分值范围包含在跳跃表的分值范围之内， 那么返回 1 ，否则返回 0 。</p><p><strong>d、zslFirstInRange</strong></p><p>给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点。</p><p><strong>e、zslDeleteRangeByScore</strong></p><p>给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点。</p><p><strong>f、zslDeleteRangeByRank</strong></p><p>给定一个排名范围， 删除跳跃表中所有在这个范围之内的节点。</p><p>其实，后面列出来的那些根据排名，甚至一个范围查询删除节点的方法，都仰仗的是 span 这个字段，这也是为什么 insert 方法中需要通过那么复杂的计算逻辑对 span 字段进行计算的一个原因。</p><p>总结一下，跳表是为有序集合服务的，通过多层索引把链表的搜索效率提升到 O(logn)级别，但修改删除依然是 O(1)，是一个较为优秀的数据结构，而 redis 中的实现把每个节点实现成类似楼房一样的结构，也即我们的索引层，非常的巧妙。</p><hr><h2 id="第五节-整数集合"><a href="#第五节-整数集合" class="headerlink" title="第五节 整数集合"></a><strong>第五节 整数集合</strong></h2><p>当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它的一个优点就是可以节省很多内存，虽然字典结构的效率很高，但是它的实现结构相对复杂并且会分配较多的内存空间。</p><p>而我们的整数集合（intset）可以做到使用较少的内存空间却达到和字典一样效率的实现，但也是前提的，集合中只能包含整型数据并且数量不能太多。整数集合最多能存多少个元素在 redis 中也是有体现的。</p><blockquote><p>OBJ_SET_MAX_INTSET_ENTRIES 512</p></blockquote><p>也就是超过 512 个元素，或者向集合中添加了字符串或其他数据结构，redis 会将整数集合向字典结构进行转换。</p><h3 id="一、基本的数据结构"><a href="#一、基本的数据结构" class="headerlink" title="一、基本的数据结构"></a>一、基本的数据结构</h3><p>intset 的结构定义很简单，有以下成员构成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents [];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>encoding 记录当前 intset 使用编码，有三个取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure><p>length 记录整数集合中目前存储了多少个元素，contents 记录我们实际的数据集合，虽然我们看到结构体中给数组元素的类型定死成 int8_t，但实际上这个 int8_t 定义的毫无意义，因为这里的处理方式非常规的数组操作，content 字段虽然被定义成指向一个 int8_t 类型数据的指针，但实际上 redis 无论是读取数组元素还是新增元素进去都依赖 encoding 和 length 两个字段直接操作的内存。</p><p>基本数据结构还是非常的简单的，下面我们来看看它的一些核心方法。</p><h3 id="二、核心-API-实现"><a href="#二、核心-API-实现" class="headerlink" title="二、核心 API 实现"></a>二、核心 API 实现</h3><p><strong>1、初始化一个 intset</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，默认的 inset 配置是使用 INTSET_ENC_INT16 作为数据存储大小，并且不会为 content 数组初始化。常规的数组需要先预先确定数组长度，然后分配内存，继而通过 contents[x] 可以访问数组中任一元素。</p><p>但是，inset 这里是非常规式操作数组，encoding 字段定义了数组中每个元素实际类型，lenth 字段定义了数组中实际的元素个数，那么 contents[x] 是失效的，这种方式只会按照 int8_t 进行内存偏移，这种方式是拿不到正确的数据的，所以 redis 中通过 memcpy 按照 encoding 字段的值暴力直接偏移地址操作内存读取数据。</p><p>所以，这也是为什么 intset 初始化时不初始化 content 数组的原因所在，因为没有必要。而每当新增一个元素的时候都会去动态扩容原数组的长度以盛放下新插入进来的元素，扩容不会扩容很多，刚好一个新元素所占用的内存即可。具体的细节，我们接着看。</p><p><strong>2、添加新元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算得到新插入的元素的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果大于 intset 目前存储元素的编码大小</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">//触发 intset 升级</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//二分搜索当前元素，如果元素已经存在会直接返回</span></span><br><span class="line">        <span class="comment">//如果没找到元素，pos 的值就是该元素的位置索引</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//resize 集合，扩容一个元素的内存空间</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//移动 pos 后面的元素，以插入我们的新元素</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此，我们应该知道为什么 intset 内的数据是有序且无重复的了，二分查找 O(logN)，但是 intset 插入一个元素却不是 O(logN)，因为有些情况会触发升级操作，或者极端情况下，会移动所有元素，时间复杂度达到 O(N)。</p><p><strong>3、升级</strong></p><p>我们先看示意图的变化，然后再分析源码，假设原 intset 使用 16 位的编码存储数据，先来了一个 32 位的数据，触发了我们的编码升级。</p><p>原 intset 结构如下：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;472&quot; height=&quot;187&quot;&gt;&lt;/svg" alt="image"></p><p>新 intset 结构会扩容成这样：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;537&quot; height=&quot;173&quot;&gt;&lt;/svg" alt="image"></p><p>虽然数据占用的内存已经分配好了，但是还需要做的是迁移每个元素占用的比特位。 做法是这样的，假设我们的新元素是 int_32 类型的数值 65536，那么首先我们会将这个 65536 放到[128-159]比特位区间，然后将 78 放到[96-127]比特位区间，并向前以此类推，最后我们会得到升级完成之后 intset。</p><p>下面我们看 redis 中代码的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//intset目前的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="comment">//intset即将扩展到的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据新的元素内存大小重新分配 intset 内存大小</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这个地方我先标记一下 @1，下面详细分析</span></span><br><span class="line">    <span class="comment">//总体上你可以理解，就是我们上图画的那样，从原集合的最后一个元素</span></span><br><span class="line">    <span class="comment">//开始扩大它占用的比特位</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新元素放进 intset 中</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别的不再解释，我重点解释一下我做标记的 @1，这个循环其实是这个方法的核心点，它完成了将旧元素扩充比特位这么一个操作。</p><p>首先明确的一点是，升级操作只有两种情况会触发，一种是新插入一个较大的数值，另一种是新插入一个负很大的值，这两种情况都会导致类型不够存储，需要扩大数据位。</p><p>_intsetGetEncoded 这个方法可以根据给定了 length，也就是元素在数组中的下标取出旧数组中对应的元素，很显然，这里是从后往前倒着来的。</p><p>因为我们的 intsetResize 方法已经完成了扩容内存的操作，也就是说新元素的内存已经分配完毕，那么 _intsetSet 方法就会将 _intsetGetEncoded 取出的元素重新的向数组中赋值。循环结束时，就是所有元素重新归位的时候，最后再将新元素赋值进入数组最后的位置。</p><p>但其实细心的同学会发现，_intsetSet 方法在传下标索引的时候实际传的是 length+prepend，这其实就是我们说，如果 value 是小于零的，length+prepend 最终会导致所有的旧元素往后挪了一个偏移量，然后新的元素会被赋值的索引为零的位置。也就是说，如果新插入的数值是负数，它会被头插进数组的第一个位置。</p><p>核心的几个 API 我们都已经介绍了，其他的一些 API 你可以自行参阅源码，相信对你不难。</p><p>总结一下，整数集合(intset)使用了非常简洁的数据结构，可以更少的占用内存存储一些整数，但终究是基于数组的，也就避免不了不能存储大量数据的缺点。总体来说，插入一个元素，最好情况 O(logN)，最坏的情况是 O(N)，摊还时间复杂度为 O(N)，查找一个元素，根据索引下标时间复杂度在 O(1)。当 intset 中的元素超过 512 个，或者向其中添加了字符串，redis 会将 intset 转换成字典。</p><hr><h2 id="第六节-压缩列表"><a href="#第六节-压缩列表" class="headerlink" title="第六节 压缩列表"></a><strong>第六节 压缩列表</strong></h2><p>上一篇我们介绍了 redis 中的整数集合这种数据结构的实现，也谈到了，引入这种数据结构的一个很大的原因就是，在某些仅有少量整数元素的集合场景，通过整数集合既可以达到字典的效率，也能使用远少于字典的内存达到同样的效果。</p><p>我们本篇介绍的压缩列表，相信你从他的名字里应该也能看出来，又是一个为了节约内存而设计的数据结构，它的数据结构相对于整数集合来说会复杂了很多，但是整数集合只能允许存储少量的整型数据，而我们的压缩列表可以允许存储少量的整型数据或字符串。</p><p>这是他们之间的一个区别，下面我们来看看这种数据结构。</p><h3 id="一、基本的结构定义"><a href="#一、基本的结构定义" class="headerlink" title="一、基本的结构定义"></a>一、基本的结构定义</h3><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a764ad1fcd3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><ul><li>ZIPLIST_BYTES：四个字节，记录了整个压缩列表总共占用了多少字节数</li><li>ZIPLIST_TAIL_OFFSET：四个字节，记录了整个压缩列表第一个节点到最后一个节点跨越了多少个字节，通故这个字段可以迅速定位到列表最后一个节点位置</li><li>ZIPLIST_LENGTH：两个字节，记录了整个压缩列表中总共包含几个 zlentry 节点</li><li>zlentry：非固定字节，记录的是单个节点，这是一个复合结构，我们等下再说</li><li>0xFF：一个字节，十进制的值为 255，标志压缩列表的结尾</li></ul><p>其中，zlentry 在 redis 中确实有着这样的结构体定义，但实际上这个结构定义了一堆类似于 length 这样的字段，记录前一个节点和自身节点占用的字节数等等信息，用处不多，而我们更倾向于使用这样的逻辑结构来描述 zlentry 节点。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a764b42d99f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>这种结构在 redis 中是没有具体结构体定义的，请知悉，网上的很多博客文章都直接描述 zlentry 节点是这样的一种结构，其实是不准确的。</p><p>简单解释一下这三个字段的含义：</p><ul><li>previous_entry_length：每个节点会使用一个或者五个字节来描述前一个节点占用的总字节数，如果前一个节点占用的总字节数小于 254，那么就用一个字节存储，反之如果前一个节点占用的总字节数超过了 254，那么一个字节就不够存储了，这里会用五个字节存储并将第一个字节的值存储为固定值 254 用于区分。</li><li>encoding：压缩列表可以存储 16位、32位、64位的整数以及字符串，encoding 就是用来区分后面的 content 字段中存储于的到底是哪种内容，分别占多少字节，这个我们等下细说。</li><li>content：没什么特别的，存储的就是具体的二进制内容，整数或者字符串。</li></ul><p>下面我们细说一个 encoding 具体是怎么存储的。</p><p>主要分为两种，一种是字符串的存储格式：</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content类型</th></tr></thead><tbody><tr><td>00xxxxxx</td><td>一个字节</td><td>长度小于 63 的字符串</td></tr><tr><td>01xxxxxx xxxxxxxx</td><td>两个字节</td><td>长度小于 16383 的字符串</td></tr><tr><td>10xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</td><td>五个字节</td><td>长度小于 4294967295 的字符串</td></tr></tbody></table><p>content 的具体长度，由编码除去高两位剩余的二进制位表示。</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content类型</th></tr></thead><tbody><tr><td>11000000</td><td>一个字节</td><td>int16_t 类型的整数</td></tr><tr><td>11010000</td><td>一个字节</td><td>int32_t 类型的整数</td></tr><tr><td>11100000</td><td>一个字节</td><td>int64_t 类型的整数</td></tr><tr><td>11110000</td><td>一个字节</td><td>24 位有符号整数</td></tr><tr><td>11111110</td><td>一个字节</td><td>8 位有符号整数</td></tr></tbody></table><p>注意，整型数据的编码是固定 11 开头的八位二进制，而字符串类型的编码都是非固定的，因为它还需要通过后面的二进制位得到字符串的长度，稍有区别。</p><p>这就是压缩列表的基本的结构定义情况，下面我们通过节点的增删改查方法源码实现来看看 redis 中具体的实现情况。</p><h3 id="二、redis-的具体源码实现"><a href="#二、redis-的具体源码实现" class="headerlink" title="二、redis 的具体源码实现"></a>二、redis 的具体源码实现</h3><p><strong>1、ziplistNew</strong></p><p>我们先来看看压缩列表初始化的方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//bytes=2*4+2</span></span><br><span class="line">    <span class="comment">//分配压缩列表结构所需要的字节数</span></span><br><span class="line">    <span class="comment">//ZIPLIST_BYTES + ZIPLIST_TAIL_OFFSET + ZIPLIST_LENGTH</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_BYTES 字段</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_TAIL_OFFSET</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_LENGTH 字段</span></span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为压缩列表最后一个字节赋值 255</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、ziplistPush</strong></p><p>接着我们看新增节点的源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s</span></span></span><br><span class="line"><span class="function"><span class="params">        ,<span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">//找到待插入的位置，头部或者尾部</span></span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下 ziplistPush 的几个入参的含义。</p><p>zl 指向一个压缩列表的首地址，s 指向一个字符串首地址），slen 指向字符串的长度（如果节点存储的值是整型，存储的就是整型值），where 指明新节点的插入方式，头插亦或尾插。</p><p>ziplistPush 方法的核心是 __ziplistInsert：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; </span><br><span class="line">    zlentry tail;</span><br><span class="line">    <span class="comment">//prevlensize 存储前一个节点长度，本节点使用了几个字节 1 or 5</span></span><br><span class="line">    <span class="comment">//prelen  存储前一个节点实际占用了几个字节</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">//s 指针指向一个整数，尝试进行一个转换并得到存储这个整数占用了几个字节</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//s 指针指向一个字符串（字符数组），slen 就是他占用的字节数</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前节点存储数据占用 reqlen 个字节，加上存储前一个节点长度占用的字节数</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">//encoding 字段存储实际占用字节数</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line">    <span class="comment">//至此，reqlen 保存了存储当前节点数据占用字节数和 encoding 编码占用的字节数总和</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前节点占用的总字节减去存储前一个节点字段占用的字节</span></span><br><span class="line">    <span class="comment">//记录的是这一个节点的插入会引起下一个节点占用字节的变化量</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容有可能导致 zl 的起始位置偏移，故记录 p 与 zl 首地址的相对偏差数，事后还原 p 指针指向</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line">        <span class="comment">//把当前节点占用的字节数存储到下一个节点的头部字段</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新 tail_offset 字段，让他保存从头节点到尾节点之间的距离</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否触发连锁更新</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将节点写入指定位置</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体细节我不再赘述，总结一下整个插入节点的步骤。</p><ol><li>计算并得到前一个节点的总长度，并判断得到当前待插入节点保存前一个节点长度的 previous_entry_length 占用字节数</li><li>根据传入的 s 和 slen，计算并保存 encoding 字段内容</li><li>构建节点并将数据写入节点添加到压缩列表中</li></ol><p><em>ps：重点要去理解压缩列表节点的数据结构定义，previous_entry_length、encoding、content 字段，这样才能比较容易理解节点新增操作的实现。</em></p><h3 id="三、连锁更新"><a href="#三、连锁更新" class="headerlink" title="三、连锁更新"></a>三、连锁更新</h3><p>谈到 redis 的压缩列表，就必然会谈到他的连锁更新，我们先引一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a76497a20d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>假设原本 entry1 节点占用字节数为 211（小于 254），那么 entry2 的 previous_entry_length 会使用一个字节存储 211，现在我们新插入一个节点 NEWEntry，这个节点比较大，占用了 512 个字节。</p><p>那么，我们知道，NEWEntry 节点插入后，entry2 的 previous_entry_length 存储不了 512，那么 redis 就会重分配内存，增加 entry2 的内存分配，并分配给 previous_entry_length 五个字节存储 NEWEntry 节点长度。</p><p>看似没什么问题，但是如果极端情况下，entry2 扩容四个字节后，导致自身占用字节数超过 254，就会又触发后一个节点的内存占用空间扩大，非常极端情况下，会导致所有的节点都扩容，这就是连锁更新，一次更新导致大量甚至全部节点都更新内存的分配。</p><p>如果连锁更新发生的概率很高的话，压缩列表无疑就会是一个低效的数据结构，但实际上连锁更新发生的条件是非常苛刻的，其一是需要大量节点长度小于 254 连续串联连接，其二是我们更新的节点位置恰好也导致后一个节点内存扩充更新。</p><p>基于这两点，且少量的连锁更新对性能是影响不大的，所以这里的连锁更新对压缩列表的性能是没有多大的影响的，可以忽略，但需要知晓。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><blockquote><p><a href="https://juejin.im/post/5d7dac02518825297023fb35" target="_blank" rel="noopener">Redis 的底层数据结构（SDS和链表）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5d872b41f265da03ec2ea091" target="_blank" rel="noopener">Redis 的底层数据结构（字典）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5da1ca58e51d4577fc7b1c5a" target="_blank" rel="noopener">Redis 的底层数据结构（跳跃表）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5dac52a96fb9a04e2d36c9ec" target="_blank" rel="noopener">Redis 的底层数据结构（整数集合）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5dcbf185f265da3072427647" target="_blank" rel="noopener">Redis 的底层数据结构（压缩列表）</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理Redis中的几种常见的底层数据结构，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度</title>
    <link href="http://linyishui.top/2020061801.html"/>
    <id>http://linyishui.top/2020061801.html</id>
    <published>2020-06-18T11:03:47.000Z</published>
    <updated>2020-08-04T06:33:02.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p><strong>时间复杂度</strong>是一个函数，用于描述算法的运行时间。常用大O符号表示，如 <code>O(n)</code> 。时间复杂度可以被称为是<strong>渐进的</strong>，即考察输入值趋近于无穷时的情况，如一个算法对于任意数量n的输入，需要 5n^3^ + 3n 的时间运行完毕，则其渐进时间复杂度为 O(n^3^) 。</p><p>即使相同数目大小的不同输入值仍可能导致算法的运行时间不同，所以<strong>通常使用算法的最坏情况复杂度</strong>，即 <code>T(n)</code> 。</p><h3 id="1-1-常见时间复杂度"><a href="#1-1-常见时间复杂度" class="headerlink" title="1.1 常见时间复杂度"></a><strong>1.1 常见时间复杂度</strong></h3><ul><li>O(n^3^)：矩阵乘法的基础实现。</li><li>O(n^2^)：冒泡排序、插入排序。</li><li>O(loglogn)：有界优先队列的单个操作。</li><li>O(nlogn)：最快的比较排序。</li><li>O(logn)：二分搜索。</li><li>O(n)：无序数组的搜索。</li><li>O(1)：奇偶判断。</li></ul><p>对于时间复杂度中的对数表达式，一般默认底数为2（计算机偏爱2?），所以 logn 即 log~2~n。</p><h2 id="第二节-计算时间复杂度"><a href="#第二节-计算时间复杂度" class="headerlink" title="第二节 计算时间复杂度"></a><strong>第二节 计算时间复杂度</strong></h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a><strong>2.1 步骤</strong></h3><ol><li>找出算法中的基本语句。<ul><li>基本语句即执行次数最多的语句，通常指最内层循环。</li></ul></li><li>计算基本语句的执行次数的数量级。<ul><li>可忽略所有的低次幂和高次幂的系数。</li></ul></li><li>用大O记号表示算法的时间性能。</li></ol><h3 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2 实例"></a><strong>2.2 实例</strong></h3><h4 id="（1）单层和双层循环"><a href="#（1）单层和双层循环" class="headerlink" title="（1）单层和双层循环"></a><strong>（1）单层和双层循环</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">       x++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">       x++;</span><br></pre></td></tr></table></figure><p>两种基本语句都是最内层循环 <code>x++;</code> 。</p><p>单层循环执行了 n 次，双层循环执行了 n^2^ 次。</p><p>所以二者的时间复杂度分别为 O(n) 和 O(N^2^) 。</p><h4 id="（2）循环乘2"><a href="#（2）循环乘2" class="headerlink" title="（2）循环乘2"></a><strong>（2）循环乘2</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">       i = i * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>基本语句 <code>i = i * 2;</code> ，设y为其执行次数，则 2^y^ &lt;= n ，即 y &lt;= log~2~n 。</p><p>所以 T(n) = O(log~2~n) 。</p><h4 id="（3）冒泡排序"><a href="#（3）冒泡排序" class="headerlink" title="（3）冒泡排序"></a><strong>（3）冒泡排序</strong></h4><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="comment">// 比较两个元素大小，若前大于后则交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句即比较操作 <code>arr[j] &gt; arr[j + 1]</code> ，其运行次数为 (n - 1) + (n - 2) + … + 2 + 1  = n (n - 1) / 2 = n^2^ / 2 。所以时间复杂度为 O(n^2^) 。</p><h4 id="（4）选择排序"><a href="#（4）选择排序" class="headerlink" title="（4）选择排序"></a><strong>（4）选择排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;<span class="comment">//将数组a按升序排序</span></span><br><span class="line">    <span class="keyword">int</span> N = a.length;<span class="comment">//记录数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;<span class="comment">//将a[i]与a[i+1...N]最小元素交换</span></span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//循环遍历找到当前最小元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; N;j++)</span><br><span class="line">            <span class="keyword">if</span>(less(a[j],a[min])) min = j;</span><br><span class="line">        <span class="comment">//将第i小元素交换至位置i</span></span><br><span class="line">        exch(a,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>min = j;</code> ，其运行次数为 (n - 1) + (n - 2) + … + 2 + 1 = n (n - 1) / 2 = n^2^ / 2 。</p><p>所以时间复杂度为 O(n^2^) 。</p><h4 id="（5）插入排序"><a href="#（5）插入排序" class="headerlink" title="（5）插入排序"></a><strong>（5）插入排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)&#123;</span><br><span class="line">    <span class="comment">// 第二层游标j从游标i开始，逆向遍历，不断和比其小的元素交换位置，直到移动到0位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span> &amp;&amp; less(a[j],a[j-<span class="number">1</span>]);j--)</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>less(a[j],a[j-1])</code> ，其运行次数为 1 + 2 + … + (n - 2) +  (n - 1) = n (n - 1) / 2 = n^2^ / 2 。</p><p>所以时间复杂度为 O(n^2^) 。</p><h4 id="（6）希尔排序"><a href="#（6）希尔排序" class="headerlink" title="（6）希尔排序"></a><strong>（6）希尔排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> H = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 根据元素数目初始化H：1、4、13、40、121...</span></span><br><span class="line">    <span class="keyword">while</span> (H &lt; N/<span class="number">3</span>)</span><br><span class="line">        H = <span class="number">3</span>*H + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//同插入排序，但游标不是相邻移动，而是间隔H，将a[i]插入到a[i-H],a[i-2H]...之中</span></span><br><span class="line">    <span class="keyword">while</span> (H &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 游标i从H开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = H;i &lt; N;i++)&#123;</span><br><span class="line">        <span class="comment">// 游标j仍从游标i开始，逆向隔H遍历，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;=H &amp;&amp; less(a[j],a[j-H]);j-=H)<span class="comment">//</span></span><br><span class="line">                exch(a,j,j-H);</span><br><span class="line">        &#125;</span><br><span class="line">        H = H/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>less(a[j],a[j-H])</code> ，希尔排序的性能论证十分复杂，目前的结论是其运行时间达不到平方级别，运行次数本人目前浅陋的数学水平无法归纳，根据书本和互联网获得的答案是<strong>平均时间复杂度为 O(nlogn) </strong>，<strong>最坏情况大概与 N^(3/2)^ 成正比</strong>，相比插入排序一点微小的改变就突破了平方的屏障，这正是算法设计的目标。</p><p>所以时间复杂度为 O(nlogn) 。</p><h4 id="（7）归并排序"><a href="#（7）归并排序" class="headerlink" title="（7）归并排序"></a><strong>（7）归并排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> <span class="keyword">extends</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] a = RandomUtil.getRandomIndex(<span class="number">10000</span>);</span><br><span class="line">        Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(stopwatch.elapseTime());</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原地归并的抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将a[lo,mid]与a[mid+1,hi]归并，两个数组是有序的</span></span><br><span class="line">        <span class="keyword">int</span> i = lo,j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先将所有元素复制到aux[]中，再归并到a[]中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo;k &lt;= hi;k++)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        <span class="comment">//用i,j指针分别游离于两数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]; <span class="comment">//左边下标已结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];<span class="comment">//右边下标已结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j],aux[i])) a[k] = aux[j++];<span class="comment">//两数组的指针比较当前大小，前者较小</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自顶向下的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">//归并所需的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];<span class="comment">//一次性分配空间</span></span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组a排序，递归排序，sort的作用为以正确的顺序调用merge方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);      <span class="comment">// 将左半边排序</span></span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);    <span class="comment">// 将右半边排序</span></span><br><span class="line">        merge(a,lo,mid,hi);  <span class="comment">// 归并结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBottomUp</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 进行lgN次两两归并</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N ;sz = sz + sz) <span class="comment">//sz-子数组大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz;lo+=sz+sz) <span class="comment">//子数组索引</span></span><br><span class="line">                merge(a,lo,lo+sz-<span class="number">1</span>,Math.min(lo+sz+sz-<span class="number">1</span>,N-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于长度为N的任意数组，自顶向下的归并排序需要 <code>1/2NlgN</code> 至 <code>NlgN</code> 次比较，并且最多需要访问数组 <code>6NlgN</code> 次</strong>。</p><p><strong>归并排序所需时间与 <code>NlgN</code> 成正比</strong>，这相比前几个排序要快很多（指数级），只需要比遍历整个数组多个对数因子的时间就可以将一个庞大的数组排序。</p><p><strong>对于长度为N的任意数组，自底向上的归并排序需要 <code>1/2NlgN</code> 至 <code>NlgN</code> 次比较，最多访问数组 <code>6NlgN</code> 次</strong>。</p><p>所以时间复杂度为 O(nlogn) 。</p><h4 id="（8）快速排序"><a href="#（8）快速排序" class="headerlink" title="（8）快速排序"></a><strong>（8）快速排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//消除对输入的依赖，需要在这里把元素随机分布一下</span></span><br><span class="line">        StdRandom.shuffle(a);</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当左右游标相等，表示已对最小数组排序，结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//将左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切分数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo,j = hi + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        Comparable v = a[lo];  </span><br><span class="line">        <span class="comment">//扫描左右，检查扫描是否结束并交换元素，遍历结束后数组被切分为两部分，一边小于切分元素，一边大于切分元素</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//循环遍历直到找到大于v元素或游标到底</span></span><br><span class="line">            <span class="keyword">while</span>(less(a[++i],v))</span><br><span class="line">                <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//循环遍历直到找到小于v元素或游标到头</span></span><br><span class="line">            <span class="keyword">while</span>(less(v,a[--j]))</span><br><span class="line">                <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若游标交叉则表示以遍历所有元素，结束</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换两边元素</span></span><br><span class="line">            exch(a,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将v=a[j]放入正确位置</span></span><br><span class="line">        exch(a,lo,j); </span><br><span class="line">        <span class="comment">//a[lo...j-1] &lt;= a[j] &lt;= a[j+1...hi] 达成</span></span><br><span class="line">        <span class="keyword">return</span> j;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以时间复杂度为 O(nlogn) 。</p><p>T(n) = O(n^2^)</p><blockquote><p>命题：<strong>将长度为N的无重复元素数组排序，快速排序平均需要 ~ <code>2NlnN</code> 次比较，以及 <code>1/6</code> 的交换</strong>。</p><p>证明：<code>CN</code> 为将N个不同元素排序平均所需的比较次数。很明显 <code>C0</code> = <code>C1</code> = 0，对于 <code>N &gt; 1</code> ，由递归程序可以得到以下归纳关系：</p><p> CN = N + 1 + (C0 + C1 + … + C(N-2) + C(N-1)) / N + (C(N-1) + C(N-2) + … + C0) / N</p><p>第一项是切分的成本（总是N+1），第二项是将左子数组排序的平均成本，第三项是将右子数组（长度和左子数组相同）排序的平均成本。将等式左右两边乘以N并整理各项得到：</p><p> NCN = N (N + 1) + 2(C0 + C1 + … + C(N-2) + C(N-1))</p><p>将该等式减去 <code>N - 1</code> 时的相同等式可得：</p><p> NCN - (N - 1)C(N - 1) = 2N + 2C(N - 1)</p><p>整理等式并将两边除以 <code>N(N + 1)</code> 可得：</p><p> CN / (N + 1) = C(N - 1) / N + 2 / (N + 1)</p><p>归纳法推导可得：</p><p> CN ~ 2(N + 1)(1/3 + 1/4 + … + 1 / (N + 1))</p><p>括号内的量是曲线 <code>2 / x</code> 下从3到N的离散近似面积加一，积分得到 <code>CN ~ 2NlnN</code> 。注意 <code>2NlnN</code> ≈ <code>1.39NlgN</code> ，也就是说平均比较次数只比最好情况多39%。</p></blockquote><blockquote><p>命题：<strong>快速排序最多需要 <code>N^2/2</code> 次比较，但随机打乱数组能够预防这种情况。</strong></p><p>证明：在每次切分后两个子数组之一总是空的情况下，比较次数为：</p><p> N + (N - 1) + … + (N - 2) + 2 + 1 = (N + 1) N / 2</p><p>这说明了算法所需时间为平方级别，所需空间是线性的，而这对于大数组来说是不可接受的。比较次数的标准差为0.65N，因此随着N的增大，运行时间会趋于平均数，且不可能与平均数偏差太大。</p></blockquote><h4 id="（9）堆排序"><a href="#（9）堆排序" class="headerlink" title="（9）堆排序"></a><strong>（9）堆排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Set</span> <span class="keyword">extends</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparable[] sort(Comparable[] c)&#123;</span><br><span class="line">        Comparable[] a = <span class="keyword">new</span> Comparable[c.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> N = c.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">            a[i+<span class="number">1</span>] = c[i];</span><br><span class="line">        <span class="comment">// for循环构造堆，sink方法将a从1到N排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(a,k,N);</span><br><span class="line">        show(a);</span><br><span class="line">        <span class="comment">// while循环将最大元素a[1]和a[N]交换，并修复堆</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            exch(a,<span class="number">1</span>,N--);</span><br><span class="line">            sink(a,<span class="number">1</span>,N);</span><br><span class="line">            show(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;<span class="comment">//循环判断条件，k&gt;1,父结点的值比当前小</span></span><br><span class="line">            <span class="comment">//交换当前结点和父结点的值，以及当前游标所指下标</span></span><br><span class="line">            exch(a,k/<span class="number">2</span>,k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;<span class="comment">//循环判断条件，当前游标所指有子结点存在</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">//当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; N &amp;&amp; less(a[j],a[j+<span class="number">1</span>]))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//如果当前结点比子结点大就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(!less(a[k],a[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换，更新游标</span></span><br><span class="line">            exch(a,k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Integer[] a = RandomUtil.getRandomIndex(10000);</span></span><br><span class="line">        Comparable[] a = &#123;<span class="string">'S'</span>,<span class="string">'O'</span>,<span class="string">'R'</span>,<span class="string">'T'</span>,<span class="string">'E'</span>,<span class="string">'X'</span>,<span class="string">'A'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>,<span class="string">'L'</span>,<span class="string">'E'</span>&#125;;</span><br><span class="line">        Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        a = sort(a);</span><br><span class="line">        System.out.println(stopwatch.elapseTime());</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将N个元素排序，堆排序只需要少于 <code>2NlgN + 2N</code> 次比较，以及一半次数的交换</strong>。</p><p>所以时间复杂度为 O(nlogn) 。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">时间复杂度- 维基百科</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/21387264" target="_blank" rel="noopener">如何理解算法时间复杂度的表示法，例如 O(n²)、O(n)、O(1)、O(nlogn) 等</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BlockingQueue（未完成）</title>
    <link href="http://linyishui.top/2020061401.html"/>
    <id>http://linyishui.top/2020061401.html</id>
    <published>2020-06-14T13:41:26.000Z</published>
    <updated>2020-07-26T14:53:33.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><strong>BlockingQueue</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>并发包 <code>java.util.concurrent</code> 提供了阻塞队列系列，顶层接口 <code>BlockingQueue</code> ，相关实现类：</p><ul><li>ArrayBlockingQueue：基于数组的有界阻塞队列。</li><li>LinkedBlockingQueue：基于链表的阻塞队列。</li><li>DelayQueue：延迟队列。</li><li>SynchronousQueue：同步队列。</li><li>PriorityBlockingQueue：优先阻塞队列。</li></ul>]]></content>
    
    <summary type="html">
    
      简单整理Java并发包中阻塞队列BlockingQueue相关内容，包括：概述，API，ArrayBlockingQueue，LinkedBlockingQueue等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList的实现原理</title>
    <link href="http://linyishui.top/2020060501.html"/>
    <id>http://linyishui.top/2020060501.html</id>
    <published>2020-06-05T14:27:02.000Z</published>
    <updated>2020-07-23T09:09:32.847Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><strong>CopyOnWriteArrayList</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-为什么需要CopyOnWriteArrayList？"><a href="#1-1-为什么需要CopyOnWriteArrayList？" class="headerlink" title="1.1 为什么需要CopyOnWriteArrayList？"></a><strong>1.1 为什么需要CopyOnWriteArrayList？</strong></h3><p><strong>多读场景需要高效的并发数组</strong>。</p><p>常用的 <code>ArrayList</code> 不是一个线程安全的集合，基于快速失败机制，多线程操作会抛出 <code>ConcurrentModificationException</code> ，而线程安全的  <code>Vector</code> 又因为低效的设计而被弃用，又或者 <code>Collections.synchronizedList()</code> 来获取一个包装的线程安全类，与前者一样使用 <code>synchronized</code> 来保证的线程安全。</p><p> <code>synchronized</code> 这种独占锁在同一时刻只能有一个线程拥有对象监视器，对于大部分<strong>读多写少的业务场景</strong>并不适用。针对这种场景而设计的读写锁 <code>ReentrantReadWriteLock</code> 是一个合适的选择。</p><p>如果只是在 <code>List</code> 上封装一层读写锁，读数据仍会被其他操作阻塞，所以需要并发包提供的 <code>CopyOnWriteArrayList</code> 。</p><h3 id="1-2-什么是CopyOnWrite？"><a href="#1-2-什么是CopyOnWrite？" class="headerlink" title="1.2 什么是CopyOnWrite？"></a><strong>1.2 什么是CopyOnWrite？</strong></h3><p><code>CopyOnWrite</code>（COW）即<strong>写时复制</strong>，通过延迟更新的策略来实现数据一致性，并且能保证线程间不阻塞。</p><p>通俗的讲就是在向容器添加元素时，并非直接向容器内添加，而是先将当前容器进行Copy，复制出一个新容器，然后向新容器添加元素，完成后再将指向旧容器的引用指向新容器。</p><p>这一过程的优势就是在进行并发的读操作时不用加锁，因为旧容器并不改变，所以<strong>写时复制也是一种读写分离的思想</strong>，通过放弃数据的实时性来达到数据一致性，获得的是提高并发性。</p><h3 id="1-3-写时复制和读写锁的区别？"><a href="#1-3-写时复制和读写锁的区别？" class="headerlink" title="1.3 写时复制和读写锁的区别？"></a><strong>1.3 写时复制和读写锁的区别？</strong></h3><ul><li><p>相同点：两者都是通过读写分离思想实现，都实现了读线程间互不阻塞。</p></li><li><p>不同点：使用读写锁依然会存在线程阻塞等待的情况，而COW则牺牲了数据实时性，保证读线程不会存在等待。</p></li></ul><p>读写锁中，读线程为了实现数据实时性，在写锁被获取时，读线程会等待。而写时复制中虽然写线程最终的修改结果可以被读线程感知，但有一定延迟。</p><h2 id="第二节-实现原理"><a href="#第二节-实现原理" class="headerlink" title="第二节 实现原理"></a><strong>第二节 实现原理</strong></h2><h3 id="2-1-基本结构"><a href="#2-1-基本结构" class="headerlink" title="2.1 基本结构"></a><strong>2.1 基本结构</strong></h3><p>根据其接口实现 <code>RandomAccess</code> 就可得知，其底层为数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过可重入锁 <code>ReentrantLock</code> 来保证线程安全，通过 <code>volatile</code> 修饰底层数组来保证可见性。 </p><h3 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get"></a><strong>2.2 get</strong></h3><p><code>get()</code> 方法源码如下，读操作不需要考虑并发安全，直接通过数组索引获取元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Positional Access Operations</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-add"><a href="#2-3-add" class="headerlink" title="2.3 add"></a><strong>2.3 add</strong></h3><p><code>add()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.首先获取Lock，保证写操作线程安全</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.获取旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 3.通过Arrays.copyOf进行数组浅复制扩容，底层是通过调用System.arraycopy()进行数组的浅拷贝</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 4.将新元素添加到新数组的末尾</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 5.指向新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现核心主要是：</p><ol><li>通过 <code>ReentrantLock</code> 保证同一时刻只有一个写线程在进行数组的复制，否则会导致内存中存在多份复制数组。</li><li><code>volatile</code> 修饰的底层数组，根据 <code>happens-before</code> 规则，写线程对数组引用的修改对读线程是可见的。</li></ol><p><code>add()</code> 还有重载方法，指定位置添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 末尾添加，直接拷贝生成新数组</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非末尾，先构建新数组，再通过System.arraycopy错位复制</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 第一次复制源数组下标0-index的元素</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 第二次复制源数组index-end的元素，错位复制到新数组，此步完成后index元素重复一次</span></span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新元素</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        <span class="comment">// 更新引用</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心就是通过 <code>System.arraycopy()</code> 进行错位复制。</p><h3 id="2-4-set"><a href="#2-4-set" class="headerlink" title="2.4 set"></a><strong>2.4 set</strong></h3><p><code>set()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 先获取旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="comment">// 仍通过浅复制进行替换</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 旧值等价于新值，不需要替换，此处只更新一下引用</span></span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-remove"><a href="#2-5-remove" class="headerlink" title="2.5 remove"></a><strong>2.5 remove</strong></h3><p><code>remove()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).  Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If this list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &#123;<span class="doctag">@code</span> true&#125; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">int</span> index = indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A version of remove(Object) using the strong hint that given</span></span><br><span class="line"><span class="comment"> * recent snapshot contains o at the given index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o, Object[] snapshot, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123;</span><br><span class="line">            <span class="keyword">int</span> prefix = Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span> findIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (current[index] == o)</span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">            index = indexOf(o, current, index, len);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>,</span><br><span class="line">                         newElements, index,</span><br><span class="line">                         len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes from this list all of the elements whose index is between</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="doctag">@code</span> toIndex&#125;, exclusive.</span></span><br><span class="line"><span class="comment"> * Shifts any succeeding elements to the left (reduces their index).</span></span><br><span class="line"><span class="comment"> * This call shortens the list by &#123;<span class="doctag">@code</span> (toIndex - fromIndex)&#125; elements.</span></span><br><span class="line"><span class="comment"> * (If &#123;<span class="doctag">@code</span> toIndex==fromIndex&#125;, this operation has no effect.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex index of first element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex index after last element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if fromIndex or toIndex out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> fromIndex &lt; 0 || toIndex &gt; size() || toIndex &lt; fromIndex&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || toIndex &lt; fromIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">int</span> newlen = len - (toIndex - fromIndex);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - toIndex;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, newlen));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[newlen];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, fromIndex);</span><br><span class="line">            System.arraycopy(elements, toIndex, newElements,</span><br><span class="line">                             fromIndex, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>set()</code> 、<code>add()</code> 等方法一样，<code>remove()</code> 仍通过数组浅复制进行删除操作，主要是错位复制。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><blockquote><p><a href="https://juejin.im/post/5aeeb55f5188256715478c21#heading-4" target="_blank" rel="noopener">并发容器之CopyOnWriteArrayList</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了一下CopyOnWriteArrayList的相关内容，主要内容包括：概述（为什么需要CopyOnWriteArrayList、什么是CopyOnWrite、写时复制和读写锁的区别），实现原理（基本结构、get、add、set、remove）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="list" scheme="http://linyishui.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>迭代器</title>
    <link href="http://linyishui.top/2020060301.html"/>
    <id>http://linyishui.top/2020060301.html</id>
    <published>2020-06-03T14:21:21.000Z</published>
    <updated>2020-07-17T17:25:01.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-迭代器是什么？"><a href="#1-1-迭代器是什么？" class="headerlink" title="1.1 迭代器是什么？"></a><strong>1.1 迭代器是什么？</strong></h3><p><strong>迭代器</strong>（iterator），是确使用户可在容器对象（container，例如<a href="https://zh.wikipedia.org/wiki/鏈表" target="_blank" rel="noopener">链表</a>或<a href="https://zh.wikipedia.org/wiki/陣列" target="_blank" rel="noopener">数组</a>）上遍访的<a href="https://zh.wikipedia.org/wiki/对象_(计算机科学" target="_blank" rel="noopener">对象</a>)，设计人员使用此接口无需关心容器对象的内存分配的实现细节。</p><h3 id="1-2-Java迭代器"><a href="#1-2-Java迭代器" class="headerlink" title="1.2 Java迭代器"></a><strong>1.2 Java迭代器</strong></h3><p><a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a> JDK 1.2 版开始支持迭代器。每一个迭代器提供 <code>next()</code>以及 <code>hasNext()</code>方法，同时也支持 <code>remove()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iter = list.iterator();</span><br><span class="line"><span class="comment">//Iterator&lt;MyType&gt; iter = list.iterator();    in J2SE 5.0</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext())</span><br><span class="line">    System.out.println(iter.next());</span><br></pre></td></tr></table></figure><p>迭代器主要用来帮助集合遍历，使集合类型的遍历行为与被遍历的集合对象分离。</p><p>Java语法糖中的 <code>foreach</code> 就是由迭代器来实现的。</p><h3 id="1-3-快速失败与安全失败"><a href="#1-3-快速失败与安全失败" class="headerlink" title="1.3 快速失败与安全失败"></a><strong>1.3 快速失败与安全失败</strong></h3><p>快速失败（fail-fast）是指迭代器遍历集合对象时发现内容被同时修改，且修改导致了计数器与期待值不同，导致抛出异常 <code>ConcurrentModificationException</code>（迭代器内部有计数器ModCount，每次移动指针前会检查当前值是否是expected，若修改不会使modCount不匹配就不会抛出异常）。</p><p>安全失败（fail-safe）则是指相应集合并不直接在内部访问，而是先拷贝副本，在副本上进行遍历，所以遍历过程中的修改不会影响到读取。</p><p>Java迭代器采用的是快速失败的模式，在一个线程工作时不允许其他线程修改相关内容。</p><hr><h2 id="第二节-源码"><a href="#第二节-源码" class="headerlink" title="第二节 源码"></a><strong>第二节 源码</strong></h2><p><em>本部分代码来自于JDK 1.8。</em></p><h3 id="2-1-Iterable"><a href="#2-1-Iterable" class="headerlink" title="2.1 Iterable"></a><strong>2.1 Iterable</strong></h3><p>Iterable接口定义了 <code>iterator()</code> 返回一个迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口Iterable表示<strong>对象是否可迭代</strong>，集合顶层接口Collection继承了此接口，所以所有集合对象都是可迭代的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Iterator"><a href="#2-2-Iterator" class="headerlink" title="2.2 Iterator"></a><strong>2.2 Iterator</strong></h3><p>迭代器接口Iterator源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 删除最后一个元素，默认实现抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意 <code>remove()</code> 使用时有一些陷阱，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List list = ...;  </span><br><span class="line"><span class="keyword">for</span>(Iterator iter = list.iterator();iter.hasNext();) &#123;  </span><br><span class="line">    Object obj = iter.next();  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">if</span>(XXX) &#123;  </span><br><span class="line">        list.remove(obj);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代器遍历集合时，调用 <code>remove()</code> 后，继续执行 <code>next()</code> 时，程序会抛出异常 <code>UnsupportedOperationException</code> 或 <code>ConcurrentModificationException</code> 。</p><p>前者是因为接口或抽象类默认实现即抛出此异常。后者则因为删除方法修改了modCount计数值，导致与期待值不等所以抛出此异常。</p><h3 id="2-3-Itr"><a href="#2-3-Itr" class="headerlink" title="2.3 Itr"></a><strong>2.3 Itr</strong></h3><p>AbstractList中通过子类Itr实现了迭代器接口Iterator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 计数器记录操作次数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 抽象类默认仍是抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查modCount是否修改</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                E next = get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查modCount是否修改</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList中也通过子类Itr实现了迭代器接口Iterator。</p><p>在ArrayList中如 <code>remove()</code> 或 <code>sort()</code> 等方法会 <code>modCount++</code> 所以并发修改会导致计数器值和期待值不符，导致抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《维基百科》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Java集合中迭代器简单整理。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记</title>
    <link href="http://linyishui.top/2020060101.html"/>
    <id>http://linyishui.top/2020060101.html</id>
    <published>2020-06-01T09:06:15.000Z</published>
    <updated>2020-06-30T08:39:08.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a><strong>算法笔记</strong></h1><h2 id="第一节-递归"><a href="#第一节-递归" class="headerlink" title="第一节 递归"></a><strong>第一节 递归</strong></h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a><strong>1.1 概述</strong></h3><p>什么是递归？简单的说，一个方法自己调用自己即递归。递归实质上是把一个大问题分解为一个个小问题，然后通过一个个解决小问题最终解决大问题。</p><h3 id="1-2-斐波那契数列"><a href="#1-2-斐波那契数列" class="headerlink" title="1.2 斐波那契数列"></a><strong>1.2 斐波那契数列</strong></h3><h4 id="1-2-1-问题"><a href="#1-2-1-问题" class="headerlink" title="1.2.1 问题"></a><strong>1.2.1 问题</strong></h4><p>斐波那契数列是典型的递归案例：</p><ul><li>F(0) = 0（初始值）</li><li>F(1) = 1（初始值）</li><li>对于所有大于1的整数n：f(n) = f(n-1) + f(n-2)（递归定义）</li></ul><p>除了开头0和1，每个数字都刚好等于前两个数字之和：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……</p><h4 id="1-2-2-实现"><a href="#1-2-2-实现" class="headerlink" title="1.2.2 实现"></a><strong>1.2.2 实现</strong></h4><p>用代码来表示斐波那契数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-运行轨迹"><a href="#1-2-3-运行轨迹" class="headerlink" title="1.2.3 运行轨迹"></a><strong>1.2.3 运行轨迹</strong></h4><p>但递归的时间开销实在是太高了，如下图所示，求F(n)要沿树走下去并依次执行返回上来，即4-3-2-1-2-0-3-1-4-2-1-2-0-2-4。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt></p><h4 id="1-2-4-时间复杂度"><a href="#1-2-4-时间复杂度" class="headerlink" title="1.2.4 时间复杂度"></a><strong>1.2.4 时间复杂度</strong></h4><p>递归过程即遍历二叉树的流程，所以所有节点耗时相加即总耗时。每个节点只做了求和操作即 <code>O(1)</code> ，所以总时间为 <code>2^n</code> 。</p><h4 id="1-2-5-额外内存空间"><a href="#1-2-5-额外内存空间" class="headerlink" title="1.2.5 额外内存空间"></a><strong>1.2.5 额外内存空间</strong></h4><p>空间复杂度是指算法运行期间所需占用的所有内存空间，而我们分析算法时更常用的是额外内存空间，两者区别：长度为 <code>n</code> 的数组排序， <code>O(n)</code> 的空间不会算在额外内存空间，因为这个空间是必要的，不是取决于你的算法的。</p><p>对于递归算法来说，每个节点所需空间为 <code>O(1)</code> ，总共需要 <code>O(n)</code> 的空间。</p><h4 id="1-2-6-优化"><a href="#1-2-6-优化" class="headerlink" title="1.2.6 优化"></a><strong>1.2.6 优化</strong></h4><p>可以明显的看出递归算法的低效主要是因为进行了大量的<strong>重复操作</strong>，只要减少不必要的重复操作就可以提高算法效率。</p><p>首先我们可以想到用一个数据结构来记录已经进行过的操作，每次操作前判断一下是否进行过来避免重复。</p><p>选用一个数组来存放对应下标的值，通过游标遍历到n求得对应值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] notes = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    notes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    notes[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        notes[i] = notes[i-<span class="number">1</span>] + notes[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> notes[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时时间复杂度降低到了 <code>O(n)</code> 。</p><p>接着还可以继续优化空间，求第n个数的值最终并不需要我们记录之前的每个元素，所以可以继续优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样时间复杂度仍为 <code>O(n)</code> ，而空间也降到了 <code>O(1)</code> 。</p><p>这种解法其实就是<strong>动态规划</strong>。</p>]]></content>
    
    <summary type="html">
    
      暂时记录一些基础内容，持续更新。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>HTTP会话（未完成）</title>
    <link href="http://linyishui.top/2020050701.html"/>
    <id>http://linyishui.top/2020050701.html</id>
    <published>2020-05-07T11:21:21.000Z</published>
    <updated>2020-07-01T14:21:03.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP会话"><a href="#HTTP会话" class="headerlink" title="HTTP会话"></a><strong>HTTP会话</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-为什么需要会话？"><a href="#1-1-为什么需要会话？" class="headerlink" title="1.1 为什么需要会话？"></a><strong>1.1 为什么需要会话？</strong></h3><p>服务器接收请求时需要<strong>标识用户身份</strong>，当然首先可以想到<strong>IP地址</strong>可以作为<strong>唯一标识符</strong>，即某个时间段内来自同一IP地址的所有请求一定属于相同客户端。但是<strong>网络地址转换（NAT）并不可靠</strong>，比如大学校园或大型企业，可能有数千人使用相同的IP地址，其真实IP则隐藏在NAT路由之后。我们<strong>需要一个维护用户状态的机制</strong>，而HTTP协议本身是无状态的，所以所有的HTTP服务器都普遍采用了HTTP会话的概念。</p><h3 id="1-2-什么是会话？"><a href="#1-2-什么是会话？" class="headerlink" title="1.2 什么是会话？"></a><strong>1.2 什么是会话？</strong></h3><p>在网络领域，会话（session）是一种持久网络协议，在用户端（或用户代理）和服务器端间创建关联，从而起到交换数据包的作用机制。<strong>在不包含会话层（UDP）或无法长时间驻留会话层（HTTP）的传输协议中，会话的维持需要依靠在传输数据中的高级版程序</strong>。例如HTTP中使用Cookie存放一些如 <code>Session ID</code> 、参数和权限信息等。</p><p>会话是由服务器或Web应用程序管理的某些文件、内存片段、对象或容器，它包含了应用分配给它的各种数据。容器和用户浏览器直接通过某种方式连接起来，通常是赋予一个随机生成的字符串 <code>Session ID</code> 也叫会话ID。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010139.jpg" alt></p><h3 id="1-3-会话的作用"><a href="#1-3-会话的作用" class="headerlink" title="1.3 会话的作用"></a><strong>1.3 会话的作用</strong></h3><h4 id="1-3-1-维持状态"><a href="#1-3-1-维持状态" class="headerlink" title="1.3.1 维持状态"></a><strong>1.3.1 维持状态</strong></h4><p><strong>会话用于维持请求和请求之间的状态，HTTP请求自身是完全无状态的</strong>。在无状态的方式下，大部分应用程序无法正常工作，比如购物网站，所有的行为和功能都要基于用户身份，如购物车、收藏夹、支付等，可以想象没有状态的话所有的功能都必须一次成功走完，会话是维持请求状态的引擎。</p><h4 id="1-3-2-记住用户"><a href="#1-3-2-记住用户" class="headerlink" title="1.3.2 记住用户"></a><strong>1.3.2 记住用户</strong></h4><p><strong>会话的机制让系统能够记住用户</strong>：如论坛等网站，用户都要有用户名或“匿名”，用户登录后可以添加主题、回复主题、参与此人讨论等，所有流程中用户只须登录一次，系统需要记住此用户。</p><h4 id="1-3-3-启动应用程序工作流"><a href="#1-3-3-启动应用程序工作流" class="headerlink" title="1.3.3 启动应用程序工作流"></a><strong>1.3.3 启动应用程序工作流</strong></h4><p>通常用户在使用一些高级功能时，需要使用某种形式的<strong>工作流</strong>，比如新闻网站中发布新闻时，首先要进入编写标题、标语和正文的页面，然后下个页面选择相关图片，最后还可能要选择一些类似文章或关键字。以上三个步骤完成后，新闻被发布出去，这样的<strong>工作流通常包含多个步骤，每个步骤是单个任务，共同构成了整个工作流</strong>，所以请求之间需要维持一个状态。</p><hr><h2 id="第二节-简单使用"><a href="#第二节-简单使用" class="headerlink" title="第二节 简单使用"></a><strong>第二节 简单使用</strong></h2><h3 id="2-1-Cookie、Session、Token"><a href="#2-1-Cookie、Session、Token" class="headerlink" title="2.1 Cookie、Session、Token"></a><strong>2.1 Cookie、Session、Token</strong></h3><p>相关内容：<a href="../2019052101.html" title="Title">Cookie，Session，Token</a>。</p><h3 id="2-2-传输会话ID"><a href="#2-2-传输会话ID" class="headerlink" title="2.2 传输会话ID"></a><strong>2.2 传输会话ID</strong></h3><p>有两种流行的方式来传输会话ID：</p><ul><li>通过Set-Cookie头将JSESSIONID发送给浏览器。</li><li>通过URL直接拼接JSESSIONID。</li></ul><p>第二种方式可以避免使用Cookie，但所有请求URL都会嵌入会话ID。</p><h3 id="2-3-会话常见漏洞"><a href="#2-3-会话常见漏洞" class="headerlink" title="2.3 会话常见漏洞"></a><strong>2.3 会话常见漏洞</strong></h3><p>可以通过一些漏洞检测工具或如Open Web Application Security Project(OWASP)网站来进行检查。</p><h4 id="2-3-1-复制并粘贴错误"><a href="#2-3-1-复制并粘贴错误" class="headerlink" title="2.3.1 复制并粘贴错误"></a><strong>2.3.1 复制并粘贴错误</strong></h4><p>使用URL拼接的方式传输SessionID会面临一个问题：用户可能会不小心把URL复制到互联网上，如果一些人在会话结束前访问此URL，那么自然也会变当作此用户。</p><p>解决此问题的方法就是<strong>不要使用URL拼接这种方式</strong>，这并不奇怪，大部分网站都采用Cookie来作为通用的解决方案。</p><h4 id="2-3-2-会话固定"><a href="#2-3-2-会话固定" class="headerlink" title="2.3.2 会话固定"></a><strong>2.3.2 会话固定</strong></h4><p>会话固定攻击类似于复制粘贴错误，攻击者首先获得一个拼接SessionID的URL，然后将此URL传播出去，不知情的用户通过此URL在会话期间登录网站，那么攻击者也能够登录成功并访问被攻击用户的账户。</p><p>解决方法有：</p><ul><li>禁止在URL中嵌入会话ID，同时也需要在应用程序中禁止接受通过URL传递的会话ID。</li><li>在登录后采用会话迁移。即用户登录后，修改会话ID并将之前会话ID无效。</li></ul><h4 id="2-3-3-跨站脚本和会话劫持"><a href="#2-3-3-跨站脚本和会话劫持" class="headerlink" title="2.3.3 跨站脚本和会话劫持"></a><strong>2.3.3 跨站脚本和会话劫持</strong></h4><p><strong>跨站脚本攻击</strong>（CSRF）：攻击者会通过将JS注入某个页面，通过DOM属性 <code>document.cookie</code> 读取会话Cookie的内容，攻击者获得会话ID后，可以通过创建Cookie/或URL嵌入来模拟会话，直接使用被攻击用户的身份。</p><p>大致的触发流程是：</p><ol><li>用户登录了站点A，并且在Cookie中留下了A站点的认证信息</li><li>用户进入了站点B，而站点B用一些方式（比如一个提交行为是到A站点某关键接口的表单）引诱用户去点击。当用户点击时，会发出到A站点的请求。而浏览器会给这个请求附带上A站点的认证信息，从而让这个请求能够执行。这种行为可能是，但不限于，给某个A站点的某个其他用户提权/转账/发文辱骂等等。</li></ol><p>解决方法：</p><ol><li>编码和过滤，将HTML字符转换为 <code>HTML Entities</code> 编码，对js代码进行转义。</li><li>避免使用 <code>Cookie</code> ，而使用 <code>Local Storage</code> ，但会使XSS攻击更容易。</li><li>使用 <code>CSRF Token</code> 作表单验证。</li><li>给所有接口都添加一个请求 <code>secret</code> ，来标记其来自于合法的客户端。</li><li>用 <code>Same-Site Cookie</code> 限制站点必须同域名才能携带cookie。</li><li>总是用 <code>json</code> 格式提交，禁止允许跨域的 <code>application/x-www-form-urlencoded</code> 格式，而使用<code>application/json</code> 。</li><li>双认证，认证信息同时存放在 <code>HttpOnly Cookie</code> 和 <code>Authorization Header</code> ，并在服务器对比。</li><li>使用HTTPS，将Cookie设置为Secure，浏览器就可以只在访问https网址时才会携带Cookie。</li></ol><h4 id="2-3-4-不安全的Cookie"><a href="#2-3-4-不安全的Cookie" class="headerlink" title="2.3.4 不安全的Cookie"></a><strong>2.3.4 不安全的Cookie</strong></h4><p><strong>中间人攻击</strong>（MitM）：是一种典型的数据截获攻击，攻击者通过观察客户端和服务端交互的请求或响应，从中获取信息。</p><p>这种类型的攻击促进了<strong>安全套接字层</strong>和<strong>传输层安全</strong>（SSL/TLS）的发展，是HTTPS协议的基础。</p><p>解决方案是<strong>使用HTTPS协议</strong>，但仍存在的问题是<strong>应用可能同时支持HTTP和HTTPS</strong>，那么在HTTP请求重定向到HTTPS时攻击可能已经发生了（在用户浏览器通过未加密的方式发送会话ID cookie时，观察者已经窃取到此ID）。这种情况需要使用Cookie的 <code>Secure</code> 特性，此标志告诉浏览器只能通过HTTPS传输Cookie，即<strong>一直使用HTTPS</strong>。</p><h4 id="2-3-5-安全的会话"><a href="#2-3-5-安全的会话" class="headerlink" title="2.3.5 安全的会话"></a><strong>2.3.5 安全的会话</strong></h4><p><code>SSL/TLS 会话 ID</code> 通过去除必须在每次请求中都执行SSL握手的需求，改善了SSL协议的效率。<code>SSL/TLS 会话 ID</code> 在SSL握手期间建立，然后使用在后续请求中，将请求绑定在一起，决定加密和界面所使用的密钥。它与 <code>HTTP 会话 ID</code> 的区别在于其并不通过URL或Cookie来传输或存储，而是需要认证授权才能获取。</p><p>使用 <code>SSL/TLS 会话 ID</code> 需要一直使用HTTPS协议，并且SSL通信必须由Web容器完成，如果使用了Web服务器或负载均衡器管理SSL通信，Web容器将无法获得通信中的 <code>SSL/TLS 会话 ID</code> 值。在集群环境中，用户的请求必须要一直发生到同一服务器（多机不会备份会话信息）。服务端存储 <code>SSL/TLS 会话 ID</code> 对应的信息不太容易控制失效时间，太短起不到作用，太长又占用服务端大量资源。</p><hr><h2 id="第三节-在会话中存储数据"><a href="#第三节-在会话中存储数据" class="headerlink" title="第三节 在会话中存储数据"></a><strong>第三节 在会话中存储数据</strong></h2><hr><h2 id="第四节-使用会话"><a href="#第四节-使用会话" class="headerlink" title="第四节 使用会话"></a><strong>第四节 使用会话</strong></h2><hr><h2 id="第五节-将使用会话的应用集群化"><a href="#第五节-将使用会话的应用集群化" class="headerlink" title="第五节 将使用会话的应用集群化"></a><strong>第五节 将使用会话的应用集群化</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《JavaWeb高级编程——涵盖WebSockets、Spring Framework、JPA Hibernate和Spring Security》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="session" scheme="http://linyishui.top/tags/session/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="web" scheme="http://linyishui.top/tags/web/"/>
    
      <category term="java web" scheme="http://linyishui.top/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Redis</title>
    <link href="http://linyishui.top/2020050501.html"/>
    <id>http://linyishui.top/2020050501.html</id>
    <published>2020-05-05T03:44:21.000Z</published>
    <updated>2020-08-06T16:35:23.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h1><h2 id="第一节-综合"><a href="#第一节-综合" class="headerlink" title="第一节 综合"></a><strong>第一节 综合</strong></h2><h3 id="问：简单描述下-Redis？支持哪些数据结构？优点？"><a href="#问：简单描述下-Redis？支持哪些数据结构？优点？" class="headerlink" title="问：简单描述下 Redis？支持哪些数据结构？优点？"></a><strong>问：简单描述下 Redis？支持哪些数据结构？优点？</strong></h3><details><br><br>由<strong>C语言</strong>开发的一个<strong>基于高性能键值对</strong>的<strong>开源</strong>的<strong>内存数据库</strong>，是一个<strong>非关系型数据库</strong>（NoSQL）。<br><br>支持八种数据结构：字符串String，哈希Hash，数组List，集合Set，有序集合ZSet，位图BitMaps，基数统计HyperLogLig，地理信息定位GEO。<br><br>Redis的优势有：<br><br><em> 支持多种数据结构和算法，所以<strong>应用面广</strong>。</em> 将数据存放在内存，所以有<strong>高效的读写性能</strong>。<br>* 内存中的数据通过快照和日志的方式保存在硬盘，所以<strong>不易丢失</strong>。<br><br><a href="https://zhuanlan.zhihu.com/p/118561398" target="_blank" rel="noopener">我和面试官的博弈：Redis 篇</a><br><br></details><h3 id="问：redis-最适合的场景？"><a href="#问：redis-最适合的场景？" class="headerlink" title="问：redis 最适合的场景？"></a><strong>问：redis 最适合的场景？</strong></h3><details><br><br>1. <strong>缓存模块</strong>：常用于大型网站来加速数据访问和缓解后端数据库压力。Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。会话缓存 session cache。<br>1. <strong>排行榜</strong>：几乎所有网站都需要各种规则的排行榜，或是依据热度排行，或是发布时间，或是结合各种复杂维度计算。Redis提供了列表和有序集合数据结构，合理的使用这些结构可以很方便的构建各种排行榜系统。<br>1. <strong>计数器</strong>：如一些视频网站的播放数，电商网站的浏览数，对于数据的实时性有较高的要求，如果并发量很大时，传统关系型数据库很难做好这一工作。Redis天然支持计数功能，且性能优越。<br>1. <strong>社交网络</strong>：比如赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等常见功能，由于社交网站访问量通常较大，且传统关系型数据库不太适合存储这种类型的数据，而Redis提供的数据结构比较容易实现这些功能。<br>1. <strong>消息队列</strong>：大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列功能，虽然相比专业的消息队列还有所欠缺，但可以满足大部分基础需求。<br><br></details><h3 id="问：redis单线程为什么执行速度这么快？"><a href="#问：redis单线程为什么执行速度这么快？" class="headerlink" title="问：redis单线程为什么执行速度这么快？"></a><strong>问：redis单线程为什么执行速度这么快？</strong></h3><details><br><br>1. 纯内存操作，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快<br>2. 单线程操作，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗<br>3. 采用了非阻塞I/O多路复用机制，减少了线程切换时上下文切换和竞争。<br><br></details><h3 id="问：Redis高并发快的原因？"><a href="#问：Redis高并发快的原因？" class="headerlink" title="问：Redis高并发快的原因？"></a><strong>问：Redis高并发快的原因？</strong></h3><details><br>1. 内存数据库，读写速度快。<br>2. 采用了非阻塞I/O多路复用机制。<br>3. 单线程模型，保证了操作原子性，也避免了不必要的上下文切换和竞争条件。<br>4. 数据结构有做底层优化，如Hash、压缩表、压缩存储、跳跃表等。<br>5. Redis实现了高效率的事件分离器，内部采用非阻塞的执行方式，吞吐能力很高。<br><br></details><h3 id="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；"><a href="#问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；" class="headerlink" title="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；"></a><strong>问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；</strong></h3><details><br><br></details><h3 id="问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a><strong>问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></h3><details><br><br>使用keys指令可以扫出指定模式的key列表。 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了 ，但是整体所花费的时间会比直接用keys指令长。<br><br></details><h3 id="问：Redis如何压缩内存？"><a href="#问：Redis如何压缩内存？" class="headerlink" title="问：Redis如何压缩内存？"></a><strong>问：Redis如何压缩内存？</strong></h3><details><br><br></details><h3 id="问：讲一下平时使用Redis遇到过哪些问题？如何解决的？"><a href="#问：讲一下平时使用Redis遇到过哪些问题？如何解决的？" class="headerlink" title="问：讲一下平时使用Redis遇到过哪些问题？如何解决的？"></a><strong>问：讲一下平时使用Redis遇到过哪些问题？如何解决的？</strong></h3><details><br><br></details><hr><h2 id="第二节-底层数据结构"><a href="#第二节-底层数据结构" class="headerlink" title="第二节 底层数据结构"></a><strong>第二节 底层数据结构</strong></h2><h3 id="问：redis支持哪些数据结构？"><a href="#问：redis支持哪些数据结构？" class="headerlink" title="问：redis支持哪些数据结构？"></a><strong>问：redis支持哪些数据结构？</strong></h3><details><br><br>string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog（做基数统计）、GEO（地理信息定位）等多种数据结构和算法<br><br></details><h3 id="问：Redis各种数据结构的使用场景、内部编码及底层实现？"><a href="#问：Redis各种数据结构的使用场景、内部编码及底层实现？" class="headerlink" title="问：Redis各种数据结构的使用场景、内部编码及底层实现？"></a><strong>问：Redis各种数据结构的使用场景、内部编码及底层实现？</strong></h3><details><br><br><strong>String</strong>：<br><br><em> 【应用场景】：   </em> <strong>缓存</strong><br>  <em> <strong>计数</strong>  </em> <strong>共享Session</strong><br>  <em> <strong>限速</strong></em> 【内部编码】：<br><br>  <em> <strong>int</strong>：8个字节的长整型。  </em> <strong>embstr</strong>：小于等于39个字节的字符串。<br>  <em> <strong>raw</strong>：大于39个字节的字符串。</em> 【底层实现】：<code>Simple dynamic string</code>（SDS）的数据结构：<br><br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">  <span class="comment">//等于SDS保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len；</span><br><span class="line">  <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>；</span><br><span class="line">  <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[]；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><br>  优点（都是C字符串的缺点弥补）：<br><br>  <em> 不会出现字符串变更造成的内存溢出问题。  </em> 获取字符串长度时间复杂度为1，C字符串没有长度信息（以 <code>\0</code> 来明确表示结尾），必须遍历字符串，时间复杂度为O(n)。<br>  <em> 空间预分配， 惰性空间释放free字段，会默认留够一定的空间防止多次重分配内存。<br><br><strong>Hash</strong>：</em> 【应用场景】：<br>  <em> <strong>保存结构体信息</strong>，可部分获取不用序列化所有字段。如保存用户类，原生字符串每个属性都要对应一个键，序列化字符串需要序列与反序列的开销，而哈希类型只须一个键即可存放一个用户信息。</em> 【内部编码】：<br>  <em> <strong>ziplist</strong>（压缩列表）：当哈希类型元素个数小于 <code>hash-max-ziplist-entries</code> 配置（默认为512个），同时所有值都小于 <code>hash-max-ziplist-value</code> 配置（默认为6字节）时，Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以相比hashtable会更节省空间。  </em> <strong>hashtable</strong>（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，这种情况ziplist的读写效率会下降，而hashtable读写时间复杂度为 <code>O(1)</code> 。<br><em> 【底层实现】：在数组+链表的基础上，进行了一些rehash优化。  </em> Reids的Hash采用<strong>链地址法</strong>来处理冲突，然后它<strong>没有使用红黑树优化</strong>。<br>  <em> 哈希表节点采用<strong>单链表结构</strong>。  </em> <strong>rehash优化</strong> （采用分而治之的思想，将庞大的迁移工作量划分到每一次CURD中，避免了服务繁忙）<br><br><strong>List</strong>：<br><br><em> 【应用场景】：   </em> <strong>消息队列</strong>：<code>lpush</code> + <code>brpop</code> 命令组合即可实现<strong>阻塞队列</strong><br><br>  <em> <strong>文章列表</strong>：比如twitter的关注列表，粉丝列表等  </em> 经典口诀：<br><br>    <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush + <span class="attr">lpop</span> = Stack（栈）</span><br><span class="line">lpush + <span class="attr">rpop</span> = Queue（队列）</span><br><span class="line">lpush + <span class="attr">ltrim</span> = Capped Collection（有限集合）</span><br><span class="line">lpush + <span class="attr">brpop</span> = Message Queue（消息队列）</span><br></pre></td></tr></table></figure><br><br><em> 【内部编码】：  </em> <strong>ziplist</strong>：当列表的元素个数小于 <code>list-max-ziplist-entries</code> 配置（默认512个），同时列表中每个元素的值都小于 <code>list-max-ziplist-value</code> 配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。<br>  <em> <strong>linkedlist</strong>（链表）：当列表类型无法满足ziplist的条件时，Redis会使用链表实现。</em> 【底层实现】：list的实现为一个<strong>双向链表</strong>，即可以支持反向查找和遍历。<br><br><strong>Set</strong>：<br><br><em> 【应用场景】：   </em> <strong>去重的场景</strong><br>  <em> <strong>求交集</strong>（sinter）、<strong>并集</strong>（sunion）、<strong>差集</strong>（sdiff）  </em> <strong>标签</strong>：实现如共同关注、共同喜好、二度好友等功能。<br><em> 【内部编码】：  </em> <strong>intset</strong>（整数集合）：当集合中的元素都是整数且元素个数小于 <code>set-max-intset-entries</code> 配置（默认512个）时，Redis会选用intset来作为集合内部实现，从而减少内存的使用。<br>  <em> <strong>hashtable</strong>（哈希表）：集合无法满足intset的条件时，选用hashtable作为集合内部实现。</em> 【底层实现】：是一个<strong>value为null的HashMap</strong>，实际就是<strong>通过计算hash的方式来快速排重</strong>的，这也是set能提供判断一个成员是否在集合内的原因。<br><br><strong>ZSet</strong>：<br><br><em> 【应用场景】：  </em> <strong>排行榜</strong><br>  <em> <strong>实现延时队列</strong></em> 【内部编码】：<br>  <em> <strong>ziplist</strong>（压缩列表）：当有序集合的元素个数小于 <code>zset-max-ziplist-entries</code> 配置（默认128个），同时列表中每个元素的值都小于 <code>zset-max-ziplist-value</code> 配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。  </em> <strong>skiplist</strong>（跳跃表）：当无法满足ziplist的条件时，Redis选用skiplist作为内部实现，因为此时ziplist的读写效率会下降。<br><em> 【底层实现】：内部使用<strong>HashMap</strong>和<strong>跳跃表</strong>（SkipList）来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。   </em> 跳表：每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的<br><br></details><h3 id="问：redis中的字符串类型是怎么实现的？"><a href="#问：redis中的字符串类型是怎么实现的？" class="headerlink" title="问：redis中的字符串类型是怎么实现的？"></a><strong>问：redis中的字符串类型是怎么实现的？</strong></h3><details><br><br>通过一个抽象数据结构SDS来实现，包含三个重要属性：已使用字节数量，未使用字节数量，字节数组。存储时保留了C语言以 <code>\0</code> 为结尾的习惯以便能兼容C语言的函数。分配空间时，当长度小于1MB，会根据已使用空间分配相等大小的未使用空间以备扩展，大于1MB时只会分配1MB。<br><br></details><h3 id="问：redis-如何存储一个-String-的？"><a href="#问：redis-如何存储一个-String-的？" class="headerlink" title="问：redis 如何存储一个 String 的？"></a><strong>问：redis 如何存储一个 String 的？</strong></h3><details><br><br>假设要存储一个字符串 <code>hello</code> ，SDS会记录已使用字节长度为5，并分配相同大小的未使用字节空间（长度小于1MB时）所以也为5，并保留 <code>\0</code> 作为字符串结尾但不计入空间占用，所以此时SDS分配空间为11。<br><br></details><h3 id="问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？"><a href="#问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？" class="headerlink" title="问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？"></a><strong>问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？</strong></h3><details><br>首先原生C字符串获取字符串长度需要遍历整个字符串，复杂度为O(n)，而SDS则为O(1)。<br><br>因为有预分配的空间以及惰性释放空间，所以可以避免重复内存分配。<br><br>因为有了长度控制，所以避免了C字符串常见的内存溢出问题。<br><br>C字符串对于字符编码有要求，对于一些如图片、音频等格式的二进制编码未必能支持，而SDS虽然保留了空字符结尾但并不以它来判断字符串结尾，所以可以安全的存储一些特殊格式要求的二进制数据。<br><br></details><h3 id="问：hash底层如何实现？rehash做了哪些优化？"><a href="#问：hash底层如何实现？rehash做了哪些优化？" class="headerlink" title="问：hash底层如何实现？rehash做了哪些优化？"></a><strong>问：hash底层如何实现？rehash做了哪些优化？</strong></h3><details><br>Redis 的 hash 数据有两种底层编码实现：ziplist和hashtable。<br><br>字典由 <code>dict.h</code> 文件定义，其中ht是哈希表结构，0是正常使用的表，1则是渐进rehash时用来转移0的节点。<br><br>rehashidx用来在rehash过程记录正在转移的键，平时为-1。<br><br><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010116.png" alt><br><br>dictht即哈希表结构，内部包含一个 <code>dictEntry **table</code> table即dictEntry二维数组，为了哈希冲突时能够串联所有冲突的节点。size即哈希表最大可寻址大小，即一维数组最大长度。dictEntry则是一个键值对结构。<br><br>在数组+链表的基础上，进行了一些rehash优化。TODO<br><br><em> Reids的Hash采用<strong>链地址法</strong>来处理冲突，然后它<strong>没有使用红黑树优化</strong>。</em> 哈希表节点采用<strong>单链表结构</strong>。<br>* <strong>rehash优化</strong> （采用分而治之的思想，将庞大的迁移工作量划分到每一次CURD中，避免了服务繁忙）<br><br></details><h3 id="问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？"><a href="#问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？" class="headerlink" title="问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？"></a><strong>问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？</strong></h3><details><br><br>1. skiplist的复杂度和红黑树一样，而且实现起来更简单。<br>1. 在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。<br><br></details><h3 id="问：redis如何实现延时队列？"><a href="#问：redis如何实现延时队列？" class="headerlink" title="问：redis如何实现延时队列？"></a><strong>问：redis如何实现延时队列？</strong></h3><details><br><br>使用sortedset，想要执行时间的时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。<br><br></details><h3 id="问：关于redis对象系统的一个问题？"><a href="#问：关于redis对象系统的一个问题？" class="headerlink" title="问：关于redis对象系统的一个问题？"></a><strong>问：关于redis对象系统的一个问题？</strong></h3><details><br><br>（我说忘记了，记得redis设计与实现有写，面试小哥：忘记了那就不问了）<br><br></details><h3 id="问：如何利用Redis处理热点数据？"><a href="#问：如何利用Redis处理热点数据？" class="headerlink" title="问：如何利用Redis处理热点数据？"></a><strong>问：如何利用Redis处理热点数据？</strong></h3><details><br><br></details><h3 id="问：redis-的过期策略？"><a href="#问：redis-的过期策略？" class="headerlink" title="问：redis 的过期策略？"></a><strong>问：redis 的过期策略？</strong></h3><details><br><br></details><h3 id="问：redis-的内存淘汰策略？"><a href="#问：redis-的内存淘汰策略？" class="headerlink" title="问：redis 的内存淘汰策略？"></a><strong>问：redis 的内存淘汰策略？</strong></h3><details><br><br></details><hr><h2 id="第三节-事务"><a href="#第三节-事务" class="headerlink" title="第三节 事务"></a><strong>第三节 事务</strong></h2><h3 id="问：redis事务？"><a href="#问：redis事务？" class="headerlink" title="问：redis事务？"></a><strong>问：redis事务？</strong></h3><details><br><br>1. Multi开启事务<br>1. Exec执行事务块内命令<br>1. Discard 取消事务<br>1. Watch 监视一个或多个key，如果事务执行前key被改动，事务将打断<br><br></details><h3 id="问：redis事务的实现特征？"><a href="#问：redis事务的实现特征？" class="headerlink" title="问：redis事务的实现特征？"></a><strong>问：redis事务的实现特征？</strong></h3><details><br><br>1. 所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行<br>1. Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行<br>1. 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行<br>1. 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。<br><br>然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。<br><br>Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了<br><br></details><hr><h2 id="第四节-同步阻塞"><a href="#第四节-同步阻塞" class="headerlink" title="第四节 同步阻塞"></a><strong>第四节 同步阻塞</strong></h2><h3 id="问：Redis的同步机制？"><a href="#问：Redis的同步机制？" class="headerlink" title="问：Redis的同步机制？"></a><strong>问：Redis的同步机制？</strong></h3><details><br><br>&gt; <em> 全量拷贝：<br>&gt; </em> 1. slave第一次启动时，连接Master，发送PSYNC命令，<br>&gt;   2. master会执行bgsave命令来生成rdb文件，期间的所有写命令将被写入缓冲区。<br>&gt;   3. master bgsave执行完毕，向slave发送rdb文件<br>&gt;   4. slave收到rdb文件，丢弃所有旧数据，开始载入rdb文件<br>&gt;   5. rdb文件同步结束之后，slave执行从master缓冲区发送过来的所以写命令。此后 master 每执行一个写命令，就向slave发送相同的写命令。<br>&gt; <em> 增量拷贝：<br>&gt; </em> <em> 如果出现网络闪断或者命令丢失等异常情况，从节点之前保存了自身已复制的偏移量和主节点的运行ID<br>&gt;      </em> 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。<br><br></details><h3 id="问：redis阻塞原因？"><a href="#问：redis阻塞原因？" class="headerlink" title="问：redis阻塞原因？"></a><strong>问：redis阻塞原因？</strong></h3><details><br><br>1. 数据结构使用不合理bigkey<br>1. CPU饱和<br>1. 持久化阻塞，rdb fork子线程，aof每秒刷盘等<br><br></details><h3 id="问：讲一下分布式锁？"><a href="#问：讲一下分布式锁？" class="headerlink" title="问：讲一下分布式锁？"></a><strong>问：讲一下分布式锁？</strong></h3><details><br><br></details><h3 id="问：说说怎么用redis实现分布式锁？"><a href="#问：说说怎么用redis实现分布式锁？" class="headerlink" title="问：说说怎么用redis实现分布式锁？"></a><strong>问：说说怎么用redis实现分布式锁？</strong></h3><details><br><br></details><h3 id="问：Redis分布式锁？"><a href="#问：Redis分布式锁？" class="headerlink" title="问：Redis分布式锁？"></a><strong>问：Redis分布式锁？</strong></h3><details><br><br>2.6版本以后lua脚本保证setnx跟setex进行原子性（setnx之后，未setex，服务挂了，锁不释放） a获取锁，超过过期时间，自动释放锁，b获取到锁执行，a代码执行完remove锁，a和b是一样的key，导致a释放了b的锁。 解决办法：remove之前判断value（高并发下value可能被修改，应该用lua来保证原子性）<br><br></details><h3 id="问：redis锁续租问题？"><a href="#问：redis锁续租问题？" class="headerlink" title="问：redis锁续租问题？"></a><strong>问：redis锁续租问题？</strong></h3><details><br><br><br>1. 基于redis的redission分布式可重入锁RLock，以及配合java集合中lock；<br><br>1. Redission 内部提供了一个监控锁的看门狗，不断延长锁的有效期，默认检查锁的超时时间是30秒<br><br>1. 此方案的问题：如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master ，slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。<br><br>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。 此时就会导致多个客户端对一个分布式锁完成了加锁 解决办法：只需要将新的redis实例，在一个TTL时间内，对客户端不可用即可，在这个时间内，所有客户端锁将被失效或者自动释放.<br><br></details><h3 id="问：如何使用Redis做异步队列？"><a href="#问：如何使用Redis做异步队列？" class="headerlink" title="问：如何使用Redis做异步队列？"></a><strong>问：如何使用Redis做异步队列？</strong></h3><details><br><br>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。<br><br></details><h3 id="问：可不可以不用sleep呢？"><a href="#问：可不可以不用sleep呢？" class="headerlink" title="问：可不可以不用sleep呢？"></a><strong>问：可不可以不用sleep呢？</strong></h3><details><br><br>list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。<br><br></details><h3 id="问：如何解决-Redis-的并发竞争-Key-问题？"><a href="#问：如何解决-Redis-的并发竞争-Key-问题？" class="headerlink" title="问：如何解决 Redis 的并发竞争 Key 问题？"></a><strong>问：如何解决 Redis 的并发竞争 Key 问题？</strong></h3><details><br><br></details><hr><h2 id="第x节-发布订阅"><a href="#第x节-发布订阅" class="headerlink" title="第x节 发布订阅"></a><strong>第x节 发布订阅</strong></h2><h3 id="问：能不能生产一次消费多次呢？"><a href="#问：能不能生产一次消费多次呢？" class="headerlink" title="问：能不能生产一次消费多次呢？"></a><strong>问：能不能生产一次消费多次呢？</strong></h3><details><br><br>使用pub/sub主题订阅者模式，可以实现1：N的消息队列。<br><br></details><h3 id="问：pub-sub有什么缺点？"><a href="#问：pub-sub有什么缺点？" class="headerlink" title="问：pub/sub有什么缺点？"></a><strong>问：pub/sub有什么缺点？</strong></h3><details><br><br>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。<br><br></details><h3 id="问：讲一下项目中Redis消息队列如何做的？"><a href="#问：讲一下项目中Redis消息队列如何做的？" class="headerlink" title="问：讲一下项目中Redis消息队列如何做的？"></a><strong>问：讲一下项目中Redis消息队列如何做的？</strong></h3><details><br><br>使用pub/sub主题订阅者模式，可以实现1：N的消息队列。<br><br></details><hr><h2 id="第x节-持久化"><a href="#第x节-持久化" class="headerlink" title="第x节 持久化"></a><strong>第x节 持久化</strong></h2><h3 id="问：Redis-持久化策略？Redis如何做持久化？"><a href="#问：Redis-持久化策略？Redis如何做持久化？" class="headerlink" title="问：Redis 持久化策略？Redis如何做持久化？"></a><strong>问：Redis 持久化策略？Redis如何做持久化？</strong></h3><details><br>Redis持久化分两种：RDB和AOF，RDB是全量持久化，aof则是增量持久化。因为全量持久化是重操作，无法进行实时的持久化，所以通过AOF解决。<br><br>RDB是将进程数据的快照保存到硬盘，通过fork子进程来异步生成RDB文件。<br><br>AOF则将命令写入缓冲区，通过三种策略同步到硬盘（每次都同步，每秒同步，不同步），随着文件增大还会进行文件重写，服务器重启时通过AOF文件恢复。<br><br>在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。<br><br></details><h3 id="问：如果突然机器断电会怎样？"><a href="#问：如果突然机器断电会怎样？" class="headerlink" title="问：如果突然机器断电会怎样？"></a><strong>问：如果突然机器断电会怎样？</strong></h3><details><br>一般会选择everysec模式，即每秒执行一次fsync同步文件，所以只会丢失1s的数据（同步时主线程会判断最近2s是否有进行同步，有则直接返回，否则阻塞等同步线程执行完毕，所以最多可能丢失2s的数据）。<br><br></details><h3 id="问：bgsave的原理是什么？"><a href="#问：bgsave的原理是什么？" class="headerlink" title="问：bgsave的原理是什么？"></a><strong>问：bgsave的原理是什么？</strong></h3><details><br>bgsave相比于已废弃的save，后者阻塞服务器直到RDB过程结束，前者则通过fork创建子进程，持久化过程由子进程来完成，减少了主进程的阻塞时间。通过copy-on-write机制，父子进程共享内存，父进程继续提供读写服务，子进程根据父进程内存生成快照文件，并替换到RDB文件。<br><br></details><h3 id="问：RDB与AOF区别？"><a href="#问：RDB与AOF区别？" class="headerlink" title="问：RDB与AOF区别？"></a><strong>问：RDB与AOF区别？</strong></h3><details><br><br>1. RDB压缩文件格式紧凑，适合备份和全量复制，数据恢复快。但没法实时持久化，且有不同版本多个格式问题。<br><br>1. AOF则不断的追加命令到文件（文本协议RESP），因此文件会不断变大，需要重写机制来压缩体积。重写时通过重写缓冲区保存此期间主进程响应的命令。<br><br></details><hr><h2 id="第x节-哨兵、复制、集群"><a href="#第x节-哨兵、复制、集群" class="headerlink" title="第x节 哨兵、复制、集群"></a><strong>第x节 哨兵、复制、集群</strong></h2><h3 id="问：redis主从机制了解么？怎么实现的？"><a href="#问：redis主从机制了解么？怎么实现的？" class="headerlink" title="问：redis主从机制了解么？怎么实现的？"></a><strong>问：redis主从机制了解么？怎么实现的？</strong></h3><details><br><br></details><h3 id="问：redis-的部署方式，主从，集群？"><a href="#问：redis-的部署方式，主从，集群？" class="headerlink" title="问：redis 的部署方式，主从，集群？"></a><strong>问：redis 的部署方式，主从，集群？</strong></h3><details><br><br></details><h3 id="问：谈谈Redis哨兵、复制、集群？"><a href="#问：谈谈Redis哨兵、复制、集群？" class="headerlink" title="问：谈谈Redis哨兵、复制、集群？"></a><strong>问：谈谈Redis哨兵、复制、集群？</strong></h3><details><br><br></details><h3 id="问：redis-的哨兵模式，一个-key-值如何在-redis-集群中找到存储在哪？"><a href="#问：redis-的哨兵模式，一个-key-值如何在-redis-集群中找到存储在哪？" class="headerlink" title="问：redis 的哨兵模式，一个 key 值如何在 redis 集群中找到存储在哪？"></a><strong>问：redis 的哨兵模式，一个 key 值如何在 redis 集群中找到存储在哪？</strong></h3><details><br><br></details><h3 id="问：redis集群模式性能优化？"><a href="#问：redis集群模式性能优化？" class="headerlink" title="问：redis集群模式性能优化？"></a><strong>问：redis集群模式性能优化？</strong></h3><details><br><br>1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件<br>1. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次<br>1. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内<br>1. 尽量避免在压力很大的主库上增加从库<br>1. 主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master - Slave1 - Slave2 - Slave3…</code> 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。<br><br></details><h3 id="问：Redis集群方案？"><a href="#问：Redis集群方案？" class="headerlink" title="问：Redis集群方案？"></a><strong>问：Redis集群方案？</strong></h3><details><br><br><br>1. 官方cluster方案<br>1. twemproxy：代理方案twemproxy是一个单点，很容易对其造成很大的压力，所以通常会结合keepalived来实twemproy的高可用<br>1. codis 基于客户端来进行分片<br><br></details><br>### <strong>问：集群不可用场景？</strong><br><br><details><br><br>1. master挂掉，且当前master没有slave<br>1. 集群超过半数以上master挂掉，无论是否有slave集群进入fail状态<br><br></details><h3 id="问：hot-key出现造成集群访问量倾斜解决办法？"><a href="#问：hot-key出现造成集群访问量倾斜解决办法？" class="headerlink" title="问：hot key出现造成集群访问量倾斜解决办法？"></a><strong>问：hot key出现造成集群访问量倾斜解决办法？</strong></h3><details><br><br>1. 使用本地缓存<br>1. 利用分片算法的特性，对key进行打散处理（给hot key加上前缀或者后缀，把一个hotkey 的数量变成 redis 实例个数N的倍数M，从而由访问一个 redis key 变成访问 N * M 个redis key）<br><br></details><h3 id="问：缓存淘汰策略？"><a href="#问：缓存淘汰策略？" class="headerlink" title="问：缓存淘汰策略？"></a><strong>问：缓存淘汰策略？</strong></h3><details><br><br>1. 先进先出算法（FIFO）<br><br>1. 最近使用最少Least Frequently Used（LFU）<br><br>1. 最长时间未被使用的Least Recently Used（LRU）<br><br>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重<br><br></details><h3 id="问：redis过期key删除策略？"><a href="#问：redis过期key删除策略？" class="headerlink" title="问：redis过期key删除策略？"></a><strong>问：redis过期key删除策略？</strong></h3><details><br><br>1. 惰性删除，cpu友好，但是浪费cpu资源<br><br>1. 定时删除（不常用）<br><br>1. 定期删除，cpu友好，节省空间<br><br></details><h3 id="问：缓存雪崩以及处理办法？"><a href="#问：缓存雪崩以及处理办法？" class="headerlink" title="问：缓存雪崩以及处理办法？"></a><strong>问：缓存雪崩以及处理办法？</strong></h3><details><br><br>同一时刻大量缓存失效；<br><br>&gt;处理方法：<br>&gt; 1. 缓存数据增加过期标记<br>&gt; 1. 设置不同的缓存失效时间<br>&gt; 1. 双层缓存策略C1为短期，C2为长期<br>&gt; 1. 定时更新策略<br><br></details><h3 id="问：缓存击穿原因以及处理办法？"><a href="#问：缓存击穿原因以及处理办法？" class="headerlink" title="问：缓存击穿原因以及处理办法？"></a><strong>问：缓存击穿原因以及处理办法？</strong></h3><details><br>频繁请求查询系统中不存在的数据导致；<br><br>&gt;处理方法：<br>&gt; 1. cache null策略，查询反馈结果为null仍然缓存这个null结果，设置不超过5分钟过期时间<br>&gt; 1. 布隆过滤器，所有可能存在的数据映射到足够大的bitmap中 google布隆过滤器：基于内存，重启失效不支持大数据量，无法在分布式场景 redis布隆过滤器：可扩展性，不存在重启失效问题，需要网络io，性能低于google<br><br></details><h3 id="问：你们怎么解决缓存击穿问题的？"><a href="#问：你们怎么解决缓存击穿问题的？" class="headerlink" title="问：你们怎么解决缓存击穿问题的？"></a><strong>问：你们怎么解决缓存击穿问题的？</strong></h3><details><br><br>注:估计答了Hystrix<br><br></details><h3 id="问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？"><a href="#问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？" class="headerlink" title="问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？"></a><strong>问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？</strong></h3><details><br><br></details><h3 id="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"><a href="#问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？" class="headerlink" title="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"></a><strong>问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？</strong></h3><details><br><br>注:估计答了Hystrix<br><br></details><h3 id="问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？"><a href="#问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？"></a><strong>问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？</strong></h3><details><br><br></details><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Redis相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Dubbo</title>
    <link href="http://linyishui.top/2020050401.html"/>
    <id>http://linyishui.top/2020050401.html</id>
    <published>2020-05-04T03:42:50.000Z</published>
    <updated>2020-05-12T07:49:18.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><strong>Dubbo</strong></h1><h2 id="第一节-待整理"><a href="#第一节-待整理" class="headerlink" title="第一节 待整理"></a><strong>第一节 待整理</strong></h2><h4 id="问：dubbo流程？"><a href="#问：dubbo流程？" class="headerlink" title="问：dubbo流程？"></a><strong>问：dubbo流程？</strong></h4><details><br><br>&emsp;&emsp;（1）：生产者（Provider）启动，向注册中心（Register）注册<br><br>（2）：消费者（Consumer）订阅，而后注册中心通知消费者<br><br>（3）：消费者从生产者进行消费<br><br>（4）：监控中心（Monitor）统计生产者和消费者<br><br></details><h4 id="问：Dubbo推荐使用什么序列化框架，还有哪些？"><a href="#问：Dubbo推荐使用什么序列化框架，还有哪些？" class="headerlink" title="问：Dubbo推荐使用什么序列化框架，还有哪些？"></a><strong>问：Dubbo推荐使用什么序列化框架，还有哪些？</strong></h4><details><br><br>&emsp;&emsp;推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化<br><br></details><h4 id="问：Dubbo默认使用的是什么通信框架，还有哪些？"><a href="#问：Dubbo默认使用的是什么通信框架，还有哪些？" class="headerlink" title="问：Dubbo默认使用的是什么通信框架，还有哪些？"></a><strong>问：Dubbo默认使用的是什么通信框架，还有哪些？</strong></h4><details><br><br>&emsp;&emsp;默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。<br><br></details><h4 id="问：Dubbo有哪几种负载均衡策略，默认是哪种？"><a href="#问：Dubbo有哪几种负载均衡策略，默认是哪种？" class="headerlink" title="问：Dubbo有哪几种负载均衡策略，默认是哪种？"></a><strong>问：Dubbo有哪几种负载均衡策略，默认是哪种？</strong></h4><details><br><br>&emsp;&emsp;<br>（1）：随机调用{默认}<br><br>（2）：权重轮询<br><br>（3）：最少活跃数<br><br>（4）：一致性Hash<br><br></details><h4 id="问：RPC流程？"><a href="#问：RPC流程？" class="headerlink" title="问：RPC流程？"></a><strong>问：RPC流程？</strong></h4><details><br><br>&emsp;&emsp;（1）消费者调用需要消费的服务，<br><br>（2）：客户端存根将方法、入参等信息序列化发送给服务端存根<br><br>（3）：服务端存根反序列化操作根据解码结果调用本地的服务进行相关处理<br><br>（4）：本地服务执行具体业务逻辑并将处理结果返回给服务端存根<br><br>（5）：服务端存根序列化<br><br>（6）：客户端存根反序列化<br><br>（7）：服务消费方得到最终结果<br><br>RPC框架的实现目标PC框架的实现目标是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务<br><br></details><h4 id="问：服务暴露、服务引用、服务调用（TODO）？"><a href="#问：服务暴露、服务引用、服务调用（TODO）？" class="headerlink" title="问：服务暴露、服务引用、服务调用（TODO）？"></a><strong>问：服务暴露、服务引用、服务调用（TODO）？</strong></h4><details><br><br>&emsp;&emsp;<br><br></details><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Dubbo相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Mybatis</title>
    <link href="http://linyishui.top/2020050301.html"/>
    <id>http://linyishui.top/2020050301.html</id>
    <published>2020-05-03T10:44:58.000Z</published>
    <updated>2020-05-20T04:56:29.179Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a><strong>Mybatis</strong></h1><h2 id="第一节-综合"><a href="#第一节-综合" class="headerlink" title="第一节 综合"></a><strong>第一节 综合</strong></h2><h4 id="问：Mybatis原理？"><a href="#问：Mybatis原理？" class="headerlink" title="问：Mybatis原理？"></a><strong>问：Mybatis原理？</strong></h4><details><br><br>&gt; <em> sqlsessionFactoryBuilder生成sqlsessionFactory（单例）<br>&gt; </em> 工厂模式生成sqlsession执行sql以及控制事务<br>&gt; * Mybatis通过动态代理使Mapper（sql映射器）接口能运行起来即为接口生成代理对象将sql查询到结果映射成pojo<br><br></details><h4 id="问：sqlSessionFactory构建过程？"><a href="#问：sqlSessionFactory构建过程？" class="headerlink" title="问：sqlSessionFactory构建过程？"></a><strong>问：sqlSessionFactory构建过程？</strong></h4><details><br><br>&gt; <em> 解析并读取配置中的xml创建Configuration对象 （单例）<br>&gt; </em> 使用Configruation类去创建sqlSessionFactory（builder模式）<br><br></details><h4 id="问：Mybatis一级缓存与二级缓存？"><a href="#问：Mybatis一级缓存与二级缓存？" class="headerlink" title="问：Mybatis一级缓存与二级缓存？"></a><strong>问：Mybatis一级缓存与二级缓存？</strong></h4><details><br><br>&emsp;&emsp;默认情况下一级缓存是开启的，而且是不能关闭的。<br><br>&gt; <em> 一级缓存是指 SqlSession 级别的缓存 原理：使用的数据结构是一个 map，如果两次中间出现 commit 操作 （修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空<br>&gt; </em> 二级缓存是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存； 原理： 是通过 CacheExecutor 实现的。CacheExecutor其实是 Executor 的代理对象<br><br></details><h3 id="问：讲一下Mybatis基于接口完成查询的过程及原理？"><a href="#问：讲一下Mybatis基于接口完成查询的过程及原理？" class="headerlink" title="问：讲一下Mybatis基于接口完成查询的过程及原理？"></a><strong>问：讲一下Mybatis基于接口完成查询的过程及原理？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Mybatis的一级缓存和二级缓存？"><a href="#问：讲一下Mybatis的一级缓存和二级缓存？" class="headerlink" title="问：讲一下Mybatis的一级缓存和二级缓存？"></a><strong>问：讲一下Mybatis的一级缓存和二级缓存？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Mybatis相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——分布式</title>
    <link href="http://linyishui.top/2020050201.html"/>
    <id>http://linyishui.top/2020050201.html</id>
    <published>2020-05-02T10:45:03.000Z</published>
    <updated>2020-08-19T07:23:56.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h1><h2 id="第一节-待整理"><a href="#第一节-待整理" class="headerlink" title="第一节 待整理"></a><strong>第一节 待整理</strong></h2><h4 id="问：分布式事务的控制？"><a href="#问：分布式事务的控制？" class="headerlink" title="问：分布式事务的控制？"></a><strong>问：分布式事务的控制？</strong></h4><details><br><br><br><br></details><h4 id="问：分布式锁如何设计？"><a href="#问：分布式锁如何设计？" class="headerlink" title="问：分布式锁如何设计？"></a><strong>问：分布式锁如何设计？</strong></h4><details><br><br><br><br></details><h4 id="问：分布式-session-如何设计？"><a href="#问：分布式-session-如何设计？" class="headerlink" title="问：分布式 session 如何设计？"></a><strong>问：分布式 session 如何设计？</strong></h4><details><br><br><br><br></details><h4 id="问：分布式ID？"><a href="#问：分布式ID？" class="headerlink" title="问：分布式ID？"></a><strong>问：分布式ID？</strong></h4><details><br><br><a href="https://zhuanlan.zhihu.com/p/107420326" target="_blank" rel="noopener">9种 分布式ID生成方式</a><br><br></details><h2 id="第二节-dubbo"><a href="#第二节-dubbo" class="headerlink" title="第二节 dubbo"></a><strong>第二节 dubbo</strong></h2><h4 id="问：dubbo-的组件有哪些，及其作用？"><a href="#问：dubbo-的组件有哪些，及其作用？" class="headerlink" title="问：dubbo 的组件有哪些，及其作用？"></a><strong>问：dubbo 的组件有哪些，及其作用？</strong></h4><details><br><br><br></details><h4 id="问：dubbo-SPI-机制；远程接口调用过程？"><a href="#问：dubbo-SPI-机制；远程接口调用过程？" class="headerlink" title="问：dubbo SPI 机制；远程接口调用过程？"></a><strong>问：dubbo SPI 机制；远程接口调用过程？</strong></h4><details><br><br><br><br></details><h4 id="问：dubbo-支持的协议及序列化方式？"><a href="#问：dubbo-支持的协议及序列化方式？" class="headerlink" title="问：dubbo 支持的协议及序列化方式？"></a><strong>问：dubbo 支持的协议及序列化方式？</strong></h4><details><br><br><br><br></details><h4 id="问：dubbo-的负载均衡和容错策略？"><a href="#问：dubbo-的负载均衡和容错策略？" class="headerlink" title="问：dubbo 的负载均衡和容错策略？"></a><strong>问：dubbo 的负载均衡和容错策略？</strong></h4><details><br><br><br><br></details><h4 id="问：服务调用超时问题怎么解决？"><a href="#问：服务调用超时问题怎么解决？" class="headerlink" title="问：服务调用超时问题怎么解决？"></a><strong>问：服务调用超时问题怎么解决？</strong></h4><details><br><br><br><br></details><h4 id="问：Dubbo支持哪些序列化方式？"><a href="#问：Dubbo支持哪些序列化方式？" class="headerlink" title="问：Dubbo支持哪些序列化方式？"></a><strong>问：Dubbo支持哪些序列化方式？</strong></h4><details><br><br><br><br></details><h4 id="问：Dubbo和SpringCloud的关系？"><a href="#问：Dubbo和SpringCloud的关系？" class="headerlink" title="问：Dubbo和SpringCloud的关系？"></a><strong>问：Dubbo和SpringCloud的关系？</strong></h4><details><br><br><br><br></details><h4 id="问：Dubbo的架构设计？一共划分了哪些层？"><a href="#问：Dubbo的架构设计？一共划分了哪些层？" class="headerlink" title="问：Dubbo的架构设计？一共划分了哪些层？"></a><strong>问：Dubbo的架构设计？一共划分了哪些层？</strong></h4><details><br><br><br><br></details><h4 id="问：Dubbo的默认集群容错方案？"><a href="#问：Dubbo的默认集群容错方案？" class="headerlink" title="问：Dubbo的默认集群容错方案？"></a><strong>问：Dubbo的默认集群容错方案？</strong></h4><details><br><br><br><br></details><h4 id="问：Dubbo使用的是什么通信框架"><a href="#问：Dubbo使用的是什么通信框架" class="headerlink" title="问：Dubbo使用的是什么通信框架?"></a><strong>问：Dubbo使用的是什么通信框架?</strong></h4><details><br><br><br><br></details><h4 id="问：-Dubbo的主要应用场景？"><a href="#问：-Dubbo的主要应用场景？" class="headerlink" title="问： Dubbo的主要应用场景？"></a><strong>问： Dubbo的主要应用场景？</strong></h4><details><br><br><br><br></details><h4 id="问：Dubbo服务注册与发现的流程？流程说明。"><a href="#问：Dubbo服务注册与发现的流程？流程说明。" class="headerlink" title="问：Dubbo服务注册与发现的流程？流程说明。"></a><strong>问：Dubbo服务注册与发现的流程？流程说明。</strong></h4><details><br><br><br><br></details><h4 id="问：Dubbo的集群容错方案有哪些？"><a href="#问：Dubbo的集群容错方案有哪些？" class="headerlink" title="问：Dubbo的集群容错方案有哪些？"></a><strong>问：Dubbo的集群容错方案有哪些？</strong></h4><details><br><br><br></details><h4 id="问：-Dubbo的四大组件？"><a href="#问：-Dubbo的四大组件？" class="headerlink" title="问： Dubbo的四大组件？"></a><strong>问： Dubbo的四大组件？</strong></h4><details><br><br><br></details><h4 id="问：Dubbo在安全机制方面是如何解决的？"><a href="#问：Dubbo在安全机制方面是如何解决的？" class="headerlink" title="问：Dubbo在安全机制方面是如何解决的？"></a><strong>问：Dubbo在安全机制方面是如何解决的？</strong></h4><details><br><br><br></details><h4 id="问：Dubbo支持哪些协议，每种协议的应用场景，优缺点？"><a href="#问：Dubbo支持哪些协议，每种协议的应用场景，优缺点？" class="headerlink" title="问：Dubbo支持哪些协议，每种协议的应用场景，优缺点？"></a><strong>问：Dubbo支持哪些协议，每种协议的应用场景，优缺点？</strong></h4><details><br><br><br></details><h4 id="问：Dubbo的集群容错方案有哪些？-1"><a href="#问：Dubbo的集群容错方案有哪些？-1" class="headerlink" title="问：Dubbo的集群容错方案有哪些？"></a><strong>问：Dubbo的集群容错方案有哪些？</strong></h4><details><br><br><br></details><h4 id="问：Dubbo的核心功能有哪些？"><a href="#问：Dubbo的核心功能有哪些？" class="headerlink" title="问：Dubbo的核心功能有哪些？"></a><strong>问：Dubbo的核心功能有哪些？</strong></h4><details><br><br><br></details><h4 id="问：Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？"><a href="#问：Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？" class="headerlink" title="问：Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？"></a><strong>问：Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？</strong></h4><details><br><br><br></details><h4 id="问：Dubbo集群的负载均衡有哪些策略"><a href="#问：Dubbo集群的负载均衡有哪些策略" class="headerlink" title="问：Dubbo集群的负载均衡有哪些策略"></a><strong>问：Dubbo集群的负载均衡有哪些策略</strong></h4><details><br><br><br></details><h4 id="问：为什么需要服务治理？"><a href="#问：为什么需要服务治理？" class="headerlink" title="问：为什么需要服务治理？"></a><strong>问：为什么需要服务治理？</strong></h4><details><br><br><br></details><h4 id="问：Dubbo超时时间怎样设置？"><a href="#问：Dubbo超时时间怎样设置？" class="headerlink" title="问：Dubbo超时时间怎样设置？"></a><strong>问：Dubbo超时时间怎样设置？</strong></h4><details><br><br><br></details><h2 id="第三节-zookeeper"><a href="#第三节-zookeeper" class="headerlink" title="第三节 zookeeper"></a><strong>第三节 zookeeper</strong></h2><h4 id="问：zookeeper-的-ZAB-协议工作原理？"><a href="#问：zookeeper-的-ZAB-协议工作原理？" class="headerlink" title="问：zookeeper 的 ZAB 协议工作原理？"></a><strong>问：zookeeper 的 ZAB 协议工作原理？</strong></h4><details><br><br><br><br></details><h4 id="问：zookeeper-的-Watcher-机制？"><a href="#问：zookeeper-的-Watcher-机制？" class="headerlink" title="问：zookeeper 的 Watcher 机制？"></a><strong>问：zookeeper 的 Watcher 机制？</strong></h4><details><br><br><br><br></details><h4 id="问：zookeeper-的数据存储？"><a href="#问：zookeeper-的数据存储？" class="headerlink" title="问：zookeeper 的数据存储？"></a><strong>问：zookeeper 的数据存储？</strong></h4><details><br><br><br><br></details><h4 id="问：zookeeper-的负载均衡算法？"><a href="#问：zookeeper-的负载均衡算法？" class="headerlink" title="问：zookeeper 的负载均衡算法？"></a><strong>问：zookeeper 的负载均衡算法？</strong></h4><details><br><br><br><br></details><h4 id="问：rocketmq-的模块功能？"><a href="#问：rocketmq-的模块功能？" class="headerlink" title="问：rocketmq 的模块功能？"></a><strong>问：rocketmq 的模块功能？</strong></h4><details><br><br><br><br></details><h4 id="问：rocketmq-的高可用及高性能？"><a href="#问：rocketmq-的高可用及高性能？" class="headerlink" title="问：rocketmq 的高可用及高性能？"></a><strong>问：rocketmq 的高可用及高性能？</strong></h4><details><br><br><br><br></details><h2 id="第四节-ElasticSearch"><a href="#第四节-ElasticSearch" class="headerlink" title="第四节 ElasticSearch"></a><strong>第四节 ElasticSearch</strong></h2><h4 id="问：你们公司的ES集群，一个node一般会分配几个分片？"><a href="#问：你们公司的ES集群，一个node一般会分配几个分片？" class="headerlink" title="问：你们公司的ES集群，一个node一般会分配几个分片？"></a><strong>问：你们公司的ES集群，一个node一般会分配几个分片？</strong></h4><details><br><br><br><br></details><h4 id="问：Elasticsearch是如何实现Master选举的？"><a href="#问：Elasticsearch是如何实现Master选举的？" class="headerlink" title="问：Elasticsearch是如何实现Master选举的？"></a><strong>问：Elasticsearch是如何实现Master选举的？</strong></h4><details><br><br><br><br></details><h4 id="问：你是如何做写入调优的？"><a href="#问：你是如何做写入调优的？" class="headerlink" title="问：你是如何做写入调优的？"></a><strong>问：你是如何做写入调优的？</strong></h4><details><br><br><br><br></details><h4 id="问：什么是脑裂？如何避免脑裂？"><a href="#问：什么是脑裂？如何避免脑裂？" class="headerlink" title="问：什么是脑裂？如何避免脑裂？"></a><strong>问：什么是脑裂？如何避免脑裂？</strong></h4><details><br><br><br><br></details><h4 id="问：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？"><a href="#问：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？" class="headerlink" title="问：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？"></a><strong>问：Elasticsearch对于大数据量（上亿量级）的聚合如何实现？</strong></h4><details><br><br><br><br></details><h4 id="问：ES主分片数量可以在后期更改吗？为什么？"><a href="#问：ES主分片数量可以在后期更改吗？为什么？" class="headerlink" title="问：ES主分片数量可以在后期更改吗？为什么？"></a><strong>问：ES主分片数量可以在后期更改吗？为什么？</strong></h4><details><br><br><br><br></details><h4 id="问：如何监控集群状态？"><a href="#问：如何监控集群状态？" class="headerlink" title="问：如何监控集群状态？"></a><strong>问：如何监控集群状态？</strong></h4><details><br><br><br><br></details><h4 id="问：ElasticSearch中的副本是什么？"><a href="#问：ElasticSearch中的副本是什么？" class="headerlink" title="问：ElasticSearch中的副本是什么？"></a><strong>问：ElasticSearch中的副本是什么？</strong></h4><details><br><br><br><br></details><h4 id="问：ES更新数据的执行流程？"><a href="#问：ES更新数据的执行流程？" class="headerlink" title="问：ES更新数据的执行流程？"></a><strong>问：ES更新数据的执行流程？</strong></h4><details><br><br><br><br></details><h4 id="问：shard里面是什么组成的？"><a href="#问：shard里面是什么组成的？" class="headerlink" title="问：shard里面是什么组成的？"></a><strong>问：shard里面是什么组成的？</strong></h4><details><br><br><br><br></details><h4 id="问：ElasticSearch中的分析器是什么？"><a href="#问：ElasticSearch中的分析器是什么？" class="headerlink" title="问：ElasticSearch中的分析器是什么？"></a><strong>问：ElasticSearch中的分析器是什么？</strong></h4><details><br><br><br><br></details><h4 id="问：客户端在和集群连接时，如何选择特定的节点执行请求的？"><a href="#问：客户端在和集群连接时，如何选择特定的节点执行请求的？" class="headerlink" title="问：客户端在和集群连接时，如何选择特定的节点执行请求的？"></a><strong>问：客户端在和集群连接时，如何选择特定的节点执行请求的？</strong></h4><details><br><br><br><br></details><h4 id="问：Elasticsearch中的倒排索引是什么？"><a href="#问：Elasticsearch中的倒排索引是什么？" class="headerlink" title="问：Elasticsearch中的倒排索引是什么？"></a><strong>问：Elasticsearch中的倒排索引是什么？</strong></h4><details><br><br><br><br></details><h4 id="问：什么是索引？索引（名词）-一个索引-index"><a href="#问：什么是索引？索引（名词）-一个索引-index" class="headerlink" title="问：什么是索引？索引（名词） 一个索引(index)"></a><strong>问：什么是索引？索引（名词） 一个索引(index)</strong></h4><details><br><br><br><br></details><h4 id="问：详细描述一下Elasticsearch更新和删除文档的过程？"><a href="#问：详细描述一下Elasticsearch更新和删除文档的过程？" class="headerlink" title="问：详细描述一下Elasticsearch更新和删除文档的过程？"></a><strong>问：详细描述一下Elasticsearch更新和删除文档的过程？</strong></h4><details><br><br><br><br></details><h4 id="问：elasticsearch-的系统架构及读写过程？"><a href="#问：elasticsearch-的系统架构及读写过程？" class="headerlink" title="问：elasticsearch 的系统架构及读写过程？"></a><strong>问：elasticsearch 的系统架构及读写过程？</strong></h4><details><br><br><br><br></details><h4 id="问：elasticsearch-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"><a href="#问：elasticsearch-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？" class="headerlink" title="问：elasticsearch 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"></a><strong>问：elasticsearch 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</strong></h4><details><br><br><br><br></details><h2 id="第五节-消息中间件"><a href="#第五节-消息中间件" class="headerlink" title="第五节 消息中间件"></a><strong>第五节 消息中间件</strong></h2><h4 id="问：eureka-的相关原理，和-zookeeper-的比较？"><a href="#问：eureka-的相关原理，和-zookeeper-的比较？" class="headerlink" title="问：eureka 的相关原理，和 zookeeper 的比较？"></a><strong>问：eureka 的相关原理，和 zookeeper 的比较？</strong></h4><details><br><br><br><br></details><h4 id="问：LVS（4层与7层）原理？"><a href="#问：LVS（4层与7层）原理？" class="headerlink" title="问：LVS（4层与7层）原理？"></a><strong>问：LVS（4层与7层）原理？</strong></h4><details><br><br>&gt; <em> 由前端虚拟负载均衡器和后端真实服务器群组成；<br>&gt; </em> 请求发送给虚拟服务器后其根据包转发策略以及负载均衡调度算法转发给真实服务器<br>&gt; * 所谓四层（lvs，f5）就是基于IP+端口的负载均衡；七层（nginx）就是基于URL等应用层信息的负载均衡<br><br></details><h4 id="问：zookeeper实现分布式锁？"><a href="#问：zookeeper实现分布式锁？" class="headerlink" title="问：zookeeper实现分布式锁？"></a><strong>问：zookeeper实现分布式锁？</strong></h4><details><br><br><br>（1）：利用节点名称唯一性来实现，加锁时所有客户端一起创建节点，只有一个创建成功者获得锁，解锁时删除节点。<br><br>（2）：利用临时顺序节点实现，加锁时所有客户端都创建临时顺序节点，创建节点序列号最小的获得锁，否则监视比自己序列号次小的节点进行等待<br><br>（3）：方案2比1好处是当zookeeper宕机后，临时顺序节点会自动删除释放锁，不会造成锁等待；<br><br>（4）：方案1会产生惊群效应（当有很多进程在等待锁的时候，在释放锁的时候会有很多进程就过来争夺锁）。<br><br>（5）：由于需要频繁创建和删除节点，性能上不如redis锁<br><br></details><h4 id="问：消费者获取消息有几种模式？"><a href="#问：消费者获取消息有几种模式？" class="headerlink" title="问：消费者获取消息有几种模式？"></a><strong>问：消费者获取消息有几种模式？</strong></h4><details><br><br><br><br></details><h4 id="问：说说你对Consumer的了解？"><a href="#问：说说你对Consumer的了解？" class="headerlink" title="问：说说你对Consumer的了解？"></a><strong>问：说说你对Consumer的了解？</strong></h4><details><br><br><br><br></details><h4 id="问：介绍下Kafka？Kafka的优点？Kafka-的设计是什么样的呢？"><a href="#问：介绍下Kafka？Kafka的优点？Kafka-的设计是什么样的呢？" class="headerlink" title="问：介绍下Kafka？Kafka的优点？Kafka 的设计是什么样的呢？"></a><strong>问：介绍下Kafka？Kafka的优点？Kafka 的设计是什么样的呢？</strong></h4><details><br><br><br><br></details><h4 id="问：什么情况会导致Kafka运行变慢？"><a href="#问：什么情况会导致Kafka运行变慢？" class="headerlink" title="问：什么情况会导致Kafka运行变慢？"></a><strong>问：什么情况会导致Kafka运行变慢？</strong></h4><details><br><br><br><br></details><h4 id="问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？"><a href="#问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？" class="headerlink" title="问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？"></a><strong>问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？</strong></h4><details><br><br><br><br></details><h4 id="问：Kafka新建的分区会在哪个目录下创建？"><a href="#问：Kafka新建的分区会在哪个目录下创建？" class="headerlink" title="问：Kafka新建的分区会在哪个目录下创建？"></a><strong>问：Kafka新建的分区会在哪个目录下创建？</strong></h4><details><br><br><br><br></details><h4 id="问：Kafka-与传统消息系统之间有三个关键区别？"><a href="#问：Kafka-与传统消息系统之间有三个关键区别？" class="headerlink" title="问：Kafka 与传统消息系统之间有三个关键区别？"></a><strong>问：Kafka 与传统消息系统之间有三个关键区别？</strong></h4><details><br><br><br><br></details><h4 id="问：请详细说一下推送模式和拉取模式？"><a href="#问：请详细说一下推送模式和拉取模式？" class="headerlink" title="问：请详细说一下推送模式和拉取模式？"></a><strong>问：请详细说一下推送模式和拉取模式？</strong></h4><details><br><br><br><br></details><h4 id="问：-kafka消息发送的可靠性机制有几种？"><a href="#问：-kafka消息发送的可靠性机制有几种？" class="headerlink" title="问： kafka消息发送的可靠性机制有几种？"></a><strong>问： kafka消息发送的可靠性机制有几种？</strong></h4><details><br><br><br><br></details><h4 id="问：Kafka如何判断一个节点是否存活？"><a href="#问：Kafka如何判断一个节点是否存活？" class="headerlink" title="问：Kafka如何判断一个节点是否存活？"></a><strong>问：Kafka如何判断一个节点是否存活？</strong></h4><details><br><br><br><br></details><h4 id="问：Kafka-数据存储设计？"><a href="#问：Kafka-数据存储设计？" class="headerlink" title="问：Kafka 数据存储设计？"></a><strong>问：Kafka 数据存储设计？</strong></h4><details><br><br><br><br></details><h4 id="问：为何需要Kafka集群？"><a href="#问：为何需要Kafka集群？" class="headerlink" title="问：为何需要Kafka集群？"></a><strong>问：为何需要Kafka集群？</strong></h4><details><br><br><br><br></details><h4 id="问：kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka将如何处理？"><a href="#问：kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka将如何处理？" class="headerlink" title="问：kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka将如何处理？"></a><strong>问：kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka将如何处理？</strong></h4><details><br><br><br><br></details><h4 id="问：RocketMQ的特点有哪些？"><a href="#问：RocketMQ的特点有哪些？" class="headerlink" title="问：RocketMQ的特点有哪些？"></a><strong>问：RocketMQ的特点有哪些？</strong></h4><details><br><br><br><br></details><h4 id="问：RocketMQ-由哪些角色组成？"><a href="#问：RocketMQ-由哪些角色组成？" class="headerlink" title="问：RocketMQ 由哪些角色组成？"></a><strong>问：RocketMQ 由哪些角色组成？</strong></h4><details><br><br><br><br></details>]]></content>
    
    <summary type="html">
    
      整理面试中常问的分布式相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Spring Cloud</title>
    <link href="http://linyishui.top/2020050101.html"/>
    <id>http://linyishui.top/2020050101.html</id>
    <published>2020-05-01T10:44:28.000Z</published>
    <updated>2020-05-12T07:33:08.027Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a><strong>Java并发编程</strong></h1><h2 id="第一节-待整理"><a href="#第一节-待整理" class="headerlink" title="第一节 待整理"></a><strong>第一节 待整理</strong></h2><h4 id="问：Zuul与Gateway区别？"><a href="#问：Zuul与Gateway区别？" class="headerlink" title="问：Zuul与Gateway区别？"></a><strong>问：Zuul与Gateway区别？</strong></h4><details><br><br>（1）：zuul则是netflix公司的项目集成在spring-cloud中使用而已， Gateway是spring-cloud的 一个子项目；<br><br>（2）：zuul不提供异步支持流控等均由hystrix支持， gateway提供了异步支持，提供了抽象负载均衡，提供了抽象流控； 理论上gateway则更适合于提高系统吞吐量（但不一定能有更好的性能），最终性能还需要通过严密的压测来决定<br><br>（3）：两者底层实现都是servlet，但是gateway多嵌套了一层webflux框架<br><br>（4）： zuul可用至其他微服务框架中，内部没有实现限流、负载均衡；gateway只能用在springcloud中；<br><br></details><h4 id="问：Zuul原理分析？"><a href="#问：Zuul原理分析？" class="headerlink" title="问：Zuul原理分析？"></a><strong>问：Zuul原理分析？</strong></h4><details><br><br>（1）：请求给zuulservlet处理（HttpServlet子类） zuulservlet中有一个zuulRunner对象，该对象中初始化了RequestContext（存储请求的数据），RequestContext被所有的zuulfilter共享；<br><br>（2）： zuulRunner中有 FilterProcessor（zuulfilter的管理器），其从filterloader 中获取zuulfilter；<br><br>（3）：有了这些filter之后， zuulservelet执行的Pre-&gt; route-&gt; post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行error类型的过滤器，执行完后把结果返回给客户端.<br><br></details><h4 id="问：Gateway原理分析？"><a href="#问：Gateway原理分析？" class="headerlink" title="问：Gateway原理分析？"></a><strong>问：Gateway原理分析？</strong></h4><details><br><br>（1）：请求到达DispatcherHandler， DispatchHandler在IOC容器初始化时会在容器中实例化HandlerMapping接口<br><br>（2）：用handlerMapping根据请求URL匹配到对应的Route，然后有对应的filter做对应的请求转发最终response返回去<br><br></details><h4 id="问：Zookeeper-工作原理（待查）？"><a href="#问：Zookeeper-工作原理（待查）？" class="headerlink" title="问：Zookeeper 工作原理（待查）？"></a><strong>问：Zookeeper 工作原理（待查）？</strong></h4><details><br><br>&emsp;&emsp;Zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。<br><br></details><h4 id="问：zoo与eur区别？"><a href="#问：zoo与eur区别？" class="headerlink" title="问：zoo与eur区别？"></a><strong>问：zoo与eur区别？</strong></h4><details><br><br>&gt; <em> zookeeper保证cp（一致性）<br>&gt; </em> eureka保证ap（可用性）<br>&gt; <em> zoo在选举期间注册服务瘫痪，期间不可用<br>&gt; </em> eur各个节点平等关系，只要有一台就可保证服务可用，而查询到的数据可能不是最新的，可以很好应对网络故障导致部分节点失联情况<br>&gt; <em> zoo有leader和follower角色，eur各个节点平等<br>&gt; </em> zoo采用半数存活原则（避免脑裂），eur采用自我保护机制来解决分区问题<br>&gt; * eur本质是个工程，zoo只是一个进程 ZooKeeper基于CP，不保证高可用，如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。 Eureka基于AP，能保证高可用，即使所有机器都挂了，也能拿到本地缓存的数据。作为注册中心，其实配置是不经常变动的，只有发版（发布新的版本）和机器出故障时会变。对于不经常变动的配置来说，CP是不合适的，而AP在遇到问题时可以用牺牲一致性来保证可用性，既返回旧数据，缓存数据。 所以理论上Eureka是更适合做注册中心。而现实环境中大部分项目可能会使用ZooKeeper，那是因为集群不够大，并且基本不会遇到用做注册中心的机器一半以上都挂了的情况。所以实际上也没什么大问题。<br><br></details><h4 id="问：Hystrix原理（待查）？"><a href="#问：Hystrix原理（待查）？" class="headerlink" title="问：Hystrix原理（待查）？"></a><strong>问：Hystrix原理（待查）？</strong></h4><details><br><br>&emsp;&emsp;通过维护一个自己的线程池，当线程池达到阈值的时候，就启动服务降级，返回fallback默认值<br><br></details><h4 id="问：为什么需要hystrix熔断？"><a href="#问：为什么需要hystrix熔断？" class="headerlink" title="问：为什么需要hystrix熔断？"></a><strong>问：为什么需要hystrix熔断？</strong></h4><details><br><br>&emsp;&emsp;防止雪崩，及时释放资源，防止系统发生更多的额级联故障，需要对故障和延迟进行隔离，防止单个依赖关系的失败影响整个应用程序；<br><br></details><h4 id="问：微服务优缺点？"><a href="#问：微服务优缺点？" class="headerlink" title="问：微服务优缺点？"></a><strong>问：微服务优缺点？</strong></h4><details><br><br>&gt; <em> 每个服务高内聚，松耦合，面向接口编程；<br>&gt; </em> 服务间通信成本，数据一致性，多服务运维难度增加，http传输效率不如rpc<br><br></details><h4 id="问：eureka自我保护机制？"><a href="#问：eureka自我保护机制？" class="headerlink" title="问：eureka自我保护机制？"></a><strong>问：eureka自我保护机制？</strong></h4><details><br><br>&gt; <em> eur不移除长时间没收到心跳而应该过期的服务<br>&gt; </em> 仍然接受新服务注册和查询请求，但是不会同步到其它节点（高可用）<br>&gt; * 当网络稳定后，当前实例新注册信息会同步到其它节点（最终一致性）<br><br></details><h4 id="问：MQ对比？"><a href="#问：MQ对比？" class="headerlink" title="问：MQ对比？"></a><strong>问：MQ对比？</strong></h4><details><br><br>&gt; <em> ActiveMQ：Apache出品，最早使用的消息队列产品，时间比较长了，最近版本更新比较缓慢。 RabbitMQ：erlang语言开发，支持很多的协议，非常重量级，更适合于企业级的开发。性能较好，但是不利于做二次开发和维护。<br>&gt; </em> RocketMQ：阿里开源的消息中间件，纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点，分布式事务。 ZeroMQ：号称最快的消息队列系统，尤其针对大吞吐量的需求场景，采用 C 语言实现。 消息队列的选型需要根据具体应用需求而定，ZeroMQ 小而美，RabbitMQ 大而稳，Kakfa 和 RocketMQ 快而强劲<br><br></details><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Spring Cloud相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>对象序列化</title>
    <link href="http://linyishui.top/2020042501.html"/>
    <id>http://linyishui.top/2020042501.html</id>
    <published>2020-04-25T10:21:08.000Z</published>
    <updated>2020-06-29T08:41:51.921Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是序列化？"><a href="#1-1-什么是序列化？" class="headerlink" title="1.1 什么是序列化？"></a><strong>1.1 什么是序列化？</strong></h3><p>&emsp;&emsp;序列化指<strong>将一个Java对象转化为二进制序列</strong>，可以看作一个 <code>byte[]</code> 字节数组。</p><h3 id="1-2-为什么要序列化？"><a href="#1-2-为什么要序列化？" class="headerlink" title="1.2 为什么要序列化？"></a><strong>1.2 为什么要序列化？</strong></h3><p>&emsp;&emsp;需要<strong>把对象等数据转为字节序列进行传输</strong>。序列化后方便把对象<strong>存入文件</strong>或是通过<strong>网络传输</strong>到远程服务器。</p><h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a><strong>1.3 使用场景</strong></h3><blockquote><ul><li><strong>持久保存</strong>：保存对象的字节序列到本地文件或数据库</li><li><strong>网络传输</strong>：序列化后写入字节流使对象得以在网络中传输</li><li><strong>传递对象</strong>：通过序列化在进程间传递对象</li></ul></blockquote><h3 id="1-4-序列化与反序列化"><a href="#1-4-序列化与反序列化" class="headerlink" title="1.4 序列化与反序列化"></a><strong>1.4 序列化与反序列化</strong></h3><p>&emsp;&emsp;把对象等数据转为字节序列的这个过程就是序列化，还原的过程就是反序列化。</p><p>&emsp;&emsp;注意：<strong>反序列化时，由JVM直接构造出Java对象，不调用构造方法</strong>，构造方法内部的代码，在反序列化时根本不可能执行。</p><hr><h2 id="第二节-Java序列化"><a href="#第二节-Java序列化" class="headerlink" title="第二节 Java序列化"></a><strong>第二节 Java序列化</strong></h2><p>&emsp;&emsp;Java支持<strong>对象序列化</strong>机制可以将任何对象写出到流中，并在之后读回。其实现机制主要基于两个接口 <code>Serializable</code> 和 <code>Externalizable</code> 。</p><p>&emsp;&emsp;实现 <code>Serializable</code> 接口表示此类的对象是可序列化的。如果类中的成员变量是引用类型，那么它也必须实现<code>Serializable</code> 接口才能保证序列化成功。</p><h3 id="2-1-ObjectInputStream与ObjectOutputStream"><a href="#2-1-ObjectInputStream与ObjectOutputStream" class="headerlink" title="2.1 ObjectInputStream与ObjectOutputStream"></a><strong>2.1 ObjectInputStream与ObjectOutputStream</strong></h3><p>&emsp;&emsp;可以通过库提供的 <code>ObjectInputStream</code> ，<code>ObjectOutputStream</code> 类来进行对象的序列化。</p><p>&emsp;&emsp;以下示例通过 <code>ObjectOutputStream</code> 保存对象数据，<code>ObjectInputStream</code> 读回对象数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">3000</span>,<span class="number">1995</span>,<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">Manager manager = <span class="keyword">new</span> Manager(<span class="string">"李四"</span>,<span class="number">8000</span>,<span class="number">1986</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">oos.writeObject(employee);</span><br><span class="line">oos.writeObject(manager);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.dat"</span>));</span><br><span class="line">Employee e1 = (Employee)in.readObject();</span><br><span class="line">Employee e2 = (Employee)in.readObject();</span><br><span class="line">System.out.println(e1.toString());</span><br><span class="line">System.out.println(e2.toString());</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果如下。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name<span class="string">[张三]</span> pay<span class="string">[3000]</span> year<span class="string">[1995]</span> month<span class="string">[8]</span> day<span class="string">[1]</span></span><br><span class="line">name<span class="string">[李四]</span> pay<span class="string">[8000]</span> year<span class="string">[1986]</span> month<span class="string">[12]</span> day<span class="string">[15]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <code>writeObject()</code> 和 <code>readObject()</code> 方法只能写出对象，如果想使用基本数据类型需要实现 <code>DataInput</code> 和 <code>DataOutput</code> 定义的相对方法，对象流已经都实现了所需方法：<code>readXX()</code> 和 <code>writeXX()</code> 系列方法支持各种数据类型的字节读写（包括各种基本类型、UTF-8编码的String和实现了Serializable接口的Object等）。</p><p>&emsp;&emsp;<code>ObjectOutputStream</code>（序列化）可以把一个Java对象变为 <code>byte[]</code> 数组，它负责把一个Java对象写入一个字节流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span>, <span class="title">ObjectStreamConstants</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">            writeObjectOverride(obj);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">                writeFatalException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Underlying writeObject/writeUnshared implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check for replacement object</span></span><br><span class="line">            Object orig = obj;</span><br><span class="line">            Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">            ObjectStreamClass desc;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">                Class&lt;?&gt; repCl;</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                    (repCl = obj.getClass()) == cl)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = repCl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">                Object rep = replaceObject(obj);</span><br><span class="line">                <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cl = rep.getClass();</span><br><span class="line">                    desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                obj = rep;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line">            <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">                subs.assign(orig, obj);</span><br><span class="line">                <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    writeNull();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    writeHandle(h);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                    writeClass((Class) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remaining cases 当对象非字符串、数组、枚举类以及Serializable时会抛出NotSerializableException</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                writeString((String) obj, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                writeArray(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">                writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            bout.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> val)</span>  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        bout.writeInt(val);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos + <span class="number">4</span> &lt;= MAX_BLOCK_SIZE) &#123;</span><br><span class="line">            Bits.putInt(buf, pos, v);</span><br><span class="line">            pos += <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dout.writeInt(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>ObjectInputStream</code>（反序列化）则负责从一个字节流读取Java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span>, <span class="title">ObjectStreamConstants</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">            <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">        <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">            handles.markDependency(outerHandle, passHandle);</span><br><span class="line">            ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">                vlist.doCallbacks();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            passHandle = outerHandle;</span><br><span class="line">            <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">                clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bin.readBoolean();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = read();</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (v != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ObjectInputStream</code> 可能抛出的异常包括：</p><ul><li><code>ClassNotFoundException</code> ：没有找到对应的Class，如Person对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义Person类，所以无法反序列化。</li><li><code>InvalidClassException</code> ：Class不匹配，如序列化的Person对象定义了一个int类型的age字段，但是反序列化时，Person类定义的age字段被改成了long类型，所以导致class不兼容。</li></ul></blockquote><p>&emsp;&emsp;为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的 <code>serialVersionUID</code> 静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。</p><h3 id="2-2-序列化ID"><a href="#2-2-序列化ID" class="headerlink" title="2.2 序列化ID"></a><strong>2.2 序列化ID</strong></h3><p>&emsp;&emsp;<strong>序列化ID</strong>（serialVersionUID）可以看作版本号，序列化对象的唯一标识，如果序列化ID不同（比如新版本不兼容旧版本）或修改了对象的信息，反序列化时就会抛出 <code>InvalidClassException</code> 异常。</p><p>&emsp;&emsp;序列化ID可以通过以下两种方式生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认1L</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// 根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = xxxL;</span><br></pre></td></tr></table></figure><h3 id="2-3-安全性"><a href="#2-3-安全性" class="headerlink" title="2.3 安全性"></a><strong>2.3 安全性</strong></h3><p>&emsp;&emsp;因为Java的序列化机制可以导致一个实例能直接从 <code>byte[]</code> 数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的 <code>byte[]</code> 数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>&emsp;&emsp;实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h3 id="2-4-Transient"><a href="#2-4-Transient" class="headerlink" title="2.4 Transient"></a><strong>2.4 Transient</strong></h3><p>&emsp;&emsp;某些域是不可被序列化的或着说没有序列化的意义，Java可以通过transient关键字来标记这类域，详细可看这篇<a href="../2019010901.html" title="Title">static,final,transient,volatile等关键字原理作用</a>。</p><h3 id="2-5-自定义序列化"><a href="#2-5-自定义序列化" class="headerlink" title="2.5 自定义序列化"></a><strong>2.5 自定义序列化</strong></h3><p>&emsp;&emsp;对于一个对象只要实现 <code>Serializable</code> 接口，就会可以对 <code>非transient</code> 以及 <code>非static</code> 修饰属性进行序列化工作（静态属性属于类信息，所以不会被序列化）。</p><p>&emsp;&emsp;如果想要<strong>自定义序列化的属性</strong>，除了transient也可以通过重写 <code>readObject()</code> 和 <code>writeObject()</code> 方法来代替默认的自动序列化或通过实现Externalizable接口。</p><blockquote><p>部分属性序列化（自定义序列化）的方法：</p><ul><li><strong>transient</strong></li><li><strong>重写</strong> <code>readObject()</code> 和 <code>writeObject()</code></li><li><strong>实现</strong> <code>Externalizable</code> 接口</li></ul></blockquote><h3 id="2-6-writeReplace-和readResolve"><a href="#2-6-writeReplace-和readResolve" class="headerlink" title="2.6 writeReplace()和readResolve()"></a><strong>2.6 writeReplace()和readResolve()</strong></h3><p>&emsp;&emsp;<code>writeReplace()</code> 在序列化时，会先调用此方法，再调用 <code>writeObject()</code> ，此方法可将任意对象代替目标序列化对象。</p><p>&emsp;&emsp;<code>readResolve()</code> 反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃，此方法在 <code>readObject()</code> 后调用。</p><p>&emsp;&emsp;readResolve常用来反序列单例类，保证单例类的唯一性。</p><p>&emsp;&emsp;注意：<code>readResolve()</code> 与 <code>writeReplace()</code> 的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于final修饰的类重写 <code>readResolve()</code> 方法没有问题；否则，重写 <code>readResolve()</code> 使用private修饰。</p><h3 id="2-7-Externalizable"><a href="#2-7-Externalizable" class="headerlink" title="2.7 Externalizable"></a><strong>2.7 Externalizable</strong></h3><p>&emsp;&emsp;<code>Externalizable</code> 接口继承自 <code>Serializable</code> ，声明了两个方法 <code>writeExternal()</code> 和 <code>readExternal()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两个方法可以<strong>对包含超类在内的对象所有数据的存储和恢复进行管理</strong>，序列化机制在流中仅仅记录对象所属的类。在读入可外部化的类时，对象流将调用无参构造器创建一个新的对象（所以实现Externalizable接口一定要声明无参构造器），然后调用 <code>readExternal()</code> 方法，将字段值分别填充到新的对象中。</p><p>&emsp;&emsp;<code>readObject()</code> 和 <code>writeObject()</code> 是<strong>私有</strong>的，只能被序列化机制调用，而 <code>readExternal()</code> 和 <code>writeExternal()</code> 是<strong>公共</strong>的。</p><blockquote><p>Serializable和Externalizable的区别：</p><ul><li>Serializable没有声明方法，只是一个标识接口。</li><li>Serializable实现时不需要重写 <code>readObject()</code> 和 <code>writeObject()</code>，有默认实现。</li><li>实现Externalizable接口必须声明无参构造器，Serializable则采用反射机制完成内容恢复，没有这个限制。</li><li>Externalizable方式不需要序列化ID，而Serializable接口则需要。</li><li>相比Serializable, Externalizable序列化、反序列更加快速，占用相比较小的内存。</li></ul></blockquote><p>&emsp;&emsp;虽然Externalizable接口带来了一定的性能提升，但相应的复杂度也提高了，所以一般还是会通过实现Serializable接口进行序列化。</p><hr><h2 id="第三节-原理"><a href="#第三节-原理" class="headerlink" title="第三节 原理"></a><strong>第三节 原理</strong></h2><h3 id="3-1-序列化流程"><a href="#3-1-序列化流程" class="headerlink" title="3.1 序列化流程"></a><strong>3.1 序列化流程</strong></h3><p>&emsp;&emsp;Java序列化同一对象，多次的序列化只会得到相同的结果。可以编程试验一下，原因就在于序列化时会对是否序列化过进行检测。</p><blockquote><p>Java序列化算法简单描述：</p><ol><li>所有保存到磁盘的对象都有一个序列化编码号。</li><li>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</li><li>如果此对象已经序列化过，则直接输出编号即可。</li></ol></blockquote><h3 id="3-2-序列化后内容改变"><a href="#3-2-序列化后内容改变" class="headerlink" title="3.2 序列化后内容改变"></a><strong>3.2 序列化后内容改变</strong></h3><p>&emsp;&emsp;当一个对象在序列化后，内容发生了修改，再次序列化会如何？</p><p>&emsp;&emsp;答案是仍然不会再次进行序列化转换，只是保存一下序列化编号。</p><blockquote><p>什么情况下会导致serialVersionUID修改呢？</p><ul><li>如果只是修改了方法，反序列化不容影响，则无需修改版本号。</li><li>如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号。</li><li>如果修改了非瞬态变量，则可能导致反序列化失败。</li><li>如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。</li><li>如果只是新增了实例变量，则反序列化回来新增的是默认值；</li><li>如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li></ul></blockquote><h3 id="3-3-被多个对象共享"><a href="#3-3-被多个对象共享" class="headerlink" title="3.3 被多个对象共享"></a><strong>3.3 被多个对象共享</strong></h3><p>&emsp;&emsp;当一个对象被多个对象共享时，序列化过程是怎么样的呢？</p><p>&emsp;&emsp;每个对象都是用一个序列号保存，第一次调用时，将对象数据保存到流中，如果此对象已被保存过，则只写出”与以保存序列号x对象相同”。</p><p>&emsp;&emsp;对于流中的对象，第一次遇到其序列号时，构建对象，并使用流中的数据来初始化，再记录此序号和新对象之间的关联，当遇到”与以保存序列号x对象相同”此标记时，获取与序号关联的对象引用。</p><p>&emsp;&emsp;对象序列化以特殊的文件格式来存储对象数据，通过对类的域进行排序，然后通过 <code>SHA安全散列算法</code> 得到SHA码，只取前8个字节作为类的<strong>指纹</strong>（指纹即其身份证明）。可以通过对象的指纹和其所属类的指纹进行比对，<strong>当类信息改变时，指纹大概率会不同</strong>（注意是类的结构信息，而非对象数据），所以当两者不同时就抛出一个异常。</p><p>&emsp;&emsp;具体如何进行编码和排布对于当前的学习不是那么重要，只需要知道对象流输出中包含所有对象的类型和数据域，每个对象都被赋予一个序列号，相同对象的重复出现将被存储为对这个对象序列号的引用。</p><h3 id="3-4-序列化单例和类型安全的枚举"><a href="#3-4-序列化单例和类型安全的枚举" class="headerlink" title="3.4 序列化单例和类型安全的枚举"></a><strong>3.4 序列化单例和类型安全的枚举</strong></h3><p>&emsp;&emsp;<a href="../2019030501.html" title="Title">枚举类</a>这篇博客有提到序列化枚举类，当枚举类或使用单例模式进行序列化化时目标对象是唯一的，这其中隐藏着一个问题：<strong>即序列化后的对象和原对象是相等吗？</strong></p><p>&emsp;&emsp;我们实现单例模式时，期望得到的实例应该是唯一的，而<strong>序列化的对象却是一个全新的对象</strong>，所以其它方式实现单例模式时，只要实现了Serializable接口，目标对象就不唯一了，所以需要加如 <code>readResolve()</code>方法来避免这种情况，此方法会直接返回单例对象。</p><p>&emsp;&emsp;而使用Java中的枚举类时不会出现此问题，因为<strong>Jvm限制枚举类型及其枚举常量是唯一的</strong>，在序列化时只会将枚举对象的name属性输出到流中，反序列化时在通过 <code>Enum.valueOf()</code> 方法根据名字来查找枚举对象。同时Jvm禁止了枚举类的 <code>readObject()</code> ， <code>writeObject()</code> 和 <code>readResolve()</code> 等方法，避免上述规范被破坏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;<span class="comment">//定义了此方法后，对象被序列化时会被调用，其返回的对象在之后会成为readObject()的返回值。</span></span><br><span class="line">    <span class="keyword">if</span>(filed == A) <span class="keyword">return</span> Demo.A;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(filed == B) <span class="keyword">return</span> Demo.B;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-克隆和序列化"><a href="#3-5-克隆和序列化" class="headerlink" title="3.5 克隆和序列化"></a><strong>3.5 克隆和序列化</strong></h3><p>&emsp;&emsp;<a href="../2018083001.html" title="Title">Java对象克隆</a>这篇博客中有谈到用序列化去实现克隆，相比重载 <code>equals()</code> 还要更为简单。只要声明对象为可序列化的，将其序列化到流中再读回，即可得到一个深拷贝的结果，但序列化的性能相比复制数据域来说是要慢很多的，所以个人觉得非深克隆的情况还是避免使用好一点。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java核心技术 卷Ⅱ》</p></blockquote><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698" target="_blank" rel="noopener">序列化</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf" target="_blank" rel="noopener">java序列化</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的对象序列化，内容包括：概述（什么是序列化、为什么要序列化、使用场景、序列化与反序列化），Java序列化（ObjectInputStream与ObjectOutputStream、序列化ID、安全性、Transient、自定义序列化、writeReplace()和readResolve()、Externalizable），原理（序列化流程、序列化后内容改变、被多个对象共享、序列化单例和类型安全的枚举、克隆和序列化）。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>办公利器-截图工具</title>
    <link href="http://linyishui.top/2020042301.html"/>
    <id>http://linyishui.top/2020042301.html</id>
    <published>2020-04-23T03:12:27.000Z</published>
    <updated>2020-04-23T09:28:53.512Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a><strong>截图工具</strong></h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a><strong>1. 需求</strong></h2><ul><li>简单易用</li><li>满足截图+实时编辑+保存/复制等基础功能</li><li>能够支持滚动截图</li><li>能够录制动态视频或动态图（最好）</li></ul><h2 id="2-Snipaste"><a href="#2-Snipaste" class="headerlink" title="2. Snipaste"></a><strong>2. Snipaste</strong></h2><p>&emsp;&emsp;<a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a>，可以直接在Windows商店获取，知名的开源贴图/截图软件，除了截图外，贴图是核心内容。写这篇博文的原因也是因为Snipaste无法满足博主日常需求，记录一下我寻找替代方案的过程。</p><p>&emsp;&emsp;这里偷懒一下，直接从官方文档和一些网络上的资源，摘抄我经常使用的功能。</p><p>&emsp;&emsp;以下动图一些快捷键和官方不一致，如<code>F2</code>应为<code>F3</code>，需要注意，懒得一个个再截了。</p><h3 id="2-1-截图"><a href="#2-1-截图" class="headerlink" title="2.1 截图"></a><strong>2.1 截图</strong></h3><ul><li>快捷键（默认为 <code>F1</code>）</li><li><code>鼠标左键</code> 单击托盘图标</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010108.jpg" alt></p><h3 id="2-2-取色"><a href="#2-2-取色" class="headerlink" title="2.2 取色"></a><strong>2.2 取色</strong></h3><ul><li>当放大镜可见的时候，按下 <code>C</code> 可复制该像素点的颜色值（RGB/Hex）。之后可以 <code>F3</code> 将它贴出，或者 <code>Ctrl</code> + <code>V</code> 贴到其他程序里</li><li>可按下 <code>Shift</code> 来切换颜色格式</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010110.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010111.jpg" alt></p><h3 id="2-3-纯文本截图"><a href="#2-3-纯文本截图" class="headerlink" title="2.3 纯文本截图"></a><strong>2.3 纯文本截图</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010112.jpg" alt></p><h3 id="2-4-编辑"><a href="#2-4-编辑" class="headerlink" title="2.4 编辑"></a><strong>2.4 编辑</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010113.gif" alt></p><h3 id="2-5-开始贴图"><a href="#2-5-开始贴图" class="headerlink" title="2.5 开始贴图"></a><strong>2.5 开始贴图</strong></h3><ul><li>快捷键（默认 <code>F3</code>）</li><li><code>鼠标中键</code> 单击托盘图标</li><li>截图时选择 <code>贴到屏幕</code></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010109.jpg" alt></p><h3 id="2-6-缩放贴图"><a href="#2-6-缩放贴图" class="headerlink" title="2.6 缩放贴图"></a><strong>2.6 缩放贴图</strong></h3><ul><li><code>滑动滚轮</code></li><li><code>+</code> <code>-</code></li><li>拖动贴图窗口的边缘</li></ul><h3 id="2-7-设置贴图透明度"><a href="#2-7-设置贴图透明度" class="headerlink" title="2.7 设置贴图透明度"></a><strong>2.7 设置贴图透明度</strong></h3><ul><li><code>Ctrl</code> + <code>滑动滚轮</code></li><li><code>Ctrl</code> + <code>+</code> <code>-</code></li></ul><h3 id="2-8-关闭单张贴图"><a href="#2-8-关闭单张贴图" class="headerlink" title="2.8 关闭单张贴图"></a><strong>2.8 关闭单张贴图</strong></h3><ul><li><code>Esc</code> / <code>左键双击</code></li><li><ul><li>可自定义</li></ul></li><li><code>Ctrl</code> + <code>W</code></li><li>被关闭的贴图，可再次被贴出，除非超过“可被恢复的已关闭贴图数”</li><li><ul><li>如何恢复：按下贴图键一次或多次</li></ul></li><li>“可被恢复的已关闭贴图数”可在选项对话框设置（默认设置/建议是 <strong>1</strong>）</li><li>当你觉得自己可能不需要这张贴图了，<strong>关闭</strong>贴图操作是你的首选，因为它同时提供了一种后悔药，防止你刚把贴图关闭就后悔了，想找回来</li><li><strong>如果你并不希望这张贴图消失，而只是想暂时隐藏它，那么你不应该关闭它</strong>，而是使用“隐藏所有贴图”，或者把它移动到另一个贴图分组</li><li>关闭 Snipaste 时，如果已关闭的贴图没有被显示出来，它们会被自动销毁（即使未达到最大计数）</li></ul><h3 id="2-9-隐藏所有贴图"><a href="#2-9-隐藏所有贴图" class="headerlink" title="2.9 隐藏所有贴图"></a><strong>2.9 隐藏所有贴图</strong></h3><ul><li>快捷键（默认为 <code>Shift</code> + <code>F3</code>）</li><li>再次按下快捷键将显示所有贴图</li><li>注意，隐藏所有贴图与上面提到的关闭单张贴图<strong>是完全不同的行为</strong>，也就是说，隐藏所有贴图不会影响对已关闭贴图的计数</li><li>被隐藏的贴图不会被自动销毁，即使关闭 Snipaste 时它们都是隐藏状态</li></ul><h3 id="2-10-销毁贴图"><a href="#2-10-销毁贴图" class="headerlink" title="2.10 销毁贴图"></a><strong>2.10 销毁贴图</strong></h3><ul><li><code>Shift</code> + <code>Esc</code> / 在贴图窗口的右键菜单中选 <code>销毁</code></li><li>当你确认自己不可能再需要这张贴图，并且不希望这张贴图留下任何痕迹，才建议使用<strong>销毁</strong></li><li>被销毁的贴图，不会再通过贴图键被恢复出来</li><li><ul><li>可是再按贴图键，还是贴出来了？</li></ul></li><li><ul><li><ul><li>这是因为它还在你剪贴板里，Snipaste 是把它当做新的内容贴了出来</li></ul></li></ul></li><li>如果希望销毁当前分组的所有贴图，关闭该贴图分组即可</li></ul><h3 id="2-11-总结"><a href="#2-11-总结" class="headerlink" title="2.11 总结"></a><strong>2.11 总结</strong></h3><p>&emsp;&emsp;根据官网描述，开源版本已停止更新，作者发布了2.X收费版本，但翻阅了新增功能，并没有我想要的如滚动截图等。</p><p>&emsp;&emsp;GitHub中相关issules：<a href="https://github.com/Snipaste/feedback/issues/19" target="_blank" rel="noopener">关于滚屏截屏支持讨论</a>，虽然被作者接纳，但从2016年到今天也未见到相关更新。</p><p>&emsp;&emsp;所以，只能考虑其他替代方案。</p><h2 id="3-多个工具共用"><a href="#3-多个工具共用" class="headerlink" title="3. 多个工具共用"></a><strong>3. 多个工具共用</strong></h2><p>&emsp;&emsp;首先先采用比较缓和的方案，找到能支持滚动截图的工具，辅助Snipaste。</p><p>&emsp;&emsp;因为博主需要使用滚动截图的场景常为浏览器，所以有以下几种方案来在浏览器中滚动截图。</p><h3 id="3-1-Chrome-命令-实现长截图"><a href="#3-1-Chrome-命令-实现长截图" class="headerlink" title="3.1 Chrome 命令 实现长截图"></a><strong>3.1 Chrome 命令 实现长截图</strong></h3><p>&emsp;&emsp;第一种方案是使用 Chrome62 版本时更新的长截图功能，缺点是不够灵活，不能随意控制截取范围等，优点是在产生的图片文件大小在接受范围内时，清晰度很高。</p><blockquote><p>Windows：</p><ul><li>打开调试界面（<code>F12</code>）</li><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code> 打开命令行</li><li>输入命令：Capture full size screenshot</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 截图整个页面</span></span><br><span class="line">Capture full size screenshot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 截图单个节点，需要先在调试界面选中节点[Elements]</span></span><br><span class="line">Capture node screenshot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 截图当前可见</span></span><br><span class="line">Capture screenshot</span><br></pre></td></tr></table></figure><h3 id="3-2-Chrome-插件-Nimbus"><a href="#3-2-Chrome-插件-Nimbus" class="headerlink" title="3.2 Chrome 插件 Nimbus"></a><strong>3.2 Chrome 插件 Nimbus</strong></h3><p>&emsp;&emsp;在Chrome扩展商店搜索Nimbus，并安装。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010114.png" alt></p><p>&emsp;&emsp;功能如下图所示，可以支持如滚动截屏，录制视频等需求。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010115.png" alt></p><p>&emsp;&emsp;截屏或录屏都有多种选项（Tab或桌面），如下所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010116.png" alt></p><p>&emsp;&emsp;整个屏幕并非指桌面，不是录屏软件那种获取系统每帧数据或是视频采集卡等对桌面进行录屏，只是范围扩散到屏幕，捕捉的还是当前页面。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010117.png" alt></p><p>&emsp;&emsp;但可以对某个应用进行截图或录屏，这样就不会只能局限于浏览器使用了。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010118.png" alt></p><p>&emsp;&emsp;选择某个应用进行录屏，如下图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010119.png" alt></p><p>&emsp;&emsp;视频甚至可以转换为Gif，日常使用很方便。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010120.png" alt></p><h2 id="4-单个工具替代"><a href="#4-单个工具替代" class="headerlink" title="4. 单个工具替代"></a><strong>4. 单个工具替代</strong></h2><h3 id="4-1-FScapture"><a href="#4-1-FScapture" class="headerlink" title="4.1 FScapture"></a><strong>4.1 FScapture</strong></h3><ul><li>官网：<a href="https://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FastStone Capture</a></li><li>开源软件</li><li>支持屏幕任意截长图，甚至录屏</li></ul><p>&emsp;&emsp;官网有点年代感，等以后Nimbus无法满足我的需求时再试用一下。</p><h3 id="4-2-ShareX"><a href="#4-2-ShareX" class="headerlink" title="4.2 ShareX"></a><strong>4.2 ShareX</strong></h3><ul><li>官网：<a href="https://getsharex.com/" target="_blank" rel="noopener">ShareX</a></li><li>开源软件，专业工具，功能强大</li><li>屏幕截取，录制相关功能齐全</li><li>支持Firefox、Chrome浏览器扩展</li><li>扩展功能丰富，如支持二维码生成等</li></ul><p>&emsp;&emsp;有机会会试用一下，感觉很强大。</p><h3 id="4-3-Xnip"><a href="#4-3-Xnip" class="headerlink" title="4.3 Xnip"></a><strong>4.3 Xnip</strong></h3><p>&emsp;&emsp;上述软件应该都只支持Windows系统，Mac作为最好的办公工具当然也有专业的截图工具（此为个人观点，好想买台MacBook Pro..orz），除了自带截图外，Xnip是一个好的选择，手里没有Mac，没法对比一下了。</p><h3 id="4-4-QQ截图"><a href="#4-4-QQ截图" class="headerlink" title="4.4 QQ截图"></a><strong>4.4 QQ截图</strong></h3><p>&emsp;&emsp;emmm，QQ自带的截图功能，日常使用足以满足，截屏、截长屏、录屏等都可以支持，但感觉使用不是很方便（其实人家有快捷键…），对比一下单一的截屏软件，首先会有一些不需要的中间步骤，然后还会有种混乱感吧，怕误操作把截图什么的发给别人…</p><p>&emsp;&emsp;最重要的是用QQ截图不能装逼，俗话说装逼是第一生产力，在马斯洛的<a href="https://zh.wikipedia.org/wiki/%E9%9C%80%E6%B1%82%E5%B1%82%E6%AC%A1%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">需求层次理论</a>中对应的是高层次的人类需求，而QQ太low，就算是俺们搬砖的也得西装笔挺的才有干活的动力嘛。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010122.png" alt></p><h3 id="4-5-Windows-截图工具"><a href="#4-5-Windows-截图工具" class="headerlink" title="4.5 Windows 截图工具"></a><strong>4.5 Windows 截图工具</strong></h3><p>&emsp;&emsp;不是很好用。不过Edge自带的截长图功能还行，不像Chrome那样需要输入命令，对非程序员用户不太友好。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010121.png" alt></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="[https://axutongxue.github.io/2019/01/15/%E8%BF%99%E4%B8%89%E6%AC%BE%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%BB%A1%E8%B6%B3%E4%BD%A0%E5%AF%B9%E6%88%AA%E5%9B%BE%E7%9A%84%E6%89%80%E6%9C%89%E9%9C%80%E6%B1%82/](https://axutongxue.github.io/2019/01/15/这三款软件，满足你对截图的所有需求/">这三款软件，满足你对截图的所有需求</a>)</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理办公中常用的截图工具，主要针对博主当前的需求。
    
    </summary>
    
      <category term="实用工具" scheme="http://linyishui.top/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tools" scheme="http://linyishui.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建个人博客 (七) 优化加载记录</title>
    <link href="http://linyishui.top/2020042201.html"/>
    <id>http://linyishui.top/2020042201.html</id>
    <published>2020-04-22T09:49:01.000Z</published>
    <updated>2020-04-24T01:47:12.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化加载记录"><a href="#优化加载记录" class="headerlink" title="优化加载记录"></a><strong>优化加载记录</strong></h1><h2 id="PageSpeed-Insights测试Blog性能"><a href="#PageSpeed-Insights测试Blog性能" class="headerlink" title="PageSpeed Insights测试Blog性能"></a><strong>PageSpeed Insights测试Blog性能</strong></h2><p>&emsp;&emsp;通过<a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">PageSpeed Insights</a>检查网站加载速度。</p><p>&emsp;&emsp;手机端测试结果如下，性能尚可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010103.png" alt></p><p>&emsp;&emsp;桌面端测试结果如下，评分一下就下来了，虽然会有一些波动，但多次测试都低于49。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010104.png" alt></p><p>&emsp;&emsp;首先查看优化建议，主要是核心js代码，这部分先暂时不动（博主目前前端优化技术有限）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010105.png" alt></p><p>&emsp;&emsp;查看其它影响项，发现看板娘占用了很多的网络资源（需要加载模型），所以先尝试移除这个功能。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010106.png" alt></p><h3 id="移除看板娘"><a href="#移除看板娘" class="headerlink" title="移除看板娘"></a><strong>移除看板娘</strong></h3><p>&emsp;&emsp;卸载相关包。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;删掉根目录配置文件中相关内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态妹子</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-shizuku</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">left</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">125</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">250</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;更新博客，再次测试，发现评分直接提高到97（汗，看来罪魁祸首就是模型了）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010107.png" alt></p><p>&emsp;&emsp;使用Google Chrome自带的Audits，再次测试博客加载性能。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://blog.serenader.me/ye-mian-de-jia-zai-xing-neng-you-hua-fang-an" target="_blank" rel="noopener">页面的加载性能优化方案</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://linyishui.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://linyishui.top/tags/hexo/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="http://linyishui.top/2020041701.html"/>
    <id>http://linyishui.top/2020041701.html</id>
    <published>2020-04-17T01:31:16.000Z</published>
    <updated>2020-04-27T02:24:12.810Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-为什么需要WebSocket"><a href="#1-1-为什么需要WebSocket" class="headerlink" title="1.1 为什么需要WebSocket"></a><strong>1.1 为什么需要WebSocket</strong></h3><p>&emsp;&emsp;我们已经有了HTTP协议，为什么还需要使用WebSocket呢？答案就是解决HTTP的缺陷-<strong>通信只能由客户端发起</strong>。</p><p>&emsp;&emsp;很多场景下我们需要由服务端主动向客户端推送消息，而HTTP协议这种单向请求的设计注定了服务器端有连续的状态变化时，客户端很难去获知。</p><p>&emsp;&emsp;早期，很多网站为了实现<a href="https://zh.wikipedia.org/wiki/推送技术" target="_blank" rel="noopener">推送技术</a>，所用的技术都是<a href="https://zh.wikipedia.org/wiki/輪詢" target="_blank" rel="noopener">轮询</a>。轮询是指由浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，然后服务器返回最新的数据给客户端。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求与回复可能会包含较长的<a href="https://zh.wikipedia.org/wiki/HTTP头字段" target="_blank" rel="noopener">头部</a>，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源，最常见的场景就是聊天室。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010102.png" alt></p><p>&emsp;&emsp;比较新的轮询技术是<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。</p><p>&emsp;&emsp;由此契机催生了WebSocket协议，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h3 id="1-2-什么是WebSocket"><a href="#1-2-什么是WebSocket" class="headerlink" title="1.2 什么是WebSocket"></a><strong>1.2 什么是WebSocket</strong></h3><p>&emsp;&emsp;<strong>WebSocket</strong>是一种<a href="https://zh.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在单个<a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP</a>连接上进行<a href="https://zh.wikipedia.org/wiki/全雙工" target="_blank" rel="noopener">全双工</a>通信，位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>。</p><p>&emsp;&emsp;WebSocket协议诞生于2008年，最初在<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>规范中被引用为TCPConnection，作为基于TCP的套接字API的占位符。2008年6月，<a href="https://zh.wikipedia.org/w/index.php?title=Michael_Carter&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Michael Carter</a>进行了一系列讨论，最终形成了称为WebSocket的协议。</p><p>&emsp;&emsp;WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>&emsp;&emsp;WebSocket是一种与<a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP</a>不同的协议。两者都位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>，并且都依赖于<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>的TCP协议。 虽然它们不同，但是RFC 6455中规定：<code>it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries</code>（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-1" target="_blank" rel="noopener">[1]</a>从HTTP协议更改为WebSocket协议。</p><p>&emsp;&emsp;WebSocket协议支持Web<a href="https://zh.wikipedia.org/wiki/浏览器" target="_blank" rel="noopener">浏览器</a>（或其他客户端应用程序）与Web<a href="https://zh.wikipedia.org/wiki/服务器" target="_blank" rel="noopener">服务器</a>之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)之类的技术以非标准化的方式实现了类似的双向通信。</p><p>&emsp;&emsp;<strong>与HTTP不同，WebSocket提供全双工通信</strong>。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-2" target="_blank" rel="noopener">[2]</a><a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-quantum-3" target="_blank" rel="noopener">[3]</a>此外，<strong>WebSocket还可以在TCP之上实现消息流</strong>。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p><blockquote><ul><li>单工通信：即只能A到B（广播），同一时间只允许一方向另一方传送消息，另一方则不允许反过来传送。</li><li>全双工：指在发送数据的同时也能接收数据，二者同步进行。</li><li>半双工：指在一个时间段内只有一个动作发生，数据信息可以沿两个方向传送，但同一时刻一个信道只允许单方向传送，因此也称为双向交替通信。如果要改变传输方向，需由开关进行切换。半双工方式要求收发两端都有发送装置和接收装置。由于这种方式要频繁变换信道方向，故效率低，但可以节约传输线路。半双工方式适用于终端与终端之间的会话式通信。</li></ul></blockquote><p>&emsp;&emsp;WebSocket协议规范将<code>ws</code>（WebSocket）和<code>wss</code>（WebSocket Secure）定义为两个新的<a href="https://zh.wikipedia.org/wiki/統一資源標識符" target="_blank" rel="noopener">统一资源标识符</a>（URI）方案<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-4" target="_blank" rel="noopener">[4]</a>，分别对应明文和加密连接，其中<code>wss</code>表示使用了<a href="https://zh.wikipedia.org/wiki/TLS" target="_blank" rel="noopener">TLS</a>的Websocket。除了方案名称和片段ID（不支持<code>#</code>）之外，其余的URI组件都被定义为此URI的通用语法。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-5" target="_blank" rel="noopener">[5]</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">w</span><span class="variable">s:</span>//example.<span class="keyword">com</span>/wsapi</span><br><span class="line"><span class="keyword">ws</span><span class="variable">s:</span>//secure.example.<span class="keyword">com</span>/wsapi</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。        </p><p>&emsp;&emsp;使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架。</p><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a><strong>1.3 优点</strong></h3><ul><li><p><strong>较少的控制开销</strong>。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a href="https://zh.wikipedia.org/wiki/掩码" target="_blank" rel="noopener">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p></li><li><p><strong>更强的实时性</strong>。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的<a href="https://zh.wikipedia.org/w/index.php?title=长轮询&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">长轮询</a>比较，其也能在短时间内更多次地传递数据。</p></li><li><p><strong>保持连接状态</strong>。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p></li><li><p><strong>更好的二进制支持</strong>。Websocket定义了<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</p></li><li><p><strong>可以支持扩展</strong>。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a href="https://zh.wikipedia.org/wiki/数据压缩" target="_blank" rel="noopener">压缩</a>等。</p></li><li><p><strong>更好的压缩效果</strong>。相对于<a href="https://zh.wikipedia.org/wiki/HTTP压缩" target="_blank" rel="noopener">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a href="https://zh.wikipedia.org/wiki/上下文" target="_blank" rel="noopener">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-14" target="_blank" rel="noopener">[14]</a></p></li></ul><h3 id="1-4-WebSocket和Socket"><a href="#1-4-WebSocket和Socket" class="headerlink" title="1.4 WebSocket和Socket"></a><strong>1.4 WebSocket和Socket</strong></h3><blockquote><p>WebSocket和Socket 的区别：</p><p>&emsp;&emsp;软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。</p><p>&emsp;&emsp;Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。</p><p>&emsp;&emsp;WebSocket 则是一个典型的应用层协议。</p><p>&emsp;&emsp;总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。</p></blockquote><h3 id="1-5-一次Websocket握手请求"><a href="#1-5-一次Websocket握手请求" class="headerlink" title="1.5 一次Websocket握手请求"></a><strong>1.5 一次Websocket握手请求</strong></h3><p>&emsp;&emsp;客户端请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;服务器回应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Location</span>: ws://example.com/</span><br></pre></td></tr></table></figure><ul><li>Connection 必须设置 Upgrade，表示客户端希望连接升级。</li><li>Upgrade 字段必须设置 Websocket，表示希望升级到 Websocket 协议。</li><li>Sec-WebSocket-Key 是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。把 “Sec-WebSocket-Key” 加上一个特殊字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算 SHA-1 摘要，之后进行 BASE-64 编码，将结果做为 “Sec-WebSocket-Accept” 头的值，返回给客户端。如此操作，可以尽量避免普通 HTTP 请求被误认为 Websocket 协议。</li><li>Sec-WebSocket-Version 表示支持的 Websocket 版本。RFC6455 要求使用的版本是 13，之前草案的版本均应当弃用。</li><li>Origin 字段是可选的，通常用来表示在浏览器中发起此 Websocket 连接所在的页面，类似于 Referer。但是，与 Referer 不同的是，Origin 只包含了协议和主机名称。</li><li>其他一些定义在 HTTP 协议中的字段，如 Cookie 等，也可以在 Websocket 中使用。</li></ul><h3 id="1-6-支持Websocket的服务器"><a href="#1-6-支持Websocket的服务器" class="headerlink" title="1.6 支持Websocket的服务器"></a><strong>1.6 支持Websocket的服务器</strong></h3><p>&emsp;&emsp;在服务器方面，网上都有不同对websocket支持的服务器：</p><ul><li>php - <a href="http://code.google.com/p/phpwebsocket/" target="_blank" rel="noopener">http://code.google.com/p/phpwebsocket/</a></li><li>jetty - <a href="http://jetty.codehaus.org/jetty/（版本7开始支持websocket）" target="_blank" rel="noopener">http://jetty.codehaus.org/jetty/（版本7开始支持websocket）</a></li><li>netty - <a href="http://www.jboss.org/netty" target="_blank" rel="noopener">http://www.jboss.org/netty</a></li><li>ruby - <a href="http://github.com/gimite/web-socket-ruby" target="_blank" rel="noopener">http://github.com/gimite/web-socket-ruby</a></li><li>Kaazing - <a href="https://web.archive.org/web/20100923224709/http://www.kaazing.org/confluence/display/KAAZING/Home" target="_blank" rel="noopener">https://web.archive.org/web/20100923224709/http://www.kaazing.org/confluence/display/KAAZING/Home</a></li><li>Tomcat - <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/（7.0.27支持websocket，建议用tomcat8，7.0.27中的接口已经过时）</a></li><li>WebLogic - <a href="http://www.oracle.com/us/products/middleware/cloud-app-foundation/weblogic/overview/index.html" target="_blank" rel="noopener">http://www.oracle.com/us/products/middleware/cloud-app-foundation/weblogic/overview/index.html（12.1.2開始支持）</a></li><li>node.js - <a href="https://github.com/Worlize/WebSocket-Node" target="_blank" rel="noopener">https://github.com/Worlize/WebSocket-Node</a></li><li>node.js - <a href="http://socket.io/" target="_blank" rel="noopener">http://socket.io</a></li><li>nginx - <a href="http://nginx.com/" target="_blank" rel="noopener">http://nginx.com/</a></li><li>mojolicious - <a href="http://mojolicio.us/" target="_blank" rel="noopener">http://mojolicio.us/</a></li><li>python - <a href="https://github.com/abourget/gevent-socketio" target="_blank" rel="noopener">https://github.com/abourget/gevent-socketio</a></li><li>Django - <a href="https://github.com/stephenmcd/django-socketio" target="_blank" rel="noopener">https://github.com/stephenmcd/django-socketio</a></li><li>erlang - <a href="https://github.com/ninenines/cowboy.git" target="_blank" rel="noopener">https://github.com/ninenines/cowboy.git</a></li></ul><h2 id="第二节-HTML5-WebSocket"><a href="#第二节-HTML5-WebSocket" class="headerlink" title="第二节 HTML5 WebSocket"></a><strong>第二节 HTML5 WebSocket</strong></h2><p>&emsp;&emsp;浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>&emsp;&emsp;当你获取 Web Socket 连接后，你可以通过 <strong>send()</strong> 方法来向服务器发送数据，并通过 <strong>onmessage</strong> 事件来接收服务器返回的数据。</p><p>&emsp;&emsp;以下 API 用于创建 WebSocket 对象。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Socket = <span class="keyword">new</span> <span class="type">WebSocket</span>(url, [protocol] );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h3 id="2-1-WebSocket-属性"><a href="#2-1-WebSocket-属性" class="headerlink" title="2.1 WebSocket 属性"></a><strong>2.1 WebSocket 属性</strong></h3><table><thead><tr><th style="text-align:left"><strong>属性</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">Socket.readyState</td><td style="text-align:left">只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td></tr><tr><td style="text-align:left">Socket.bufferedAmount</td><td style="text-align:left">只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td></tr></tbody></table><h3 id="2-2-WebSocket-事件"><a href="#2-2-WebSocket-事件" class="headerlink" title="2.2 WebSocket 事件"></a><strong>2.2 WebSocket 事件</strong></h3><table><thead><tr><th style="text-align:left"><strong>事件</strong></th><th style="text-align:left"><strong>事件处理程序</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">open</td><td style="text-align:left">Socket.onopen</td><td style="text-align:left">连接建立时触发</td></tr><tr><td style="text-align:left">message</td><td style="text-align:left">Socket.onmessage</td><td style="text-align:left">客户端接收服务端数据时触发</td></tr><tr><td style="text-align:left">error</td><td style="text-align:left">Socket.onerror</td><td style="text-align:left">通信发生错误时触发</td></tr><tr><td style="text-align:left">close</td><td style="text-align:left">Socket.onclose</td><td style="text-align:left">连接关闭时触发</td></tr></tbody></table><h3 id="2-3-WebSocket-方法"><a href="#2-3-WebSocket-方法" class="headerlink" title="2.3 WebSocket 方法"></a><strong>2.3 WebSocket 方法</strong></h3><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">Socket.send()</td><td style="text-align:left">使用连接发送数据</td></tr><tr><td style="text-align:left">Socket.close()</td><td style="text-align:left">关闭连接</td></tr></tbody></table><h3 id="2-4-WebSocket-实例"><a href="#2-4-WebSocket-实例" class="headerlink" title="2.4 WebSocket 实例"></a><strong>2.4 WebSocket 实例</strong></h3><p>&emsp;&emsp;WebSocket 协议本质上是一个基于 TCP 的协议。</p><p>&emsp;&emsp;为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">         <span class="function"><span class="keyword">function</span> <span class="title">WebSocketTest</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">         &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="string">"WebSocket"</span> <span class="keyword">in</span> <span class="built_in">window</span>)</span></span><br><span class="line"><span class="undefined">            &#123;</span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"您的浏览器支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="undefined">               </span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="actionscript">               <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:9998/echo"</span>);</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">               &#123;</span></span><br><span class="line"><span class="actionscript">                  <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span><br><span class="line"><span class="actionscript">                  ws.send(<span class="string">"发送数据"</span>);</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"数据发送中..."</span>);</span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span></span></span><br><span class="line"><span class="undefined">               &#123; </span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">var</span> received_msg = evt.data;</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"数据已接收..."</span>);</span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">               &#123; </span></span><br><span class="line"><span class="actionscript">                  <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"连接已关闭..."</span>); </span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="actionscript">            <span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">            &#123;</span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 浏览器不支持 WebSocket</span></span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"您的浏览器不支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">         &#125;</span></span><br><span class="line"><span class="undefined">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sse"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:WebSocketTest()"</span>&gt;</span>运行 WebSocket<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;python服务部分省略。</p><hr><h2 id="第三节-实现"><a href="#第三节-实现" class="headerlink" title="第三节 实现"></a><strong>第三节 实现</strong></h2><p>&emsp;&emsp;有多种方式来实现 WebSocket 协议，Spring Boot 采用基于 STOMP 的实现，常见的还有如 Socket.IO等。</p><h3 id="3-1-STOMP"><a href="#3-1-STOMP" class="headerlink" title="3.1 STOMP"></a><strong>3.1 STOMP</strong></h3><p>&emsp;&emsp;STOMP：即<code>Simple Text Orientated Messaging Protocol</code>，它是一个简单的文本消息传输协议，属于 WebSocket 的子协议， 提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单， 易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。</p><h3 id="3-2-引入依赖"><a href="#3-2-引入依赖" class="headerlink" title="3.2 引入依赖"></a><strong>3.2 引入依赖</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此处使用jetty代替内置的Tomcat服务器，可以只引入<code>spring-boot-starter-websocket</code>即可。</p><h3 id="3-3-配置"><a href="#3-3-配置" class="headerlink" title="3.3 配置"></a><strong>3.3 配置</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry stompEndpointRegistry)</span> </span>&#123;</span><br><span class="line">        stompEndpointRegistry.addEndpoint(<span class="string">"/simple"</span>)</span><br><span class="line">                .setAllowedOrigins(<span class="string">"*"</span>) <span class="comment">//解决跨域问题</span></span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.enableSimpleBroker(<span class="string">"/topic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@EnableWebSocketMessageBroker</code> 注解表示开启使用STOMP协议，来传输基于代理的消息，Broker即代理。</li><li><code>registerStompEndpoints</code>方法表示注册STOMP协议的节点，并指定映射的URL。</li><li><code>addEndpoint().withSockJS()</code>用来注册STOMP协议节点，同时指定使用SockJS。</li><li><code>configureMessageBroker</code>方法用来配置消息代理，此处实现推送功能，所以是<code>/topic</code>。</li></ul><h3 id="3-4-消息类"><a href="#3-4-消息类" class="headerlink" title="3.4 消息类"></a><strong>3.4 消息类</strong></h3><p>&emsp;&emsp;请求消息类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;响应消息类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String responseMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseMessage</span><span class="params">(String responseMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseMessage = responseMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResponseMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-控制器"><a href="#3-5-控制器" class="headerlink" title="3.5 控制器"></a><strong>3.5 控制器</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WsController</span><span class="params">(SimpMessagingTemplate messagingTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messagingTemplate = messagingTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping</span>(<span class="string">"/welcome"</span>)</span><br><span class="line">    <span class="meta">@SendTo</span>(<span class="string">"/topic/say"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseMessage <span class="title">say</span><span class="params">(RequestMessage message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseMessage(<span class="string">"welcome,"</span> + message.getName() + <span class="string">" !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时推送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发现消息</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">"/topic/callback"</span>, <span class="string">"定时推送消息时间: "</span> + df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>say方法上添加的<code>@MessageMapping</code>注解和我们之前使用的<code>@RequestMapping</code>类似。</p></li><li><p><code>@SendTo</code>注解表示当服务器有消息需要推送的时候， 会对订阅了<code>@SendTo</code>中路径的浏览器发送消息。</p></li><li><p>除此之外，还定义了一个定时推送消息方法，这个方法每隔1秒会主动给订阅了主题<code>/topic/callback</code>的客户端推送消息。</p></li><li>到此为止服务器端就编写完成，可以看到服务器的编写非常简单。</li></ul><h3 id="3-6-网站客户端"><a href="#3-6-网站客户端" class="headerlink" title="3.6 网站客户端"></a><strong>3.6 网站客户端</strong></h3><p>&emsp;&emsp;<a href="https://github.com/yidao620c/SpringBootBucket/tree/master/springboot-websocket/src/test/java/com/xncoding/jwt/socket/client/html" target="_blank" rel="noopener">测试代码</a></p><p>&emsp;&emsp;页面上面点击”连接”按钮后，开始连接到<code>/simple</code>节点。输入名字后点击发送，将向<code>/welcome</code>的url发送消息。</p><p>&emsp;&emsp;同时订阅了两个主题：<code>/topic/say</code> 和 <code>/topic/callback</code>，会接收到服务器的say方法的返回，以及定时推送消息。</p><h3 id="3-7-Android客户端"><a href="#3-7-Android客户端" class="headerlink" title="3.7 Android客户端"></a><strong>3.7 Android客户端</strong></h3><p>&emsp;&emsp;参考 <a href="https://github.com/NaikSoftware/StompProtocolAndroid" target="_blank" rel="noopener">StompProtocolAndroid</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/WebSocket" target="_blank" rel="noopener">WebSocket-维基百科</a></p><p><a href="https://www.runoob.com/html/html5-websocket.html" target="_blank" rel="noopener">html5-websocket-菜鸟教程</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p><p><a href="https://www.xncoding.com/2017/07/15/spring/sb-websocket.html" target="_blank" rel="noopener">SpringBoot系列 - 集成WebSocket实时通信</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍WebSocket相关知识，内容包括：简介（为什么需要WebSocket、什么是WebSocket、优点、WebSocket和Socket、一次Websocket握手请求、支持Websocket的服务器），HTML5 WebSocket（WebSocket属性、WebSocket事件、WebSocket方法、WebSocket实例），实现（STOMP、引入依赖、配置、消息类、控制器、网站客户端、Android客户端）。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="webSocket" scheme="http://linyishui.top/tags/webSocket/"/>
    
  </entry>
  
  <entry>
    <title>Nginx简单处理一次灰度发布问题</title>
    <link href="http://linyishui.top/2020041501.html"/>
    <id>http://linyishui.top/2020041501.html</id>
    <published>2020-04-15T06:28:48.000Z</published>
    <updated>2020-04-16T09:41:22.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nginx简单处理一次灰度发布问题"><a href="#Nginx简单处理一次灰度发布问题" class="headerlink" title="Nginx简单处理一次灰度发布问题"></a><strong>Nginx简单处理一次灰度发布问题</strong></h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a><strong>1.需求</strong></h2><p>&emsp;&emsp;公司接手的一个半成品项目，客户要求更新版本时不要停掉网站（灰度发布）。</p><p>&emsp;&emsp;马上想到的方案是：主从热备和负载均衡，nginx+keepalived，然后又想到了自动部署-CI/CD，及时打住避免越想越远。这个项目本身比较粗糙，简单的解决当前的问题即可。</p><p>&emsp;&emsp;原系统使用session存储会话信息，所以还要解决session如何共享的问题，google了一下，决定nginx配置两台服务器负载均衡，发布新版本时，一次更新一个，然后使用Redis来共享session。</p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a><strong>2.实现</strong></h2><p>&emsp;&emsp;时间和精力有限，先在本地和测试服务器跑通一个demo。</p><p>&emsp;&emsp;两台机器：本机，服务器A</p><table><thead><tr><th style="text-align:center">工具</th><th style="text-align:center">本机</th><th style="text-align:center">服务器A</th></tr></thead><tbody><tr><td style="text-align:center">JDK 1.8</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Nginx</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">Redis</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr></tbody></table><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a><strong>2.1 代码</strong></h3><p>&emsp;&emsp;首先新建spring-boot项目，代码如下。</p><h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="(1) pom.xml"></a><strong>(1) pom.xml</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-application-properties"><a href="#2-application-properties" class="headerlink" title="(2) application.properties"></a><strong>(2) application.properties</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8022</span><br><span class="line"></span><br><span class="line">spring.redis.host=&#123;服务器A&#125;</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=</span><br><span class="line">spring.redis.timeout=5000</span><br></pre></td></tr></table></figure><h4 id="3-Application"><a href="#3-Application" class="headerlink" title="(3) Application"></a><strong>(3) Application</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NginxKeepalivedRedisDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NginxKeepalivedRedisDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-控制器和实体类"><a href="#4-控制器和实体类" class="headerlink" title="(4) 控制器和实体类"></a><strong>(4) 控制器和实体类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">login</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">"sessionId"</span>,session.getId());</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(<span class="string">"01"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        session.setAttribute(<span class="string">"userInfo"</span>, userInfo);</span><br><span class="line">        content.put(<span class="string">"hostAddress"</span>,InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">        content.put(<span class="string">"hostName"</span>,InetAddress.getLocalHost().getHostName());</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5392373940126446170L</span>;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a><strong>2.2 调试</strong></h3><p>&emsp;&emsp;尝试启动，发现报错：Connection refused: no further information。很明显Redis无法连接。</p><p>&emsp;&emsp;先开了下命令行，尝试 telnet 服务器A 6379 ，无法连通。</p><p>&emsp;&emsp;检查了一下防火墙，确认端口已经开放了，然后又检查了一下阿里云控制平台上是否在安全组中开放端口，发现也是正确的。</p><p>&emsp;&emsp;google了一下，尝试修改redis.conf，将bind 127.0.0.1 修改为0.0.0.0。</p><p>&emsp;&emsp;再次telnet，可以连通，分别在本地和服务器A发布服务（服务器端口8022被占用，启动时指定了端口8023），并分别访问：http://{服务器A}:8023/login</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务器A返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"6a5e81a6-04f4-4ca8-afd4-1559695c1446"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"xxx.xxx.xxx.xxx"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 本地返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"DESKTOP-xx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"2a7c4873-1f9b-414a-85fc-6298562de64b"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"192.168.31.197"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问：<a href="http://qxamoy.com:8023/login" target="_blank" rel="noopener">http://qxamoy.com:8023/login</a></p><p>&emsp;&emsp;修改配置文件nginx.conf（我新建了一个demo.conf并在nginx.conf中引用）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 负载均衡配置</span></span><br><span class="line">upstream demo_upstream&#123;</span><br><span class="line">  <span class="keyword">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8022</span> weight=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">server</span> xxx:<span class="number">8023</span> weight=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#虚拟主机的配置</span></span><br><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">    <span class="meta">#监听端口</span></span><br><span class="line">    listen <span class="number">7051</span>;</span><br><span class="line">    <span class="meta"># 指定ip地址或者域名，多个配置之间用空格分隔</span></span><br><span class="line">    server_name localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#对 "/" 启用反向代理</span></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//demo_upstream;</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动nginx。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx.exe</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问<a href="http://localhost:7051/login" target="_blank" rel="noopener">http://localhost:7051/login</a></p><p>&emsp;&emsp;可以观察每次请求后返回结果的变化（ip和session），顺利的话会看到根据权重来切换接收的服务端，所以日常更新版本时可以依次对单个服务器进行更新来完成“灰度发布”。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.v2ex.com/t/477509" target="_blank" rel="noopener">大家是怎么做到服务器热更新的?</a></p><p><a href="https://blog.csdn.net/IT_10/article/details/89365436" target="_blank" rel="noopener">超详细的Nginx负载均衡+高可用配置</a></p><p><a href="https://www.cnblogs.com/54chensongxia/p/12096493.html" target="_blank" rel="noopener">Spring系列.@EnableRedisHttpSession原理简析</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      使用Nginx来简单处理一次灰度发布的问题，更新网站后台同时“不停掉服务”。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="nginx" scheme="http://linyishui.top/tags/nginx/"/>
    
  </entry>
  
</feed>
