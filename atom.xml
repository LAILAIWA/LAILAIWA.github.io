<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-04-23T09:28:53.512Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Speciosity</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>办公利器-截图工具</title>
    <link href="http://linyishui.top/2020042301.html"/>
    <id>http://linyishui.top/2020042301.html</id>
    <published>2020-04-23T03:12:27.000Z</published>
    <updated>2020-04-23T09:28:53.512Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a><strong>截图工具</strong></h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a><strong>1. 需求</strong></h2><ul><li>简单易用</li><li>满足截图+实时编辑+保存/复制等基础功能</li><li>能够支持滚动截图</li><li>能够录制动态视频或动态图（最好）</li></ul><h2 id="2-Snipaste"><a href="#2-Snipaste" class="headerlink" title="2. Snipaste"></a><strong>2. Snipaste</strong></h2><p>&emsp;&emsp;<a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a>，可以直接在Windows商店获取，知名的开源贴图/截图软件，除了截图外，贴图是核心内容。写这篇博文的原因也是因为Snipaste无法满足博主日常需求，记录一下我寻找替代方案的过程。</p><p>&emsp;&emsp;这里偷懒一下，直接从官方文档和一些网络上的资源，摘抄我经常使用的功能。</p><p>&emsp;&emsp;以下动图一些快捷键和官方不一致，如<code>F2</code>应为<code>F3</code>，需要注意，懒得一个个再截了。</p><h3 id="2-1-截图"><a href="#2-1-截图" class="headerlink" title="2.1 截图"></a><strong>2.1 截图</strong></h3><ul><li>快捷键（默认为 <code>F1</code>）</li><li><code>鼠标左键</code> 单击托盘图标</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010108.jpg" alt=""></p><h3 id="2-2-取色"><a href="#2-2-取色" class="headerlink" title="2.2 取色"></a><strong>2.2 取色</strong></h3><ul><li>当放大镜可见的时候，按下 <code>C</code> 可复制该像素点的颜色值（RGB/Hex）。之后可以 <code>F3</code> 将它贴出，或者 <code>Ctrl</code> + <code>V</code> 贴到其他程序里</li><li>可按下 <code>Shift</code> 来切换颜色格式</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010110.jpg" alt=""></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010111.jpg" alt=""></p><h3 id="2-3-纯文本截图"><a href="#2-3-纯文本截图" class="headerlink" title="2.3 纯文本截图"></a><strong>2.3 纯文本截图</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010112.jpg" alt=""></p><h3 id="2-4-编辑"><a href="#2-4-编辑" class="headerlink" title="2.4 编辑"></a><strong>2.4 编辑</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010113.gif" alt=""></p><h3 id="2-5-开始贴图"><a href="#2-5-开始贴图" class="headerlink" title="2.5 开始贴图"></a><strong>2.5 开始贴图</strong></h3><ul><li>快捷键（默认 <code>F3</code>）</li><li><code>鼠标中键</code> 单击托盘图标</li><li>截图时选择 <code>贴到屏幕</code></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010109.jpg" alt=""></p><h3 id="2-6-缩放贴图"><a href="#2-6-缩放贴图" class="headerlink" title="2.6 缩放贴图"></a><strong>2.6 缩放贴图</strong></h3><ul><li><code>滑动滚轮</code></li><li><code>+</code> <code>-</code></li><li>拖动贴图窗口的边缘</li></ul><h3 id="2-7-设置贴图透明度"><a href="#2-7-设置贴图透明度" class="headerlink" title="2.7 设置贴图透明度"></a><strong>2.7 设置贴图透明度</strong></h3><ul><li><code>Ctrl</code> + <code>滑动滚轮</code></li><li><code>Ctrl</code> + <code>+</code> <code>-</code></li></ul><h3 id="2-8-关闭单张贴图"><a href="#2-8-关闭单张贴图" class="headerlink" title="2.8 关闭单张贴图"></a><strong>2.8 关闭单张贴图</strong></h3><ul><li><code>Esc</code> / <code>左键双击</code></li><li><ul><li>可自定义</li></ul></li><li><code>Ctrl</code> + <code>W</code></li><li>被关闭的贴图，可再次被贴出，除非超过“可被恢复的已关闭贴图数”</li><li><ul><li>如何恢复：按下贴图键一次或多次</li></ul></li><li>“可被恢复的已关闭贴图数”可在选项对话框设置（默认设置/建议是 <strong>1</strong>）</li><li>当你觉得自己可能不需要这张贴图了，<strong>关闭</strong>贴图操作是你的首选，因为它同时提供了一种后悔药，防止你刚把贴图关闭就后悔了，想找回来</li><li><strong>如果你并不希望这张贴图消失，而只是想暂时隐藏它，那么你不应该关闭它</strong>，而是使用“隐藏所有贴图”，或者把它移动到另一个贴图分组</li><li>关闭 Snipaste 时，如果已关闭的贴图没有被显示出来，它们会被自动销毁（即使未达到最大计数）</li></ul><h3 id="2-9-隐藏所有贴图"><a href="#2-9-隐藏所有贴图" class="headerlink" title="2.9 隐藏所有贴图"></a><strong>2.9 隐藏所有贴图</strong></h3><ul><li>快捷键（默认为 <code>Shift</code> + <code>F3</code>）</li><li>再次按下快捷键将显示所有贴图</li><li>注意，隐藏所有贴图与上面提到的关闭单张贴图<strong>是完全不同的行为</strong>，也就是说，隐藏所有贴图不会影响对已关闭贴图的计数</li><li>被隐藏的贴图不会被自动销毁，即使关闭 Snipaste 时它们都是隐藏状态</li></ul><h3 id="2-10-销毁贴图"><a href="#2-10-销毁贴图" class="headerlink" title="2.10 销毁贴图"></a><strong>2.10 销毁贴图</strong></h3><ul><li><code>Shift</code> + <code>Esc</code> / 在贴图窗口的右键菜单中选 <code>销毁</code></li><li>当你确认自己不可能再需要这张贴图，并且不希望这张贴图留下任何痕迹，才建议使用<strong>销毁</strong></li><li>被销毁的贴图，不会再通过贴图键被恢复出来</li><li><ul><li>可是再按贴图键，还是贴出来了？</li></ul></li><li><ul><li><ul><li>这是因为它还在你剪贴板里，Snipaste 是把它当做新的内容贴了出来</li></ul></li></ul></li><li>如果希望销毁当前分组的所有贴图，关闭该贴图分组即可</li></ul><h3 id="2-11-总结"><a href="#2-11-总结" class="headerlink" title="2.11 总结"></a><strong>2.11 总结</strong></h3><p>&emsp;&emsp;根据官网描述，开源版本已停止更新，作者发布了2.X收费版本，但翻阅了新增功能，并没有我想要的如滚动截图等。</p><p>&emsp;&emsp;GitHub中相关issules：<a href="https://github.com/Snipaste/feedback/issues/19" target="_blank" rel="noopener">关于滚屏截屏支持讨论</a>，虽然被作者接纳，但从2016年到今天也未见到相关更新。</p><p>&emsp;&emsp;所以，只能考虑其他替代方案。</p><h2 id="3-多个工具共用"><a href="#3-多个工具共用" class="headerlink" title="3. 多个工具共用"></a><strong>3. 多个工具共用</strong></h2><p>&emsp;&emsp;首先先采用比较缓和的方案，找到能支持滚动截图的工具，辅助Snipaste。</p><p>&emsp;&emsp;因为博主需要使用滚动截图的场景常为浏览器，所以有以下几种方案来在浏览器中滚动截图。</p><h3 id="3-1-Chrome-命令-实现长截图"><a href="#3-1-Chrome-命令-实现长截图" class="headerlink" title="3.1 Chrome 命令 实现长截图"></a><strong>3.1 Chrome 命令 实现长截图</strong></h3><p>&emsp;&emsp;第一种方案是使用 Chrome62 版本时更新的长截图功能，缺点是不够灵活，不能随意控制截取范围等，优点是在产生的图片文件大小在接受范围内时，清晰度很高。</p><blockquote><p>Windows：</p><ul><li>打开调试界面（<code>F12</code>）</li><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code> 打开命令行</li><li>输入命令：Capture full size screenshot</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 截图整个页面</span></span><br><span class="line">Capture full size screenshot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 截图单个节点，需要先在调试界面选中节点[Elements]</span></span><br><span class="line">Capture node screenshot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 截图当前可见</span></span><br><span class="line">Capture screenshot</span><br></pre></td></tr></table></figure><h3 id="3-2-Chrome-插件-Nimbus"><a href="#3-2-Chrome-插件-Nimbus" class="headerlink" title="3.2 Chrome 插件 Nimbus"></a><strong>3.2 Chrome 插件 Nimbus</strong></h3><p>&emsp;&emsp;在Chrome扩展商店搜索Nimbus，并安装。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010114.png" alt=""></p><p>&emsp;&emsp;功能如下图所示，可以支持如滚动截屏，录制视频等需求。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010115.png" alt=""></p><p>&emsp;&emsp;截屏或录屏都有多种选项（Tab或桌面），如下所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010116.png" alt=""></p><p>&emsp;&emsp;整个屏幕并非指桌面，不是录屏软件那种获取系统每帧数据或是视频采集卡等对桌面进行录屏，只是范围扩散到屏幕，捕捉的还是当前页面。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010117.png" alt=""></p><p>&emsp;&emsp;但可以对某个应用进行截图或录屏，这样就不会只能局限于浏览器使用了。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010118.png" alt=""></p><p>&emsp;&emsp;选择某个应用进行录屏，如下图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010119.png" alt=""></p><p>&emsp;&emsp;视频甚至可以转换为Gif，日常使用很方便。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010120.png" alt=""></p><h2 id="4-单个工具替代"><a href="#4-单个工具替代" class="headerlink" title="4. 单个工具替代"></a><strong>4. 单个工具替代</strong></h2><h3 id="4-1-FScapture"><a href="#4-1-FScapture" class="headerlink" title="4.1 FScapture"></a><strong>4.1 FScapture</strong></h3><ul><li>官网：<a href="https://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FastStone Capture</a></li><li>开源软件</li><li>支持屏幕任意截长图，甚至录屏</li></ul><p>&emsp;&emsp;官网有点年代感，等以后Nimbus无法满足我的需求时再试用一下。</p><h3 id="4-2-ShareX"><a href="#4-2-ShareX" class="headerlink" title="4.2 ShareX"></a><strong>4.2 ShareX</strong></h3><ul><li>官网：<a href="https://getsharex.com/" target="_blank" rel="noopener">ShareX</a></li><li>开源软件，专业工具，功能强大</li><li>屏幕截取，录制相关功能齐全</li><li>支持Firefox、Chrome浏览器扩展</li><li>扩展功能丰富，如支持二维码生成等</li></ul><p>&emsp;&emsp;有机会会试用一下，感觉很强大。</p><h3 id="4-3-Xnip"><a href="#4-3-Xnip" class="headerlink" title="4.3 Xnip"></a><strong>4.3 Xnip</strong></h3><p>&emsp;&emsp;上述软件应该都只支持Windows系统，Mac作为最好的办公工具当然也有专业的截图工具（此为个人观点，好想买台MacBook Pro..orz），除了自带截图外，Xnip是一个好的选择，手里没有Mac，没法对比一下了。</p><h3 id="4-4-QQ截图"><a href="#4-4-QQ截图" class="headerlink" title="4.4 QQ截图"></a><strong>4.4 QQ截图</strong></h3><p>&emsp;&emsp;emmm，QQ自带的截图功能，日常使用足以满足，截屏、截长屏、录屏等都可以支持，但感觉使用不是很方便（其实人家有快捷键…），对比一下单一的截屏软件，首先会有一些不需要的中间步骤，然后还会有种混乱感吧，怕误操作把截图什么的发给别人…</p><p>&emsp;&emsp;最重要的是用QQ截图不能装逼，俗话说装逼是第一生产力，在马斯洛的<a href="https://zh.wikipedia.org/wiki/%E9%9C%80%E6%B1%82%E5%B1%82%E6%AC%A1%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">需求层次理论</a>中对应的是高层次的人类需求，而QQ太low，就算是俺们搬砖的也得西装笔挺的才有干活的动力嘛。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010122.png" alt=""></p><h3 id="4-5-Windows-截图工具"><a href="#4-5-Windows-截图工具" class="headerlink" title="4.5 Windows 截图工具"></a><strong>4.5 Windows 截图工具</strong></h3><p>&emsp;&emsp;不是很好用。不过Edge自带的截长图功能还行，不像Chrome那样需要输入命令，对非程序员用户不太友好。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010121.png" alt=""></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="[https://axutongxue.github.io/2019/01/15/%E8%BF%99%E4%B8%89%E6%AC%BE%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%BB%A1%E8%B6%B3%E4%BD%A0%E5%AF%B9%E6%88%AA%E5%9B%BE%E7%9A%84%E6%89%80%E6%9C%89%E9%9C%80%E6%B1%82/](https://axutongxue.github.io/2019/01/15/这三款软件，满足你对截图的所有需求/">这三款软件，满足你对截图的所有需求</a>)</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理办公中常用的截图工具，主要针对博主当前的需求。
    
    </summary>
    
      <category term="实用工具" scheme="http://linyishui.top/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tools" scheme="http://linyishui.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建个人博客 (七) 优化加载记录</title>
    <link href="http://linyishui.top/2020042201.html"/>
    <id>http://linyishui.top/2020042201.html</id>
    <published>2020-04-22T09:49:01.000Z</published>
    <updated>2020-04-24T01:47:12.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化加载记录"><a href="#优化加载记录" class="headerlink" title="优化加载记录"></a><strong>优化加载记录</strong></h1><h2 id="PageSpeed-Insights测试Blog性能"><a href="#PageSpeed-Insights测试Blog性能" class="headerlink" title="PageSpeed Insights测试Blog性能"></a><strong>PageSpeed Insights测试Blog性能</strong></h2><p>&emsp;&emsp;通过<a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">PageSpeed Insights</a>检查网站加载速度。</p><p>&emsp;&emsp;手机端测试结果如下，性能尚可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010103.png" alt=""></p><p>&emsp;&emsp;桌面端测试结果如下，评分一下就下来了，虽然会有一些波动，但多次测试都低于49。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010104.png" alt=""></p><p>&emsp;&emsp;首先查看优化建议，主要是核心js代码，这部分先暂时不动（博主目前前端优化技术有限）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010105.png" alt=""></p><p>&emsp;&emsp;查看其它影响项，发现看板娘占用了很多的网络资源（需要加载模型），所以先尝试移除这个功能。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010106.png" alt=""></p><h3 id="移除看板娘"><a href="#移除看板娘" class="headerlink" title="移除看板娘"></a><strong>移除看板娘</strong></h3><p>&emsp;&emsp;卸载相关包。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;删掉根目录配置文件中相关内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态妹子</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-shizuku</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">left</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">125</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">250</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;更新博客，再次测试，发现评分直接提高到97（汗，看来罪魁祸首就是模型了）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010107.png" alt=""></p><p>&emsp;&emsp;使用Google Chrome自带的Audits，再次测试博客加载性能。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://blog.serenader.me/ye-mian-de-jia-zai-xing-neng-you-hua-fang-an" target="_blank" rel="noopener">页面的加载性能优化方案</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://linyishui.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://linyishui.top/tags/hexo/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="http://linyishui.top/2020041701.html"/>
    <id>http://linyishui.top/2020041701.html</id>
    <published>2020-04-17T01:31:16.000Z</published>
    <updated>2020-04-21T10:35:15.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-为什么需要WebSocket"><a href="#1-1-为什么需要WebSocket" class="headerlink" title="1.1 为什么需要WebSocket"></a><strong>1.1 为什么需要WebSocket</strong></h3><p>&emsp;&emsp;我们已经有了HTTP协议，为什么还需要使用WebSocket呢？答案就是解决HTTP的缺陷-<strong>通信只能由客户端发起</strong>。</p><p>&emsp;&emsp;很多场景下我们需要由服务端主动向客户端推送消息，而HTTP协议这种单向请求的设计注定了服务器端有连续的状态变化时，客户端很难去获知。</p><p>&emsp;&emsp;早期，很多网站为了实现<a href="https://zh.wikipedia.org/wiki/推送技术" target="_blank" rel="noopener">推送技术</a>，所用的技术都是<a href="https://zh.wikipedia.org/wiki/輪詢" target="_blank" rel="noopener">轮询</a>。轮询是指由浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，然后服务器返回最新的数据给客户端。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求与回复可能会包含较长的<a href="https://zh.wikipedia.org/wiki/HTTP头字段" target="_blank" rel="noopener">头部</a>，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源，最常见的场景就是聊天室。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010102.png" alt=""></p><p>&emsp;&emsp;比较新的轮询技术是<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。</p><p>&emsp;&emsp;由此契机催生了WebSocket协议，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h3 id="1-2-什么是WebSocket"><a href="#1-2-什么是WebSocket" class="headerlink" title="1.2 什么是WebSocket"></a><strong>1.2 什么是WebSocket</strong></h3><p>&emsp;&emsp;<strong>WebSocket</strong>是一种<a href="https://zh.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在单个<a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP</a>连接上进行<a href="https://zh.wikipedia.org/wiki/全雙工" target="_blank" rel="noopener">全双工</a>通信，位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>。</p><p>&emsp;&emsp;WebSocket协议诞生于2008年，最初在<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>规范中被引用为TCPConnection，作为基于TCP的套接字API的占位符。2008年6月，<a href="https://zh.wikipedia.org/w/index.php?title=Michael_Carter&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Michael Carter</a>进行了一系列讨论，最终形成了称为WebSocket的协议。</p><p>&emsp;&emsp;WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>&emsp;&emsp;WebSocket是一种与<a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP</a>不同的协议。两者都位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>，并且都依赖于<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>的TCP协议。 虽然它们不同，但是RFC 6455中规定：<code>it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries</code>（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-1" target="_blank" rel="noopener">[1]</a>从HTTP协议更改为WebSocket协议。</p><p>&emsp;&emsp;WebSocket协议支持Web<a href="https://zh.wikipedia.org/wiki/浏览器" target="_blank" rel="noopener">浏览器</a>（或其他客户端应用程序）与Web<a href="https://zh.wikipedia.org/wiki/服务器" target="_blank" rel="noopener">服务器</a>之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)之类的技术以非标准化的方式实现了类似的双向通信。</p><p>&emsp;&emsp;<strong>与HTTP不同，WebSocket提供全双工通信</strong>。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-2" target="_blank" rel="noopener">[2]</a><a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-quantum-3" target="_blank" rel="noopener">[3]</a>此外，<strong>WebSocket还可以在TCP之上实现消息流</strong>。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p><blockquote><ul><li>单工通信：即只能A到B（广播），同一时间只允许一方向另一方传送消息，另一方则不允许反过来传送。</li><li>全双工：指在发送数据的同时也能接收数据，二者同步进行。</li><li>半双工：指在一个时间段内只有一个动作发生，数据信息可以沿两个方向传送，但同一时刻一个信道只允许单方向传送，因此也称为双向交替通信。如果要改变传输方向，需由开关进行切换。半双工方式要求收发两端都有发送装置和接收装置。由于这种方式要频繁变换信道方向，故效率低，但可以节约传输线路。半双工方式适用于终端与终端之间的会话式通信。</li></ul></blockquote><p>&emsp;&emsp;WebSocket协议规范将<code>ws</code>（WebSocket）和<code>wss</code>（WebSocket Secure）定义为两个新的<a href="https://zh.wikipedia.org/wiki/統一資源標識符" target="_blank" rel="noopener">统一资源标识符</a>（URI）方案<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-4" target="_blank" rel="noopener">[4]</a>，分别对应明文和加密连接，其中<code>wss</code>表示使用了<a href="https://zh.wikipedia.org/wiki/TLS" target="_blank" rel="noopener">TLS</a>的Websocket。除了方案名称和片段ID（不支持<code>#</code>）之外，其余的URI组件都被定义为此URI的通用语法。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-5" target="_blank" rel="noopener">[5]</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">w</span><span class="variable">s:</span>//example.<span class="keyword">com</span>/wsapi</span><br><span class="line"><span class="keyword">ws</span><span class="variable">s:</span>//secure.example.<span class="keyword">com</span>/wsapi</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。        </p><p>&emsp;&emsp;使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架。</p><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a><strong>1.3 优点</strong></h3><ul><li><p><strong>较少的控制开销</strong>。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a href="https://zh.wikipedia.org/wiki/掩码" target="_blank" rel="noopener">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p></li><li><p><strong>更强的实时性</strong>。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的<a href="https://zh.wikipedia.org/w/index.php?title=长轮询&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">长轮询</a>比较，其也能在短时间内更多次地传递数据。</p></li><li><p><strong>保持连接状态</strong>。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p></li><li><p><strong>更好的二进制支持</strong>。Websocket定义了<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</p></li><li><p><strong>可以支持扩展</strong>。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a href="https://zh.wikipedia.org/wiki/数据压缩" target="_blank" rel="noopener">压缩</a>等。</p></li><li><p><strong>更好的压缩效果</strong>。相对于<a href="https://zh.wikipedia.org/wiki/HTTP压缩" target="_blank" rel="noopener">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a href="https://zh.wikipedia.org/wiki/上下文" target="_blank" rel="noopener">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-14" target="_blank" rel="noopener">[14]</a></p></li></ul><h3 id="1-4-WebSocket和Socket"><a href="#1-4-WebSocket和Socket" class="headerlink" title="1.4 WebSocket和Socket"></a><strong>1.4 WebSocket和Socket</strong></h3><blockquote><p>WebSocket和Socket 的区别：</p><p>&emsp;&emsp;软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。</p><p>&emsp;&emsp;Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。</p><p>&emsp;&emsp;WebSocket 则是一个典型的应用层协议。</p><p>&emsp;&emsp;总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。</p></blockquote><h3 id="1-5-一次Websocket握手请求"><a href="#1-5-一次Websocket握手请求" class="headerlink" title="1.5 一次Websocket握手请求"></a><strong>1.5 一次Websocket握手请求</strong></h3><p>&emsp;&emsp;客户端请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;服务器回应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Location</span>: ws://example.com/</span><br></pre></td></tr></table></figure><ul><li>Connection 必须设置 Upgrade，表示客户端希望连接升级。</li><li>Upgrade 字段必须设置 Websocket，表示希望升级到 Websocket 协议。</li><li>Sec-WebSocket-Key 是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。把 “Sec-WebSocket-Key” 加上一个特殊字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算 SHA-1 摘要，之后进行 BASE-64 编码，将结果做为 “Sec-WebSocket-Accept” 头的值，返回给客户端。如此操作，可以尽量避免普通 HTTP 请求被误认为 Websocket 协议。</li><li>Sec-WebSocket-Version 表示支持的 Websocket 版本。RFC6455 要求使用的版本是 13，之前草案的版本均应当弃用。</li><li>Origin 字段是可选的，通常用来表示在浏览器中发起此 Websocket 连接所在的页面，类似于 Referer。但是，与 Referer 不同的是，Origin 只包含了协议和主机名称。</li><li>其他一些定义在 HTTP 协议中的字段，如 Cookie 等，也可以在 Websocket 中使用。</li></ul><h3 id="1-6-支持Websocket的服务器"><a href="#1-6-支持Websocket的服务器" class="headerlink" title="1.6 支持Websocket的服务器"></a><strong>1.6 支持Websocket的服务器</strong></h3><p>&emsp;&emsp;在服务器方面，网上都有不同对websocket支持的服务器：</p><ul><li>php - <a href="http://code.google.com/p/phpwebsocket/" target="_blank" rel="noopener">http://code.google.com/p/phpwebsocket/</a></li><li>jetty - <a href="http://jetty.codehaus.org/jetty/（版本7开始支持websocket）" target="_blank" rel="noopener">http://jetty.codehaus.org/jetty/（版本7开始支持websocket）</a></li><li>netty - <a href="http://www.jboss.org/netty" target="_blank" rel="noopener">http://www.jboss.org/netty</a></li><li>ruby - <a href="http://github.com/gimite/web-socket-ruby" target="_blank" rel="noopener">http://github.com/gimite/web-socket-ruby</a></li><li>Kaazing - <a href="https://web.archive.org/web/20100923224709/http://www.kaazing.org/confluence/display/KAAZING/Home" target="_blank" rel="noopener">https://web.archive.org/web/20100923224709/http://www.kaazing.org/confluence/display/KAAZING/Home</a></li><li>Tomcat - <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/（7.0.27支持websocket，建议用tomcat8，7.0.27中的接口已经过时）</a></li><li>WebLogic - <a href="http://www.oracle.com/us/products/middleware/cloud-app-foundation/weblogic/overview/index.html" target="_blank" rel="noopener">http://www.oracle.com/us/products/middleware/cloud-app-foundation/weblogic/overview/index.html（12.1.2開始支持）</a></li><li>node.js - <a href="https://github.com/Worlize/WebSocket-Node" target="_blank" rel="noopener">https://github.com/Worlize/WebSocket-Node</a></li><li>node.js - <a href="http://socket.io/" target="_blank" rel="noopener">http://socket.io</a></li><li>nginx - <a href="http://nginx.com/" target="_blank" rel="noopener">http://nginx.com/</a></li><li>mojolicious - <a href="http://mojolicio.us/" target="_blank" rel="noopener">http://mojolicio.us/</a></li><li>python - <a href="https://github.com/abourget/gevent-socketio" target="_blank" rel="noopener">https://github.com/abourget/gevent-socketio</a></li><li>Django - <a href="https://github.com/stephenmcd/django-socketio" target="_blank" rel="noopener">https://github.com/stephenmcd/django-socketio</a></li><li>erlang - <a href="https://github.com/ninenines/cowboy.git" target="_blank" rel="noopener">https://github.com/ninenines/cowboy.git</a></li></ul><h2 id="第二节-HTML5-WebSocket"><a href="#第二节-HTML5-WebSocket" class="headerlink" title="第二节 HTML5 WebSocket"></a><strong>第二节 HTML5 WebSocket</strong></h2><p>&emsp;&emsp;浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>&emsp;&emsp;当你获取 Web Socket 连接后，你可以通过 <strong>send()</strong> 方法来向服务器发送数据，并通过 <strong>onmessage</strong> 事件来接收服务器返回的数据。</p><p>&emsp;&emsp;以下 API 用于创建 WebSocket 对象。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Socket = <span class="keyword">new</span> <span class="type">WebSocket</span>(url, [protocol] );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h3 id="2-1-WebSocket-属性"><a href="#2-1-WebSocket-属性" class="headerlink" title="2.1 WebSocket 属性"></a><strong>2.1 WebSocket 属性</strong></h3><table><thead><tr><th style="text-align:left"><strong>属性</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">Socket.readyState</td><td style="text-align:left">只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td></tr><tr><td style="text-align:left">Socket.bufferedAmount</td><td style="text-align:left">只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td></tr></tbody></table><h3 id="2-2-WebSocket-事件"><a href="#2-2-WebSocket-事件" class="headerlink" title="2.2 WebSocket 事件"></a><strong>2.2 WebSocket 事件</strong></h3><table><thead><tr><th style="text-align:left"><strong>事件</strong></th><th style="text-align:left"><strong>事件处理程序</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">open</td><td style="text-align:left">Socket.onopen</td><td style="text-align:left">连接建立时触发</td></tr><tr><td style="text-align:left">message</td><td style="text-align:left">Socket.onmessage</td><td style="text-align:left">客户端接收服务端数据时触发</td></tr><tr><td style="text-align:left">error</td><td style="text-align:left">Socket.onerror</td><td style="text-align:left">通信发生错误时触发</td></tr><tr><td style="text-align:left">close</td><td style="text-align:left">Socket.onclose</td><td style="text-align:left">连接关闭时触发</td></tr></tbody></table><h3 id="2-3-WebSocket-方法"><a href="#2-3-WebSocket-方法" class="headerlink" title="2.3 WebSocket 方法"></a><strong>2.3 WebSocket 方法</strong></h3><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">Socket.send()</td><td style="text-align:left">使用连接发送数据</td></tr><tr><td style="text-align:left">Socket.close()</td><td style="text-align:left">关闭连接</td></tr></tbody></table><h3 id="2-4-WebSocket-实例"><a href="#2-4-WebSocket-实例" class="headerlink" title="2.4 WebSocket 实例"></a><strong>2.4 WebSocket 实例</strong></h3><p>&emsp;&emsp;WebSocket 协议本质上是一个基于 TCP 的协议。</p><p>&emsp;&emsp;为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">         <span class="function"><span class="keyword">function</span> <span class="title">WebSocketTest</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">         &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="string">"WebSocket"</span> <span class="keyword">in</span> <span class="built_in">window</span>)</span></span><br><span class="line"><span class="undefined">            &#123;</span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"您的浏览器支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="undefined">               </span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="actionscript">               <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:9998/echo"</span>);</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">               &#123;</span></span><br><span class="line"><span class="actionscript">                  <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span><br><span class="line"><span class="actionscript">                  ws.send(<span class="string">"发送数据"</span>);</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"数据发送中..."</span>);</span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span></span></span><br><span class="line"><span class="undefined">               &#123; </span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">var</span> received_msg = evt.data;</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"数据已接收..."</span>);</span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="actionscript">               ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span></span><br><span class="line"><span class="undefined">               &#123; </span></span><br><span class="line"><span class="actionscript">                  <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">"连接已关闭..."</span>); </span></span><br><span class="line"><span class="undefined">               &#125;;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="actionscript">            <span class="keyword">else</span></span></span><br><span class="line"><span class="undefined">            &#123;</span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 浏览器不支持 WebSocket</span></span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"您的浏览器不支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">         &#125;</span></span><br><span class="line"><span class="undefined">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sse"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:WebSocketTest()"</span>&gt;</span>运行 WebSocket<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;python服务部分省略。</p><hr><h2 id="第三节-实现"><a href="#第三节-实现" class="headerlink" title="第三节 实现"></a><strong>第三节 实现</strong></h2><p>&emsp;&emsp;有多种方式来实现 WebSocket 协议，Spring Boot 采用基于 STOMP 的实现，常见的还有如 Socket.IO等。</p><h3 id="3-1-STOMP"><a href="#3-1-STOMP" class="headerlink" title="3.1 STOMP"></a><strong>3.1 STOMP</strong></h3><p>&emsp;&emsp;STOMP：即<code>Simple Text Orientated Messaging Protocol</code>，它是一个简单的文本消息传输协议，属于 WebSocket 的子协议， 提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单， 易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。</p><h3 id="3-2-引入依赖"><a href="#3-2-引入依赖" class="headerlink" title="3.2 引入依赖"></a><strong>3.2 引入依赖</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此处使用jetty代替内置的Tomcat服务器，可以只引入<code>spring-boot-starter-websocket</code>即可。</p><h3 id="3-3-配置"><a href="#3-3-配置" class="headerlink" title="3.3 配置"></a><strong>3.3 配置</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry stompEndpointRegistry)</span> </span>&#123;</span><br><span class="line">        stompEndpointRegistry.addEndpoint(<span class="string">"/simple"</span>)</span><br><span class="line">                .setAllowedOrigins(<span class="string">"*"</span>) <span class="comment">//解决跨域问题</span></span><br><span class="line">                .withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.enableSimpleBroker(<span class="string">"/topic"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@EnableWebSocketMessageBroker</code> 注解表示开启使用STOMP协议，来传输基于代理的消息，Broker即代理。</li><li><code>registerStompEndpoints</code>方法表示注册STOMP协议的节点，并指定映射的URL。</li><li><code>addEndpoint().withSockJS()</code>用来注册STOMP协议节点，同时指定使用SockJS。</li><li><code>configureMessageBroker</code>方法用来配置消息代理，此处实现推送功能，所以是<code>/topic</code>。</li></ul><h3 id="3-4-消息类"><a href="#3-4-消息类" class="headerlink" title="3.4 消息类"></a><strong>3.4 消息类</strong></h3><p>&emsp;&emsp;请求消息类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;响应消息类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String responseMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseMessage</span><span class="params">(String responseMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseMessage = responseMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResponseMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-控制器"><a href="#3-5-控制器" class="headerlink" title="3.5 控制器"></a><strong>3.5 控制器</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WsController</span><span class="params">(SimpMessagingTemplate messagingTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messagingTemplate = messagingTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping</span>(<span class="string">"/welcome"</span>)</span><br><span class="line">    <span class="meta">@SendTo</span>(<span class="string">"/topic/say"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseMessage <span class="title">say</span><span class="params">(RequestMessage message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseMessage(<span class="string">"welcome,"</span> + message.getName() + <span class="string">" !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时推送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发现消息</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">"/topic/callback"</span>, <span class="string">"定时推送消息时间: "</span> + df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>say方法上添加的<code>@MessageMapping</code>注解和我们之前使用的<code>@RequestMapping</code>类似。</p></li><li><p><code>@SendTo</code>注解表示当服务器有消息需要推送的时候， 会对订阅了<code>@SendTo</code>中路径的浏览器发送消息。</p></li><li><p>除此之外，还定义了一个定时推送消息方法，这个方法每隔1秒会主动给订阅了主题<code>/topic/callback</code>的客户端推送消息。</p></li><li>到此为止服务器端就编写完成，可以看到服务器的编写非常简单。</li></ul><h3 id="3-6-网站客户端"><a href="#3-6-网站客户端" class="headerlink" title="3.6 网站客户端"></a><strong>3.6 网站客户端</strong></h3><p>&emsp;&emsp;<a href="https://github.com/yidao620c/SpringBootBucket/tree/master/springboot-websocket/src/test/java/com/xncoding/jwt/socket/client/html" target="_blank" rel="noopener">测试代码</a></p><p>&emsp;&emsp;页面上面点击”连接”按钮后，开始连接到<code>/simple</code>节点。输入名字后点击发送，将向<code>/welcome</code>的url发送消息。</p><p>&emsp;&emsp;同时订阅了两个主题：<code>/topic/say</code> 和 <code>/topic/callback</code>，会接收到服务器的say方法的返回，以及定时推送消息。</p><h3 id="3-7-Android客户端"><a href="#3-7-Android客户端" class="headerlink" title="3.7 Android客户端"></a><strong>3.7 Android客户端</strong></h3><p>&emsp;&emsp;参考 <a href="https://github.com/NaikSoftware/StompProtocolAndroid" target="_blank" rel="noopener">StompProtocolAndroid</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/WebSocket" target="_blank" rel="noopener">WebSocket-维基百科</a></p><p><a href="https://www.runoob.com/html/html5-websocket.html" target="_blank" rel="noopener">html5-websocket-菜鸟教程</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p><p><a href="https://www.xncoding.com/2017/07/15/spring/sb-websocket.html" target="_blank" rel="noopener">SpringBoot系列 - 集成WebSocket实时通信</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍WebSocket相关知识，内容包括：简介（为什么需要WebSocket、什么是WebSocket、优点、WebSocket和Socket、一次Websocket握手请求、支持Websocket的服务器），HTML5 WebSocket（WebSocket属性、WebSocket事件、WebSocket方法、WebSocket实例），实现（STOMP、引入依赖、配置、消息类、控制器、网站客户端、Android客户端）。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="webSocket" scheme="http://linyishui.top/tags/webSocket/"/>
    
  </entry>
  
  <entry>
    <title>Nginx简单处理一次灰度发布问题</title>
    <link href="http://linyishui.top/2020041501.html"/>
    <id>http://linyishui.top/2020041501.html</id>
    <published>2020-04-15T06:28:48.000Z</published>
    <updated>2020-04-16T09:41:22.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nginx简单处理一次灰度发布问题"><a href="#Nginx简单处理一次灰度发布问题" class="headerlink" title="Nginx简单处理一次灰度发布问题"></a><strong>Nginx简单处理一次灰度发布问题</strong></h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a><strong>1.需求</strong></h2><p>&emsp;&emsp;公司接手的一个半成品项目，客户要求更新版本时不要停掉网站（灰度发布）。</p><p>&emsp;&emsp;马上想到的方案是：主从热备和负载均衡，nginx+keepalived，然后又想到了自动部署-CI/CD，及时打住避免越想越远。这个项目本身比较粗糙，简单的解决当前的问题即可。</p><p>&emsp;&emsp;原系统使用session存储会话信息，所以还要解决session如何共享的问题，google了一下，决定nginx配置两台服务器负载均衡，发布新版本时，一次更新一个，然后使用Redis来共享session。</p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a><strong>2.实现</strong></h2><p>&emsp;&emsp;时间和精力有限，先在本地和测试服务器跑通一个demo。</p><p>&emsp;&emsp;两台机器：本机，服务器A</p><table><thead><tr><th style="text-align:center">工具</th><th style="text-align:center">本机</th><th style="text-align:center">服务器A</th></tr></thead><tbody><tr><td style="text-align:center">JDK 1.8</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Nginx</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">Redis</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr></tbody></table><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a><strong>2.1 代码</strong></h3><p>&emsp;&emsp;首先新建spring-boot项目，代码如下。</p><h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="(1) pom.xml"></a><strong>(1) pom.xml</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-application-properties"><a href="#2-application-properties" class="headerlink" title="(2) application.properties"></a><strong>(2) application.properties</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8022</span><br><span class="line"></span><br><span class="line">spring.redis.host=&#123;服务器A&#125;</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=</span><br><span class="line">spring.redis.timeout=5000</span><br></pre></td></tr></table></figure><h4 id="3-Application"><a href="#3-Application" class="headerlink" title="(3) Application"></a><strong>(3) Application</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NginxKeepalivedRedisDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NginxKeepalivedRedisDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-控制器和实体类"><a href="#4-控制器和实体类" class="headerlink" title="(4) 控制器和实体类"></a><strong>(4) 控制器和实体类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">login</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">"sessionId"</span>,session.getId());</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(<span class="string">"01"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        session.setAttribute(<span class="string">"userInfo"</span>, userInfo);</span><br><span class="line">        content.put(<span class="string">"hostAddress"</span>,InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">        content.put(<span class="string">"hostName"</span>,InetAddress.getLocalHost().getHostName());</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5392373940126446170L</span>;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a><strong>2.2 调试</strong></h3><p>&emsp;&emsp;尝试启动，发现报错：Connection refused: no further information。很明显Redis无法连接。</p><p>&emsp;&emsp;先开了下命令行，尝试 telnet 服务器A 6379 ，无法连通。</p><p>&emsp;&emsp;检查了一下防火墙，确认端口已经开放了，然后又检查了一下阿里云控制平台上是否在安全组中开放端口，发现也是正确的。</p><p>&emsp;&emsp;google了一下，尝试修改redis.conf，将bind 127.0.0.1 修改为0.0.0.0。</p><p>&emsp;&emsp;再次telnet，可以连通，分别在本地和服务器A发布服务（服务器端口8022被占用，启动时指定了端口8023），并分别访问：http://{服务器A}:8023/login</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务器A返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"6a5e81a6-04f4-4ca8-afd4-1559695c1446"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"xxx.xxx.xxx.xxx"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 本地返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"DESKTOP-xx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"2a7c4873-1f9b-414a-85fc-6298562de64b"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"192.168.31.197"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问：<a href="http://qxamoy.com:8023/login" target="_blank" rel="noopener">http://qxamoy.com:8023/login</a></p><p>&emsp;&emsp;修改配置文件nginx.conf（我新建了一个demo.conf并在nginx.conf中引用）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 负载均衡配置</span></span><br><span class="line">upstream demo_upstream&#123;</span><br><span class="line">  <span class="keyword">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8022</span> weight=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">server</span> xxx:<span class="number">8023</span> weight=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#虚拟主机的配置</span></span><br><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">    <span class="meta">#监听端口</span></span><br><span class="line">    listen <span class="number">7051</span>;</span><br><span class="line">    <span class="meta"># 指定ip地址或者域名，多个配置之间用空格分隔</span></span><br><span class="line">    server_name localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#对 "/" 启用反向代理</span></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//demo_upstream;</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动nginx。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx.exe</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问<a href="http://localhost:7051/login" target="_blank" rel="noopener">http://localhost:7051/login</a></p><p>&emsp;&emsp;可以观察每次请求后返回结果的变化（ip和session），顺利的话会看到根据权重来切换接收的服务端，所以日常更新版本时可以依次对单个服务器进行更新来完成“灰度发布”。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.v2ex.com/t/477509" target="_blank" rel="noopener">大家是怎么做到服务器热更新的?</a></p><p><a href="https://blog.csdn.net/IT_10/article/details/89365436" target="_blank" rel="noopener">超详细的Nginx负载均衡+高可用配置</a></p><p><a href="https://www.cnblogs.com/54chensongxia/p/12096493.html" target="_blank" rel="noopener">Spring系列.@EnableRedisHttpSession原理简析</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      使用Nginx来简单处理一次灰度发布的问题，更新网站后台同时“不停掉服务”。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="nginx" scheme="http://linyishui.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Postman笔记（持续更新）</title>
    <link href="http://linyishui.top/2020041001.html"/>
    <id>http://linyishui.top/2020041001.html</id>
    <published>2020-04-10T07:41:30.000Z</published>
    <updated>2020-04-23T02:55:45.926Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Postman笔记"><a href="#Postman笔记" class="headerlink" title="Postman笔记"></a><strong>Postman笔记</strong></h1><h2 id="1-自动获取Token"><a href="#1-自动获取Token" class="headerlink" title="1. 自动获取Token"></a><strong>1. 自动获取Token</strong></h2><p>&emsp;&emsp;首先根据login-api返回body确定token的位置。</p><p>&emsp;&emsp;然后在login-api中设置Tests，增加如下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"Status code is 200"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(responseBody);</span><br><span class="line"><span class="comment">// 项目多了一个Bearer，postman会自动生成，所以导致出现两个Bearer</span></span><br><span class="line"><span class="keyword">var</span> temp = data.token.substring(<span class="number">7</span>);</span><br><span class="line">pm.environment.set(<span class="string">"token"</span>, temp);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;添加自定义environment。</p><p>&emsp;&emsp;重新发送登录请求，观察是否自动生成环境变量。</p><p>&emsp;&emsp;接下来在使用token的api中通过的方式来获取变量，【Authorization】-&gt;【TYPE-Bearer Token】</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.postman.com/api-documentation-generator" title="Title" target="_blank" rel="noopener">postman-doc</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Postman笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="postman" scheme="http://linyishui.top/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（二）API介绍</title>
    <link href="http://linyishui.top/2020030201.html"/>
    <id>http://linyishui.top/2020030201.html</id>
    <published>2020-04-08T01:34:54.000Z</published>
    <updated>2020-04-21T09:36:39.348Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-API介绍"><a href="#第二章-API介绍" class="headerlink" title="第二章 API介绍"></a><strong>第二章 API介绍</strong></h1><h2 id="2-1-准备"><a href="#2-1-准备" class="headerlink" title="2.1 准备"></a><strong>2.1 准备</strong></h2><p>&emsp;&emsp;首先了解一些通用的Redis全局命令、数据结构和内部编码、单线程命令处理机制。</p><h3 id="2-1-1-全局命令"><a href="#2-1-1-全局命令" class="headerlink" title="2.1.1 全局命令"></a><strong>2.1.1 全局命令</strong></h3><p>&emsp;&emsp;Redis有5种数据结构，它们是键值对中的值，对于键来说有一些通用的命令。</p><h4 id="1-查看所有键"><a href="#1-查看所有键" class="headerlink" title="1. 查看所有键"></a><strong>1. 查看所有键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set java jedis</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set python redis-py</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">"python"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h4 id="2-键总数"><a href="#2-键总数" class="headerlink" title="2. 键总数"></a><strong>2. 键总数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;dbsize命令会返回当前数据库中键的总数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush mylist a b c d e f g</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; dbsize</span><br><span class="line">(integer) <span class="number">4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;dbsize命令在计算键总数时不会遍历所有键，而是直接获取Redis内置的键总数变量，所有dbsize命令的时间复杂度为O(1)。而keys命令则会遍历所有键，时间复杂度为O(n)，当Redis保存了大量键时，线上环境禁止使用。</p><h4 id="3-检查键是否存在"><a href="#3-检查键是否存在" class="headerlink" title="3. 检查键是否存在"></a><strong>3. 检查键是否存在</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果键存在就返回1，否则返回0。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists not_exist_key</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="4-删除键"><a href="#4-删除键" class="headerlink" title="4. 删除键"></a><strong>4. 删除键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key [key ...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;del是一个通用命令，无论值是什么数据结构类型，del命令都可以将其删除。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists java</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del mylist</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists mylist</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del not_exist_key</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set a</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set c</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; del a b c</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="5-键过期"><a href="#5-键过期" class="headerlink" title="5. 键过期"></a><strong>5. 键过期</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis支持对键添加过期时间，当超过过期时间后，会自动删除键。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire hello <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; tll hello</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; tll hello</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; tll hello</span><br><span class="line">(integer) -<span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><blockquote><p>tll命令会返回键的剩余过期时间，返回值有三类：</p><ul><li>大于0的整数：键剩余的过期时间。</li><li>-1：键没设置过期时间。</li><li>-2：键不存在。</li></ul></blockquote><h4 id="6-键的数据结构类型"><a href="#6-键的数据结构类型" class="headerlink" title="6. 键的数据结构类型"></a><strong>6. 键的数据结构类型</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;返回键对应的数据类型。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set a b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; type a</span><br><span class="line">string</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush mylist a b c d e f g</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; type mylist</span><br><span class="line">list</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; type not_exist_key</span><br><span class="line">none</span><br></pre></td></tr></table></figure><h3 id="2-1-2-数据结构和内部编码"><a href="#2-1-2-数据结构和内部编码" class="headerlink" title="2.1.2 数据结构和内部编码"></a><strong>2.1.2 数据结构和内部编码</strong></h3><p>&emsp;&emsp;type命令实际返回的就是当前键的数据结构类型，分别是：string、hash、list、set、zset，这些只是Redis对外的数据结构。实际上每种数据结构都有自己的底层内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码。</p><p>&emsp;&emsp;可以看到每种数据结构都有两种以上的内部编码实现，如list数据结构包含了linked和ziplist两种内部编码。同时有些内部编码，例如ziplist，可以作为多种外部数据结构的内部实现，可以通过object encoding命令查询内部编码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding hello</span><br><span class="line">"embstr"</span><br><span class="line">127.0.0.1:6379&gt; object encoding mylist</span><br><span class="line">"ziplist"</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis这样设计有两个好处：第一，可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令（有点装饰模式的意思）。第二，多种内部编码实现可以在不同的场景下发挥各自的优势，如ziplist比较节省内存，但是在列表元素比较多的情况下性能会有所下降，此时Redis会根据配置选项将列表类型的内部实现转换为linkedlist。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010105.jpg" alt=""></p><h3 id="2-1-3-单线程架构"><a href="#2-1-3-单线程架构" class="headerlink" title="2.1.3 单线程架构"></a><strong>2.1.3 单线程架构</strong></h3><p>&emsp;&emsp;Redis使用单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p><h4 id="1-单线程模型"><a href="#1-单线程模型" class="headerlink" title="1. 单线程模型"></a><strong>1. 单线程模型</strong></h4><p>&emsp;&emsp;首先开启三个redis-cli客户端同时执行命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端1设置一个字符串键值对</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line"><span class="comment"># 客户端2对counter做自增操作</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; incr counter</span><br><span class="line"><span class="comment"># 客户端3对counter做自增操作</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; incr counter</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis客户端和服务端的模型可以简化为图2-3，每次客户端调用都经历了：发送命令、执行命令、返回结果三个过程。Redis是单线程来处理命令的，所以一条命令从客户端到达服务端不会立刻被执行，而是进入一个队列中，然后逐个等待执行。因此上述三个命令的执行顺序并不确定。但一定不会发生并发问题，Redis通过I/O多路复用技术来解决I/O问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010106.jpg" alt=""></p><h4 id="2-为什么单线程可以这么快？"><a href="#2-为什么单线程可以这么快？" class="headerlink" title="2. 为什么单线程可以这么快？"></a><strong>2. 为什么单线程可以这么快？</strong></h4><p>&emsp;&emsp;通常单线程处理能力要比多线程差，而Redis却反常的拥有高性能的单线程模型，主要原因有以下三点：</p><blockquote><ul><li>纯内存访问，基础速度快，响应时间短。</li><li>非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间，如图2-6。</li><li>单线程避免了线程切换和竞态产生的消耗。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010107.jpg" alt=""></p><blockquote><p>单线程模型的优点：</p><ul><li>简化数据结构和算法的实现。</li><li>避免了线程切换和竞态产生的消耗。</li></ul></blockquote><p>&emsp;&emsp;单线程模型有一个弊端是不能出现执行时间过长的命令，否则会导致阻塞，这对于Redis这种高性能的服务是致命的，所以Redis是面向快速执行场景的数据库。</p><hr><h2 id="2-2-字符串"><a href="#2-2-字符串" class="headerlink" title="2.2 字符串"></a><strong>2.2 字符串</strong></h2><p>&emsp;&emsp;所有的键都是字符串类型，其它数据结构类型也是基于字符串类型来构建的。字符串既可以是字符串（当然包括如JSON和XML等）、数字、二进制（图片、音频、视频）等，但最大不能超过512MB。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010108.jpg" alt=""></p><h3 id="2-2-1-命令"><a href="#2-2-1-命令" class="headerlink" title="2.2.1 命令"></a><strong>2.2.1 命令</strong></h3><h4 id="1-设置值"><a href="#1-设置值" class="headerlink" title="(1) 设置值"></a><strong>(1) 设置值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br><span class="line">setex ...</span><br><span class="line">setnx ...</span><br></pre></td></tr></table></figure><blockquote><p>可选参数：</p><ul><li>ex seconds ：为键设置秒级过期时间。</li><li>px milliseconds：为键设置毫秒级过期时间。</li><li>nx：键必须不存在，才可以设置成功，用于添加。</li><li>xx：与nx相反，键必须存在，才可以设置成功，用于更新。</li></ul></blockquote><p>&emsp;&emsp;setnx和setxx在特殊的场景有其用处，比如多个客户端同时进行添加，使用setnx可以保证只有一个客户端能设置成功，算是一种分布式锁的实现方案。</p><h4 id="2-获取值"><a href="#2-获取值" class="headerlink" title="(2) 获取值"></a><strong>(2) 获取值</strong></h4><p>&emsp;&emsp;获取值，值不存在返回nil（空）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><h4 id="3-批量设置值"><a href="#3-批量设置值" class="headerlink" title="(3) 批量设置值"></a><strong>(3) 批量设置值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure><h4 id="4-批量获取值"><a href="#4-批量获取值" class="headerlink" title="(4) 批量获取值"></a><strong>(4) 批量获取值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;批量操作可以提高开发效率。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010109.jpg" alt=""></p><p>&emsp;&emsp;Redis可以支撑起每秒数万次的读写操作，但这是服务端的处理性能，客户端除了命令时间还要加上网络时间，假设网络时间为1毫秒，一次命令时间0.1毫秒，那么执行1000次get所需时间为1100毫秒，而1次mget则只需101毫秒。所以网络往往成为性能的瓶颈，不过要注意过量的批量操作也会导致Redis阻塞或网络拥塞。</p><h4 id="5-计数"><a href="#5-计数" class="headerlink" title="(5) 计数"></a><strong>(5) 计数</strong></h4><p>&emsp;&emsp;计数，对值进行自增操作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure><blockquote><p>返回值：</p><ul><li>值非整数 ：返回错误。</li><li>值为整数：返回自增后结果。</li><li>键不存在：按照值为0自增，返回结果1。</li><li>xx：与nx相反，键必须存在，才可以设置成功，用于更新。</li></ul></blockquote><p>&emsp;&emsp;如下图所示，test本不存在，hello则是非整数键。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010110.png" alt=""></p><p>&emsp;&emsp;除了自增（incr）以外，还有自减（decr）、自增指定数字（incrby）、自减指定数字（decrby）、自增浮点数（incrbyfloat）。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decr <span class="built_in">key</span></span><br><span class="line">incrby <span class="built_in">key</span> increment</span><br><span class="line">decrby <span class="built_in">key</span> decrement</span><br><span class="line">incrbyfloat <span class="built_in">key</span> increment</span><br></pre></td></tr></table></figure><h4 id="6-向字符串尾部追加值"><a href="#6-向字符串尾部追加值" class="headerlink" title="(6) 向字符串尾部追加值"></a><strong>(6) 向字符串尾部追加值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><h4 id="7-获取字符串长度"><a href="#7-获取字符串长度" class="headerlink" title="(7) 获取字符串长度"></a><strong>(7) 获取字符串长度</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><h4 id="8-设置并返回原值"><a href="#8-设置并返回原值" class="headerlink" title="(8) 设置并返回原值"></a><strong>(8) 设置并返回原值</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset key value</span><br></pre></td></tr></table></figure><h4 id="9-设置指定位置的字符"><a href="#9-设置指定位置的字符" class="headerlink" title="(9) 设置指定位置的字符"></a><strong>(9) 设置指定位置的字符</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange key offeset value</span><br></pre></td></tr></table></figure><h4 id="10-获取部分字符串"><a href="#10-获取部分字符串" class="headerlink" title="(10) 获取部分字符串"></a><strong>(10) 获取部分字符串</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrange key start <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="11-命令的时间复杂度"><a href="#11-命令的时间复杂度" class="headerlink" title="(11) 命令的时间复杂度"></a><strong>(11) 命令的时间复杂度</strong></h4><p>&emsp;&emsp;下图是字符串类型命令的时间复杂度，以供参考。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010111.jpg" alt=""></p><h3 id="2-2-2-内部编码"><a href="#2-2-2-内部编码" class="headerlink" title="2.2.2 内部编码"></a><strong>2.2.2 内部编码</strong></h3><blockquote><p>字符串内部编码有三种：</p><ul><li>int：8个字节的长整型。</li><li>embstr：小于等于39个字节的字符串。</li><li>raw：大于39个字节的字符串。</li></ul></blockquote><p>&emsp;&emsp;Redis会自动根据当前值的类型和长度决定使用哪种内部编码实现。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出内部编码类型</span></span><br><span class="line">object encoding key</span><br></pre></td></tr></table></figure><h3 id="2-2-3-使用场景"><a href="#2-2-3-使用场景" class="headerlink" title="2.2.3 使用场景"></a><strong>2.2.3 使用场景</strong></h3><h4 id="1-缓存功能"><a href="#1-缓存功能" class="headerlink" title="(1) 缓存功能"></a><strong>(1) 缓存功能</strong></h4><p>&emsp;&emsp;经典的缓存应用场景如图所示，Redis作为缓存层，MySql作为存储层，绝大部分数据都是从缓存中获取。由于Redis具有支撑高并发的特性，所以缓存能起到加速读写和降低后端压力的作用。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010112.jpg" alt=""></p><p>&emsp;&emsp;1) 通过此函数获取用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2) 首先从Redis获取用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义键</span></span><br><span class="line">userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">      <span class="comment">// 从Redis获取值</span></span><br><span class="line">      value = redis.get(userRedisKey);</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">// 将值进行反序列化为UserInfo并返回结果</span></span><br><span class="line">      userInfo = deserialize(value);</span><br><span class="line">      <span class="keyword">return</span> userInfo;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;3) 如果没有从Redis获取到用户信息，则需要从MySql中获取，并将结果写入Redis，并添加1小时过期时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从MySql获取用户信息</span></span><br><span class="line">userInfo = mysql.get(id);</span><br><span class="line">      <span class="comment">// 将userInfo序列化，并存入Redis</span></span><br><span class="line">      redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));</span><br><span class="line">      <span class="comment">// 返回结果</span></span><br><span class="line">      <span class="keyword">return</span> userInfo;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;合并后伪代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">// 定义键</span></span><br><span class="line">userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">       <span class="comment">// 从Redis获取值</span></span><br><span class="line">       value = redis.get(userRedisKey);</span><br><span class="line">       <span class="keyword">if</span> (value != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="comment">// 将值进行反序列化为UserInfo并返回结果</span></span><br><span class="line">       userInfo = deserialize(value);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 从MySql获取用户信息</span></span><br><span class="line">userInfo = mysql.get(id);</span><br><span class="line">       <span class="comment">// 将userInfo序列化，并存入Redis</span></span><br><span class="line">       redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));      </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 返回结果</span></span><br><span class="line">       <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-计数"><a href="#2-计数" class="headerlink" title="(2) 计数"></a><strong>(2) 计数</strong></h4><p>&emsp;&emsp;Redis可以实现快速技术、查询缓存的功能，同时数据可以异步落地到其他数据源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户观看后增加一次视频播放数，当然计数系统还有防作弊、不同维度计数、数据持久化到底层数据源等</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">incrVideoCounter</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">       key = <span class="string">"video:playCount:"</span> + id;</span><br><span class="line">       <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-共享Session"><a href="#3-共享Session" class="headerlink" title="(3) 共享Session"></a><strong>(3) 共享Session</strong></h4><p>&emsp;&emsp;如图所示，一个分布式Web服务将用户的Session信息保存在各自的服务器中，这样会造成一个问题，出于负载均衡的考虑，分布式服务器会将用户的访问均衡到不同的服务器上，用户每刷新一次访问可能会发现要重新登录，这是用户无法容忍的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010113.jpg" alt=""></p><p>&emsp;&emsp;为了解决这个问题，可以使用Redis将Session进行集中管理，如下图所示，这种模式下只要保证Redis是高可用和扩展性的，每次用户更新或查询登录信息都直接从Redis获取。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010114.jpg" alt=""></p><h4 id="4-限速"><a href="#4-限速" class="headerlink" title="(4) 限速"></a><strong>(4) 限速</strong></h4><p>&emsp;&emsp;很多应用出于安全的考虑，会在每次登录时让用户输入手机验证码，以确认是否本人操作。但为了使短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，如图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010115.jpg" alt=""></p><p>&emsp;&emsp;此功能可以通过Redis实现，伪代码如下。当然一些限制IP地址不能短时间多次访问也可以如此实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phoneNum = <span class="string">"138xxxxxxxx"</span>;</span><br><span class="line">key = <span class="string">"shortMsg:limit:"</span> + phoneNum;</span><br><span class="line"><span class="comment">// SET key value EX 60 NX 过期时间60秒+NX只做新增</span></span><br><span class="line">isExists = redis.set(key.1, <span class="string">"EX 60"</span>, <span class="string">"NX"</span>);</span><br><span class="line"><span class="keyword">if</span>(isExists != <span class="keyword">null</span> || redis.incr(key) &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">          <span class="comment">// 通过</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 限速</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-哈希"><a href="#2-3-哈希" class="headerlink" title="2.3 哈希"></a><strong>2.3 哈希</strong></h2><p>&emsp;&emsp;hash，可以叫哈希、字典、关联数组。在Redis中，哈希类型是指键值本身又是一个键值对结构，形如value={ {field1, value1}, … ,{filedN, valueN} }，Redis键值对和哈希类型二者关系如下图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010116.jpg" alt=""></p><h3 id="2-3-1-命令"><a href="#2-3-1-命令" class="headerlink" title="2.3.1 命令"></a><strong>2.3.1 命令</strong></h3><h4 id="1-设置值-1"><a href="#1-设置值-1" class="headerlink" title="(1) 设置值"></a><strong>(1) 设置值</strong></h4><p>&emsp;&emsp;设置值，成功返回1，失败返回0。和set一样hset也有NX版本-hsetnx，作用域由键变为field。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset user:<span class="number">1</span> name tom</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-获取值-1"><a href="#2-获取值-1" class="headerlink" title="(2) 获取值"></a><strong>(2) 获取值</strong></h4><p>&emsp;&emsp;获取值，键或field不存在时返回nil。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hget user:<span class="number">1</span> name</span><br><span class="line"><span class="string">"tom"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hget user:<span class="number">2</span> name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="3-删除一个或多个field"><a href="#3-删除一个或多个field" class="headerlink" title="(3) 删除一个或多个field"></a><strong>(3) 删除一个或多个field</strong></h4><p>&emsp;&emsp;删除一个或多个field，返回结果为成功删除的field个数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field ...]</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hdel user:<span class="number">1</span> name</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hdel user:<span class="number">1</span> age</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="4-计算field的个数"><a href="#4-计算field的个数" class="headerlink" title="(4) 计算field的个数"></a><strong>(4) 计算field的个数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset user:<span class="number">1</span> name tom</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset user:<span class="number">1</span> age <span class="number">23</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset user:<span class="number">1</span> city tianjin</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hlen user:<span class="number">1</span></span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="5-批量设置或获取field-value"><a href="#5-批量设置或获取field-value" class="headerlink" title="(5) 批量设置或获取field-value"></a><strong>(5) 批量设置或获取field-value</strong></h4><p>&emsp;&emsp;批量设置或获取field-value，hmget需要key和多个field，hmset需要key和多对field-value</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field ...]</span><br><span class="line">hmset key field value [field value ...]</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hmset user:<span class="number">1</span> name mike age <span class="number">12</span> city tianjin</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hmget user:<span class="number">1</span> name city</span><br><span class="line"><span class="number">1</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"tianjin"</span></span><br></pre></td></tr></table></figure><h4 id="6-判断field是否存在"><a href="#6-判断field是否存在" class="headerlink" title="(6) 判断field是否存在"></a><strong>(6) 判断field是否存在</strong></h4><p>&emsp;&emsp;判断field是否存在，存在为1，否则为0。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hexists user:<span class="number">1</span> name</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="7-获取所有field"><a href="#7-获取所有field" class="headerlink" title="(7) 获取所有field"></a><strong>(7) 获取所有field</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hkeys user:<span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>) <span class="string">"name"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"age"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"city"</span></span><br></pre></td></tr></table></figure><h4 id="8-获取所有value"><a href="#8-获取所有value" class="headerlink" title="(8) 获取所有value"></a><strong>(8) 获取所有value</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hvalues key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hvalues user:<span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"12"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"tianjin"</span></span><br></pre></td></tr></table></figure><h4 id="9-获取所有的field-value"><a href="#9-获取所有的field-value" class="headerlink" title="(9) 获取所有的field-value"></a><strong>(9) 获取所有的field-value</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hgetall user:<span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>) <span class="string">"name"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"age"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"12"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"city"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"tianjin"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果哈希元素个数较多，可能会阻塞Redis，如果只须获取部分field，可以使用hmget；一定要获取全部field-value可以使用hscan命令，渐进式遍历哈希类型。</p><h4 id="10-field指定数字自增"><a href="#10-field指定数字自增" class="headerlink" title="(10) field指定数字自增"></a><strong>(10) field指定数字自增</strong></h4><p>&emsp;&emsp;同incrby和incrbyfloat一样，指定数字自增，但作用域是field。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field</span><br><span class="line">hincrbyfloat key field</span><br></pre></td></tr></table></figure><h4 id="11-计算value的字符串长度"><a href="#11-计算value的字符串长度" class="headerlink" title="(11) 计算value的字符串长度"></a><strong>(11) 计算value的字符串长度</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hstrlen key field</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hstrlen user:<span class="number">1</span> name</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="12-命令的时间复杂度"><a href="#12-命令的时间复杂度" class="headerlink" title="(12) 命令的时间复杂度"></a><strong>(12) 命令的时间复杂度</strong></h4><p>&emsp;&emsp;下图是哈希类型命令的时间复杂度，以供参考。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010117.jpg" alt=""></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010118.jpg" alt=""></p><h3 id="2-3-2-内部编码"><a href="#2-3-2-内部编码" class="headerlink" title="2.3.2 内部编码"></a><strong>2.3.2 内部编码</strong></h3><blockquote><p>哈希类型的内部编码有两种：</p><ul><li><strong>ziplist</strong>（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认为512个），同时所有值都小于hash-max-ziplist-value配置（默认为6字节）时，Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以相比hashtable会更节省空间。</li><li><strong>hashtable</strong>（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，这种情况ziplist的读写效率会下降，而hashtable读写时间复杂度为O(1)。</li></ul></blockquote><h3 id="2-3-3-使用场景"><a href="#2-3-3-使用场景" class="headerlink" title="2.3.3 使用场景"></a><strong>2.3.3 使用场景</strong></h3><p>&emsp;&emsp;如图所示，为关系型数据库和Redis哈希类型存储用户信息的对比。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010119.jpg" alt=""></p><p>&emsp;&emsp;相比于使用字符串序列化缓存用户信息，哈希类型更为直观，并且在更新操作上更加便捷。可以将每个用户的id定义为键的后缀，多对field-value对应每个用户的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line"><span class="comment">// 定义键，用户id作为key后缀</span></span><br><span class="line">userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">       <span class="comment">// 从Redis获取值，使用hgetall获取所有用户信息映射关系</span></span><br><span class="line">       userInfoMap = redis.hgetAll(userRedisKey);</span><br><span class="line">       UserInfo userInfo;</span><br><span class="line">       <span class="keyword">if</span> (userInfoMap != <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="comment">// 将映射关系转化为UserInfo</span></span><br><span class="line">       userInfo = transferMapToUserInfo(userInfoMap);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 从MySql获取用户信息</span></span><br><span class="line">userInfo = mysql.get(id);</span><br><span class="line">           <span class="comment">// 将UserInfo转换为映射关系并通过hmset保存到Redis</span></span><br><span class="line">       redis.hmset(userRedisKey, transferUserInfoToMap(userInfo));    </span><br><span class="line">       <span class="comment">// 添加过期时间</span></span><br><span class="line">       redis.expire(userRedisKey, <span class="number">3600</span>);      </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 返回结果</span></span><br><span class="line">       <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，哈希类型和关系型数据库的不同：</p><ul><li>哈希类型是稀疏的，而关系型数据库是完全结构化的。比如哈希类型每个键可以有不同的field，而关系型数据库一旦添加新的列，每行都要为其设置值（即使为null）</li><li>关系型数据库可以做复杂的关系查询，而Redis去模拟关系型复杂查询开发比较困难，维护成本很高。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010120.jpg" alt=""></p><p>&emsp;&emsp;目前为止，有三种方法来缓存用户信息，下面分别列出其实现方法和优缺点。</p><h4 id="1-原生字符串类型：每个属性一个键"><a href="#1-原生字符串类型：每个属性一个键" class="headerlink" title="(1) 原生字符串类型：每个属性一个键"></a><strong>(1) 原生字符串类型：每个属性一个键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:<span class="number">1</span>:name tom</span><br><span class="line">set user:<span class="number">1</span>:age <span class="number">23</span></span><br><span class="line">set user:<span class="number">1</span>:city beijing</span><br></pre></td></tr></table></figure><ul><li>优点：简单直观，每个属性都支持更新操作。</li><li>缺点：占用过多的键，内存占用量较大，同时用户信息内聚性比较差，所以此方案一般不会在生产环境使用。</li></ul><h4 id="2-序列化字符串类型：将用户信息序列化后用一个键保存"><a href="#2-序列化字符串类型：将用户信息序列化后用一个键保存" class="headerlink" title="(2) 序列化字符串类型：将用户信息序列化后用一个键保存"></a><strong>(2) 序列化字符串类型：将用户信息序列化后用一个键保存</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:<span class="number">1</span>: serialize(userInfo)</span><br></pre></td></tr></table></figure><ul><li>优点：简化编程，如果合理使用序列化可以提高内存的使用效率。</li><li>缺点：序列化和反序列化有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。</li></ul><h4 id="3-哈希类型：每个用户属性使用一对field-value，但是只用一个键保存"><a href="#3-哈希类型：每个用户属性使用一对field-value，但是只用一个键保存" class="headerlink" title="(3) 哈希类型：每个用户属性使用一对field-value，但是只用一个键保存"></a><strong>(3) 哈希类型：每个用户属性使用一对field-value，但是只用一个键保存</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:<span class="number">1</span>:name tom age <span class="number">23</span> city beijing</span><br></pre></td></tr></table></figure><ul><li>优点：简单直观，如果合理使用可以减少内存空间的使用。</li><li>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</li></ul><hr><h2 id="2-4-列表"><a href="#2-4-列表" class="headerlink" title="2.4 列表"></a><strong>2.4 列表</strong></h2><p>&emsp;&emsp;列表类型（list）用来存储多个有序的字符串。如图所示，5个元素从左到右组成了一个<strong>有序</strong>的列表，每个字符串即元素（element），一个列表最多可存储<strong>2^32-1</strong>个元素。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010121.jpg" alt=""></p><p>&emsp;&emsp;在Redis中，可以对列表两端<strong>插入</strong>（push）和<strong>弹出</strong>（pop），还可以<strong>获取指定范围的元素列表</strong>、<strong>获取指定索引下标的元素</strong>等。总的来说，列表是一种比较灵活的数据结构，可以充当<strong>栈</strong>和<strong>队列</strong>的角色。</p><blockquote><p>列表类型有两个特点：</p><ul><li><strong>元素有序</strong>，意味着可以通过索引下标获取某个元素或某个范围内元素列表。</li><li><strong>元素可重复</strong>。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010122.jpg" alt=""></p><h3 id="2-4-1-命令"><a href="#2-4-1-命令" class="headerlink" title="2.4.1 命令"></a><strong>2.4.1 命令</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010123.jpg" alt=""></p><h4 id="1-添加操作"><a href="#1-添加操作" class="headerlink" title="(1) 添加操作"></a><strong>(1) 添加操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从右边插入元素</span></span><br><span class="line">rpush key value [value ...]</span><br><span class="line"><span class="comment"># 从左边插入元素</span></span><br><span class="line">lpush key value [value ...]</span><br><span class="line"><span class="comment"># 向某个元素前或后插入元素</span></span><br><span class="line">linsert key before|after pivot value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush listkey c b a</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="comment"># lrange key 0 -1从左到右获取列表所有元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; linsert listkey before b java</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><h4 id="2-查找操作"><a href="#2-查找操作" class="headerlink" title="(2) 查找操作"></a><strong>(2) 查找操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取指定范围内的元素列表</span></span><br><span class="line">lrange key start <span class="keyword">end</span></span><br><span class="line"><span class="comment"># 获取列表指定索引下标的元素</span></span><br><span class="line">lindex key index</span><br><span class="line"><span class="comment"># 获取列表长度</span></span><br><span class="line">llen key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lindex listkey -<span class="number">1</span></span><br><span class="line"><span class="string">"a"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; llen listkey</span><br><span class="line">(integer) <span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>索引下标有两个特点：</p><ul><li>索引下标从左到右分别是0到N-1，从右到左分别是-1到-N。</li><li>lrange中的end选项包含了自身，不同于大部分编程语言不包含end。</li></ul></blockquote><h4 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="(3) 删除操作"></a><strong>(3) 删除操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从列表左侧弹出元素</span></span><br><span class="line">lpop key</span><br><span class="line"><span class="comment"># 从列表右侧弹出元素</span></span><br><span class="line">rpop key</span><br><span class="line"><span class="comment"># 删除指定元素</span></span><br><span class="line">lrem key count value</span><br><span class="line"><span class="comment"># 按照索引范围修剪列表</span></span><br><span class="line">ltrim key start <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop listkey</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="comment"># 先从左插入4个a，再删除从左开始4个a元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrem listkey <span class="number">4</span> a</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"a"</span></span><br><span class="line"><span class="comment"># 只保留第2到第4个元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ltrim listkey <span class="number">1</span> <span class="number">3</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><blockquote><p>count情况包括三种：</p><ul><li><strong>count&gt;0</strong>：从左到右，删除最多count个元素。</li><li><strong>count&lt;0</strong>：从右到左，删除最多count绝对值个元素。</li><li><strong>count=0</strong>：删除所有。</li></ul></blockquote><h4 id="4-修改操作"><a href="#4-修改操作" class="headerlink" title="(4) 修改操作"></a><strong>(4) 修改操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置第3个元素为python</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lset listkey <span class="number">2</span> python</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange listkey <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"java"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"python"</span></span><br></pre></td></tr></table></figure><h4 id="5-阻塞操作"><a href="#5-阻塞操作" class="headerlink" title="(5) 阻塞操作"></a><strong>(5) 阻塞操作</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ...] timeout</span><br><span class="line">brpop key [key ...] timeout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.列表为空：timeout=3，客户端等待3秒才能返回，timeout=0，客户端一直阻塞。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:test <span class="number">3</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line">...阻塞...</span><br><span class="line"><span class="comment"># 如果期间添加了数据element1，客户端立即返回。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:test <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"list:test"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"element1"</span></span><br><span class="line">(<span class="number">2.06</span>s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.列表不为空：客户端立即返回。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"list:test"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"element1"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;blpop/brpop是lpop和rpop的阻塞版本，除了弹出方向不同，使用方法基本相同。</p><blockquote><p>使用brpop时需要注意两点：</p><ul><li><p>如果是多个键，brpop会从左到右遍历键，一旦有一个可以弹出元素，客户端立即返回。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:<span class="number">1</span> list:<span class="number">2</span> list:<span class="number">3</span> <span class="number">0</span></span><br><span class="line">&gt;   ..阻塞..</span><br><span class="line">&gt;   <span class="comment"># 另一个客户端同时分别插入元素</span></span><br><span class="line">&gt;   client-lpush&gt; lpush list:<span class="number">2</span> element2</span><br><span class="line">&gt;   (integer) <span class="number">1</span></span><br><span class="line">&gt;   client-lpush&gt; lpush list:<span class="number">3</span> element3</span><br><span class="line">&gt;   (integer) <span class="number">1</span></span><br><span class="line">&gt;   <span class="comment"># 客户端立即返回list:2中的element2，因为其最先有可以弹出的元素</span></span><br><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:<span class="number">1</span> list:<span class="number">2</span> list:<span class="number">3</span> <span class="number">0</span></span><br><span class="line">&gt;   <span class="number">1</span>) <span class="string">"list:2"</span></span><br><span class="line">&gt;   <span class="number">2</span>) <span class="string">"element2_1"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>如果多个客户端对同一个键执行brpop，最先执行brpop命令的客户端可以获取到弹出的值。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment"># 客户端1</span></span><br><span class="line">&gt;   client-<span class="number">1</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line">&gt;   ..阻塞..</span><br><span class="line">&gt;   <span class="comment"># 客户端2</span></span><br><span class="line">&gt;   client-<span class="number">2</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line">&gt;   ..阻塞..</span><br><span class="line">&gt;   <span class="comment"># 客户端3</span></span><br><span class="line">&gt;   client-<span class="number">3</span>&gt; brpop list:test <span class="number">0</span></span><br><span class="line">&gt;   ..阻塞..</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="comment"># 此时另一个客户端lpush一个元素到list:test列表中</span></span><br><span class="line">&gt;   client-lpush&gt; lpush list:test element</span><br><span class="line">&gt;   (integer) <span class="number">1</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="comment"># 客户端1会获取到元素，因为其最先执行brpop，客户端2和3会继续阻塞</span></span><br><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; brpop list:<span class="number">1</span> list:<span class="number">2</span> list:<span class="number">3</span> <span class="number">0</span></span><br><span class="line">&gt;   <span class="number">1</span>) <span class="string">"list:test"</span></span><br><span class="line">&gt;   <span class="number">2</span>) <span class="string">"element"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010124.jpg" alt=""></p><h3 id="2-4-2-内部编码"><a href="#2-4-2-内部编码" class="headerlink" title="2.4.2 内部编码"></a><strong>2.4.2 内部编码</strong></h3><blockquote><p>列表类型的内部编码有两种：</p><ul><li><strong>ziplist</strong>：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li><li><strong>linkedlist</strong>（链表）：当列表类型无法满足ziplist的条件时，Redis会使用链表实现。</li></ul></blockquote><p>&emsp;&emsp;Redis 3.2版本提供了quicklist的内部编码，其结合了ziplist和linkedlist的优势，是一种更优秀的内部编码实现。</p><h3 id="2-4-3-使用场景"><a href="#2-4-3-使用场景" class="headerlink" title="2.4.3 使用场景"></a><strong>2.4.3 使用场景</strong></h3><h4 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="(1) 消息队列"></a><strong>(1) 消息队列</strong></h4><p>&emsp;&emsp;如下图所示，Redis的lpush+brpop命令组合即可实现<strong>阻塞队列</strong>，生产者客户端使用lpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010125.jpg" alt=""></p><h4 id="2-文章列表"><a href="#2-文章列表" class="headerlink" title="(2) 文章列表"></a><strong>(2) 文章列表</strong></h4><p>&emsp;&emsp;每个用户都有属于自己的文章列表，现需要分页展示文章列表。这种情况可以考虑列表，因为列表不但是有序的，同时支持按照索引范围获取元素。</p><blockquote><ol><li><p>每篇文章饰演哈希结构存储，例如每篇文章有三个属性：title、timestamp和content。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    hmset article:1 title xx timestamp 1476536196 content xxxx</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    hmset article:k title yy timestamp 1476512536 content yyyy</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>向用户文章列表添加文章，user:{id}:articles作为用户文章列表的键。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    lpush user:1:articles article:1 article:3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    lpush user:k:articles article:5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    ...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>分页获取用户文章列表，例如下面伪代码获取用户id=1的前10篇文章。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    articles = <span class="keyword">lrange</span> user:<span class="number">1</span>:articles <span class="number">0</span> <span class="number">9</span></span><br><span class="line">&gt;    <span class="keyword">for</span> article in &#123;articles&#125;</span><br><span class="line">&gt;    hgetall &#123;article&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p> 使用列表类型来保存和获取文章列表会存在两个问题：</p><ul><li>如果每次分页获取的文章个数较多，需要执行多次hgetall操作，此时可以考虑使用<strong>Pipeline</strong>批量获取，或者考虑将文章数据<strong>序列化为字符串类型</strong>，<strong>使用mget批量获取</strong>。</li><li>分页获取文章列表时，lrange命令在列表两端性能较好，但如果列表较大，获取列表中间范围的元素性能会变差，此时可以考虑将列表做<strong>二级拆分</strong>，或使用Redis 3.2的<strong>quicklist</strong>内部编码实现，获取中间的元素也可以高效完成。</li></ul></blockquote><blockquote><p> 使用列表时可以参考如下口诀：</p><ul><li>lpush + lpop = Stack（栈）</li><li>lpush + rpop = Queue（队列）</li><li>lpush + ltrim = Capped Collection（有限集合）</li><li>lpush + brpop = Message Queue（消息队列）</li></ul></blockquote><hr><h2 id="2-5-集合"><a href="#2-5-集合" class="headerlink" title="2.5 集合"></a><strong>2.5 集合</strong></h2><p>&emsp;&emsp;集合（set）类型也是用来保存多个字符串元素，但和列表不同的是，集合<strong>不允许有重复</strong>元素，且集合中的元素是<strong>无序</strong>的，不能通过索引下标获取元素。Redis除了支持集合内的增删改查，还支持了多个集合取交集、并集、差集。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010126.jpg" alt=""></p><h3 id="2-5-1-命令"><a href="#2-5-1-命令" class="headerlink" title="2.5.1 命令"></a><strong>2.5.1 命令</strong></h3><p>&emsp;&emsp;1到7为集合内操作，8到11为集合间操作。</p><h4 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="(1) 添加元素"></a><strong>(1) 添加元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果为成功个数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists myset</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd myset a b c</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd myset a b</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="(2) 删除元素"></a><strong>(2) 删除元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">srem key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果为成功个数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srem myset a b</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd myset hello</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="3-计算元素个数"><a href="#3-计算元素个数" class="headerlink" title="(3) 计算元素个数"></a><strong>(3) 计算元素个数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br><span class="line"></span><br><span class="line"><span class="comment"># scard时间复杂度为O(1)，不会遍历集合，而是直接用Redis内部的变量（类似类中的计数器属性）</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scard myset</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="4-判断元素是否在集合中"><a href="#4-判断元素是否在集合中" class="headerlink" title="(4) 判断元素是否在集合中"></a><strong>(4) 判断元素是否在集合中</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sismember key element</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果给定元素element在集合中就返回1，否则返回0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srem myset c</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="5-随机从集合返回指定个数元素"><a href="#5-随机从集合返回指定个数元素" class="headerlink" title="(5) 随机从集合返回指定个数元素"></a><strong>(5) 随机从集合返回指定个数元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># count是可选参数，默认为1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srandmember myset <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srandmember myset</span><br><span class="line"><span class="string">"d"</span></span><br></pre></td></tr></table></figure><h4 id="6-从集合随机弹出元素"><a href="#6-从集合随机弹出元素" class="headerlink" title="(6) 从集合随机弹出元素"></a><strong>(6) 从集合随机弹出元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spop key</span><br><span class="line"></span><br><span class="line"><span class="comment"># spop操作可以从集合随机弹出一个元素，如下一次pop后，元素变为(d, b, a)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; spop myset</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis 3.2版本后，spop也支持[count]参数。srandmember和spop都是随机选出元素，只不过spop会同时删掉此元素。</p><h4 id="7-获取所有元素"><a href="#7-获取所有元素" class="headerlink" title="(7) 获取所有元素"></a><strong>(7) 获取所有元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果是无序的</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;smembers和lrange、hgetall一样，都属于比较<strong>重</strong>的命令，如果元素过多就存在阻塞Redis的可能，可以通过<strong>sscan</strong>来代替。</p><h4 id="8-求多个集合的交集"><a href="#8-求多个集合的交集" class="headerlink" title="(8) 求多个集合的交集"></a><strong>(8) 求多个集合的交集</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增两个集合</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd user:<span class="number">1</span>:follow it music his sports</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd user:<span class="number">2</span>:follow it news ent sports</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 获取交集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinter user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow</span><br><span class="line"><span class="number">1</span>) <span class="string">"sports"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"it"</span></span><br></pre></td></tr></table></figure><h4 id="9-求多个集合的并集"><a href="#9-求多个集合的并集" class="headerlink" title="(9) 求多个集合的并集"></a><strong>(9) 求多个集合的并集</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sunion key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取并集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sunion user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow</span><br><span class="line"><span class="number">1</span>) <span class="string">"sports"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"it"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"his"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"news"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"music"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"ent"</span></span><br></pre></td></tr></table></figure><h4 id="10-求多个集合的差集"><a href="#10-求多个集合的差集" class="headerlink" title="(10) 求多个集合的差集"></a><strong>(10) 求多个集合的差集</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sdiff key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取差集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinter user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow</span><br><span class="line"><span class="number">1</span>) <span class="string">"music"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"his"</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010127.jpg" alt=""></p><h4 id="11-将交集、并集、差集的结果保存"><a href="#11-将交集、并集、差集的结果保存" class="headerlink" title="(11) 将交集、并集、差集的结果保存"></a><strong>(11) 将交集、并集、差集的结果保存</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [key ...]</span><br><span class="line">sunionstore destination key [key ...]</span><br><span class="line">sdiffstore destination key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合间的运算在元素较多时会比较耗时，可以通过上述三个命令将结果保存在destination key中。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sinterstore user:<span class="number">1</span>_2:inter user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; type user:<span class="number">1</span>_2:inter</span><br><span class="line">set</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers user:<span class="number">1</span>_2:inter</span><br><span class="line"><span class="number">1</span>) <span class="string">"it"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"sports"</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010128.jpg" alt=""></p><h3 id="2-5-2-内部编码"><a href="#2-5-2-内部编码" class="headerlink" title="2.5.2 内部编码"></a><strong>2.5.2 内部编码</strong></h3><blockquote><p>集合类型的内部编码有两种：</p><ul><li><strong>intset</strong>（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis会选用intset来作为集合内部实现，从而减少内存的使用。</li><li><strong>hashtable</strong>（哈希表）：集合无法满足intset的条件时，选用hashtable作为集合内部实现。</li></ul></blockquote><h3 id="2-5-3-使用场景"><a href="#2-5-3-使用场景" class="headerlink" title="2.5.3 使用场景"></a><strong>2.5.3 使用场景</strong></h3><p>&emsp;&emsp;集合类型比较典型的使用场景是<strong>标签</strong>。</p><p>&emsp;&emsp;例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就可以是标签。有了这些用户数据，就可以从这个维度得到兴趣相投的用户，以及共同喜欢的标签等，这些对于提高用户体验以及增强用户粘度比较重要。</p><h4 id="1-给用户添加标签"><a href="#1-给用户添加标签" class="headerlink" title="(1) 给用户添加标签"></a><strong>(1) 给用户添加标签</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd user:<span class="number">1</span>:tags tag1 tag2 tag5</span><br><span class="line">sadd user:<span class="number">2</span>:tags tag2 tag3 tag5</span><br><span class="line">...</span><br><span class="line">sadd user:k:tags tag1 tag2 tag4</span><br></pre></td></tr></table></figure><h4 id="2-给标签添加用户"><a href="#2-给标签添加用户" class="headerlink" title="(2) 给标签添加用户"></a><strong>(2) 给标签添加用户</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd tag1:users user:<span class="number">1</span> user:<span class="number">3</span></span><br><span class="line">sadd tag2:users user:<span class="number">1</span> user:<span class="number">2</span> user:<span class="number">3</span></span><br><span class="line">...</span><br><span class="line">sadd tagk:users user:<span class="number">1</span> user:<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="3-删除用户下的标签"><a href="#3-删除用户下的标签" class="headerlink" title="(3) 删除用户下的标签"></a><strong>(3) 删除用户下的标签</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srem user:<span class="number">1</span>:tags tag1 tag5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="4-删除标签下的用户"><a href="#4-删除标签下的用户" class="headerlink" title="(4) 删除标签下的用户"></a><strong>(4) 删除标签下的用户</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srem tag1:users user:<span class="number">1</span></span><br><span class="line">srem tag5:users user:<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;3和4都是尽量放在一个事务下执行。</p><h4 id="5-计算用户共同感兴趣的标签"><a href="#5-计算用户共同感兴趣的标签" class="headerlink" title="(5) 计算用户共同感兴趣的标签"></a><strong>(5) 计算用户共同感兴趣的标签</strong></h4><p>&emsp;&emsp;可以通过sinter命令，来计算用户共同感兴趣的标签。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sinter user:<span class="number">1</span>:tags user:<span class="number">2</span>:tags</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述只是一种简单的标签，实际应用上可能会复杂很多。</p><blockquote><p> 集合类型一般有这几种应用场景：</p><ul><li>sadd = Tagging（标签）</li><li>spop/srandmember = Random item（队列）</li><li>sadd + sinter = Social Graph（社交需求）</li></ul></blockquote><hr><h2 id="2-6-有序集合"><a href="#2-6-有序集合" class="headerlink" title="2.6 有序集合"></a><strong>2.6 有序集合</strong></h2><p>&emsp;&emsp;有序集合，保留了<strong>元素不能重复</strong>的特性，但元素可以<strong>排序</strong>。和列表使用<strong>索引下标</strong>作为排序依据不同的是，有序集合通过给每个元素设置一个<strong>分数</strong>（score）作为排序依据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010129.jpg" alt=""></p><p>&emsp;&emsp;下图给出了列表、集合、有序集合的异同点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010130.jpg" alt=""></p><h3 id="2-6-1-命令"><a href="#2-6-1-命令" class="headerlink" title="2.6.1 命令"></a><strong>2.6.1 命令</strong></h3><p>&emsp;&emsp;1到11为集合内操作，12到13为集合间操作。</p><h4 id="1-添加成员"><a href="#1-添加成员" class="headerlink" title="(1) 添加成员"></a><strong>(1) 添加成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zadd key store member [store member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有序集合user:ranking中添加用户tom和分数251，返回表示成功个数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd user:ranking <span class="number">251</span> tom</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><blockquote><p> Redis 3.2版本为zadd命令添加了nx、xx、ch、incr四个选项：</p><ul><li><strong>nx</strong>：member必须不存在，才可以设置成功，用于添加。</li><li><strong>xx</strong>：member必须存在，才可以设置成功，用于更新。</li><li><strong>ch</strong>：返回此次操作后，有序集合元素和分数变化的个数。</li><li><strong>incr</strong>：对score做增加，相当于后面介绍的zincrby。</li></ul></blockquote><p>&emsp;&emsp;有序集合相比集合提供了排序字段，但是也产生了代价，zadd的时间复杂度为O(log(n))，sadd的时间复杂度为O(1)。</p><h4 id="2-计算成员个数"><a href="#2-计算成员个数" class="headerlink" title="(2) 计算成员个数"></a><strong>(2) 计算成员个数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br><span class="line"></span><br><span class="line"><span class="comment"># zcard和scard一样，时间复杂度为O(1)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcard user:ranking</span><br><span class="line">(integer) <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="3-计算某个成员分数"><a href="#3-计算某个成员分数" class="headerlink" title="(3) 计算某个成员分数"></a><strong>(3) 计算某个成员分数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存在返回分数，不存在返回nil</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zscore user:ranking tom</span><br><span class="line"><span class="string">"251"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zscore user:ranking test</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="4-计算成员的排名"><a href="#4-计算成员的排名" class="headerlink" title="(4) 计算成员的排名"></a><strong>(4) 计算成员的排名</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br><span class="line">zrevrank key member</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrank是分数从低到高返回排名，zrevrank则相反</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrank user:ranking tom</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrank user:ranking tom</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="5-删除成员"><a href="#5-删除成员" class="headerlink" title="(5) 删除成员"></a><strong>(5) 删除成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除集合中元素，返回表示成功个数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrem user:ranking mike</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="6-增加成员的分数"><a href="#6-增加成员的分数" class="headerlink" title="(6) 增加成员的分数"></a><strong>(6) 增加成员的分数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zincrby user:ranking <span class="number">9</span> tom</span><br><span class="line"><span class="string">"260"</span></span><br></pre></td></tr></table></figure><h4 id="7-返回指定排名范围内的成员"><a href="#7-返回指定排名范围内的成员" class="headerlink" title="(7) 返回指定排名范围内的成员"></a><strong>(7) 返回指定排名范围内的成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">zrange key start <span class="keyword">end</span> [withscores]</span><br><span class="line">zrevrange key start <span class="keyword">end</span> [withscores]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有序集合是按照分值排名的，zrange是从低到高返回，zrevrange则相反，withscores选项会同时返回分数。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange user:ranking <span class="number">0</span> <span class="number">2</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"kris"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"frank"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"200"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrange user:ranking <span class="number">0</span> <span class="number">2</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"260"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"250"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"220"</span></span><br></pre></td></tr></table></figure><h4 id="8-返回指定分数范围内的成员"><a href="#8-返回指定分数范围内的成员" class="headerlink" title="(8) 返回指定分数范围内的成员"></a><strong>(8) 返回指定分数范围内的成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [withscores] [limit offset count]</span><br><span class="line">zrevrangebyscore key min max [withscores] [limit offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrangebyscore按照分值从低到高返回，zrevrangebyscore则相反，withscores选项会同时返回分数，[limit offset count]可以限制输出的起始位置和个数。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrangebyscore user:ranking <span class="number">200</span> <span class="number">221</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"frank"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"200"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrevrangebyscore user:ranking <span class="number">200</span> <span class="number">221</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"frank"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"200"</span></span><br><span class="line"><span class="comment"># min和max还支持开区间（小括号）和闭区间（中括号），-inf和+inf分别代表无限小和无限大</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrangebyscore user:ranking (<span class="number">200</span> +inf withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"trim"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"250"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"260"</span></span><br></pre></td></tr></table></figure><h4 id="9-返回指定分数范围内的成员个数"><a href="#9-返回指定分数范围内的成员个数" class="headerlink" title="(9) 返回指定分数范围内的成员个数"></a><strong>(9) 返回指定分数范围内的成员个数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcount user:ranking <span class="number">221</span> <span class="number">200</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="10-删除指定排名内的升序元素"><a href="#10-删除指定排名内的升序元素" class="headerlink" title="(10) 删除指定排名内的升序元素"></a><strong>(10) 删除指定排名内的升序元素</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zremrangebyrank user:ranking <span class="number">0</span> <span class="number">2</span></span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="11-删除指定分数范围内的成员"><a href="#11-删除指定分数范围内的成员" class="headerlink" title="(11) 删除指定分数范围内的成员"></a><strong>(11) 删除指定分数范围内的成员</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zremrangebyscore user:ranking (<span class="number">250</span> +inf</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="12-交集"><a href="#12-交集" class="headerlink" title="(12) 交集"></a><strong>(12) 交集</strong></h4><blockquote><ul><li><strong>destination</strong>：交集计算结果保存到这个键。</li><li><strong>numkeys</strong>：需要做交集计算键的个数。</li><li><strong>key [key …]</strong>：需要做交集计算的键。</li><li><strong>weights weight [weight …]</strong>：每个键的权重，在做交集计算时，每个键中的每个member会将自己的分数乘以这个权重，默认为1。</li><li><strong>aggregate sum|min|max</strong>：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认为sum。</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;添加如图所示两个集合。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010131.jpg" alt=""></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd user:ranking:<span class="number">1</span> <span class="number">1</span> kris <span class="number">91</span> mike <span class="number">200</span> frank <span class="number">220</span> tim <span class="number">250</span> martin <span class="number">251</span> tom</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd user:ranking:<span class="number">2</span> <span class="number">8</span> james <span class="number">77</span> mike <span class="number">625</span> martin <span class="number">888</span> tom</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求两个集合的交集，weights和aggregate取默认值，分值做了sum操作</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zinterstore user:ranking:<span class="number">1</span>_inter_2 <span class="number">2</span> user:ranking:<span class="number">1</span> user:ranking:<span class="number">2</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange user:ranking:<span class="number">1</span>_inter_2 <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"168"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"875"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"1139"</span></span><br><span class="line"><span class="comment"># 配置权重，使集合2权重为集合1一半，并使聚合效果变为max</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zinterstore user:ranking:<span class="number">1</span>_inter_2 <span class="number">2</span> user:ranking:<span class="number">1</span> user:ranking:<span class="number">2</span> weights <span class="number">1</span> <span class="number">0.5</span> aggregate max</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange user:ranking:<span class="number">1</span>_inter_2 <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"91"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"312.5"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"444"</span></span><br></pre></td></tr></table></figure><h4 id="13-并集"><a href="#13-并集" class="headerlink" title="(13) 并集"></a><strong>(13) 并集</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zunionstore user:ranking:<span class="number">1</span>_union_2 <span class="number">2</span> user:ranking:<span class="number">1</span> user:ranking:<span class="number">2</span></span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange user:ranking:<span class="number">1</span>_inter_2 <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"kris"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"james"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"8"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"mike"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"168"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"frank"</span></span><br><span class="line"><span class="number">8</span>) <span class="string">"200"</span></span><br><span class="line"><span class="number">9</span>) <span class="string">"tim"</span></span><br><span class="line"><span class="number">10</span>) <span class="string">"220"</span></span><br><span class="line"><span class="number">11</span>) <span class="string">"martin"</span></span><br><span class="line"><span class="number">12</span>) <span class="string">"875"</span></span><br><span class="line"><span class="number">13</span>) <span class="string">"tom"</span></span><br><span class="line"><span class="number">14</span>) <span class="string">"1139"</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010132.jpg" alt=""></p><h3 id="2-6-2-内部编码"><a href="#2-6-2-内部编码" class="headerlink" title="2.6.2 内部编码"></a><strong>2.6.2 内部编码</strong></h3><blockquote><p>有序集合有两种内部编码：</p><ul><li><strong>ziplist</strong>（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时列表中每个元素的值都小于zset-max-ziplist-value配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li><li><strong>skiplist</strong>（跳跃表）：当无法满足ziplist的条件时，Redis选用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li></ul></blockquote><h3 id="2-6-3-使用场景"><a href="#2-6-3-使用场景" class="headerlink" title="2.6.3 使用场景"></a><strong>2.6.3 使用场景</strong></h3><p>&emsp;&emsp;有序集合比较常见的使用场景是<strong>排行榜系统</strong>。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能有多方面：时间、播放数量、获得的赞数。我们试着实现一个简单的赞数的维度。</p><h4 id="1-添加用户赞数"><a href="#1-添加用户赞数" class="headerlink" title="(1) 添加用户赞数"></a><strong>(1) 添加用户赞数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户mike上传了一个视频，并获得了3个赞</span></span><br><span class="line">zadd user:ranking:<span class="number">2016</span>_03_15 <span class="number">3</span> mike</span><br><span class="line"><span class="comment"># 又获得了一个赞</span></span><br><span class="line">zincrby user:ranking:<span class="number">2016</span>_03_15 <span class="number">1</span> mike</span><br></pre></td></tr></table></figure><h4 id="2-取消用户赞数"><a href="#2-取消用户赞数" class="headerlink" title="(2) 取消用户赞数"></a><strong>(2) 取消用户赞数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为如用户注销或用户作弊等原因需要将用户以及获得赞数删除</span></span><br><span class="line">zrem user:ranking:<span class="number">2016</span>_03_15 mike</span><br></pre></td></tr></table></figure><h4 id="3-展示获取赞数最多的十个用户"><a href="#3-展示获取赞数最多的十个用户" class="headerlink" title="(3) 展示获取赞数最多的十个用户"></a><strong>(3) 展示获取赞数最多的十个用户</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrangebyrank user:ranking:<span class="number">2016</span>_03_15 <span class="number">0</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="4-展示用户信息以及用户分数"><a href="#4-展示用户信息以及用户分数" class="headerlink" title="(4) 展示用户信息以及用户分数"></a><strong>(4) 展示用户信息以及用户分数</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将用户名作为键后缀，将用户信息保存在哈希类型中</span></span><br><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:<span class="number">2016</span>_03_15 mike</span><br><span class="line">zrank user:ranking:<span class="number">2016</span>_03_15 mike</span><br></pre></td></tr></table></figure><hr><h2 id="2-7-键管理"><a href="#2-7-键管理" class="headerlink" title="2.7 键管理"></a><strong>2.7 键管理</strong></h2><p>&emsp;&emsp;从单个键管理、遍历键、数据库管理三个维度来介绍一些通用命令。</p><h3 id="2-7-1-单个键管理"><a href="#2-7-1-单个键管理" class="headerlink" title="2.7.1 单个键管理"></a><strong>2.7.1 单个键管理</strong></h3><h4 id="1-键重命名"><a href="#1-键重命名" class="headerlink" title="(1) 键重命名"></a><strong>(1) 键重命名</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get python</span><br><span class="line"><span class="string">"jedis"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set python jedis</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename python java</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get python</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get java</span><br><span class="line"><span class="string">"jedis"</span></span><br><span class="line"><span class="comment"># 若rename之前，键java就已经存在，那么其值就会被覆盖</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set a b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set c d</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename a c</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get a</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get c</span><br><span class="line"><span class="string">"b"</span></span><br><span class="line"><span class="comment"># 为了防止误操作被强行rename，Redis提供了renamenx命令，确保只有newKey不存在时才能覆盖</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set java jedis</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set python redis-py</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; renamenx python java</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get java</span><br><span class="line"><span class="string">"jedis"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get python</span><br><span class="line"><span class="string">"redis-py"</span></span><br></pre></td></tr></table></figure><blockquote><p>使用重命名命令时需要注意：</p><ul><li><p>由于重命名键期间会执行del命令删除旧的键，如果键对应的值较大，会存在阻塞Redis的可能性。</p></li><li><p>如果rename和renamenx中的key和newkey是相同的，在Redis3.2版本之后和之前结果略有不同。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment"># 3.2</span></span><br><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename key key</span><br><span class="line">&gt;   OK</span><br><span class="line">&gt;   <span class="comment"># 3.2之前</span></span><br><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename key key</span><br><span class="line">&gt;   (error) ERR source and destination objects are the same</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="2-随机返回一个键"><a href="#2-随机返回一个键" class="headerlink" title="(2) 随机返回一个键"></a><strong>(2) 随机返回一个键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">randomkey</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; dbsize</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; randomkey</span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; randomkey</span><br><span class="line"><span class="string">"jedis"</span></span><br></pre></td></tr></table></figure><h4 id="3-键过期"><a href="#3-键过期" class="headerlink" title="(3) 键过期"></a><strong>(3) 键过期</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 键在seconds秒后过期</span></span><br><span class="line">expire key seconds</span><br><span class="line"><span class="comment"># 键在秒级时间戳timestamp后过期</span></span><br><span class="line">expireat key timestamp</span><br><span class="line"><span class="comment"># 键在milliseconds毫秒后过期</span></span><br><span class="line">pexpire key milliseconds</span><br><span class="line"><span class="comment"># 键在毫秒级时间戳timestamp后过期</span></span><br><span class="line">pexpireat key milliseconds-timestamp</span><br><span class="line"><span class="comment"># 查询键的剩余过期时间，返回值（大于等于0:表示剩余时间，-1:键没有设置过期时间，-2:键不存在）</span></span><br><span class="line">ttl key</span><br><span class="line"><span class="comment"># 查询键的剩余过期时间，毫秒级</span></span><br><span class="line">pttl key</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire hello <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="comment"># 还剩7秒</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">(integer) <span class="number">7</span></span><br><span class="line">...</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="comment"># 返回结果为-2，表示键已被删除</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">(integer) -<span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expireat hello <span class="number">1469980800</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不论是过期时间还是时间戳，秒级还是毫秒级，在Redis内部最终使用的都是pexpireat。</p><blockquote><p>使用过期命令需要注意以下几点：</p><ol><li><p>如果 expire key 的键不存在，返回结果为0。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire not_exist_key <span class="number">30</span></span><br><span class="line">&gt;    (integer) <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>如果过期时间为负值，键会立即被删除，犹如使用del命令一样。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">&gt;    OK</span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire hello -<span class="number">2</span></span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get hello</span><br><span class="line">&gt;    (nil)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>persist命令可以将键的过期时间清除。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset key f1 v1</span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire key <span class="number">50</span></span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl key</span><br><span class="line">&gt;    (integer) <span class="number">46</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; persist key</span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl key</span><br><span class="line">&gt;    (integer) -<span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p><strong>对于字符串类型键，执行set命令会去掉过期时间</strong>，这个问题在开发中很容易被忽视。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="comment">// set命令的函数setKey，可以看到最后执行了removeExpire(db, key)函数去掉了过期时间</span></span><br><span class="line">&gt;    <span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">if</span> (lookupKeyWrite(db, key) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;            dbAdd(db, key, val);</span><br><span class="line">&gt;        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;            dbOverwrite(db, key, val);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        incrRefCount(val);</span><br><span class="line">&gt;        <span class="comment">// 去掉过期时间</span></span><br><span class="line">&gt;        removeExpire(db, key);</span><br><span class="line">&gt;        signalModifiedKey(db, key);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote>   <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire hello <span class="number">50</span></span><br><span class="line">&gt;    (integer) <span class="number">1</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">&gt;    (integer) <span class="number">46</span></span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world</span><br><span class="line">&gt;    OK</span><br><span class="line">&gt;    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl hello</span><br><span class="line">&gt;    (integer) -<span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="5"><li><p>Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素做过期时间设置。</p></li><li><p>setex命令作为set + expire的组合，不但是原子执行，同时减少了一次网络通讯的时间。</p></li></ol></blockquote><h4 id="4-迁移键"><a href="#4-迁移键" class="headerlink" title="(4) 迁移键"></a><strong>(4) 迁移键</strong></h4><p>&emsp;&emsp;有时我们会想把部分数据由一个Redis转移到另一个Redis，Redis发展历程中提供了move、restore、migrate三组迁移键的方法。</p><h4 id="1-move"><a href="#1-move" class="headerlink" title="1) move"></a><strong>1) move</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;move指令用于Redis内部进行数据迁移，Redis内部可以有多个数据库，彼此数据是隔离的。move指令把指定的键从源数据库移动到目标数据库，但不建议在生产环境使用多数据库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010133.jpg" alt=""></p><h4 id="2-dump-restore"><a href="#2-dump-restore" class="headerlink" title="2) dump+restore"></a><strong>2) dump+restore</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dump key</span><br><span class="line">restore key ttl value</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;dump+restore可以实现在不同的Redis实例之间进行数据迁移的功能。</p><blockquote><p>整个迁移的过程分为两步：</p><ol><li>在源Redis上，dump命令会将键值序列化，格式采用的是RDB格式。</li><li>在目标Redis上，restore命令将上面序列化的值进行复原，其中ttl参数代表过期时间，如果ttl=0代表没有过期时间。</li></ol></blockquote><p>&emsp;&emsp;需要注意两点：第一，整个迁移过程并非原子性的，而是通过客户端分布完成的。第二，迁移过程是开启了两个客户端连接，所以dump的结果不是在源Redis和目标Redis之间进行传输。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010134.jpg" alt=""></p><blockquote><p>演示过程：</p><ol><li><p>在源Redis上执行dump。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    redis-source&gt; set hello world</span><br><span class="line">&gt;    OK</span><br><span class="line">&gt;    redis-source&gt; dump hello</span><br><span class="line">&gt;    <span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>在目标Redis上执行restore。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;    redis-target&gt; get hello</span><br><span class="line">&gt;    (nil)</span><br><span class="line">&gt;    redis-target&gt; restore hello <span class="number">0</span> <span class="string">"\x00\x05world\x06\x00\x8f&lt;T\x04%\xfcNQ"</span></span><br><span class="line">&gt;    OK</span><br><span class="line">&gt;    redis-target&gt; get hello</span><br><span class="line">&gt;    <span class="string">"world"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>   上面2步对应的伪代码如下。</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    Redis sourceRedis = <span class="keyword">new</span> Redis(<span class="string">"sourceMachine"</span>, <span class="number">6379</span>);</span><br><span class="line">&gt;    Redis targetRedis = <span class="keyword">new</span> Redis(<span class="string">"targetMachine"</span>, <span class="number">6379</span>);</span><br><span class="line">&gt;    targetRedis.restore(<span class="string">"hello"</span>, <span class="number">0</span>, sourceRedis.dump(key));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="3"><li><p>migrate</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    migrate host port key|<span class="string">""</span> destination-db timeout [copy] [replace] [keys key [key ...]]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>   migrate命令也是用于在Redis实例间进行数据迁移的，实际上migrate命令就是将dump、restore、del三个命令进行组合，从而简化了操作流程。migrate命令具有原子性，而且从Redis 3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁移效率，migrate在水平扩容中起到重要作用。</p></blockquote><p>&emsp;&emsp;如图所示，实现过程和dump+restore基本类似，但有三点不同。</p><blockquote><ol><li>整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis上执行migrate命令即可。</li><li>migrate命令的数据传输直接在源Redis和目标Redis上完成的。</li><li>目标Redis完成restore后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否在源Redis上删除对应的键。</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010135.jpg" alt=""></p><blockquote><p>migrate参数说明：</p><ul><li><strong>host</strong>：目标Redis的IP地址。</li><li><strong>port</strong>：目标Redis的端口。</li><li><strong>key|“”</strong>：在Redis 3.0.6版本之前，migrate只支持迁移一个键，所以此处是要迁移的键，但Redis 3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串””。</li><li><strong>destination-db</strong>：目标Redis的数据库索引，例如要迁移到0号数据库，这里就写0。</li><li><strong>timeout</strong>：迁移的超时时间（单位为毫秒）。</li><li><strong>[copy]</strong>：如果添加此选项，迁移后并不删除源键。</li><li><strong>[replace]</strong>：如果添加此选项，migrate不管目标Redis是否存在该键都会正常迁移进行数据覆盖。</li><li><strong>[keys key [key …]]</strong>：迁移多个键。</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源Redis使用6379端口，目标Redis使用6380端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况1：源Redis有键hello，目标Redis没有</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> hello <span class="number">0</span> <span class="number">1000</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 情况2：源Redis和目标Reids都有键hello，需要加replace选项</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get hello</span><br><span class="line"><span class="string">"world"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6380</span>&gt; get hello</span><br><span class="line"><span class="string">"redis"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> hello <span class="number">0</span> <span class="number">1000</span></span><br><span class="line">(error) ERR Target instance replied with error: BUSYKEY Target key name already exists.</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> hello <span class="number">0</span> <span class="number">1000</span> replace</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 情况3：源Redis没有键hello</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> hello <span class="number">0</span> <span class="number">1000</span></span><br><span class="line">NOKEY</span><br></pre></td></tr></table></figure><blockquote><p>Redis 3.0.6版本以后迁移多个键的功能：</p><ul><li><p>源Redis批量添加多个键</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mset key1 value1 key2 value2 key3 value3</span><br><span class="line">&gt;   OK</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>源Redis执行如下命令完成多个键的迁移</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; migrate <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6380</span> <span class="string">""</span> <span class="number">0</span> <span class="number">5000</span> keys key1 key2 key3</span><br><span class="line">&gt;   OK</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010136.jpg" alt=""></p><h3 id="2-7-2-遍历键"><a href="#2-7-2-遍历键" class="headerlink" title="2.7.2 遍历键"></a><strong>2.7.2 遍历键</strong></h3><h4 id="1-全量遍历键"><a href="#1-全量遍历键" class="headerlink" title="(1) 全量遍历键"></a><strong>(1) 全量遍历键</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; dbsize</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mset hello world redis best jedis best hill high</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 获取所有键</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">"hill"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"jedis"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><blockquote><p>pattern使用glob风格的通配符：</p><ul><li>* ：代表匹配任意字符。</li><li>? ：代表匹配一个字符。 </li><li>[] ：代表匹配部分字符，如[1, 3]代表匹配1和3，[1-10]代表匹配1到10的任意数字。</li><li>\x ：用来做转移，例如要匹配星号、问号需要进行转义。</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys [j,r]edis</span><br><span class="line"><span class="number">1</span>) <span class="string">"jedis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redis"</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys h?ll*</span><br><span class="line"><span class="number">1</span>) <span class="string">"hill"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当需要遍历所有键时（如检测过期或闲置时间、寻找大对象），keys是一个很有帮助的命令，例如想删除所有以video字符串开头的键，可以如下操作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli keys video* | xargs redis-cli del</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但Redis是单线程架构，如果对大量的键执行keys命令很可能会造成Redis阻塞，所以一般不建议在生产环境下使用keys命令。</p><blockquote><p>生产环境下代替方案：</p><ul><li>在一个不对外提供服务的Redis从节点上执行，这样不会阻塞到客户端的请求，但会影响到主从复制。</li><li>如果确认键值总数确实比较少，可以执行此命令。</li><li>使用scan命令渐进式的遍历所有键，可以有效防止阻塞。</li></ul></blockquote><h4 id="2-渐进式遍历"><a href="#2-渐进式遍历" class="headerlink" title="(2) 渐进式遍历"></a><strong>(2) 渐进式遍历</strong></h4><p>&emsp;&emsp;Redis 2.8版本后，提供了一个新的命令<strong>scan</strong>，有效的解决了keys命令存在的问题。<strong>与keys命令遍历所有键的方式不同，scan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题</strong>，scan命令的时间复杂度为O(1)，但要真正的实现keys的功能，需要多次执行scan。Redis存储键值对实际使用的是hashtable的数据结构，简化模型如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010137.jpg" alt=""></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次执行scan，可以想象成只扫描一个字典中的一部分键，知道将字典中的所有键遍历完毕</span></span><br><span class="line">scan cursor [match pattern] [count number]</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>cursor</strong>：必须参数，实际上cursor是一个游标，第一次遍历从0开始，每次scan遍历完都返回当前游标的值，直到游标值为0，表示遍历结束。</li><li><strong>match pattern</strong>：可选参数，它的作用是做模式的匹配，这点和keys的模式匹配很像。</li><li><strong>count number</strong>：可选参数，它的作用是表明每次要遍历的键个数，默认值是10，此参数可以适当增大。</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现有一个Redis有26个键，遍历所有的键，第一次执行返回两个部分，第一部分的6就是下次scan需要的cursor，第二部分是10个键。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scan <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"6"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"w"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"i"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"e"</span></span><br><span class="line">   <span class="number">4</span>) <span class="string">"x"</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">"j"</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">"q"</span></span><br><span class="line">   <span class="number">7</span>) <span class="string">"y"</span></span><br><span class="line">   <span class="number">8</span>) <span class="string">"u"</span></span><br><span class="line">   <span class="number">9</span>) <span class="string">"b"</span></span><br><span class="line">   <span class="number">10</span>) <span class="string">"o"</span></span><br><span class="line"><span class="comment"># 使用新的cursor="6"，执行scan 6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scan <span class="number">6</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"11"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"h"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"n"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"m"</span></span><br><span class="line">   <span class="number">4</span>) <span class="string">"t"</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">"c"</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">"d"</span></span><br><span class="line">   <span class="number">7</span>) <span class="string">"g"</span></span><br><span class="line">   <span class="number">8</span>) <span class="string">"p"</span></span><br><span class="line">   <span class="number">9</span>) <span class="string">"z"</span></span><br><span class="line">   <span class="number">10</span>) <span class="string">"a"</span></span><br><span class="line"><span class="comment"># 这次得到的11，继续执行scan 11得到结果cursor为0，说明所有的键都被遍历过了</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scan <span class="number">11</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"0"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"s"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"f"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"r"</span></span><br><span class="line">   <span class="number">4</span>) <span class="string">"v"</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">"k"</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">"l"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了scan以外，Redis还提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决如hgetall、smembers、zrange可能产生的阻塞问题，对应的命令分别为hscan、sscan、zscan。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前集合有两种类型的元素，分别以old:user和new:user开头</span></span><br><span class="line">String key = <span class="string">"myset"</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">String pattern = <span class="string">"old:user"</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">String cursor = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       ScanResult scanResult = redis.sscan(key, cursor, pattern);</span><br><span class="line">       List elements = scanResult.getResult();</span><br><span class="line">       <span class="keyword">if</span> (elements != <span class="keyword">null</span> &amp;&amp; elements.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           redis.rem(key, elements);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       cursor = scanResult.getStringCursor();</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">"0"</span>.equals(cursor)) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;渐进式遍历可以有效的解决相应命令的阻塞问题，但scan并非完美，如果在遍历的过程中出现键的变化（增删改），遍历效果就可能会遇到：新增的键没被遍历到，遍历出重复的键等情况。即<strong>scan并不能保证完整的遍历出来所有的键</strong>。</p><h3 id="2-7-3-数据库管理"><a href="#2-7-3-数据库管理" class="headerlink" title="2.7.3 数据库管理"></a><strong>2.7.3 数据库管理</strong></h3><h4 id="1-切换数据库"><a href="#1-切换数据库" class="headerlink" title="(1) 切换数据库"></a><strong>(1) 切换数据库</strong></h4><p>&emsp;&emsp;许多关系型数据库支持一个实例下有多个数据库存在，与关系型数据库用字符来区分不同数据库名相比，Redis使用数字作为多个数据库的实现，默认是16个数据库。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select dbIndex</span><br><span class="line">database <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; set hello world <span class="comment"># 默认进到0号数据库</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get hello</span><br><span class="line"><span class="string">"world"</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; select <span class="number">15</span> <span class="comment"># 切换到15号数据库</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>[<span class="number">15</span>]&gt; get hello <span class="comment"># 数据库间是隔离的</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述过程如图所示，还有当使用 redis-cli -h {ip} -p {port} 链接Redis时，默认也是0号数据库，其他数据库会显示index下标。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010138.jpg" alt=""></p><p>&emsp;&emsp;那么可以像关系型数据库那样，0号数据库作为正式库，1号数据库作为测试库，这样二者的数据也不会互相影响呢？Redis 3.0开始慢慢的在淡化此功能，例如Redis的分布式实现<strong>Redis Cluster只允许使用0号数据库</strong>，只是为了向下兼容老版本才没有完全废弃此功能。</p><blockquote><p>废弃这个功能的原因有三点：</p><ul><li>Redis是单线程的，如果使用多个数据库，这些库仍然只使用一个CPU，还是会影响到彼此的。</li><li>多数据库的使用方式，会让调试和运维不同业务的数据库变得困难。假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定位问题变得困难。</li><li>部分Redis客户端不支持这种方式，即使支持，在开发时来回切换数字形式的数据库也容易混乱。</li></ul></blockquote><p>&emsp;&emsp;所以一般建议在一台机器上部署多个Redis来实现，以端口号来区分，这样既保证了业务之间不会受影响，有利用了多核CPU的资源。</p><h4 id="2-清除数据库"><a href="#2-清除数据库" class="headerlink" title="(2) 清除数据库"></a><strong>(2) 清除数据库</strong></h4><p>&emsp;&emsp;flushdb/flushall命令用于清除数据库，区别是flushdb只清除当前数据库，flushall会清除所有数据库。</p><blockquote><p>flushdb/flushall命令存在的问题：</p><ul><li>flushdb/flushall命令会将所有的数据清除，一旦误操作很难处理。</li><li>如果当前数据库键值比较多，flushdb/flushall命令存在阻塞Redis的可能性。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（二）API介绍，内容包括：准备，字符串，哈希，列表，集合，有序集合，键管理等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建个人博客 (六) 异常解决记录</title>
    <link href="http://linyishui.top/2020040301.html"/>
    <id>http://linyishui.top/2020040301.html</id>
    <published>2020-04-03T02:31:00.000Z</published>
    <updated>2020-04-23T01:51:23.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo异常解决记录"><a href="#Hexo异常解决记录" class="headerlink" title="Hexo异常解决记录"></a><strong>Hexo异常解决记录</strong></h1><h2 id="unknown-block-tag-endif"><a href="#unknown-block-tag-endif" class="headerlink" title="unknown block tag: endif"></a><strong>unknown block tag: endif</strong></h2><p>&emsp;&emsp;一次更新博客（hexo g）时，出现以下异常。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010101.png" alt=""></p><p>&emsp;&emsp;google了一下，看到有类似问题的是因为在’{‘和’%’之间多写了空格这种语法错误，所以花了一些时间去找项目中的swig文件，因为刚好这次更新也有增加一些博客功能，怀疑是不是修改swig文件时也写错了。(<a href="https://52heartz.top/articles/hexo-template-render-error/" title="title" target="_blank" rel="noopener">Hexo 的 Template render error 错误</a> 和 <a href="https://github.com/hexojs/hexo/issues/3346" title="title" target="_blank" rel="noopener">hexo 在markdown文档中出现<code>{-% %-}</code>语法会报错，提示“Template render error: (unknown path) </a>)</p><p>&emsp;&emsp;但很快便发现没有找到异常，所以思考了一下，既然代码文件中的endif没有问题，会不会是其他地方也写了endif，突然想到这次提交也更新了MD文件，记录我这次更新，其中也直接记录了{\% endif \%}，所以就修改了相关描述。</p><p>&emsp;&emsp;重试了一下，问题解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://linyishui.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://linyishui.top/tags/hexo/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十四）Redis配置统计字典（未完成）</title>
    <link href="http://linyishui.top/2020032801.html"/>
    <id>http://linyishui.top/2020032801.html</id>
    <published>2020-03-28T08:26:47.000Z</published>
    <updated>2020-04-22T09:26:26.871Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十四章-Redis配置统计字典"><a href="#第十四章-Redis配置统计字典" class="headerlink" title="第十四章 Redis配置统计字典"></a><strong>第十四章 Redis配置统计字典</strong></h1><h2 id="14-1-info系统状态说明"><a href="#14-1-info系统状态说明" class="headerlink" title="14.1 info系统状态说明"></a><strong>14.1 info系统状态说明</strong></h2><h3 id="14-1-1-命令说明"><a href="#14-1-1-命令说明" class="headerlink" title="14.1.1 命令说明"></a><strong>14.1.1 命令说明</strong></h3><h3 id="14-1-2-详细说明"><a href="#14-1-2-详细说明" class="headerlink" title="14.1.2 详细说明"></a><strong>14.1.2 详细说明</strong></h3><hr><h2 id="14-2-standalone配置说明和分析"><a href="#14-2-standalone配置说明和分析" class="headerlink" title="14.2 standalone配置说明和分析"></a><strong>14.2 standalone配置说明和分析</strong></h2><h3 id="14-2-1-总体配置"><a href="#14-2-1-总体配置" class="headerlink" title="14.2.1 总体配置"></a><strong>14.2.1 总体配置</strong></h3><h3 id="14-2-2-最大内存及策略"><a href="#14-2-2-最大内存及策略" class="headerlink" title="14.2.2 最大内存及策略"></a><strong>14.2.2 最大内存及策略</strong></h3><h3 id="14-2-3-AOF相关配置"><a href="#14-2-3-AOF相关配置" class="headerlink" title="14.2.3 AOF相关配置"></a><strong>14.2.3 AOF相关配置</strong></h3><h3 id="14-2-4-RDB相关配置"><a href="#14-2-4-RDB相关配置" class="headerlink" title="14.2.4 RDB相关配置"></a><strong>14.2.4 RDB相关配置</strong></h3><h3 id="14-2-5-慢查询配置"><a href="#14-2-5-慢查询配置" class="headerlink" title="14.2.5 慢查询配置"></a><strong>14.2.5 慢查询配置</strong></h3><h3 id="14-2-6-数据结构优化配置"><a href="#14-2-6-数据结构优化配置" class="headerlink" title="14.2.6 数据结构优化配置"></a><strong>14.2.6 数据结构优化配置</strong></h3><h3 id="14-2-7-复制相关配置"><a href="#14-2-7-复制相关配置" class="headerlink" title="14.2.7 复制相关配置"></a><strong>14.2.7 复制相关配置</strong></h3><h3 id="14-2-8-客户端相关配置"><a href="#14-2-8-客户端相关配置" class="headerlink" title="14.2.8 客户端相关配置"></a><strong>14.2.8 客户端相关配置</strong></h3><h3 id="14-2-9-安全相关配置"><a href="#14-2-9-安全相关配置" class="headerlink" title="14.2.9 安全相关配置"></a><strong>14.2.9 安全相关配置</strong></h3><hr><h2 id="14-3-Sentinel配置说明和分析"><a href="#14-3-Sentinel配置说明和分析" class="headerlink" title="14.3 Sentinel配置说明和分析"></a><strong>14.3 Sentinel配置说明和分析</strong></h2><hr><h2 id="14-4-Cluster配置说明和分析"><a href="#14-4-Cluster配置说明和分析" class="headerlink" title="14.4 Cluster配置说明和分析"></a><strong>14.4 Cluster配置说明和分析</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十四）Redis配置统计字典，内容包括：info系统状态说明（命令说明，详细说明），standalone配置说明和分析（总体配置、最大内存及策略、AOF相关配置、RDB相关配置、慢查询配置、数据结构优化配置、复制相关配置、客户端相关配置、安全相关配置），Sentinel配置说明和分析，Cluster配置说明和分析等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十三）Redis监控运维云平台-CacheCloud（未完成）</title>
    <link href="http://linyishui.top/2020032501.html"/>
    <id>http://linyishui.top/2020032501.html</id>
    <published>2020-03-25T08:26:40.000Z</published>
    <updated>2020-04-22T09:21:52.485Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十三章-Redis监控运维云平台-CacheCloud"><a href="#第十三章-Redis监控运维云平台-CacheCloud" class="headerlink" title="第十三章 Redis监控运维云平台-CacheCloud"></a><strong>第十三章 Redis监控运维云平台-CacheCloud</strong></h1><h2 id="13-1-CacheCloud是什么"><a href="#13-1-CacheCloud是什么" class="headerlink" title="13.1 CacheCloud是什么"></a><strong>13.1 CacheCloud是什么</strong></h2><h3 id="13-1-1-现有问题"><a href="#13-1-1-现有问题" class="headerlink" title="13.1.1 现有问题"></a><strong>13.1.1 现有问题</strong></h3><h3 id="13-1-2-CacheCloud基本功能"><a href="#13-1-2-CacheCloud基本功能" class="headerlink" title="13.1.2 CacheCloud基本功能"></a><strong>13.1.2 CacheCloud基本功能</strong></h3><hr><h2 id="13-2-快速部署"><a href="#13-2-快速部署" class="headerlink" title="13.2 快速部署"></a><strong>13.2 快速部署</strong></h2><h3 id="13-2-1-CacheCloud环境需求"><a href="#13-2-1-CacheCloud环境需求" class="headerlink" title="13.2.1 CacheCloud环境需求"></a><strong>13.2.1 CacheCloud环境需求</strong></h3><h3 id="13-2-2-CacheCloud快速开始"><a href="#13-2-2-CacheCloud快速开始" class="headerlink" title="13.2.2 CacheCloud快速开始"></a><strong>13.2.2 CacheCloud快速开始</strong></h3><hr><h2 id="13-3-机器部署"><a href="#13-3-机器部署" class="headerlink" title="13.3 机器部署"></a><strong>13.3 机器部署</strong></h2><h3 id="13-3-1-部署脚本"><a href="#13-3-1-部署脚本" class="headerlink" title="13.3.1 部署脚本"></a><strong>13.3.1 部署脚本</strong></h3><h3 id="13-3-2-添加机器"><a href="#13-3-2-添加机器" class="headerlink" title="13.3.2 添加机器"></a><strong>13.3.2 添加机器</strong></h3><hr><h2 id="13-4-接入应用"><a href="#13-4-接入应用" class="headerlink" title="13.4 接入应用"></a><strong>13.4 接入应用</strong></h2><h3 id="13-4-1-总体流程"><a href="#13-4-1-总体流程" class="headerlink" title="13.4.1 总体流程"></a><strong>13.4.1 总体流程</strong></h3><h3 id="13-4-2-账户申请和审批"><a href="#13-4-2-账户申请和审批" class="headerlink" title="13.4.2 账户申请和审批"></a><strong>13.4.2 账户申请和审批</strong></h3><h3 id="13-4-3-应用申请和审批"><a href="#13-4-3-应用申请和审批" class="headerlink" title="13.4.3 应用申请和审批"></a><strong>13.4.3 应用申请和审批</strong></h3><h3 id="13-4-4-客户端接入"><a href="#13-4-4-客户端接入" class="headerlink" title="13.4.4 客户端接入"></a><strong>13.4.4 客户端接入</strong></h3><hr><h2 id="13-5-用户功能"><a href="#13-5-用户功能" class="headerlink" title="13.5 用户功能"></a><strong>13.5 用户功能</strong></h2><h3 id="13-5-1-应用统计信息"><a href="#13-5-1-应用统计信息" class="headerlink" title="13.5.1 应用统计信息"></a><strong>13.5.1 应用统计信息</strong></h3><h3 id="13-5-2-实例列表"><a href="#13-5-2-实例列表" class="headerlink" title="13.5.2 实例列表"></a><strong>13.5.2 实例列表</strong></h3><h3 id="13-5-3-应用详情"><a href="#13-5-3-应用详情" class="headerlink" title="13.5.3 应用详情"></a><strong>13.5.3 应用详情</strong></h3><h3 id="13-5-4-命令曲线"><a href="#13-5-4-命令曲线" class="headerlink" title="13.5.4 命令曲线"></a><strong>13.5.4 命令曲线</strong></h3><h3 id="13-5-5-CacheCloud-Redis-Shell-控制台"><a href="#13-5-5-CacheCloud-Redis-Shell-控制台" class="headerlink" title="13.5.5 CacheCloud Redis Shell 控制台"></a><strong>13.5.5 CacheCloud Redis Shell 控制台</strong></h3><h3 id="13-5-6-慢查询"><a href="#13-5-6-慢查询" class="headerlink" title="13.5.6 慢查询"></a><strong>13.5.6 慢查询</strong></h3><h3 id="13-5-7-应用拓扑"><a href="#13-5-7-应用拓扑" class="headerlink" title="13.5.7 应用拓扑"></a><strong>13.5.7 应用拓扑</strong></h3><hr><h2 id="13-6-运维功能"><a href="#13-6-运维功能" class="headerlink" title="13.6 运维功能"></a><strong>13.6 运维功能</strong></h2><h3 id="13-6-1-应用运维"><a href="#13-6-1-应用运维" class="headerlink" title="13.6.1 应用运维"></a><strong>13.6.1 应用运维</strong></h3><h3 id="13-6-2-接入已存在的Redis节点"><a href="#13-6-2-接入已存在的Redis节点" class="headerlink" title="13.6.2 接入已存在的Redis节点"></a><strong>13.6.2 接入已存在的Redis节点</strong></h3><h3 id="13-6-3-Redis配置模板"><a href="#13-6-3-Redis配置模板" class="headerlink" title="13.6.3 Redis配置模板"></a><strong>13.6.3 Redis配置模板</strong></h3><h3 id="13-6-4-迁移工具"><a href="#13-6-4-迁移工具" class="headerlink" title="13.6.4 迁移工具"></a><strong>13.6.4 迁移工具</strong></h3><h3 id="13-6-5-监控报警"><a href="#13-6-5-监控报警" class="headerlink" title="13.6.5 监控报警"></a><strong>13.6.5 监控报警</strong></h3><h3 id="13-6-6-系统配置管理"><a href="#13-6-6-系统配置管理" class="headerlink" title="13.6.6 系统配置管理"></a><strong>13.6.6 系统配置管理</strong></h3><hr><h2 id="13-7-客户端上报"><a href="#13-7-客户端上报" class="headerlink" title="13.7 客户端上报"></a><strong>13.7 客户端上报</strong></h2><h3 id="13-7-1-客户端上报整体设计"><a href="#13-7-1-客户端上报整体设计" class="headerlink" title="13.7.1 客户端上报整体设计"></a><strong>13.7.1 客户端上报整体设计</strong></h3><h3 id="13-7-2-Jedis核心代码修改"><a href="#13-7-2-Jedis核心代码修改" class="headerlink" title="13.7.2 Jedis核心代码修改"></a><strong>13.7.2 Jedis核心代码修改</strong></h3><h3 id="13-7-3-带上报功能的客户端"><a href="#13-7-3-带上报功能的客户端" class="headerlink" title="13.7.3 带上报功能的客户端"></a><strong>13.7.3 带上报功能的客户端</strong></h3><h3 id="13-7-4-CacheCloud客户端设计"><a href="#13-7-4-CacheCloud客户端设计" class="headerlink" title="13.7.4 CacheCloud客户端设计"></a><strong>13.7.4 CacheCloud客户端设计</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十三）Redis监控运维云平台-CacheCloud，内容包括：CacheCloud是什么，快速部署，机器部署，接入应用，用户功能，运维功能，客户端上报等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十二）开发运维的“陷阱”（未完成）</title>
    <link href="http://linyishui.top/2020032401.html"/>
    <id>http://linyishui.top/2020032401.html</id>
    <published>2020-03-24T08:26:34.000Z</published>
    <updated>2020-04-22T09:14:21.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十二章-开发运维的“陷阱”"><a href="#第十二章-开发运维的“陷阱”" class="headerlink" title="第十二章 开发运维的“陷阱”"></a><strong>第十二章 开发运维的“陷阱”</strong></h1><h2 id="12-1-Linux配置优化"><a href="#12-1-Linux配置优化" class="headerlink" title="12.1 Linux配置优化"></a><strong>12.1 Linux配置优化</strong></h2><h3 id="12-1-1-内存分配控制"><a href="#12-1-1-内存分配控制" class="headerlink" title="12.1.1 内存分配控制"></a><strong>12.1.1 内存分配控制</strong></h3><h3 id="12-1-2-swappiness"><a href="#12-1-2-swappiness" class="headerlink" title="12.1.2 swappiness"></a><strong>12.1.2 swappiness</strong></h3><h3 id="12-1-3-THP"><a href="#12-1-3-THP" class="headerlink" title="12.1.3 THP"></a><strong>12.1.3 THP</strong></h3><h3 id="12-1-4-OOM-killer"><a href="#12-1-4-OOM-killer" class="headerlink" title="12.1.4 OOM killer"></a><strong>12.1.4 OOM killer</strong></h3><h3 id="12-1-5-使用NTP"><a href="#12-1-5-使用NTP" class="headerlink" title="12.1.5 使用NTP"></a><strong>12.1.5 使用NTP</strong></h3><h3 id="12-1-6-ulimit"><a href="#12-1-6-ulimit" class="headerlink" title="12.1.6 ulimit"></a><strong>12.1.6 ulimit</strong></h3><h3 id="12-1-7-TCP-backlog"><a href="#12-1-7-TCP-backlog" class="headerlink" title="12.1.7 TCP backlog"></a><strong>12.1.7 TCP backlog</strong></h3><hr><h2 id="12-2-flushall-flushdb误操作"><a href="#12-2-flushall-flushdb误操作" class="headerlink" title="12.2 flushall/flushdb误操作"></a><strong>12.2 flushall/flushdb误操作</strong></h2><h3 id="12-2-1-缓存与存储"><a href="#12-2-1-缓存与存储" class="headerlink" title="12.2.1 缓存与存储"></a><strong>12.2.1 缓存与存储</strong></h3><h3 id="12-2-2-借助AOF机制恢复"><a href="#12-2-2-借助AOF机制恢复" class="headerlink" title="12.2.2 借助AOF机制恢复"></a><strong>12.2.2 借助AOF机制恢复</strong></h3><h3 id="12-2-3-RDB有什么变化"><a href="#12-2-3-RDB有什么变化" class="headerlink" title="12.2.3 RDB有什么变化"></a><strong>12.2.3 RDB有什么变化</strong></h3><h3 id="12-2-4-从节点有什么变化"><a href="#12-2-4-从节点有什么变化" class="headerlink" title="12.2.4 从节点有什么变化"></a><strong>12.2.4 从节点有什么变化</strong></h3><h3 id="12-2-5-快速恢复数据"><a href="#12-2-5-快速恢复数据" class="headerlink" title="12.2.5 快速恢复数据"></a><strong>12.2.5 快速恢复数据</strong></h3><hr><h2 id="12-3-安全的Redis"><a href="#12-3-安全的Redis" class="headerlink" title="12.3 安全的Redis"></a><strong>12.3 安全的Redis</strong></h2><h3 id="12-3-1-Redis密码机制"><a href="#12-3-1-Redis密码机制" class="headerlink" title="12.3.1 Redis密码机制"></a><strong>12.3.1 Redis密码机制</strong></h3><h3 id="12-3-2-伪装危险命令"><a href="#12-3-2-伪装危险命令" class="headerlink" title="12.3.2 伪装危险命令"></a><strong>12.3.2 伪装危险命令</strong></h3><h3 id="12-3-3-防火墙"><a href="#12-3-3-防火墙" class="headerlink" title="12.3.3 防火墙"></a><strong>12.3.3 防火墙</strong></h3><h3 id="12-3-4-bind"><a href="#12-3-4-bind" class="headerlink" title="12.3.4 bind"></a><strong>12.3.4 bind</strong></h3><h3 id="12-3-5-定期备份数据"><a href="#12-3-5-定期备份数据" class="headerlink" title="12.3.5 定期备份数据"></a><strong>12.3.5 定期备份数据</strong></h3><h3 id="12-3-6-不使用默认端口"><a href="#12-3-6-不使用默认端口" class="headerlink" title="12.3.6 不使用默认端口"></a><strong>12.3.6 不使用默认端口</strong></h3><h3 id="12-3-7-使用非root用户启动"><a href="#12-3-7-使用非root用户启动" class="headerlink" title="12.3.7 使用非root用户启动"></a><strong>12.3.7 使用非root用户启动</strong></h3><hr><h2 id="12-4-处理bigkey"><a href="#12-4-处理bigkey" class="headerlink" title="12.4 处理bigkey"></a><strong>12.4 处理bigkey</strong></h2><h3 id="12-4-1-bigkey的危害"><a href="#12-4-1-bigkey的危害" class="headerlink" title="12.4.1 bigkey的危害"></a><strong>12.4.1 bigkey的危害</strong></h3><h3 id="12-4-2-如何发现"><a href="#12-4-2-如何发现" class="headerlink" title="12.4.2 如何发现"></a><strong>12.4.2 如何发现</strong></h3><h3 id="12-4-3-如何删除"><a href="#12-4-3-如何删除" class="headerlink" title="12.4.3 如何删除"></a><strong>12.4.3 如何删除</strong></h3><h3 id="12-4-4-最佳实践思路"><a href="#12-4-4-最佳实践思路" class="headerlink" title="12.4.4 最佳实践思路"></a><strong>12.4.4 最佳实践思路</strong></h3><hr><h2 id="12-5-寻找热点key"><a href="#12-5-寻找热点key" class="headerlink" title="12.5 寻找热点key"></a><strong>12.5 寻找热点key</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十二）开发运维的“陷阱”，内容包括：Linux配置优化，flushall/flushdb误操作，安全的Redis，处理bigkey，寻找热点key等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十一）缓存设计（未完成）</title>
    <link href="http://linyishui.top/2020032101.html"/>
    <id>http://linyishui.top/2020032101.html</id>
    <published>2020-03-21T08:26:28.000Z</published>
    <updated>2020-04-22T09:08:08.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十一章-缓存设计"><a href="#第十一章-缓存设计" class="headerlink" title="第十一章 缓存设计"></a><strong>第十一章 缓存设计</strong></h1><h2 id="11-1-缓存的收益与成本"><a href="#11-1-缓存的收益与成本" class="headerlink" title="11.1 缓存的收益与成本"></a><strong>11.1 缓存的收益与成本</strong></h2><hr><h2 id="11-2-缓存更新策略"><a href="#11-2-缓存更新策略" class="headerlink" title="11.2 缓存更新策略"></a><strong>11.2 缓存更新策略</strong></h2><hr><h2 id="11-3-缓存粒度控制"><a href="#11-3-缓存粒度控制" class="headerlink" title="11.3 缓存粒度控制"></a><strong>11.3 缓存粒度控制</strong></h2><hr><h2 id="11-4-穿透优化"><a href="#11-4-穿透优化" class="headerlink" title="11.4 穿透优化"></a><strong>11.4 穿透优化</strong></h2><hr><h2 id="11-5-无底洞优化"><a href="#11-5-无底洞优化" class="headerlink" title="11.5 无底洞优化"></a><strong>11.5 无底洞优化</strong></h2><hr><h2 id="11-6-雪崩优化"><a href="#11-6-雪崩优化" class="headerlink" title="11.6 雪崩优化"></a><strong>11.6 雪崩优化</strong></h2><hr><h2 id="11-7-热点key重建优化"><a href="#11-7-热点key重建优化" class="headerlink" title="11.7 热点key重建优化"></a><strong>11.7 热点key重建优化</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十一）缓存设计，内容包括：缓存的收益与成本，缓存更新策略，缓存粒度控制，穿透优化，无底洞优化，雪崩优化，热点key重建优化等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（十）集群（未完成）</title>
    <link href="http://linyishui.top/2020031801.html"/>
    <id>http://linyishui.top/2020031801.html</id>
    <published>2020-03-18T08:26:19.000Z</published>
    <updated>2020-04-22T09:05:11.539Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十章-集群"><a href="#第十章-集群" class="headerlink" title="第十章 集群"></a><strong>第十章 集群</strong></h1><h2 id="10-1-数据分布"><a href="#10-1-数据分布" class="headerlink" title="10.1 数据分布"></a><strong>10.1 数据分布</strong></h2><h3 id="10-1-1-数据分布理论"><a href="#10-1-1-数据分布理论" class="headerlink" title="10.1.1 数据分布理论"></a><strong>10.1.1 数据分布理论</strong></h3><h3 id="10-1-2-Redis数据分区"><a href="#10-1-2-Redis数据分区" class="headerlink" title="10.1.2 Redis数据分区"></a><strong>10.1.2 Redis数据分区</strong></h3><h3 id="10-1-3-集群功能限制"><a href="#10-1-3-集群功能限制" class="headerlink" title="10.1.3 集群功能限制"></a><strong>10.1.3 集群功能限制</strong></h3><hr><h2 id="10-2-搭建集群"><a href="#10-2-搭建集群" class="headerlink" title="10.2 搭建集群"></a><strong>10.2 搭建集群</strong></h2><h3 id="10-2-1-准备节点"><a href="#10-2-1-准备节点" class="headerlink" title="10.2.1 准备节点"></a><strong>10.2.1 准备节点</strong></h3><h3 id="10-2-2-节点握手"><a href="#10-2-2-节点握手" class="headerlink" title="10.2.2 节点握手"></a><strong>10.2.2 节点握手</strong></h3><h3 id="10-2-3-分配槽"><a href="#10-2-3-分配槽" class="headerlink" title="10.2.3 分配槽"></a><strong>10.2.3 分配槽</strong></h3><h3 id="10-2-4-用redis-trib-rb搭建集群"><a href="#10-2-4-用redis-trib-rb搭建集群" class="headerlink" title="10.2.4 用redis-trib.rb搭建集群"></a><strong>10.2.4 用redis-trib.rb搭建集群</strong></h3><hr><h2 id="10-3-节点通信"><a href="#10-3-节点通信" class="headerlink" title="10.3 节点通信"></a><strong>10.3 节点通信</strong></h2><h3 id="10-3-1-通信流程"><a href="#10-3-1-通信流程" class="headerlink" title="10.3.1 通信流程"></a><strong>10.3.1 通信流程</strong></h3><h3 id="10-3-2-Gossip消息"><a href="#10-3-2-Gossip消息" class="headerlink" title="10.3.2 Gossip消息"></a><strong>10.3.2 Gossip消息</strong></h3><h3 id="10-3-3-节点选择"><a href="#10-3-3-节点选择" class="headerlink" title="10.3.3 节点选择"></a><strong>10.3.3 节点选择</strong></h3><hr><h2 id="10-4-集群伸缩"><a href="#10-4-集群伸缩" class="headerlink" title="10.4 集群伸缩"></a><strong>10.4 集群伸缩</strong></h2><h3 id="10-4-1-伸缩原理"><a href="#10-4-1-伸缩原理" class="headerlink" title="10.4.1 伸缩原理"></a><strong>10.4.1 伸缩原理</strong></h3><h3 id="10-4-2-扩容集群"><a href="#10-4-2-扩容集群" class="headerlink" title="10.4.2 扩容集群"></a><strong>10.4.2 扩容集群</strong></h3><h3 id="10-4-3-收缩集群"><a href="#10-4-3-收缩集群" class="headerlink" title="10.4.3 收缩集群"></a><strong>10.4.3 收缩集群</strong></h3><hr><h2 id="10-5-请求路由"><a href="#10-5-请求路由" class="headerlink" title="10.5 请求路由"></a><strong>10.5 请求路由</strong></h2><h3 id="10-5-1-请求重定向"><a href="#10-5-1-请求重定向" class="headerlink" title="10.5.1 请求重定向"></a><strong>10.5.1 请求重定向</strong></h3><h3 id="10-5-2-Smart客户端"><a href="#10-5-2-Smart客户端" class="headerlink" title="10.5.2 Smart客户端"></a><strong>10.5.2 Smart客户端</strong></h3><h3 id="10-5-3-ASK重定向"><a href="#10-5-3-ASK重定向" class="headerlink" title="10.5.3 ASK重定向"></a><strong>10.5.3 ASK重定向</strong></h3><hr><h2 id="10-6-故障转移"><a href="#10-6-故障转移" class="headerlink" title="10.6 故障转移"></a><strong>10.6 故障转移</strong></h2><h3 id="10-6-1-故障发现"><a href="#10-6-1-故障发现" class="headerlink" title="10.6.1 故障发现"></a><strong>10.6.1 故障发现</strong></h3><h3 id="10-6-2-故障恢复"><a href="#10-6-2-故障恢复" class="headerlink" title="10.6.2 故障恢复"></a><strong>10.6.2 故障恢复</strong></h3><h3 id="10-6-3-故障转移时间"><a href="#10-6-3-故障转移时间" class="headerlink" title="10.6.3 故障转移时间"></a><strong>10.6.3 故障转移时间</strong></h3><h3 id="10-6-4-故障演练"><a href="#10-6-4-故障演练" class="headerlink" title="10.6.4 故障演练"></a><strong>10.6.4 故障演练</strong></h3><hr><h2 id="10-7-集群运维"><a href="#10-7-集群运维" class="headerlink" title="10.7 集群运维"></a><strong>10.7 集群运维</strong></h2><h3 id="10-7-1-集群完整性"><a href="#10-7-1-集群完整性" class="headerlink" title="10.7.1 集群完整性"></a><strong>10.7.1 集群完整性</strong></h3><h3 id="10-7-2-带宽消耗"><a href="#10-7-2-带宽消耗" class="headerlink" title="10.7.2 带宽消耗"></a><strong>10.7.2 带宽消耗</strong></h3><h3 id="10-7-3-Pub-Sub广播问题"><a href="#10-7-3-Pub-Sub广播问题" class="headerlink" title="10.7.3 Pub/Sub广播问题"></a><strong>10.7.3 Pub/Sub广播问题</strong></h3><h3 id="10-7-4-集群倾斜"><a href="#10-7-4-集群倾斜" class="headerlink" title="10.7.4 集群倾斜"></a><strong>10.7.4 集群倾斜</strong></h3><h3 id="10-7-5-集群读写分离"><a href="#10-7-5-集群读写分离" class="headerlink" title="10.7.5 集群读写分离"></a><strong>10.7.5 集群读写分离</strong></h3><h3 id="10-7-6-手动故障转移"><a href="#10-7-6-手动故障转移" class="headerlink" title="10.7.6 手动故障转移"></a><strong>10.7.6 手动故障转移</strong></h3><h3 id="10-7-7-数据迁移"><a href="#10-7-7-数据迁移" class="headerlink" title="10.7.7 数据迁移"></a><strong>10.7.7 数据迁移</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（十）集群，内容包括：数据分布，搭建集群，节点通信，集群伸缩，请求路由，故障转移，集群运维等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（九）哨兵（未完成）</title>
    <link href="http://linyishui.top/2020031601.html"/>
    <id>http://linyishui.top/2020031601.html</id>
    <published>2020-03-16T08:26:13.000Z</published>
    <updated>2020-04-22T08:58:18.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第九章-哨兵"><a href="#第九章-哨兵" class="headerlink" title="第九章 哨兵"></a><strong>第九章 哨兵</strong></h1><h2 id="9-1-基本概念"><a href="#9-1-基本概念" class="headerlink" title="9.1 基本概念"></a><strong>9.1 基本概念</strong></h2><h3 id="9-1-1-主从复制的问题"><a href="#9-1-1-主从复制的问题" class="headerlink" title="9.1.1 主从复制的问题"></a><strong>9.1.1 主从复制的问题</strong></h3><h3 id="9-1-2-高可用"><a href="#9-1-2-高可用" class="headerlink" title="9.1.2 高可用"></a><strong>9.1.2 高可用</strong></h3><h3 id="9-1-3-Redis-Sentinel的高可用性"><a href="#9-1-3-Redis-Sentinel的高可用性" class="headerlink" title="9.1.3 Redis Sentinel的高可用性"></a><strong>9.1.3 Redis Sentinel的高可用性</strong></h3><hr><h2 id="9-2-安装和部署"><a href="#9-2-安装和部署" class="headerlink" title="9.2 安装和部署"></a><strong>9.2 安装和部署</strong></h2><h3 id="9-2-1-部署拓扑结构"><a href="#9-2-1-部署拓扑结构" class="headerlink" title="9.2.1 部署拓扑结构"></a><strong>9.2.1 部署拓扑结构</strong></h3><h3 id="9-2-2-部署Redis数据节点"><a href="#9-2-2-部署Redis数据节点" class="headerlink" title="9.2.2 部署Redis数据节点"></a><strong>9.2.2 部署Redis数据节点</strong></h3><h3 id="9-2-3-部署Sentinel节点"><a href="#9-2-3-部署Sentinel节点" class="headerlink" title="9.2.3 部署Sentinel节点"></a><strong>9.2.3 部署Sentinel节点</strong></h3><h3 id="9-2-4-配置优化"><a href="#9-2-4-配置优化" class="headerlink" title="9.2.4 配置优化"></a><strong>9.2.4 配置优化</strong></h3><h3 id="9-2-5-部署技巧"><a href="#9-2-5-部署技巧" class="headerlink" title="9.2.5 部署技巧"></a><strong>9.2.5 部署技巧</strong></h3><hr><h2 id="9-3-API"><a href="#9-3-API" class="headerlink" title="9.3 API"></a><strong>9.3 API</strong></h2><hr><h2 id="9-4-客户端连接"><a href="#9-4-客户端连接" class="headerlink" title="9.4 客户端连接"></a><strong>9.4 客户端连接</strong></h2><h3 id="9-4-1-Redis-Sentinel的客户端"><a href="#9-4-1-Redis-Sentinel的客户端" class="headerlink" title="9.4.1 Redis Sentinel的客户端"></a><strong>9.4.1 Redis Sentinel的客户端</strong></h3><h3 id="9-4-2-Redis-Sentinel客户端基本实现原理"><a href="#9-4-2-Redis-Sentinel客户端基本实现原理" class="headerlink" title="9.4.2 Redis Sentinel客户端基本实现原理"></a><strong>9.4.2 Redis Sentinel客户端基本实现原理</strong></h3><h3 id="9-4-3-Java操作Redis-Sentinel"><a href="#9-4-3-Java操作Redis-Sentinel" class="headerlink" title="9.4.3 Java操作Redis Sentinel"></a><strong>9.4.3 Java操作Redis Sentinel</strong></h3><hr><h2 id="9-5-实现原理"><a href="#9-5-实现原理" class="headerlink" title="9.5 实现原理"></a><strong>9.5 实现原理</strong></h2><h3 id="9-5-1-三个定时监控任务"><a href="#9-5-1-三个定时监控任务" class="headerlink" title="9.5.1 三个定时监控任务"></a><strong>9.5.1 三个定时监控任务</strong></h3><h3 id="9-5-2-主观下线和客观下线"><a href="#9-5-2-主观下线和客观下线" class="headerlink" title="9.5.2 主观下线和客观下线"></a><strong>9.5.2 主观下线和客观下线</strong></h3><h3 id="9-5-3-领导者Sentinel节点选举"><a href="#9-5-3-领导者Sentinel节点选举" class="headerlink" title="9.5.3 领导者Sentinel节点选举"></a><strong>9.5.3 领导者Sentinel节点选举</strong></h3><h3 id="9-5-4-故障转移"><a href="#9-5-4-故障转移" class="headerlink" title="9.5.4 故障转移"></a><strong>9.5.4 故障转移</strong></h3><hr><h2 id="9-6-开发与运维中的问题"><a href="#9-6-开发与运维中的问题" class="headerlink" title="9.6 开发与运维中的问题"></a><strong>9.6 开发与运维中的问题</strong></h2><h3 id="9-6-1-故障转移日志分析"><a href="#9-6-1-故障转移日志分析" class="headerlink" title="9.6.1 故障转移日志分析"></a><strong>9.6.1 故障转移日志分析</strong></h3><h3 id="9-6-2-节点运维"><a href="#9-6-2-节点运维" class="headerlink" title="9.6.2 节点运维"></a><strong>9.6.2 节点运维</strong></h3><h3 id="9-6-3-高可用读写分离"><a href="#9-6-3-高可用读写分离" class="headerlink" title="9.6.3 高可用读写分离"></a><strong>9.6.3 高可用读写分离</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（九）哨兵，内容包括：基本概念，安装和部署，API，客户端连接，实现原理，开发与运维中的问题等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（八）理解内存（未完成）</title>
    <link href="http://linyishui.top/2020031501.html"/>
    <id>http://linyishui.top/2020031501.html</id>
    <published>2020-03-15T08:26:07.000Z</published>
    <updated>2020-04-22T08:52:45.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第八章-理解内存"><a href="#第八章-理解内存" class="headerlink" title="第八章 理解内存"></a><strong>第八章 理解内存</strong></h1><h2 id="8-1-内存消耗"><a href="#8-1-内存消耗" class="headerlink" title="8.1 内存消耗"></a><strong>8.1 内存消耗</strong></h2><h3 id="8-1-1-内存使用统计"><a href="#8-1-1-内存使用统计" class="headerlink" title="8.1.1 内存使用统计"></a><strong>8.1.1 内存使用统计</strong></h3><h3 id="8-1-2-内存消耗划分"><a href="#8-1-2-内存消耗划分" class="headerlink" title="8.1.2 内存消耗划分"></a><strong>8.1.2 内存消耗划分</strong></h3><h3 id="8-1-3-子进程内存消耗"><a href="#8-1-3-子进程内存消耗" class="headerlink" title="8.1.3 子进程内存消耗"></a><strong>8.1.3 子进程内存消耗</strong></h3><hr><h2 id="8-2-内存管理"><a href="#8-2-内存管理" class="headerlink" title="8.2 内存管理"></a><strong>8.2 内存管理</strong></h2><h3 id="8-2-1-设置内存上限"><a href="#8-2-1-设置内存上限" class="headerlink" title="8.2.1 设置内存上限"></a><strong>8.2.1 设置内存上限</strong></h3><h3 id="8-2-2-动态调整内存上限"><a href="#8-2-2-动态调整内存上限" class="headerlink" title="8.2.2 动态调整内存上限"></a><strong>8.2.2 动态调整内存上限</strong></h3><h3 id="8-2-3-内存回收策略"><a href="#8-2-3-内存回收策略" class="headerlink" title="8.2.3 内存回收策略"></a><strong>8.2.3 内存回收策略</strong></h3><hr><h2 id="8-3-内存优化"><a href="#8-3-内存优化" class="headerlink" title="8.3 内存优化"></a><strong>8.3 内存优化</strong></h2><h3 id="8-3-1-redisObject对象"><a href="#8-3-1-redisObject对象" class="headerlink" title="8.3.1 redisObject对象"></a><strong>8.3.1 redisObject对象</strong></h3><h3 id="8-3-2-缩减键值对象"><a href="#8-3-2-缩减键值对象" class="headerlink" title="8.3.2 缩减键值对象"></a><strong>8.3.2 缩减键值对象</strong></h3><h3 id="8-3-3-共享对象池"><a href="#8-3-3-共享对象池" class="headerlink" title="8.3.3 共享对象池"></a><strong>8.3.3 共享对象池</strong></h3><h3 id="8-3-4-字符串优化"><a href="#8-3-4-字符串优化" class="headerlink" title="8.3.4 字符串优化"></a><strong>8.3.4 字符串优化</strong></h3><h3 id="8-3-5-编码优化"><a href="#8-3-5-编码优化" class="headerlink" title="8.3.5 编码优化"></a><strong>8.3.5 编码优化</strong></h3><h3 id="8-3-6-控制键的数量"><a href="#8-3-6-控制键的数量" class="headerlink" title="8.3.6 控制键的数量"></a><strong>8.3.6 控制键的数量</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（八）理解内存，内容包括：内存消耗（内存使用统计、内存消耗划分、子进程内存消耗），内存管理（设置内存上限、动态调整内存上限、内存回收策略），内存优化（redisObject对象、缩减键值对象、共享对象池、字符串优化、编码优化、控制键的数量）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（七）阻塞（未完成）</title>
    <link href="http://linyishui.top/2020031201.html"/>
    <id>http://linyishui.top/2020031201.html</id>
    <published>2020-03-12T08:26:00.000Z</published>
    <updated>2020-04-23T01:50:20.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第七章-阻塞"><a href="#第七章-阻塞" class="headerlink" title="第七章 阻塞"></a><strong>第七章 阻塞</strong></h1><h2 id="7-1-发现阻塞"><a href="#7-1-发现阻塞" class="headerlink" title="7.1 发现阻塞"></a><strong>7.1 发现阻塞</strong></h2><hr><h2 id="7-2-内在原因"><a href="#7-2-内在原因" class="headerlink" title="7.2 内在原因"></a><strong>7.2 内在原因</strong></h2><h3 id="7-2-1-API或数据结构使用不合理"><a href="#7-2-1-API或数据结构使用不合理" class="headerlink" title="7.2.1 API或数据结构使用不合理"></a><strong>7.2.1 API或数据结构使用不合理</strong></h3><h3 id="7-2-2-CPU饱和"><a href="#7-2-2-CPU饱和" class="headerlink" title="7.2.2 CPU饱和"></a><strong>7.2.2 CPU饱和</strong></h3><h3 id="7-2-3-持久化阻塞"><a href="#7-2-3-持久化阻塞" class="headerlink" title="7.2.3 持久化阻塞"></a><strong>7.2.3 持久化阻塞</strong></h3><hr><h2 id="7-3-外在原因"><a href="#7-3-外在原因" class="headerlink" title="7.3 外在原因"></a><strong>7.3 外在原因</strong></h2><h3 id="7-3-1-CPU竞争"><a href="#7-3-1-CPU竞争" class="headerlink" title="7.3.1 CPU竞争"></a><strong>7.3.1 CPU竞争</strong></h3><h3 id="7-3-2-内存交换"><a href="#7-3-2-内存交换" class="headerlink" title="7.3.2 内存交换"></a><strong>7.3.2 内存交换</strong></h3><h3 id="7-3-3-网络问题"><a href="#7-3-3-网络问题" class="headerlink" title="7.3.3 网络问题"></a><strong>7.3.3 网络问题</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（七）阻塞，内容包括：发现阻塞，内在原因（API或数据结构使用不合理、CPU饱和、持久化阻塞），外在原因（CPU竞争、内存交换、网络问题）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（六）复制（未完成）</title>
    <link href="http://linyishui.top/2020031001.html"/>
    <id>http://linyishui.top/2020031001.html</id>
    <published>2020-03-10T08:25:54.000Z</published>
    <updated>2020-04-22T08:44:49.694Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第六章-复制"><a href="#第六章-复制" class="headerlink" title="第六章 复制"></a><strong>第六章 复制</strong></h1><h2 id="6-1-配置"><a href="#6-1-配置" class="headerlink" title="6.1 配置"></a><strong>6.1 配置</strong></h2><h3 id="6-1-1-建立复制"><a href="#6-1-1-建立复制" class="headerlink" title="6.1.1 建立复制"></a><strong>6.1.1 建立复制</strong></h3><h3 id="6-1-2-断开复制"><a href="#6-1-2-断开复制" class="headerlink" title="6.1.2 断开复制"></a><strong>6.1.2 断开复制</strong></h3><h3 id="6-1-3-安全性"><a href="#6-1-3-安全性" class="headerlink" title="6.1.3 安全性"></a><strong>6.1.3 安全性</strong></h3><h3 id="6-1-4-只读"><a href="#6-1-4-只读" class="headerlink" title="6.1.4 只读"></a><strong>6.1.4 只读</strong></h3><h3 id="6-1-5-传输延迟"><a href="#6-1-5-传输延迟" class="headerlink" title="6.1.5 传输延迟"></a><strong>6.1.5 传输延迟</strong></h3><hr><h2 id="6-2-拓扑"><a href="#6-2-拓扑" class="headerlink" title="6.2 拓扑"></a><strong>6.2 拓扑</strong></h2><hr><h2 id="6-3-原理"><a href="#6-3-原理" class="headerlink" title="6.3 原理"></a><strong>6.3 原理</strong></h2><h3 id="6-3-1-复制过程"><a href="#6-3-1-复制过程" class="headerlink" title="6.3.1 复制过程"></a><strong>6.3.1 复制过程</strong></h3><h3 id="6-3-2-数据同步"><a href="#6-3-2-数据同步" class="headerlink" title="6.3.2 数据同步"></a><strong>6.3.2 数据同步</strong></h3><h3 id="6-3-3-全量复制"><a href="#6-3-3-全量复制" class="headerlink" title="6.3.3 全量复制"></a><strong>6.3.3 全量复制</strong></h3><h3 id="6-3-4-部分复制"><a href="#6-3-4-部分复制" class="headerlink" title="6.3.4 部分复制"></a><strong>6.3.4 部分复制</strong></h3><h3 id="6-3-5-心跳"><a href="#6-3-5-心跳" class="headerlink" title="6.3.5 心跳"></a><strong>6.3.5 心跳</strong></h3><h3 id="6-3-6-异步复制"><a href="#6-3-6-异步复制" class="headerlink" title="6.3.6 异步复制"></a><strong>6.3.6 异步复制</strong></h3><hr><h2 id="6-4-开发与运维中的问题"><a href="#6-4-开发与运维中的问题" class="headerlink" title="6.4 开发与运维中的问题"></a><strong>6.4 开发与运维中的问题</strong></h2><h3 id="6-4-1-读写分离"><a href="#6-4-1-读写分离" class="headerlink" title="6.4.1 读写分离"></a><strong>6.4.1 读写分离</strong></h3><h3 id="6-4-2-主从配置不一致"><a href="#6-4-2-主从配置不一致" class="headerlink" title="6.4.2 主从配置不一致"></a><strong>6.4.2 主从配置不一致</strong></h3><h3 id="6-4-3-规避全量复制"><a href="#6-4-3-规避全量复制" class="headerlink" title="6.4.3 规避全量复制"></a><strong>6.4.3 规避全量复制</strong></h3><h3 id="6-4-4-规避复制风暴"><a href="#6-4-4-规避复制风暴" class="headerlink" title="6.4.4 规避复制风暴"></a><strong>6.4.4 规避复制风暴</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（六）复制，内容包括：配置，拓扑，原理，开发与运维中的问题等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（五）持久化（未完成）</title>
    <link href="http://linyishui.top/2020030801.html"/>
    <id>http://linyishui.top/2020030801.html</id>
    <published>2020-03-08T08:25:45.000Z</published>
    <updated>2020-04-22T08:41:04.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第五章-持久化"><a href="#第五章-持久化" class="headerlink" title="第五章 持久化"></a><strong>第五章 持久化</strong></h1><h2 id="5-1-RDB"><a href="#5-1-RDB" class="headerlink" title="5.1 RDB"></a><strong>5.1 RDB</strong></h2><h3 id="5-1-1-触发机制"><a href="#5-1-1-触发机制" class="headerlink" title="5.1.1 触发机制"></a><strong>5.1.1 触发机制</strong></h3><h3 id="5-1-2-流程说明"><a href="#5-1-2-流程说明" class="headerlink" title="5.1.2 流程说明"></a><strong>5.1.2 流程说明</strong></h3><h3 id="5-1-3-RDB文件的处理"><a href="#5-1-3-RDB文件的处理" class="headerlink" title="5.1.3 RDB文件的处理"></a><strong>5.1.3 RDB文件的处理</strong></h3><h3 id="5-1-4-RDB的优缺点"><a href="#5-1-4-RDB的优缺点" class="headerlink" title="5.1.4 RDB的优缺点"></a><strong>5.1.4 RDB的优缺点</strong></h3><hr><h2 id="5-2-AOF"><a href="#5-2-AOF" class="headerlink" title="5.2 AOF"></a><strong>5.2 AOF</strong></h2><h3 id="5-2-1-使用AOF"><a href="#5-2-1-使用AOF" class="headerlink" title="5.2.1 使用AOF"></a><strong>5.2.1 使用AOF</strong></h3><h3 id="5-2-2-命令写入"><a href="#5-2-2-命令写入" class="headerlink" title="5.2.2 命令写入"></a><strong>5.2.2 命令写入</strong></h3><h3 id="5-2-3-文件同步"><a href="#5-2-3-文件同步" class="headerlink" title="5.2.3 文件同步"></a><strong>5.2.3 文件同步</strong></h3><h3 id="5-2-4-重写机制"><a href="#5-2-4-重写机制" class="headerlink" title="5.2.4 重写机制"></a><strong>5.2.4 重写机制</strong></h3><h3 id="5-2-5-重启加载"><a href="#5-2-5-重启加载" class="headerlink" title="5.2.5 重启加载"></a><strong>5.2.5 重启加载</strong></h3><h3 id="5-2-6-文件校验"><a href="#5-2-6-文件校验" class="headerlink" title="5.2.6 文件校验"></a><strong>5.2.6 文件校验</strong></h3><hr><h2 id="5-3-问题定位与优化"><a href="#5-3-问题定位与优化" class="headerlink" title="5.3 问题定位与优化"></a><strong>5.3 问题定位与优化</strong></h2><h3 id="5-3-1-fork操作"><a href="#5-3-1-fork操作" class="headerlink" title="5.3.1 fork操作"></a><strong>5.3.1 fork操作</strong></h3><h3 id="5-3-2-子进程开销监控和优化"><a href="#5-3-2-子进程开销监控和优化" class="headerlink" title="5.3.2 子进程开销监控和优化"></a><strong>5.3.2 子进程开销监控和优化</strong></h3><h3 id="5-3-3-AOF追加阻塞"><a href="#5-3-3-AOF追加阻塞" class="headerlink" title="5.3.3 AOF追加阻塞"></a><strong>5.3.3 AOF追加阻塞</strong></h3><hr><h2 id="5-4-多实例部署"><a href="#5-4-多实例部署" class="headerlink" title="5.4 多实例部署"></a><strong>5.4 多实例部署</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（五）持久化，内容包括：RDB，AOF，问题定位与优化，多实例部署等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（四）客户端（未完成）</title>
    <link href="http://linyishui.top/2020030601.html"/>
    <id>http://linyishui.top/2020030601.html</id>
    <published>2020-03-06T08:10:23.000Z</published>
    <updated>2020-04-22T08:40:54.087Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第四章-客户端"><a href="#第四章-客户端" class="headerlink" title="第四章 客户端"></a><strong>第四章 客户端</strong></h1><h2 id="4-1-客户端通信协议"><a href="#4-1-客户端通信协议" class="headerlink" title="4.1 客户端通信协议"></a><strong>4.1 客户端通信协议</strong></h2><hr><h2 id="4-2-Java客户端Jedis"><a href="#4-2-Java客户端Jedis" class="headerlink" title="4.2 Java客户端Jedis"></a><strong>4.2 Java客户端Jedis</strong></h2><h3 id="4-2-1-获取Jedis"><a href="#4-2-1-获取Jedis" class="headerlink" title="4.2.1 获取Jedis"></a><strong>4.2.1 获取Jedis</strong></h3><h3 id="4-2-2-Jedis的基本使用方法"><a href="#4-2-2-Jedis的基本使用方法" class="headerlink" title="4.2.2 Jedis的基本使用方法"></a><strong>4.2.2 Jedis的基本使用方法</strong></h3><h3 id="4-2-3-Jedis连接池的使用方法"><a href="#4-2-3-Jedis连接池的使用方法" class="headerlink" title="4.2.3 Jedis连接池的使用方法"></a><strong>4.2.3 Jedis连接池的使用方法</strong></h3><h3 id="4-2-4-Redis中的Pipeline的使用方法"><a href="#4-2-4-Redis中的Pipeline的使用方法" class="headerlink" title="4.2.4 Redis中的Pipeline的使用方法"></a><strong>4.2.4 Redis中的Pipeline的使用方法</strong></h3><h3 id="4-2-4-Jedis的Lua脚本"><a href="#4-2-4-Jedis的Lua脚本" class="headerlink" title="4.2.4 Jedis的Lua脚本"></a><strong>4.2.4 Jedis的Lua脚本</strong></h3><hr><h2 id="4-3-Python客户端redis-py"><a href="#4-3-Python客户端redis-py" class="headerlink" title="4.3 Python客户端redis-py"></a><strong>4.3 Python客户端redis-py</strong></h2><h3 id="4-3-1-获取redis-py"><a href="#4-3-1-获取redis-py" class="headerlink" title="4.3.1 获取redis-py"></a><strong>4.3.1 获取redis-py</strong></h3><h3 id="4-3-2-redis-py的基本使用方法"><a href="#4-3-2-redis-py的基本使用方法" class="headerlink" title="4.3.2 redis-py的基本使用方法"></a><strong>4.3.2 redis-py的基本使用方法</strong></h3><h3 id="4-3-3-redis-py中的Pipeline的使用方法"><a href="#4-3-3-redis-py中的Pipeline的使用方法" class="headerlink" title="4.3.3 redis-py中的Pipeline的使用方法"></a><strong>4.3.3 redis-py中的Pipeline的使用方法</strong></h3><h3 id="4-3-4-redis-py中的Lua脚本的使用方法"><a href="#4-3-4-redis-py中的Lua脚本的使用方法" class="headerlink" title="4.3.4 redis-py中的Lua脚本的使用方法"></a><strong>4.3.4 redis-py中的Lua脚本的使用方法</strong></h3><hr><h2 id="4-4-客户端管理"><a href="#4-4-客户端管理" class="headerlink" title="4.4 客户端管理"></a><strong>4.4 客户端管理</strong></h2><h3 id="4-4-1-客户端API"><a href="#4-4-1-客户端API" class="headerlink" title="4.4.1 客户端API"></a><strong>4.4.1 客户端API</strong></h3><h3 id="4-4-2-客户端相关配置"><a href="#4-4-2-客户端相关配置" class="headerlink" title="4.4.2 客户端相关配置"></a><strong>4.4.2 客户端相关配置</strong></h3><h3 id="4-4-3-客户端统计片段"><a href="#4-4-3-客户端统计片段" class="headerlink" title="4.4.3 客户端统计片段"></a><strong>4.4.3 客户端统计片段</strong></h3><hr><h2 id="4-5-客户端常见异常"><a href="#4-5-客户端常见异常" class="headerlink" title="4.5 客户端常见异常"></a><strong>4.5 客户端常见异常</strong></h2><hr><h2 id="4-6-客户端案例分析"><a href="#4-6-客户端案例分析" class="headerlink" title="4.6 客户端案例分析"></a><strong>4.6 客户端案例分析</strong></h2><h3 id="4-6-1-Redis内存陡增"><a href="#4-6-1-Redis内存陡增" class="headerlink" title="4.6.1 Redis内存陡增"></a><strong>4.6.1 Redis内存陡增</strong></h3><h3 id="4-6-2-客户端周期性的超时"><a href="#4-6-2-客户端周期性的超时" class="headerlink" title="4.6.2 客户端周期性的超时"></a><strong>4.6.2 客户端周期性的超时</strong></h3><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（四）客户端，内容包括：客户端通信协议，Java客户端Jedis，Python客户端redis-py，客户端管理，客户端常见异常，客户端案例分析等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（三）功能（未完成）</title>
    <link href="http://linyishui.top/2020030501.html"/>
    <id>http://linyishui.top/2020030501.html</id>
    <published>2020-03-05T03:57:50.000Z</published>
    <updated>2020-04-24T01:45:34.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第三章-功能"><a href="#第三章-功能" class="headerlink" title="第三章 功能"></a><strong>第三章 功能</strong></h1><h2 id="3-1-慢查询分析"><a href="#3-1-慢查询分析" class="headerlink" title="3.1 慢查询分析"></a><strong>3.1 慢查询分析</strong></h2><h3 id="3-1-1-慢查询的两个配置参数"><a href="#3-1-1-慢查询的两个配置参数" class="headerlink" title="3.1.1 慢查询的两个配置参数"></a><strong>3.1.1 慢查询的两个配置参数</strong></h3><h3 id="3-1-2-最佳实践"><a href="#3-1-2-最佳实践" class="headerlink" title="3.1.2 最佳实践"></a><strong>3.1.2 最佳实践</strong></h3><hr><h2 id="3-2-Redis-Shell"><a href="#3-2-Redis-Shell" class="headerlink" title="3.2 Redis Shell"></a><strong>3.2 Redis Shell</strong></h2><h3 id="3-2-1-redis-cli详解"><a href="#3-2-1-redis-cli详解" class="headerlink" title="3.2.1 redis-cli详解"></a><strong>3.2.1 redis-cli详解</strong></h3><h3 id="3-2-2-redis-server详解"><a href="#3-2-2-redis-server详解" class="headerlink" title="3.2.2 redis-server详解"></a><strong>3.2.2 redis-server详解</strong></h3><h3 id="3-2-3-redis-benchmark详解"><a href="#3-2-3-redis-benchmark详解" class="headerlink" title="3.2.3 redis-benchmark详解"></a><strong>3.2.3 redis-benchmark详解</strong></h3><hr><h2 id="3-3-Pipeline"><a href="#3-3-Pipeline" class="headerlink" title="3.3 Pipeline"></a><strong>3.3 Pipeline</strong></h2><h3 id="3-3-1-pipeline概念"><a href="#3-3-1-pipeline概念" class="headerlink" title="3.3.1 pipeline概念"></a><strong>3.3.1 pipeline概念</strong></h3><h3 id="3-3-2-性能测试"><a href="#3-3-2-性能测试" class="headerlink" title="3.3.2 性能测试"></a><strong>3.3.2 性能测试</strong></h3><h3 id="3-3-3-原生批量命令和Pipeline对比"><a href="#3-3-3-原生批量命令和Pipeline对比" class="headerlink" title="3.3.3 原生批量命令和Pipeline对比"></a><strong>3.3.3 原生批量命令和Pipeline对比</strong></h3><h3 id="3-3-4-最佳实践"><a href="#3-3-4-最佳实践" class="headerlink" title="3.3.4 最佳实践"></a><strong>3.3.4 最佳实践</strong></h3><hr><h2 id="3-4-事务与Lua"><a href="#3-4-事务与Lua" class="headerlink" title="3.4 事务与Lua"></a><strong>3.4 事务与Lua</strong></h2><h3 id="3-4-1-事务"><a href="#3-4-1-事务" class="headerlink" title="3.4.1 事务"></a><strong>3.4.1 事务</strong></h3><h3 id="3-4-2-Lua用法简述"><a href="#3-4-2-Lua用法简述" class="headerlink" title="3.4.2 Lua用法简述"></a><strong>3.4.2 Lua用法简述</strong></h3><h3 id="3-4-3-案例"><a href="#3-4-3-案例" class="headerlink" title="3.4.3 案例"></a><strong>3.4.3 案例</strong></h3><h3 id="3-4-4-Redis如何管理Lua脚本"><a href="#3-4-4-Redis如何管理Lua脚本" class="headerlink" title="3.4.4 Redis如何管理Lua脚本"></a><strong>3.4.4 Redis如何管理Lua脚本</strong></h3><hr><h2 id="3-5-Bitmaps"><a href="#3-5-Bitmaps" class="headerlink" title="3.5 Bitmaps"></a><strong>3.5 Bitmaps</strong></h2><h3 id="3-5-1-数据结构模型"><a href="#3-5-1-数据结构模型" class="headerlink" title="3.5.1 数据结构模型"></a><strong>3.5.1 数据结构模型</strong></h3><h3 id="3-5-2-命令"><a href="#3-5-2-命令" class="headerlink" title="3.5.2 命令"></a><strong>3.5.2 命令</strong></h3><h3 id="3-5-3-Bitmaps分析"><a href="#3-5-3-Bitmaps分析" class="headerlink" title="3.5.3 Bitmaps分析"></a><strong>3.5.3 Bitmaps分析</strong></h3><hr><h2 id="3-6-HyperLogLog"><a href="#3-6-HyperLogLog" class="headerlink" title="3.6 HyperLogLog"></a><strong>3.6 HyperLogLog</strong></h2><hr><h2 id="3-7-发布订阅"><a href="#3-7-发布订阅" class="headerlink" title="3.7 发布订阅"></a><strong>3.7 发布订阅</strong></h2><h3 id="3-7-1-命令"><a href="#3-7-1-命令" class="headerlink" title="3.7.1 命令"></a><strong>3.7.1 命令</strong></h3><h3 id="3-7-2-使用场景"><a href="#3-7-2-使用场景" class="headerlink" title="3.7.2 使用场景"></a><strong>3.7.2 使用场景</strong></h3><hr><h2 id="3-8-GEO"><a href="#3-8-GEO" class="headerlink" title="3.8 GEO"></a><strong>3.8 GEO</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（三）功能，内容包括：慢查询分析，Redis Shell，Pipeline，事务与Lua，Bitmaps，HyperLogLog，发布订阅，GEO等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（一）Redis简介</title>
    <link href="http://linyishui.top/2020030102.html"/>
    <id>http://linyishui.top/2020030102.html</id>
    <published>2020-03-01T07:24:19.000Z</published>
    <updated>2020-04-08T03:57:23.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-Redis简介"><a href="#第一章-Redis简介" class="headerlink" title="第一章 Redis简介"></a><strong>第一章 Redis简介</strong></h1><h2 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1 什么是Redis?"></a><strong>1.1 什么是Redis?</strong></h2><p>&emsp;&emsp;Redis是一种基于<strong>键值对</strong>的NoSQL（非关系型）数据库。与另外一些键值对数据库不同的是，Redis的值可以是：string、hash、list、set、zset（有序集合）、Bitmaps（位图）、HyperLogLog（做基数统计）、GEO（地理信息定位）等多种数据结构和算法。</p><blockquote><p>Redis主要有哪些优势？</p><ul><li>值可以存放多种数据结构和算法，所以可以满足大量的应用场景。</li><li>将数据存放在内存，所以有高效的读写性能。</li><li>内存中的数据通过快照和日志的方式保存在硬盘上，防止丢失。</li></ul></blockquote><p>&emsp;&emsp;Redis的作者本身想通过MySql来实现一个高性能的队列功能，但优化SQL无法提高性能，所以他决定自己开发一款数据库，即Redis。目前大部分国内外知名的互联网企业都在使用Redis，还有一些开源技术如ELK（即Elasticsearch，Logstash 和Kibana，实现集中式日志系统）也把Redis当作组件中的重要一环。</p><hr><h2 id="1-2-Redis特性"><a href="#1-2-Redis特性" class="headerlink" title="1.2 Redis特性"></a><strong>1.2 Redis特性</strong></h2><h3 id="1-2-1-速度快"><a href="#1-2-1-速度快" class="headerlink" title="1.2.1 速度快"></a><strong>1.2.1 速度快</strong></h3><blockquote><p>Redis速度非常快，其高效性能的原因有：</p><ul><li>所有数据都存放在内存。</li><li>使用C语言实现。</li><li>使用单线程架构，避免了多线程竞争问题。</li><li>作者对源码进行了精打细磨，曾被人评价是少有的集性能与优雅于一身的开源代码。</li></ul></blockquote><h3 id="1-2-2-基于键值对的数据结构服务器"><a href="#1-2-2-基于键值对的数据结构服务器" class="headerlink" title="1.2.2 基于键值对的数据结构服务器"></a><strong>1.2.2 基于键值对的数据结构服务器</strong></h3><p>&emsp;&emsp;大部分语言都会提供类似字典的功能，映射这种组织数据的方式叫做<strong>基于键值的方式</strong>，但Redis中的值不仅可以是字符串，还可以是字符串、哈希、列表、集合、有序集合。同时又在字符串的基础上演变出了Bitmaps（位图）、HyperLogLog（做基数统计）两种高级数据结构，并且随着LBS（Location Based Service，基于位置服务）的发展加入了GEO（地理信息定位）功能。</p><h3 id="1-2-3-丰富的功能"><a href="#1-2-3-丰富的功能" class="headerlink" title="1.2.3 丰富的功能"></a><strong>1.2.3 丰富的功能</strong></h3><blockquote><p>Redis还提供许多额外功能：</p><ul><li>提供了键过期功能，可以用来实现缓存。</li><li>提供了发布订阅功能，可以用来实现消息系统。</li><li>支持Lua脚本功能，可以利用Lua创造出新的Redis命令。</li><li>提供了简单的事务功能，能在一定程度上保证事务特性。</li><li>提供了流水线（Pipeline）功能，使客户端能将一批命令一次性传到Redis，减少了网络的开销。</li></ul></blockquote><h3 id="1-2-4-简单稳定"><a href="#1-2-4-简单稳定" class="headerlink" title="1.2.4 简单稳定"></a><strong>1.2.4 简单稳定</strong></h3><p>&emsp;&emsp;Redis的简单主要体现在三个方面：首先是源码很精简，几万行代码，对于大部分使用者来说都是可以去快速阅读一遍的。其次Redis使用单线程模型，不仅使得Redis服务端处理模型变得简单，也使客户端开发变得简单。最后Redis不需要依赖操作系统的类库（如Memcache需要依赖libevent），Redis自己实现了事件处理的相关功能。</p><p>&emsp;&emsp;Redis虽然精简，但非常稳定。</p><h3 id="1-2-5-客户端语言多"><a href="#1-2-5-客户端语言多" class="headerlink" title="1.2.5 客户端语言多"></a><strong>1.2.5 客户端语言多</strong></h3><p>&emsp;&emsp;Redis提供了简单的TCP通信协议，方便编程语言接入Redis，因为主流公司的认可，所以大部分客户端编程语言都支持Redis。</p><h3 id="1-2-6-持久化"><a href="#1-2-6-持久化" class="headerlink" title="1.2.6 持久化"></a><strong>1.2.6 持久化</strong></h3><p>&emsp;&emsp;数据存放在内存一般被认为是不安全的（断电或机器故障导致数据丢失），Redis提供了两种持久化方式：<strong>RDB</strong>和<strong>AOF</strong>。</p><h3 id="1-2-7-主从复制"><a href="#1-2-7-主从复制" class="headerlink" title="1.2.7 主从复制"></a><strong>1.2.7 主从复制</strong></h3><p>&emsp;&emsp;Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式的基础。</p><h3 id="1-2-8-高可用和分布式"><a href="#1-2-8-高可用和分布式" class="headerlink" title="1.2.8 高可用和分布式"></a><strong>1.2.8 高可用和分布式</strong></h3><p>&emsp;&emsp;Redis从2.8版本后提供了高可用实现：Redis Sentinel，能保证Redis节点的故障发现和故障自动转移。</p><p>&emsp;&emsp;3.0版本正式提供了分布式实现：Redis Cluster，提供了高可用、读写和容量的扩展性。</p><hr><h2 id="1-3-Redis使用场景"><a href="#1-3-Redis使用场景" class="headerlink" title="1.3 Redis使用场景"></a><strong>1.3 Redis使用场景</strong></h2><h3 id="1-3-1-Redis可以做什么？"><a href="#1-3-1-Redis可以做什么？" class="headerlink" title="1.3.1 Redis可以做什么？"></a><strong>1.3.1 Redis可以做什么？</strong></h3><blockquote><ol><li><strong>缓存</strong>，常用于大型网站来加速数据访问和缓解后端数据库压力。Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。</li><li><strong>排行榜系统</strong>，几乎所有网站都需要各种规则的排行榜，或是依据热度排行，或是发布时间，或是结合各种复杂维度计算。Redis提供了列表和有序集合数据结构，合理的使用这些结构可以很方便的构建各种排行榜系统。</li><li><strong>计数器应用</strong>，如一些视频网站的播放数，电商网站的浏览数，对于数据的实时性有较高的要求，如果并发量很大时，传统关系型数据库很难做好这一工作。Redis天然支持计数功能，且性能优越。</li><li><strong>社交网络</strong>，比如赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等常见功能，由于社交网站访问量通常较大，且传统关系型数据库不太适合存储这种类型的数据，而Redis提供的数据结构比较容易实现这些功能。</li><li><strong>消息队列系统</strong>，大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列功能，虽然相比专业的消息队列还有所欠缺，但可以满足大部分基础需求。</li></ol></blockquote><h3 id="1-3-2-Redis不可以做什么？"><a href="#1-3-2-Redis不可以做什么？" class="headerlink" title="1.3.2 Redis不可以做什么？"></a><strong>1.3.2 Redis不可以做什么？</strong></h3><p>&emsp;&emsp;正像大部分技术一样，Redis也有其边界。</p><p>&emsp;&emsp;首先站在<strong>数据规模</strong>的角度来看，我们把数据分为大规模数据和小规模数据。因为其存放数据于内存这一设定，在面对海量数据时就是一个性价比极低的选择。</p><p>&emsp;&emsp;然后站在<strong>数据冷热</strong>的角度来看，我们把数据分为热数据和冷数据，热数据指需要频繁操作的数据，冷数据则相反。例如对于视频网站，视频基本信息需要在各个业务线频繁操作，而用户观看记录（不要和观看数混为一谈，此处应该指行为数据）相比就不会那么繁忙，先不讨论两者的规模差异，视频信息属于热数据，用户观看记录属于冷数据。冷数据存放于内存是一种浪费，而热数据可以放在内存中加速读写，也减轻了后端存储的负载压力。</p><hr><h2 id="1-4-如何用好Redis？"><a href="#1-4-如何用好Redis？" class="headerlink" title="1.4 如何用好Redis？"></a><strong>1.4 如何用好Redis？</strong></h2><blockquote><ul><li><strong>不要把Redis当作黑盒使用，开发和运维一样重要</strong>。很多线上故障都是因为开发者把Redis当作黑盒使用而造成的：如果不了解Redis的单线程模型，可能会在有上千万个键的Redis上执行keys *操作；如果不了解持久化相关原理，可能会在一个写操作量很大的Redis上配置自动保存RDB。相比专职的关系型数据库DBA，大部分公司并没有人来专职运维Redis，所以往往需要开发人员来担当这一角色。这一经验对于我们学好Redis也大有帮助。</li><li><strong>阅读源码</strong>。Redis源码量很小，所以请多读Redis源码，不仅可以加深理解，也可以提高自身编程水平，甚至定制化Redis，需要大公司会对Redis进行定制来满足其业务需求。</li></ul></blockquote><hr><h2 id="1-5-安装Redis"><a href="#1-5-安装Redis" class="headerlink" title="1.5 安装Redis"></a><strong>1.5 安装Redis</strong></h2><h3 id="1-5-1-Linux上安装Redis"><a href="#1-5-1-Linux上安装Redis" class="headerlink" title="1.5.1 Linux上安装Redis"></a><strong>1.5.1 Linux上安装Redis</strong></h3><p>&emsp;&emsp;Linux上安装Redis的方式有两种：第一种是通过各个操作系统的软件管理软件进行安装，如CentOS的yum管理工具，Ubuntu的apt（Docker应该也属于第一种吧）。第二种是通过源码的方式安装。</p><p>&emsp;&emsp;Redis更新较快，所以一般推荐第二种安装方式。</p><p>&emsp;&emsp;安装步骤只需要六步即可，如下案例安装3.0.7版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-3.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-3.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s redis-3.0.7 redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>下载指定版本的Redis源码压缩包到当前目录。</li><li>解压缩Redis源码压缩包。</li><li>建立一个redis目录的软连接，指向redis-3.0.7（为了不把redis目录固定在指定版本，有利于未来版本升级，算是一种安装软件的好习惯）。</li><li>进入redis目录。</li><li>编译（编译前确保操作系统已安装gcc）。</li><li>安装（将Redis的相关运行软件放在/usr/local/bin/下，从而可以在任意目录下执行Redis的命令）。</li></ol></blockquote><p>&emsp;&emsp;如下图安装5.0.8版本。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010101.png" alt=""></p><h3 id="1-5-2-Windows上安装Redis"><a href="#1-5-2-Windows上安装Redis" class="headerlink" title="1.5.2 Windows上安装Redis"></a><strong>1.5.2 Windows上安装Redis</strong></h3><p>&emsp;&emsp;Redis官方并不支持Windows操作系统，但微软的开源技术组在GitHub上维护了一个Redis的分支：<a href="https://github.com/microsoftarchive/redis" target="_blank" rel="noopener">microsoftarchive/redis</a>。</p><p>&emsp;&emsp;首先在上述开源项目中找到想要安装的版本并下载：<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a></p><p>&emsp;&emsp;解压并在根目录打开命令行，可以把redis路径添加到环境变量，方便以后使用。</p><h3 id="1-5-3-配置、启动、操作、关闭Redis"><a href="#1-5-3-配置、启动、操作、关闭Redis" class="headerlink" title="1.5.3 配置、启动、操作、关闭Redis"></a><strong>1.5.3 配置、启动、操作、关闭Redis</strong></h3><p>&emsp;&emsp;Redis安装后，src和/usr/local/bin/下会多出几个redis开头的文件，被称作Redis Shell。类似于JDK中的可执行文件，这些文件可以帮助我们做很多事情。</p><table><thead><tr><th style="text-align:left">可执行文件</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">redis-server</td><td style="text-align:left">启动Redis</td></tr><tr><td style="text-align:left">redis-cli</td><td style="text-align:left">Redis命令行客户端</td></tr><tr><td style="text-align:left">redis-benchmark</td><td style="text-align:left">Redis基准测试工具</td></tr><tr><td style="text-align:left">redis-check-aof</td><td style="text-align:left">Redis  AOF持久化文件检查和修复工具</td></tr><tr><td style="text-align:left">redis-check-dump</td><td style="text-align:left">Redis  RDB持久化文件检查和修复工具</td></tr><tr><td style="text-align:left">redis-sentinel</td><td style="text-align:left">启动Redis Sentinel</td></tr></tbody></table><h4 id="1-启动Redis"><a href="#1-启动Redis" class="headerlink" title="1.  启动Redis"></a><strong>1.  启动Redis</strong></h4><p>&emsp;&emsp;首先启动Redis，有三种方式：默认配置、运行配置、配置文件启动。</p><h5 id="（1）默认配置"><a href="#（1）默认配置" class="headerlink" title="（1）默认配置"></a><strong>（1）默认配置</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010102.png" alt=""></p><p>&emsp;&emsp;由上述信息可以得知，我们当前版本是5.0.8，默认端口6379，线程ID-30710，Redis建议使用配置文件启动。</p><p>&emsp;&emsp;因为直接启动无法自定义配置，所以生产环境不会采用这种方式。</p><h5 id="（2）运行配置"><a href="#（2）运行配置" class="headerlink" title="（2）运行配置"></a><strong>（2）运行配置</strong></h5><p>&emsp;&emsp;redis-server要加上修改配置名和值（可以多对），没有配置的将使用默认配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server --configkey1 configValue1 --configkey2 configValue2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比如我们想修改端口号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server --port 6380</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当配置较多或是想保存配置到文件中时，不建议使用这种方式。</p><h5 id="（3）配置文件启动"><a href="#（3）配置文件启动" class="headerlink" title="（3）配置文件启动"></a><strong>（3）配置文件启动</strong></h5><p>&emsp;&emsp;将配置写到文件中，比如写到/opt/redis/redis.conf，然后只须执行下列命令即可启动Redis。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server /opt/redis/redis.conf</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis有60多个配置，此处只给出比较重要的四个，后续会专门做整理介绍。</p><table><thead><tr><th style="text-align:left">配置名</th><th style="text-align:left">配置说明</th></tr></thead><tbody><tr><td style="text-align:left">port</td><td style="text-align:left">端口</td></tr><tr><td style="text-align:left">logfile</td><td style="text-align:left">日志文件</td></tr><tr><td style="text-align:left">dir</td><td style="text-align:left">Redis工作目录（存放持久化文件和日志文件）</td></tr><tr><td style="text-align:left">daemonize</td><td style="text-align:left">是否以守护线程的方式启动Redis</td></tr></tbody></table><p>&emsp;&emsp;配置文件启动的方式具有灵活性，所以大部分生产环境会使用这种方式。</p><h4 id="2-Redis命令行客户端"><a href="#2-Redis命令行客户端" class="headerlink" title="2.  Redis命令行客户端"></a><strong>2.  Redis命令行客户端</strong></h4><p>&emsp;&emsp;我们已经启动了Redis服务，接下来是使用redis-cli连接和操作Redis服务。redis-cli有两种方式来连接Redis服务器。</p><h5 id="（1）交互式方式"><a href="#（1）交互式方式" class="headerlink" title="（1）交互式方式"></a><strong>（1）交互式方式</strong></h5><p>&emsp;&emsp;通过 redis-cli -h {host} -p {port} 的方式连接到Redis服务，之后所有的操作都通过交互的方式实现，不需要再执行 redis-cli 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p &#123;port&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010103.png" alt=""></p><h5 id="（2）命令方式"><a href="#（2）命令方式" class="headerlink" title="（2）命令方式"></a><strong>（2）命令方式</strong></h5><p>&emsp;&emsp;通过 redis-cli -h {host} -p {port}  {command}直接得到命令结果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010104.png" alt=""></p><p>&emsp;&emsp;没有 -h 参数则默认连接127.0.0.1；没有 -p 参数则默认6379端口。</p><h4 id="3-停止Redis服务"><a href="#3-停止Redis服务" class="headerlink" title="3.  停止Redis服务"></a><strong>3.  停止Redis服务</strong></h4><p>&emsp;&emsp;Redis提供了shutdown命令来停止Redis服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli shutdown</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意：</p><ol><li><p>Redis关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式。</p></li><li><p>除了shutdown命令外，也可以通过kill进程号的方式关闭Redis，但请不要粗暴的使用kill -9 强制杀死Redis服务，这样不但不会做持久化操作，还会造成缓冲区不能正常关闭，极端情况下会造成AOF和复制丢失数据的情况。</p></li><li><p>shutdown还有一个参数，表示是否在关闭Redis前生成持久化文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    $ redis-cli shutdown nosave|save</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><hr><h2 id="1-6-版本命名"><a href="#1-6-版本命名" class="headerlink" title="1.6 版本命名"></a><strong>1.6 版本命名</strong></h2><p>&emsp;&emsp;Redis借鉴了Linux对于版本号的命名规则：版本号第二位如果是奇数，表示非稳定版本（unstable），如果是偶数，表示稳定版本（stable），当然还有Beta版本。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（一）Redis简介，内容包括：简介，特性，使用场景，如何使用，安装，版本命名。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
</feed>
