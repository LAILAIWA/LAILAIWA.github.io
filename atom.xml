<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-10-10T08:16:55.435Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>林沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ（六）运维</title>
    <link href="http://linyishui.top/2020100801.html"/>
    <id>http://linyishui.top/2020100801.html</id>
    <published>2020-10-08T15:34:48.000Z</published>
    <updated>2020-10-10T08:16:55.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（六）运维"><a href="#RabbitMQ（六）运维" class="headerlink" title="RabbitMQ（六）运维"></a>RabbitMQ（六）运维</h1><h2 id="第一节-集群搭建"><a href="#第一节-集群搭建" class="headerlink" title="第一节 集群搭建"></a>第一节 集群搭建</h2><p>单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键。</p><p>RabbitMQ 集群也不能保证消息的万无一失，即将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式。当集群中一个 RabbitMQ 节点崩溃时，该节点上的所有队列中的消息也会丢失。 RabbitMQ 集群中的所有节点都会备份所有的元数据信息， 包括以下内容：</p><ul><li><strong>队列元数据</strong>：队列的名称及属性； </li><li><strong>交换器</strong>：交换器的名称及属性： </li><li><strong>绑定关系元数据</strong>：交换器与队列或者交换器与交换器之间的绑定关系； </li><li><strong>vhost 元数据</strong>：为 vhost 内的队列、交换器和绑定提供命名空间及安全属性。</li></ul><p>但是不会备份消息（当然通过特殊的配置比如镜像队列可以解决这个问题）。基于存储空间和性能的考虑，在 RabbitMQ 集群中创建队列，<strong>集群只会在单个节点而不是在所有节点上创建队列的进程并包含完整的队列信息</strong>（元数据、状态、内容）。这样只有队列的宿主节点，即所有者节点知道队列的所有信息，所有其他非所有者节点只知道队列的元数据和指向该队列存在的那个节点的指针。因此当集群节点崩溃时，该节点的队列进程和关联的绑定都会消失。附加在那些队列上的消费者也会丢失其所订阅的信息，井且任何匹配该队列绑定信息的新消息也都会消失。</p><p>不同于队列那样拥有自己的进程，交换器其实只是一个名称和绑定列表。当消息发布到交换器时，实际上是由所连接的信道将消息上的路由键同交换器的绑定列表进行比较，然后再路由消息。当创建一个新的交换器时， RabbitMQ 所要做的就是<strong>将绑定列表添加到集群中的所有节点上</strong>。这样，每个节点上的每条信道都可以访问到新的交换器了。</p><p>创建集群的过程可以看作向集群中添加节点的过程。</p><h3 id="1-1-多机多节点配置"><a href="#1-1-多机多节点配置" class="headerlink" title="1.1 多机多节点配置"></a>1.1 多机多节点配置</h3><p>多机多节点主要是指在每台机器中部署一个 RabbitMQ 服务节点，进而由多台机器组成一个 RabbitMQ 集群。</p><p>假设这里一共有三台物理主机，均己正确地安装了 RabbitMQ ，且主机名分别为 node1、node2、node3。RabbitMQ 集群对延迟非常敏感，应当只在本地局域网内使用 。<strong>在广域网中不应该使用集群，而应该使用 Federation 或者 Shovel 来代替</strong>。</p><h4 id="1-1-1-配置流程"><a href="#1-1-1-配置流程" class="headerlink" title="1.1.1 配置流程"></a>1.1.1 配置流程</h4><ul><li><p>第一步，配置各个节点的 hosts 文件，让各个节点都能互相识别对方的存在。</p><ul><li><p>比如在 Linux 系统中可以编辑 <code>/etc/hosts</code> 文件，在其上添加地址与节点名称的映射信息：</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.2</span> <span class="selector-tag">node1</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.3</span> <span class="selector-tag">node2</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.4</span> <span class="selector-tag">node3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>第二步，编辑 RabbitMQ 的 cookie 文件，以确保各个节点的 cookie 文件使用的是同一个值。</p><ul><li><p>可以读取 node1 节点的 cookie 值，然后将其复制到 node2、node3 节点中。</p></li><li><p>cookie 文件默认路径为：<code>/var/lib/rabbitmq/.erlang.cookie</code> 或者 <code>$HOME/.erlang.cookie</code> 。</p></li><li><p>集群中的 RabbitMQ 节点需要通过交换密钥令牌以获得相互认证。</p></li><li><p>如果节点的密钥令牌不一致，那么在配置节点时就会有如下的报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster rabbit@node1</span></span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1</span><br><span class="line">Error: unable to connect to nodes [rabbit@node1]: nodedown </span><br><span class="line"></span><br><span class="line">DIAGNOSTICS </span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">attempted to contact: [rabbit@node1] </span><br><span class="line"></span><br><span class="line">rabbit@node1:</span><br><span class="line">* connected to epmd (port 4369) on node1</span><br><span class="line">* epmd reports node rabbit runn ng on port 25672</span><br><span class="line">* TCP connection succeeded but Erlang distribution failed </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意此处</span></span><br><span class="line">* Authentication failed (rejected by the remote node), please check the Erlang cookie </span><br><span class="line"></span><br><span class="line">current node details:</span><br><span class="line">- node name: 'rabbitmq-cli-53@node2'</span><br><span class="line">- home dir: /root</span><br><span class="line">- cookie hash: kLtTY75JJGZnZpQF7CqnYg==</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第三步，配置集群。</p><ul><li><p>配置集群有三种方式 ：</p><ul><li>通过 rabbitmqctl 工具配置；</li><li>通过 rabbitmq.config 配置文件配置；</li><li>通过 rabbitmq-autocluster 插件配置。</li></ul></li><li><p>示例通过 rabbitmqctl 工具配置：</p><ul><li><p>首先启动 node1、node2、node3 这几个节点的 RabbitMQ 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node2 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node3 ~]# rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li><li><p>开启后这3个节点目前都是以独立节点存在的单个集群，查看各个节点的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl cluster_status </span><br><span class="line">[root@node2 ~]# rabbitmqctl cluster_status </span><br><span class="line">[root@node3 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li><li><p>接下来为了将这3个节点组成一个集群，需要以 node1 节点为基准，将 node2 和 node3 节点加入 node1 节点的集群中。这3个节点是平等的，如果想调换彼此的加入顺序也未尝不可。</p><ol><li><p>首先将 node2 节点加入 node1 节点的集群中：（此时再通过 <code>rabbitmqctl cluster_status</code> 可以看到两个节点的信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabb t@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl join cluster rabbit@node1</span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1</span><br><span class="line">[root@node2 ~]# rabbitmqctl start_ app</span><br><span class="line">Starting node rabbit@node2</span><br></pre></td></tr></table></figure></li><li><p>再将 node3 节点也加入 node1 节点所在的集群中，步骤同上。</p></li></ol></li></ul></li></ul></li></ul><h4 id="1-1-2-节点关闭的几种情况"><a href="#1-1-2-节点关闭的几种情况" class="headerlink" title="1.1.2 节点关闭的几种情况"></a>1.1.2 节点关闭的几种情况</h4><ul><li><p>如果集群中某个节点关闭了，会使集群处于怎样的状态？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭 node2 节点</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 node1 节点查看集群状态时，会发现 running_nodes 已没有 node2</span></span><br><span class="line">[root@node1 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li><li><p>如果关闭了集群中的所有节点，则<strong>需要确保在启动的时候最后关闭的那个节点是第一个启动的</strong>。</p><ul><li>如果第一个启动的不是最后关闭的节点，那么这个节点会等待最后关闭的节点启动。这个等待时间是 30 秒，如果没有等到，那么这个先启动的节点也会失败。</li><li>在最新的版本中会有重试机制，默认重试 10 次 30 秒以等待最后关闭的节点启动。</li></ul></li><li><p>如果最后一个关闭的节点最终由于某些异常而无法启动，则可以通过 <code>rabbitmqctl forget_cluster_node</code> 命令来将此节点剔出当前集群。</p></li><li><p>如果集群中的所有节点由于某些非正常因素，比如断电而关闭，那么集群中的节点都会认为还有其他节点在它后面关闭，此时需要调用 <code>rabbitmqctl force_boot</code> 命令来启动一个节点，之后集群才能正常启动。</p></li></ul><h3 id="1-2-集群节点类型"><a href="#1-2-集群节点类型" class="headerlink" title="1.2 集群节点类型"></a>1.2 集群节点类型</h3><h4 id="1-2-1-两种节点类型"><a href="#1-2-1-两种节点类型" class="headerlink" title="1.2.1 两种节点类型"></a>1.2.1 两种节点类型</h4><p>使用 <code>rabbitmqctl cluster_status</code> 命令来查看集群状态时会有 <code>{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]</code> 这一项信息，其中的 disc 标注了 RabbitMQ 点的类型。</p><p>不论是单一节点还是集群节点，有两种类型：</p><ul><li><strong>内存节点</strong>：将所有的队列、 交换器、绑定关系、用户、权限和 vhost 的元数据定义都存储在内存中；</li><li><strong>磁盘节点</strong>：存放到磁盘中。所以单节点集群只能是磁盘节点，否则重启后会丢失系统的配置信息。</li></ul><h4 id="1-2-2-如何指定或切换节点类型"><a href="#1-2-2-如何指定或切换节点类型" class="headerlink" title="1.2.2 如何指定或切换节点类型"></a>1.2.2 如何指定或切换节点类型</h4><p>将节点指定为内存节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 node2 节点加入 node1 节点的时候可以指定 node2 节点的类型为内存节点</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl join_cluster rabbit@node1 --ram</span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以在集群搭建好以后再通过 rabbitmqctl change_cluster_node_type &#123;disc, ram&#125;命令切换类型</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl stop_app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl change cluster node type disc</span><br><span class="line">Turning rabbit@node2 into a disc node</span><br><span class="line">[root@node2 ~]# rabbitmqctl start app</span><br><span class="line">Starting node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><h4 id="1-2-3-如何选择内存还是磁盘节点"><a href="#1-2-3-如何选择内存还是磁盘节点" class="headerlink" title="1.2.3 如何选择内存还是磁盘节点"></a>1.2.3 如何选择内存还是磁盘节点</h4><p>在集群中创建队列、交换器或者绑定关系的时候，这些操作直到所有集群节点都成功提交元数据变更后才会返回。对内存节点来说，这意味着将变更写入内存；而对于磁盘节点来说，这意味着昂贵的磁盘写入操作。内存节点可以提供出色的性能，磁盘节点能够保证集群配置信息的高可靠性，如何在这两者之间进行抉择呢？</p><ul><li>首先集群中至少有一个磁盘节点；</li><li>新增或删除节点时需要将变更通知到至少一个磁盘节点；</li><li>如果只有一个磁盘节点，而且它刚好崩溃了，集群可以继续发送或者接收消息，但是不能执行创建队列、交换器、绑定关系、用户，以及更改权限、添加或删除集群节点的操作了。<strong>即唯一磁盘节点崩溃时，集群可以继续运行，但不能变更</strong>。</li><li>在内存节点重启后，它们会连接到预先配置的磁盘节点，下载当前集群元数据的副本。当在集群中添加内存节点时，确保告知其所有的磁盘节点（内存节点唯一存储到磁盘的元数据信 息是集群中磁盘节点的地址）。只要内存节点可以找到至少一个磁盘节点，那么它就能在重启后重新加入集群中。</li><li>除了使用RPC功能时，大多数的操作就是生产或者消费消息。为了确保集群信息的可靠性，或者在不确定使用磁盘节点或者内存节点的时候，<strong>建议全部使用磁盘节点</strong>。</li></ul><h3 id="1-3-剔除单个节点"><a href="#1-3-剔除单个节点" class="headerlink" title="1.3 剔除单个节点"></a>1.3 剔除单个节点</h3><h4 id="1-3-1-如何从集群中删除一个节点"><a href="#1-3-1-如何从集群中删除一个节点" class="headerlink" title="1.3.1 如何从集群中删除一个节点"></a>1.3.1 如何从集群中删除一个节点</h4><p>两种方案：</p><ul><li><p>第一种：适合节点不再运行RabbitMQ的情况。</p><ul><li>首先在 node2 节点上执行 <code>rabbitmqctl stop_app</code> 或者 <code>rabbitmqctl stop</code> 命令来关闭 RabbitMQ 服务；</li><li>然后再在 node1 节点或者 node3 节点上执行 <code>rabbitmqctl forget_cluster_node rabbit@node2</code> （可以添加 <code>-offline</code> 即使非运行状态也可以生效）命令将 node2 节点剔除出去。</li></ul></li><li><p>第二种：只是简单的将节点从集群中移出，变成单一节点。</p><ul><li><p>在 node2 上执行 <code>rabbitmqctl reset</code> 命令。此命令将清空节点的状态，并将其恢复到空白状态，也会和集群中的磁盘节点进行通信，告诉它们该节点正在离开集群。</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl start app</span><br><span class="line">Starting node rabbit@node2</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-4-集群节点的升级"><a href="#1-4-集群节点的升级" class="headerlink" title="1.4 集群节点的升级"></a>1.4 集群节点的升级</h3><h4 id="1-4-1-独立节点的升级"><a href="#1-4-1-独立节点的升级" class="headerlink" title="1.4.1 独立节点的升级"></a>1.4.1 独立节点的升级</h4><p>只须先关闭原来的服务，然后解压新的版本再运行即可。不过要确保原节点的 Mnesia 中的数据不被变更，且新节点中的 Mnesia 路径的指向要与原节点中的相同。</p><h4 id="1-4-2-集群节点的升级步骤"><a href="#1-4-2-集群节点的升级步骤" class="headerlink" title="1.4.2 集群节点的升级步骤"></a>1.4.2 集群节点的升级步骤</h4><p>单个节点的升级步骤：</p><ol><li>关闭所有节点的服务，注意采用 <code>rabbitmqctl stop</code> 命令关闭。</li><li>保存各个节点的 Mnesia 数据。</li><li>解压新版本的 RabbitMQ 到指定的目录。</li><li>指定新版本的 Mnesia 路径为步骤2中保存的 Mnesia 数据路径。</li><li>启动新版本的服务，注意先重启原版本中最后关闭的那个节点。</li></ol><p>步骤4和步骤5可以一起操作，比如执行 <code>RABBITMQ_MNESIA_BASE=/opt/mnesia rabbitmq-server-detached</code> 命令，其中 <code>/opt/mnesia</code> 为原版本保存 Mnesia 数据的路径。</p><p><strong>在对不同版本升级的过程中，最好先测试两个版本互通的可能性，然后再在线上环境中实地操作。</strong></p><p>如果原集群上的配置和数据都可以舍弃，则可以删除原版本的 RabbitMQ ，然后再重新安装配置即可：如果配置和数据不可丢弃 ，则按照上面所述保存元数据，之后再关闭所有生产者，并等待消费者消费完队列中的所有数据，紧接着关闭所有消费者，然后重新安装 RabbitMQ 重建元数据等。</p><p>也可以利用集群迁移直接转为新的集群。</p><h3 id="1-5-单机多节点配置"><a href="#1-5-单机多节点配置" class="headerlink" title="1.5 单机多节点配置"></a>1.5 单机多节点配置</h3><p>有时候不得不在单台物理机器上去创建一个多 RabbitMQ 服务节点的集群，需要<strong>确保每个节点都有独立的名称、数据存储位置、端口号（包括插件的端口号）等</strong>。</p><p>我们在主机名称为 node1 的机器上创建一个由 rabbit1@node1、rabbit2@node 1 和 rabbit3@node1 这3个节点组成 RabbitMQ 集群。</p><ul><li><p>为每个 RabbitMQ 服务节点设置不同的端口号和节点名称来启动相应的服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5672 RABBITMQ NODENAME=rabbit1</span><br><span class="line">rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5673 RABBITMQ NODENAME=rabbit2</span><br><span class="line">rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5674 RABBITMQ NODENAME=rabbit3</span><br><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li><li><p>在启动 rabbit1@node1 节点的服务之后，继续启动 rabbit2@node1 和 rabbit@node1 服务节点会遇到启动失败的情况。</p><ul><li><p>这种情况大多数是由于配置发生了冲突而造成后面的服务节点启动失 败，需要进一步确认是否开启了某些功能，比如 RabbitMQ Management 插件。</p></li><li><p>如果开启了 RabbitMQ Management 插件，就需要为每个服务节点配置一个对应插件端口号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5672 RABBITMQ NODENAME=rabbit1 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [&#123;port,15672)]" rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5673 RABBITMQ NODENAME=rabbit2 RABBITMQ_SERVER_START_ARGS="- rabbitmq_management listener [&#123;port, 15673&#125;]" rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5674 RABBITMQ NODENAME=rabbit3 RABBITMQ_SERVER_START_ARGS="- rabbitmq_management listener [&#123;port,15674&#125;]" rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动各节点服务之后，将 rabbit2@node1 节点加入 rabbit1@node1 集群之中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~] # rabbitmqctl -n rabbit2@node1 stop app</span><br><span class="line">Stopping rabbit application on node rabbit2@node1</span><br><span class="line">[root@node1 ~J # rabbitmqctl -n rabbit2@node1 reset</span><br><span class="line">Resetting node rabbit2@node1</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 join_cluster rabbit1@node1</span><br><span class="line">Clustering node rabbit2@node1 with rabbit1@node1</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 start_app</span><br><span class="line">Starting node rabbit2@node1</span><br></pre></td></tr></table></figure></li><li><p>执行相似的操作将 rabbit3@node1 也加入进来，并通过 <code>rabbitmqctl cluster_status</code> 命令来查看各个服务节点的集群状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit1@node1 cluster_status</span><br><span class="line">Cluster status of de rabbit1@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit3@node1, rabbit2@node1, rabbit1@node1]&#125;,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125;,</span><br><span class="line">&#123;alarms, [&#123;rabbit3@node1, []&#125;, &#123;rabbit2@node1, []&#125;, &#123;rabbit1@node1, []&#125;]&#125;]</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 cluster_status</span><br><span class="line">Cluster status of node rabbit2@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit3@node1, rabbit1@node1, rabbit2@node1]&#125;,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125; ,</span><br><span class="line">&#123;alarms, [&#123;rabbit3@node1, []&#125; , &#123;rabbit1@node1, []&#125;, &#123;rabbit2@node1, []&#125;]&#125;]</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit3@node1 cluster_status</span><br><span class="line">Cluster status of node rabbit3@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125; ,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125; ,</span><br><span class="line">&#123;alarms, [&#123;rabbit1@node1, []&#125;, &#123;rabbit2@node1, []&#125;, &#123;rabbit3@node1, []&#125;]&#125;]</span><br></pre></td></tr></table></figure></li></ul><p>RabbitMQ 单机多节点配置大多用于实验性论证，生产环境还是选用多机多节点的集群。</p><h2 id="第二节-查看服务日志"><a href="#第二节-查看服务日志" class="headerlink" title="第二节 查看服务日志"></a>第二节 查看服务日志</h2><p>RabbitMQ 日志中包含各种类型的事件，比如<strong>连接尝试、服务启动、插件安装及解析请求时的错误等</strong>。</p><p>RabbitMQ 的日志默认存放在 <code>$RABBITMQ_HOME/var/log/rabbitmq</code> 文件夹内。在这个文件夹内 RabbitMQ 会创建两个日志文件：</p><ul><li><code>RABBITMQ_NODENAME-sasl.log</code> ：SASL (System Application Support Libraries，系统应用程序支持库）是库的集合，作为 Erlang-OTP 发行版的一部分。提供了一系列标准，其中之一是日志记录格式。<strong>当 RabbitMQ 记录 Erlang 相关信息时，它会将日志写入文件<code>RABBITMQ_NODENAME-sasl.log</code> </strong>。</li><li><code>RABBITMQ_NODENAME.log</code> ：RabbitMQ 服务日志指的就是这个文件。</li></ul><h3 id="2-1-启动RabbitMQ服务"><a href="#2-1-启动RabbitMQ服务" class="headerlink" title="2.1 启动RabbitMQ服务"></a>2.1 启动RabbitMQ服务</h3><ul><li>使用 <code>rabbitmq-server -detached</code> 命令启动RabbitMQ服务，顺带会启动 Erlang 虚拟机和RabbitMQ应用服务。</li><li>使用 <code>rabbitmqctl start_app</code> 用来启动 RabbitMQ 应用服务（启动成功的前提是 Erlang 虚拟机运转正常）。</li><li>如果使用 <code>rabbitmqctl stop_app</code> 命令关闭的 RabbitMQ 应用服务，那么在使用 <code>rabbitmqctl start_app</code> 命令开启 bbitMQ 应用服务时的启动日志和 <code>rabbitmq-server</code> 的启动日志相同。</li></ul><p>相关服务日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RabbitMQ 版本号、Erlang 的版本号</span></span><br><span class="line"><span class="string">Starting</span> <span class="string">RabbitMQ</span> <span class="number">3.6</span><span class="number">.2</span> <span class="string">on</span> <span class="string">Erlang</span> <span class="number">19.1</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2007</span><span class="bullet">-2016</span> <span class="string">Pivotal</span> <span class="string">Software,</span> <span class="string">Inc</span> <span class="string">.</span></span><br><span class="line"><span class="string">Licensed</span> <span class="string">under</span> <span class="string">the</span> <span class="string">MPL.</span> <span class="string">See</span> <span class="attr">http://www.rabbitmq.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO REPORT 和 WARNING REPORT 表示日志级别</span></span><br><span class="line"><span class="comment"># RabbitMQ 服务节点名称、cookie 的 hash 值、配置文件地址</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:08</span> <span class="string">===</span></span><br><span class="line"><span class="string">node</span> <span class="string">:</span> <span class="string">rabbit@node1</span></span><br><span class="line"><span class="string">home</span> <span class="string">dir</span> <span class="string">:</span> <span class="string">/root</span></span><br><span class="line"><span class="string">config</span> <span class="string">file(s)</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/etc/rabbitmq/rabbitmq.config</span> <span class="string">(not</span> <span class="string">found)</span></span><br><span class="line"><span class="string">cookie</span> <span class="string">hash</span> <span class="string">:</span> <span class="string">VCwbL3S9/ydrGgVsrLjVkA==</span></span><br><span class="line"><span class="string">log</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/var/log/rabbitmq/rabbit@node1.log</span></span><br><span class="line"><span class="string">sasl</span> <span class="string">log</span> <span class="string">:</span> <span class="string">pt/rabbitmq</span> <span class="string">/var/</span> <span class="string">log/rabbitmq/rabbit@node1-sasl.log</span></span><br><span class="line"><span class="string">database</span> <span class="string">dir</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存限制</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span> </span><br><span class="line"><span class="string">Memory</span> <span class="string">limit</span> <span class="string">set</span> <span class="string">to</span> <span class="number">3148</span><span class="string">MB</span> <span class="string">of</span> <span class="number">7872</span><span class="string">MB</span> <span class="string">total.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 磁盘限制</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Disk</span> <span class="string">free</span> <span class="string">limit</span> <span class="string">set</span> <span class="string">to</span> <span class="number">50</span><span class="string">MB</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Limiting</span> <span class="string">to</span> <span class="string">approx</span> <span class="number">924</span> <span class="string">file</span> <span class="string">handles</span> <span class="string">(829</span> <span class="string">sockets)</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">FHC</span> <span class="string">read</span> <span class="attr">buffering:</span> <span class="string">OFF</span></span><br><span class="line"><span class="string">FHC</span> <span class="string">write</span> <span class="attr">buffering:</span> <span class="string">ON</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Database</span> <span class="string">rectory</span> <span class="string">at</span> <span class="string">/opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node1</span> <span class="string">is</span></span><br><span class="line"><span class="string">empty.</span> <span class="string">Initialising</span> <span class="string">from</span> <span class="string">scratch...</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Priority</span> <span class="string">queues</span> <span class="string">enabled,</span> <span class="string">real</span> <span class="string">BQ</span> <span class="string">is</span> <span class="string">rabbit_variable_queue</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Adding</span> <span class="string">vhost</span> <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认账户 guest 的创建及权限配置</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">user</span> <span class="string">'guest'</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Setting</span> <span class="string">user</span> <span class="string">tags</span> <span class="string">for</span> <span class="string">user</span> <span class="string">'guest'</span> <span class="string">to</span> <span class="string">[admistrator]</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Setting</span> <span class="string">permissions</span> <span class="string">for</span> <span class="string">'guest'</span> <span class="string">in</span> <span class="string">to</span> <span class="string">'.*'</span><span class="string">,</span> <span class="string">'.*'</span><span class="string">,</span> <span class="string">'.*'</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="attr">transient:</span> <span class="string">using</span> <span class="string">rabbit_msg_store_ets_index</span> <span class="string">to</span> <span class="string">provide</span> <span class="string">index</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="string">persistent</span> <span class="string">using</span> <span class="string">rabbit_msg_store_ets_index</span> <span class="string">to</span> <span class="string">provide</span> <span class="string">index</span></span><br><span class="line"></span><br><span class="line"><span class="string">=WARNING</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="attr">persistent:</span> <span class="string">rebuilding</span> <span class="string">indices</span> <span class="string">from</span> <span class="string">scratch</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">started</span> <span class="string">TCP</span> <span class="string">Listener</span> <span class="string">on</span> <span class="string">[::]:5672</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="bullet">-Oct-2017</span> <span class="string">::10:52</span> <span class="string">:</span> <span class="number">10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Server</span> <span class="string">startup</span> <span class="string">complete;</span> <span class="number">0</span> <span class="string">plugins</span> <span class="string">started.</span></span><br></pre></td></tr></table></figure><p>日志级别：（通过 <code>rabbitmq.config</code> 配置文件中 <code>log_levels</code> 参数来设置，默认为 <code>[{connection, info}]</code> ）</p><ul><li>none</li><li>error</li><li>warning</li><li>info</li><li>debug</li></ul><h3 id="2-2-关闭RabbitMQ服务"><a href="#2-2-关闭RabbitMQ服务" class="headerlink" title="2.2 关闭RabbitMQ服务"></a>2.2 关闭RabbitMQ服务</h3><p>如果使用 <code>rabbitmqctl stop</code> 命令，会将 Erlang 虚拟机一同关闭，而 <code>rabbitmqctl stop_app</code> 只关闭 RabbitMQ 应用服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Stopping</span> <span class="string">RabbitMQ</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">stopped</span> <span class="string">TCP</span> <span class="string">Listener</span> <span class="string">on</span> <span class="string">[::]:5672</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Stopped</span> <span class="string">RabbitMQ</span> <span class="string">application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用 rabbitmqctl stop 来进行关闭操作，则会多出下面的日志信息，即关闭 Erlang 虚拟机。</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Halting</span> <span class="string">Erlang</span> <span class="string">VM</span></span><br></pre></td></tr></table></figure><h3 id="2-3-建立集群"><a href="#2-3-建立集群" class="headerlink" title="2.3 建立集群"></a>2.3 建立集群</h3><p>举例将节点 rabbit@node2 和 rabbit@node1 组成一个集群：</p><ul><li><p>首先在 rabbit@node2 中执行 <code>rabbitmq-server -detached</code> 开启 Erlang 虚拟机和 RabbitMQ 应用服务，之后再执行 <code>rabbitmqctl stop_app</code> 来关闭 RabbitMQ 应用服务，之后需要重置节点 rabbit@node2 中的数据 <code>rabbitmqctl reset</code> ，在 rabbit@node2 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:25:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Resetting</span> <span class="string">Rabbit</span></span><br></pre></td></tr></table></figure></li><li><p>在 rabbit@node2 节点上执行 <code>rabbitmqctl join_clcuster rabbit@node1</code> ，将其加 rabbit@node1 中以组成一个集群，在 rabbit@node2 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:30:46</span> <span class="string">===</span></span><br><span class="line"><span class="string">Clustering</span> <span class="string">with</span> <span class="string">[rabbit@node1]</span> <span class="string">as</span> <span class="string">disc</span> <span class="string">node</span></span><br></pre></td></tr></table></figure></li><li><p>同时在 rabbit@node1 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:30:56</span> <span class="string">===</span></span><br><span class="line"><span class="string">node</span> <span class="string">rabbit@node2</span> <span class="string">up</span></span><br></pre></td></tr></table></figure></li><li><p>如果此时在 rabbit@node2 节点上执行 <code>rabbitmqctl stop_app</code> 的动作，那么在 <code>rabbit@node1</code> 节点中会有如下信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">rabbit</span> <span class="string">on</span> <span class="string">node</span> <span class="string">rabbit@node2</span> <span class="string">down</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Keep</span> <span class="string">rabbit@node2</span> <span class="attr">listeners:</span> <span class="string">the</span> <span class="string">node</span> <span class="string">is</span> <span class="string">already</span> <span class="string">back</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h3><p>客户端与 RabbitMQ 建立连接：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">14</span><span class="bullet">-0</span><span class="attr">ct-2017:</span> <span class="string">:16:24:55</span> <span class="string">===</span></span><br><span class="line"><span class="string">accepting</span> <span class="string">AMQP</span> <span class="string">connection</span> <span class="string">&lt;0.5865.0&gt;</span> <span class="string">(192.168.0.9:61601</span> <span class="bullet">-&gt;</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span><span class="string">:5672)</span></span><br></pre></td></tr></table></figure><p>客户端强制中断连接时：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=WARNING</span> <span class="string">REPORT====</span> <span class="number">14</span><span class="attr">-Jul-2017:</span> <span class="string">:16:36:57</span> <span class="string">===</span></span><br><span class="line"><span class="string">closing</span> <span class="string">AMQP</span> <span class="string">connection</span> <span class="string">&lt;0.5909.0&gt;</span> <span class="string">(192.168.0.9:61629</span> <span class="bullet">-&gt;</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span><span class="string">:5672)</span></span><br><span class="line"><span class="string">connection_closed_abruptly</span></span><br></pre></td></tr></table></figure><h3 id="2-5-日常积累各种操作对应日志格式"><a href="#2-5-日常积累各种操作对应日志格式" class="headerlink" title="2.5 日常积累各种操作对应日志格式"></a>2.5 日常积累各种操作对应日志格式</h3><p>可以通过尝试各种的操作以收集相应的服务日志，之后组成一个知识集，这个知识集不单单指一个日志列表，需要通过后期的强化训练掌握其规律，让这个知识集了然于心 。在真正遇到异常故障的时候可以通过查看服务日志来迅速定位问题，之后再采取相应的措施以解决问题。</p><p>比如在执行任何 RabbitMQ 操作之前，都会打开一个新的窗口运 <code>tail -f $RABBITMQ_HOME/var/log/rabbitmq/rabbit@$HOSTNAME.log -n 200</code> 命令来实时查看相应操作所对应的服务日志是什么，久而久之即可在脑海中建立一个相对完备的“知识集”。</p><h3 id="2-6-日志文件管理"><a href="#2-6-日志文件管理" class="headerlink" title="2.6 日志文件管理"></a>2.6 日志文件管理</h3><p>RabbitMQ 中可以通过 <code>rabbitmqctl rotate_logs {suffix}</code> 命令来轮换日志，比如手工切换当前的日志：<code>rabbitmqctl rotate_logs.bak</code> ，之后可以看到在日志目录下会建立新的日志文件，并且将老的日志文件以添加 <code>.bak</code> 后缀的方式进行区分保存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 rabbitmq]# ls - al</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 22646 Jul 23 00:50 rabbit@node1.log.bak</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1-sasl.log</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1-sasl.log.bak</span><br></pre></td></tr></table></figure><p>也可以执行一个定时任务，比如使用 <code>Linux crontab</code> ，以当前日期为后缀，每天执行一次切换日志的任务，这样在后面需要查阅日志的时候可以根据日期快速定位到相应的日志文件。</p><p>RabbitMQ 还可以通过程序化的方式来查看相应的日志， 默认会创建一些交换器， 其中 <code>amq.rabbitmq.log</code> 就是用来收集 RabbitMQ 日志的，集群中所有的服务日志都会发往这个交换器中。这个交换器的类型为 topic ，可以收集如前面所说的 debug、info、warning、error 4个级别的日志。</p><p>首先确认是否创建 <code>amq.rabbitmq.log</code> 交换器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl list_exchanges</span><br><span class="line">Listing exchanges for vhost / ...</span><br><span class="line">name    type</span><br><span class="line">exchange_demo   direct</span><br><span class="line">amq.fanout      fanout</span><br><span class="line">amq.rabbitmq.trace      topic</span><br><span class="line">myAe    fanout</span><br><span class="line">amq.headers     headers</span><br><span class="line">amq.topic       topic</span><br><span class="line">amq.direct      direct</span><br><span class="line">normalExchange  direct</span><br><span class="line">        direct</span><br><span class="line">amq.match       headers</span><br></pre></td></tr></table></figure><p>配置文件 <code>vi /etc/rabbitmq/rabbitmq.conf</code> （没有就新建）开启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.exchange = true</span><br></pre></td></tr></table></figure><p>重启下RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmqctl stop</span><br><span class="line">Stopping and halting node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmq-server restart</span><br><span class="line">Configuring logger redirection</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##      RabbitMQ 3.8.8</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Copyright (c) 2007-2020 VMware, Inc. or its affiliates.</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#####  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Licensed under the MPL 2.0. Website: https://rabbitmq.com</span></span></span><br><span class="line"></span><br><span class="line">  Doc guides: https://rabbitmq.com/documentation.html</span><br><span class="line">  Support:    https://rabbitmq.com/contact.html</span><br><span class="line">  Tutorials:  https://rabbitmq.com/getstarted.html</span><br><span class="line">  Monitoring: https://rabbitmq.com/monitoring.html</span><br><span class="line"></span><br><span class="line">  Logs: /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">        /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ_upgrade.log</span><br><span class="line"></span><br><span class="line">  Config file(s): /etc/rabbitmq/rabbitmq.conf</span><br><span class="line"></span><br><span class="line">  Starting broker... completed with 4 plugins.</span><br></pre></td></tr></table></figure><p>可以看到交换器已启动：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010117.png" alt></p><p>分别创建四个日志队列，并采用相应的路由键来绑定 <code>amq.rabbitmq.log</code> 交换器，如果想用一个日志队列收集所有级别日志可以使用 <code>#</code> 这个路由键。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010116.png" alt></p><p>编写代码打印对应级别日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建连接</span></span><br><span class="line">            Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">            &#125;;</span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">            factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">            factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">            Connection connection = factory.newConnection(addresses);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建对应日志级别的信道</span></span><br><span class="line">            Channel channelDebug = connection.createChannel();</span><br><span class="line">            Channel channelInfo = connection.createChannel();</span><br><span class="line">            Channel channelWarn = connection.createChannel();</span><br><span class="line">            Channel channelError = connection.createChannel();</span><br><span class="line">            channelDebug.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelInfo.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelWarn.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelError.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelDebug.basicConsume(<span class="string">"queue.debug"</span>, <span class="keyword">false</span>, <span class="string">"DEBUG"</span>, <span class="keyword">new</span> ConsumerThread(channelDebug));</span><br><span class="line">            channelInfo.basicConsume(<span class="string">"queue.info"</span>, <span class="keyword">false</span>, <span class="string">"INFO "</span>, <span class="keyword">new</span> ConsumerThread(channelInfo)) ;</span><br><span class="line">            channelWarn.basicConsume(<span class="string">"queue.warning"</span>, <span class="keyword">false</span>, <span class="string">"WARNING"</span>, <span class="keyword">new</span> ConsumerThread(channelWarn)) ;</span><br><span class="line">            channelError.basicConsume(<span class="string">"queue.error"</span>, <span class="keyword">false</span>, <span class="string">"ERROR"</span>, <span class="keyword">new</span> ConsumerThread(channelError)) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String log = <span class="keyword">new</span> String(body);</span><br><span class="line">            System.out.println(<span class="string">"="</span> + consumerTag + <span class="string">" REPORT====\n"</span> + log);</span><br><span class="line">            <span class="comment">//对日志进行处理</span></span><br><span class="line">            getChannel().basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">INFO</span>  REPORT====</span><br><span class="line"><span class="number">2020</span>-<span class="number">10</span>-<span class="number">09</span> <span class="symbol">16:00</span><span class="symbol">:19</span>.<span class="number">709</span> [<span class="built_in">info</span>] &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; accepting AMQP connection &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; (<span class="number">115.236</span>.<span class="number">91.15</span><span class="symbol">:64187</span> -&gt; <span class="number">172.17</span>.<span class="number">48.148</span><span class="symbol">:5672</span>)</span><br><span class="line"></span><br><span class="line">=<span class="built_in">INFO</span>  REPORT====</span><br><span class="line"><span class="number">2020</span>-<span class="number">10</span>-<span class="number">09</span> <span class="symbol">16:00</span><span class="symbol">:19</span>.<span class="number">978</span> [<span class="built_in">info</span>] &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; connection &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; (<span class="number">115.236</span>.<span class="number">91.15</span><span class="symbol">:64187</span> -&gt; <span class="number">172.17</span>.<span class="number">48.148</span><span class="symbol">:5672</span>)<span class="symbol">:</span> user 'root' authenticated <span class="built_in">and</span> granted access to vhost '/'</span><br></pre></td></tr></table></figure><p>要注意的是各个节点对应级别的日志是交错在一起的。可以通过检索日志的 running_partitioned_network 关键字来及时地探测到<strong>网络分区</strong>的发生，之后可以迅速采取措施以保证集群服务的鲁棒性。当然对于日志的监控处理也可以采用第3方工具实现，如 Logstash 等。</p><h2 id="第三节-单点故障恢复"><a href="#第三节-单点故障恢复" class="headerlink" title="第三节 单点故障恢复"></a>第三节 单点故障恢复</h2><h3 id="3-1-什么是单点故障"><a href="#3-1-什么是单点故障" class="headerlink" title="3.1 什么是单点故障"></a>3.1 什么是单点故障</h3><p>对于集群层面来说，经常遇到的是单点故障。所谓的单点故障是指集群中单个节点发生了故障，有可能会引起集群服务不可用、数据丢失等异常。配置数据节点冗余（镜像队列）可以有效地防止由于单点故障而降低整个集群的可用性、可靠性。</p><h3 id="3-2-四种常见的单点故障"><a href="#3-2-四种常见的单点故障" class="headerlink" title="3.2 四种常见的单点故障"></a>3.2 四种常见的单点故障</h3><p>单节点故障包括：</p><ul><li><strong>机器硬件故障</strong>：包括机器硬盘、内存、主板等故障造成的死机，无法从软件角度来恢复。<ul><li>此时需要在集群中的其他节点中执行 <code>rabbitmqctl forget_cluster_node {nodename}</code> 命令来将故障节点剔除，其中 nodename 表示故障机器节点名称。</li><li>如果之前有客户端连接到此故障节点上，在故障发生时会有异常报出，此时需要将故障节点的IP地址从连接列表里删除，并让客户端重新与集群中的节点建立连接，以恢复整个应用。</li></ul></li><li><strong>机器掉电</strong>：需要等待电源接通之后重启机器。<ul><li>此时这个机器节点上的 RabbitMQ 处于 stop 状态，但是此时不要盲目重启服务，否则可能会引起<strong>网络分区</strong>。</li><li>此时需要在集群中的其他节点中执行 <code>rabbitmqctl forget_cluster_node {nodename}</code> 命令来将故障节点剔除。</li><li>然后删除当前故障机器的 RabbitMQ 中的 Mnesia 数据（相当于重置）。</li><li>然后再重启 RabbitMQ 服务。</li><li>最后再将此节点作为一个新的节点加入到当前集群中。</li></ul></li><li><strong>网络异常</strong>：网线松动或者网卡损坏都会引起网络故障的发生。<ul><li>对于网线松动，无论是彻底断开，还是“藕断丝连”，只要它不降速， RabbitMQ 集群就没有任何影响。但是为了保险起见，建议先关闭故障机器的 RabbitMQ 进程，然后对网线进行更换或者修复操作，之后再考虑是否重新开启 RabbitMQ 进程。</li><li>网卡故障极易引起<strong>网络分区</strong>的发生，如果监控到网卡故障而网络分区尚未发生时，理应第一时间关闭此机器节点上的 RabbitMQ 进程，在网卡修复之前不建议再次开启。 如果己经发生了网络分区，可以参考 10.5 节进行手动恢复网络分区。</li></ul></li><li><strong>服务进程异常</strong>：如 RabbitMQ 进程非预期终止，需要预先思考相关风险是否在可控范围之内。如果风险不可控，可以选择抛弃这个节点。一般情况下，重新启动 RabbitMQ 服务进程即可。</li></ul><h2 id="第四节-集群迁移"><a href="#第四节-集群迁移" class="headerlink" title="第四节 集群迁移"></a>第四节 集群迁移</h2><p>扩容比较简单，一般向集群中加入新的集群节点即可，不过新的机器节点中是没有队列创建的，只有后面新创建的队列才有可能进入这个新的节点中。或者如果集群配置了镜像队列，可以通过系列操作将原先队列“漂移”到这个新的节点中，具体可以参考第 10.5 节。</p><p>迁移同样可以解决扩容的问题，将旧的集群中的数据（包括元数据信息和消息）迁移到新的且容量更大的集群中即可。 RabbitMQ 中的集群迁移更多的是<strong>用来解决集群故障不可短时间内修复而将所有的数据、客户端连接等迁移到新的集群中，以确保服务的可用性</strong>。相比于单点故障而言，集群故障的危害性就大得多，比如 IDC 整体停电、网线被挖断等。这时候就需要通过集群迁移重新建立起一个新的集群。</p><h3 id="4-1-准备阶段-元数据重建"><a href="#4-1-准备阶段-元数据重建" class="headerlink" title="4.1 准备阶段-元数据重建"></a>4.1 准备阶段-元数据重建</h3><p>元数据重建是指在新的集群中创建原集群的队列交换器、绑定关系、 host、用户、权限 Parameter 等数据信息。元数据重建是集群迁移前的准备工作，之后才可将原集群中的消息及客户端连接迁移过来。</p><p>实现方式：</p><ul><li>手工创建：</li><li>客户端创建：</li></ul><p>元数据的整理十分繁琐，需要如Web管理工具的辅助：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010118.png" alt></p><p>可以在原集群上点击 <code>Download broker definitions</code> 按钮下载集群的元数据信息文件，此文件是 JSON 文件，比如叫 metadata.json 。</p><p>之后再在新集群上的 Web 管理界面中点击 <code>Upload broker definitions</code> 按钮上传 metadata.json 文件。</p><p>如果导入成功则会跳转到成功页面，这样就迅速在新集群中创建了元数据信息。如果新集群有数据与 metadata.json 中的数据相冲突，对于交换器、队列及绑定关系这类非可变对象而言会报错，而对于其他可变对象如 Parameter、用户等则会被覆盖，没有发生冲突的则不受影响。如果过程中发生错误，则导入过程终止，导致 metadata.json 中只有部分数据加载成功。</p><p>三个问题：</p><ol><li><p>如果原集群突发故障，又或者开启 RabbitMQ Management 插件的那个节点机器故障不可修复，就无法获取原集群的元数据 metadata.json。</p><ul><li>这个问题很好解决，采取一个通用的备份任务，在元数据有变更或者达到某个存储周期时将最新的 metadata.json 备份至另一处安全的地方。这样在遇 到需要集群迁移时，可以获取到最新的元数据。</li></ul></li><li><p>如果新旧集群的 RabbitMQ 版本不一致时会出现异常情况。一般情况下 RabbitMQ 是能够做到向下兼容的，在高版本的 RabbitMQ 中可以上传低版本的元数据文件。然而如果在低版本中上传高版本的元数据文件就没有那么顺利了。</p><ul><li>比如 3.5.7 版本与 3.6.10 版本的加密算法不一样，就会出现用户登录失败的情况，可以简单地在 Shell 控制台输入变更密码的方式来解决这个问题：<code>rabbitmqctl change_password {username} {new_password}</code> 。</li><li>如果还是不能成功上传元数据，我们要先清楚对于用户、策略、权限这种元数据来说内容相对固定，且内容较少，手工重建的代价较小。集群中元数据最多且最复杂的要数队列、交换器和绑定这三项的内容，如果采用人工重建的方式代价太大，重建元数据的意义其实就在于重建队列、交换器及绑定这三项的相关信息。</li><li>可以将 3.6.10 的元数据从 queues 这一项前面的内容，包括 rabbit_version、users、vhosts、permissions、parameters、global_parameters 和 policies 这几项内容复制后替换 3.5.7 版本中的 queues 这一项前面的所有内容，然后再保存。之后将修改并保存过后的 3.5.7 版本的元数据 JSON 文件上传到新集群 3.6.10 版本的 Web 管理界面中，至此就完成了集群的元数据重建。</li></ul></li><li><p>第三个问题就是如果采用上面的方法将元数据在新集群上重建，则所有的队列都只会落到同一个集群节点上，而其他节点处于空置状态，这样所有的压力将会集中到这单台节点之上。</p><p>两种解决方案，都是通过程序或脚本的形式在新集群上建立元数据：</p><ul><li><p>通过 HTTP API 接口创建相应的数据：</p><ul><li><p>引入gson：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>三个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> Boolean durable;</span><br><span class="line"><span class="keyword">private</span> Boolean auto_delete;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchange</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="keyword">private</span> Boolean durable;</span><br><span class="line"><span class="keyword">private</span> Boolean auto_delete;</span><br><span class="line"><span class="keyword">private</span> Boolean internal;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binding</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String source;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> String destination;</span><br><span class="line"><span class="keyword">private</span> String destination_type;</span><br><span class="line"><span class="keyword">private</span> String routing_key;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String , Object&gt; arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析原集群的 metadata.json 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Queue&gt; queueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Exchange&gt; exchangeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Binding&gt; bindingList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseJson</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JsonObject json = (JsonObject) parser.parse(<span class="keyword">new</span></span><br><span class="line">                    FileReader(filename));</span><br><span class="line">            JsonArray jsonQueueArray = json.get(<span class="string">"queues"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonQueueArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonQueueArray.get(i).getAsJsonObject();</span><br><span class="line">                Queue queue = parseQueue(subObject);</span><br><span class="line">                queueList.add(queue);</span><br><span class="line">            &#125;</span><br><span class="line">            JsonArray jsonExchangeArray =</span><br><span class="line">                    json.get(<span class="string">"exchanges"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonExchangeArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonExchangeArray.get(i).getAsJsonObject();</span><br><span class="line">                Exchange exchange = parseExchange(subObject);</span><br><span class="line">                exchangeList.add(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">            JsonArray jsonBindingArray = json.get(<span class="string">"bindings"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonBindingArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonBindingArray.get(i).getAsJsonObject();</span><br><span class="line">                Binding binding = parseBinding(subObject);</span><br><span class="line">                bindingList.add(binding);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析队列信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Queue <span class="title">parseQueue</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.setName(subObject.get(<span class="string">"name"</span>).getAsString());</span><br><span class="line">        queue.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        queue.setDurable(subObject.get(<span class="string">"durable"</span>).getAsBoolean());</span><br><span class="line">        queue.setAuto_delete(subObject.get(<span class="string">"auto_delete"</span>).getAsBoolean());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        queue.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析交换器信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Exchange <span class="title">parseExchange</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略，具体参考 parseQueue 方法进行推演</span></span><br><span class="line">        Exchange exchange = <span class="keyword">new</span> Exchange();</span><br><span class="line">        exchange.setName(subObject.get(<span class="string">"name"</span>).getAsString());</span><br><span class="line">        exchange.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        exchange.setType(subObject.get(<span class="string">"type"</span>).getAsString());</span><br><span class="line">        exchange.setDurable(subObject.get(<span class="string">"durable"</span>).getAsBoolean());</span><br><span class="line">        exchange.setInternal(subObject.get(<span class="string">"internal"</span>).getAsBoolean());</span><br><span class="line">        exchange.setAuto_delete(subObject.get(<span class="string">"auto_delete"</span>).getAsBoolean());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        exchange.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析绑定信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Binding <span class="title">parseBinding</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        Binding binding = <span class="keyword">new</span> Binding();</span><br><span class="line">        binding.setSource(subObject.get(<span class="string">"source"</span>).getAsString());</span><br><span class="line">        binding.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        binding.setDestination(subObject.get(<span class="string">"destination"</span>).getAsString());</span><br><span class="line">        binding.setDestination_type(subObject.get(<span class="string">"destination_type"</span>).getAsString());</span><br><span class="line">        binding.setRouting_key(subObject.get(<span class="string">"routing_key"</span>).getAsString());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        binding.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> binding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析参数 arguments 项内容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">parseArguments</span><span class="params">(JsonObject argsObject)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;Map.Entry&lt;String, JsonElement&gt;&gt; entrySet = argsObject.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, JsonElement&gt; mapEntry : entrySet) &#123;</span><br><span class="line">            map.put(mapEntry.getKey(), mapEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在解析完队列、交换器及绑定关系之后，只需要遍历 queueList、exchangeList、bindingList ，然后调用 HTTP API 创建相应的数据即可。随机挑选一个节点并明确指明了 node 节点这一参数来创建队列，如此便可解决集群内部队列分布不均匀的问题。当然首先需要确定新集群中节点名称的列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ip = <span class="string">"192.168.0.2"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String username = <span class="string">"root "</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String password = <span class="string">"rootl23"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; nodeList =<span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"rabbit@node1"</span>);</span><br><span class="line">    add(<span class="string">"rabbit@node2"</span>);</span><br><span class="line">    add(<span class="string">"rabbit@node3"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createQueues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queueList.size(); i++) &#123;</span><br><span class="line">            Queue queue = queueList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = String.format(<span class="string">"http://%s:l5672/api/queues/%s/%s"</span>, ip,</span><br><span class="line">                    encode(queue.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                    encode(queue.getName(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"auto_delete"</span>, queue.getAuto_delete());</span><br><span class="line">            map.put(<span class="string">"durable"</span>, queue.getDurable());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, queue.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建交换器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createExchanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exchangeList.size(); i++) &#123;</span><br><span class="line">            Exchange exchange = exchangeList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = String.format(<span class="string">"http://%s:l5672/api/exchanges/%s/%s"</span>, ip,</span><br><span class="line">                    encode(exchange.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                    encode(exchange.getName(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"auto_delete"</span>, exchange.getAuto_delete());</span><br><span class="line">            map.put(<span class="string">"durable"</span>, exchange.getDurable());</span><br><span class="line">            map.put(<span class="string">"type"</span>, exchange.getType());</span><br><span class="line">            map.put(<span class="string">"internal"</span>, exchange.getInternal());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, exchange.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建绑定关系</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略, 具体参考 createQueues 方法进行推演, 关键信息如 url</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bindingList.size(); i++) &#123;</span><br><span class="line">            Binding binding = bindingList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//绑定有两种 交换器与队列, 交换器与交换器</span></span><br><span class="line">            <span class="keyword">if</span> (binding.getDestination_type().equals(<span class="string">"queue"</span>) )&#123;</span><br><span class="line">                url = String.format(<span class="string">"http://%s:l5672/api//bindings/%s/e/%s/q/%s"</span>, ip,</span><br><span class="line">                        encode(binding.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getSource(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getDestination(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                url = String.format(<span class="string">"http://%s:l5672/api//bindings/%s/e/%s/e/%s"</span>, ip,</span><br><span class="line">                        encode(binding.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getSource (), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getDestination(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"destination"</span>, binding.getDestination());</span><br><span class="line">            map.put(<span class="string">"destination_type"</span>, binding.getDestination_type());</span><br><span class="line">            map.put(<span class="string">"routing_key"</span>, binding.getRouting_key());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, binding.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// http post</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">httpPut</span><span class="params">(String url, String data, String username, String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">            <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">    PutMethod putMethod = <span class="keyword">new</span> PutMethod(url);</span><br><span class="line">    putMethod.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">    putMethod.setRequestEntity(<span class="keyword">new</span> StringRequestEntity(data, <span class="string">"application/json"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">    <span class="keyword">int</span> statusCode = client.executeMethod(putMethod);</span><br><span class="line">    <span class="comment">//System.out.println(statusCode);</span></span><br><span class="line">    <span class="keyword">return</span> statusCode;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">httpPost</span><span class="params">(String url, String data, String username, String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//省略, 具体参考 httpPut 方法进行推演</span></span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">            <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">    PostMethod postMethod = <span class="keyword">new</span> PostMethod(url);</span><br><span class="line">    postMethod.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">    postMethod.setRequestEntity(<span class="keyword">new</span> StringRequestEntity(data, <span class="string">"application/json"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">    <span class="keyword">int</span> statusCode = client.executeMethod(postMethod);</span><br><span class="line">    <span class="comment">//System.out.println(statusCode);</span></span><br><span class="line">    <span class="keyword">return</span> statusCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 Gson 解析 metadata.json 文件，进而使用 HttpClient 调用相应的 HTTP API 在随机的节点上创建相应的队列进程，从而达到了集群节点负载均衡的目的。</p></li><li><p>HttpClient需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-httpclient<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过随机连接集群中不同的节点的IP地址，然后再创建队列。与前一种方式需要节点名称的列表不同，这里需要的是节点IP地址列表：</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ipList = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="string">"192.168.0.2"</span>);</span><br><span class="line">    add(<span class="string">"192.168.0.3"</span>);</span><br><span class="line">    add(<span class="string">"192.168.0.4"</span>); </span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>客户端通过连接不同的IP地址来创建不同的 connection 和 channel ，然后将 channel 存入一个缓冲池，之后从 channelList 中获取一个 channel ，再根据 queueList 中的信息创建相应的队列。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010119.png" alt></p></li><li><p>每一个 channel 对应一个 connection，而每一个 connection 又对应一个 IP ，这样串起来就能保证 channelList 中不会遗留任何节点，最终实现与第一种方式相同的功能。对应的队列创建代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createQueuesNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Channel&gt; channelList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Connection&gt; connectionList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ipList.size();i++) &#123;</span><br><span class="line">            String ip = ipList.get(i);</span><br><span class="line">            ConnectionFactory connectionFactory =<span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">            connectionFactory.setUsername(username);</span><br><span class="line">            connectionFactory.setPassword(password);</span><br><span class="line">            connectionFactory.setHost(ip);</span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            Connection connection = connectionFactory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            channelList.add(channel) ;</span><br><span class="line">            connectionList.add(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        createQueueByChannel(channelList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace() ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connection connection : connectionList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createQueueByChannel</span><span class="params">(List&lt;Channel&gt; channelList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queueList.size(); i++) &#123;</span><br><span class="line">        Queue queue = queueList.get(i);</span><br><span class="line">        <span class="comment">//随机获取相应的 channel</span></span><br><span class="line">        Collections.shuffle(channelList);</span><br><span class="line">        Channel channel = channelList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, Object&gt; mapArgs = queue.getArguments();</span><br><span class="line">            <span class="comment">//do something with mapArgs.</span></span><br><span class="line">            channel.queueDeclare(queue.getName(), queue.getDurable(),</span><br><span class="line">                    <span class="keyword">false</span>, queue.getAuto_delete(), mapArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="4-2-数据迁移和客户端连接的切换"><a href="#4-2-数据迁移和客户端连接的切换" class="headerlink" title="4.2 数据迁移和客户端连接的切换"></a>4.2 数据迁移和客户端连接的切换</h3><p>首先需要将生产者的客户端与原 RabbitMQ 集群的连接断开，然后再与新的集群建立新的连接，这样就可以将新的消息流转入到新的集群中。</p><p>之后就需要考虑消费者客户端的事情，一 种是等待原集群中的消息全部消费完之后再将连接断开，然后与新集群建立连接进行消费作业。</p><p>当原集群服务不可用或者出现故障造成服务质量下降而需要迅速将消息流切换到新的集群中时，此时就不能等待消费完原集群中的消息，这里需要及时将消费者客户端的连接切换到新的集群中，那么在原集群中就会残留部分未被消费的消息，此时需要做进一步的处理。如果原集群损坏，可以等待修复之后将数据迁移到新集群中，否则会丢失数据。</p><p><strong>数据迁移的主要原理</strong>是先从原集群中将数据消费出来，然后存入一个缓存区中，另一个线程读取缓存区中的消息再发布到新的集群中，如此便完成了数据迁移的动作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010120.png" alt></p><p>RabbitMQ提供的 Federation 和 Shovel 都可以实现 ForwardMaker 功能。</p><h3 id="4-3-自动化迁移"><a href="#4-3-自动化迁移" class="headerlink" title="4.3 自动化迁移"></a>4.3 自动化迁移</h3><p>要实现集群自动化迁移，需要在使用相关资源时就做好一些准备工作，方便在自动化迁移过程中进行无缝切换。</p><h4 id="4-3-1-使用资源的3个部分"><a href="#4-3-1-使用资源的3个部分" class="headerlink" title="4.3.1 使用资源的3个部分"></a>4.3.1 使用资源的3个部分</h4><p>与生产者和消费者客户端相关的是交换器、队列及集群的信息，如果这种类型的资源发生改变时需要让客户端迅速感知，以便进行相应的处理，则可以通过将相应的资源加载到 ZooKeeper 的相应节点中，然后在客户端为对应的资源节点加入 watcher 来感知变化， 当然这个功能使用 etcd 或者集成到公司层面的资源配置中心中会更加标准、高效。</p><p>如图将整个 RabbitMQ 集群资源的使用分为3个部分：</p><ul><li>客户端、</li><li>集群、</li><li>ZooKeeper 配置管理。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010121.png" alt></p><h4 id="4-3-2-自动化迁移过程"><a href="#4-3-2-自动化迁移过程" class="headerlink" title="4.3.2 自动化迁移过程"></a>4.3.2 自动化迁移过程</h4><p>在集群中<strong>创建元数据资源</strong>时都需要在 ZooKeeper 中生成相应的配置：</p><ul><li><p>比如在 cluster1 集群中创建交换器 exchange1 之后，需要在 /rmqNode/exchanges 路径下创建实节点 exchange1。并赋予节点的数据内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cluster=cluster1</span> <span class="comment"># 表示此交换器所在的集群名称</span></span><br><span class="line"><span class="string">exchangeType=direct</span> <span class="comment"># 表示此交换器的类型</span></span><br><span class="line"><span class="string">vhost=vhost1</span> <span class="comment"># 表示此交换器所在的 vhost</span></span><br><span class="line"><span class="string">username=root</span> <span class="comment"># 表示用户名</span></span><br><span class="line"><span class="string">password=root123</span> <span class="comment"># 表示密码</span></span><br></pre></td></tr></table></figure></li><li><p>在 cluster1 集群中创建队列 queue1 之后，需要在 /rmqNode/queues 路径下创建实节点 queue1 ，并赋予节点的数据内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cluster=cluster1</span></span><br><span class="line"><span class="string">bindings=exchange1</span> <span class="comment"># 表示此队列所绑定的交换器</span></span><br><span class="line"><span class="comment"># 如果有需要，也可以添加一些其他信息，比如路由键等</span></span><br><span class="line"><span class="string">vhost=vhost1</span></span><br><span class="line"><span class="string">username=root</span></span><br><span class="line"><span class="string">password=root123</span></span><br></pre></td></tr></table></figure></li><li><p>对应集群的数据在 /rmqNode/clusters 路径下，比如 cluster 集群，其对应节点的数据内容包含 IP 地址列表信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ipList=192.168.0.2,</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span><span class="string">,</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span> <span class="comment"># 集群中各个节点的 IP 地址信息</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>客户端程序</strong>如果与其上的交换器或者队列进行交互，那么需要在相应的 <strong>ZooKeeper 节点中添加 watcher</strong> ，以便在数据发生变更时进行相应的变更，从而达到自动化迁移的目的。</p><p><strong>生产者客户端</strong>：</p><ul><li>在发送消息之前需要先连接 ZooKeeper，</li><li>然后根据指定的交换器名称如 exchange1 找到相应的路径 /rmqNode/exchanges 中寻找 exchange1 的节点，</li><li>之后再读取节点中的数据，井同时对此节点添加 watcher 。</li><li>在节点的数据第一条 <code>cluster=cluster1</code> 中找到交换器所在的集群名称，</li><li>然后再从路径 /rmqNode/clusters 中寻找 cluster1 节点，</li><li>然后读取其对应 IP 地址列表信息。</li><li>这样整个发送端所需要的连接串数据 (IP地址列表、vhost、usemame、password 等）都己获取，接下就可以与 RabbitMQ 集群 cluster 建立连接然后发送数据了。 </li></ul><p>对于<strong>消费者客户端</strong>而言：</p><ul><li>同样需要连接 ZooKeeper ，</li><li>之后根据指定的队列名称（queue1) 到相应的路径 /rmqNode/queues 中寻找 queue1 节点，</li><li>继而找到相应的连接串，</li><li>然后与 RabbitMQ 集群 cluster1 建立连接进行消费。</li><li>当然对 /rmqNode/queues/queue1 节点的 watcher 必不可少。</li></ul><p>当 cluster1 集群需要迁移到 cluster2 集群时：</p><ul><li>首先需要将 cluster1 集群中的元数据在 cluster2 集群中重建。</li><li>之后通过修改 channel 和 queue 元数据信息：<ul><li>比如原 cluster1 集群中有交换 exchange1、exchange2 和队列 queue1、queue2 ，</li><li>现在通过脚本或者程序将其中的 <code>cluster=cluster1</code> 数据修改为 <code>cluster=cluster2</code> 。</li><li>客户端会立刻感知节点的变化，然后迅速关闭当前连接之后再与新集群 cluster2 建立新的连接后生产和消费消息，在此切换客户端连接的过程中是可以保证数据零丢失的。</li></ul></li><li>迁移之后，生产者和消费者都会与 cluster2 集群进行互通，此时原 cluster 集群中可能还有未被消费完的数据，此时需要使用 RabbitMQ ForwardMaker 工具将 cluster1 集群中未被消费完的数据同步到 cluster2 集群中。</li></ul><p>如果没有准备 RabbitMQ ForwardMaker 工具，也不想使用 Federation 或者 Shovel 插件，那么在变更完交换器相关的 ZooKeeper 中的节点数据之后，需要等待原集群中的所有队列都消费完全之后，再将队列相关的 ZooKeeper 中的节点数据变更，进而使得消费者的连接能够顺利迁移到新的集群之上。可以通过下面的命令来查看是否有队列中的消息未被消费完：</p><p><code>rabbitmqctl list_queues -p / -q | awk &#39;{if($2&gt;0) print $0 }&#39;</code></p><h4 id="4-3-3-空闲备份集群解决方案"><a href="#4-3-3-空闲备份集群解决方案" class="headerlink" title="4.3.3 空闲备份集群解决方案"></a>4.3.3 空闲备份集群解决方案</h4><p>上面的自动化迁移立足于将现有集群迁移到空闲的备份集群，如果由于原集群硬件升级等原因迁移也无可厚非。很多情况下，自动化迁移作为容灾手段中的一种，如果有很多个正在运行的 RabbitMQ 集群，为每个集群都配备一个空闲的备份集群无疑是一种资源的浪费。当然可以采取几个集群共用一个备份集群来减少这种浪费，那么有没有更优的解决方案呢？</p><p>就以4个 RabbitMQ 集群为例，其被分配4个独立的业务使用。如图 7-8 所示， 当 cluster1 集群中的元数据备份到 cluster2 集群中，而 cluster2 集群中的元数据备份到 cluster3 集群中，如此可以两两互备。<strong>比如在 cluster1 集群中创建了一个交换器 exchange1 ，此时需要在 cluster2 集群中同样创建一个交换器 exchange1</strong> 。在正常情况下，使用的是 cluster1 集群中的 exchange1 ，而 exchange1 在 cluster2 集群中只是一份记录，并不消耗 cluster2 集群的任何性能。而当需要将 cluster1 迁移时，只需要将交换器及队列相对应的 ZooKeeper 节点数据项变更即可完成迁移的工作。如此既不用耗费额外的硬件资源，又不用再迁移的时候重新建立元数据信息。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010122.png" alt></p><p>为了更加稳妥起见，也可以准备一个空闲的备份集群以备后用。当 cluster1 集群需要迁移 cluster2 集群中时， cluster2 集群己经发生故障被关闭或者被迁移到 cluster3 集群中了，那么这个空闲的备份集群可以当作 Plan B 来增强整体服务的可靠性。如果既想不浪费多余的硬件资源又想具备更加稳妥的措施，可以参考图 7-9 ，将 cluster1 中的元数据备份到 cluster2、cluster3 中，这样以1备2的方式即可解决这个难题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010123.png" alt></p><p>对于上面介绍的多集群间互备的解决方案需要配套一个完备的实施系统，比如具备资源管理、执行下发、数据校对等功能，并且对于 ZooKeepe 节点中的数据项设计也需要细细斟酌，最好能够根据实际使用情况将这些整合到一个大的平台化系统之中。</p><h2 id="第五节-集群监控"><a href="#第五节-集群监控" class="headerlink" title="第五节 集群监控"></a>第五节 集群监控</h2><p>监控不仅可以提供运行时的数据为应用提供依据参考，还可以迅速定位问题、提供预防及告警等功能，很大程度上增强了整体服务的鲁棒性。</p><p>RabbitMQ Management 插件就能提供一定的监控功能：如发送速度、确认速度、消费速度、消息总数、磁盘读写速度、句柄数、Socket 连接数、 Connection 数、 Channel 数、内存信息等。但是有一个遗憾就是其难以和公司内部系统平台关联，对于业务资源的使用情况、相应的预防及告警的联动无法顺利贯通。如果在人力、物力等条件允许的情况下，自定义一套监控系统非常有必要。</p><h3 id="5-1-通过HTTP-API接口提供监控数据"><a href="#5-1-通过HTTP-API接口提供监控数据" class="headerlink" title="5.1 通过HTTP API接口提供监控数据"></a>5.1 通过HTTP API接口提供监控数据</h3><p>RabbitMQ Management 插件提供了HTTP API接口来提供监控数据。</p><p>假设集群中一共有4个节点：nod1、node2、node3、node4 。有一个交换器 exchange 通过同一个路由键“rk”绑定了3个队列 quue1、queue2 和 queue3。</p><p>首先可以通过 /api/nodes 接口来收集集群节点的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> diskFree;<span class="comment">//磁盘空闲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> diskFreeLimit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fdUsed;<span class="comment">//句柄使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fdTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> socketsUsed;<span class="comment">//Socket 使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> socketsTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> memoryUsed;<span class="comment">//内存使用值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> memoryLimit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> procUsed;<span class="comment">//Erlang 进程使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> procTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;disk_free="</span> + diskFree + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"disk_free_limit="</span> + diskFreeLimit + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"fd_used= "</span> + fdUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"fd_total = "</span> + fdTotal + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"sockets_used= "</span> + socketsUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"sockets_total= "</span> + socketsTotal + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"mem_used= "</span> + memoryUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"mem_limit= "</span> + memoryLimit + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"proc_used="</span> + procUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"proc_total="</span> + procTotal + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装一下HTTP GET，方便后续程序直接调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">httpGet</span><span class="params">(String url, String username, String password)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">        GetMethod getMethod = <span class="keyword">new</span> GetMethod(url) ;</span><br><span class="line">        <span class="keyword">int</span> ret = client.executeMethod(getMethod);</span><br><span class="line">        String data = getMethod.getResponseBodyAsString();</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 HTTP GET 方法获取 <code>http://xx.xxx.xxx.xxx:15672/api/nodes</code> 的 JSON 数据，然后通过 GSON 进行解析， 之后即可采集到感兴趣的数据项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ClusterNode&gt; <span class="title">getClusterData</span><span class="params">(String ip, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               String username, String password)</span> </span>&#123;</span><br><span class="line">    List&lt;ClusterNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String url = <span class="string">"http://"</span> + ip + <span class="string">":"</span> + port + <span class="string">"/api/nodes"</span>;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String urlData = HttpUtils.httpGet(url, username, password);</span><br><span class="line">        parseClusters(urlData, list);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseClusters</span><span class="params">(String urlData, List&lt;ClusterNode&gt; list)</span> </span>&#123;</span><br><span class="line">    JsonParser parser= <span class="keyword">new</span> JsonParser();</span><br><span class="line">    JsonArray jsonArray =(JsonArray) parser.parse(urlData);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ;i &lt; jsonArray.size(); i++) &#123;</span><br><span class="line">        JsonObject jsonObjectTemp = jsonArray.get(i).getAsJsonObject();</span><br><span class="line">        ClusterNode cluster = <span class="keyword">new</span> ClusterNode();</span><br><span class="line">        cluster.setDiskFree(jsonObjectTemp.get(<span class="string">"disk_free"</span>).getAsLong());</span><br><span class="line">        cluster.setDiskFreeLimit(jsonObjectTemp.get(<span class="string">" disk_free_limit"</span>).</span><br><span class="line">                getAsLong());</span><br><span class="line">        cluster.setFdUsed(jsonObjectTemp.get(<span class="string">"fd_used"</span>).getAsLong());</span><br><span class="line">        cluster.setFdTotal(jsonObjectTemp.get(<span class="string">"fd_total"</span>).getAsLong() );</span><br><span class="line">        cluster.setSocketsUsed(jsonObjectTemp.get(<span class="string">"sockets_used"</span>).getAsLong());</span><br><span class="line">        cluster.setSocketsTotal(jsonObjectTemp.get(<span class="string">"sockets_total"</span>).getAsLong());</span><br><span class="line">        cluster.setMemoryUsed(jsonObjectTemp.get(<span class="string">"mem_used"</span>).getAsLong() );</span><br><span class="line">        cluster.setMemoryLimit(jsonObjectTemp.get(<span class="string">"mem_limit"</span>).getAsLong() );</span><br><span class="line">        cluster.setProcUsed(jsonObjectTemp.get(<span class="string">"proc_used"</span>).getAsLong());</span><br><span class="line">        cluster.setProcTotal(jsonObjectTemp.get(<span class="string">" proc_total"</span>).getAsLong() );</span><br><span class="line">        list.add(cluster);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据来集完之后并没有结束，图 7-10 中简单囊括了从数据采集到用户使用的过程：</p><ul><li>首先采集程序通过定时调用 HTTP API 接口获取 JSON 数据，</li><li>然后进行 JSON 解析之后再进行持久化处理。</li><li>对于这种基于时间序列的数据非常适合使用 OpenTSDB（基于 Hbase 的分布式的、可伸缩的时间序列数据库。主要用途就是做监控系统，比如收集大规模集群，包括网络设备、操作系统、应用程序的监控数据并进行存储、查询）来进行存储。</li><li>监控管理系统可以根据用户的检索条件来从 OpenTSDB 获取相应的数据并展示到页面之中。</li><li>监控管理系统本身还可以具备报表、权限管理等功能，同时也可以实时读取所采集的数据，对其进行分析处理，对于异常的数据需要及时报告给相应的人员。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010124.png" alt></p><p>对于集群的各节点信息展示可以参考下方，图 7-11 展示了各个节点实时的内存占用情况，图 7-12 展示了各个节点实时的磁盘使用情况。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010125.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010126.png" alt></p><p>对于交换器而言的数据采集可以调用 /api/exchanges/vhost/name 接口，比如需要调用虚拟主机为默认的 <code>/</code> 、交换器名称为 exchange 的数据，只需要使用 HTTP GET 方法获取 <code>http://xxx.xxx.xxx.xxx:15672/api/exchanges/%2F/exchange</code> 的数据即可。注意，这里需要将 <code>/</code> 进行 HTML 转义成 <code>%2F</code> ，否则会出错。对应的数据内容可以参考下方：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message_stats"</span>:&#123;</span><br><span class="line"><span class="attr">"publish_in_details"</span>: &#123;</span><br><span class="line"><span class="attr">"rate"</span>: <span class="number">0.4</span> //数据流入的速率</span><br><span class="line">&#125;,</span><br><span class="line">"publish_in": 9,//数据流入的总量</span><br><span class="line">"publish_out_details": &#123;</span><br><span class="line">"rate": 1.2 //数据流出的速率</span><br><span class="line">&#125;,</span><br><span class="line">"publish_out": 27//数据流出的总量</span><br><span class="line">&#125;,</span><br><span class="line">"outgoing": [],</span><br><span class="line">"incoming": [],</span><br><span class="line">"arguments": &#123;&#125;,</span><br><span class="line">"internal": false,</span><br><span class="line">"auto_delete": false,</span><br><span class="line">"durable": true,</span><br><span class="line">"type": "direct",</span><br><span class="line">"vhost": "/",</span><br><span class="line">"name": "exchange" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于1个交换器绑定3个队列的情况，向交换器发送1条消息，那么流入就是1条，而流出就是3条。在应用的时候根据实际情况挑选数据流入速率或者数据流出速率作为发送数量， 以及挑选数据流入的量还是数据流出的量作为发送量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JQExchange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> publishInRate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> publishIn;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> publishOutRate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> publishOut;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;publish_in_rate="</span> + publishInRate +</span><br><span class="line">                <span class="string">", publish_in"</span> + publishIn +</span><br><span class="line">                <span class="string">", publish_out_rate="</span> + publishOutRate +</span><br><span class="line">                <span class="string">", publish_out="</span> + publishOut + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeMonitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getExchangeData(<span class="string">"192.168.0.2"</span>, <span class="number">15672</span>, <span class="string">"root"</span>, <span class="string">"rootl23"</span>, <span class="string">"/"</span>, <span class="string">"exchange"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JQExchange <span class="title">getExchangeData</span><span class="params">(String ip, <span class="keyword">int</span> port, String username,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String password, String vhost , String exchange)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String url = <span class="string">"http://"</span> + ip + <span class="string">":"</span> + port + <span class="string">"/api/exchanges"</span></span><br><span class="line">                + encode(vhost, <span class="string">"UTF-8"</span>) + <span class="string">"/"</span> + encode(exchange, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        String urlData = HttpUtils.httpGet(url, username, password);</span><br><span class="line">        System.out.println(urlData);</span><br><span class="line">        JQExchange exchangeAns = parseExchange(urlData);</span><br><span class="line">        System.out.println(exchangeAns);</span><br><span class="line">        <span class="keyword">return</span> exchangeAns;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JQExchange <span class="title">parseExchange</span><span class="params">(String urlData)</span> </span>&#123;<span class="comment">//解析程序</span></span><br><span class="line">        JQExchange exchange = <span class="keyword">new</span> JQExchange();</span><br><span class="line">        JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">        JsonObject jsonObject = (JsonObject) parser.parse(urlData);</span><br><span class="line">        JsonObject msgStats =</span><br><span class="line">                jsonObject.get(<span class="string">"message_stats"</span>).getAsJsonObject();</span><br><span class="line">        <span class="keyword">double</span> publish_in_details_rate =</span><br><span class="line">                msgStats.get(<span class="string">"publish_in_details"</span>)</span><br><span class="line">                        .getAsJsonObject().get(<span class="string">"rate"</span>).getAsDouble();</span><br><span class="line">        <span class="keyword">double</span> publish_out_details_rate =</span><br><span class="line">                msgStats.get(<span class="string">"publish_out_details"</span>).</span><br><span class="line">                        getAsJsonObject().get(<span class="string">"rate"</span>).getAsDouble();</span><br><span class="line">        <span class="keyword">long</span> publish_in = msgStats.get(<span class="string">"publish_in"</span>).getAsLong();</span><br><span class="line">        <span class="keyword">long</span> publish_out = msgStats.get(<span class="string">"publish_out"</span>).getAsLong();</span><br><span class="line">        exchange.setPublishInRate(publish_in_details_rate);</span><br><span class="line">        exchange.setPublishOutRate(publish_out_details_rate);</span><br><span class="line">        exchange.setPublishIn(publish_in);</span><br><span class="line">        exchange.setPublishOut(publish_out);</span><br><span class="line">        <span class="keyword">return</span> exchange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于队列而言的数据来集相关的接口为 /api/queues/vhost/name 。</p><h3 id="5-2-通过客户端提供监控数据"><a href="#5-2-通过客户端提供监控数据" class="headerlink" title="5.2 通过客户端提供监控数据"></a>5.2 通过客户端提供监控数据</h3><p>除了 HTTP API 接口可以提供监控数据，Java 版客户端从 3.6.x 版本开始，也在 <code>Channel</code> 接口中提供了两个方法来获取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">messageCount</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">consumerCount</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>messageCount：用来查询队列中的消息个数，可以为监控消息堆积的情况提供数据。</li><li>consumerCount：用来查询队列中的消费者个数，可以为监控消费者的情况提供数据。</li></ul><p>相应监控视图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010127.png" alt></p><p>还可以通过连接的状态进行监控，<code>Connection</code> 接口提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBlockedListener</span><span class="params">(BlockedListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BlockedListener <span class="title">addBlockedListener</span><span class="params">(BlockedCallback var1, UnblockedCallback var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeBlockedListener</span><span class="params">(BlockedListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBlockedListeners</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>addBlockedListener：用来监昕连接阻塞信息。</li><li>addShutdownListener：用来监昕连接关闭信息。</li></ul><p>用户客户端还可以自行定义一些数据进行埋点 ，比如客户端成功发送的消息个数和发送失败的消息个数，进一步可以计算发送消息的成功率等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> successCount = <span class="number">0</span>; <span class="comment">//记录发送成功的次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> failureCount = <span class="number">0</span>; <span class="comment">//记录发送失败的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XXXXXX</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                failureCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>,</span><br><span class="line">                MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                <span class="string">"msg"</span> .getBytes());</span><br><span class="line">        <span class="keyword">if</span> (channel.waitForConfirms() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            successCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            failureCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        failureCount++;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        failureCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里推荐引入 metrics 工具（比如 <code>com.codahale.metrics.*</code>）来进行埋点，这样既方便又高效。同样的方式也可以统计消费者消费成功的条数和消费失败的条数。</p><h3 id="5-3-检测RabbitMQ服务是否健康"><a href="#5-3-检测RabbitMQ服务是否健康" class="headerlink" title="5.3 检测RabbitMQ服务是否健康"></a>5.3 检测RabbitMQ服务是否健康</h3><p>上述两种方式都要基于 RabbitMQ 服务运行正常的情况下，但无法判断 RabbitMQ 是否具备服务外部请求的能力。</p><p>三种检查方式：</p><ul><li>检查RabbitMQ是否运行：<code>ps aux | grep rabbitmq</code> 。</li><li>检查5672端口是否开启：<code>telnet xxx.xxx.xxx.xxx 5672</code> 。</li><li>使用 AMQP 协议来构建一个类似于 TCP 协议中的 Ping 的检测程序。当这个测试程序与 RabbitMQ 服务无法建立 TCP 协议层面的连接，或者无法构建 AMQP 协议层面的连接，再或者构建连接超时时，则可判定 RabbitMQ 服务处于异常状态而无法正常为外部应用提供相应的服务。</li></ul><p>AMQPPing实现代码可以参考《RabbitMQ实战指南 7.5.3》。</p><p>RabbitMQ Management 插件提供了 /api/aliveness-test/vhost 的 HTTP API 形式的接口，通过3个步骤来验证 RabbitMQ 服务的健康性：</p><ul><li>创建1个以 <code>aliveness-test</code> 为名称的队列来接收测试消息。</li><li>用队列名称 <code>aliveness-test</code> 作为消息的路由键，将消息发往默认交换器。 </li><li>到达队列时就消费该消息，否则就报错。</li></ul><p>检测程序 <code>aliveness-test</code> 运行在 Erlang 虚拟机内部， 因此它不会受到网络问题的影响。</p><h3 id="5-4-元数据管理与监控"><a href="#5-4-元数据管理与监控" class="headerlink" title="5.4 元数据管理与监控"></a>5.4 元数据管理与监控</h3><p>确保 RabbitMQ 能够健康运行还不足以让人放松警惕。比如在生产环境误删了一个队列（或者删除交换器、修改绑定信息等），若业务方正在使用这个队列，返回了异常后即使处理还能尽量的减少影响。但如果是深夜执行的定时任务，处理起来就很麻烦了。</p><p>许多应用场景是在业务逻辑代码中创建相应的元数据资源（交换器、队列及绑定关系）并使用对于排他的、自动删除的这类非高可靠性要求的元数据资源可以在一定程度上忽略元数据变更的影响。但是对于两个非常重要的且通过消息中间件交互的业务应用，在使用相应的元数据资源时最好进行相应的管控，如果一方或者其他方肆意变更所使用的元数据，必然对另一方造成不小的损失。管控的介入自然会降低消息中间件的灵活度，但是可以增强系统的可靠性。 比如通过专用的“元数据审核系统”来配置相应的元数据资源，提供给业务方使用的用户只有 可读和可写的权限，这样可以进一步降低风险。</p><p>RabbitMQ 在创建元数据资源的时候是以一种声明的形式完成的：无则创建、有则不变，不过在对应的元数据存在的情况下，对其再次声明时使用不同的属性会报出相应的错误信息。 我们可以利用这一特性来监控元数据的变更，通过定时程序来将记录中的元数据信息重新声明一次，查看是否有异常报出。不过这种方法非常具有局限性，只能增加元数据的信息而不能减少。比如有一个队列没有消费者且以后也不会被使用，我们对其进行了解绑操作，这样就没有更多的消息流入而造成消息堆积，不过这一变更由于某些局限性没有及时将记录变更以通知到那个定时程序，此时又重新将此队列绑定到原交换器中。</p><p>如图 7-15 所示，所有的业务应用都需要通过元数据审核系统来申请创建（当然也可以包含查询、修改及删除）相应的元数据信息。在申请动作完成之后，由专门的人员进行审批，之后在数据库中存储和在 RabbitMQ 集群中创建相应的元数据，这两个步骤可以同时进行，而且也无须为这两个动作添加强一致性的事务逻辑。在数据库和 RabbitMQ 集群之间会有一个元数据一致性校验程序来检测元数据不一致的地方，然后将不一致的数据上送到监控管理系统。监控管理系统中可以显示元数据不一致的记录信息，也可以以告警的形式推送出来，然后相应的管 理人员可以选择手动或者自动地进行元数据修正。这里的不一致有可能是由于数据库的记录未被正确及时地更新，有可能是 RabbitMQ 集群中元数据被异常篡改 元数据修正需慎之又慎，在整个系统修正逻辑完备之前，建议优先采用人工的方式，毕竟不一致的元数据仅占少数，人工修正的工作量并不太大。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010128.png" alt></p><p>主要的元数据是：queues、exchanges、bindings ，可以分别建立三张表。元数据一致性检测程序可以通过 /api/definitions 的 HTTP API 接口获取集群的元数据信息，通过解析之后与数据库中的记录一一比对，查看是否有不一致的地方。</p><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第六章《运维》，内容来自于《RabbitMQ实战指南》，内容：在 RabbitMQ 使用过程中难免会出现各式各样的异常情况，客户端的异常一般是由于应用代码的缺陷造成的，对于服务端的异常，虽然不能完全杜绝，但是可以采取一些有效的手段去监测、管控、修正等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（五）配置</title>
    <link href="http://linyishui.top/2020100601.html"/>
    <id>http://linyishui.top/2020100601.html</id>
    <published>2020-10-06T13:00:41.000Z</published>
    <updated>2020-10-07T15:40:06.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（五）配置"><a href="#RabbitMQ（五）配置" class="headerlink" title="RabbitMQ（五）配置"></a>RabbitMQ（五）配置</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><p>一般情况下，只需要使用默认的内建配置来运行 RabbitMQ，也可以利用调节系统范围内的参数来达到定制化的需求。</p><p>RabbitMQ 提供了三种方式来定制化服务：</p><ol><li>环境变量（Enviroment Variables）：RabbitMQ 服务端参数可以通过环境变量进行配置，例如：节点名称、 RabbitMQ 配直文件的地址、节点内部通信端口等。</li><li>配置文件（ Configuration File）：可以定义 RabbitMQ 服务和插件设置，例如：TCP 听端口，以及其他网络相关的设直、内存限制、磁盘限制等。</li><li>运行时参数和策略（ Runtime Parameters and Policies）：可以在运行时定义集群层面的服务设置。</li></ol><h2 id="第二节-环境变量"><a href="#第二节-环境变量" class="headerlink" title="第二节 环境变量"></a>第二节 环境变量</h2><h3 id="2-1-配置方式"><a href="#2-1-配置方式" class="headerlink" title="2.1 配置方式"></a>2.1 配置方式</h3><p>RabbitMQ 的环境变量都是以 <code>RABBITMQ_</code> 开头的，可以在 Shell 环境中设置，也可以在 <code>rabbitmq-env.conf</code> 这个 RabbitMQ 环境变量的定义文件中设置。在非 Shell 环境中配置，则需要将 <code>RABBITMQ_</code> 这个前缀去除。</p><p>指令 <code>rabbitmq-server -detached</code> 启动 RabbitMQ 服务的时候，此服务节点默认以 <code>rabbit＠</code> 加上当前的 Shell 环境的 hostname（主机名）来命名，即 <code>rabbit@$HOSTNAME</code> 。可以在 <code>rabbitmq-server</code> 命令前添 <code>RABBITMQ_NODENAME</code> 变量来设定指定的名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> RABBITMQ_NODENAME=rabbit@node2 rabbitmq-server -detached</span></span><br><span class="line">Warning: PIO file not written; -detached was passed.</span><br></pre></td></tr></table></figure><p>优先级顺序：Shell环境 &gt; <code>rabbitmq-env.conf</code> 配置文件 &gt; 默认配置。</p><p>配置 <code>rabbitmq-env.conf</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RabbitMQ 环境变量的定义文件</span></span><br><span class="line"><span class="comment"># 定义节点名称</span></span><br><span class="line"><span class="string">NODENAME=rabbit@node1</span></span><br><span class="line"><span class="comment"># 定义 RabbitMQ 的对外通信端口号</span></span><br><span class="line"><span class="string">NODE_PORT=5672</span></span><br><span class="line"><span class="comment"># 定义 RabbitMQ 配置文件的目录，注意对于 rabbitmq.config</span></span><br><span class="line"><span class="comment"># 文件来说这里不用添加".config后缀"</span></span><br><span class="line"><span class="string">CONFIG_FILE=/opt/rabbitmq/etc/rabbitmq/rabbitmq</span></span><br></pre></td></tr></table></figure><p>默认配置记录在 <code>$RABBITMQ HOME/sbin/rabbitmq-defaults</code> 文件。</p><h3 id="2-2-常见的RabbitMQ变量"><a href="#2-2-常见的RabbitMQ变量" class="headerlink" title="2.2 常见的RabbitMQ变量"></a>2.2 常见的RabbitMQ变量</h3><table><thead><tr><th>变量名称</th><th>描述</th></tr></thead><tbody><tr><td>RABBITMQ_NODE_IP_ADDRESS</td><td>绑定某个特定的网络接口。默认值是空字符串，即绑定到所有网络接口上。如果要绑定两个或者更多的网络接口，可以参考 rabbitmq.config 中的 tcp_listeners 配置</td></tr><tr><td>RABBITMQ_NODE_PORT</td><td>监听客户端连接的端口号，默认为 5672</td></tr><tr><td>RABBITMQ_DIST_PORT</td><td>RabbitMQ 节点内部通信的端口号，默认值为 RABBITMQ_NODE_PORT+20000, 即25672。如果设置了 kernel.inet_dist_listen_min 或者 kemel.inect_dist_listen_max</td></tr><tr><td>RABBITMQ_NODENAME</td><td>RabbitMQ 的节点名称，默认为 rabbit@$HOSTNAME 。在每个 Erlang 节点和机器的组合中，节点名称必须唯一</td></tr><tr><td>RABBITMQ_CONF_ENV_FILE</td><td>RabbitMQ 环境变量的配置文件（rabbitmq-env.conf）的地址，默认值为 $RABBITMQ_HOME/etc/rabbitmq/rabbi tmq-env.conf 注意这里与 RabbitMQ 配置文件 rabbitmq.config 的区别</td></tr><tr><td>RABBITMQ_USE_LONGNAME</td><td>如果当前的 hostname 为 node1.longname ，那么默认情况下创建的节点名称为 rabbit@node1 ，将此参数设置为 true 时，创建的节点名称就为 <a href="mailto:rabbit@node1.longname" target="_blank" rel="noopener">rabbit@node1.longname</a>，即使用了长名称命名，默认值为空</td></tr><tr><td>RABBITMQ_CONFIG_FILE</td><td>RabbitMQ 配置文件（rabbitmq.config）的路径，注意没有“.config”的后缀．默认值为 $RABBITMQ_HOME/etc/rabbitmq/rabbitmq</td></tr><tr><td>RABBITMQ_MNESIA_BASE</td><td>RABBITMQ_MNESIA_DIR 的父目录。除非明确设置了 RABBITMQ_MNESIA _DIR 目录，否则每个节点都应该配置这个环境变量。默认值为 $RABBITMQ_HOME/var/lib/rabbitmq/mnesia  注意对于 RabbitMQ 的操作用户来说，需要有对当前目录可读、可写、可创建文件及子目录的权限</td></tr><tr><td>RABBITMQ_MNESA_DIR</td><td>包含 RabbitMQ 服务节点的数据库、数据存储及集群状态等目录，默认值为 <code>$RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME</code></td></tr><tr><td>RABBITMQ_LOG_BASE</td><td>RabbitMQ 服务日志所在基础目录．默认值为$RABBITMQ_HOME/var/log/rabbitmq</td></tr><tr><td>RABBITMQ_LOGS</td><td>RabbitMQ 服务与 Erlang 相关的日志，默认值为 <code>$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log</code></td></tr><tr><td>RABBITMQ_SASL_LOGS</td><td>RabbitMQ 服务于 Erlang 的 SASL(System Application Support Libraries）相关的日志，默认值为 <code>$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME-sasl.log</code></td></tr><tr><td>RABBITMQ_PLUGINS_DIR</td><td>插件所在路径。默认值为$RABBITMQ_HOME/plugins</td></tr></tbody></table><p>一般不建议修改环境变量，如果生产环境有特殊要求，可以参考：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件的地址</span></span><br><span class="line"><span class="string">CONFIG_FILE=/apps/conf/rabbitmq/rabbitmq</span></span><br><span class="line"><span class="comment"># 环境变量的配置文件的地址</span></span><br><span class="line"><span class="string">CONF_ENV_FILE=/apps/conf/rabbitmq/rabbitmq-env.conf</span></span><br><span class="line"><span class="comment"># 服务日志的地址</span></span><br><span class="line"><span class="string">LOG_BASE=/apps/logs/rabbitmq</span></span><br><span class="line"><span class="comment"># Mnesia 的路径</span></span><br><span class="line"><span class="string">MNESIA_BASE=/apps/dbdat/rabbitmq/mnesia</span></span><br></pre></td></tr></table></figure><h2 id="第三节-配置文件"><a href="#第三节-配置文件" class="headerlink" title="第三节 配置文件"></a>第三节 配置文件</h2><p>在启动 RabbitMQ 服务的时候会打印相关信息，可以检查服务日志来判断配置文件地址。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010112.png" alt></p><p>配置失效的情况：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="keyword">file</span>(s) : <span class="regexp">/opt/</span>rabbitmq<span class="regexp">/sbin/</span>..<span class="regexp">/etc/</span>rabbitmq<span class="regexp">/rabbitmq. config(not found)</span></span><br></pre></td></tr></table></figure><p>检查对应路径下是否有相关配置文件，以及配置文件地址是否设置正确（通过 RABBITMQ_CONFIG_FILE 变量或者 <code>rabbitmq-env.conf</code> 文件设置）。</p><p>还可以通过查看进程信息的方式来检查配直文件的位置。通过 <code>ps aux|grep rabbitmq</code> 命令查看到 RabbitMQ 进程的信息，如果 <code>rabbitmq.config</code> 文件不处于默认的路径中，则会有 <code>-config</code> 选项标记正在使用的路径。</p><h3 id="3-1-配置项"><a href="#3-1-配置项" class="headerlink" title="3.1 配置项"></a>3.1 配置项</h3><p>极简的 <code>rabbitmq.config</code> 文件：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listeners, [<span class="number">5673</span>]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>上面的配置将 RabbitMQ 监听 AMQP 0-9-1 客户端连接的默认端口号从 5672 修改为 5673。</p><p>RabbitMQ 服务相关配置表格暂略。</p><h3 id="3-2-配置加密"><a href="#3-2-配置加密" class="headerlink" title="3.2 配置加密"></a>3.2 配置加密</h3><p>配置文件中有些敏感的配置项可以被加密，在 RabbitMQ 启动时可以对这些项进行解密。在配置文件中将加密之后的值以 <code>{encrypted, 加密的值}</code> 形式包裹。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;default_user,&lt;&lt;<span class="string">"guest"</span>&gt;&gt;&#125;,</span><br><span class="line">&#123;default_pass,</span><br><span class="line">&#123;</span><br><span class="line">&#123;encrypted,&lt;&lt;<span class="string">"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="</span>&gt;&gt;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;loopback_users,[]&#125;,</span><br><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,&lt;&lt;<span class="string">"zzhpassphrase"</span>&gt;&gt;&#125;</span><br><span class="line">]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>config_entry_decoder 项中的 passphrase 配置的就是口令。注意这里将 loopback_users 项配置为 <code>[]</code> ，就可以使用非本地网络访问 RabbitMQ 了，如果开启了 RabbitMQ Management 插件，就可以使用 guest/guest 的用户及密码来访问 Web 管理界面了。</p><p>passphrase 内容可以以单独的文件来赋值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,<span class="string">"/path/to/passphrase/file"</span>&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>加密解密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode &lt;&lt;<span class="string">"guest"</span>&gt;&gt; zzhpassphrase </span></span><br><span class="line">&#123;encrypted,&lt;&lt;"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="&gt;&gt;&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode --DECODE &lt;&lt;<span class="string">"guest"</span>&gt;&gt; <span class="string">'&#123;encrypted,&lt;&lt;"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="&gt;&gt;&#125;'</span> zzhpassphrase</span></span><br></pre></td></tr></table></figure><p>默认情况下，加密机制 PBKDF2 用来从口令中派生出密钥。默认的 Hash 算法是 SHA512，默认的迭代次数是 1000 ，以及默认的加密算法为 AES_256_CBC。可以在配置文件中进行修改：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,<span class="string">"zzhpassphrase"</span>&#125;,</span><br><span class="line">&#123;cipher, blowfish_cfb64&#125;,</span><br><span class="line">&#123;hash, sha256&#125;,</span><br><span class="line">&#123;iterations, <span class="number">10000</span>&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>或者通过 rabbitmqctl encode 命令设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode --cipher blowfish_cfb64 --<span class="built_in">hash</span> sha256 --iterations 10000 <span class="string">'&lt;&lt;"guest"&gt;&gt;'</span> zzhpassphrase</span></span><br></pre></td></tr></table></figure><h3 id="3-3-优化网络配置"><a href="#3-3-优化网络配置" class="headerlink" title="3.3 优化网络配置"></a>3.3 优化网络配置</h3><p>RabbitMQ 支持的所有协议都是基于 TCP 层面的，除了操作系统内核参数和 DNS，所有的 RabbitMQ 设置都可以通过在 rabbitmq.config 配置文件中配置来实现。</p><h4 id="3-3-1-监听端口"><a href="#3-3-1-监听端口" class="headerlink" title="3.3.1 监听端口"></a>3.3.1 监听端口</h4><p>RabbitMQ 在等待接收客户端连接时需要绑定一个或者多个网络接口（可以理解成IP地址)，井监听特定的端口。网络接口使用 rabbit.tcp_listeners 选项来配置。默认情况下，RabbitMQ 会在所有可用的网络接口上监听 5672 端口。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line"># 在一个指定的地址和端口上进行监听，同时在 <span class="symbol">IPv4</span> 和 <span class="number">1</span><span class="symbol">Pv6</span> 上监听</span><br><span class="line">&#123;tcp_listeners, [&#123;<span class="string">"192.168.0.2"</span>, <span class="number">5672</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"::1"</span>, <span class="number">5672</span>&#125;]&#125;</span><br><span class="line"> </span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><h4 id="3-3-2-提高吞吐量"><a href="#3-3-2-提高吞吐量" class="headerlink" title="3.3.2 提高吞吐量"></a>3.3.2 提高吞吐量</h4><p>优化网络配置的一个重要目标就是提高吞吐量，比如禁用 Nagle 算法、增大 TCP 缓冲区的大小。每个 TCP 连接都分配了缓冲区。一般来说，缓冲区越大，吞吐量也会越高，但是每个连接上耗费的内存也就越多，从而使总体服务的内存增大，这是一个权衡的问题。在 Linux 操作系统中，默认会自动调节 TCP 缓冲区的大小，通常会设置为 80KB 到 120KB 之间。</p><p>要提高吞吐量可以使用 rabbit.tcp_listen_options 来加大配置：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listen_options, [</span><br><span class="line">                 &#123;backlog, <span class="number">128</span>&#125;,</span><br><span class="line">                 &#123;nodelay, true&#125;,</span><br><span class="line">                 &#123;linger, &#123;true,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">                 &#123;exit_on_close, false&#125;,</span><br><span class="line">                 &#123;sndbuf, <span class="number">196608</span>&#125;,</span><br><span class="line">                 &#123;recbuf, <span class="number">196608</span>&#125;]&#125; </span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>大部分操作系统都限制了同一时间可以打开的文件句柄数。在优化并发连接数的时候，需要确保系统有足够的文件句柄数来支撑客户端和 Broker 的交互。可以用每个节点上连接的数目乘以1.5来粗略的估算限制。例如，要支撑 10 万个 TCP 连接，需要设置文件句柄数为 15 万。当 然，略微增加文件句柄数可以增加闲置机器内存的使用量，但这需要合理权衡。</p><p>如上所述，增大 TCP 缓冲区的大小可以提高吞吐量，如果减小 TCP 缓冲区的大小，这样 就可以减小每个连接上的内存使用量。如果并发量比吞吐量更重要，可以修改此值。</p><p>禁用 Nagle 算法可以提高吞吐量，但是其主要还是用于减少延迟。RabbitMQ 内部节点交互时可以在 kernel.inet_default_connect_options 和 kernel.inet_default_listen_options 配置项中配置 {nodelay, true} 来禁用 Nagle 算法。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">kernel, [</span><br><span class="line">&#123;inet_default_connect_options, [&#123;nodelay, true&#125;]&#125;,</span><br><span class="line">&#123;inet_default_listen_options, [&#123;nodelay, true&#125;]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listen_options, [</span><br><span class="line">                 &#123;backlog, <span class="number">4096</span>&#125;,</span><br><span class="line">                 &#123;nodelay, true&#125;,</span><br><span class="line">                 &#123;linger, &#123;true,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">                 &#123;exit_on_close, false&#125;]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><h4 id="3-3-3-设置线程池大小"><a href="#3-3-3-设置线程池大小" class="headerlink" title="3.3.3 设置线程池大小"></a>3.3.3 设置线程池大小</h4><p>Erlang 在运行时使用线程池来异步执行 IO 操作。线程池的大小可以通过 RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS 这个环境变量来调节。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</span>=<span class="string">"+A 128"</span></span><br></pre></td></tr></table></figure><p>当机器的内核个数大于等于8时，建议将此值设置为大于等于 96 ，这样可以确保每个内核上可以运行大于等于 12 个 I/O 线程。</p><h4 id="3-3-4-连接量大"><a href="#3-3-4-连接量大" class="headerlink" title="3.3.4 连接量大"></a>3.3.4 连接量大</h4><p>当只有少量的客户端时，新建立的连接分布是非常不均匀的，但是由于数量足够小，所以没有太大的差异。当连接数量到达数万或者更多时，重要的是确保服务器能够接受入站连接。未接受的 TCP 连接将会放在有长度限制的队列中。这个通过 rabbit.tcp_listen_options.backlog 参数来设置，默认值为 128 ，当挂起的连接队列的长度超过此值时，连接将被操作系统拒绝。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010113.png" alt></p><h4 id="3-3-5-一些可配置的内核选项"><a href="#3-3-5-一些可配置的内核选项" class="headerlink" title="3.3.5 一些可配置的内核选项"></a>3.3.5 一些可配置的内核选项</h4><p>与操作系统有关的网络设置也会影响到 RabbitMQ 的运行，注意这一类型的内核参数在 <code>/etc/sysctl.conf</code> 文件（Linux 操作系统）中配置，而不是 rabbitmq.config 这个文件中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010114.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010115.png" alt></p><h2 id="第四节-参数及策略"><a href="#第四节-参数及策略" class="headerlink" title="第四节 参数及策略"></a>第四节 参数及策略</h2><p>有些配置不太适合在 rabbitmq.config 中实现，比如某项配置不需要同步到集群中的其他节点中，或者某项配置需要在运行时更改，因为 rabbitmq.config 需要重启 Broker 才能生效。 这种类型的配置在 RabbitMQ 中的另一种称呼为参数（ Paramter），也可以称之为运行时参数（Runtime Parameter）。</p><p>Parameter的设置方式：</p><ul><li>通过 rabbitmqctl 工具；</li><li>通过 RabbitMQ Management 插件提供的 HTTP API 接口来设置。</li></ul><p>RabbitMQ 一共有两种类型的 Parameter:：</p><ul><li>vhost 级别的 Parameter ，由一个组件名称（component name）、名称（name）和值 (value）组成。</li><li>global 级别的 Parameter ，由一个名称和值组成。</li></ul><p>不管什么类型，值都是JSON类型的。例如 Federation upstream 是一个 vhost 级别的 Parameter ，它用来定义 Federation link 的上游信息，其对应的 Parameter 的组件名称为 “federation-upstream” ，名称对应于其自身的名称，而值对应于与上游的相关的连接参数等；对 Shovel 而言也可以通过 Parameter 设置，其对应组件名称为 “shovel”。</p><h3 id="4-1-vhost级别Parameter"><a href="#4-1-vhost级别Parameter" class="headerlink" title="4.1 vhost级别Parameter"></a>4.1 vhost级别Parameter</h3><p>vhost 级别的参数对应的 rabbitmqctl 相关的命令有3种：</p><ul><li><p>set_parameter：用来设置一个参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter [-p vhost] &#123;component_name&#125; &#123;name&#125; &#123;value&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation </span></span><br><span class="line">The following plugins have been enabled: </span><br><span class="line">  rabbitmq_federation </span><br><span class="line">Applying plugin configuration to rabbit@node1... started 1 plugin. </span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter federation-upstream f1 <span class="string">'&#123;"uri":"amqp://root:root123@192.168.0.2:5672","ack-mode":"on-confirm"&#125;'</span></span></span><br><span class="line">Setting runtime parameter "f1" for component "federation-upstream" to "&#123;\"uri\":\"amqp://root:root123@192.168.0.2:5672\",\"ack-mode\":\"on-confirm\"&#125;"</span><br></pre></td></tr></table></figure></li><li><p>list_parameters：用来列出指定虚拟主机上所有的Parameter。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters [-p vhost] </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters -p /</span></span><br><span class="line">Listing runtime parameters </span><br><span class="line">federation-upstream f1 &#123;"uri":"amqp://root:root123@192.168.0.2:5672","ack-mode":"on-confirm"&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear_parameter：用来清除指定的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_parameter [-p vhost] &#123;componenet_name&#125; &#123;key&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_parameter -p / federation-upstream f1 </span></span><br><span class="line">Clearing runtime parameter "fl" for component "federation-upstream"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters -p /</span></span><br><span class="line">Listing runtime parameters</span><br></pre></td></tr></table></figure></li></ul><p>HTTP API接口：</p><ul><li>设置一个参数：PUT /api/parameters/{componenet_name}/vhost/name</li><li>清除一个参数：DELETE /api/parameters/{componenet_name}/vhost/name</li><li>列出指定 vhost 中的所有参数：GET /api/parameters</li></ul><h3 id="4-2-global级别Parameter"><a href="#4-2-global级别Parameter" class="headerlink" title="4.2 global级别Parameter"></a>4.2 global级别Parameter</h3><p>global 级别的 Parameter 的操作：</p><table><thead><tr><th>方式</th><th>详细内容</th></tr></thead><tbody><tr><td>rabbitmqctl</td><td>rabbitmqctl set_global_parameter name value<br>rabbitmqctl list_global_parameters<br>rabbitmqctl clear_global_parameter name</td></tr><tr><td>HTTP API接口</td><td>PUT /api/global-parameters/name<br>DELETE /api/global-parameters/name<br>GET /api/global-parameters/</td></tr></tbody></table><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list global parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_global_parameter name1 <span class="string">'&#123;&#125;'</span></span></span><br><span class="line">Setting global runtime parameter "name1" to "&#123;&#125;"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_global_parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br><span class="line">name1        []</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_global_parameter name1</span></span><br><span class="line">Clearing global runtime parameter "name1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_global_parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br></pre></td></tr></table></figure><h3 id="4-3-Policy"><a href="#4-3-Policy" class="headerlink" title="4.3 Policy"></a>4.3 Policy</h3><p>除了一些固定参数（ 比如 durable 或者 exclusive），客户端在创建交换器或者队列的时候可以配置一些可选参数来获得一些不同的功能，比如 x-message-ttl 或 x-expires 或 x-max-length 等。通过客户端设定的这些属性参数一旦设置成功就不能再改变（不能修改也不能添加），除非删除原来的交换器或队列之后再重新创建新的。</p><p>Policy 的介入就可以很好的解决这类问题，是一种特殊的Parameter的用法。</p><ul><li>Policy 是 vhost 级别的，一个 Policy 可以匹配多个队列或交换器，便于批量管理。</li><li>Policy 也支持动态的修改一些属性参数，提高了应用的灵活度。</li><li>一般用来配置Federation、镜像、备份交换器、死信等功能。</li></ul><p>rabbitmq_managemet 本身就提供了 Policy 的支持。可以在 【Admin】-&gt;【Policies】-&gt; 【Add / update a policy】中添加一个 Policy 。</p><p>参数： </p><ul><li>Virtual host ：表示当前 Policy 所在的 vhost 是哪个。 </li><li>Name ：表示当前 Policy 的名称。</li><li>Pattern ：一个正则表达式，用来匹配相关的队列或者交换器。 </li><li>Apply to ：用来指定当前 Policy 作用于哪一方。 共有三个选项：<ul><li>Exchanges and queues：表示作用与 Pattern 所匹配的所有队列和交换器；</li><li>Exchanges：表示作用于 Pattern 所匹配的所有交换器；</li><li>Queues：表示作用于与 Pattern 所匹配的所有队列。 </li></ul></li><li>Priority ：定义优先级，如果有多个 Policy 作用于同一个交换器或者队列，那么 Priority 最大的那个 Policy 才会有用 。</li><li>Definition ：定义一组或者多组键值对，为匹配的交换器或者队列附加相应的功能。</li></ul><p>作为一种 Paramter, Policy 也可以通过 rabbitmqctl 工具或者 HTTP API 接口来操 。与前面所讲的 Parameter 对应， rabbitmqctl 工具或者 HTTP API 接口各种都有 set、clear、list 的功能。</p><ul><li><p>用来设置一个 Policy：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy [-p vhost] [--priority priority] [--apply-to apply-to] &#123;name&#125; &#123;pattern&#125; &#123;definition&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例，设置默认的 vhost 中所有以<span class="string">"^amq."</span>开头的交换器为联邦交换器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy --apply-to exchanges --priority 1 p1 <span class="string">"^amq."</span> <span class="string">'&#123;"federation-upstream":"f1"&#125;'</span></span></span><br><span class="line">Setting policy</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root123 -XPUT -d <span class="string">'&#123;"pattern":"^amq\.","definition":&#123;"federation-upstream":"f1"&#125;,"priority":1,"apply-to":"exchanges"&#125;'</span> http://192.168.0.2:15672/api/policies/%2F/p1</span></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:36:20 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type : application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure></li><li><p>列出默认 vhost 所有的 Policy ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_policies [-p vhost] </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_policies </span></span><br><span class="line">Listing policies </span><br><span class="line">/  p1 exchanges ^amq. &#123;"federation-upstream":"f1"&#125;1</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XGET http://192.168.0.2:15672/api/policies/%2F</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:37:30 GMT</span><br><span class="line">content-length: 125</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">[&#123;"vhost":"/","name":"pl","pattern":"^amq\\.","apply-to":"exchanges","definition":&#123;"federation-upstream":"f1"&#125;,"priority":1&#125;]</span><br></pre></td></tr></table></figure></li><li><p>清除指定的 Policy ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_policy [-p vhost] &#123;name&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_policy p1</span></span><br><span class="line">Clearing policy "p1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XDELETE http://192.168.0.2:15672/api/policies/%2F/p1</span></span><br><span class="line"></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:38:55 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure><p>如果两个或多个 Policy 都作用到同一个交换器或者队列上，且这些 Policy 的优先级都是一样的，则参数项最多的 Policy 具有决定权。如果参数一样多，则最后添加的 Policy 具有决定权。</p></li></ul><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第五章《配置》，内容来自于《RabbitMQ实战指南》，内容包括：环境变量，配置文件，参数及策略。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（四）管理</title>
    <link href="http://linyishui.top/2020100201.html"/>
    <id>http://linyishui.top/2020100201.html</id>
    <published>2020-10-02T07:08:31.000Z</published>
    <updated>2020-10-06T12:41:01.662Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（四）管理"><a href="#RabbitMQ（四）管理" class="headerlink" title="RabbitMQ（四）管理"></a>RabbitMQ（四）管理</h1><h2 id="第一节-多租户与权限"><a href="#第一节-多租户与权限" class="headerlink" title="第一节 多租户与权限"></a>第一节 多租户与权限</h2><h3 id="1-1-什么是vhost？"><a href="#1-1-什么是vhost？" class="headerlink" title="1.1 什么是vhost？"></a>1.1 什么是vhost？</h3><p>每个 RabbitMQ 服务器都能创建虚拟的消息服务器，我们称之为虚拟主机（virtual host，简称为 vhost)。</p><ul><li>每一个 vhost 本质上是一个独立的小型 RabbitMQ 服务器；</li><li>拥有自己独立的队列、交换器及绑定关系等；</li><li>井且它拥有自己独立的权限。 </li><li>vhost 之间是绝对隔离的，无法将 vhostl 中的交换器与 vhost2 中的队列进行绑定，既保证了安全性，又可以确保可移植性。</li><li>建议用户对业务功能、场景进行归类 区分，并为之分配独立的 vhost。</li><li>vhost 是 AMQP 概念的基础，客户端在连接的时候必须制定一个 vhost。</li><li>默认的 vhost 是 <code>/</code> ，使用默认的用户名 guest 和密码 guest 就可以访问它。</li></ul><h3 id="1-2-常用指令"><a href="#1-2-常用指令" class="headerlink" title="1.2 常用指令"></a>1.2 常用指令</h3><p>创建新 vhost ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_vhost &#123;vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_vhost vhost1</span></span><br></pre></td></tr></table></figure><p>列表当前所有  vhost ：</p><ul><li>name：vhost名称；</li><li>tracing：是否使用trace功能。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts &#123;vhostinfoitem...&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts name tracing</span></span><br><span class="line">Listing vhosts</span><br><span class="line">vhost1 false</span><br><span class="line">/      false</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl trace_on</span></span><br><span class="line">Starting tracing for host "/"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts name tracing</span></span><br><span class="line">Listing vhosts</span><br><span class="line">vhost1 false</span><br><span class="line">/      true</span><br></pre></td></tr></table></figure><p>删除 vhost ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_vhost &#123;vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_vhost vhost1</span></span><br><span class="line">Deleting vhost "vhost1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts</span></span><br><span class="line">Listing vhosts</span><br></pre></td></tr></table></figure><p>vhost 授予用户权限：</p><ul><li>vhost：授予用户权限的vhost名称；</li><li>user：可以访问vhost的用户名；</li><li>conf：用于匹配用户在哪些资源上拥有可配置权限的正则表达式（指队列和交换器的创建和删除操作）；</li><li>write：用于匹配用户在哪些资源上拥有可写权限的正则表达式（指发布消息）；</li><li>read：用于匹配用户在哪些资源上拥有可读权限的正则表达式（指与消息有关的操作，如读取消息或清空队列）；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions &#123;-p vhost&#125; &#123;user&#125; &#123;conf&#125; &#123;write&#125; &#123;<span class="built_in">read</span>&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授予root：可访问vhost1，所有资源可配置 + 可写 + 可读权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions -p vhost1 root <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span></span><br><span class="line">Setting permissions for user "root" in vhost "vhost1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 授予root：可访问vhost2，<span class="string">"queue"</span>开头资源上可配置，所有资源可写 + 可读权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions -p vhost2 root <span class="string">"^queue.*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span></span><br><span class="line">Setting permissions for user "root" in vhost "vhost2"</span><br></pre></td></tr></table></figure><p>不同AMQP命令的列表和对应权限：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010101.png" alt></p><p>vhost 清除用户权限：禁止用户访问vhost</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_permissions &#123;-p vhost&#125; &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_permissions -p vhost1 root</span></span><br><span class="line">Clearing permissions for user "root" in vhost "vhost1"</span><br></pre></td></tr></table></figure><p>列表查询权限信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显式虚拟主机上的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_permissions &#123;-p vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显式用户的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_user_permissions &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_permissions -p vhost1</span></span><br><span class="line">Listing permissions in vhost "vhost1"</span><br><span class="line">root .* .* .*</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_user_permissions root</span></span><br><span class="line">Listing permissions for user "root"</span><br><span class="line">/      .* .* .*</span><br><span class="line">vhost1 .* .* .*</span><br></pre></td></tr></table></figure><p>rabbitmqctl 工具是用来管理 RabbitMQ 中间件的命令行工具，它通过连接各个 RabbitMQ 节点来执行所有操作。如果有节点没有运行，将显示诊断信息：不能到达或因不匹配的 Erlang cookie 而拒绝连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 标准语法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl [-n node] [-t timeout] [-q] &#123;<span class="built_in">command</span>&#125; [<span class="built_in">command</span> options]</span></span><br></pre></td></tr></table></figure><ul><li><code>[-n node]</code> ：默认节点 <code>rabbit@hostname</code> ，通常 <code>hostname -s</code> 命令输出是 <code>@</code> 标志后的东西。</li><li><code>[-t timeout]</code> ：操作超时时间。</li><li><code>[-q]</code> ：启用quiet模式，可以屏蔽一些消息。</li></ul><h2 id="第二节-用户管理"><a href="#第二节-用户管理" class="headerlink" title="第二节 用户管理"></a>第二节 用户管理</h2><p>在 RabbitMQ 中，用户是访问控制（Access Control) 的基本单元，且单个用户可以跨越多个 vhost 进行授权，同个用户针对多个 vhost 可以被赋予不同级别的访问权限。</p><h3 id="2-1-常用指令"><a href="#2-1-常用指令" class="headerlink" title="2.1 常用指令"></a>2.1 常用指令</h3><p>创建用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_user &#123;username&#125; &#123;password&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_user root root123</span></span><br><span class="line">Creating user "root"</span><br></pre></td></tr></table></figure><p>修改密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_password root root321</span></span><br></pre></td></tr></table></figure><p>清除密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_password &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_password root</span></span><br></pre></td></tr></table></figure><p>密码验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl authenticate_user &#123;username&#125; &#123;password&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl authenticate_user root root321</span></span><br></pre></td></tr></table></figure><p>删除用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_user &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_user root</span></span><br></pre></td></tr></table></figure><p>列表查询用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_users</span></span><br></pre></td></tr></table></figure><p>用户包括5种角色类型：</p><ul><li>none：无任何角色，新用户默认为none。</li><li>management：允许访问Web管理界面。</li><li>policymaker：可以管理策略和参数。</li><li>monitoring：可以看到所有连接、信道及节点的相关信息。</li><li>administrator：可以管理用户、虚拟主机、权限、策略、参数等。</li></ul><p>设置用户角色：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_user_tags &#123;username&#125; &#123;tag ...&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_user_tags root monitoring</span></span><br></pre></td></tr></table></figure><h2 id="第三节-Web端管理"><a href="#第三节-Web端管理" class="headerlink" title="第三节 Web端管理"></a>第三节 Web端管理</h2><h3 id="3-1-RabbitMQ-management"><a href="#3-1-RabbitMQ-management" class="headerlink" title="3.1 RabbitMQ management"></a>3.1 RabbitMQ management</h3><p>为了能够运行 rabbitmqctl 工具，当前的用户需要拥有访问 Erlang cookie 的权限，由于服务器可能是 guest 或者 root 用户身份来运行的，因此你需要获得这些文件的访问权限，这样就引申出来一些权限管理的问题。</p><p>RabbitMQ 开发了 RabbitMQ management ，由 Erlang 言编写，并且和 RabbitMQ 服务运行在同一个 Erlang 虚拟机中。提供了 Web 管理界面用来管理如前面所述的虚拟主机、用户等，也可以用来管理队列、交换器、绑定关系、策略、 参数等，还可以用来监控 RabbitMQ 服务的状态及一些数据统计类信息，可谓是功能强大，基本上能够涵盖所有 RabbitMQ 管理的功能。</p><h3 id="3-2-指令开启和关闭"><a href="#3-2-指令开启和关闭" class="headerlink" title="3.2 指令开启和关闭"></a>3.2 指令开启和关闭</h3><p>RabbitMQ插件的默认存放目录：<code>$RABBITMQ_HOME/plugins</code> ，格式为 <code>.ez</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rabbitmq-plugins语法格式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins [-n node] &#123;<span class="built_in">command</span>&#125; [<span class="built_in">command</span> options...]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> [plugin-name]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">disable</span> [plugin-name]</span></span><br></pre></td></tr></table></figure><p>开启 rabbitmq_management 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span></span><br><span class="line">Enabling plugins on node rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">rabbitmq_management</span><br><span class="line">The following plugins have been configured:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">Applying plugin configuration to rabbit@iZ2zeet6kto8eqx1w7sluzZ...</span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line"></span><br><span class="line">started 3 plugins.</span><br></pre></td></tr></table></figure><p>查看当前插件的使用情况：<code>[E*]</code> 表示显示启动，<code>[e*]</code> 表示隐式启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins list</span></span><br><span class="line">Listing plugins with pattern ".*" ...</span><br><span class="line"> Configured: E = explicitly enabled; e = implicitly enabled</span><br><span class="line"> | Status: * = running on rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line"> |/</span><br><span class="line">[  ] rabbitmq_amqp1_0                  3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_cache       3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_http        3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_ldap        3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_oauth2      3.8.8</span><br><span class="line">[  ] rabbitmq_auth_mechanism_ssl       3.8.8</span><br><span class="line">[  ] rabbitmq_consistent_hash_exchange 3.8.8</span><br><span class="line">[  ] rabbitmq_event_exchange           3.8.8</span><br><span class="line">[  ] rabbitmq_federation               3.8.8</span><br><span class="line">[  ] rabbitmq_federation_management    3.8.8</span><br><span class="line">[  ] rabbitmq_jms_topic_exchange       3.8.8</span><br><span class="line">[E*] rabbitmq_management               3.8.8</span><br><span class="line">[e*] rabbitmq_management_agent         3.8.8</span><br><span class="line">[  ] rabbitmq_mqtt                     3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_aws       3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_common    3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_consul    3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_etcd      3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_k8s       3.8.8</span><br><span class="line">[  ] rabbitmq_prometheus               3.8.8</span><br><span class="line">[  ] rabbitmq_random_exchange          3.8.8</span><br><span class="line">[  ] rabbitmq_recent_history_exchange  3.8.8</span><br><span class="line">[  ] rabbitmq_sharding                 3.8.8</span><br><span class="line">[  ] rabbitmq_shovel                   3.8.8</span><br><span class="line">[  ] rabbitmq_shovel_management        3.8.8</span><br><span class="line">[  ] rabbitmq_stomp                    3.8.8</span><br><span class="line">[  ] rabbitmq_top                      3.8.8</span><br><span class="line">[  ] rabbitmq_tracing                  3.8.8</span><br><span class="line">[  ] rabbitmq_trust_store              3.8.8</span><br><span class="line">[e*] rabbitmq_web_dispatch             3.8.8</span><br><span class="line">[  ] rabbitmq_web_mqtt                 3.8.8</span><br><span class="line">[  ] rabbitmq_web_mqtt_examples        3.8.8</span><br><span class="line">[  ] rabbitmq_web_stomp                3.8.8</span><br><span class="line">[  ] rabbitmq_web_stomp_examples       3.8.8</span><br></pre></td></tr></table></figure><p>还要再重启 RabbitMQ 服务使之生效。</p><p>关闭 <code>rabbitmq_management</code> 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_management</span></span><br></pre></td></tr></table></figure><h3 id="3-3-简单使用图形化工具"><a href="#3-3-简单使用图形化工具" class="headerlink" title="3.3 简单使用图形化工具"></a>3.3 简单使用图形化工具</h3><p>注意：阿里云服务器要在管理端配置入方向规则，开放15672端口。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010102.png" alt></p><p>尝试使用 guest 账号登录，但被拦截（如下），只允许本地地址访问。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010103.png" alt></p><p>使用 root 登录：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010104.png" alt></p><p>用户管理可以实现上节所有指令的功能：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010105.png" alt></p><p>可以指定用户角色：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010106.png" alt></p><p>新增了用户 <code>user01</code> ：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010107.png" alt></p><p>点击一个用户名，进入详情界面：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010108.png" alt></p><p>新用户没有指定虚拟主机，可以设置一个：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010109.png" alt></p><p>注意：有时Web管理界面可以正常登陆，但进入后显式部分页面，这种情况清空一下浏览器缓存即可。</p><h2 id="第四节-应用与集群管理"><a href="#第四节-应用与集群管理" class="headerlink" title="第四节 应用与集群管理"></a>第四节 应用与集群管理</h2><h3 id="4-1-应用管理"><a href="#4-1-应用管理" class="headerlink" title="4.1 应用管理"></a>4.1 应用管理</h3><p>停止 Erlang 虚拟机和 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop [pid_file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl shutdown</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop /opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@nodel.pid</span></span><br></pre></td></tr></table></figure><ul><li><code>stop [pid_file]</code> ：<ul><li>如果指定了 pid_file, 还需要等待指定进程的结束。</li><li>pid_file 是通过调用 <code>rabbitmq-server</code> 命令启动 RabbitMQ 服务时创建的，默认情况下存放于 Mnesia 目录中，可以通过 <code>RABBITMQ_PID_FILE</code> 这个环境变量来改变存放路径。</li><li>使用 <code>rabbitmq-server -detach</code> 这个带有 <code>-detach</code> 后缀的命令来启动 RabbitMQ 服务则不会生成 pid_file 文件。</li></ul></li><li><code>shutdown</code> ：<ul><li>执行这个命令会阻塞直到 Erlang 虚拟机进程退出。</li><li>和stop不同的是，不需要指定pid_file即可阻塞等待指定进程的关闭。</li></ul></li></ul><p>停止 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br></pre></td></tr></table></figure><ul><li>只停止 RabbitMQ 服务应用，Erlang 虚拟机还处于运行状态。</li></ul><p>启动 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app</span></span><br></pre></td></tr></table></figure><p>等待 RabbitMQ 应用的启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">wait</span> [pid_file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">wait</span></span></span><br><span class="line">/opt/rabbitmq/var/lib/rabbitmq/mnes a/rabbit\@nodel.pid</span><br></pre></td></tr></table></figure><ul><li>等待 pid_file 的创建，和对应进程启动。</li></ul><p>重置 RabbitMQ 节点（以及强制重置）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl reset</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl force_reset</span></span><br></pre></td></tr></table></figure><ul><li>重置操作将节点还原至最初状态。<ul><li>从所在集群删除此节点</li><li>从管理数据库中删除所有配置数据，如已配置的用户、vhost等</li><li>删除所有持久化消息。</li></ul></li><li>重置前要先停止 RabbitMQ 应用。</li><li>强制重置不同的是不会考虑集群和管理数据库的状态</li></ul><p>指示 RabbitMQ 节点轮换日志文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl rotate_logs &#123;suffix&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span> </span></span><br><span class="line">/opt/rabbitmq/var/log/rabbitmq</span><br><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br><span class="line">-rw-r--r-- 1 root root 1024127 Oct 18 11:56 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 720553 Oct 17 19:16 rabbit@node1-sasl.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原日志文件为 rabbit@node1.log 和 rabbit@node1-sasl.log</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl rotate_logs .1</span></span><br><span class="line">Rotating logs to files with suffix ".1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 轮换日志之后，原日志文件中的内容就被迫加到 rabbit@nodel.log.1 rabbit@node1-sasl.log.1 日志中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 18 12:05 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 1024202 Oct 18 12:05 rabbit@node1.log.1</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 18 12:05 rabbit@node1-sasl.log</span><br><span class="line">-rw-r--r-- 1 root root 720553 Oct 18 12:05 rabbit@node1-sasl.log.1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后重新建立 rabbit@node1.log 和 rabbit@node1-sasl.log 文件用来接收新的日志。</span></span><br></pre></td></tr></table></figure><ul><li>将原日志文件的内容追加到“原始名称+后缀”的日志文件中；</li><li>将新日志内容记录到新创建的日志中（同名），不存在会创建文件；</li><li>若不指定后缀，只会打开文件而不进行轮换。</li></ul><p>将 RabbitMQ 代码用 HiPE 编译，生成的 <code>.beam</code> 文件保存到指定文件目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl hipe_compile &#123;directory&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl hipe compile</span></span><br><span class="line">/opt/rabbitmq/tmp/rabbit-hipe/ebin</span><br><span class="line">HiPE compiling: |-----------------------------------------------|</span><br><span class="line">                |###############################################|</span><br><span class="line">Compiled 57 modules in 55s</span><br></pre></td></tr></table></figure><ul><li>如果要使用预编译的这些文件，则需要设置 RABBITMQ_SERVER_CODE_PATH 这个环境变量来指定 hipe_compile 调用的路径。</li></ul><h3 id="4-2-集群管理"><a href="#4-2-集群管理" class="headerlink" title="4.2 集群管理"></a>4.2 集群管理</h3><p>将节点加入指定集群中：（在这个命令执行前需要停止 RabbitMQ 应用并重置节点）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster &#123;cluster_node&#125; [--ram]</span></span><br></pre></td></tr></table></figure><p>显式集群的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure><p>修改集群节点的类型：（在这个命令执行前需要停止 RabbitMQ 应用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_cluster_node_type &#123;disc|ram&#125;</span></span><br></pre></td></tr></table></figure><p>将节点从集群中删除，允许离线执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl forget_cluster_node [--offline]</span></span><br></pre></td></tr></table></figure><p>在集群中的节点应用启动前咨询 clusternode 节点的最新信息，并更新相应的集群信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl update_cluster_nodes &#123;clusternode&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>和 join_cluster 不同 ，它不加入集群。</p></li><li><p>使用案例：考虑这样一种情况，节点A和节点B都在集群 中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B但是这样会失败，因为节点B经不在集群中了。 <code>Rabbitmqctl update_cluster_nodes -n A C</code> 可以解决这种场景下出现的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 假设己有 node1 和 node 组成的集群</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1. 初始状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br><span class="line">[</span><br><span class="line"> &#123;nodes, [&#123;disc , [rabbit@node1, rabbit@node2]&#125;]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;running_nodes, [rabbit@node2, rabbit@node1]&#125;,</span><br><span class="line"> &#123;cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions, []&#125;,</span><br><span class="line"> &#123;alarms, [</span><br><span class="line">     &#123;rabbit@node2, []&#125;, </span><br><span class="line">           &#123;rabbit@node1, []&#125; </span><br><span class="line">          ]</span><br><span class="line"> &#125; </span><br><span class="line">]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#2. 关闭 node1 节点的应用</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#3. 之后将 node3 加入到集群中 </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster rabbit@node2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#4. 再将 node2 节点的应用关闭</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#5. 最后启动 node1 节点的应用，此时会报错</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app </span></span><br><span class="line">Starting node rabbit@node1</span><br><span class="line">BOOT FAILED</span><br><span class="line">==========</span><br><span class="line">Timeout contacting cluster nodes : [rabbit@node2] . </span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#6. 如果在启动 node1 节点的应用之前咨询 node3 并更新相关集群信息则可以解决这个问题</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl update_cluster_nodes rabbit@node3</span></span><br><span class="line">Updating cluster nodes for rabbit@node1 from rabbit@node3</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app </span></span><br><span class="line">Starting node rabbit@node1</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#7. 查看最终集群状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure></li></ul><p>确保节点可以启动，即使它不是最后一个关闭的节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl force_boot</span></span><br></pre></td></tr></table></figure><ul><li>通常情况下，当关闭整个 RabbitMQ 集群时，重启的第一个节点应该是最后关闭的节点，因为它可以看到其他节点所看不到的事情。</li><li>有时会有一些异常情况出现，比如整个集群都掉电而所有节点都认为它不是最后关闭 的。</li><li>这时可以调用 <code>rabbitmqctl force_boot</code> 命令，告诉节点可以无条件地启动节点 。在此节点关闭后，集群的任何变化，它都会丢失。</li><li>如果最后一个关闭的节点永久 丢失了，那么需要优先使用 <code>rabbitmqctl forget_cluster_node --offline</code> 命令，因 为它可以确保镜像队列的正常运转。</li></ul><p>指示未同步队列 queue 的 slave 镜像可以同步 master 镜像行的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl sync_queue [-p vhost] &#123;queue&#125;</span></span><br></pre></td></tr></table></figure><ul><li>同步期间此队列会被阻塞（所有此队列的生产消费者都会被阻塞），直到同步完成。</li><li>执行成功的前提是队列 queue 配置了镜像。</li><li>未同步队列中的消息被耗尽后，最终也会变成同步，此命令主要用于未耗尽的队列。</li></ul><p>取消队列 queue 同步镜像的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cancel_sync_queue [-p vhost] &#123;queue&#125;</span></span><br></pre></td></tr></table></figure><p>设置集群名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_cluster_name &#123;name&#125;</span></span><br></pre></td></tr></table></figure><ul><li>集群名称在客户端连接时会通报给客户端。</li><li>默认是集群中第一个节点的名称。</li></ul><h2 id="第五节-服务端状态"><a href="#第五节-服务端状态" class="headerlink" title="第五节 服务端状态"></a>第五节 服务端状态</h2><p>服务器状态的查询会返回一个以制表符分隔的列表，此类命令接受一个可选 vhost 参数以显示其结果， 默认值为 <code>/</code> ：</p><ul><li>list_queues </li><li>list_exchanges </li><li>list_bindings </li><li>list_consumers </li></ul><h3 id="5-1-list-queues"><a href="#5-1-list-queues" class="headerlink" title="5.1 list_queues"></a>5.1 list_queues</h3><p>此命令返回队列的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_queues [-p vhost] [queueinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>queueinfoitem</code> 参数用于指示哪些队列的信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>name ：队列名称。</li><li>durable ：队列是否持久化。</li><li>auto_delete ：队列是否自动删除。</li><li>arguments ：队列的参数。</li><li>policy ：应用到队列上的策略名称。</li><li>pid：队列关联的 Erlang 进程的 ID。</li><li>owner_pid ：处理排他队列连接的 Erlang 进程。如果此队列是非排他的，此值将为空。 </li><li>exclusive ：队列是否是排他的。</li><li>exclusive_consumer_pid ：订阅到此排他队列的消费者相关的信道关联的 Erlang 进程。如果此队列是非排他的，此值将为空。</li><li>exclusive_consumer_tag ：订阅到此排他队列的消费者的 consumerTag 如果此队列是非排他的，此值将为空。 </li><li>messages_ready ：准备发送给客户端的消息个数。</li><li>messages_unacknowledged ：发送给客户端但尚未应答的消息个数。messages ：准备发送给客户端和未应答消息的总和。</li><li>messages_ready_ram ：驻留在内存中 messages_ready 的消息个数。</li><li>messages_unacknowledged_ram ：驻留在内存中。messages_unacknowledged 的消息个数。</li><li>messages ram ：驻留在内存中的消息总数。</li><li>messages_persistent ：队列中持久化消息的个数，对于非持久化队列来说总是0。</li><li>messages_bytes ：队列中所有消息的大小总和。不包括消息属性或者任何其他开销。 </li><li>messages_bytes_ready ：准备发送给客户端的消息的大小总和。 </li><li>messages_bytes_unacknowledged ：发送给客户端但尚未应答的消息的大小总和。</li><li>messages_bytes_ram：驻留在内存中的 messages_bytes。</li><li>messages_bytes_persiste ：队列中持久化的 messages_bytes。</li><li>disk_reads ：从队列启动开始，己从磁盘中读取该队列的消息总次数。 </li><li>disk_writes ：从队列启动开始，己向磁盘队列写消息的总次数。 </li><li>consumer ：消费者数目。 </li><li>consumer_utilisation ：队列中的消息能够立刻投递给消费者的比率，介于0或1之间 。这个受网络拥塞或者 Basic.Qos 的影响而小于1。</li><li>memory ：与队列相关的 Erlang 进程所消耗的内存字节数，包括栈、堆及内部结构。</li><li>slave_pids ：如果队列是镜像的，列出所有 slave 镜像的 pid。</li><li>synchronised_slave_pids ：如果队列是镜像的，列出所有己经同步的 slave 镜像 pid。</li><li>state ：队列状态。正常情况下是 running ；如果队列正常同步数据可能会有 <code>{syncing, MsgCount}</code> 的状态；如果队列所在的节点掉线了，则队列显示状态为 down （此时大多数的 queueinfoitems 也将不可用）。</li></ul><p>如果没有指定 queueinfoitems ，那么此命令将显示队列的名称和消息的个数。</p><h3 id="5-2-list-exchanges"><a href="#5-2-list-exchanges" class="headerlink" title="5.2 list_exchanges"></a>5.2 list_exchanges</h3><p>返回交换器的详细细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_exchanges [-p vhost] [exchangeinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>exchangeinfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>name ：交换器的名称。 </li><li>type ：交换器的类型。 </li><li>durable ：设置是否持久化。 durable 设置为 true 表示持久化，反之是非持久化。持久化可以将交换器信息存盘而在服务器重启的时候不会丢失相关信息。 </li><li>auto_delete ：设直是否自动删除。 </li><li>internal ：是否是内置的。 </li><li>arguments ：其他一些结构化参数，比如 alternate-exchange </li><li>policy ：应用到交换器上的策略名称。</li></ul><p><code>exchangeinfoitem</code> 的内容和客户端中的 <code>channel.exchangeDeclare</code> 方法的参数基本一致。</p><h3 id="5-3-list-bindings"><a href="#5-3-list-bindings" class="headerlink" title="5.3 list_bindings"></a>5.3 list_bindings</h3><p>返回绑定关系的细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_bindings [-p vhost] [bindinginfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>bindinginfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>source_name ：绑定中消息来源的名称。 </li><li>source_kind ：绑定中消息来源的类别。 </li><li>destination_name ：绑定中消息目的地的名称。 </li><li>destination_kind ：绑定中消息目的地的种类。 </li><li>routing_key ：绑定的路由键。 </li><li>arguments ：绑定的参数。</li></ul><h3 id="5-4-list-connections"><a href="#5-4-list-connections" class="headerlink" title="5.4 list_connections"></a>5.4 list_connections</h3><p>返回 TCP/IP 连接的统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_connections [connectioninfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>connectioninfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>pid ：与连接相关的 Erlang 进程 ID </li><li>name ：连接的名称。 </li><li>port ：服务器端口。</li><li>host ：返回反向 DNS 获取的服务器主机名称，或者 IP 地址，或者未启用。</li><li>peer_port ：服务器对端端口。当一个客户端与服务器连接时，这个客户端的端口就是 peer_port 。</li><li>peer_host ：返回反向 DNS 获取的对端主机名称，或者 IP 地址， 或者未启用。 </li><li>ssl ：是否启用 SSL 。</li><li>ssl_protocol ：SSL 协议，如 tlsvl 。</li><li>ssl_key_exchange ：SSL 密钥交换算法，如 rsa 。</li><li>ssl_cipher ：SSL 加密算法，如 aes_256_cbc 。</li><li>ssl_hash ：SSL 哈希算法，如 sha 。</li><li>peer_cert_subject ：对端的 SSL 安全证书的主题，基于 RFC4514 的形式。 peer_cert_issuer ：对端 SSL 安全证书的发行者， 基于 RFC4514 的形式。 </li><li>peer_cert_validity ：对端 SSL 安全证书的有效期。 </li><li>state ：连接状态，包括 starting、tuning、opening、running、flow、blocking、blocked、closing、closed 这几种。 </li><li>channels ：该连接中的信道个数。 </li><li>protocol ：使用的 AMQP 协议的版本，当前是｛0,9,1｝或者｛0,8,0｝。注意，如果客户端请求的是 AMQP 0-9 的连接， RabbitMQ 也会将其视为 0-9-1 。</li><li>auth_mechanism ：使用的 SASL 认证机制，如 PLAIN、AMQPLAIN、EXTERNAL、RABBIT-CR-DEMO 等。</li><li>user ：与连接相关的用户名。 </li><li>vhost ：与连接相关的 vhost 的名称。 </li><li>timeout ：连接超时／协商的心跳间隔，单位为秒。 </li><li>frame_max ：最大传输帧的大小，单位为 B 。</li><li>channel_max ：此连接上信道的最大数量。如果值 0，则表示无上限，但客户端一般会将0转变为 65535 。</li><li>client_properties ：在建立连接期间由客户端发送的信息属性。 </li><li>recv_oct ：收到的字节数。 </li><li>recv_cnt ：收到的数据包个数。</li><li>send_oct ：发送的字节数。 </li><li>send_cnt ：发送的数据包个数。 </li><li>send_pend ：发送队列大小。 </li><li>connected_at ：连接建立的时间戳。</li></ul><h3 id="5-5-list-channels"><a href="#5-5-list-channels" class="headerlink" title="5.5 list_channels"></a>5.5 list_channels</h3><p>返回当前所有信道的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_channels [channelinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>channelinfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>pid ：与连接相关的 Erlang 进程 ID 。</li><li>connection ：信道所属连接的 Erlang 进程 ID 。</li><li>name ：信道的名称。 </li><li>number ：信道的序号。 </li><li>user ：与信道相关的用户名称。 </li><li>vhost ：与信道相关的 vhost 。</li><li>transactional ：信道是否处于事务模式。 </li><li>confirm ：信道是否处于 publiser confirm 模式。 </li><li>consumer_count ：信道中的消费者的个数。 </li><li>messages_unacknowledged ：已投递但是还未被 ack 的消息个数。</li><li>messages_uncommitted ：已接收但是还未提交事务的消息个数。</li><li>acks_uncommitted ：已 ack 收到但是还未提交事务的消息个数。</li><li>messages_unconfirmed ：已发送但是还未确认的消息个数。如果信道不处于 publisher confirm 模式下，则此值为 0 。</li><li>perfetch_count ：新消费者的 Qos 个数限制，0 表示无上限。</li><li>global_prefetch_count ：整个信道的 Qos 个数限制，0 表示无上限。</li></ul><h3 id="5-6-list-consumers"><a href="#5-6-list-consumers" class="headerlink" title="5.6 list_consumers"></a>5.6 list_consumers</h3><p>列举消费者信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_consumers [-p vhost]</span></span><br></pre></td></tr></table></figure><p>每行将显示由制表符分隔的己订阅队列的名称、相关信道的进程标识、 consumerTag、是否需要消费端确认、 prefetch_count 及参数列表这些信息。</p><h3 id="5-7-其它"><a href="#5-7-其它" class="headerlink" title="5.7 其它"></a>5.7 其它</h3><p>显示 Broker 状态，比如当前 Erlang 节点上运行的应用程序、RabbitMQ/Erlang 的版本信息、 OS 的名称、内存及文件描述符等统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl status</span></span><br></pre></td></tr></table></figure><p>对 RabbitMQ 节点进行健康检查，确认应用是否正常运行、list_queues 和 list_channels 是否能够正常返回等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl node_health_check</span></span><br></pre></td></tr></table></figure><p>显示每个运行程序环境中每个变量的名称和值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl environment</span></span><br></pre></td></tr></table></figure><p>为所有服务器状态生成一个服务器状态报告，井将输出重定向到一个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl report</span></span><br></pre></td></tr></table></figure><p>执行任意 Erlang 表达式：（此处暂时不作eval扩展）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">eval</span> &#123;expr&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第六节-HTTP-API接口管理"><a href="#第六节-HTTP-API接口管理" class="headerlink" title="第六节 HTTP API接口管理"></a>第六节 HTTP API接口管理</h2><h3 id="6-1-HTTP-API接口功能"><a href="#6-1-HTTP-API接口功能" class="headerlink" title="6.1 HTTP API接口功能"></a>6.1 HTTP API接口功能</h3><p>RabbitMQ Management 插件不仅提供了 Web 管理界面，还提供了 HTTP API 接口来方便调用。比如创建一个队列，就可以通过 PUT 方法调用 <code>/api/queues/vhost/name</code> 接口来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root123 -H <span class="string">"content-type:application/json"</span></span></span><br><span class="line">-XPUT -d '&#123;"auto_delete":false,"durable":true,"node":"rabbit@node2"&#125;' </span><br><span class="line">http://192.168.0.2:15672/api/queues/%2F/queue</span><br><span class="line"></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Fri, 25 Aug 2017 06:03:17 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure><p><code>%2F</code> 即 <code>/</code> 默认的 vhost，特殊字符需要在HTTP URL中进行转义。</p><p>完全基于 RESTful 风格：</p><ul><li>GET 方法一般用来获取如集群、节点、队列、交换器等信息。</li><li>PUT 方法用来创建资源，如交换器、队列之类的。</li><li>DELETE 方法用来删除资源。</li><li>POST 方法也是用来创建资源的，与 PUT 不同的是，POST 创建的是无法用具体名称的资源。比如绑定关系（bindings）和发布消息（publish）无法指定一个具体的名称。</li></ul><h3 id="6-2-接口列表"><a href="#6-2-接口列表" class="headerlink" title="6.2 接口列表"></a>6.2 接口列表</h3><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 10%;}table th:nth-of-type(3){width: 10%;}table th:nth-of-type(4){width: 10%;}table th:nth-of-type(5){width: 60%;}</style><table><thead><tr><th style="text-align:center">GET</th><th style="text-align:center">PUT</th><th style="text-align:center">DELETE</th><th style="text-align:center">POST</th><th>Path &amp; Description</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/overview <br>描述整个系统的各种信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/cluster-name <br>集群的名称</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/nodes <br>集群中节点的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/nodes/name <br>集群中单个节点的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/extensions <br>管理插件的扩展列表</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/definitions <br>GET 方法列出集群中所有的元数据信息，包括交换器、队列、绑定关系、用户、 host 权限及参数。<br>POST 方法用来加载新的元数据信息，不过需要注意如下内容： <br>(1）新的原数据信息会与原本的合并，如果旧的元数据信息中某些项在新加载的 元数据中没有定义， 则不受任何影响<br> (2）对于交换器、队列及绑定关系等不可变的内容，如果新旧元数据有冲突，则会报错 <br>(3）对于其他的可变的内容，如果新旧元数据有冲突，则新的会替换旧的<br> (4）如果在加载过程中发生错误，加载过程会停止，最终只能加载到部分新的元数据信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/definitions/vhost<br>将/api/definitions 接口细化到 vhost 级别，其余内容同上</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/connections<br>所有的连接信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/vhost/connections<br>指定的 vhost 中所有连接信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/connections/name<br>GET 方法列出指定连接的信息<br>DELETE 方法可以 close 指定的连接</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/connections/name/channels<br>指定连接的所有信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/channels<br>所有信道的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/vhost/channels <br>指定的 vhost 中所有信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/channels/channel <br>指定的信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/consumers <br>所有的消费者信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/consumers/vhost <br>指定 vhost 中的所有消费者信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges <br>所有交换器信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost <br>指定 vhost 中所有交换器信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/exchanges/vhost/name<br>GET 方法列出一个指定的交换器信息。<br>PUT 方法可以声明一个交换器，对应的内容可以参考如下： <br>{“type”:”direct”,”auto_ delete”:false,”durable”:true ,”internal”:false,”arguments”:{}} <br>其中 type 是必需的，其他都是可选的。 <br>DELETE 方法可以删除指定的交换器，其中可以添加 if-unused=true 参数用来防止有队列与其绑定时能够被删除</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost/name/bindings/source<br>列出指定交换器的所有绑定关系，此交换器需为绑定关系的源端</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost/name/bindings/destination<br>列出指定交换器的所有绑定关系，此交换器帘为绑定关系的目的端</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/exchanges/vhost/name/publish<br>向指定的交换器中发送一条消息，对应的内容可以参考： <br>{“properties”:{},”routing_key”,”my key”,”payload:”my body”,”payload_ encoding”:”string”} <br>这里所有的项都是必需的，如果发送成功，会返回 ｛”routed”:true} 。这个接口不适合做稳定、高效的发送之用 ，以采用其他的方式比如通过 AMQP 协议或者其他长连接的协议</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues<br>列出所有的队列信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues/vhost<br>列出指定的 vhost 下所有的队列信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/queues/vhost/name<br>GET 方法列出执行的队列信息<br>PUT 方法可声明一个队列，对应的内容可以参考： <br>{“auto_delete”:false,”durable”:true,”arguments”:{},”node”:”rabbit@smacmullen”} <br>其中所有的项都是可选的。 <br>DELETE 方法用来删除一个队列，当然可以指定 if-empty 或 if-unused 参数</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues/vhost/name/bindings<br>列出指定队列的所有绑定关系</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/queues/vhost/name/contents<br>清空（purge）指定的队列</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/queues/vhost/name/actions<br>对指定的队列附加一些动作，对应的内容可以参考：<br>{“action”:”sync”｝ <br>目前仅支持 sync 和 cancel_sync</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/queues/vhost/name/get<br>从指定队列中获取消息，对应的内容可以参考： <br>{“count”:5,”requeue”:true,”encoding”:”auto”,”truncate”:50000}<br>count 表示最大能获取的消息个数，实际可能小于这个值；requeue 表示获取到这些消息时是否从队列中删除，如果 requeue 为 true ，则消息不会被删除，但是消息的 redelivered 标示会被设置；encoding 表示编码格式，两种取值：auto 和 base64，auto 指如果消息符合 UTF-8 格式则返回 string 类型，否则为 base64 类型； truncate表示如果消息的 payload 过指定大小会被截断。除了 truncate 其余项都是必需的。注意这个接口是用来做测试用的，如果要持续的消费队列的消息，需要采用其他的方法</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/bindings<br>列出所有绑定关系的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/bindings/vhost<br>列出指定的 vhost 中所有绑定关系的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/bindings/vhost/e/exchange/q/queue<br>GET 方法列出一个指定的交换器和一个指定的队列中的所有绑定关系的信息。注意一个交换器和一个队列之间可以绑定多次.。<br>POST 用来添加绑定关系，对应的内容可以参考：<br> {“routing_ key”:”my_routing_ key”,”arguments”:{}} 其中所有的项都是可选的</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/bindings/vhost/e/exchange/q/queue/props<br>GET 方法列出一个交换器和一个队列的一个单独的绑定关系的信息 <br>DELETE 方法用来解绑相应的绑定关系，其中 props 表示的是 /api/bindings 返回的绑定关系列表里的 properties_key 的值，具体是指绑定时 routingkey 与 arguments 的哈希值的组合，一般 arguments 为空，此时 properties_key 等于 routingkey</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/bindings/vhost/e/source/e/destination<br>GET 方法用来列出两个交换器的所有绑定关系的信息<br>POST 方法用来添加绑定关系，与接口 /api/bindings/vhost/e/exchange/q/queue 相似</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/bindings/vhost/e/source/e/destination/props<br>与接口/api/bindings/vhost/e/exchange/q/queue/props 相似，只不过是两个交换器之间的关系</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts<br>列出所有 vhost 的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/vhosts/name <br>GET 方法列出指定 vhost 的信息<br>PUT 方法用来添加 vhost，host 通常只有一个名字，所以不需要任何内容以做请求之用。<br>DELETE 方法用来删除 vhost</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/name/permissions<br>列出指定 vhost 的所有权限信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/users<br>列出所有的用户信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/users/name<br>GET 方法列出指定的用户信息<br>POST 方法用来添加一个用户，对应的内容参考：<br>{“password”:”secret”,”tags”:”administrator”} <br>或者<br>{“password_hash”:”2lmotb814HODViLaK9Fxi619ds8=”,”tags”:”administrator”} <br>其中 tags 是必需的，用来标识用户角色。对于 password 或者 password_hash，两者可以择其一。 如果 password_hash 为“”，则用户可以无密码登录。<br>DELETE 方法用来删除指定的用户</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/users/user/permissions<br>用来获取指定用户的所有权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/wboami<br>当前的登录用户</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/perrnissions<br>列出所有用户的所有权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/permissions/vhost/user<br>GET 方法列出指定的权限<br>PUT 方法添加指定的权限，对应的内容惨考：<br>{“configure”:”.*“,”write”:”.*“,”read”:”.*“} <br>所有项都是必需的，对应 configure、write、read 的细节可以参考 5.1节 <br>DELETE 方法用来删除指定的权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters<br>列出所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters/component<br>列出指定组件（比如 federation-upstream、shovel 等）的所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters/component/vhost<br>列出指定 vhost 和组件的所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/parameters/component/vhost/name<br>GET 方法列出一个指定的 vbost 级别的 Parameter<br>PUT 方法用来设置一个 Parameter ，对应的内容参考如下：<br> {“vhost”:”/“,”component”:”federation”,”name”:”local_username”,”value”:”guest”} <br>DELETE 方法用来删除一个指定的 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/global-parameters<br>列出所有的 global 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/global-parameters/name<br>GET 方法列出一个指定的 global 级别的 Parameter<br>PUT 方法用来设置一个指定的 global 级别的 Parameter，对应的内容参考：<br>{“name”:”user_ vhost_mapping”,”value”:{“guest”:”/“,”rabbit”:”warren”}}<br>DELETE 方法用来删除一个指定的 global 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/policies<br>列出所有的 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/policies/vhost<br>列出指定 vhost 下的所有 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/policies/vhost/name<br>GET 方法列出指定的 Policy<br>PUT 方法用来设置 Policy 对应的内容可以参考：<br>{“pattern”:”^amq.”,”definition”: {“federation-upstream-set”:”all”}, “priority”:0, “apply-to”:”all”} <br>其中 pattern 和 definition 是必需的，其余可选。<br>DELETE 方法用来删除一个指定的 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>api/aliveness-test/vhost<br>声明一个队列，并基于其上生产和消费一条消息，用来测试系统是否运行完好。这个接口可以方便一些监控工具〈如 Zabbix ）的调用。如果系统运行完好，调用这接口会返回 {“status”:”ok”}，状态码为 200</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/healthchecks/node<br>对当前节点中进行基本的健康检查，包括 RabbitMQ 应用、信道、队列是否正常运行且无告警。如果一切正常则接口返回：<br>{“status”:”ok”} <br>如果有异常则接口返回： <br>{“status”:”failed”,”reason”,”string”} <br>不管正常与否，状态都是 200</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/healthchecks/node/node<br>对指定节点进行基本的健康检查，其余同 /api/healthchecks/node</td></tr></tbody></table><p>创建、显示和删除队列 queue 可以这样实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin -u root -p rootl23 <span class="built_in">declare</span> queue name=queue1</span></span><br><span class="line">queue declared </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin list queues</span></span><br><span class="line">+--------+----------+</span><br><span class="line">|  name  | messages |</span><br><span class="line">+--------+----------+</span><br><span class="line">| queue1 |  0       |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin -u root -p rootl23 delete queue name=queue1</span></span><br><span class="line">queue deleted</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin list queues</span></span><br><span class="line">No items</span><br></pre></td></tr></table></figure><p>rabbitmqadmin 需要安装，可以通过Web管理界面左下角 【Command Line】进行下载，或者如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://192.168 0.2:15672/cli/rabbitmqadmin</span></span><br><span class="line">--2017-08-25 17:32:50-- http://192.168.0.2:15672/cli/rabbitmqadmin</span><br><span class="line">Connecting to 192.168.0.2:15672 ... connected.</span><br><span class="line">HTTP request sent, awaiting response ... 200 OK</span><br><span class="line">Length: 36192 (35K) [application/octet-stream]</span><br><span class="line">Saving to "rabbitmqadmin"</span><br><span class="line"><span class="meta">100%</span><span class="bash">［＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＞］ 36,192 --.-K/s .<span class="keyword">in</span> 0s</span></span><br><span class="line">2017-08-25 17:32:50 (372 MB/s) - "rabbitmqadmin" saved [36192/36192]</span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x rabbitmqadmin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保已安装python</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python </span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取使用方式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第四章《管理》，内容来自于《RabbitMQ实战指南》，从服务端的角度介绍 RabbitMQ 的一些工具应用，内容包括：rabbitmqctl 工具和 rabbitmq management 插件。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（三）进阶</title>
    <link href="http://linyishui.top/2020092801.html"/>
    <id>http://linyishui.top/2020092801.html</id>
    <published>2020-09-28T05:34:23.000Z</published>
    <updated>2020-10-02T07:58:24.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="第一节-消息何去何从"><a href="#第一节-消息何去何从" class="headerlink" title="第一节 消息何去何从"></a>第一节 消息何去何从</h2><h3 id="1-1-消息不可达时返回给生产者"><a href="#1-1-消息不可达时返回给生产者" class="headerlink" title="1.1 消息不可达时返回给生产者"></a>1.1 消息不可达时返回给生产者</h3><p> <code>channel.basicPublish</code> 两个容易混淆的参数：都可以在消息传递过程不可达目的地时将消息返回给生产者。</p><ul><li><p>mandatory：为 true 时，且交换器无法根据自身的类型和路由键找到一个符合条件的队列，调用 <code>Basic.Return</code> 命令将消息返回给生产者。为 false 时，消息直接被丢弃。</p><p>如下代码，输出 <code>&quot;Basic.Return 返回的结果是：mandatory test&quot;</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">true</span>,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        <span class="string">"mandatory test"</span>.getBytes());</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用channel.addReturnListener添加ReturnListener监听器来使生产者获取是否被正确路由到合适队列</span></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 AMQP.BasicProperties basicProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">"Basic.Return 返回的结果是："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMQP协议中对应的流转过程：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010165.png" alt></p></li><li><p>immediate：为true时，若交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时， 该消息会通过 <code>Basic.Return</code> 返回至生产者。</p><ul><li>RabbitMQ 3.0 时去除了对此参数的支持，会影响镜像队列的性能，建议用TTL和DLX方法替代。</li></ul></li></ul><p>概括来说， mandatory 参数告诉服务器至少将该消息路由到一个队列中，否则将消息返回给生产者。 immediate 参数告诉服务器，如果该消息关联的队列上有消费者，则立刻投递；如果所有匹配的队列上都没有消费者，则直接将消息返还给生产者，不用将消息存入队列而等待消费者了。</p><h3 id="1-2-备份交换器"><a href="#1-2-备份交换器" class="headerlink" title="1.2 备份交换器"></a>1.2 备份交换器</h3><p><strong>备份交换器</strong>，英文名称为 <strong>Alternate Exchange</strong> ，简称<strong>AE</strong>，或者更直白地称之为“备胎交换器”。</p><p>生产者在发送消息的时候如果不设置 mandatory 参数，那么消息在未被路由的情况下将会丢失；如果设置了 mandatory 参数，那么需要添加 ReturnListener 的编程逻辑，生产者的代码将变得复杂。</p><p><strong>既不想复杂化生产者的编程逻辑，又不想消息丢失，可以使用备份交换器</strong>，这样可以将未被路由的消息存储在 RabbitMQ 中，再在需要的时候去处理这些消息。</p><p><strong>消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。</strong></p><h4 id="1-2-1-实现方式"><a href="#1-2-1-实现方式" class="headerlink" title="1.2.1 实现方式"></a>1.2.1 实现方式</h4><p><strong>实现方式</strong>：</p><ul><li>调用 <code>channel.exchangeDeclare()</code> 时添加 <code>alternate-exchange</code> 参数实现；</li><li>通过策略（Policy）方式实现。默认第一种优先级高。</li></ul><p>添加 <code>alternate-exchange</code> 参数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"alternate-exchange"</span>, <span class="string">"myAe"</span>);</span><br><span class="line"><span class="comment">// 声明两个交换器，分别绑定相应队列</span></span><br><span class="line"><span class="comment">// 并且设置myAe为normalExchange的备份交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"normalExchange"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">channel.exchangeDeclare(<span class="string">"myAe"</span>, <span class="string">"fanout"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"normalQueue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"normalQueue"</span>, <span class="string">"normalExchange"</span>, <span class="string">"normalKey"</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"unroutedQueue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"unroutedQueue"</span>, <span class="string">"myAe"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>此时发送一条消息到交换器normalExchange，当路由键等于normalKey时，消息可以正确路由到队列normalQueue；否则消息会发送给备份交换器myAe，并发送到队列unroutedQueue。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010166.png" alt></p><p>策略实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy AE <span class="string">"^normalExchange$"</span> <span class="string">'&#123;"alternate-exchange": "myAE"&#125;'</span></span></span><br></pre></td></tr></table></figure><p><strong>建议设置备份交换器为 fanout 类型</strong>：如果备份交换器的类型是 direct 并且有一个与其绑定的队列，假设绑定的路由键是 key1 当某条携带路由键为 key2 的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失。如果消息携带的路由键为 key1 ，则可以存储到队列中。</p><h4 id="1-2-2-特殊情况"><a href="#1-2-2-特殊情况" class="headerlink" title="1.2.2 特殊情况"></a>1.2.2 特殊情况</h4><ul><li>如果设置的备份交换器不存在，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li><li>如果备份交换器没有绑定任何队列，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li><li>如果备份交换器没有任何匹配的队列，客户端和 RabbitMQ 服务端都不会有异常出现， 此时消息会丢失。</li><li>如果备份交换器和 mandatory 参数一起使用，那么 mandatory 参数无效。</li></ul><h2 id="第二节-过期时间-TTL"><a href="#第二节-过期时间-TTL" class="headerlink" title="第二节 过期时间(TTL)"></a>第二节 过期时间(TTL)</h2><p>过期时间（Time to Live，TTL），可以对消息和队列设置TTL。</p><h3 id="2-1-设置消息的TTL"><a href="#2-1-设置消息的TTL" class="headerlink" title="2.1 设置消息的TTL"></a>2.1 设置消息的TTL</h3><p>设置方式：</p><ul><li><p><strong>通过队列属性设置</strong>，队列内所有消息都有相同的TTL；</p><ul><li><p>在 <code>channel.queueDeclare()</code> 中加入 <code>x-message-ttl</code> 参数，单位毫秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"x-message-ttl"</span>, <span class="number">6000</span>);</span><br><span class="line">channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);</span><br></pre></td></tr></table></figure></li><li><p>通过策略-Policy来设置TTL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy TTL <span class="string">".*"</span> <span class="string">'&#123;"message-ttl":60000&#125;'</span> --apply-to queues</span></span><br></pre></td></tr></table></figure></li><li><p>通过调用HTTP API接口设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root -H <span class="string">"content-type:application/json"</span>-X PUT -d<span class="string">'&#123;"auto_delete":false,"durable":true,"arguments":&#123;"x-message-ttl": 60000&#125;&#125;'</span> http://localhost:15672/api/queues/&#123;vhost&#125;/&#123;queuename&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>对消息本身进行单独设置</strong>，两种一起使用以较小的值为准。</p><ul><li><p>在 <code>channel.basicPublish()</code> 中加入 expiration 属性参数，单位毫秒：(消息过期后马上从队列抹去，因为过期消息都在队列头部，只要定期扫描头部并删除即可)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line"><span class="comment">// 持久化消息</span></span><br><span class="line">builder.deliveryMode(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 设置TTL=60000ms</span></span><br><span class="line">builder.expiration(<span class="string">"60000"</span>);</span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties. <span class="string">"ttlTestMessage"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties;</span><br><span class="line"><span class="comment">// 持久化消息</span></span><br><span class="line">properties.setDeliveryMode(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 设置TTL=60000ms</span></span><br><span class="line">properties.setExpiration(<span class="string">"60000"</span>);</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties. <span class="string">"ttlTestMessage"</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>通过调用HTTP API接口设置：（消息过期不会马上抹去，因为每条消息过期时间不同，需要扫描整个队列，不如等被消费时再做判断）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root -H <span class="string">"content-type:application/json"</span>-X POST -d<span class="string">'&#123;"properties":&#123;"expiration":"60000"&#125;,"routing_key":"routingKey","payload":"my body","payload_encoding":"string"&#125;'</span> http://localhost:15672/api/queues/&#123;vhost&#125;/&#123;exchange</span></span><br><span class="line">name&#125;/publish</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>消息在队列中生存时间超过TTL时，会变成“死信”（Dead Message）。不设置TTL，默认不会过期；若设置为0，则表示直接投递到消费者，否则直接丢弃，可以部分替代上文所提 immediate 参数，但没有 <code>Basic.Return</code> 返回消息（可以通过死信队列来实现）。</p><h3 id="2-2-设置队列的TTL"><a href="#2-2-设置队列的TTL" class="headerlink" title="2.2 设置队列的TTL"></a>2.2 设置队列的TTL</h3><p>通过 <code>channel.queueDeclare()</code> 方法中的 <code>x-expires</code> 参数可以控制队列被自动删除前处于未使用状态的时间。未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过 <code>Basic.Get</code> 命令。</p><p>设置队列里的 TTL 可以应用于类似 <strong>RPC 方式的回复队列</strong>，在 RPC 中，许多队列会被创建出来，但是却是未被使用的。RabbitMQ 会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时 。</p><p>创建一个过期时间为30分钟的队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"x-expires"</span>, <span class="number">1800000</span>);</span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><h2 id="第三节-死信队列"><a href="#第三节-死信队列" class="headerlink" title="第三节 死信队列"></a>第三节 死信队列</h2><h3 id="3-1-死信交换器和死信队列"><a href="#3-1-死信交换器和死信队列" class="headerlink" title="3.1 死信交换器和死信队列"></a>3.1 死信交换器和死信队列</h3><p>死信交换器（Dead-Letter-Exchange，DLX）也可称为死信邮箱。当消息在一个队列中变成死信（dead message），能被重新被发送到另一交换器，这个交换器就是DLX，绑定DLX的队列就是死信队列。</p><p>DLX和普通交换器没区别，当设置的队列存在死信时，会自动的被发布到设置的DLX上，进而路由到死信队列，这个特性可以和TTL为0配合替代 immediate 参数。</p><h3 id="3-2-消息变为死信的原因"><a href="#3-2-消息变为死信的原因" class="headerlink" title="3.2 消息变为死信的原因"></a>3.2 消息变为死信的原因</h3><ul><li>消息被拒绝（ <code>Basic.Reject</code> / <code>Basic.Nack</code> ），井且设置 requeue 参数为 false;</li><li>消息过期；</li><li>队列达到最大长度。</li></ul><h3 id="3-3-实现方式"><a href="#3-3-实现方式" class="headerlink" title="3.3 实现方式"></a>3.3 实现方式</h3><ul><li><p>通过 <code>channel.queueDeclare()</code> 方法中设置 <code>x-dead-letter-exchange</code> 参数来为队列添加DLX：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建DLX</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"dlx_exchange"</span>, <span class="string">"direct"</span>);</span><br><span class="line"><span class="comment">//通过</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;;</span><br><span class="line">args.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">" dlx_exchange "</span>);</span><br><span class="line"><span class="comment">//也可以为DLX指定路由键，默认为原队列的路由键</span></span><br><span class="line">args.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"dlx-routing-key"</span>);</span><br><span class="line"><span class="comment">//为队列myqueue添加DLX</span></span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过策略-Policy来设置TTL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy DLX <span class="string">".*"</span> <span class="string">'&#123;"dead-letter-exchange":" dlx_exchange "&#125;'</span> --apply-to queues</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-过程"><a href="#3-4-过程" class="headerlink" title="3.4 过程"></a>3.4 过程</h3><p>生产者首先发送一条携带路由键为 <code>rk</code> 的消息，然后经过交换器 <code>exchange.normal</code> 顺利地存储到队列 <code>queue.normal</code> 。由于队列 <code>queue.normal</code> 设置了过期时间为 10s ，在这 10s 内没有消费者消费这条消息，那么判定这条消息为过期。由于设置了 DLX ，过期之时，消息被丢给交换器 <code>exchange.dlx</code> 中，这时找到与 <code>exchange.dlx</code> 匹配的队列 <code>queue.dlx</code> 后消息被存储在 <code>queue.dlx</code> 这个死信队列中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010167.png" alt></p><h3 id="3-5-作用"><a href="#3-5-作用" class="headerlink" title="3.5 作用"></a>3.5 作用</h3><p>DLX 是一个非常有用的特性，它可以处理异常情况下，消息不能够被消费者正确消费（消费者调用了 <code>Basic.Nack</code> 或者 <code>Basic.Reject</code> ）而被置入死信队列中的情况，后续分析程序可以<strong>通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以改善和优化系统</strong>。</p><p><strong>DLX 配合 TTL 使用还可以实现延迟队列的功能</strong>。</p><h2 id="第四节-延迟队列"><a href="#第四节-延迟队列" class="headerlink" title="第四节 延迟队列"></a>第四节 延迟队列</h2><h3 id="4-1-延迟消息"><a href="#4-1-延迟消息" class="headerlink" title="4.1 延迟消息"></a>4.1 延迟消息</h3><p>延迟队列存储的对象是对应的延迟消息，所谓<strong>“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费</strong>。</p><h3 id="4-2-使用场景"><a href="#4-2-使用场景" class="headerlink" title="4.2 使用场景"></a>4.2 使用场景</h3><ul><li><strong>支付超时</strong>：在订单系统中， 一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些订单了。</li><li><strong>定时功能</strong>：用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将用户指令发送到延迟队列，当指令设定的时间到了再将指令推送到智能设备。</li></ul><h3 id="4-3-实现方式"><a href="#4-3-实现方式" class="headerlink" title="4.3 实现方式"></a>4.3 实现方式</h3><p>在 AMQP 协议中，或者 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面所介绍的 <strong>DLX + TTL 模拟出延迟队列的功能</strong>。</p><p>图4-4不仅展示的是死信队列的用法，也是延迟队列的用法， <code>queue.dlx</code> 这个死信队列可以看作延迟队列。假设一个应用中需要将每条消息都设置为 10 秒的延迟， 生产者通过 <code>exchange.normal</code> 这个交换器将发送的消息存储在 <code>queue.normal</code> 这个队列中。消费者订阅的并非是 <code>queue.normal</code> 这个队列，而是 <code>queue.dlx</code> 这个队列 。当消息从 <code>queue.normal</code> 这个队列中过期之后被存入 <code>queue.dlx</code> 这个队列中，消费者就恰巧消费到了延迟 10 秒的这条消息。</p><p>在真实应用中，对于延迟队列可以根据延迟时间的长短分为多个等级，一般分为 5秒、10 秒、30 秒、 1分钟、5分钟、10 分钟、30 分钟、 1小时这几个维度，当然也可以再细化一下。</p><p>图4-5为了简化说明，这里只设置了5秒、10 秒、30 秒、1分钟这四个等级。根据应用需求的不同，生产者在发送消息的时候通过设置不同的路由键，以此将消息发送到与交换器绑定的不同的队列中。这里队列分别设置了过期时间为5秒、10 秒、30 秒、1分钟，同时也分别配置了 DLX 和相应的死信队列。</p><p>当相应的消息过期时，就会转存到相应的死信队列（即延迟队列〉中，这样消费者根据业务自身的情况，分别选择不同延迟等级的延迟队列进行消费。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010168.png" alt></p><h2 id="第五节-优先级队列"><a href="#第五节-优先级队列" class="headerlink" title="第五节 优先级队列"></a>第五节 优先级队列</h2><p>优先级队列，顾名思义，具有高优先级的队列具有高的优先权，优先级高的消息具备优先被消费的特权。</p><p>可以通过设置队列的 <code>x-max-priority</code> 参数来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置一个队列的最大优先级</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-rnax-priority"</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"queue.priority"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args); </span><br><span class="line"><span class="comment">// 需要在发送时在消息中设置消息当前的优先级</span></span><br><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">builder.priority(<span class="number">5</span>);</span><br><span class="line">AMQP.BasicProperties properties = bulder.build();</span><br><span class="line">channel.basicPublish(<span class="string">"exchange_priority"</span>, <span class="string">"rk_priority"</span>, properties, (<span class="string">"messages"</span>).getBytes());</span><br></pre></td></tr></table></figure><p>上面的代码中设置消息的优先级为5。默认最低为0，最高为队列设置的最大优先级。优先级高的消息可以被优先消费，这个也是有前提的；如果在消费者的消费速度大于生产者的速度且 Broker 中没有消息堆积的情况下，对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</p><h2 id="第六节-RPC实现"><a href="#第六节-RPC实现" class="headerlink" title="第六节 RPC实现"></a>第六节 RPC实现</h2><h3 id="6-1-什么是RPC？"><a href="#6-1-什么是RPC？" class="headerlink" title="6.1 什么是RPC？"></a>6.1 什么是RPC？</h3><p>远程过程调用（Remote Procedure Call，RPC），它是一种通过网络从远程计算机上请求服务，而不需要了解底层网络的技术。 RPC的主要功用是让构建分布式计算更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</p><p>通俗点来说，假设有两台服务器A和B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在同一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><p>RPC的协议有很多，比如最早的 CORBA、Java RMI、WebService的RPC风格、 Hessian、Thrift、Dubbo等，甚至还有 Restful API。</p><h3 id="6-2-RabbitMQ如何进行RPC"><a href="#6-2-RabbitMQ如何进行RPC" class="headerlink" title="6.2 RabbitMQ如何进行RPC"></a>6.2 RabbitMQ如何进行RPC</h3><p>一般在 RabbitMQ 中进行 RPC 是很简单。客户端发送请求消息，服务端回复响应的消息。为了接收响应的消息，我们需<strong>要在请求消息中发送一个回调队列</strong>（参考下面代码中的 replyTo 可以使用默认的队列）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String callbackQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">BasicProperties props = <span class="keyword">new</span> BasicProperties.Bulder().replyTo(callbackQueueName).build();</span><br><span class="line">channel.basicPublish (<span class="string">""</span>,<span class="string">"rpc_queue"</span>, props, message.getBytes());</span><br><span class="line"><span class="comment">// then code to read a response message from the callback_queue ...</span></span><br></pre></td></tr></table></figure><p>BasicProperties包含14个属性，这里主要用到两个：</p><ul><li>replyTo：通常用来设置一个回调队列；</li><li>correlationId：用来关联请求（request）和其调用 RPC 之后的回复（response）。</li></ul><p>上述代码中为每个 RPC 请求创建一个回调队列是非常低效的。通用的解决方案一一<strong>可以为每个客户端创建一个单一的回调队列</strong>。</p><p>这样就产生了一个新的问题，对于回调队列而言，在其接收到一条回复的消息之后，它并不知道这条消息应该和哪一个请求匹配。这里就用到 correlationId 这个属性了，我们应该<strong>为每一个请求设置一个唯一的 correlationId</strong> 。之后<strong>在回调队列接收到回复的消息时，可以根据这个属性匹配到相应的请求</strong>。如果回调队列接收到一条未知 correlationId 的回复消息，可以简单地将其丢弃。</p><p>疑问：</p><ul><li>为什么要将回调队列中的位置消息丢弃而不是仅仅将其看作失败？</li><li><strong>这样可以针对这个失败做一些弥补措施</strong>。</li></ul><p>参考图 4-7 考虑这样一种情况：RPC 服务器可能在发送给回调队列（ <code>amq.gen-LhQzlgv3GhDOv8PIDabOXA</code> ）并且在确认接收到请求消息（rpc_queue中的消息）之后挂掉了，那么只需重启下 RPC 服务器即可，RPC 服务会重新消费 rpc_queue 队列中的请求，这样就不会出现 RPC 服务端未处理请求的情况。这里的回调队列可能会收到重复消息的情况，这需要客户端能够优雅地处理这种情况，并且 RPC 请求需要保证其本身是幂等的（补充：<strong>消费者消费消息一般是先处理业务逻辑，再使用 <code>Basic.Ack</code> 确认己接收到消息以防止消息不必要地丢失</strong>）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010169.png" alt></p><h3 id="6-3-RPC处理流程"><a href="#6-3-RPC处理流程" class="headerlink" title="6.3 RPC处理流程"></a>6.3 RPC处理流程</h3><p>RPC的处理流程如下：</p><ol><li>当客户端启动时，创建一个匿名的回调队列（名称由 RabbitMQ 自动创建，如图4-7的回调队列为 <code>amq.gen-LhQzlgv3GhDOv8PIDabOXA</code> ）。</li><li>客户端为 RPC 请求设置2个属性：replyTo-用来告知 RPC 服务端回复请求时的目的队列，即回调队列； correlationId-用来标记一个请求。</li><li>请求被发送到 rpc_queue 队列中。</li><li>RPC 服务端监听 rpc_queue 队列中的请求，当请求到来时，服务端会处理并且把带有结果的消息发送给客户端，接收的队列就是 replyTo 设定的回调队列。</li><li>客户端监听回调队列，当有消息时，检查 correlationId 属性，如果与请求匹配， 那就是结果了。</li></ol><h3 id="6-4-示例"><a href="#6-4-示例" class="headerlink" title="6.4 示例"></a>6.4 示例</h3><p>示例：RPC客户端通过 RPC 来调用服务端的方法以便得到相应斐波那契值。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE_NQME = <span class="string">"rpc_queue"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(IP_ADDRESS);</span><br><span class="line">        factory.setPort(PORT);</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">        Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(RPC_QUEUE_NQME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [x] Awaiting RPC requests"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                AMQP.BasicProperties replyProps = <span class="keyword">new</span> AMQP.BasicProperties()</span><br><span class="line">                        .builder()</span><br><span class="line">                        .correlationId(properties.getCorrelationId())</span><br><span class="line">                        .build();</span><br><span class="line">                String response = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                    <span class="keyword">int</span> n = Integer.parseInt(message);</span><br><span class="line">                    System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [.] fib("</span> + message + <span class="string">")"</span>);</span><br><span class="line">                    response += fib(n);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [.] "</span> + e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">""</span>, properties.getReplyTo(),</span><br><span class="line">                            replyProps, response.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(RPC_QUEUE_NQME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> String requestQueueName = <span class="string">"rpc_queue"</span>;</span><br><span class="line">    <span class="keyword">private</span> String replyQueueName;</span><br><span class="line">    <span class="keyword">private</span> MyConsumer consumer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RPCClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"></span><br><span class="line">        replyQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">        consumer = <span class="keyword">new</span> MyConsumer(channel);</span><br><span class="line">        channel.basicConsume(replyQueueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ShutdownSignalException, ConsumerCancelledException,</span></span><br><span class="line"><span class="function">            InterruptedException </span>&#123;</span><br><span class="line">        String response = <span class="keyword">null</span>;</span><br><span class="line">        String corrId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties()</span><br><span class="line">                .builder()</span><br><span class="line">                .correlationId(corrId)</span><br><span class="line">                .replyTo(replyQueueName)</span><br><span class="line">                .build();</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, requestQueueName, properties, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            MyConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            <span class="keyword">if</span>(delivery.getProperties().getCorrelationId().equals(corrId))&#123;</span><br><span class="line">                response = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RPCClient fibRpc = <span class="keyword">new</span> RPCClient();</span><br><span class="line">        System.out.println(<span class="string">"RPCClient "</span> + LocalTime.now() + <span class="string">" [x] Requesting fib(30)"</span>);</span><br><span class="line">        String response = fibRpc.call(<span class="string">"30"</span>);</span><br><span class="line">        System.out.println(<span class="string">"RPCClient "</span> + LocalTime.now() + <span class="string">" [.] Got '"</span> + response + <span class="string">"'"</span>);</span><br><span class="line">        fibRpc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前版本MQ已废弃QueueingConsumer，自定义一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Delivery&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//TODO someting</span></span><br><span class="line">        Delivery delivery = <span class="keyword">new</span> Delivery();</span><br><span class="line">        delivery.setBody(body);</span><br><span class="line">        delivery.setProperties(properties);</span><br><span class="line">        delivery.setEnvelope(envelope);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(delivery);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Delivery <span class="title">nextDelivery</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException, ShutdownSignalException, ConsumerCancelledException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Delivery <span class="title">nextDelivery</span><span class="params">(<span class="keyword">long</span> timeout)</span><span class="keyword">throws</span> InterruptedException, ShutdownSignalException, ConsumerCancelledException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delivery</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BasicProperties properties;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line">        <span class="keyword">private</span> Envelope envelope;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BasicProperties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(BasicProperties properties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(<span class="keyword">byte</span>[] body)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.body = body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Envelope <span class="title">getEnvelope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> envelope;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvelope</span><span class="params">(Envelope envelope)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.envelope = envelope;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">RPCServer</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">01.198</span> [x] <span class="symbol">Awaiting</span> <span class="symbol">RPC</span> requests</span><br><span class="line"><span class="symbol">RPCClient</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">06.135</span> [x] <span class="symbol">Requesting</span> fib(<span class="number">30</span>)</span><br><span class="line"><span class="symbol">RPCServer</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">07.315</span> [.] fib(<span class="number">30</span>)</span><br><span class="line"><span class="symbol">RPCClient</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">07.364</span> [.] <span class="symbol">Got</span> <span class="string">'832040'</span></span><br></pre></td></tr></table></figure><h2 id="第七节-持久化"><a href="#第七节-持久化" class="headerlink" title="第七节 持久化"></a>第七节 持久化</h2><h3 id="7-1-RabbitMQ的持久化"><a href="#7-1-RabbitMQ的持久化" class="headerlink" title="7.1 RabbitMQ的持久化"></a>7.1 RabbitMQ的持久化</h3><p>持久化可以提高 RabbitMQ 的可靠性，以防在异常情况（重启、关闭、宿机等）下的数据丢失。</p><p> RabbitMQ 的持久化分为三个部分：</p><ul><li>交换器的持久化；</li><li>队列的持久化；</li><li>消息的持久化。</li></ul><h3 id="7-2-实现方式"><a href="#7-2-实现方式" class="headerlink" title="7.2 实现方式"></a>7.2 实现方式</h3><h4 id="7-2-1-交换器的持久化"><a href="#7-2-1-交换器的持久化" class="headerlink" title="7.2.1 交换器的持久化"></a>7.2.1 交换器的持久化</h4><p>交换器的持久化是<strong>通过在声明队列时将 durable 参数置为 true 实现的</strong>。如果交换器不设置持久化，那么在 RabbitMQ 服务重启之后，相关的交换器元数据会丢失， 不过消息不会丢失，只是不能将消息发送到这个交换器中了。对于一个长期使用的交换器来说， 建议将其置为持久化的。</p><h4 id="7-2-2-队列的持久化"><a href="#7-2-2-队列的持久化" class="headerlink" title="7.2.2 队列的持久化"></a>7.2.2 队列的持久化</h4><p>队列的持久化是<strong>通过在声明队列时将 durable 参数置为 true 实现的</strong>。如果队列不设置持久化，那么在 RabbitMQ 服务重启之后，相关队列的元数据会丢失， 此时数据也会丢失 。正所谓 “皮之不存，毛将焉附”，队列都没有了，消息又能存在哪里呢？</p><h4 id="7-2-3-消息的持久化"><a href="#7-2-3-消息的持久化" class="headerlink" title="7.2.3 消息的持久化"></a>7.2.3 消息的持久化</h4><p>队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。</p><p><strong>通过将消息的投递模式 (BasicProperties 中的 deliveryMode 属性）设置为2,即可实现消息的持久化</strong>。前面示例中多次提及的 <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 实际上是封装了这个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BasicProperties PERSISTENT_TEXT_PLAIN = <span class="keyword">new</span> BasicProperties(<span class="string">"text/plain"</span>, (String)<span class="keyword">null</span>, (Map)<span class="keyword">null</span>, <span class="number">2</span>, <span class="number">0</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (Date)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>设置了队列和消息的持久化，当 RabbitMQ 服务重启之后，消息依旧存在。单单只设置队列持久化，重启之后消息会丢失；单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</p><p>注意要点：可以将所有的消息都设直为持久化，但是这样会严重影响 RabbitMQ 的性能（随机）。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一 个权衡。</p><h3 id="7-3-为何持久化不能保证数据不会丢失？"><a href="#7-3-为何持久化不能保证数据不会丢失？" class="headerlink" title="7.3 为何持久化不能保证数据不会丢失？"></a>7.3 为何持久化不能保证数据不会丢失？</h3><p>将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗？答案是否定的。</p><p>首先从消费者来说，如果在订阅消费队列时将 autoAck 参数设置为 true ，那么当消费者接收到相关消息之后，还没来得及处理就看宕机了，这样也算数据丢失。这种情况很好解决，将 autoAck 参数设置为 false ，并进行手动确认。</p><p>其次，在持久化的消息正确存入 RabbitMQ 之后，还需要有一段时间（虽然很短，但是不可忽视〉才能存入磁盘之中。 RabbitMQ 并不会为每条消息都进行同步存盘（调用内核的 <code>fsync</code> 方法）的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内 RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。</p><p>这个问题怎么解决呢？这里可以<strong>引入 RabbitMQ 镜像队列机制</strong>，相当于配置了副本，如果主节点（ master ）在此特殊时间内挂掉，可以自动切换到从节点（slave), 这样有效地保证了高可用性，除非整个集群都挂掉。虽然这样也不能完全保证 RabbitMQ 消息不丢失，但是配置了镜像队列要比没有配置镜像队列的可靠性要高很多，在实际生产环境中的关键业务队列一般都会设置镜像队列。</p><p>还可以<strong>在发送端引入事务机制</strong>或者<strong>发送方确认机制</strong>来保证消息己经正确地发送并存储至 RabbitMQ 中，前提还要保证在调用 <code>channel.basicPublish</code> 方法的时候交换器能够将消息正确路由到相应的队列之中。</p><h2 id="第八节-生产者确认"><a href="#第八节-生产者确认" class="headerlink" title="第八节 生产者确认"></a>第八节 生产者确认</h2><p>在使用 RabbitMQ 的时候，可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失，除此之外，我们还会遇到一个问题，<strong>当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢？</strong></p><p>如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化？</p><p>RabbitMQ 针对这个问题，提供了两种解决方式：</p><ul><li>通过事务机制实现；</li><li>通过发送方确认（publisher confirm）机制实现。</li></ul><h3 id="8-1-事务机制"><a href="#8-1-事务机制" class="headerlink" title="8.1 事务机制"></a>8.1 事务机制</h3><p>RabbitMQ 客户端中与事务机制相关的方法有 个：</p><ul><li><code>channel.txSelect</code> ：用于将当前的信道设置成事务模式；</li><li><code>channel.txCommit</code> ：用于提交事务；</li><li><code>channel.txRollback</code> ：用于事务回滚。</li></ul><p>在通过 channel.txSelect 方法开启事务之后，我们便可以发布消息给 RabbitMQ 了， 如果事务提交成功，则消息一定到达了 RabbitMQ 中，如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行 channel.txRollback 方法来实现事务回滚。注意这里的 RabbitMQ 中的事务机制与大多数数据库中的事务概念井不相同，需要注意区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"transaction messages"</span>.getBytes());</span><br><span class="line">channel.txCommit();</span><br></pre></td></tr></table></figure><p>上面代码对应的 AMQP 协议流转过程如图 4-8 示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010170.png" alt></p><p>可以发现开启事务机制与不开启（参考图2-10）相比多了四个步骤：</p><ul><li>客户端发送 <code>Tx.Select</code> ，将信道置为事务模式；</li><li>Broker 回复 <code>Tx Select-Ok</code> ，确认己将信道置为事务模式：</li><li>在发送完消息之后，客户端发送 <code>Tx.Commit</code> 提交事务</li><li>Broker回复 <code>Tx.Commit-Ok</code> ，确认事务提交。</li></ul><p>上面所陈述的是正常的情况下的事务机制运转过程，而事务回滚是什么样子呢？我们先来 参考下面一段示例代码（代码清单 4-15 ），来看看怎么使用事务回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       channel.txSelect();</span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">       channel.txCommit();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       channel.txRollback();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面代码中很明显有一个 <code>java.lang.ArithmeticException</code> ，在事务提交之前捕获到异常，之后显式地提交事务回滚，其 AMQP 议流转过程如图 4-9 所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010171.png" alt></p><p>如果要发送多条消息，则将 <code>channel.basicPublish</code> 和 <code>channel.txCommit</code> 等方法包裹进循环内即可，可以参考如下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; LOOP_TIMES;i++)&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, (<span class="string">"messages"</span> + i).getBytes());</span><br><span class="line">           channel.txCommit();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           channel.txRollback();</span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>事务确实能够解决消息发送方和 RabbitMQ 之间消息确认的问题，只有消息成功被 RabbitMQ 接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。</p><p>但是使用事务机制会“吸干” RabbitMQ 的性能，那么有没有更好的方法既能保证消息发送方确认消息已经正确送达，又能基本上不带来性能上的损失呢？从 AMQP 协议层面来看并没有更好的办法，但是 RabbitMQ 提供了一个改进方案，即发送方确认机制。</p><h3 id="8-2-发送方确认机制"><a href="#8-2-发送方确认机制" class="headerlink" title="8.2 发送方确认机制"></a>8.2 发送方确认机制</h3><p>前面介绍了 RabbitMQ 可能会遇到的一个问题，即消息发送方（生产者）并不知道消息是否真正地到达了 RabbitMQ 。随后了解到在 AMQP 协议层面提供了事务机制来解决这个问题， 但是采用事务机制实现会严重降低 RabbitMQ 的消息吞吐量，这里就引入了一种<strong>轻量级的方式</strong>一<strong>发送方确认</strong>（publisher confirm）机制。</p><p>生产者将信道设置成 confirm （确认）模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的ID （从1开始），一旦消息被投递到所有匹配的队列之后， RabbitMQ 会发送一个确认（ <code>Basic.Ack</code> ）给生产者（包含消息的唯一ID ），这就使得生产者知晓消息已经正确到达了目的地了。</p><p>如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。 RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号，此外 RabbitMQ 可以设置 <code>channel.basicAck</code> 方法中的 multiple 参数，表示到这个序号之前的所有消息都己经得到了处理，可以参考图 4-10 。注意辨别这里的确认和消费时候的确认之间的异同。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010172.png" alt></p><p>事务机制在一条消息发送之后会使发送端阻塞，以等待 RabbitMQ 的回应，之后才能继续发送下一条消息。相比之下，<strong>发送方确认机制最大的好处在于它是异步的</strong>，一旦发布一条消息， 生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用程序便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack ( <code>Basic.Nack</code> ）命令，生产者应用程序同样可以在回调方法中处理该 nack 命令。</p><p>生产者通过调用 <code>channel.confirmSelect</code> 方法（即 <code>Confirm.Select</code> 命令）将信道 设置为 confirm 模式，之后 RabbitMQ 会返回 <code>Confirm.Select-Ok</code> 命令表示同意生产者将当前信道设置为 confirm 模式。所有被发送的后续消息都被 ack 或者 nack 一次，不会出现一条消息既被 ack 又被 nack 情况，并且 RabbitMQ 并没有对消息被 confirm 的快慢做任何保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">// 将信道置为 publisher confirm 模式</span></span><br><span class="line">       channel.confirmSelect();</span><br><span class="line">       <span class="comment">// 之后正常发送消息</span></span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, <span class="string">"publisher confirm test"</span>.getBytes());</span><br><span class="line">       <span class="keyword">if</span>(!channel.waitFormConfirms()) &#123;</span><br><span class="line">           System.out.println(<span class="string">"send message failed"</span>);</span><br><span class="line">           <span class="comment">// do something else</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果发送多条消息，只需要将 <code>channel.basicPubish</code> 和 <code>channel. waitForConfirms</code> 方法包裹在循环里面即可，参考事务机制，不过不需要 <code>channel.confirmSelect</code> 方法包裹在循环内部。</p><p>在 <code>publisher confirm</code> 模式下发送多条消息的 AMQP 协议流转过程可参考图 4-11：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010173.png" alt></p><p>对于 <code>channel.waitForConfirms</code> 而言，在 RabbitMQ 客户端中它有4个同类 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForConfirmsOrDie</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForConfirmsOrDie</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException, InterruptedException, TimeoutException</span>;</span><br></pre></td></tr></table></figure><p>如果信道没有开启 <code>publisher confirm</code> 模式，则调用任何 <code>waitForConfirms</code> 方法都会报出 <code>java.lang.IllegalStateException</code> 。对于没有参数的 <code>waitForConfirms</code> 方法来说， 其返回的条件是客户端收到了相应的 <code>Basic.Ack / .Nack</code> 或者被中断。</p><p>参数 timeout 表示超时时间， 一旦等待 RabbitMQ 回应超时就会抛出 <code>java.util.concurrent.TimeoutException</code> 的异常。</p><p>两个 <code>waitForConfirmsOrDie</code> 方法在接收到 RabbitMQ 返回 <code>Basic.Nack</code> 之后会抛出 <code>java.io.IOException</code> 业务代码可以根据自身的特性灵活地运用这四种方法来保障消息的可靠发送。</p><p>前面提到过 RabbitMQ 引入了 <code>publisher confirm</code> 机制来弥补事务机制的缺陷，提高了整体的吞吐量，那么来对比下两者之间的QPS ，测试代码可以参考上面的示例代码。</p><p>测试环境：客户端和 Broker 机器配置一CPU 24 核、主频为 2600Hz 、内存为 64GB、硬盘为 1TB 。客户端发送的消息体大小为 10B ，单线程发送，并且消息都进行持久化处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010174.png" alt></p><p>图中的横坐标表示测试的次数，纵坐标表示 QPS，可以发现 publisher confirm 与事务机制相比， QPS 并没有提高多少，难道是 RabbitMQ 欺骗了我们？</p><p>我们再来回顾下前面的示例代码，可以发现 publisher confirm 模式是每发送一条消息后就调用 <code>channe.waitForConfirms</code> 方法，之后等待服务端的确认，这实际上是一种串行同步等待的方式。事务机制和它一样，发送消息之后等待服务端确认，之后再发送消息。两者的存储确认原理相同，尤其对于持久化的消息来说，两者都需要等待消息确认落盘之后才会返回（调 Linux 内核的 <code>fsync</code> 方法） 。在同步等待的方式下， publisher confirm 机制发送一条消息需要通信交互的命令是 <code>Basic.Publish</code> 、<code>Basic.Ack</code> ；事务机制是3条： <code>Basic.Publish</code> 、<code>Tx.Commmit/.Commit-Ok</code> （或者 <code>Tx Rollback/. Rollback-Ok</code> ），事务机制多了一个命令帧报文的交互，所以 QPS 会略微下降。</p><p>注意要点：</p><ol><li>事务机制和 <code>publisher confirm</code> 机制两者是互斥的，不能共存。如果企图将已开启事务模式的信道再设置为 <code>publisher confirm</code> 模式，RabbitMQ 会报错：<code>{amqp_error, precondition_failed, &quot;cannot switch from tx to confirm mode&quot;, &#39;confirm.select&#39;};</code> 或者如果企图将已开启 <code>publisher confirm</code> 模式的信道再设置为事务模式，RabbitMQ 也会报错： <code>{amqp_error, precondition_failed, &quot;cannot switch from tx to confirm mode&quot;, &#39;tx.select&#39; }</code> 。 </li><li>事务机制和 <code>publisher confirm</code> 机制确保的是消息能够正确地发送至 RabbitMQ ，这里的“发送至 RabbitMQ”的含义是指消息被正确地发往至 RabbitMQ 的交换器，如果此交换器没有匹配的队列，那么消息也会丢失。所以在使用这两种机制的时候要确保所涉及的交换器能够有匹配的队列，更进一步地讲，发送方要配合 mandatory 参数或者备份交换器一起使用来提高 消息传输的可靠性。</li></ol><p><code>publisher confirm</code> 的优势在于并不一定需要同步确认。这里我们改进了一下使用方式，总结有如下两种：</p><ul><li>批量confirm方法：每发送一批消息后，调用 <code>channel.waitForConfirms</code> 方法，等待服务器的确认返回；</li><li>异步confirm方法：提供一个回调方法，服务端确认了一条或者多条消息后客户端会因调这个方法进行处理。</li></ul><p>在批量 confirm 方法中，客户端程序需要定期或者定量（达到多少条），亦或者两者结合起来调用 <code>channel.waitForConfirms</code> 来等待 RabbitMQ 确认返回。相比于前面示例中的普通 confirm 方法，批量极大地提升了 confirm 效率，但是问题在于出现返回 <code>Basic.Nack</code> 或者超时情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且当消息经常丢失时，批量 confirm 性能应该是不升反降的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">// 将信道置为 publisher confirm 模式</span></span><br><span class="line">       channel.confirmSelect();</span><br><span class="line">       <span class="keyword">int</span> MsgCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, <span class="string">"batch confirm test"</span>.getBytes());</span><br><span class="line">           <span class="comment">// 将发送出去的消息存入缓存，缓存可以是ArrayList或BlockingQueue等</span></span><br><span class="line">           <span class="keyword">if</span>(++MsgCount &gt;= BATCH_COUNT) &#123;</span><br><span class="line">               MsgCount = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(channel.waitForConfirms()) &#123;</span><br><span class="line">                       <span class="comment">// 将缓存中的消息清空</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 将缓存中的消息重新发送</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                   <span class="comment">// 将缓存中的消息重新发送</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>异步 confirm 方法的编程实现最为复杂，在客户端 Channel 接口中提供的 <code>addConfirmListener</code> 方法可以添加 <code>ConfirmListener</code> 这个回调接口，这个 <code>ConfirmListener</code> 接口包含两个方法： <code>handleAck</code> 、<code>handleNack</code> ，分别用来处理 RabbitMQ 回传的 <code>Basic.Ack</code> 和 <code>Basic.Nack</code> 。在这两个方法中都包含有 个参数 <code>deliveryTag</code> （在 <code>publisher confirm</code> 模式下用来标记消息的唯一有序序号）。我们需要为每个信道维护一个“unconfirm ”的消息序号集合，每发送一条消息，集合中的元素加1。每当调 <code>ConfirmListener</code> 中的 <code>handleAck</code> 方法时，“ unconfirm ”集合中删掉相应的一条 ( multiple 设置为 false ）或者多条（ multiple 设置为 true ）记录。从程序运行效率上来看， 这个“unconfrrm ”集合最好采用有序集合 <code>SortedSet</code> 的存储结构。事实上， Java 客户端 SDK 中的 <code>waitForConfirms</code> 方法也是通过 SortedSet 维护消息序号的。</p><p>演示异步 confirm 的编码实现，其中的 confirmSet 就是一个 SortedSet 类型的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener()&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"Nack, SeqNo: "</span> + deliveryTag +</span><br><span class="line">                             <span class="string">", multiple: "</span> + multiple);</span><br><span class="line">           <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">               confirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               confirmSet.remove(deliveryTag);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">               confirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               confirmSet.remove(deliveryTag);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 注意这里需要添加处理消息重发的场景</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"><span class="comment">// 下面是演示一直发送消息的场景</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">       <span class="keyword">long</span> nextSeqNo = channel.getNextPublishSeqNo();</span><br><span class="line">       channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">       confirmSet.add(nextSeqNo);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后我们将事务、普通 confirm、批量 confirm 和异步 confirm 这4种方式放到一起来比较下彼此的 QPS。测试环境和数据和图 4-12 中的测试相同，具体测试对比如图 4-13 所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010175.png" alt></p><p>可以看到批量 confirm 和异步 confirm 这两种方式所呈现的性能要比其余两种好得多。</p><ul><li>事务机制和普通 confirm 的方式吐吞量很低，但是编程方式简单，不需要在客户端维护状态（这里指的是维护 deliveryTag 及缓存未确认的消息）。</li><li>批量 confirm 方式的问题在于遇到 RabbitMQ 服务端返回 <code>Basic.Nack</code> 需要重发批量消息而导致的性能降低。</li><li>异步 confirm 方式编程模型最为复杂，而且和批量 confirm 方式一样需要在客户端维护状态。</li></ul><p>在实际生产环境中采用何种方式，这里就仁者见仁智者见智了，不过<strong>强烈建议使用异步 confirm 的方式</strong>。</p><h2 id="第九节-消费端要点介绍"><a href="#第九节-消费端要点介绍" class="headerlink" title="第九节 消费端要点介绍"></a>第九节 消费端要点介绍</h2><p>消费者客户端可以通过推模式或者拉模式的方式来获取井消费消息，当消费者处理完业务逻辑需要手动确认消息己被接收，这样 RabbitMQ 才能把当前消息从队列中标记清除。当然如果消费者由于某些原因无法处理当前接收到的消息， 可以通过 <code>channel.basicNack</code> 或者 <code>channel.basicReject</code> 来拒绝掉。</p><p>这里对于 RabbitMQ 消费端来说，还有几点需要注意：</p><ul><li>消息分发；</li><li>消息顺序性；</li><li>弃用 <code>QueueingConsumer</code> 。</li></ul><h3 id="9-1-消息分发"><a href="#9-1-消息分发" class="headerlink" title="9.1 消息分发"></a>9.1 消息分发</h3><p>当 RabbitMQ 队列拥有多个消费者时，队列收到的消息将以轮询（ <code>round-robin</code> ）的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。</p><p>很多时候轮询的分发机制也不是那么优雅。默认情况下，如果有n个消费者，那么 RabbitMQ 会将第m条消息分发给第 <code>m%n</code>（取余的方式）个消费者，RabbitMQ 不管消费者是否消费并己经确认（ <code>Basic.Ack</code> ）了消息。试想一下，如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因（比如业务逻辑简单、机器性能卓越等）很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降。</p><p>那么该如何处理这种情况呢？这里就要用到 <code>channel.basicQos(int prefetchCount)</code> 这个方法，如前面章节所述， <code>channel.basicQos</code> 方法允许限制信道上的消费者所能保持的最大未确认消息的数量。</p><p>举例说明，在订阅消费队列之前，消费端程序调用了 <code>channel.basicQos(5)</code> ，之后订阅了某个队列进行消费。 RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么 RabbitMQ 就不会向这个消费者再发送任何消息。 直到消费者确认了某条消息之后 RabbitMQ 将相应的计数减1 ，之后消费者可以继续接收消息， 直到再次到达计数上限。这种机制可以类比于 TCP/IP 中的“滑动窗口”。</p><p>注意要点：<code>Basic.Qos</code> 的使用对于拉模式的消费方式无效。</p><p>channel.basicQos 有三种类型的重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchSize, <span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> gl bal)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>前面介绍的都只用到了 prefetchCount 这个参数，当 prefetchCount 设置为0则表示没有上限。还有 prefetchSize 这个参数表示消费者所能接收未确认消息的总体大小的上限， 单位为B，设置为0则表示没有上限。</p><p>对于一个信道来说，它可以同时消费多个队列，当设置了 prefetchCount 大于0时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的 prefetchCount 的值，这样会 RabbitMQ 的性能降低，尤其是这些队列分散在集群中的多个 Broker 节点之中。 RabbitMQ 为了提升相关的性能，在 AMQP 0-9-1 协议之上重新定义了 global 这个参数，对比如表 4-1 所示。</p><table><thead><tr><th>global 参数</th><th>AMQP 0-9-1</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>false</td><td>信道上所有的消费者都需要遵从 prefetch Count 的限定值</td><td>信道上新的消费者需要遵从 prefetchCount 的限定值</td></tr><tr><td>true</td><td>当前通信链路（ Connection ）上所有的消费者都需要遵从 prefetchCount 的限定值</td><td>信道上所有的消费者都需要遵从 prefetchCount 的限定值</td></tr></tbody></table><p>前面章节中的 <code>channel.basicQos</code> 方法的示例都是针对单个消费者的，而对于同一个信道上的多个消费者而言，如果设置了 prefetchCount 的值，那么都会生效。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例中有两个消费者，各自的能接收到的未确认消息的上限都为10</span></span><br><span class="line">Channel channel = ...;</span><br><span class="line">Consumer consumer1 = ...;</span><br><span class="line">Consumer consumer2 = ...;</span><br><span class="line"><span class="comment">// Per consumer limit</span></span><br><span class="line">channel.basicQos(<span class="number">10</span>);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue1"</span>, <span class="keyword">false</span>, consumer1);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue2"</span>, <span class="keyword">false</span>, consumer2);</span><br></pre></td></tr></table></figure><p>如果在订阅消息之前，既设置了 global 为 true 的限制，又设置了 global 为 false 的限制，那么哪个会生效呢？ RabbitMQ 会确保两者都会生效。举例说明，当前有两个队列 queue1 和 queue2：queue1 有 10 条消息，分别为1到10; queue2 也有10条消息，分别为11到20 。有两个消费者分别消费这两个队列，如代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">Consumer consumer1 = ...;</span><br><span class="line">Consumer consumer2 = ...;</span><br><span class="line"><span class="comment">// Per consumer limit</span></span><br><span class="line">channel.basicQos(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Per Channel limit</span></span><br><span class="line">channel.basicQos(<span class="number">5</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue1"</span>, <span class="keyword">false</span>, consumer1);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue2"</span>, <span class="keyword">false</span>, consumer2);</span><br></pre></td></tr></table></figure><p>那么这里每个消费者最多只能收到3个未确认的消息，两个消费者能收到的未确认的消息个数之和的上限为5。在未确认消息的情况下，如果 consumer1 接收到了消息 ，那么 consumer2 至多只能收到 11 到 12 。如果像这样同时使用两种 global 的模式，则会增加 RabbitMQ 的负载，因为 RabbitMQ 需要更多的资源来协调完成这些限制。如无特殊需要，最好只使用 global 为 false 设置，这也是默认的设置。</p><h3 id="9-2-消息顺序性"><a href="#9-2-消息顺序性" class="headerlink" title="9.2 消息顺序性"></a>9.2 消息顺序性</h3><p>消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。举个例子，不考虑消息重复的情况，如果生产者发布的消息分别为 msg1、msg2、msg3 ，那么消费者必然也是按照此顺序进行消费的。</p><p>目前很多资料显示 RabbitMQ 的消息能够保障顺序性，这是不正确的，或者说这个观点有很大的局限性。在不使用任何 RabbitMQ 高级特性，也没有消息丢失、网络故障之类异常的情况发生，并且只有一个消费者的情况下，最好也只有一个生产者的情况下可以保证消息的顺序性。如果有多个生产者同时发送消息，无法确定消息到达 Broker 的前后顺序，也就无法验证消息的顺序性。</p><p>那么哪些情况下 RabbitMQ 的消息顺序性会被打破呢？</p><p>常见情形：</p><ul><li>如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补偿发送这条消息，如果补偿发送是在另一个线程实现的，那么消息在生产者这个源头就出现了错序。同样，如果启用 publisher confirm 时，在发生超时、中断，又或者是收到 RabbitMQ 的 <code>Basic.Nack</code> 命令时，那么同样需要补偿发送，结果与事务机制一样会错序。或者这种说法有 些牵强，我们可以固执地认为消息的顺序性保障是从存入队列之后开始的，而不是在发迭的时候开始的。</li><li>考虑另一种情形，如果生产者发送的消息设置了不同的超时时间，井且也设置了死信队列， 整体上来说相当于一个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致。</li><li>再考虑一种情形，如果消息设置了优先级，那么消费者消费到的消息也必然不是顺序性的。</li><li>如果一个队列按照前后顺序分有 msg1、msg2、msg3、msg4 这4个消息，同时有 ConsumerA 和 ConsumerB 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中， ConsumerA 中的消息为 msg1 和 msg3, ConsumerB 中的消息为 msg2 和 msg4。ConsumerA 收到消息 msg1 之后并不想处理而调用了 <code>Basic Nack/.Reject</code> 将消息拒绝，与此同时将 requeue 设置为 true ，这样这条消息就可以重新存入队列中。消息 msg1 之后被发送到了 ConsumerB 中，此时 ConsumerB 己经消费了 msg2 和 msg4 ，之后再消费 msg1 ，这样消息顺序性也就错乱了。或者消息 msg1 又重新发往 ConsumerA 中，此时 ConsumerA 消费了 msg3, 那么再消费 msg1 ，消息顺序性也无法得到保障。同样可以用在 <code>Basic.Recover</code> 这个 AMQP 命令中。</li></ul><p>包括但不仅限于以上几种情形会使 RabbitMQ 消息错序。如果要保证消息的顺序性，需要业务方使用 RabbitMQ 之后做进一步的处理，比如在消息体内添加全局有序标识（类似 Sequence ID ）来实现。</p><h3 id="9-3-弃用QueueingConsumer"><a href="#9-3-弃用QueueingConsumer" class="headerlink" title="9.3 弃用QueueingConsumer"></a>9.3 弃用QueueingConsumer</h3><p>在前面的章节中所介绍的订阅消费的方式都是通过继承 <code>DefaultConsumer</code> 类来实现的，建议不要使用 <code>QueueingConsumer</code> 这个类来实现订阅消费，在 4.x 版本开始被标记为 <code>＠Deprecated</code> ，想必这个类中有些无法弥补的缺陷：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"><span class="comment">//channel.basicQos(64); //使用QueueingConsumer一定要添加</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, <span class="string">"consumer_zzh"</span>, consumer);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">       String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">       System.out.println(<span class="string">" [X] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">       channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>乍一看没什么问题，而且实际生产环境中如果不是太“傲娇”地使用也不会造成什么大问题。QueueingConsumer 本身有几个大缺陷，需要在使用时特别注意 ：</p><ul><li>首当其冲的就是内存溢出的问题，如果由于某些原因，队列之中堆积了比较多的消息，就可能导致消费者客户端内存溢出假死，于是发生恶性循环，队列消息不断堆积而得不到消化。</li><li>QueueingConsumer 会拖累同一个 Connection 下的所有信道，使其性能降低；</li><li>同步递归调用 QueueingConsumer 会产生死锁：</li><li>RabbitMQ 的自动连接恢复机制（ automatic connection recove可）不支持 Queueing Consumer 的这种形式：</li><li>QueueingConsumer 不是事件驱动的。</li></ul><p>采用代码清单 4-22 中的代码进行演示 首先向一个队列发送 200多MB 的消息，然后进行消费。在客户端调用 channel.basicConsume 方法订阅队列的时候， RabbitMQ 会持续地将消息发往 QueueingConsumer 中， QueueingConsumer 内部使用 LinkedBlockingQueue 来缓存这些消息。通过 JVisualVM 可以看到堆内存的变化，如图 4-14 示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010176.png" alt></p><p>可以看到堆内存一直在增加，这里只测试了发送 200MB 左右的消息，如果发送更多的消息，那么这个堆内存会变得更大，直到出现 <code>java.lang.OutOfMemoryError</code> 的报错。</p><p>这个内存溢出的问题可以使用 <code>Basic.Qos</code> 来得到有效的解决，<code>Basic.Qos</code> 可以限制某个消费者所保持未确认消息的数量，也就是间接地限制了 QueueingConsumer 中的 LinkedBlockingQueue 的大小。注意一定要在调用 <code>Basic.Consume</code> 之前调用 <code>Basic.Qos</code> 才能生效。</p><p>为了避免不必要的麻烦，建议在消费的时候尽量使用继承 DefaultConsumer 的方式。</p><h2 id="第十节-消息传输保障"><a href="#第十节-消息传输保障" class="headerlink" title="第十节 消息传输保障"></a>第十节 消息传输保障</h2><p>消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题， 一般消息中间件的消息传输保障分为三个层级：</p><ul><li>At most once：最多一次。消息可能会丢失，但绝不会重复传输。</li><li>At least once：最少一次。消息绝不会丢失，但可能会重复传输。</li><li>Exactly once：恰好一次。每条消息肯定会被传输一次且仅传输一次。</li></ul><p>RabbitMQ 支持其中的“最多一次”和“最少一次”。其中“最少一次”投递实现需要考虑以下这个几个方面的内容：</p><ol><li>消息生产者需要开启事务机制或者 publisher confirm 机制，以确保消息可以可靠地传输到 RabbitMQ 中。</li><li>消息生产者需要配合使用 mandatory 参数或者备份交换器来确保消息能够从交换器路由到队列中，进而能够保存下来而不会被丢弃。</li><li>消息和队列都需要进行持久化处理，以确保 RabbitMQ 务器在遇到异常情况时不会造成消息丢失。</li><li>消费者在消费消息的同时需要将 autoAck 设置为 false ，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。</li></ol><p>“最多一次”的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这样很难确保消息不会丢失。</p><p>“恰好一次”是 RabbitMQ 目前无法保障的。考虑这样一种情况，消费者在消费完一条消息之后向 RabbitMQ 发送确认 <code>Basic.Ack</code> 命令，此时由于网络断开或者其他原因造成 RabbitMQ 并没有收到这个确认命令，那么 RabbitMQ 不会将此条消息标记删除。在重新建立连接之后， 消费者还是会消费到这一条消息，这就造成了重复消费。再考虑一种情况，生产者在使用 publisher confirm 机制的时候，发送完一条消息等待 RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送，这样 RabbitMQ 中就有两条同样的消息，在消费的时候，消费者就会重复消费。</p><p>那么 RabbitMQ 有没有去重的机制来保证“恰好一次”呢？答案是并没有，不仅是 RabbitMQ, 目前大多数主流的消息中间件都没有消息去重机制，也不保障“恰好一次”。去重处理一般是在业务客户端实现，比如引入 GUID (Globally Unique Identifier）的概念。针对 GUID ，如果从客户端的角度去 ，那么需要引入集中式缓存，必然会增加依赖复杂度，另外缓存的大小也难以界定。建议在实际生产环境中，业务方根据自身的业务特性进行去重，比如业务消息本身具备幂等性，或者借助 Redis 等其他产品进行去重处理。</p><hr><p>参考：<br>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第三章《进阶》，内容来自于《RabbitMQ实战指南》，内容包括：消息何去何从，过期时间，死信队列，延迟队列，优先级队列，RPC实现，持久化，生产者确认，消费端要点，消息传输保障等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>数据备份mysqldump</title>
    <link href="http://linyishui.top/2020092601.html"/>
    <id>http://linyishui.top/2020092601.html</id>
    <published>2020-09-27T06:46:17.000Z</published>
    <updated>2020-10-02T08:15:15.627Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据备份mysqldump"><a href="#数据备份mysqldump" class="headerlink" title="数据备份mysqldump"></a>数据备份mysqldump</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-什么是mysqldump？"><a href="#1-1-什么是mysqldump？" class="headerlink" title="1.1 什么是mysqldump？"></a>1.1 什么是mysqldump？</h3><p> <code>mysqldump</code> 是用于转存储 <code>mysql</code> 数据库的实用程序。生成一个 <code>SQL</code> 脚本，其中包含从头重新创建数据库的所有命令。</p><p>导出脚本的大概过程：创建数据库判断语句、删除表、创建表、锁表、禁用索引、插入数据、启用索引、解锁表。</p><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a>1.2 简单使用</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># game 是库名</span><br><span class="line"></span><br><span class="line"># 完整导出一个库</span><br><span class="line"># 包括建库语句、表结构、数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 --databases game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 只导出表结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -d game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 只导出数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -t game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 导出一个数据库中多个表的数据和结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game --tables articles users &gt; test.sql</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 恢复导出数据</span><br><span class="line">mysql -u username -proot databse &lt; backup.sql</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>--user=user_name, -u user_name</code> ：连接数据库的用户名。</li><li><code>--password=password, -p[password]</code> ：连接数据库的密码，如果使用 <code>-p</code> 缩写，和密码之间不能有空格。</li><li><code>--opt or --compact</code> ：<ul><li>使用 <code>--opt</code> 等于使用这些参数 <code>--add-drop-table, --add-locks, --create-options, --disable-keys, --extended-insert, --lock-tables, --quick, and --set-charset</code>，默认情况下即使不加 <code>--opt</code> 参数也是开启的。</li><li>使用 <code>--compact</code> 等于使用这些参数 <code>--skip-add-drop-table, --skip-add-locks, --skip-comments, --skip-disable-keys, and --skip-set-charset</code>，默认不开启。</li></ul></li><li><code>--databases, -B</code> ：指定导出的库名。</li><li><code>--all-databases</code> ：表示导出所有的库。</li><li><code>--tables</code> ：会覆盖 –databases or -B 选项，指定导出某个表就会忽略库选项。</li><li><code>--no-data, -d</code> ：不导出数据，只导出表结构。</li><li><code>--no-create-info, -t</code> ：只导出数据，不导出表结构，不添加 <code>CREATE TABLE</code> 语句。</li><li><code>--no-create-db, -n</code> ：不添加 <code>CREATE DATABASE</code> 建库语句。</li><li><code>--routines, -R</code> ：导出存储过程以及自定义函数。</li></ul><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><p>实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 导出一个数据库</span><br><span class="line">// 包括建库语句、删表语句、建表语句、插入数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 --databases game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="comment">/*!32312 IF NOT EXISTS*/</span> <span class="string">`game`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> <span class="string">`game`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `address`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`address`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`address`</span> (</span><br><span class="line">        ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`address`</span> WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ...</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` ENABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// -d 不导出数据，导出所有的建表删表语句，不包括建库语句，</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -d game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`address`</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = utf8 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`address`</span> (</span><br><span class="line">        ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// -t 不导出结构，导出所有表中的数据，不包括建库语句，都是插入语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -t game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`address`</span> WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` DISABLE KEYS */</span>;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` ENABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line"></span><br><span class="line">// 导出一个数据库的表结构以及数据，不包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的表结构以及数据，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -B game game2 &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的结构，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -d -B game game2 &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的数据，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -t -B game game2 &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>导出某张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 导出一个数据库中一个表的结构，导出 articles 表的结构和数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的数据和结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game --tables articles users &gt; test.sql</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -d game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -t game articles users &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>数据表条件导出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出 articles 表 id = 1 的数据</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --where='id=1' game articles &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>忽略某张表：多次添加忽略多张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--ignore-table database.tableName</span></span><br></pre></td></tr></table></figure><p>导入某个表数据脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 数据来源</span><br><span class="line">src_user="root" # 用户名</span><br><span class="line">src_password="root" # 密码</span><br><span class="line">src_host="localhost" # Host</span><br><span class="line">src_port="3306" # 端口</span><br><span class="line">src_database="test" # 数据库名</span><br><span class="line">src_table="edu" # 表名</span><br><span class="line"></span><br><span class="line"># 数据导入的数据库配置</span><br><span class="line">dst_user="root" # 用户名</span><br><span class="line">dst_password="root" # 密码</span><br><span class="line">dst_host="localhost" # Host</span><br><span class="line">dst_port="3306" # 端口</span><br><span class="line">dst_database="test" # 数据库名</span><br><span class="line"></span><br><span class="line">mysqldump <span class="comment">--host=$src_host --port=$src_port -u$src_user -p$src_password $src_database --tables $src_table | mysql --host=$dst_host --port=$dst_port -u$dst_user -p$dst_password $dst_database</span></span><br></pre></td></tr></table></figure><p>备份脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 以下配置信息请自己修改</span><br><span class="line">mysql_user="root" #MySQL备份用户</span><br><span class="line">mysql_password="root" #MySQL备份用户的密码</span><br><span class="line">mysql_host="localhost"</span><br><span class="line">mysql_port="3306"</span><br><span class="line">mysql_charset="utf8mb4" #MySQL编码</span><br><span class="line">backup_db_arr=("db1" "db2") #要备份的数据库名称，多个用空格分开隔开 如("db1" "db2" "db3")</span><br><span class="line">backup_location=/var/www/mysql  #备份数据存放位置，末尾请不要带"/",此项可以保持默认，程序会自动创建文件夹</span><br><span class="line">expire_backup_delete="OFF" #是否开启过期备份删除 ON为开启 OFF为关闭</span><br><span class="line">expire_days=3 #过期时间天数 默认为三天，此项只有在expire_backup_delete开启时有效</span><br><span class="line"></span><br><span class="line"># 本行开始以下不需要修改</span><br><span class="line">backup_time=`date +%Y%m%d%H%M`  #定义备份详细时间</span><br><span class="line">backup_Ymd=`date +%Y-%m-%d` #定义备份目录中的年月日时间</span><br><span class="line">backup_3ago=`date -d '3 days ago' +%Y-%m-%d` #3天之前的日期</span><br><span class="line">backup_dir=$backup_location/$backup_Ymd  #备份文件夹全路径</span><br><span class="line">welcome_msg="Welcome to <span class="keyword">use</span> MySQL <span class="keyword">backup</span> tools!<span class="string">" #欢迎语</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 判断MYSQL是否启动,mysql没有启动则备份退出</span></span><br><span class="line"><span class="string">mysql_ps=`ps -ef |grep mysql |wc -l`</span></span><br><span class="line"><span class="string">mysql_listen=`netstat -an |grep LISTEN |grep $mysql_port|wc -l`</span></span><br><span class="line"><span class="string">if [ [$mysql_ps == 0] -o [$mysql_listen == 0] ]; then</span></span><br><span class="line"><span class="string">        echo "</span><span class="keyword">ERROR</span>:MySQL <span class="keyword">is</span> <span class="keyword">not</span> running! <span class="keyword">backup</span> <span class="keyword">stop</span>!<span class="string">"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">        echo $welcome_msg</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 连接到mysql数据库，无法连接则备份退出</span></span><br><span class="line"><span class="string">mysql -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password &lt;&lt;end</span></span><br><span class="line"><span class="string">use mysql;</span></span><br><span class="line"><span class="string">select host,user from user where user='root' and host='localhost';</span></span><br><span class="line"><span class="string">exit</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">flag=`echo $?`</span></span><br><span class="line"><span class="string">if [ $flag != "</span><span class="number">0</span><span class="string">" ]; then</span></span><br><span class="line"><span class="string">        echo "</span><span class="keyword">ERROR</span>:Can<span class="string">'t connect mysql server! backup stop!"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">        echo "MySQL connect ok! Please wait......"</span></span><br><span class="line"><span class="string">        # 判断有没有定义备份的数据库，如果定义则开始备份，否则退出备份</span></span><br><span class="line"><span class="string">        if [ "$backup_db_arr" != "" ];then</span></span><br><span class="line"><span class="string">                #dbnames=$(cut -d '</span>,<span class="string">' -f1-5 $backup_database)</span></span><br><span class="line"><span class="string">                #echo "arr is ($&#123;backup_db_arr[@]&#125;)"</span></span><br><span class="line"><span class="string">                for dbname in $&#123;backup_db_arr[@]&#125;</span></span><br><span class="line"><span class="string">                do</span></span><br><span class="line"><span class="string">                        echo "database $dbname backup start..."</span></span><br><span class="line"><span class="string">                        `mkdir -p $backup_dir`</span></span><br><span class="line"><span class="string">                        `mysqldump -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password $dbname --default-character-set=$mysql_charset | gzip &gt; $backup_dir/$dbname-$backup_time.sql.gz`</span></span><br><span class="line"><span class="string">                        flag=`echo $?`</span></span><br><span class="line"><span class="string">                        if [ $flag == "0" ];then</span></span><br><span class="line"><span class="string">                                echo "database $dbname success backup to $backup_dir/$dbname-$backup_time.sql.gz"</span></span><br><span class="line"><span class="string">                        else</span></span><br><span class="line"><span class="string">                                echo "database $dbname backup fail!"</span></span><br><span class="line"><span class="string">                        fi</span></span><br><span class="line"><span class="string">                        </span></span><br><span class="line"><span class="string">                done</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">                echo "ERROR:No database to backup! backup stop"</span></span><br><span class="line"><span class="string">                exit</span></span><br><span class="line"><span class="string">        fi</span></span><br><span class="line"><span class="string">        # 如果开启了删除过期备份，则进行删除操作</span></span><br><span class="line"><span class="string">        if [ "$expire_backup_delete" == "ON" -a  "$backup_location" != "" ];then</span></span><br><span class="line"><span class="string">                 #`find $backup_location/ -type d -o -type f -ctime +$expire_days -exec rm -rf &#123;&#125; \;`</span></span><br><span class="line"><span class="string">                 `find $backup_location/ -type d -mtime +$expire_days | xargs rm -rf`</span></span><br><span class="line"><span class="string">                 echo "Expired backup data delete complete!"</span></span><br><span class="line"><span class="string">        fi</span></span><br><span class="line"><span class="string">        echo "All database backup success! Thank you!"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">fi</span></span><br></pre></td></tr></table></figure><p>修改shell脚本的属性：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">600</span> <span class="regexp">/root/my</span>sql_backup.sh</span><br><span class="line">chmod +x <span class="regexp">/root/my</span>sql_backup.sh</span><br></pre></td></tr></table></figure><p>设置好属性之后，把命令加入 <code>crontab</code>，设置每天 <code>00:00</code> 定时自动备份。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00 </span><span class="number">00</span> * * * /path/<span class="keyword">to</span>/mysql_backup.sh</span><br></pre></td></tr></table></figure><p>恢复备份：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql -u username -proot databse &lt; backup.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和建库语句一起导入</span></span><br><span class="line">mysql -u root -p root --host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port=<span class="number">33006</span>  &lt; global.sql</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">use dbname;</span><br><span class="line"></span><br><span class="line">source dbname.sql</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 <a href="https://juejin.im/post/6844903653183062030" target="_blank" rel="noopener">mysqldump 深入浅出</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据迁移</title>
    <link href="http://linyishui.top/2020092701.html"/>
    <id>http://linyishui.top/2020092701.html</id>
    <published>2020-09-27T06:06:40.000Z</published>
    <updated>2020-10-02T08:14:17.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-什么是数据迁移？"><a href="#1-1-什么是数据迁移？" class="headerlink" title="1.1 什么是数据迁移？"></a>1.1 什么是数据迁移？</h3><p><strong>数据迁移</strong>（英语：data migration）是指<strong>选择、准备、提取和转换数据</strong>，并<strong>将数据从一个计算机存储系统永久地传输到另一个计算机存储系统</strong>的过程。此外，<strong>验证迁移数据的完整性</strong>和<strong>退役原来旧的数据存储</strong>，也被认为是整个数据迁移过程的一部分。数据迁移是任何系统实现、升级或集成的关键考虑因素，通常以尽可能自动化的方式执行，从而将人力资源从繁琐的任务中解放出来。数据迁移有多种原因，包括服务器或存储设备更换、维护或升级、应用程序迁移、网站集成、灾难恢复和数据中心迁移。</p><h3 id="1-2-为什么需要迁移数据？"><a href="#1-2-为什么需要迁移数据？" class="headerlink" title="1.2 为什么需要迁移数据？"></a>1.2 为什么需要迁移数据？</h3><ul><li>数据备份</li><li>数据转换</li><li>业务需求</li><li>……</li></ul><h3 id="1-3-常见方案"><a href="#1-3-常见方案" class="headerlink" title="1.3 常见方案"></a>1.3 常见方案</h3><ul><li>mysqldump：导出一个SQL文件，再在新数据库中执行。效率低耗时高，失败率高。<ul><li>参考：《<a href="../2020092601.html" title="Title">数据备份mysqldump</a>》</li></ul></li><li>脚本迁移：<ul><li><strong>实现一个迁移脚本</strong>，远程连接源数据库，分块读取后再写入目标数据库。可以通过切分然后多线程执行的方式进行优化，但<strong>只能先读后写</strong>。</li><li><strong>通过 Redis 搭建一个生产者+ 消费者的迁移方案</strong>，在源数据服务器运行一个多线程脚本，并行读取数据，并生产到Redis队列；在目标服务器也运行一个多线程脚本，远程连接Redis，并行读取队列中的数据，并把数据写入目标数据库。相比前一个方案，这种方式是<strong>异步</strong>的，<strong>读和写可以同时进行</strong>。</li></ul></li><li>文件迁移：SqlLoader（Oracle）或 <code>load data infile</code>（MySql）如： <code>select data into outfile file.txt</code>、<code>load data infile file.txt into table</code> 的命令。<ul><li>参考：《<a href="../2020092401.html" title="Title">SqlLoader</a>》</li></ul></li></ul><h2 id="第二节-方案实战"><a href="#第二节-方案实战" class="headerlink" title="第二节 方案实战"></a>第二节 方案实战</h2><p>数据准备，一张日志表：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010163.png" alt></p><p>数据量为一千万：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010164.png" alt></p><p>将其从 test 库迁移到 test_b 库。</p><h3 id="2-1-mysqldump"><a href="#2-1-mysqldump" class="headerlink" title="2.1 mysqldump"></a>2.1 mysqldump</h3><h3 id="2-MySql-SqlLoader"><a href="#2-MySql-SqlLoader" class="headerlink" title="2. MySql SqlLoader"></a>2. MySql SqlLoader</h3><p>1.在源数据库导出数据文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'logs1.txt'</span>;</span><br></pre></td></tr></table></figure><p>执行耗时：（只需半分钟）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010160.png" alt></p><p>文件大小：676MB</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010161.png" alt></p><p>生成文件格式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1811</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span>首页</span><br><span class="line"><span class="selector-tag">1812</span><span class="selector-tag">2</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:01</span>首页</span><br><span class="line"><span class="selector-tag">1813</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span>首页</span><br><span class="line"><span class="selector-tag">1814</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:03</span>首页</span><br><span class="line"><span class="selector-tag">1815</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:04</span>首页</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>2.复制数据文件到目标服务器：（如果是在服务器端操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip fans.zip /data/fans.txt</span><br><span class="line">scp fans.zip root@ip:/data/ </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在目标数据库导入文件</span></span><br><span class="line">unzip /data/fans.zip</span><br></pre></td></tr></table></figure><p>3.目标数据库执行命令：（需要先导入表结构）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'logs1.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> logs1(<span class="keyword">id</span>, logtype, logurl, logip, logdz, ladduser, lfadduser, laddtime, htmlname);</span><br></pre></td></tr></table></figure><p>执行耗时：（只需5分钟左右）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010162.png" alt></p><p>对比导出SQL文件，耗时从将近1小时缩短到5分钟。</p><p>在mysql执行 <code>load data infile</code> 和 <code>into outfile</code> 命令都需要在mysql开启了 <code>secure_file_priv</code> 选项， 可以通过 <code>show global variables like &#39;%secure%&#39;;</code> 查看mysql是否开启了此选项，默认值Null标识不允许执行导入导出命令。通过 <code>vim /etc/my.cnf</code> （Windows修改 <code>my.ini</code> ）修改mysql配置项，将 <code>secure_file_priv</code> 的值设置为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">  secure_file_priv=&apos;&apos;</span><br></pre></td></tr></table></figure><p>在导入数据的时候，可以通过设置字段名来匹配目标字段的数据，可以通过<code>@dummy</code>丢弃掉不需要的目标字段数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/data/fans.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> wxa_fans(<span class="keyword">id</span>,appid,openid,unionid,@dummy,created_at,@dummy,nickname,gender,avatar_url,@dummy,@dummy,@dummy,@dummy,<span class="keyword">language</span>,country,province,city,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy);</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 <a href="https://juejin.im/post/6844903630227636237" target="_blank" rel="noopener">Mysql百万级数据迁移实战笔记</a></p><p>🔗 <a href="https://cloud.google.com/solutions/database-migration-concepts-principles-part-1?hl=zh-cn" target="_blank" rel="noopener">数据库迁移：概念和原则（第 1 部分）</a></p>]]></content>
    
    <summary type="html">
    
      简单整理一下数据库中数据迁移相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>SqlLoader</title>
    <link href="http://linyishui.top/2020092401.html"/>
    <id>http://linyishui.top/2020092401.html</id>
    <published>2020-09-24T07:26:04.000Z</published>
    <updated>2020-10-02T08:17:02.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SqlLoader"><a href="#SqlLoader" class="headerlink" title="SqlLoader"></a>SqlLoader</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-常见的几种数据迁移方式"><a href="#1-1-常见的几种数据迁移方式" class="headerlink" title="1.1 常见的几种数据迁移方式"></a>1.1 常见的几种数据迁移方式</h3><p>日常开发中会经常遇到这样的需求，大批量的数据需要在不同的数据库间迁移，一般会有如下几种方式（不一定涵盖所有）：</p><ul><li>源数据库直接导出SQL文件，目标数据库执行；<ul><li>数据量大时效率很低，甚至可能会卡死客户端。</li></ul></li><li>创建数据库间的DBLink，用 <code>create table B as select * from A@dblink where ...</code> ，或 <code>insert into B select * from A@dblink where ...</code> ；</li><li>exp A 表，再 imp 到 B 表，exp 时可加查询条件；</li><li>程序实现 <code>select from A ..</code> ，然后 <code>insert into B ...</code> ，也要分批提交；</li><li>SqlLoader导入数据。</li></ul><h3 id="1-2-什么是SqlLoader"><a href="#1-2-什么是SqlLoader" class="headerlink" title="1.2 什么是SqlLoader"></a>1.2 什么是SqlLoader</h3><p>Oracle提供了 <code>sqlldr</code> 命令，参数：</p><ul><li>userid：username/password[@servicename]；</li><li>control：控制文件，可能包含表的数据；</li><li>log：记录导入时的日志文件，默认为 控制文件(去除扩展名).log；</li><li>bad：坏数据文件，默认为 控制文件(去除扩展名).bad；</li><li>data：数据文件，一般在控制文件中指定。用参数控制文件中不指定数据文件更适于自动操作；</li><li>errors：允许的错误记录数，可以用他来控制一条记录都不能错；</li><li>rows：多少条记录提交一次，默认为 64；</li><li>skip：跳过的行数，比如导出的数据文件前面几行是表头或其他描述。</li></ul><p>sqlldr是在处理大数据量的操作中建议采用的方式，它有许多性能相关的开关，能最大程度的减少 redo，undo 的生成。</p><p>MySql中对应的语句：<code>load data infile</code> 。</p><h3 id="1-3-SqlLoader用法"><a href="#1-3-SqlLoader用法" class="headerlink" title="1.3 SqlLoader用法"></a>1.3 SqlLoader用法</h3><p>控制文件 <code>.ctl</code> 格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 控制文件标识</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 要导入的数据文件名</span></span><br><span class="line"><span class="keyword">INFILE</span> <span class="string">'xxx.txt'</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 将文件插入到数据库的 test 表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 用于分割一行中各个属性值的符号（例如每个属性值用逗号分割， 那么就把 X'09' 改为','）</span></span><br><span class="line"><span class="keyword">Fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> X<span class="string">'09'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. test表中对应的属性名</span></span><br><span class="line">(<span class="keyword">id</span>, username, passwprd, ......)</span><br></pre></td></tr></table></figure><p>操作类型有：</p><ol><li>insert：为缺省方式，在数据装载开始时要求表为空；</li><li>append：在表中追加新记录；</li><li>replace：删除旧记录(用 delete from table 语句)，替换成新装载的记录；</li><li>truncate：删除旧记录(用 truncate table 语句)，替换成新装载的记录。</li></ol><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此文件格式是.log，用文本文件的方法可以导入进去</span></span><br><span class="line"><span class="keyword">infile</span> <span class="string">'D:/xxx/xxx.log'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- insert为缺省方式，插入时要求表为空</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> database_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据文件每个字段也就是属性是按照|来分割的</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'|'</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据中某些属性可能是null值 ， 如果不加入这行导入到数据库的时候就会自动跳过null值的列, 这样数据插入后就会属性和值对应不上</span></span><br><span class="line">trailing nullcols </span><br><span class="line"></span><br><span class="line"><span class="comment">-- content运用的类型是clob，当使用sqlldr加载很长的字符串(超过4000)到表中的clob类型中时会报错：数据文件的字段超出最大长度；sqlldr每次读入文件中数据流的数据类型默认为CHAR ,长度为 255 .所以只要超过255字符的段都会报这个错，所以char(10000)用来控制上限</span></span><br><span class="line">(<span class="keyword">time</span>, user_id, <span class="keyword">type</span>, longitude, latitude, height, <span class="keyword">content</span> <span class="built_in">char</span>(<span class="number">10000</span>))</span><br></pre></td></tr></table></figure><p>接下来可以直接通过 <code>sqlldr</code> 语句导入，一般项目会通过一个数据文件和一个控制文件来实现此功能，这样可以将模板和数据分离，可以重复使用：</p><ul><li>数据文件：可以是PL/SQL或Toad导出、SqlPlus的Spool格式化产出、UTL_FILE包生成。</li></ul><h3 id="1-4-LOAD-DATA-INFILE用法"><a href="#1-4-LOAD-DATA-INFILE用法" class="headerlink" title="1.4 LOAD DATA INFILE用法"></a>1.4 LOAD DATA INFILE用法</h3><p><code>LOAD DATA INFILE</code> 是  <code>SELECT ... INTO OUTFILE</code> 的相对语句。把表的数据备份到文件使用 <code>SELECT ... INTO OUTFILE</code> ，从备份文件恢复表数据，使用  <code>LOAD DATA INFILE</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">CONCURRENT</span>] [<span class="keyword">LOCAL</span>] <span class="keyword">INFILE</span> <span class="string">'file_name.txt'</span></span><br><span class="line">    [<span class="keyword">REPLACE</span> | <span class="keyword">IGNORE</span>]</span><br><span class="line">    <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tbl_name</span><br><span class="line">    [<span class="keyword">FIELDS</span></span><br><span class="line">        [<span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">        [[<span class="keyword">OPTIONALLY</span>] <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'char'</span>]</span><br><span class="line">        [<span class="keyword">ESCAPED</span> <span class="keyword">BY</span> <span class="string">'char'</span> ]</span><br><span class="line">    ]</span><br><span class="line">    [<span class="keyword">LINES</span></span><br><span class="line">        [<span class="keyword">STARTING</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">        [<span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">    ]</span><br><span class="line">    [<span class="keyword">IGNORE</span> <span class="built_in">number</span> <span class="keyword">LINES</span>]</span><br><span class="line">    [(col_name_or_user_var,...)]</span><br><span class="line">    [<span class="keyword">SET</span> col_name = expr,...)]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'data.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tbl_name </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> </span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span> </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只载入部分列</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'persondata.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> persondata (col1,col2)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p>LOW_PRIORITY：适用于表锁存储引擎，比如MyISAM, MEMORY, 和 MERGE，在写入过程中如果有客户端程序读表，写入将会延后，直至没有任何客户端程序读表再继续写入。</p></li><li><p>CONCURRENT：使用该参数，允许在写入过程中其它客户端程序读取表内容。</p></li><li><p>LOCAL：关键字影响数据文件定位和错误处理，影响在哪里找到数据文件。只有当 mysql-server 和 mysql-client 同时在配置中指定允许使用，LOCAL关键字才会生效。</p><ul><li><p>LOCAL load operations：如果指定了LOCAL，数据文将被客户端程序从客户端主机读取，然后发送给服务器主机。将在服务器主机的临时目录创建一个数据文件的副本，如果临时目录剩余空间不足，将导致语句执行失败。</p></li><li><p>Non-LOCAL load operations：如果没有指定LOCAL，数据文件必须位于服务器值机上，直接由 mysql-server 读取。mysql-serve 使用如下规则来定位文件：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>数据文件使用绝对路径，直接使用</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>数据文件使用相对路径并且有前导的部分，将相对于 mysql-server 的数据目录查找，例如 ./myfile.txt</span><br><span class="line"></span><br><span class="line"><span class="bullet">3. </span>数据文件使用相对路径并且没有前导的部分，将相对于默认数据库的数据文件目录查找,例如 myfile.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>根据上面的规则，./myfile.txt  将被定位到 mysql-server 的 data directory,而 myfile.txt 将被定位到 default database 的  database directory。如果 db1 时默认数据库，则下面的语句将从 db1 的数据库目录读取 data.txt,即使明确指定把数据装载到 db2：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'data.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> db2.my_table;</span><br></pre></td></tr></table></figure>Non-LOCAL load operations 从服务器主机上读取数据文将。出于安全原因，这个操作需要文件权限。 如果secure_file_priv 系统变量的value 不为空，数据文件必须放在该变量指定的目录。如果该变量为空，数据文件必须可读。使用LOCAL将比让服务器直接存取文件慢些，因为文件的内容必须从客户主机传送到服务器主机。在另一方面，你不需要file权限装载本地文件。</code></pre><ul><li><p>LOCAL关键字对错误处理的影响：</p><ol><li>使用 LOAD DATA INFILE,data-interpretation 和 duplicate-key 错误会终止操作；</li><li>使用 LOAD DATA LOCAL INFILE，data-interpretation 和 duplicate-key 错误会发出警告，操作将继续执行。对于duplicate-key错误，效果和指定了 IGNORE 关键字一样。</li></ol></li></ul><ul><li><p>REPLACE | IGNORE：控制对现有的唯一键记录的重复的处理。</p><ul><li>指定REPLACE，新行将代替有相同的唯一键值的现有行。</li><li>指定IGNORE，跳过有唯一键的现有行的重复行的输入。</li><li>不指定任何一个选项，当找到重复键键时，出现一个错误，并且文本文件的余下部分被忽略时。</li></ul></li><li><p>FIELDS：</p><ul><li><p>基本用法：如果指定一个FIELDS子句，它的每一个子句(TERMINATED BY, [OPTIONALLY] ENCLOSED BY和ESCAPED BY)也是可选的，但是必须至少指定一个。</p><p>如果你指定 FIELDS 或 LINES ，缺省值为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'</span><br><span class="line">LINES TERMINATED BY '\n' STARTING BY ''</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>缺省值导致读取输入时，LOAD DATA INFILE表现如下：1. 在 \n 处寻找行边界2. 在 \t 处将行分进字段3. 不要期望字段由任何引号字符封装4. 将由“\”开头的定位符、换行符或“\”解释成转义序列。例如 \t, \n, and \ 分别解释成 定位符，换行，反斜杠。相反，缺省值导致在写入输出时，SELECT ... INTO OUTFILE表现如下：1. 在字段之间写 \t2. 不用任何引号字符封装字段3. 使用“\”转义出现在字段中的 定位符、换行符或“\”字符4. 在行尾处写换行符</code></pre><ul><li><p>FIELDS [OPTIONALLY] ENCLOSED BY：控制哪些字段应该包裹在引号里面。</p><p>对于SELECT … INTO OUTFILE 输出，如果不包含OPTIONALLY选项，所有的字段将会被ENCLOSED BY指定的字符包裹，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1"</span>,<span class="string">"a string"</span>,<span class="string">"100.20"</span>  </span><br><span class="line"><span class="string">"2"</span>,<span class="string">"a string containing a , comma"</span>,<span class="string">"102.20"</span>  </span><br><span class="line"><span class="string">"3"</span>,<span class="string">"a string containing a \" quote"</span>,<span class="string">"102.20"</span>  </span><br><span class="line"><span class="string">"4"</span>,<span class="string">"a string containing a \", quote and comma"</span>,<span class="string">"102.20"</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>如果我们指定OPTIONALLY，只有string数据类型（如 CHAR, BINARY, TEXT, 或 ENUM）的字段才会被ENCLOSED BY指定的字符包裹，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a \" quote"</span>,102.20  </span><br><span class="line">4,<span class="string">"a string containing a \", quote and comma"</span>,102.20</span><br></pre></td></tr></table></figure>注意，如果在字段值内出现ENCLOSED BY字符，则通过使用ESCAPED BY字符作为前缀，对ENCLOSED BY字符进行转义。另外，要注意，如果指定了一个空ESCAPED BY值，则可能会生成不能被LOAD DATAINFILE 正确读取的输出值。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a "</span> quote<span class="string">",102.20  </span></span><br><span class="line"><span class="string">4,"</span>a string containing a <span class="string">", quote and comma"</span>,102.20</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>FIELDS ESCAPED BY：用来控制如何对特殊字符进行读写。</p><p>如上面一个例子，导出和导入时指定FIELDS ESCAPED BY为双引号[“]才能被正确的导入，导出的格式如下，对字段内的双引号[“]进行了转义。</p></li></ul><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a #"</span> quote<span class="string">",102.20  </span></span><br><span class="line"><span class="string">4,"</span>a string containing a <span class="comment">#", quote and comma",102.20</span></span><br></pre></td></tr></table></figure>对于输入： 假如FIELDS ESCAPED BY指定字符非空，则输入时该字符被移除，后续的内容被添加到字段里。一些两个字符的字符串序列且第一个字符是转义字符的例外 。这些字符序列见下表：| Character | Escape Sequence                || :-------: | ------------------------------ ||    \0     | An ASCII NUL (X&apos;00&apos;) character ||    \b     | A backspace character          ||    \n     | A newline (linefeed) character ||    \r     | A carriage return character    ||    \t     | A tab character.               ||    \Z     | ASCII 26 (Control+Z)           ||    \N     | NULL                           |假如FIELDS ESCAPED BY指定字符为空，将不会发生转义序列的解释。对于输出，如果FIELDS ESCAPED BY指定字符非空，字符作为以下输出的前缀：1. FIELDS ESCAPED BY 字符，例如 \2. FIELDS [OPTIONALLY] ENCLOSED BY 字符，例如 &quot;3. FIELDS TERMINATED BY and LINES TERMINATED BY 的 value 的第一个字符,例如\n4. ASCII 0如果LINES TERMINATED BY是空字符串，FIELDS TERMINATED BY非空,字符将不会被转义，NULL 将输出为 NULL而不是 \N。指定LINES TERMINATED BY为空字符串并不是个好主意，特别当内容中包含上表列出的特殊字符时。</code></pre><ul><li><p>LINES STARTING BY：如果所有希望读入的行都含有一个我们希望忽略的共用前缀，则可以使用 LINES STARTING BY ‘prefix_string’  来跳过前缀（以及该前缀前的所有字符）。如果某行不包括前缀，则整个行被跳过。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> </span><br><span class="line">   <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>  <span class="keyword">LINES</span> <span class="keyword">STARTING</span> <span class="keyword">BY</span> <span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure></li></ul><pre><code>假如/tmp/test.txt文件内容如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx"abc",1  </span><br><span class="line">something xxx"def",2  </span><br><span class="line">"ghi",3</span><br></pre></td></tr></table></figure>则我们读入的内容包括(&quot;abc&quot;,1) 和 (&quot;def&quot;,2)，第三行直接被跳过。</code></pre><ul><li><p>IGNORE number LINES：该选项可以被用于在文件的开始处忽略行。例如，我们可以使用IGNORE 1 LINES来跳过一个包含列名称的起始标题行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">IGNORE</span> <span class="number">1</span> <span class="keyword">LINES</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在特定情况下，field-和line-handling选项相互影响：</p><ol><li>如果LINES TERMINATED BY是空字符串，FIELDS TERMINATED BY非空,行以FIELDS TERMINATED BY指定的字符串作为结尾。</li><li>如果FIELDS TERMINATED BY 与 FIELDS ENCLOSED BY值均为空(‘’)，将使用固定行（无分割）格式。使用固定行格式，字段之间将没有分隔符（行终止符依然可使用），列字段数据的读取和写入均按照字段定义的宽度去操作，如 TINYINT, SMALLINT, MEDIUMINT, INT, 和 BIGINT, 字段宽度分别为4, 6, 8, 11, 和 20。</li></ol></li><li><p>不适合使用 LOAD DATA INFILE 的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用固定行格式（即FIELDS TERMINATED BY 和 FIELDS ENCLOSED BY 均为空）,列字段类型为BLOB或TEXT。</span><br><span class="line">2. 指定分隔符与其它选项前缀一样，<span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>不能对输入做正确的解释。例如：</span><br><span class="line">   <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'"'</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span>  </span><br><span class="line"><span class="number">3.</span> 如果 <span class="keyword">FIELDS</span> <span class="keyword">ESCAPED</span> <span class="keyword">BY</span> 为空，字段值包含 <span class="keyword">FIELDS</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> 指定字符，或者 <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> 的字符在 <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> 之前，都会导致过早的停止 <span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>操作。因为<span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>不能准确的确定行或列的结束。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>IGNORE number LINES 选项：IGNORE number LINES选项可以被用于在文件的开始处忽略行。<br>您可以使用IGNORE 1 LINES来跳过一个包含列名称的起始标题行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span>  <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">IGNORE</span> <span class="number">1</span> <span class="keyword">LINES</span>;</span><br></pre></td></tr></table></figure></li><li><p>选择导入的列：</p><p>下面的语句会导入文件的所有列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'persondata.txt'</span> INTO TABLE persondata;</span><br></pre></td></tr></table></figure><p>如果我们想导入表的某些列，需要指定列的列表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'persondata.txt'</span> <span class="function">INTO TABLE <span class="title">persondata</span> (<span class="params">col1,col2,...</span>)</span>;</span><br></pre></td></tr></table></figure><p>如果输入文件与表的列顺序不同，我们必须指定一个列清单，否则mysql不能把输入文件的字段与表的列匹配起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA INFILE <span class="string">'/tmp/loadtest.txt'</span> INTO TABLE loadtest </span><br><span class="line">   FIELDS TERMINATED BY <span class="string">','</span> </span><br><span class="line">   OPTIONALLY ENCLOSED BY <span class="string">'"'</span> </span><br><span class="line">   ESCAPED BY <span class="string">'#'</span> </span><br><span class="line">   LINES TERMINATED BY <span class="string">'\n'</span> </span><br><span class="line">   (c1, c2, c4, c3);</span><br></pre></td></tr></table></figure><p>列的清单可以包含列名或者用户变量，在写入列前我们需要使用SET语句对用户变量进行转换。对set语句及用户变量有如下使用方法：</p><p>方法1：在用户变量用于第一列之前，先把第一列的值赋予用户变量，进行除法操作后输入到c1。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, <span class="meta">@var</span>1)</span><br><span class="line">  SET column2 = <span class="meta">@var</span>1/<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>方法2The SET clause can be used to supply values not derived from the input file. 。使用下面例子把c3列设为当前时间</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, column2)</span><br><span class="line">  SET column3 = CURRENT_TIMESTAMP;</span><br></pre></td></tr></table></figure><p>方法3：把输入赋予用户变量，而不把用户变量赋予表中的列，来丢弃此输入值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, <span class="meta">@dummy</span>, column2, <span class="meta">@dummy</span>, column3);</span><br></pre></td></tr></table></figure></li><li><p>通过管道导入数据：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在unix系统中，如果我们想要从管道（pipe）中load data，需要用如下方法：</span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># mkfifo /tmp/ls.dat  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># chmod 666 /tmp/ls.dat  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># find / -ls &gt; /tmp/ls.dat &amp;  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># mysql -e <span class="string">"LOAD DATA INFILE '/tmp/ls.dat' INTO TABLE test.tb1 FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"</span><span class="string">' ESCAPED BY '</span>#<span class="string">' LINES TERMINATED BY '</span>\n<span class="string">'"</span></span></span><br></pre></td></tr></table></figure><p>注意：sql-mode使用严格事物模式STRICT_TRANS_TABLES会报错</p><p>在另一窗口将数据写入管道</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> <span class="regexp">/]# cat /</span>tmp<span class="regexp">/loadtest.txt &gt; /</span>tmp/ls.dat</span><br></pre></td></tr></table></figure><p>注：可以先读或者先写管道，谁先谁后都可以，在写入管道的数据被全部读出前，处于阻塞状态。</p></li></ul><h2 id="第二节-实战"><a href="#第二节-实战" class="headerlink" title="第二节 实战"></a>第二节 实战</h2><h3 id="2-1-导出SQL"><a href="#2-1-导出SQL" class="headerlink" title="2.1 导出SQL"></a>2.1 导出SQL</h3><p>导出一千万条数据，耗时-5分钟，sql文件大小-1.17 GB</p><p>直接执行SQL文件，耗时54分41秒</p><h3 id="2-2-load-data-infile"><a href="#2-2-load-data-infile" class="headerlink" title="2.2 load data infile"></a>2.2 load data infile</h3><p>1.在源数据库导出数据文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'logs1.txt'</span>;</span><br></pre></td></tr></table></figure><p>执行耗时：（只需半分钟）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010160.png" alt></p><p>文件大小：676MB</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010161.png" alt></p><p>生成文件格式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1811</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span>首页</span><br><span class="line"><span class="selector-tag">1812</span><span class="selector-tag">2</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:01</span>首页</span><br><span class="line"><span class="selector-tag">1813</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span>首页</span><br><span class="line"><span class="selector-tag">1814</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:03</span>首页</span><br><span class="line"><span class="selector-tag">1815</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:04</span>首页</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>3.目标数据库执行命令：（需要先导入表结构）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'logs1.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> logs1(<span class="keyword">id</span>, logtype, logurl, logip, logdz, ladduser, lfadduser, laddtime, htmlname);</span><br></pre></td></tr></table></figure><p>执行耗时：（只需5分钟左右）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010162.png" alt></p><p>对比导出SQL文件，耗时从将近1小时缩短到5分钟。</p><h3 id="2-3-SqlLoader"><a href="#2-3-SqlLoader" class="headerlink" title="2.3 SqlLoader"></a>2.3 SqlLoader</h3><p>1.导出数据文件，可以是任意支持格式，如 <code>.txt</code>，<code>.csv</code> 等。</p><p>2.创建控制文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS (skip=1,rows=128) <span class="comment">-- sqlldr 命令显示的 选项可以写到这里边来,skip=1 用来跳过数据中的第一行  </span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span>  </span><br><span class="line"><span class="keyword">INFILE</span> <span class="string">"users_data.csv"</span> <span class="comment">--指定外部数据文件，可以写多 个 INFILE "another_data_file.csv" 指定多个数据文件  </span></span><br><span class="line"><span class="comment">--这里还可以使 用 BADFILE、DISCARDFILE 来指定坏数据和丢弃数据的文件，  </span></span><br><span class="line"><span class="keyword">truncate</span> <span class="comment">--操作类型，用 truncate table 来清除表中原有 记录  </span></span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> <span class="comment">-- 要插入记录的表  </span></span><br><span class="line"><span class="keyword">Fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">","</span> <span class="comment">-- 数据中每行记录用 "," 分隔  </span></span><br><span class="line"><span class="keyword">Optionally</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">'"'</span> <span class="comment">-- 数据中每个字段用 '"' 框起，比如字段中有 "," 分隔符时  </span></span><br><span class="line">trailing nullcols <span class="comment">--表的字段没有对应的值时允 许为空  </span></span><br><span class="line">(  </span><br><span class="line">  virtual_column FILLER, <span class="comment">--这是一个虚拟字段，用来跳 过由 PL/SQL Developer 生成的第一列序号  </span></span><br><span class="line">  user_id <span class="built_in">number</span>, <span class="comment">--字段可以指定类型，否则认 为是 CHARACTER 类型, log 文件中有显示  </span></span><br><span class="line">  user_name,  </span><br><span class="line">  login_times,  </span><br><span class="line">  last_login <span class="built_in">DATE</span> <span class="string">"YYYY-MM-DD HH24:MI:SS"</span> <span class="comment">-- 指定接受日期的格式，相当用 to_date() 函数转换  </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行完 sqlldr 后可以留意一下生成的几个文件，如 users.log 日志文件、users.bad 坏数据文件等。特别是要看看日志文件，从中可让你更好的理解 Sql Loader，里面有对控制文件的解析、列出每个字段的类型、加载记录的统计、出错原因等信息。</p><h2 id="第三节-SqlLoader细节"><a href="#第三节-SqlLoader细节" class="headerlink" title="第三节 SqlLoader细节"></a>第三节 SqlLoader细节</h2><p>SqlLoader 的性能与并发操作：</p><ol><li><p>ROWS 的默认值为 64，可以根据实际指定更合适的 ROWS 参数来指定每次提交记录数。</p></li><li><p>常规导入可以通过使用 INSERT语句来导入数据。Direct 导入可以跳过数据库的相关逻辑(DIRECT=TRUE)，而直接将数据导入到数据文件中，可以提高导入数据的性能。当然，在很多情况下，不能使用此参数(如果主键重复的话会使索引的状态变成UNUSABLE!)。</p></li><li><p>通过指定 UNRECOVERABLE选项，可以关闭数据库的日志(是否要 alter table table1 nologging 呢?)。这个选项只能和 direct 一起使用。</p></li><li><p>对于超大数据文件的导入就要用并发操作了，即同时运行多个导入任务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlldr userid=/ control=result1.ctl direct=true parallel=true   </span><br><span class="line">sqlldr userid=/ control=result2.ctl direct=true parallel=true   </span><br><span class="line">sqlldr userid=/ control=result2.ctl direct=true parallel=true</span><br></pre></td></tr></table></figure></li><li><p>当加载大量数据时（大约超过10GB），最好抑制日志的产生：  <code>SQL&gt;ALTER  TABLE  RESULTXT  nologging;</code> 这样不产生REDO LOG，可以提高效率。然后在 CONTROL 文件中 load data 上面加一行：unrecoverable， 此选项必须要与DIRECT共同应用。</p></li><li><p>在并发操作时，ORACLE声称可以达到每小时处理100GB数据的能力！其实，估计能到 1－10G 就算不错了，开始可用结构相同的文件，但只有少量数据，成功后开始加载大量数据，这样可以避免时间的浪费。（注意：一般只能用ASCII码形式，切记要转换编码，不然导入数据为空）</p></li></ol><p><a href="https://cloud.tencent.com/developer/article/1059843" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1059843</a></p><hr><p>参考：</p><p>🔗 <a href="https://blog.csdn.net/shadow_zed/article/details/82661118" target="_blank" rel="noopener">oracle sqlldr 用法详解</a></p><p>🔗 <a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">MySql官方文档-LOAD DATA Statement</a></p><p>🔗 <a href="https://www.jianshu.com/p/bcafd8f3ad8e" target="_blank" rel="noopener">LOAD DATA INFILE 导入数据</a></p>]]></content>
    
    <summary type="html">
    
      简单整理一下SqlLoader相关内容，简单使用，实战案例等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
      <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（二）客户端开发</title>
    <link href="http://linyishui.top/2020092001.html"/>
    <id>http://linyishui.top/2020092001.html</id>
    <published>2020-09-20T04:34:35.000Z</published>
    <updated>2020-10-02T08:15:29.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a><strong>客户端开发</strong></h1><h2 id="第一节-连接RabbitMQ"><a href="#第一节-连接RabbitMQ" class="headerlink" title="第一节 连接RabbitMQ"></a><strong>第一节 连接RabbitMQ</strong></h2><p>客户端给定参数（IP地址、端口号、用户名、密码等）连接RabbitMQ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUsername(USERNAME);</span><br><span class="line">factory.setPassword(PASSWORD);</span><br><span class="line">factory.setVirtualHost(virtualHost);</span><br><span class="line">factory.setHost(IP_ADDRESS);</span><br><span class="line">factory.setPort(PORT);</span><br><span class="line">Connection conn = factory.newConnection();</span><br></pre></td></tr></table></figure><p>也可以用URL的方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUri(<span class="string">"amqp://userName:password@ipAddress:portNumber/virtualHost"</span>);</span><br><span class="line">Connection conn = factory.newConnection();</span><br><span class="line"><span class="comment">//Connection 接口被用来创建一个 Channel:</span></span><br><span class="line">Channel channel= conn.createChannel();</span><br><span class="line"><span class="comment">//在创建之后，Channel可以用来发送或者接收消息了</span></span><br></pre></td></tr></table></figure><p>Connection 可以用来创建多个 Channel 实例，但是 Channel 实例不能在线程问共享， 应用程序应该为每一个线程开辟一个 Channel 。多线程问共享 Channel 实例是非线程安全的。</p><p>Channel 或者 Connection 中有个 <code>isOpen</code> 方法可以用来检测其是否己处于开启状态，这个方法的返回值依赖于 <code>shutdownCause</code> ，不推荐在生产环境使用，可能会产生竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.shutdownCause == <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误地使用 <code>isOpen</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brokenMethod</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.isOpen())&#123;</span><br><span class="line">        <span class="comment">//The following code depends on the channel being in opeηstate.</span></span><br><span class="line">        <span class="comment">//However there is a possibility of the change in the channel state</span></span><br><span class="line">        <span class="comment">//between isOpen() and basicQos(l) call</span></span><br><span class="line">        ...</span><br><span class="line">        channel.basicQos(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，在调用 <code>createXXX</code> 或者 <code>newXXX</code> 方法之后，我们可以简单地认为 Connection 或者 Channel 已经成功地处于开启状态，而并不会在代码中使用 <code>isOpen</code> 这个检测方法。如果在使用 Channel 的时候其己经处于关闭状态，那么程序会抛出一个 <code>com.rabbitmq.client.ShutdownSignalException</code> ，我们只需捕获这个异常即可。当然同时也要试着捕获 <code>IOException</code> 或者 <code>SocketException</code> ，以防 Connection 意外关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validMethod</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">channel.basicQos(l);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ShutdownSignalException sse) &#123;</span><br><span class="line">        <span class="comment">//possibly check if channel was closed</span></span><br><span class="line">        <span class="comment">//by the time we started action and reasons for</span></span><br><span class="line">        <span class="comment">//closing it</span></span><br><span class="line">        ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="comment">//check why connection was closed </span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-使用交换器和队列"><a href="#第二节-使用交换器和队列" class="headerlink" title="第二节 使用交换器和队列"></a><strong>第二节 使用交换器和队列</strong></h2><p>交换器和队列是 AMQP high-level 层面的构建模块，应用程序需确保在使用它们的时候就已经存在了，在使用之前需要先声明（declare）它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个持久化的、非自动删除的、绑定类型为 direct 交换器</span></span><br><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//同时也创建一个非持久化的、排他的、自动删除的队列（此队列的名称由 RabbitMQ 自动生成）</span></span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//使用路由键将队列和交换器绑定起来</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure><p>上面声明的队列具备如下特性：只对当前应用中同一个 Connection 层面可用，同一个 Connection 的不同 Channel 可共用，并且也会在应用连接断开时自动删除。</p><p>如果要在应用中共享一个队列，可以做如下声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上</span></span><br><span class="line">channel.exchangeDeclare(exchangeName , <span class="string">"direct"</span>, <span class="keyword">true</span>) ;</span><br><span class="line"><span class="comment">//队列被声明为持久化的 非排他的、非自动删除的，而且也被分配另一个确定的己知的名称（由客户端分配而非 RabbitMQ 自动生成）</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(queueName , exchangeName , routingKey) ;</span><br></pre></td></tr></table></figure><p>生产者和消费者都可以声明一个交换器或者队列。</p><h3 id="2-1-exchangeDeclare"><a href="#2-1-exchangeDeclare" class="headerlink" title="2.1 exchangeDeclare()"></a><strong>2.1 exchangeDeclare()</strong></h3><p><code>exchangeDeclare()</code> 用来声明交换器，有多种重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> autoDelete, <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String , Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li><code>Exchange.DeclareOk</code> ：用来标识成功声明了一个交换器。</li><li>exchange：交换器的<strong>名称</strong>。</li><li>type：交换器的<strong>类型</strong>。<ul><li>常见的如fanout，direct，topic。</li></ul></li><li>durable：设置<strong>是否持久化</strong>。<ul><li>持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li></ul></li><li>autoDelete：设置<strong>是否自动删除</strong>。<ul><li>自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。</li><li>注意不能错误地把这个参数理解为：当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器。</li></ul></li><li>internal：设置<strong>是否是内置的的交换器</strong>。<ul><li>客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li></ul></li><li>argument：其他一些<strong>结构化参数</strong>，比如 <code>alternate-exchange</code> </li></ul><p>类似的方法：</p><ul><li>exchangeDeclareNoWait：无返回值，不建议使用，刚声明完交换器紧接着就使用，可能导致因交换器未创建而发生异常。</li><li>exchangeDeclarePassive：用来检测相应的交换器是否存在，不存在抛出异常 <code>404 channel exception</code> 同时关闭 Channel 。</li><li>exchangeDelete：删除交换器。</li><li>exchangeDeleteNoWait：无返回删除。</li></ul><h3 id="2-2-queueDeclare"><a href="#2-2-queueDeclare" class="headerlink" title="2.2 queueDeclare()"></a><strong>2.2 queueDeclare()</strong></h3><p><code>queueDeclare()</code> 创建一个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>无参方法默认构建一个 RabbitMQ命名的、排他的、自动删除的、非持久化的队列。</li><li>queue：队列<strong>名称</strong></li><li>durable：设置<strong>是否持久化</strong>。<ul><li>持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li></ul></li><li>exclusive：设置<strong>是否排他</strong>。<ul><li>如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。</li><li>这里需要注意三点：<ul><li>排他队列是基于连接（ Connection ）可见的，同一个连接的不同信道（Channel) 是可以同时访问同一连接创建的排他队列；</li><li>“首次”是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；</li><li>即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。</li></ul></li></ul></li><li>autoDelete：设置是否自动删除。<ul><li>自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为：“当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li></ul></li><li>arguments：设置队列的其他一些参数。<ul><li>如 <code>x-message-ttl</code> <code>x-expires</code> <code>x-max-length</code> <code>x-max-length-bytes</code> <code>x-dead-letter-exchange</code> <code>x-dead-letter-routing-key</code> , <code>x-max-priority</code> 等。</li></ul></li></ul><p>注意：生产者和消费者都能够使用 queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道置为“传输”模式，之后才能声明队列。</p><p>类似的方法这里不再赘述。</p><h3 id="2-3-queueBind"><a href="#2-3-queueBind" class="headerlink" title="2.3 queueBind()"></a><strong>2.3 queueBind()</strong></h3><p><code>queueBind()</code> 将队列与交换器绑定/解绑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">BindOk <span class="title">queueBind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Queue.<span class="function">UnbindOk <span class="title">queueUnbind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>queue：队列名称；</li><li>exchange：交换器的名称；</li><li>routingKey：用来绑定队列和交换器的路由键；</li><li>arguments：定义绑定的一些参数。</li></ul><h3 id="2-4-exchangeBind"><a href="#2-4-exchangeBind" class="headerlink" title="2.4 exchangeBind()"></a><strong>2.4 exchangeBind()</strong></h3><p><code>exchangeBind()</code> 将交换器与交换器绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">BindOk <span class="title">exchangeBind</span><span class="params">(String destination, String source , String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>绑定之后，消息从 source 交换器转发到 destination 交换器，后者可以看作是一个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别声明source和destination交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"source"</span>, <span class="string">"direct"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>) ;</span><br><span class="line">channel.exchangeDeclare(<span class="string">"destination"</span>, <span class="string">"fanout"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//绑定两者</span></span><br><span class="line">channel.exchangeBind(<span class="string">"destination"</span>, <span class="string">"source"</span>, <span class="string">"exKey"</span>);</span><br><span class="line"><span class="comment">//声明队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">"queue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//绑定destination交换器和队列</span></span><br><span class="line">channel.queueBind(<span class="string">"queue"</span>, <span class="string">"destination"</span>，<span class="string">""</span>);</span><br><span class="line"><span class="comment">//source推送消息</span></span><br><span class="line">channel.basicPublish(<span class="string">"source"</span>, <span class="string">"exKey"</span>, <span class="keyword">null</span>, <span class="string">"exToExDemo"</span>. getBytes());</span><br></pre></td></tr></table></figure><p>生产者发送消息至交换器 source 中，交换器 source 根据路由键找到与其匹配 的另一个交换器 destination 井把消息转发到 destination 中，进而存储在 destination 绑定的队列 queue 中：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010156.png" alt></p><h3 id="2-5-何时创建"><a href="#2-5-何时创建" class="headerlink" title="2.5 何时创建"></a><strong>2.5 何时创建</strong></h3><p>RabbitMQ 的<strong>消息存储在队列中</strong>，交换器的使用并不真正耗费服务器的性能，而队列会。 如果要衡量 RabbitMQ 当前的 QPS ，只需看队列的即可。<strong>在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值</strong>，以便在固定硬件资源的情况下能够进行合理有效的分配。 </p><p>按照 RabbitMQ 官方建议，<strong>生产者和消费者都应该尝试创建（这里指声明操作）队列</strong>。这是一个很好的建议，但不适用于所有的情况。如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好（<strong>比如通过页面管理、 RabbitMQ 命令或者更好的是从配置中心下发</strong>），这样业务程序也可以免去声明的过程，直接使用即可。 </p><p>预先创建好资源还有一个好处是，<strong>可以确保交换器和队列之间正确地绑定匹配</strong>。很多时候， 由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失；或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。 当然<strong>可以配合 mandatory 参数或者备份交换器来提高程序的健壮性</strong>。 </p><p>与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。 </p><p>如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，<strong>也完全可以在业务程序中声明队列</strong>。 至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。</p><hr><h2 id="第三节-发送消息"><a href="#第三节-发送消息" class="headerlink" title="第三节 发送消息"></a><strong>第三节 发送消息</strong></h2><p><code>channel.basicPublish()</code> 可以用来发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送一条持久化的消息 hello world!</span></span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//mandatory参数可以更好的控制发送</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes) ; </span><br><span class="line"></span><br><span class="line"><span class="comment">//这条消息的投递模式（delivery mode）为2，消息会被持久化到服务器中</span></span><br><span class="line"><span class="comment">//消息的优先级设置为1，contentType为text/plain</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQPBasicProperties.Builder()</span><br><span class="line">                           .contentType(<span class="string">"text/plain"</span>)</span><br><span class="line">                           .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                           .priority(<span class="number">1</span>)</span><br><span class="line">                           .userld(<span class="string">"hidden"</span>)</span><br><span class="line">                           .build()), messageBodyBytes); </span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以设置消息的headers</span></span><br><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;String Object&gt;();</span><br><span class="line">headers.put(<span class="string">"localtion"</span>，<span class="string">"here"</span>);</span><br><span class="line">headers.put(<span class="string">"time"</span>, <span class="string">"today"</span>);</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                           .headers(headers)</span><br><span class="line">                           .build()), messageBodyBytes); </span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以带过期时间</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                           .expiration(<span class="string">"60000"</span>) </span><br><span class="line">                           .build()), messageBodyBytes);</span><br></pre></td></tr></table></figure><p>包括各种重载方法，有以下具体参数：</p><ul><li>exchange：交换器的名称，指明消息需要发送到哪个交换器中，如果设置为空字符串， 则消息会被发送到 RabbitMQ 默认的交换器中。 </li><li>routingKey：路由键，交换器根据路由键将消息存储到相应的队列之中 </li><li>props：消息的基本属性集，其包含 14 个属性成员，分别有 <code>contentType</code> 、<code>contentEncoding</code> 、 <code>headers(Map&lt;String, Object&gt;)</code> 、<code>deliveryMode</code> 、<code>priority</code> 、<code>correlationId</code> 、<code>replyTo</code> 、<code>expiration</code> 、<code>messageId</code> 、<code>timestamp</code> 、<code>type</code> 、<code>userId</code> 、<code>appId</code> 、<code>clusterId</code> </li><li>byte[] body：消息体，真正要发送的消息。</li><li>mandatory：为 true 时，且交换器无法根据自身的类型和路由键找到一个符合条件的队列，调用 <code>Basic.Return</code> 命令将消息返回给生产者。为 false 时，消息直接被丢弃。</li><li>immediate：为true时，若交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时， 该消息会通过 <code>Basic.Return</code> 返回至生产者。</li></ul><hr><h2 id="第四节-消费消息"><a href="#第四节-消费消息" class="headerlink" title="第四节 消费消息"></a><strong>第四节 消费消息</strong></h2><p>两种模式：</p><ul><li>推模式：采用 <code>Basic.Consume</code> 进行消费；</li><li>拉模式：采用 <code>Basic.Get</code> 进行消费。</li></ul><h3 id="4-1-推模式"><a href="#4-1-推模式" class="headerlink" title="4.1 推模式"></a>4.1 推模式</h3><p>通过持续订阅的方式消费消息，接收消息一般通过实现 <code>Consumer</code> 接口或者继承 <code>DefaultConsumer</code> 类来实现。不同的订阅采用不同的消费者标签（ConsumerTag）来区分彼此。</p><p>主要通过方法 <code>channel.basicConsume()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">      <span class="comment">//接收到消息之后进行显式 ack 操作 channel.basicAck 对于消费者很必要，防止消息不必要的消失</span></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">      channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">      channel.basicConsume(QUEUE_NAME, autoAck, <span class="string">"myConsumerTag"</span>,</span><br><span class="line">              <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                      String routingKey = envelope.getRoutingKey();</span><br><span class="line">                      String contentType = properties.getContentType();</span><br><span class="line">                      <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                      <span class="comment">// process the message components here ...</span></span><br><span class="line">                      channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>queue：队列的名称；</li><li>autoAck：设置是否自动确认。建议设成 false ，即不自动确认；</li><li>consumerTag：消费者标签，用来区分多个消费者；</li><li>noLocal 设置为 true 则表示不能将同一个 Connection 中生产者发送的消息传送给这个 Connection 中的消费者；</li><li>exclusive：设置是否排他 ；</li><li>arguments：设置消费者的其他参数；</li><li>callback：设置消费者的回调函数。用来处理 RabbitMQ 推送过来的消息，比如 DefaultConsumer 使用时需要客户端重写其中的方法。</li></ul><p>消费者客户端可以重写多种方法：</p><ul><li><code>handleDelivery()</code></li><li><code>handleConsumerOk()</code> ：会在其他方法之前调用，返回消费者标签。</li><li><code>handleCancelOk()</code> ：消费端可以在显式地取消订阅的时候调用。</li><li><code>handleCancel()</code> ：消费端可以在隐式地取消订阅的时候调用</li><li><code>handleShutdownSignal()</code> ：当 Channel 或者 Connection 关闭的时候会调用。</li><li><code>handleRecoverOk()</code></li></ul><p>通过 <code>channel.basicCancel()</code> 显式地取消一个消费者的订阅，先触发 <code>handleConsumerOk()</code> ，然后是 <code>handleDelivery()</code> ，最后是 <code>handleCancelOk()</code> 。</p><p>和生产者一样，消费者客户端同样需要考虑线程安全的问题。消费者客户端的这些 callback 会被分配到与 Channel 不同的线程池上，这意味着消费者客户端可以安全地调用这些阻塞方法，比如 <code>channel.queueDeclare</code> ， <code>channel.basicCancel</code> 等。 </p><p>每个 Channel 都拥有自己独立的线程。最常用的做法是一个 Channel 对应一个消费者， 也就是意味着消费者彼此之间没有任何关联。当然也可以在一个 Channel 中维持多个消费者， 但是要注意一个问题，如果 Channel 中的一个消费者一直在运行，那么其他消费者的 callback 会被“耽搁”。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png" alt></p><h3 id="4-2-拉模式"><a href="#4-2-拉模式" class="headerlink" title="4.2 拉模式"></a>4.2 拉模式</h3><p>通过 <code>channel.basicGet()</code> 可以单条的获取消息，当 autoAck 设置为false，需要用 <code>channel.basicAck()</code> 来确认消息已被成功接收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out,println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010158.png" alt></p><p><code>Basic.Consume</code> 将信道（Channel）置为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 <code>Basic.Qos</code> 的限制．如果只想从队列获得单条消息而不是持续订阅，建议还是使用 <code>Basic.Get</code> 进行消费．但是不能将 <code>Basic.Get</code> 放在一个循环里来代替 <code>Basic.Consume</code> ，这样做会严重影响 RabbitMQ 的性能．如果要实现高吞吐量，消费者理应使用 <code>Basic.Consume</code> 方法。</p><hr><h2 id="第五节-消费端的确认与拒绝"><a href="#第五节-消费端的确认与拒绝" class="headerlink" title="第五节 消费端的确认与拒绝"></a><strong>第五节 消费端的确认与拒绝</strong></h2><p>为了保证消息从队列可靠地达到消费者， RabbitMQ 提供了消息确认机制 （message acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false 时， RabbitMQ 会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。当 autoAck 等于 true 时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息。</p><p>采用消息确认机制后，只要设置 autoAck 参数为 false ，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题 因为 RabbitMQ 会一直等待持有消息直到消费者显式调 <code>Basic.Ack</code> 命令为止。</p><p>当 autoAck 参数置为 false ，对于 RabbitMQ 服务端而言，队列中的消息分成了两个部分：一部分是等待投递给消费者的消息；一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p><p>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。 </p><p>RabbtiMQ 的 Web 管理平台上可以看到当前队列中的“Ready ”状态 和“Unacknowledged ＂状态的消息数，分别对应上文中的等待投递给消费者的消息数和己经投递给消费者但是未收到确认信号的消息数：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010159.png" alt></p><p>也可以通过相应的命令来查看上述信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_queues name message_ready messages_unacknowledged</span></span><br><span class="line">Listing queues ...</span><br><span class="line">queue         1   0</span><br><span class="line">queue_demo    0</span><br></pre></td></tr></table></figure><p>在消费者接收到消息后，如果想明确拒绝当前的消息而不是确认，那么应该怎么做呢？通过 <code>Basic.Reject</code> 这个命令，消费者客户端可以调用与其对应的 <code>channel.basicReject</code> 方法来告诉 RabbitMQ 拒绝这个消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>deliveryTag：消息编号，64位的长整型值。</li><li>requeue：当为true时，RabbitMQ会重新将此条消息存入队列，以便可以发送给下一个订阅的消费者；当为false时，立即将消息从队列中移除。</li></ul><p>批量拒绝消息需要 <code>Basic.Nack</code> ，客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>multiple：为false时，表示拒绝单条消息；为true时，拒绝编号前所有未被消费者确认的消息。</li></ul><p><code>channel.basicRecover()</code> 请求RabbitMQ重新发送还未被确认的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Basic.<span class="function">RecoverOk <span class="title">basicRecover</span><span class="params">(<span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>requeue：为true，未被确认的消息会被重新加入到队列，可能会被分配给另外一个消费者；为false，同一条消息会被分配给之前相同的消费者。</li></ul><hr><h2 id="第六节-关闭连接"><a href="#第六节-关闭连接" class="headerlink" title="第六节 关闭连接"></a><strong>第六节 关闭连接</strong></h2><p>在应用程序使用完之后，需要关闭连接，释放资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>在 Connection 关闭的时候， Channel 也会自动关闭。</p><p>Connection Channel 所具备的生命周期如下所述：</p><ul><li>Open：开启状态，代表当前对象可以使用。 </li><li>Closing：正在关闭状态。当前对象被显式地通知调用关闭方法（shutdown），这样就产生了一个关闭请求让其内部对象进行操作并等待这些关闭操作的完成。 </li><li>Closed：已经关闭状态。当前对象己经接收到所有的内部对象己完成关闭动作的通知，并且其也关闭了自身。</li></ul><p>当 Connection 或者 Channel 的状态转变为 Closed 的时候会调用  <code>ShutdownListener</code> 。而且如果将一个 <code>ShutdownListener</code> 注册到一个己经处于 Closed 状态的对象（这里特指 Connection 和 Channel 对象），会立刻调用  <code>ShutdownListener</code> 。</p><p><code>getCloseReason</code> 方法可以让你知道对象关闭的原因 <code>isOpen</code> 方法检测对象当前是否处于开启状态： <code>close(int closeCode , String closeMessage)</code> 方法显式地通知当前对象执行关闭操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.addShutdownListener(<span class="keyword">new</span> ShutdownListener()&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownCompleted</span><span class="params">(ShutdownSignalException cause)</span></span>&#123;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>当触发 ShutdownListener 的时候，就可以获取到 ShutdownSignalException ，这个 ShutdownSignalException 包含了关闭的原因，可以通过<code>getCloseReason</code> 方法获取。 <code>isHardError</code> 方法 可以知道是 <code>Connection</code> 的还是 <code>Channel</code> 的错误； <code>getReason</code> 方法可以获取 cause 相关的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownCompleted</span><span class="params">(ShutdownSignal cause)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(cause.isHardError())&#123;</span><br><span class="line">           Connection conn = (Connection) cause.getReference();</span><br><span class="line">           <span class="keyword">if</span>(!cause.isInitiatedByApplication())&#123;</span><br><span class="line">               Method reason = cause.getReason();</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Channel ch = (Channel) cause.getReference();</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第二章《客户端开发》，内容来自于《RabbitMQ实战指南》，内容包括：连接RabbitMQ，使用交换器和队列，发送消息，消费消息，消费端的确认与拒绝，关闭连接。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（一）简介和入门</title>
    <link href="http://linyishui.top/2020091901.html"/>
    <id>http://linyishui.top/2020091901.html</id>
    <published>2020-09-19T04:30:19.000Z</published>
    <updated>2020-10-09T02:25:21.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（一）简介和入门"><a href="#RabbitMQ（一）简介和入门" class="headerlink" title="RabbitMQ（一）简介和入门"></a><strong>RabbitMQ（一）简介和入门</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a><strong>1.1 什么是消息中间件</strong></h3><p><strong>消息</strong>指在应用间传送的数据。可以只包含字符串、JSON等，也可以包括内嵌对象。</p><p><strong>消息队列中间件</strong>（Message Queue Middleware，即MQ）指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。<strong>通过消息传递和消息排队模型，可以在分布式环境下扩展进程间通信</strong>。</p><p>两种传递模式：</p><ul><li><strong>点对点模式</strong>（P2P）：基于队列，消息生产者发送消息到队列，消息消费者从队列接受消息。队列使消息的<strong>异步传输</strong>成为可能。</li><li><strong>发布/订阅模式</strong>（Pub/Sub）：订阅了如何向一个内容节点发布和订阅消息，内容节点被称为<strong>主题</strong>（topic），可以看作是消息传递的中介，消息发布者将消息发布到某个主题，订阅者从主题订阅消息。主题使发布者和订阅者相互独立，可以在消息的<strong>一对多广播</strong>时采用。</li></ul><p>消息中间件提供了基于存储和转发的应用程序之间的异步数据发生，即应用程序间不直接通信，而是作为中介的消息中间件通信。消息中间件封装了远程过程调用（RPC）和网络通信协议的细节。</p><h3 id="1-2-常见的消息中间件"><a href="#1-2-常见的消息中间件" class="headerlink" title="1.2 常见的消息中间件"></a><strong>1.2 常见的消息中间件</strong></h3><p>常见的几款开源消息中间件：</p><ul><li>RabbitMQ：基于AMQP协议，主流消息中间件之一，适合数据量没那么大的项目；</li><li>Kafka：诞生于LinkedIn公司，吞吐量大，可用性高，常用于大数据领域。</li><li>ActiveMQ：Apache老牌消息引擎；</li><li>RocketMQ：阿里巴巴开源产品，Java实现，参考了Kafka的设计，可用性和吞吐量很高，适合于电商和金融互联网场景。</li><li>Apollo：Apache的ActiveMQ子项目。</li></ul><h3 id="1-3-消息中间件的作用"><a href="#1-3-消息中间件的作用" class="headerlink" title="1.3 消息中间件的作用"></a><strong>1.3 消息中间件的作用</strong></h3><ul><li><strong>解耦</strong>：只要遵守同样的接口约束，我们可以独立的扩展和修改通信两端的处理过程。</li><li><strong>冗余（存储）</strong>：消息中间件可以把数据进行持久化直到被完全处理，可以规避数据丢失的风险。即消息在被从中间件删除前，需要处理系统明确的指出此消息已被处理完成。</li><li><strong>扩展性</strong>：因为解耦了应用的处理过程，所以提高消息的入队和处理效率很容易，只须增加处理过程，不需改动代码也不需调节参数。</li><li><strong>削峰</strong>：访问量剧增时，这种情况不一定是常态，如果以此为标准投入资源无疑是巨大的浪费。消息中间件可以使关键组件支撑突发访问压力，不会因为突发的超负荷请求而崩溃。</li><li><strong>可恢复性</strong>：消息中间件降低了进程间的耦合度，即使一个处理消息的进程挂掉，消息仍可以等到系统恢复后进行处理。</li><li><strong>顺序保证</strong>：大部分消息中间件支持一定程度上的数据处理的顺序性。</li><li><strong>缓冲</strong>：消息中间件通过一个缓冲层帮助任务以最高效率执行，有助于控制和优化数据流经过系统的速度。</li><li><strong>异步通信</strong>：有时应用不想也不需要立即处理消息，消息中间件提供了异步处理机制，应用可以放入一些消息但不立即处理。</li></ul><h3 id="1-4-RabbitMQ的发展历程"><a href="#1-4-RabbitMQ的发展历程" class="headerlink" title="1.4 RabbitMQ的发展历程"></a><strong>1.4 RabbitMQ的发展历程</strong></h3><p>RabbitMQ基于 Erlang 语言实现 <strong>AMQP</strong>（Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，起源于金融系统，用于在分布式系统中存储转发消息。</p><p>之前，商业的消息中间件如微软的MSMQ、IBM的WebSphere等没有创建标准来实现MQ产品的互通或允许应用自定义MQ平台。<strong>JMS</strong>（Java Message Service）应运而生，<strong>试图通过提供公共Java API的方式隐藏单独MQ产品的实际接口，来解决互通问题</strong>。<strong>ActiveMQ</strong>就是基于JMS的一种实现，但这种使用单独标准化接口来胶合不同的接口最终还是会暴露问题，所以业内需要一种新的消息通信标准化方案。</p><p>2006年6月，Cisco、Redhat、iMatix等联合制定了AMQP标准，它是应用层协议的一个开放标准，来解决众多消息中间件的需求和拓扑结构问题。<strong>面向消息的中间件设计，基于此协议的客户端和消息中间件可以传递消息，不受产品、开发语言的限制。</strong></p><p>RabbitMQ早期即实现了AMQP的一个特性：使用协议本身就可以对队列和交换器这样的资源进行配置。而商业MQ进行资源配置需要管理终端的特定工具。</p><h3 id="1-5-RabbitMQ的特点"><a href="#1-5-RabbitMQ的特点" class="headerlink" title="1.5 RabbitMQ的特点"></a><strong>1.5 RabbitMQ的特点</strong></h3><ul><li><strong>可靠性</strong>：通过如持久化、传输确认及发布确认等保障可靠性。</li><li><strong>灵活路由</strong>：消息进入队列前，通过交换器来路由消息。基本的路由功能由内置的交换器来实现，复杂的路由功能可以绑定多个路由器实现，也可以通过插件机制实现自定义的交换器。</li><li><strong>扩展性</strong>：多个RabbitMQ节点可以组成集群，可以根据实际业务情况动态扩展节点。</li><li><strong>高可用性</strong>：队列可以在集群的机器上设置镜像，在部分节点出现问题时仍能使用队列。</li><li><strong>多种协议</strong>：除了原生AMQP协议，还支持STOMP、MQTT等多种消息中间件协议。</li><li><strong>多语言客户端</strong>：支持几乎所有常用语言，如Java、Python、Ruby、PHP、C#、JavaScript等。</li><li><strong>管理界面</strong>：提供了一个易用的用户界面，可以监控和管理消息、集群中的节点等。</li><li><strong>插件机制</strong>：提供了许多插件，可以进行扩展，也可以自定义插件。</li></ul><hr><h2 id="第二节-RabbitMQ的安装和简单使用"><a href="#第二节-RabbitMQ的安装和简单使用" class="headerlink" title="第二节 RabbitMQ的安装和简单使用"></a><strong>第二节 RabbitMQ的安装和简单使用</strong></h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a><strong>2.1 安装</strong></h3><p>首先要安装Erlang，官网地址：<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">Erlang-Download</a> 。以下基于Linux操作系统安装。</p><h4 id="（1）安装Erlang"><a href="#（1）安装Erlang" class="headerlink" title="（1）安装Erlang"></a><strong>（1）安装Erlang</strong></h4><p>创建安装目录 <code>/opt/erlang</code> ，并下载安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# cd /opt</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# ls</span><br><span class="line">containerd  gitlab</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# mkdir /erlang</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# cd /erlang</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# wget http://erlang.org/download/otp_src_23.0.tar.gz</span><br><span class="line">--2020-09-21 16:20:16--  http://erlang.org/download/otp_src_23.0.tar.gz</span><br><span class="line">Resolving erlang.org (erlang.org)... 192.121.151.106</span><br><span class="line">Connecting to erlang.org (erlang.org)|192.121.151.106|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 88865562 (85M) [application/gzip]</span><br><span class="line">Saving to: ‘otp_src_23.0.tar.gz’</span><br><span class="line"></span><br><span class="line"><span class="meta"> 2%</span><span class="bash"> [=&gt;                                                                                                                   ] 1,907,973   6.64KB/s  eta 2h 40m</span></span><br></pre></td></tr></table></figure><p>官网下载速度太慢，访问 <a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="noopener">RabbitMQ - Erlang</a> 选择对应服务器，复制下载地址：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010154.png" alt></p><p>先删除未下载完成的文件，重新下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">otp_src_23.0.tar.gz</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rm -f otp_src_23.0.tar.gz</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# wget https://packages.erlang-solutions.com/erlang/rpm/centos/7/x86_64/esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">--2020-09-21 16:37:11--  https://packages.erlang-solutions.com/erlang/rpm/centos/7/x86_64/esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">Resolving packages.erlang-solutions.com (packages.erlang-solutions.com)... 13.227.21.48, 13.227.21.118, 13.227.21.90, ...</span><br><span class="line">Connecting to packages.erlang-solutions.com (packages.erlang-solutions.com)|13.227.21.48|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 43642720 (42M) [application/x-rpm]</span><br><span class="line">Saving to: ‘esl-erlang_23.0.3-1~centos~7_amd64.rpm’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[====================================================================================================================&gt;] 43,642,720  23.1KB/s   <span class="keyword">in</span> 24m 34s</span></span><br><span class="line"></span><br><span class="line">2020-09-21 17:01:49 (28.9 KB/s) - ‘esl-erlang_23.0.3-1~centos~7_amd64.rpm’ saved [43642720/43642720]</span><br></pre></td></tr></table></figure><p>通过 <code>yum install</code> 安装程序：（会安装到默认目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# yum install esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Examining esl-erlang_23.0.3-1~centos~7_amd64.rpm: esl-erlang-23.0.3-1.x86_64</span><br><span class="line">Marking esl-erlang_23.0.3-1~centos~7_amd64.rpm to be installed</span><br><span class="line">Resolving Dependencies</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package esl-erlang.x86_64 0:23.0.3-1 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libodbc.so.2()(64bit) <span class="keyword">for</span> package: esl-erlang-23.0.3-1.x86_64</span></span><br><span class="line">Determining fastest mirrors</span><br><span class="line">base                                                                                                                                   | 3.6 kB  00:00:00     </span><br><span class="line">docker-ce-stable                                                                                                                       | 3.5 kB  00:00:00     </span><br><span class="line">epel                                                                                                                                   | 4.7 kB  00:00:00</span><br><span class="line">......</span><br><span class="line">gitlab_gitlab-ee/x86_64/primary                                                                                                        | 2.6 MB  00:00:06     </span><br><span class="line">gitlab_gitlab-ee                                                                                                                                      623/623</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Total size: 107 M</span><br><span class="line">Total download size: 462 k</span><br><span class="line">Installed size: 107 M</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过rpm查看软件是否安装</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -qa | grep erlang</span><br><span class="line">esl-erlang-23.0.3-1.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看软件安装目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -ql esl-erlang-23.0.3-1.x86_64</span><br><span class="line">/usr/bin/cpu_sup</span><br><span class="line">/usr/bin/ct_run</span><br><span class="line">/usr/bin/dialyzer</span><br><span class="line">/usr/bin/epmd</span><br><span class="line">/usr/bin/erl</span><br><span class="line">/usr/bin/erl_call</span><br><span class="line">/usr/bin/erlc</span><br><span class="line">/usr/bin/escript</span><br><span class="line">/usr/bin/etop</span><br><span class="line">/usr/bin/getop</span><br><span class="line">/usr/bin/heart</span><br><span class="line">/usr/bin/memsup</span><br><span class="line">/usr/bin/run_erl</span><br><span class="line">/usr/bin/run_test</span><br><span class="line">/usr/bin/start_erl</span><br><span class="line">/usr/bin/start_webtool</span><br><span class="line">/usr/bin/to_erl</span><br><span class="line">/usr/bin/typer</span><br><span class="line">/usr/lib/erlang/COPYRIGHT</span><br><span class="line">/usr/lib/erlang/Install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者直接查看目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -qal | grep erlang</span><br></pre></td></tr></table></figure><p>若出现报错：No curses library functions found 。需要安装 ncurses：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ncurses-devel</span><br></pre></td></tr></table></figure><p>若继续出现如 No XXXXX found 的提示，可以自行安装对应包，之后再次尝试安装Erlang直到提示安装完毕。</p><p>修改 <code>/etc/profile</code> 配置文件，添加如下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# cd /</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# vi /etc/profile</span><br><span class="line"></span><br><span class="line">export ERLANG_HOME=/usr/lib/erlang</span><br><span class="line">export PATH=$PATH:/usr/bin</span><br></pre></td></tr></table></figure><p>修改完，执行如下命令使配置文件生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# source /etc/profile</span><br></pre></td></tr></table></figure><p>通过 <code>erl</code> 命令验证是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# erl -version</span><br><span class="line">Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 11.0.3</span><br></pre></td></tr></table></figure><h4 id="（2）安装RabbitMQ"><a href="#（2）安装RabbitMQ" class="headerlink" title="（2）安装RabbitMQ"></a><strong>（2）安装RabbitMQ</strong></h4><p>首先下载安装包，官网地址：<a href="http://www.rabbitmq.com/releases/rabbitmq-server/" target="_blank" rel="noopener">RabbitMQ</a> 。</p><p>然后可以将RabbitMQ和Erlang安装在同一目录（/opt）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">--2020-09-21 17:39:13--  https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">Resolving www.rabbitmq.com (www.rabbitmq.com)... 104.20.11.224, 172.67.16.25, 104.20.10.224, ...</span><br><span class="line">Connecting to www.rabbitmq.com (www.rabbitmq.com)|104.20.11.224|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 5075721 (4.8M) [application/x-redhat-package-manager]</span><br><span class="line">Saving to: ‘rabbitmq-server-3.6.15-1.el7.noarch.rpm’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[====================================================================================================================&gt;] 5,075,721   1.73MB/s   <span class="keyword">in</span> 2.8s   </span></span><br><span class="line"></span><br><span class="line">2020-09-21 17:39:18 (1.73 MB/s) - ‘rabbitmq-server-3.6.15-1.el7.noarch.rpm’ saved [5075721/5075721]</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# ls</span><br><span class="line">rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# yum install rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过rpm查看软件是否安装</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rpm -qa | grep rabbitmq</span><br><span class="line">rabbitmq-server-3.6.15-1.el7.noarch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看软件安装目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rpm -ql rabbitmq-server-3.6.15-1.el7.noarch</span><br><span class="line">/etc/logrotate.d/rabbitmq-server</span><br><span class="line">/etc/rabbitmq</span><br><span class="line">/usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server</span><br><span class="line">/usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server-ha</span><br><span class="line">......</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmq-plugins</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmq-server</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmqctl</span><br><span class="line">/usr/lib/systemd/system/rabbitmq-server.service</span><br><span class="line">/usr/lib/tmpfiles.d/rabbitmq-server.conf</span><br><span class="line">/usr/sbin/rabbitmq-plugins</span><br><span class="line">/usr/sbin/rabbitmq-server</span><br><span class="line">/usr/sbin/rabbitmqctl</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>同样修改 <code>/etc/profile</code> 文件，添加如下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# vi /etc/profile</span><br><span class="line"></span><br><span class="line">export RABBITMQ_HOME=/usr/lib/rabbitmq</span><br><span class="line">export PATH=$PATH:/usr/sbin</span><br></pre></td></tr></table></figure><p>同样使配置文件生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="（3）卸载"><a href="#（3）卸载" class="headerlink" title="（3）卸载"></a><strong>（3）卸载</strong></h4><p>卸载前先停掉rabbitmq服务，执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service rabbitmq-server stop</span></span><br></pre></td></tr></table></figure><p>查看rabbitmq安装的相关列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum list | grep rabbitmq</span></span><br></pre></td></tr></table></figure><p>卸载rabbitmq已安装的相关内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove rabbitmq-server.noarch</span></span><br></pre></td></tr></table></figure><p>查看erlang安装的相关列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum list | grep erlang</span></span><br></pre></td></tr></table></figure><p>卸载erlang已安装的相关内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove erlang-*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove erlang.x86_64</span></span><br></pre></td></tr></table></figure><h3 id="2-2-运行"><a href="#2-2-运行" class="headerlink" title="2.2 运行"></a><strong>2.2 运行</strong></h3><p>任意开启Shell，运行RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> detached参数使RabbitMQ以守护进程的方式在后台运行，不会因为Shell的关闭而影响服务</span></span><br><span class="line">rabbitmq-server -detached</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看RabbitMQ是否正常启动</span></span><br><span class="line">rabbitmqctl status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群信息，当前只有一个节点</span></span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p>运行失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmq-server -detached</span><br><span class="line">Warning: PID file not written; -detached was passed.</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmqctl status</span><br><span class="line">Status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Error: unable to connect to node rabbit@iZ2zeet6kto8eqx1w7sluzZ: nodedown</span><br><span class="line"></span><br><span class="line">DIAGNOSTICS</span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">attempted to contact: [rabbit@iZ2zeet6kto8eqx1w7sluzZ]</span><br><span class="line"></span><br><span class="line">rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">  * connected to epmd (port 4369) on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">  * epmd reports: node 'rabbit' not running at all</span><br><span class="line">                  no other nodes on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">  * suggestion: start the node</span><br><span class="line"></span><br><span class="line">current node details:</span><br><span class="line">- node name: 'rabbitmq-cli-57@iZ2zeet6kto8eqx1w7sluzZ'</span><br><span class="line">- home dir: /var/lib/rabbitmq</span><br><span class="line">- cookie hash: 63rISb5yZX97fhoF8LdjSg==</span><br></pre></td></tr></table></figure><p>首先排除是否是防火墙的问题：（不是这个原因）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙开放端口</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# firewall-cmd --zone=public --list-ports</span><br><span class="line">8025/tcp 6725/tcp</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# systemctl stop firewalld.service</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# service rabbitmq-server start</span><br><span class="line">Redirecting to /bin/systemctl start rabbitmq-server.service</span><br><span class="line">Job for rabbitmq-server.service failed because the control process exited with error code. See "systemctl status rabbitmq-server.service" and "journalctl -xe" for details.</span><br></pre></td></tr></table></figure><p>删除 <code>/var/lib/rabbitmq/mnesia</code> 目录下的文件，再重启：（不是这个原因）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# cd /var/lib/rabbitmq/mnesia</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# ls -AF</span><br><span class="line">rabbit@iZ2zeet6kto8eqx1w7sluzZ.pid</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# rm -rf rabbit@iZ2zeet6kto8eqx1w7sluzZ.pid</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# service rabbitmq-server start</span><br><span class="line">Redirecting to /bin/systemctl start rabbitmq-server.service</span><br><span class="line">Job for rabbitmq-server.service failed because the control process exited with error code. See "systemctl status rabbitmq-server.service" and "journalctl -xe" for details.</span><br></pre></td></tr></table></figure><p>查看详细错误信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# systemctl status rabbitmq-server.service</span><br><span class="line">● rabbitmq-server.service - RabbitMQ broker</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since Tue 2020-09-22 10:19:51 CST; 3s ago</span><br><span class="line">  Process: 27630 ExecStop=/bin/sh -c while ps -p $MAINPID &gt;/dev/null 2&gt;&amp;1; do sleep 1; done (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 27488 ExecStop=/usr/sbin/rabbitmqctl stop (code=exited, status=0/SUCCESS)</span><br><span class="line"><span class="meta">  #</span><span class="bash"> rabbitmq-server启动失败</span></span><br><span class="line">  Process: 27187 ExecStart=/usr/sbin/rabbitmq-server (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 27187 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Failed to start RabbitMQ broker.</span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Unit rabbitmq-server.service entered failed state.</span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service failed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# journalctl -xe</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: Stack trace:</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: []</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: &#123;"init terminating in do_boot",noproc&#125;</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: init terminating in do_boot (noproc)</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: Crash dump is being written to: erl_crash.dump...done</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service: main process exited, code=exited, status=1/FAILURE</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: Stopping and halting node rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: Error: unable to connect to node rabbit@iZ2zeet6kto8eqx1w7sluzZ: nodedown</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: DIAGNOSTICS</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: ===========</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: attempted to contact: [rabbit@iZ2zeet6kto8eqx1w7sluzZ]</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * connected to epmd (port 4369) on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * epmd reports: node 'rabbit' not running at all</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: no other nodes on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * suggestion: start the node</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: current node details:</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - node name: 'rabbitmq-cli-55@iZ2zeet6kto8eqx1w7sluzZ'</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - home dir: .</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - cookie hash: 63rISb5yZX97fhoF8LdjSg==</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Failed to start RabbitMQ broker.</span><br><span class="line">-- Subject: Unit rabbitmq-server.service has failed</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">-- </span><br><span class="line">-- Unit rabbitmq-server.service has failed.</span><br><span class="line">-- </span><br><span class="line">-- The result is failed.</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Unit rabbitmq-server.service entered failed state.</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service failed.</span><br><span class="line">lines 1389-1419/1419 (END)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 尝试重启</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ sbin]# rabbitmq-server restart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOT FAILED</span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">Error description:</span><br><span class="line">   noproc</span><br><span class="line"></span><br><span class="line">Log files (may contain more information):</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line"></span><br><span class="line">Stack trace:</span><br><span class="line">   []</span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 22-Sep-2020::20:41:05.655469 ===</span><br><span class="line">Error description:</span><br><span class="line">   noproc</span><br><span class="line"></span><br><span class="line">Log files (may contain more information):</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line"></span><br><span class="line">Stack trace:</span><br><span class="line">   []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;"init terminating in do_boot",noproc&#125;</span><br><span class="line">init terminating in do_boot (noproc)</span><br><span class="line"></span><br><span class="line">Crash dump is being written to: erl_crash.dump...done</span><br></pre></td></tr></table></figure><p>根据提示 <code>noproc</code> 考虑是否是版本不匹配，<a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">rabbitmq - erlang</a> 官网查询确认是否匹配：</p><ul><li>Erlang：23.0.3</li><li>RabbitMQ：3.6.15</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010155.png" alt></p><p>卸载当前RabbitMQ，再重新下载一个3.8.8版本的RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>阿里云服务器下载GitHub实在是太慢了，选择用Docker拉取镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# service docker restart</span><br><span class="line">Redirecting to /bin/systemctl restart docker.service</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management</span><br><span class="line">Unable to find image 'rabbitmq:3-management' locally</span><br><span class="line">3-management: Pulling from library/rabbitmq</span><br><span class="line">5d9821c94847: Downloading [=======================&gt;                           ]  12.53MB/26.7MB</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>仍然很慢，还是直接下载RPM文件，加上断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>下载成功后，重新安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# ls -AF</span><br><span class="line">rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# yum install rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>重新启动：(终于成功)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmq-server -detached</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl status</span><br><span class="line">Status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">Runtime</span><br><span class="line"></span><br><span class="line">OS PID: 4074</span><br><span class="line">OS: Linux</span><br><span class="line">Uptime (seconds): 89</span><br><span class="line">Is under maintenance?: false</span><br><span class="line">RabbitMQ version: 3.8.8</span><br><span class="line">Node name: rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Erlang configuration: Erlang/OTP 23 [erts-11.0.3] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:64] [hipe]</span><br><span class="line">Erlang processes: 275 used, 1048576 limit</span><br><span class="line">Scheduler run queue: 1</span><br><span class="line">Cluster heartbeat timeout (net_ticktime): 60</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群状态</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="2-3-生产和消费消息"><a href="#2-3-生产和消费消息" class="headerlink" title="2.3 生产和消费消息"></a><strong>2.3 生产和消费消息</strong></h3><p>RabbitMQ的默认用户名和密码都是 <code>guest</code>，此账户只能本地访问，远程网络访问会受限，所以我们要首先<strong>添加一个用户</strong>，并<strong>设置访问权限</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新增用户</span></span><br><span class="line">rabbitmqctl add_user root root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置所有权限</span></span><br><span class="line">rabbitmqctl set_permissions -p / root ".*" ".*" ".*"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置管理员角色</span></span><br><span class="line">rabbitmqctl set_user_tags root administrator</span><br></pre></td></tr></table></figure><p>若在使用RabbitMQ的过程中有 <code>com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN</code> 类似报错，很可能就是账户的问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. <span class="keyword">For</span> details see the broker logfile.</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">ERROR</span> com.rabbitmq.client.impl.ForgivingExceptionHandler - An unexpected<span class="built_in"> connection </span>driver <span class="builtin-name">error</span> occured</span><br><span class="line">java.net.SocketException: Socket Closed</span><br></pre></td></tr></table></figure><p>在Java项目中引入RabbitMQ客户端的Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建消息生产者，发送一条消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitProducer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY = <span class="string">"routingkey_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"queue_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"xxx.xxx.xxx.xxx"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">                TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">                ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">                factory.setHost(IP_ADDRESS);</span><br><span class="line">                factory.setPort(PORT);</span><br><span class="line">                factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">                factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">                Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">                Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">                <span class="comment">// 创建一个 type direct 、持久化的、非自动删除的交换器</span></span><br><span class="line">                channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//创建一个持久化、非排他的、非自动删除的队列</span></span><br><span class="line">                channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//将交换器与队列通过路由键绑定</span></span><br><span class="line">                channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line">                <span class="comment">//发送一条持久化的消息 hello world !</span></span><br><span class="line">                String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY,</span><br><span class="line">                        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                        message.getBytes());</span><br><span class="line">                <span class="comment">//关闭资源</span></span><br><span class="line">                channel.close();</span><br><span class="line">                connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"queue_demo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"xxx.xxx.xxx.xxx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里的连接方式与生产者的 demo 略有不同，注意辨别区别</span></span><br><span class="line">        Connection connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">        channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"recv message : "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, consumer);</span><br><span class="line">        <span class="comment">//等待回调函数执行完毕之后 关闭资源</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recv message : <span class="type">Hello</span> World!</span><br></pre></td></tr></table></figure><p>此处采用继承 <code>DefaultConsumer</code> 的方式来实现消费，也可以使用 <code>QueueingConsumer</code> 来实现，但会有些隐患，并且这种实现已被废弃。</p><hr><h2 id="第三节-Rabbit入门"><a href="#第三节-Rabbit入门" class="headerlink" title="第三节 Rabbit入门"></a><strong>第三节 Rabbit入门</strong></h2><p>RabbitMQ的模型架构是什么？AMQP协议是什么？两者间又有何种联系？消息从生产者发出到消费者消费的过程要经历什么？</p><h3 id="3-1-RabbitMQ基本概念"><a href="#3-1-RabbitMQ基本概念" class="headerlink" title="3.1 RabbitMQ基本概念"></a><strong>3.1 RabbitMQ基本概念</strong></h3><h4 id="（1）生产者和消费者模型"><a href="#（1）生产者和消费者模型" class="headerlink" title="（1）生产者和消费者模型"></a><strong>（1）生产者和消费者模型</strong></h4><p>RabbitMQ 整体上是一个<strong>生产者与消费者模型</strong>，主要<strong>负责接收、存储和转发消息</strong>。可以把消息传递的过程想象成当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。</p><p>从计算机术语层面来说， RabbitMQ模型更像是一种<strong>交换机模型</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010143.png" alt></p><p>消息一般包含2个部分：</p><ul><li><strong>消息体</strong>：消息体也可以称之为 payload ，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个 JSON 字符串。当然可以进一步对这个消息体进行序列化操作。</li><li><strong>标签</strong>（Label）：用来表述这条消息，比如一个交换器的名称和一个路由键。</li></ul><p>大致流程：</p><ul><li><strong>生产者（Producer）</strong>将业务数据封装（序列化）成消息（指定Exchange和RoutingKey等），把消息交由RabbitMQ，即发送给Broker （AMQP协议中对应命令为Basic.Publish）。</li><li><strong>Broker （消息中间件的服务节点）</strong>，大多数情况下可以将 RabbitMQ Broker 看作一台 RabbitMQ 服务器。RabbitMQ之后会根据标签把消息发送给感兴趣的<strong>消费者（Consumer）</strong>。</li><li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。当消费者消费一条消息时，<strong>只是消费消息的消息体</strong>（ payload ）。在消息路由的过程中，消息的标签会丢弃，<strong>存入到队列中的消息只有消息体</strong>，消费者也只会消费到消息体，也就<strong>不知道消息的生产者是谁</strong>，当然消费者也不需要知道。</li><li>消费者受到消息体后（AMQP协议中对应命令为Basic.Consume或Basic.Get）进行反序列化，得到对应的业务数据，并进行业务处理。</li></ul><p>消费者进行业务处理可以不和接收消息的逻辑使用同一线程，比如使用一个线程去接收消息存入内存（<code>BlockingQueue</code>），使用另一个线程从内存读取数据，这样可以进一步解耦，提高整体处理效率。 </p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010144.png" alt></p><h4 id="（2）队列"><a href="#（2）队列" class="headerlink" title="（2）队列"></a><strong>（2）队列</strong></h4><p><strong>队列</strong>（Queue）是 RabbitMQ 的内部对象，用来<strong>存储消息</strong>。<strong>消息只能存储在队列中</strong>，这与Kafka这种消息中间件相反（<strong>Kafka消息存储在主题topic逻辑层面</strong>），相对应的队列逻辑只是主题实际存储文件中的位移标识。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010145.png" alt></p><p>多个消费者可以订阅同一个队列，队列中的消息会被<strong>平均分摊</strong>（Round-Robin，即轮询）给多个消费者处理，<strong>不是每个消费者都收到所有的消息并处理</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010146.png" alt></p><p>RabbitMQ<strong>不支持队列层面的广播消费</strong>，如果需要只能进行二次开发。</p><h4 id="（3）交换器、路由键、绑定、交换器类型"><a href="#（3）交换器、路由键、绑定、交换器类型" class="headerlink" title="（3）交换器、路由键、绑定、交换器类型"></a><strong>（3）交换器、路由键、绑定、交换器类型</strong></h4><p>上面我们理解为生产者将消息直接投递到队列上，但其实并非如此。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010147.png" alt></p><p><strong>交换器</strong>（Exchange），生产者会先将消息发送到交换器，交换器负责将消息路由到一个或多个队列中。若路由不到，可以返回给生产者或直接丢弃。</p><p><strong>路由键</strong>（RoutingKey），生产者将消息发给交换器时，会指定一个路由键，用来指定消息的路由规则，可以决定消息流向哪里。路由键需要与<strong>交换器类型</strong>和<strong>绑定键</strong>（BindingKey）联合使用。</p><p><strong>绑定键</strong>（BindingKey），属于路由键的一种，通过绑定键将交换器和队列关联起来。<strong>某些情形下绑定键与路由键可以看作同一个东西。</strong></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010148.png" alt></p><p>可以这样区别路由键和绑定键：</p><ul><li>使用绑定时，需要的路由键是 BindingKey 。<ul><li>涉及的客户端方法：<code>channel.exchangeBind</code> 、<code>channel.queueBind</code> </li><li>对应AMQP命令：<code>Exchange.Bind</code> 、<code>Queue.Bind</code> 。</li></ul></li><li>发送消息时，需要的路由键是 RoutingKey 。<ul><li>涉及的客户端方法：<code>channel.basicPublish</code> </li><li>对应AMQP命令：<code>Basic.Publish</code> </li></ul></li></ul><p><strong>交换器类型</strong>：</p><ul><li><p><strong>fanout</strong>：会把发送到该交换器的消息路由到所有绑定的队列中。</p></li><li><p><strong>direct</strong>：会把消息路由到BindingKey和RoutingKey完全匹配的队列中。</p><p>如下案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由键为warning，消息会路由到Queue1和Queue2</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">"warning"</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">message.getBytes());</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010149.png" alt></p><p>若设置路由键为“info”或“debug”，消息只会路由到Queue2。</p></li><li><p><strong>topic</strong>：在匹配规则上相比direct进行了扩展，也是把消息路由到BindingKey和RoutingKey匹配的队列中，但匹配规则包括：</p><ul><li>RoutingKey和BindingKey为 <code>.</code> 分隔的字符串，如 <code>com.rabbitmq.client</code> 。</li><li>BindingKey中可以存着两个特殊字符串 <code>*</code> 和 <code>#</code> ，用于模糊匹配，<code>*</code> 用于匹配一个单词，<code>#</code> 用于匹配多规格单词。</li></ul><p>如下案例：</p><ul><li>路由键 <code>com.rabbitmq.client</code> 的消息同时路由到Queue1和Queue2；</li><li>路由键 <code>com.hidden.client</code> 的消息只路由到Queue2；</li><li>路由键 <code>com.hidden.demo</code> 的消息只路由到Queue2；</li><li>路由键 <code>java.rabbitmq.demo</code> 的消息只路由到Queue1；</li><li>路由键 <code>java.util.concurrent</code> 的消息会被丢弃或返回给生产者；</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010150.png" alt></p></li><li><p><strong>headers</strong>：不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时会制定一组键值对，消息到交换器时也有键值对形式的headers，对比若完全匹配就路由到此队列。<strong>这一类型性能很差且不实用</strong>。</p></li></ul><h4 id="（4）RabbitMQ运转流程"><a href="#（4）RabbitMQ运转流程" class="headerlink" title="（4）RabbitMQ运转流程"></a><strong>（4）RabbitMQ运转流程</strong></h4><p>生产者发送消息（最初状态）：</p><ol><li>生产者连接到 RabbitMQ Broker 建立一个<strong>连接</strong>（Connection），开启一个<strong>信道</strong>（Channel） ；</li><li>生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等；</li><li>生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等；</li><li>生产者通过路由键将交换器和队列绑定起来；</li><li>生产者发送消息至 RabbitMQ Broker，其中包含路由键、交换器等信息；</li><li>相应的交换器根据接收到的路由键查找相匹配的队列；</li><li>如果找到，则将从生产者发送过来的消息存入相应的队列中。</li><li>如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者。</li><li>关闭信道。</li><li>关闭连接。 </li></ol><p>消费者接收消息的过程： </p><ol><li>消费者连接到 RabbitMQ Broker ，建立一个<strong>连接</strong>（Connection），开启一个<strong>信道</strong>（Channel)；</li><li>消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作。 </li><li>等待 RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。</li><li>消费者确认（ack）接收到的消息。</li><li>RabbitMQ 从队列中删除相应己经被确认的消息。</li><li>关闭信道。</li><li>关闭连接。</li></ol><h4 id="（5）连接和信道"><a href="#（5）连接和信道" class="headerlink" title="（5）连接和信道"></a><strong>（5）连接和信道</strong></h4><p><strong>连接</strong>（Connection），即一条TCP连接。当TCP连接建立起来，客户端紧接着创建一个AMQP<strong>信道</strong>（Channel)，每个信道都会被指派一个唯一的ID。信道是虚拟链接，<strong>RabbitMQ处理每条AMQP指令都是通过信道完成</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010151.png" alt></p><p><strong>信道的作用？</strong></p><p>一个应用程序会有很多线程需要从MQ中消费消息或生产消息，所以要建立很多TCP连接。对于操作系统而言，<strong>建立和销毁TCP连接都需要昂贵的开销</strong>，所以 RabbitMQ 采用类似 NIO（Non-blocking I/O）的做法，选择<strong>TCP连接复用</strong>，既减少性能开销也便于管理。</p><p><strong>每个线程持有一个信道，信道复用了TCP连接，而 RabbitMQ 还可以保证每个线程的私密性和持有独立的连接一样。</strong>当单个信道流量很大时，多个信道复用一个连接就会产生性能瓶颈，此时可以开辟多个连接并进行均摊。</p><h3 id="3-2-AMQP协议"><a href="#3-2-AMQP协议" class="headerlink" title="3.2 AMQP协议"></a><strong>3.2 AMQP协议</strong></h3><p>AMQP协议的模型架构和 RabbitMQ的模型架构一样：生产者将消息发送给交换器，交换器与队列绑定，当生产者发送消息时所携带的 RoutingKey 与绑定时的 BindingKey 相匹配时，消息即被存入相应的队列之中。消费者可以订阅相应的队列来获取消息。</p><p>AMQP协议包括三层：</p><ul><li><strong>Module Layer</strong>：位于协议<strong>最高层</strong>，主要定义了一些供客户端调用的命令，客户端可以利用这些命令实现自己的业务逻辑。例如客户端可以使用 <code>Queue.Declare</code> 命令声明一个队列或者使用 <code>Basic.Consume</code> 订阅消费一个队列中的消息。 </li><li><strong>Session Layer</strong>：位于<strong>中间层</strong>，主要负责将客户端的命令发送给服务器，再将服务端的应答返回给客户端，主要为客户端与服务器之间的通信提供可靠性同步机制和错误处理。</li><li><strong>Transport Layer</strong> ：位于<strong>最底层</strong>，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。</li></ul><p><strong>AMQP说到底还是一个通信协议，都会涉及到报文交互</strong>，从 low level 举例来说，AMQP <strong>本身是应用层的协议，其填充于 TCP 协议层的数据部分</strong>。而从 high-level 来说 AMQP 是通过协议命令进行交互的。AMQP 协议可以看作一系列结构化命令的集合，这里的命令代表一种操作，类似于 HTTP 中的方法（GET、POST、PUT、DELETE 等）。</p><h4 id="（1）AMQP生产者流转过程"><a href="#（1）AMQP生产者流转过程" class="headerlink" title="（1）AMQP生产者流转过程"></a><strong>（1）AMQP生产者流转过程</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"><span class="comment">// 创建一个 type direct 、持久化的、非自动删除的交换器</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//创建一个持久化、非排他的、非自动删除的队列</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//将交换器与队列通过路由键绑定</span></span><br><span class="line">channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line"><span class="comment">//发送一条持久化的消息 hello world !</span></span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        message.getBytes());</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010152.png" alt></p><h4 id="（2）AMQP消费者者流转过程"><a href="#（2）AMQP消费者者流转过程" class="headerlink" title="（2）AMQP消费者者流转过程"></a><strong>（2）AMQP消费者者流转过程</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的连接方式与生产者的 demo 略有不同，注意辨别区别</span></span><br><span class="line">        Connection connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">        channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"recv message : "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, consumer);</span><br><span class="line">        <span class="comment">//等待回调函数执行完毕之后 关闭资源</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png" alt></p><h4 id="（3）AMQP命令概览"><a href="#（3）AMQP命令概览" class="headerlink" title="（3）AMQP命令概览"></a><strong>（3）AMQP命令概览</strong></h4><p>AMQP命令：</p><table><thead><tr><th>名称</th><th>是否包含内容体</th><th>对应客户端中的方法</th><th>简要描述</th></tr></thead><tbody><tr><td>Connection.Start</td><td>否</td><td>factory.newConnection</td><td>建立连接相关</td></tr><tr><td>Connection.Start-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Tune</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Tune-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Open</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Open-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Close</td><td>否</td><td>connection.close</td><td>关闭连接</td></tr><tr><td>Connection.Close-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Channel.Open</td><td>否</td><td>connection.openChannel</td><td>开启信道</td></tr><tr><td>Channel.Open-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Channel.Close</td><td>否</td><td>channel.close</td><td>关闭信道</td></tr><tr><td>Channel.Close-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Declare</td><td>否</td><td>channel.exchangeDeclare</td><td>声明交换器</td></tr><tr><td>Exchange.Declare-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Delete</td><td>否</td><td>channel.exchangeDelete</td><td>删除交换器</td></tr><tr><td>Exchange.Delete-Ok</td><td>否</td><td>向上</td><td>同上</td></tr><tr><td>Exchange.Bind</td><td>否</td><td>channel.exchangeBind</td><td>交换器与交换器绑定</td></tr><tr><td>Exchange.Bind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Unbind</td><td>否</td><td>channel.exchangeUnbind</td><td>交换器与交换器解绑</td></tr><tr><td>Exchange.Unbind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Declare</td><td>否</td><td>channel.queueDeclare</td><td>声明队列</td></tr><tr><td>Queue.Declare-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Bind</td><td>否</td><td>channel.queueBind</td><td>队列与交换器绑定</td></tr><tr><td>Queue.Bind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Purge</td><td>否</td><td>channel.queuePurge</td><td>清除队列中的内容</td></tr><tr><td>Queue.Purge-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Delete</td><td>否</td><td>channel.queueDelete</td><td>删除队列</td></tr><tr><td>Queue.Delete-Ok</td><td>否</td><td>同上</td><td>向上</td></tr><tr><td>Queue.Unbind</td><td>否</td><td>channel.queueUnbind</td><td>队列与交换器解绑</td></tr><tr><td>Queue.Unbind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Qos</td><td>否</td><td>channel.basicQos</td><td>设置未被确认消费的个数</td></tr><tr><td>Basic.Qos-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Consume</td><td>否</td><td>channel.basicConsume</td><td>消费消息（推模式）</td></tr><tr><td>BasiιConsume-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Cancel</td><td>否</td><td>channel.basicCancel</td><td>取消</td></tr><tr><td>Basic.Cancel-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Publish</td><td>否</td><td>channel.basicPublish</td><td>发送消息</td></tr><tr><td>Basic.Return</td><td>否</td><td>无</td><td>未能成功路由的消息返回</td></tr><tr><td>Basic.Deliver</td><td>否</td><td>无</td><td>Broker 推送消息</td></tr><tr><td>Basic.Get</td><td>否</td><td>channel.basicGet</td><td>消费消息（拉模式〉</td></tr><tr><td>Basic.Get-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Ack</td><td>否</td><td>channel.basicAck</td><td>确认</td></tr><tr><td>Basic.Reject</td><td>否</td><td>channel.basicReject</td><td>拒绝（单条拒绝）</td></tr><tr><td>Basic.Recover</td><td>否</td><td>channel.basicRecover</td><td>请求 Broker 重新发送未被确认的消息</td></tr><tr><td>Basic.Recover-Ok</td><td>否</td><td>向上</td><td>同上</td></tr><tr><td>Basic.Nack</td><td>否</td><td>channel.basicNack</td><td>拒绝（可批量拒绝〉</td></tr><tr><td>Tx.Select</td><td>否</td><td>channel.txSelect</td><td>开启事务</td></tr><tr><td>Tx.Select-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Tx.Commit</td><td>否</td><td>channel.txCommit</td><td>事务提交</td></tr><tr><td>Tx.Commit-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Tx.Rollback</td><td>否</td><td>channel.txRollback</td><td>事务回滚</td></tr><tr><td>Tx.Rollback-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Confirm Select</td><td>否</td><td>channel.confinnSelect</td><td>开启发送端确认模式</td></tr><tr><td>Confirm.Select-Ok</td><td>否</td><td>同上</td><td>同上</td></tr></tbody></table><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第一章《简介和入门》，内容来自于《RabbitMQ实战指南》，内容包括：RabbitMQ概述，安装和简单使用，基本概念，AMQP协议等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>分布式概览（持续更新）</title>
    <link href="http://linyishui.top/2020091201.html"/>
    <id>http://linyishui.top/2020091201.html</id>
    <published>2020-09-12T12:20:42.000Z</published>
    <updated>2020-10-02T08:15:49.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式概览"><a href="#分布式概览" class="headerlink" title="分布式概览"></a><strong>分布式概览</strong></h1><h2 id="第一节-分布式系统"><a href="#第一节-分布式系统" class="headerlink" title="第一节 分布式系统"></a><strong>第一节 分布式系统</strong></h2><h3 id="1-1-什么是分布式系统？"><a href="#1-1-什么是分布式系统？" class="headerlink" title="1.1 什么是分布式系统？"></a><strong>1.1 什么是分布式系统？</strong></h3><p>分布式系统是一种<strong>组件分布在网络计算机上</strong>，<strong>组件之间仅仅通过消息传递来通信并协调行动</strong>的系统。</p><p>对于用户来说，他面对的只是一台服务器，但实际上这台服务器是由众多服务器组成的“一台超级计算机”。所以我们可以联想到我们日常使用的各种网站，它们背后都是一整个大型分布式系统在提供服务。</p><h3 id="1-2-分布式系统的意义？"><a href="#1-2-分布式系统的意义？" class="headerlink" title="1.2 分布式系统的意义？"></a><strong>1.2 分布式系统的意义？</strong></h3><p>为什么要从单一应用架构或垂直应用架构升级到分布式系统？</p><ul><li>升级单机处理能力的性价比越来越低</li><li>单机处理能力有瓶颈</li><li>分布式系统带来稳定性和可用性</li><li>单一应用不利于扩展和升级维护</li><li>单一应用拆分后，应用间的交互越来越复杂</li></ul><h3 id="1-3-基础知识补齐"><a href="#1-3-基础知识补齐" class="headerlink" title="1.3 基础知识补齐"></a><strong>1.3 基础知识补齐</strong></h3><h4 id="1-3-1-组成计算机的5要素"><a href="#1-3-1-组成计算机的5要素" class="headerlink" title="1.3.1 组成计算机的5要素"></a><strong>1.3.1 组成计算机的5要素</strong></h4><p>冯 · 诺依曼计算机的5个组成部分：</p><ul><li>运算器</li><li>控制器</li><li>存储器<ul><li>内存</li><li>外存：断电后仍能保存数据。</li></ul></li><li>输入设备</li><li>输出设备</li></ul><p>既然分布式系统看起来像一个超级计算机，是不是也有类似的结构呢？</p><h4 id="1-3-2-线程与进程的执行模式"><a href="#1-3-2-线程与进程的执行模式" class="headerlink" title="1.3.2 线程与进程的执行模式"></a><strong>1.3.2 线程与进程的执行模式</strong></h4><p>我们学习编程都是从单线程模式开始的，面对的都是<strong>程序的顺序、分支和循环执行</strong>。多线程（指单进程内的多线程）要处理<strong>线程间通信</strong>，要对<strong>线程并发</strong>做控制，做好<strong>线程间的协调工作</strong>。</p><p>在多核CPU的时代，程序的<strong>并发</strong>和<strong>并行</strong>很重要，决定着是否能够有效利用多核带来的性能提升。</p><p>多线程的几种交互模式：</p><ul><li><strong>互不通信的多线程模式</strong>：最简单的多线程模式，线程间无共享数据，也不需要做动作协调，就是多个独立的线程各自完成自己的任务。</li><li><strong>基于共享容器的多线程模式</strong>：多线程具有共享数据，如经典的生产者消费者问题。我们需要保证数据访问的正确性，对于存储数据的容器有线程安全或不安全之分，线程不安全的容器一般可以通过<strong>加锁（数据读写比例很高，采用读写锁而非互斥锁）或写时复制CopyOnWrite</strong>的方式来控制。</li><li><strong>通过事件协同的多线程模式</strong>：除了并发访问的控制，线程间还会有协调的需求。比如A、B两个线程，B线程需要等待某个状态或事件发生后才能继续工作，而这个改变和A线程有关，这时就需要完成线程间的协调（等待通知机制），这种情况下需要注意避免死锁。</li></ul><p>多进程模式：线程属于进程，所以一个进程内的多个线程共享了进程的内存空间，而进程之间的内存空间是独立的。所以多个进程间通过内存共享、交换数据的方式与多线程有所不同。</p><ul><li>单机多进程</li><li>多机多进程：单机OS所支持的功能需要另外实现，单个机器故障处理的好就不影响集群。</li></ul><h4 id="1-3-3-网络通信"><a href="#1-3-3-网络通信" class="headerlink" title="1.3.3 网络通信"></a><strong>1.3.3 网络通信</strong></h4><p><strong>OSI与TCP/IP网络模型</strong></p><p><img src alt></p><p><img src alt></p><p>OSI七层模型：</p><ul><li>应用层</li><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li><li>运输层</li><li>网路层</li><li>数据链路层</li><li>物理层</li></ul><p>五层协议：</p><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 <strong>HTTP</strong>、<strong>DNS</strong> 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<ul><li>传输控制协议 <strong>TCP</strong>，提供面向连接、可靠的数据传输服务，数据单位为报文段；</li><li>用户数据报协议 <strong>UDP</strong>，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。</li><li>TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li></ul></li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><p>TCP/IP：</p><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p>网络IO的实现方式：使用Socket套接字进行网络通信开发时，会使用哪些实现方式。</p><ul><li><strong>BIO</strong>：Blocking IO，阻塞式实现。一个套接字需要使用一个线程来处理，建立连接、读数据、写数据都可能会阻塞。</li><li><strong>NIO</strong>：Nonblocking IO，非阻塞式实现，基于事件驱动思想，采用 Reactor 模式。相比于BIO，NIO不用为每个套接字分配一个线程，而是一个线程处理多个套接字的相关工作。</li><li><strong>AIO</strong>：AsynchronousIO，异步IO，采用 Proactor 模式。与NIO的差异是，AIO在进行读写操作时，只需调用相应的 read/write 方法，并且传入 CompletionHandler（动作完成的处理器）；在动作完成后，会调用CompletionHandler。NIO的通知发生在动作之前，是在可写、可读的时候，Selector发现这些事件后调用 Handler 处理。</li></ul><h4 id="1-3-4-如何把应用从单机扩展到分布式"><a href="#1-3-4-如何把应用从单机扩展到分布式" class="headerlink" title="1.3.4 如何把应用从单机扩展到分布式"></a><strong>1.3.4 如何把应用从单机扩展到分布式</strong></h4><p>分布式这种“超级计算机”的五个组成部分的变化：</p><ul><li>输入设备：<ul><li>互相连接的多个节点，某个节点接受其他节点信息时，可以看作输入设备。</li><li>传统人机交互的输入设备。</li></ul></li><li>输出设备：<ul><li>互相连接的多个节点，某个节点向其他节点传递信息时，可以看作输出设备。</li><li>传统人机交互的输出设备，如屏幕。</li></ul></li><li>控制器：<ul><li>单机的控制器就是CPU中的控制器。</li><li>分布式中控制器负责协调或控制节点之间的动作和行为。如远程服务调用的场景，有几种实现方式：<ul><li><strong>硬件负载均衡</strong>：所有请求都要通过机器转发。</li><li><strong>LVS透明代理</strong>：增加了网络的开销（流量和延迟），因为多了一层转发；代理崩溃会影响所有请求。</li><li><strong>名称服务</strong>：没有代理地址，请求的发起者和处理者<strong>直接连接</strong>，只不过名称服务模块搜集处理服务器的地址信息，发起者先从本机名称服务获取地址。代码升级比较复杂。</li><li><strong>规则服务器</strong>：也是<strong>直接连接</strong>，区别是名称服务和处理者机器交互记录其地址，规则服务器则不和处理者交互，只提供规则给请求的发起者。</li><li><strong>Master+Worker</strong>：Master节点管理任务，分配给不同的Worker进行处理。</li></ul></li></ul></li><li>运算器：分布式系统运用多个节点的计算能力来协同完成整体的计算任务。<ul><li>例如我们需要日志处理服务器从应用服务器集群收集日志并处理，随着应用服务器的增多，单台日志处理服务器达到瓶颈，所以需要增加日志服务器来提升处理能力。</li><li>可以使用<strong>Master+Worker</strong>来控制日志服务器集群，当然也可以采用规则服务器等。</li></ul></li><li>存储器：<ul><li>单机中存储器分为内存和外存。</li><li>分布式中要把承担存储功能的多个节点组织在一起。</li><li>实现方式：（如KV存储服务器）<ul><li>代理服务器，根据请求的Key划分（Sharding）进行转发</li><li>名称服务，根据不同场景有两种实现：<ul><li>配合规则服务器，完成固定的Sharding策略</li><li>在消息中间件的应用场景，同等看待KV存储服务器，可以灵活的增加或减少服务器。</li></ul></li><li>规则服务器，除了对数据进行Sharding，还包括具体KV存储服务器的地址。</li><li>Master根据请求返回目标KV存储服务器地址，相比名称服务返回所有地址，Master根据请求返回对应地址；相比规则服务器把规则传给具体应用再由应用服务器解析并完成规则下的路由选择，Master自身完成了这件事情，只把结果传给应用服务器，应用服务器只须拿着地址去访问即可。</li></ul></li></ul></li></ul><h4 id="1-3-5-分布式系统的难点"><a href="#1-3-5-分布式系统的难点" class="headerlink" title="1.3.5 分布式系统的难点"></a><strong>1.3.5 分布式系统的难点</strong></h4><ul><li><strong>缺乏全局时钟</strong>：单机有机器时钟为标准，容易控制时序。分布式系统中同步本身就有时间差，很难保持所有机器的时间一致。不过我们使用时钟来区分动作间的顺序不需要准确的时间，一般会由一个单独的集群来区分动作间的顺序。</li><li><strong>面对故障独立性</strong>：分布式系统中，某个部分有问题而其他部分正常是经常发生的。</li><li><strong>处理单点故障</strong>：单点即在分布式系统中的某个功能只由单机在支持，其发生的故障即单点故障，SPoE（Single Point of Failure）。所以能扩展为集群的就尽量扩展，只能单点实现的：<ul><li>做好这个单点的备份，能够在出问题时及时恢复，最好能自动恢复、快速恢复。</li><li>降低单点故障的影响范围，尽量减少故障发生时的损失。</li></ul></li><li><strong>事务</strong>：两阶段提交（2PC）、最终一致、BASE、CAP、Paxos等</li></ul><hr><h2 id="第二节-大型网站架构演变历程"><a href="#第二节-大型网站架构演变历程" class="headerlink" title="第二节 大型网站架构演变历程"></a><strong>第二节 大型网站架构演变历程</strong></h2><h3 id="2-1-早期-用Java技术和单机来构建网站"><a href="#2-1-早期-用Java技术和单机来构建网站" class="headerlink" title="2.1 早期-用Java技术和单机来构建网站"></a><strong>2.1 早期-用Java技术和单机来构建网站</strong></h3><p><strong>熟悉的技术</strong>：LAMP、MVC框架、JSP、Servlet、JDBC、Spring、Struts、Hibernate、HTML、CSS、JavaScript、Python等。</p><p>举一个交易网站的例子，核心模块有<strong>用户、商品和交易</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010119.png" alt></p><h3 id="2-2-单机负载告警，数据库与应用分离"><a href="#2-2-单机负载告警，数据库与应用分离" class="headerlink" title="2.2 单机负载告警，数据库与应用分离"></a><strong>2.2 单机负载告警，数据库与应用分离</strong></h3><p>随着访问量增加，单台服务器负载持续增高，我们首先把数据库与应用分开到两条服务器。这种变更对系统影响很小，只须修改数据库地址即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010120.png" alt></p><h3 id="2-3-应用服务器负载告警，走向集群"><a href="#2-3-应用服务器负载告警，走向集群" class="headerlink" title="2.3 应用服务器负载告警，走向集群"></a><strong>2.3 应用服务器负载告警，走向集群</strong></h3><p>应用服务器压力不断增加，可以根据监测来进行针对性的优化，我们选用将应用服务器由单机转为集群的优化方式。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010121.png" alt></p><h4 id="（1）单机转为集群的两个问题"><a href="#（1）单机转为集群的两个问题" class="headerlink" title="（1）单机转为集群的两个问题"></a><strong>（1）单机转为集群的两个问题</strong></h4><p>变更为集群会带来两个要解决的问题：</p><ul><li>两个应用服务器的选择问题，我们可以通过DNS或负载均衡设备来解决。</li><li>Session问题。</li></ul><p>引入负载均衡设备后：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010122.png" alt></p><p>我们知道HTTP协议是无状态的，为了支持有状态的会话需求，我们需要Session机制，在会话开始时分配一个SessionId，通过Cookie告知浏览器，以后会话中的每次请求都会携带此SessionId来告知Web服务器此次属于哪个会话。<strong>Web服务器需要独立的存储会话信息</strong>，当Cookie禁用时会拼接到URL中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010123.png" alt></p><p>所以当服务器变为两台时，Session就出现了问题，保存在单机上的会话，和随机访问任一服务器的会话请求产生了矛盾。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010124.png" alt></p><h4 id="（2）Session问题的解决方案"><a href="#（2）Session问题的解决方案" class="headerlink" title="（2）Session问题的解决方案"></a><strong>（2）Session问题的解决方案</strong></h4><ol><li><p><strong>Session Sticky</strong>：通过负载均衡器保证同一个会话的请求都在同一个Web服务器上处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010125.png" alt></p><p>最简单的方案，但也存在问题：</p><ul><li>一台服务器宕机或重启，其会话数据会丢失，对应的用户需要重新登录；</li><li>因为会话标识是应用层的信息，负载均衡器将会话请求保存在同一个Web服务器，需要进行应用层（第7层）的解析，开销会比第4层的交换大；</li><li>负载均衡器也变成了一个有状态的节点，相比无状态节点，内存消耗更大，容灾方面更麻烦。</li></ul></li><li><p><strong>Session Replication</strong>：每台Web服务器都保存相同的会话信息。需要在Web服务器间进行数据同步，保证Session数据一致。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010126.png" alt></p><p>同样也有其问题：</p><ul><li><strong>网络开销越来越大</strong>：同步Session数据导致了网络带宽的开销，只要Session数据有变化，就需要同步到所有机器，机器数越多，带来的网络开销越大；</li><li><strong>内存占用越来越大</strong>：每台服务器都要保存所有的Session数据，当整个集群的用户量很多时，保存数据所需的空间会很大。</li></ul></li><li><p><strong>Session数据集中存储</strong>：集中的存放所有的Session数据，所有Web服务器向同样地址获取Session。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010127.png" alt></p><p>此方案的问题：</p><ul><li>读写Session数据引入了网络操作，相比本机数据读取存在时延和不稳定行（内网通信好一些）；</li><li>集中存储Session的机器有问题，会影响整个应用（扩展集群）。</li></ul></li><li><p><strong>Cookie Based</strong>：把Session存放在Cookie中，Web服务器从Cookie中生成对应Session数据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010128.png" alt></p><p>此方案的不足：</p><ul><li>Cookie有<strong>长度限制</strong>；</li><li><strong>安全性</strong>：Session数据本身是服务端数据，此方案是由客户端存放通过外部网络传输，所以要对写入Cookie的Session数据进行加密（并不绝对安全）。</li><li><strong>带宽消耗</strong>：指数据中心整体外部带宽的消耗（每次请求都增加了数据）。</li><li><strong>性能影响</strong>：每次HTTP请求和响应都带有Session数据，对Web服务器来说，响应的结果输出越少，支持的并发请求就越多。</li></ul></li></ol><p>大型网站比较适合 <strong>Session Sticky</strong> 和 <strong>Session数据集中存储</strong> ，根据具体场景做出选择和权衡。</p><h3 id="2-4-数据读压力增大，读写分离"><a href="#2-4-数据读压力增大，读写分离" class="headerlink" title="2.4 数据读压力增大，读写分离"></a><strong>2.4 数据读压力增大，读写分离</strong></h3><h4 id="（1）采用数据库作为读库"><a href="#（1）采用数据库作为读库" class="headerlink" title="（1）采用数据库作为读库"></a><strong>（1）采用数据库作为读库</strong></h4><p>对于大型网站，大部分业务是读多写少的场景，这种情况我们可以考虑<strong>读写分离</strong>的方式。</p><p>我们可以在架构中增加一个读库，它只负责读取服务。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010129.png" alt></p><p>带来问题：</p><ul><li><p><strong>数据复制问题</strong>：数据库一般会提供数据复制功能，可以直接使用。</p><ul><li>要考虑数据复制的时延问题;</li><li>复制过程中数据的源和目标之间的映射关系及过滤条件的支持问题。</li></ul><p>数据库支持：（数据库对数据复制的支持是相对有限的）</p><ul><li>MySQL：Master（主库）+ Slave（备库）的结构，5.5版本之前都是异步数据复制，会有延迟，提供完全镜像方式的复制，保证了备库和主库的数据一致性。5.5后加入了 semi-sync ，在数据安全性上更好，但从读写分离的角度看仍有复制延迟的可能。</li><li>Oracle：Data Guard方案，主要用于容灾、数据库保护以及故障恢复等场景，在实施中又分为物理备库（物理StandBy）和逻辑备库（逻辑StandBy）。</li></ul></li></ul><ul><li><strong>应用对于数据源的选择问题</strong>：写操作走主库，事务读也要走主库，还要考虑备库数据相对于主库的延迟。</li></ul><h4 id="（2）搜索引擎"><a href="#（2）搜索引擎" class="headerlink" title="（2）搜索引擎"></a><strong>（2）搜索引擎</strong></h4><p>当我们需要根据商品标题查询商品信息时，常规做法是通过数据库的 <code>like</code> 功能进行模糊查询。使用搜索引擎的倒排表方式可以大大提升检索速度。</p><p>搜索引擎首先要根据被搜索数据构建索引，数据改变索引也要改变。应用要选择什么数据走搜索引擎，什么数据走数据库。构建索引的过程也是一种数据复制的过程，只不过不是简单的复制对应数据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010130.png" alt></p><p>可以从两个维度对搜索系统构建索引的方式进行划分：</p><ul><li>按照<strong>全量/增量</strong>划分：第一次构建索引用全量，在全量基础上采用增量方式更新索引（一般加入每日的全量作为补充）。</li><li>按照<strong>实时/非实时</strong>划分：更新时间上倾向于实时的方式，非实时主要考虑对数据源头的保护。</li></ul><h4 id="（3）缓存"><a href="#（3）缓存" class="headerlink" title="（3）缓存"></a><strong>（3）缓存</strong></h4><ol><li><p><strong>数据缓存</strong>：数据缓存的目的类似于读库，一般用来保存和查询键值对，来加速应用在响应请求时的数据读取速度。</p><p>两种方式：</p><ul><li><strong>应用主动更新缓存</strong>：应用访问缓存，数据不存在则从数据库读出并放入缓存，当缓存容量不足时清除最近不被访问的数据。</li><li><strong>数据库记录变化更新缓存</strong>：数据库发生变化，主动把数据放入缓存，这样能够及时更新缓存中的数据，不会造成读取失效。<strong>一般用于全数据缓存，要求相关代码要结合业务逻辑。</strong></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010131.png" alt></p></li><li><p><strong>页面缓存</strong>：缓存一些动态产生的页面或页面的一部分内容，ESI是一种针对这种情况的规范。</p><ul><li>Web服务器产生的请求响应结果返回给Apache，处理后找到ESI标签，在缓存中获取标签对应内容；若内容不存在，Apache模板通过Web服务器渲染这些内容，再把结果放回缓存，用内容替换掉ESI标签并返回给客户。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010132.png" alt></p><ul><li>ESI模块总是要对响应结果进行解析，Web服务器处理时直接完成这项工作是更好的选择。所以改进为如下结构，把渲染和缓存功能放在Web服务器，这样更高效一些。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010133.png" alt></p></li></ol><p>使用缓存来加速数据读取时要注意：</p><ul><li>缓存命中率：太低就导致大量请求仍要回到数据库；</li><li>数据的分布和更新策略：<ul><li>分布上要考虑<strong>避免局部热点</strong>的机制，缓存服务器的扩容和缩容要尽量平滑（考虑<strong>一致性Has</strong>h）；</li><li>更新上会有<strong>定时失效、数据变更时失效和数据变更时更新</strong>几种策略。</li></ul></li></ul><h3 id="2-5-引入分布式存储系统"><a href="#2-5-引入分布式存储系统" class="headerlink" title="2.5 引入分布式存储系统"></a><strong>2.5 引入分布式存储系统</strong></h3><p>常见的分布式存储系统：</p><ul><li>分布式文件系统：弱格式，内容格式需要自行组织，解决小文件和大文件的存储问题；</li><li>分布式Key-Value系统：提供高性能的半结构化支持；</li><li>分布式数据库：提供一个支持大数据、高并发的数据库系统。</li></ul><p>分布式存储系统通过集群提供了一个高容量、高并发访问、数据冗余容灾的支持，直接代替原先的单机主库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010134.png" alt></p><h3 id="2-6-读写分离后，数据库又遇到瓶颈"><a href="#2-6-读写分离后，数据库又遇到瓶颈" class="headerlink" title="2.6 读写分离后，数据库又遇到瓶颈"></a><strong>2.6 读写分离后，数据库又遇到瓶颈</strong></h3><p>虽然进行了以上的优化，我们的核心功能数据（用户、商品和交易）还都在一个数据库中，随着数据量和访问量的增大，数据库的压力还在不断增加。</p><p>此时我们需要进行数据的<strong>垂直拆分</strong>和<strong>水平拆分</strong>。</p><h4 id="（1）专库专用，数据垂直拆分"><a href="#（1）专库专用，数据垂直拆分" class="headerlink" title="（1）专库专用，数据垂直拆分"></a><strong>（1）专库专用，数据垂直拆分</strong></h4><p>垂直拆分就是<strong>把数据库中不同业务数据拆分到不同的数据库</strong>，对于交易系统这个例子就是把用户、商品、交易数据分开。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010135.png" alt></p><p>带来的影响：</p><ul><li>应用配置多数据源；</li><li>单机跨业务事务要转为分布式事务；</li><li>表关联要改变实现。</li></ul><h4 id="（2）垂直拆分后的单机仍有瓶颈，数据水平拆分"><a href="#（2）垂直拆分后的单机仍有瓶颈，数据水平拆分" class="headerlink" title="（2）垂直拆分后的单机仍有瓶颈，数据水平拆分"></a><strong>（2）垂直拆分后的单机仍有瓶颈，数据水平拆分</strong></h4><p>水平拆分就是<strong>把同一个表中的数据拆分到多个数据库中</strong>。一般是因为某个业务的数据表的数据量太大，达到了单个数据库的瓶颈。</p><p><strong>水平拆分与读写分离</strong>：读写分离解决的是读压力过大的问题，对于数据量大或更新量的情况并不起作用。</p><p><strong>水平拆分与垂直拆分</strong>：垂直拆分把不同表放到不同数据库，水平拆分把同一个表拆到不同数据库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010136.png" alt></p><p>带来的影响：（假设拆分用户表）</p><ul><li><strong>解决SQL路由问题</strong>：用户信息被切分到了两个库，在进行数据库操作时要知道操作的数据在哪个库。</li><li><strong>解决主键问题</strong>：原先可能是Oracle的 Sequence 或MySQL的自增字段，现在要保证多个库的主键不重复。</li><li><strong>修改查询</strong>：同个业务的数据被拆分到不同数据库，所以一些查询要从多个库取数据，如果还要分页就很难处理。</li></ul><p>完成水平拆分后，我们能很好的应对数据量及写入量增长的情况。</p><h3 id="2-7-单机负载告警，数据库与应用分离"><a href="#2-7-单机负载告警，数据库与应用分离" class="headerlink" title="2.7 单机负载告警，数据库与应用分离"></a><strong>2.7 单机负载告警，数据库与应用分离</strong></h3><p>解决完数据库问题后，我们来看下应用的变化。我们之前完成了应用服务器从单机到多机的扩展，但随着业务的发展，应用功能越来越多，为了控制应用的大小，我们需要把应用拆开。</p><h4 id="（1）拆分应用"><a href="#（1）拆分应用" class="headerlink" title="（1）拆分应用"></a><strong>（1）拆分应用</strong></h4><p><strong>根据业务特性拆分</strong>：交易系统中就是拆成分别以交易和商品为主的两个应用，当然两个应用都有涉及用户的地方，我们先粗糙的让系统各自完成用户工作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010137.png" alt></p><p>通常新拆出的应用之间没有直接的相互调用，但可能会链接相同的数据库。如下，我们拆分了几个业务，它们之间没有直接的调用，都依赖底层的数据库、缓存、文件系统、搜索等。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010138.png" alt></p><h4 id="（2）服务化"><a href="#（2）服务化" class="headerlink" title="（2）服务化"></a><strong>（2）服务化</strong></h4><p>如下图，我们把应用分成了三层，最上层是Web系统，用于完成不同的业务功能；中间层是服务中心，各自提供不同的业务服务；最下层则是业务的数据库。（图中省略了缓存等基础系统）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010139.png" alt></p><p>服务化的区别：</p><ul><li><strong>方法调用</strong>：业务功能内不仅仅是单机的内部方法调用了，还<strong>需要远程服务调用</strong>（RPC）；</li><li><strong>共享代码</strong>：不再是散落在不同的应用，而是<strong>集中在各个服务中心</strong>。</li><li><strong>数据库连接</strong>：数据库交互工作在服务中心，Web应用专注于与浏览器交互的工作，不必多关注业务逻辑。服务中心不仅把散落的可共用的业务代码集中起来，还可以使其得到更好的维护。</li><li><strong>适合人员分工</strong>：每个服务都可以由固定的小团队来维护，更好的保持稳定性。</li></ul><h3 id="2-8-消息中间件"><a href="#2-8-消息中间件" class="headerlink" title="2.8 消息中间件"></a><strong>2.8 消息中间件</strong></h3><p>消息中间件（Message-oriented middleware，MOM）就是面向消息的系统，是在分布式系统中完成消息的发送和接收的基础软件。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010140.png" alt></p><p>消息中间件有两个为人熟知的优点：<strong>异步</strong>和<strong>解耦</strong>。</p><h3 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a><strong>2.9 总结</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010141.png" alt></p><hr><h2 id="第三节-Java中间件"><a href="#第三节-Java中间件" class="headerlink" title="第三节 Java中间件"></a><strong>第三节 Java中间件</strong></h2><p>在网站的演变过程中，无论是服务化、数据库的读写分离和拆分处理还是消息系统，都会用到相关的中间件。</p><p>中间件就是为软件应用提供除操作系统提供的服务以外的服务，让软件开发者更方便的处理通信、输入和输出，关注自己应用的部分。</p><p>我们这里主要了解三个领域的中间件：</p><ul><li><strong>远程过程调用和对象访问中间件</strong>：</li><li><strong>消息中间件</strong>：</li><li><strong>数据访问中间件</strong>：</li></ul><hr><h2 id="第四节-服务框架"><a href="#第四节-服务框架" class="headerlink" title="第四节 服务框架"></a><strong>第四节 服务框架</strong></h2><hr><h2 id="第五节-数据访问层"><a href="#第五节-数据访问层" class="headerlink" title="第五节 数据访问层"></a><strong>第五节 数据访问层</strong></h2><hr><h2 id="第六节-消息中间件"><a href="#第六节-消息中间件" class="headerlink" title="第六节 消息中间件"></a><strong>第六节 消息中间件</strong></h2><hr><h2 id="第七节-软负载中心与集中配置管理"><a href="#第七节-软负载中心与集中配置管理" class="headerlink" title="第七节 软负载中心与集中配置管理"></a><strong>第七节 软负载中心与集中配置管理</strong></h2><hr><h2 id="第八节-CDN"><a href="#第八节-CDN" class="headerlink" title="第八节 CDN"></a><strong>第八节 CDN</strong></h2><hr><h2 id="第九节-分布式存储"><a href="#第九节-分布式存储" class="headerlink" title="第九节 分布式存储"></a><strong>第九节 分布式存储</strong></h2><hr><h2 id="第十节-搜索系统"><a href="#第十节-搜索系统" class="headerlink" title="第十节 搜索系统"></a><strong>第十节 搜索系统</strong></h2><hr><h2 id="第十一节-其他"><a href="#第十一节-其他" class="headerlink" title="第十一节 其他"></a><strong>第十一节 其他</strong></h2><hr><p>参考：</p><p>🔗 《大型网站系统与Java中间件实践》</p>]]></content>
    
    <summary type="html">
    
      分布式相关知识内容的概览，简单整理了一下。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习dubbo（二）注册中心和监控中心</title>
    <link href="http://linyishui.top/2020090801.html"/>
    <id>http://linyishui.top/2020090801.html</id>
    <published>2020-09-08T09:50:24.000Z</published>
    <updated>2020-10-02T08:16:14.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo（二）注册中心和监控中心"><a href="#dubbo（二）注册中心和监控中心" class="headerlink" title="dubbo（二）注册中心和监控中心"></a><strong>dubbo（二）注册中心和监控中心</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-dubbo支持的几种注册中心"><a href="#1-1-dubbo支持的几种注册中心" class="headerlink" title="1.1 dubbo支持的几种注册中心"></a><strong>1.1 dubbo支持的几种注册中心</strong></h3><ul><li><strong>Multicast</strong>：不需要启动任何中心节点，只要广播地址一样，就可以互相发现。</li><li><strong>Zookeeper</strong>：Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</li><li><strong>Nacos</strong>：Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 <a href="https://github.com/apache/incubator-dubbo/tree/master/dubbo-registry/dubbo-registry-nacos" target="_blank" rel="noopener"><code>dubbo-registry-nacos</code></a> 则是 Dubbo 融合 Nacos 注册中心的实现。</li><li><strong>Redis</strong>：使用 Redis 的 Key/Map 结构存储数据结构，使用 Redis 的 Publish/Subscribe 事件通知数据变更。</li><li><strong>Simple</strong>：Simple 注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。</li></ul><h3 id="1-2-Zookeeper注册中心"><a href="#1-2-Zookeeper注册中心" class="headerlink" title="1.2 Zookeeper注册中心"></a><strong>1.2 Zookeeper注册中心</strong></h3><p>官方推荐的注册中心，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境。如下图树型结构。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/zookeeper.jpg" alt></p><p>流程说明：</p><ul><li><strong>服务提供者启动时</strong>: 向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li><strong>服务消费者启动时</strong>: 订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li><strong>监控中心启动时</strong>: 订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址。</li></ul><p>支持以下功能：</p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息。</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求。</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求。</li><li>当设置 <code>&lt;dubbo:registry check=&quot;false&quot; /&gt;</code> 时，记录失败注册和订阅请求，后台定时重试。</li><li>可通过 <code>&lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt;</code> 设置 zookeeper 登录信息。</li><li>可通过 <code>&lt;dubbo:registry group=&quot;dubbo&quot; /&gt;</code> 设置 zookeeper 的根节点，不配置将使用默认的根节点。</li><li>支持 <code>*</code> 号通配符 <code>&lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;</code>，可订阅服务的所有分组和所有版本的提供者。</li></ul><hr><h2 id="第二节-使用"><a href="#第二节-使用" class="headerlink" title="第二节 使用"></a><strong>第二节 使用</strong></h2><p>学习环境：LG笔记本 + Win10</p><h3 id="2-1-注册中心"><a href="#2-1-注册中心" class="headerlink" title="2.1 注册中心"></a><strong>2.1 注册中心</strong></h3><p>首先安装Zookeeper注册中心，下载地址：<a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">Zookeeper - download</a></p><p>包结构：</p><ul><li>bin：二进制执行文件，如 <code>zkServer.cmd</code> 可用于Win10执行。</li><li>conf：配置文件 <code>.cfg</code> 。</li><li>contrib：</li><li>dist-maven：</li><li>docs：</li><li>lib：</li><li>recipes：</li><li>src：</li></ul><p>首次启动 <code>zkServer.cmd</code> 会出错。</p><p>找到默认配置文件，创建副本并改名为 <code>zoo.cfg</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 数据存储位置</span><br><span class="line">dataDir=../data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure><p>再次启动 <code>zkServer.cmd</code> 。</p><p>启动 <code>zkCli.cmd</code> 简单使用以下Zookeeper。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取根目录文件</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] get /</span><br><span class="line"></span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看根目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建节点<span class="built_in">test</span></span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /test 123456</span><br><span class="line">Created /test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /</span><br><span class="line">[zookeeper, test]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取<span class="built_in">test</span>节点</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] get /test</span><br><span class="line">123456</span><br><span class="line">cZxid = 0x4</span><br><span class="line">ctime = Tue Sep 08 20:10:35 CST 2020</span><br><span class="line">mZxid = 0x4</span><br><span class="line">mtime = Tue Sep 08 20:10:35 CST 2020</span><br><span class="line">pZxid = 0x4</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x100061cf1510001</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h3 id="2-2-监控中心"><a href="#2-2-监控中心" class="headerlink" title="2.2 监控中心"></a><strong>2.2 监控中心</strong></h3><p>在GitHub找到dubbo项目：<a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">apache/dubbo</a>。往下找到ecosystem，首先下载Dubbo Admin这是一个管理控制台。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010101.png" alt></p><p>查看 <code>application.properties</code> 中Zookeeper地址是否正确。</p><p>在Idea中运行或用Maven打包启动，注意运行端口。</p><p>生产环境配置：</p><ol><li><p>下载代码: <code>git clone https://github.com/apache/dubbo-admin.git</code></p></li><li><p>在 <code>dubbo-admin-server/src/main/resources/application.properties</code>中指定注册中心地址</p></li><li><p>构建</p><blockquote><ul><li><code>mvn clean package</code></li></ul></blockquote></li><li><p>启动</p><ul><li><code>mvn --projects dubbo-admin-server spring-boot:run</code><br>或者</li><li><code>cd dubbo-admin-distribution/target; java -jar dubbo-admin-0.1.jar</code></li></ul></li><li><p>访问 <code>http://localhost:8080</code></p></li></ol><p>开发环境配置：</p><ul><li>运行<code>dubbo admin server</code> <code>dubbo admin server</code>是一个标准的spring boot项目, 可以在任何java IDE中运行它</li><li>运行<code>dubbo admin ui</code> <code>dubbo admin ui</code>由npm管理和构建，在开发环境中，可以单独运行: <code>npm run dev</code></li><li>页面访问 访问 <code>http://localhost:8081</code>, 由于前后端分开部署，前端支持热加载，任何页面的修改都可以实时反馈，不需要重启应用。</li></ul><p>部署完成后，可以访问 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 来查看所有的restful api。</p><p>访问UI对应地址。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010102.png" alt></p><p>默认使用 root/root 登陆。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010103.png" alt></p><p>登录后可以查看Dubbon Admin提供的基础功能。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010104.png" alt></p><h3 id="2-3-实例"><a href="#2-3-实例" class="headerlink" title="2.3 实例"></a><strong>2.3 实例</strong></h3><h4 id="（1）需求"><a href="#（1）需求" class="headerlink" title="（1）需求"></a><strong>（1）需求</strong></h4><p>描述：某电商系统，其订单服务需要调用用户服务获取指定用户的所有地址。</p><p>因此我们需要构建两个服务模块：订单服务Web模块，用户服务Service模块。</p><p>实现：订单服务Web模块部署于服务器A，用户服务Service模块部署于服务器B，A可以远程调用B。</p><h4 id="（2）架构"><a href="#（2）架构" class="headerlink" title="（2）架构"></a><strong>（2）架构</strong></h4><p>根据 dubbo《<a href="http://dubbo.apache.org/zh-cn/docs/user/best-practice.html" target="_blank" rel="noopener">服务化最佳实践</a>》：</p><ol><li><p><strong>分包</strong>：建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：<strong>重用发布等价原则</strong>(REP)，<strong>共同重用原则</strong>(CRP)。</p><p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：/xxx/dubbo-reference.xml。</p></li><li><p><strong>粒度</strong>：服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p><p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p><p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p></li><li><p><strong>版本</strong>：每个接口都应定义版本号，为后续不兼容升级提供可能，如： <code>&lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; version=&quot;1.0&quot; /&gt;</code>。</p><p>建议使用两位版本号，因为第三位版本号通常表示兼容升级，只有不兼容时才需要变更服务版本。</p><p>当不兼容时，先升级一半提供者为新版本，再将消费者全部升为新版本，然后将剩下的一半提供者升为新版本。</p></li><li><p><strong>兼容性</strong>：服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。</p><p>各协议的兼容性不同，参见：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/introduction.html" target="_blank" rel="noopener">服务协议</a> 。</p></li><li><p><strong>枚举值</strong>：</p><ul><li>如果是完备集，可以用 <code>Enum</code>，比如：<code>ENABLE</code>, <code>DISABLE</code>。</li><li>如果是业务种类，以后明显会有类型增加，不建议用 <code>Enum</code>，可以用 <code>String</code> 代替。</li><li>如果是在返回值中用了 <code>Enum</code>，并新增了 <code>Enum</code> 值，建议先升级服务消费方，这样服务提供方不会返回新值。</li><li>如果是在传入参数中用了 <code>Enum</code>，并新增了 <code>Enum</code> 值，建议先升级服务提供方，这样服务消费方不会传入新值。</li></ul></li><li><p><strong>序列号</strong>：</p><ul><li>服务参数及返回值建议使用 POJO 对象，即通过 <code>setter</code>, <code>getter</code> 方法表示属性的对象。</li><li>服务参数及返回值不建议使用接口，因为数据模型抽象的意义不大，并且序列化需要接口实现类的元信息，并不能起到隐藏实现的意图。</li><li>服务参数及返回值都必须是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" target="_blank" rel="noopener">传值调用</a>，而不能是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference" target="_blank" rel="noopener">传引用调用</a>，消费方和提供方的参数或返回值引用并不是同一个，只是值相同，Dubbo 不支持引用远程对象。</li></ul></li><li><p><strong>异常</strong>：</p><ul><li>建议使用异常汇报错误，而不是返回错误码，异常信息能携带更多信息，并且语义更友好。</li><li>如果担心性能问题，在必要时，可以通过 override 掉异常类的 <code>fillInStackTrace()</code> 方法为空方法，使其不拷贝栈信息。</li><li>查询方法不建议抛出 checked 异常，否则调用方在查询时将过多的 <code>try...catch</code>，并且不能进行有效处理。</li><li>服务提供方不应将 DAO 或 SQL 等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常。</li></ul></li><li><p><strong>调用</strong>：</p><ul><li>不要只是因为是 Dubbo 调用，而把调用 <code>try...catch</code> 起来。<code>try...catch</code> 应该加上合适的回滚边界上。</li><li>Provider 端需要对输入参数进行校验。如有性能上的考虑，服务实现者可以考虑在 API 包上加上服务 Stub 类来完成检验。</li></ul></li></ol><p>最终：</p><ul><li>gmall-order-web：订单服务Web模块。</li><li>gmall-user：用户服务Service模块</li><li>gmall-interface：公共接口层。</li></ul><h4 id="（3）编码"><a href="#（3）编码" class="headerlink" title="（3）编码"></a><strong>（3）编码</strong></h4><p>创建Maven项目gmall，并分别创建子项目：</p><ul><li>gmall-order-web：订单服务Web模块。</li><li>gmall-user：用户服务Service模块</li><li>gmall-interface：公共接口层。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010105.png" alt></p><p>使用dubbo：</p><ul><li>首先引入dubbo和操作zookeeper的客户端的依赖；</li><li>创建xml，并在文件中配置服务（即官网所说的用Spring配置暴露服务）；</li><li>在启动类中加载Spring配置。</li></ul><h5 id="1-user-service-provider"><a href="#1-user-service-provider" class="headerlink" title="1.user-service-provider"></a><strong>1.user-service-provider</strong></h5><p>pom.xml，分别引入dubbo和zookeeper客户端。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入dubbo --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>provider.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"user-service-provider"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"127.0.0.1:2181"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20882"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4、暴露服务   ref：指向服务的真正的实现对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"userServiceImpl01"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--统一设置服务提供方的规则  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务的实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl01"</span> <span class="attr">class</span>=<span class="string">"gmall.service.impl.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"userServiceImpl02"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl02"</span> <span class="attr">class</span>=<span class="string">"gmall.service.impl.UserServiceImpl2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 连接监控中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"provider.xml"</span>);</span><br><span class="line">ioc.start();</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserServiceImpl.....old..."</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">"北京市昌平区宏福科技园综合楼3层"</span>, <span class="string">"1"</span>, <span class="string">"李老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"Y"</span>);</span><br><span class="line">UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">"深圳市宝安区西部硅谷大厦B座3层（深圳分校）"</span>, <span class="string">"1"</span>, <span class="string">"王老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"N"</span>);</span><br><span class="line"><span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">Thread.sleep(4000);</span></span><br><span class="line"><span class="comment">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">e.printStackTrace();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserServiceImpl.....new..."</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">"北京市昌平区宏福科技园综合楼3层"</span>, <span class="string">"1"</span>, <span class="string">"李老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"Y"</span>);</span><br><span class="line">UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">"深圳市宝安区西部硅谷大厦B座3层（深圳分校）"</span>, <span class="string">"1"</span>, <span class="string">"王老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"N"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceStub</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceStub</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入的是userService远程的代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserServiceStub</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.userService = userService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"UserServiceStub....."</span>);</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isEmpty(userId)) &#123;</span><br><span class="line"><span class="keyword">return</span> userService.getUserAddressList(userId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-order-service-consumer"><a href="#2-order-service-consumer" class="headerlink" title="2.order-service-consumer"></a><strong>2.order-service-consumer</strong></h5><p>pom.xml，也分别引入dubbo和zookeeper。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>order-service-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入dubbo --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>consumer.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"gmall.service.impl"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"order-service-consumer"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  配置本地存根--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明需要调用的远程服务的接口；生成远程服务代理  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">1）、精确优先 (方法级优先，接口级次之，全局配置再次之)</span></span><br><span class="line"><span class="comment">2）、消费者设置优先(如果级别一样，则消费方优先，提供方次之)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- timeout="0" 默认是1000ms--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- retries="":重试次数，不包含第一次调用，0代表不重试--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 幂等（设置重试次数）【查询、删除、修改】、非幂等（不能设置重试次数）【新增】 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span> <span class="attr">retries</span>=<span class="string">"3"</span> <span class="attr">version</span>=<span class="string">"*"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:method name="getUserAddressList" timeout="1000"&gt;&lt;/dubbo:method&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置当前消费者的统一规则：所有的服务都不检查 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:consumer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:monitor address="127.0.0.1:7070"&gt;&lt;/dubbo:monitor&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</span><br><span class="line"></span><br><span class="line">OrderService orderService = applicationContext.getBean(OrderService.class);</span><br><span class="line"></span><br><span class="line">orderService.initOrder(<span class="string">"1"</span>);</span><br><span class="line">System.out.println(<span class="string">"调用完成...."</span>);</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、将服务提供者注册到注册中心（暴露服务）</span></span><br><span class="line"><span class="comment"> * 1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator)</span></span><br><span class="line"><span class="comment"> * 2）、配置服务提供者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2、让服务消费者去注册中心订阅服务提供者的服务地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"用户id："</span>+userId);</span><br><span class="line"><span class="comment">//1、查询用户的收货地址</span></span><br><span class="line">List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);</span><br><span class="line"><span class="keyword">for</span> (UserAddress userAddress : addressList) &#123;</span><br><span class="line">System.out.println(userAddress.getUserAddress());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addressList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-gmall-interface"><a href="#3-gmall-interface" class="headerlink" title="3.gmall-interface"></a><strong>3.gmall-interface</strong></h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>UserAddress</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userAddress; <span class="comment">//用户地址</span></span><br><span class="line">    <span class="keyword">private</span> String userId; <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> String consignee; <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNum; <span class="comment">//电话号码</span></span><br><span class="line">    <span class="keyword">private</span> String isDefault; <span class="comment">//是否为默认地址    Y-是     N-否</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//constructor and getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化订单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照用户id返回所有的收货地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）启动"><a href="#（4）启动" class="headerlink" title="（4）启动"></a><strong>（4）启动</strong></h4><p>分别启动服务提供者和消费者，控制台输出如下内容：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户id：<span class="number">1</span></span><br><span class="line">北京市昌平区宏福科技园综合楼<span class="number">3</span>层</span><br><span class="line">深圳市宝安区西部硅谷大厦B座<span class="number">3</span>层（深圳分校）</span><br><span class="line">调用完成....</span><br></pre></td></tr></table></figure><p>此时再启动dubbo-admin，使用 root / root 登录。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010106.png" alt></p><hr><h2 id="第三节-整合Spring-Boot"><a href="#第三节-整合Spring-Boot" class="headerlink" title="第三节 整合Spring Boot"></a><strong>第三节 整合Spring Boot</strong></h2><p>GitHub地址：<a href="https://github.com/apache/dubbo-spring-boot-project" target="_blank" rel="noopener">apache/dubbo-spring-boot-project</a> 。</p><p>下载项目与依赖，并跑通案例 <code>dubbo-spring-boot-samples</code> 。</p><h3 id="3-1-公共接口-sample-api"><a href="#3-1-公共接口-sample-api" class="headerlink" title="3.1 公共接口 sample-api"></a><strong>3.1 公共接口 sample-api</strong></h3><p>首先看 <code>dubbo-spring-boot-samples</code> / <code>sample-api</code> ，它是<strong>公共接口层</strong>，提供了生产者和消费者要使用的DemoService服务接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.spring.boot.sample.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-自动装配-auto-configure-samples"><a href="#3-2-自动装配-auto-configure-samples" class="headerlink" title="3.2 自动装配 auto-configure-samples"></a><strong>3.2 自动装配 auto-configure-samples</strong></h3><p>再看 <code>dubbo-spring-boot-samples</code> / <code>auto-configure-samples</code> 。</p><h4 id="（1）provider"><a href="#（1）provider" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>首先看服务提供者provider的内容，配置了应用信息、Dubbo协议信息等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application </span><br><span class="line"># 应用名</span><br><span class="line">spring.application.name=dubbo-auto-configuration-provider-demo</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line"># 扫描的基础包</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Protocol地址和端口，指定远程调用协议为dubbo，还可以为rmi、http等</span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=12345</span><br><span class="line">## Dubbo Registry</span><br><span class="line">## 注册中心服务器地址，N/A为默认值，表示不使用注册中心，直连客户端，地址可以是一个或多个，多个表示集群</span><br><span class="line">dubbo.registry.address=N/A</span><br></pre></td></tr></table></figure><p>provider实现了DemoService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random costTimeRandom = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先简单休眠一下</span></span><br><span class="line">        await();</span><br><span class="line">        <span class="comment">//自己添加的更直观的控制台输出</span></span><br><span class="line">        System.out.println(<span class="string">"sayHello: "</span> + name);</span><br><span class="line">        <span class="comment">//打印serviceName和实参</span></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> timeInMillisToWait = costTimeRandom.nextInt(<span class="number">500</span>);</span><br><span class="line">            Thread.sleep(timeInMillisToWait);</span><br><span class="line">            logger.info(<span class="string">"execution time : "</span> + timeInMillisToWait + <span class="string">" ms."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboAutoConfigurationProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        new SpringApplicationBuilder(DubboAutoConfigurationProviderBootstrap.class)</span></span><br><span class="line"><span class="comment">//                .run(args);</span></span><br><span class="line">        SpringApplication.run(DubboAutoConfigurationProviderBootstrap.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）consumer"><a href="#（2）consumer" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>再来看服务消费者consumer，只是配置了应用名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-auto-configure-consumer-sample</span><br></pre></td></tr></table></figure><p>consumer的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboAutoConfigurationConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务提供者注册的地址等信息</span></span><br><span class="line">    <span class="meta">@DubboReference</span>(</span><br><span class="line">            version = <span class="string">"1.0.0"</span>,</span><br><span class="line">            url = <span class="string">"dubbo://127.0.0.1:12345"</span>,</span><br><span class="line">            timeout = <span class="number">100</span>,</span><br><span class="line">            methods = &#123;</span><br><span class="line">                    <span class="meta">@Method</span>(name = <span class="string">"sayHello"</span>, timeout = <span class="number">300</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboAutoConfigurationConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"runner()"</span>);</span><br><span class="line">        <span class="comment">//调用公共接口demoService，通过指定的服务实现远程调用服务</span></span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动并观察是否正确打印出结果。</p><h3 id="3-3-外部化配置-externalized-configuration-samples"><a href="#3-3-外部化配置-externalized-configuration-samples" class="headerlink" title="3.3 外部化配置 externalized-configuration-samples"></a><strong>3.3 外部化配置 externalized-configuration-samples</strong></h3><h4 id="（1）provider-1"><a href="#（1）provider-1" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>provider与 <code>auto-configure-samples</code> 中唯一不同的是多了服务版本的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-externalized-configuration-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=12345</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=N/A</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>provider的服务实现，不同的是服务的版本号从配置文件中获取，并且没有sleep。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider的启动类完全一致。</p><h4 id="（2）consumer-1"><a href="#（2）consumer-1" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>消费者consumer则增加了一些配置，启动了一些dubbo端点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-externalized-configuration-consumer-sample</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &apos;*&apos;</span><br><span class="line">  endpoint:</span><br><span class="line">    dubbo:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboshutdown:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboconfigs:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboservices:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboreferences:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboproperties:</span><br><span class="line">      enabled: true</span><br><span class="line">  security:</span><br><span class="line">    ## Deprecated 2.x</span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line">## For Spring Boot 1.x demo</span><br><span class="line">endpoints:</span><br><span class="line">  dubbo:</span><br><span class="line">    enabled: true</span><br><span class="line">    sensitive: false</span><br><span class="line">  dubboshutdown:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboconfigs:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboservices:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboreferences:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboproperties:</span><br><span class="line">    enabled: true</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line">    url: dubbo://localhost:12345</span><br></pre></td></tr></table></figure><p>consumer的启动类中 <code>@DubboReference</code> 也改为从配置文件读取，并且增加了Get请求接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboExternalizedConfigurationConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>, url = <span class="string">"$&#123;demo.service.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboExternalizedConfigurationConsumerBootstrap.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/say-hello"</span>, method = GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别启动 provider 和 consumer 并访问服务接口：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010108.png" alt></p><h3 id="3-4-注册中心-registry-samples"><a href="#3-4-注册中心-registry-samples" class="headerlink" title="3.4 注册中心 registry-samples"></a><strong>3.4 注册中心 registry-samples</strong></h3><p>这个实例提供了Dubbo最常用的两种注册中心：Zookeeper 和 Nacos 。</p><h4 id="（1）Zookeeper"><a href="#（1）Zookeeper" class="headerlink" title="（1）Zookeeper"></a><strong>（1）Zookeeper</strong></h4><p>配置文件如下，有些许变更：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-registry-zookeeper-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">## Random port 此处改为随机端口，会分配一个没有被占用的端口</span><br><span class="line">dubbo.protocol.port=-1</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">## 指定了注册中心地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">## 使用文件缓存注册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储</span><br><span class="line">dubbo.registry.file = $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现没有变更：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sayHello : "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类没有变更：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRegistryZooKeeperProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(DubboRegistryZooKeeperProviderBootstrap.class).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer中配置文件中增加了注册中心的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-registry-zookeeper-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line"></span><br><span class="line">embedded:</span><br><span class="line">  zookeeper:</span><br><span class="line">    port: 2181</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;</span><br><span class="line">    file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br></pre></td></tr></table></figure><p>启动类中 <code>@DubboReference</code> 只配置了服务版本，因为之前是通过客户端直连，所以需要指定客户端地址，此时使用注册中心，只须关注服务接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRegistryZooKeeperConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboRegistryZooKeeperConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动并观察控制台。</p><h4 id="（2）Nacos"><a href="#（2）Nacos" class="headerlink" title="（2）Nacos"></a><strong>（2）Nacos</strong></h4><p>内容基本一致，暂略。</p><h3 id="3-5-服务自省-service-introspection-samples"><a href="#3-5-服务自省-service-introspection-samples" class="headerlink" title="3.5  服务自省 service-introspection-samples"></a><strong>3.5  服务自省 service-introspection-samples</strong></h3><h4 id="（1）provider-2"><a href="#（1）provider-2" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>增加了 <code>registry-type</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-zookeeper-service-introspection-provider-sample</span><br><span class="line"></span><br><span class="line"># Zookeeper Server Configuration</span><br><span class="line">zookeeper.server.host = 127.0.0.1</span><br><span class="line">zookeeper.server.port = 2181</span><br><span class="line"></span><br><span class="line"># Dubbo Spring Boot Externalization Configuration</span><br><span class="line">## Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line">## Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">## Random port</span><br><span class="line">dubbo.protocol.port=-1</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=zookeeper://$&#123;zookeeper.server.host&#125;:$&#123;zookeeper.server.port&#125;?registry-type=service</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现和启动类没有变化。</p><h4 id="（2）consumer-2"><a href="#（2）consumer-2" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>增加了 <code>registry-type</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-zookeeper-service-introspection-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line"></span><br><span class="line">embedded:</span><br><span class="line">  zookeeper:</span><br><span class="line">    port: 2181</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;/?registry-type=service</span><br><span class="line">    file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br></pre></td></tr></table></figure><p>启动类无变更。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboZooKeeperServiceIntrospectionConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboZooKeeperServiceIntrospectionConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-servlet容器-servlet-container-samples"><a href="#3-6-servlet容器-servlet-container-samples" class="headerlink" title="3.6 servlet容器 servlet-container-samples"></a><strong>3.6 servlet容器 servlet-container-samples</strong></h3><p>服务提供者也开放了服务的直接访问接口。</p><h4 id="（1）provider-3"><a href="#（1）provider-3" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-spring-boot-servlet-container-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=23456</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=N/A</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现无变更。</p><p>启动类增加了服务接口，配置了 <code>WebApplicationType</code> ，表示应用是基于Servlet的Web程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServletContainerProviderBootstrap</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/say/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Run as the generic Spring Boot Web(Servlet) Application</span></span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(DubboServletContainerProviderBootstrap.class);</span><br><span class="line">        application.setWebApplicationType(WebApplicationType.SERVLET);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）consumer-3"><a href="#（2）consumer-3" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>配置无变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-servlet-container-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line">    url: dubbo://127.0.0.1:23456</span><br></pre></td></tr></table></figure><p>启动类开放GET访问接口，通过读取配置文件地址直接远程调用客户端（服务提供者）服务实现，同样设置了 <code>WebApplicationType</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServletContainerConsumerBootstrap</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>, url = <span class="string">"$&#123;demo.service.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/say-hello"</span>, method = GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Run as the generic Spring Boot Web(Servlet) Application</span></span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(DubboServletContainerConsumerBootstrap.class);</span><br><span class="line">        application.setWebApplicationType(WebApplicationType.SERVLET);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 <a href="http://dubbo.apache.org/zh-cn/docs/user/dependencies.html" target="_blank" rel="noopener">Dubbo官网-文档</a></p><p>🔗 尚硅谷-dubbo</p>]]></content>
    
    <summary type="html">
    
      从零开始学习Dubbo，第二章《注册中心和监控中心》，并跑了一下Dubbo Spring Boot的示例。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="dubbo" scheme="http://linyishui.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>文档编辑器（持续更新）</title>
    <link href="http://linyishui.top/2020090601.html"/>
    <id>http://linyishui.top/2020090601.html</id>
    <published>2020-09-06T11:05:38.000Z</published>
    <updated>2020-09-06T11:53:20.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文档编辑器"><a href="#文档编辑器" class="headerlink" title="文档编辑器"></a><strong>文档编辑器</strong></h1><h3 id="MarkDown工具"><a href="#MarkDown工具" class="headerlink" title="MarkDown工具"></a><strong>MarkDown工具</strong></h3><p>记录一下日常使用过的md工具，一般都是用来写博客和日记，办公反而很少用到。</p><h4 id="（1）VSCode"><a href="#（1）VSCode" class="headerlink" title="（1）VSCode"></a><strong>（1）VSCode</strong></h4><p>最开始使用VSCode来编辑MarkDown文档，优点是大部分程序员都已经有了这个工具，不用再下载。</p><p>但早期写博客时，总感觉效率上还有所欠缺，因为VSCode的定位是一个文本编辑器，而不是富文本编辑器，所以不能像一些Markdown编辑器一样，获得所见即所得的体验。</p><p>所以在文档内容比较长时，就很难快速定位到想要修改的内容。</p><h4 id="（2）Typora"><a href="#（2）Typora" class="headerlink" title="（2）Typora"></a><strong>（2）Typora</strong></h4><p>因为我要整理的文档内容越来越长，所以如何提高写作效率成为我需要考虑的一个问题。我换用了正规的Markdown编辑器——Typora，它能让我像写Word一样的直接在效果页面写作，常用的MarkDown格式也很方便生成，并且支持多种格式的导入导出。</p><p>很长一段时间，我都在使用Typora作为写作工具。</p><p>推荐插件：</p><ul><li>Typora：<ul><li>VLOOK</li></ul></li></ul><p>但最近发现Typora经常会有一些莫名其妙的BUG，并且在文档超过2MB左右就会限制无法打开，这逼迫我必须再寻找一个工具来代替Typora。</p><h4 id="（3）MarkText"><a href="#（3）MarkText" class="headerlink" title="（3）MarkText"></a><strong>（3）MarkText</strong></h4><p>虽然没有文件大小限制，但非常卡顿，切换源码格式直接卡崩溃了，弃用。</p><p>无奈，先用VSCode来处理大文件，平时还继续用Typora。</p><h4 id="（4）VSCode插件"><a href="#（4）VSCode插件" class="headerlink" title="（4）VSCode插件"></a><strong>（4）VSCode插件</strong></h4><p>推荐插件：</p><ul><li>VSCode：<ul><li>Markdown All in One</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      简单整理工作和学习时常用的文档编辑器，持续更新中。
    
    </summary>
    
      <category term="实用工具" scheme="http://linyishui.top/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="tools" scheme="http://linyishui.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（四）第一天即开口</title>
    <link href="http://linyishui.top/2020090503.html"/>
    <id>http://linyishui.top/2020090503.html</id>
    <published>2020-09-05T13:28:52.000Z</published>
    <updated>2020-10-02T08:15:38.751Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一天即开口"><a href="#第一天即开口" class="headerlink" title="第一天即开口"></a><strong>第一天即开口</strong></h1><h3 id="词汇量不够怎么办"><a href="#词汇量不够怎么办" class="headerlink" title="词汇量不够怎么办"></a><strong>词汇量不够怎么办</strong></h3><p>当你作为初学者，要在第一天开口说外语时，你的第一反应是：“我还什么词都不会呢！”最初的一对一交流并不需要你说出几千个单词，可能你只需要掌握能够应对两三个问题的单词，感受一下说出这门语言是什么样子就够了。</p><h3 id="最初几小时"><a href="#最初几小时" class="headerlink" title="最初几小时"></a><strong>最初几小时</strong></h3><p>为第一次交谈做准备：</p><ul><li>选择一个正在使用目标语言的人，或是你觉得作为语言联系的搭档也许不错的人。</li><li>社交软件或邮件约一个具体时间。</li><li>通过线上方式用所学语言进行交流。</li></ul><p>几个小时的准备工作：</p><ul><li>可以看一些旅行常用语一类的书。</li><li>通过免费的资源学习一些常用语：<ul><li>How are you?</li><li>What`s your name?</li><li>My name is …</li><li>I don`t understand.</li><li>Could you repeat that / Again, please.</li><li>Can you speak slower please.</li><li>What does that/… mean?</li></ul></li><li>采用关键词记忆法来记住单词或固定词组：<ul><li>Yes、NO</li><li>Please、Thank you</li><li>Hello</li><li>Good Bye</li></ul></li></ul><h3 id="有不会的词就作个小弊"><a href="#有不会的词就作个小弊" class="headerlink" title="有不会的词就作个小弊"></a><strong>有不会的词就作个小弊</strong></h3><p>虽然你的初次对话可能只持续了10秒或20秒，但你可以回归书本或笔记，回想你想说但不会说的内容，把这些短语做成学习卡，然后学会它们。</p><p>你可以随身带一个小本子，列出你想说的内容以及还未掌握好的偏难词汇。</p><h3 id="改变措辞：让交谈简单直接"><a href="#改变措辞：让交谈简单直接" class="headerlink" title="改变措辞：让交谈简单直接"></a><strong>改变措辞：让交谈简单直接</strong></h3><p>初学者会很快学会一件事：<strong>在脑海中用母语组织好想表达的内容，然后再翻译成目标语言</strong>。但如果你想达到真正流利的水准，<strong>这个多余的步骤会把你的速度拖慢很多。</strong>当然作为初学者，这是可以容忍的。</p><p>比如你聊到未来的计划，你本来打算说:”I will travel to Spain in July for a two-week vacation.”。然而你突然意识到你不会用将来时，忘记了”travel to”（去旅行），甚至想不起”July”和”vacation”对应单词。</p><p>如果你是传统型的语言学习者，你应该会放弃了，接受自己还未“准备好”的事实。但执着于交流而不是表达准确性的人会考虑改换措辞，运用其他词汇来传达同样的意思。</p><p>为了省去动词将来时词形变化的烦恼，很多语言都有一个很便捷的特征：动词不定式跟在情态动词之后。比如”want”、”need”、”would like”、”should”、”may”、”can”这样的词的一般现在时形式与”I”连用，如”I want”、”I can”，后面就可以按词典上列出的不定式形式来使用你想用的重要动词”to travel”。想想”I want to travel”和”I will travel”的区别，虽然很重要，但对于表达意思又没那么重要了。你可能不知道”travel”这个词，但可以用”go”来代替。</p><p>所以上述句子可以转换为”I want to go to Spain this summer to be a tourist for two weeks”。</p><h3 id="最初几天"><a href="#最初几天" class="headerlink" title="最初几天"></a><strong>最初几天</strong></h3><p><strong>反馈至关重要。</strong>重复你在以前的谈话中说过的内容，每次都更加自信的说出来。准备你自己的“演讲稿”，在早期这种可预测的模板是可以接受的，当然以后的阶段就不太适用了。</p><h3 id="运用分类体系来管理学到的内容"><a href="#运用分类体系来管理学到的内容" class="headerlink" title="运用分类体系来管理学到的内容"></a><strong>运用分类体系来管理学到的内容</strong></h3><p>致力于语言交流和应试或顺畅阅读的学习者不同，前者所有的努力都指向同一个目标：在下一次会话中表现的更出色一些。</p><p>偶尔回归传统的语言课程，尤其是和一些聚焦口语的课程相比更能满足你自身学习需求的课程。在解决了“说”这个难题后，就可以尽量遵循课程建议进行学习。如果课程中的内容不适合现在的你学习，请跳过它。比如你可能要学习游客常见口语，但对于正在家中自学的你来说并不是最想学的内容，你可能只想问你的对话搭档今天做了什么。</p><h3 id="我不明白对方的回复"><a href="#我不明白对方的回复" class="headerlink" title="我不明白对方的回复"></a><strong>我不明白对方的回复</strong></h3><p>早期交流中，你听到的大部分内容似乎都是难以理解的。完全的理解整段话语内容在早期阶段并不合适，提取别人讲话中你能听懂的词汇或片段，由此推断对方在说什么。</p><p>不要抱定“我不懂”的想法不放，根据语境去猜测对方的内容，并进行合理的回复。</p><h3 id="作者的两小时波兰语经历"><a href="#作者的两小时波兰语经历" class="headerlink" title="作者的两小时波兰语经历"></a><strong>作者的两小时波兰语经历</strong></h3><p>作者曾因要做演讲而进行过一次两个小时的波兰语Skype学习：</p><ul><li>使用常用语手册学习一些初次会话的基础词汇：<ul><li>“I just started learning Polish”</li><li>“I am going to Poland soon”</li></ul></li><li>用电子词典查好交流要用的词汇。</li><li>在屏幕上打开一个文本文档，在上面记录可能记不住的词，准备几十个这样的词。</li><li>当对方说出一个你不会的词时，请他在聊天窗口打出来，复制下来并抽空学习。</li></ul><p>在这次半个小时的对话中，作者坚持一直使用波兰语，虽然很多次弄不懂对方说什么，自己也说不出一些简单的内容，这种不完美的感觉会一直伴随着学习的过程。</p><p>建议用两周的时间来学习一下世界语，有研究表明学习一年世界语再学一年法语的学生比直接学习两年法语的学生更有优势。</p><p>世界语的设计很简单，可以让你在很短的时间掌握好它，克服了第一门外语的难关后，你再次学习其他外语会简单很多。</p><h3 id="尽早开始全程目标语交流"><a href="#尽早开始全程目标语交流" class="headerlink" title="尽早开始全程目标语交流"></a><strong>尽早开始全程目标语交流</strong></h3><p>传统的学习方法会用你的母语教你这门语言怎么运作，整个学习过程你都在仔细的剖析目标语的语法和词汇。语言作为交流的手段，从一开始就应该是被使用的。</p><p><strong>你需要培养用目标语思考的习惯。</strong></p><p>在会话中使用其他语言只会拖慢你前进的步伐，关键就是要尽早下定决心，只要你能容忍较长的停顿和不断的查找单词，即使从第一天开口对话也是能做到的。</p><h3 id="对方用你的母语回复怎么办"><a href="#对方用你的母语回复怎么办" class="headerlink" title="对方用你的母语回复怎么办"></a><strong>对方用你的母语回复怎么办</strong></h3><p>好的老师或拍档应该只把母语最终手段来使用，请尽可能用一些手段来作为回报，让对方能尽量使用目标语来对话，指出你是为了学习这门语言而在努力，如果无法得到好的结果，就选择和其他人交谈吧。</p><h3 id="杰克-·-斯帕罗法则：避免因迟疑而耗费时间"><a href="#杰克-·-斯帕罗法则：避免因迟疑而耗费时间" class="headerlink" title="杰克 · 斯帕罗法则：避免因迟疑而耗费时间"></a><strong>杰克 · 斯帕罗法则：避免因迟疑而耗费时间</strong></h3><p>初学者要面临的一个问题是，你在刚开始对话时只会“嗯嗯啊啊”而不得不中止交谈，这很尴尬。早期对话中，犹豫和迟疑是不可避免的，但我们可以用一些小技巧让这些时刻变得不那么紧张和尴尬。</p><p>在《加勒比海盗》中，杰克 · 斯帕罗船长的肢体语言十分丰富，即使不说话也依然生动鲜活。这种方法可以用来保持对方的注意力，比如你想说”I want to go to the supermarket”，当你说道”go to”时你发现你忘记了超市怎么说，你需要一些时间来想想。这个时候你可以看着对方的眼睛，吸引他的全部注意，然后举起食指指向远方，并且面带沉思的凝望所指向的方向。这时你可以说你想去机场、沙漠……只要稍微练习，你可以把这些停顿运用的更加自然。</p><h3 id="碰杯法则：抛开害羞的想法"><a href="#碰杯法则：抛开害羞的想法" class="headerlink" title="碰杯法则：抛开害羞的想法"></a><strong>碰杯法则：抛开害羞的想法</strong></h3><p>碰杯法则——抛开我很害羞的想法，只要接近那个人跟他问好就是了。</p><h3 id="参与即理解"><a href="#参与即理解" class="headerlink" title="参与即理解"></a><strong>参与即理解</strong></h3><blockquote><p><strong>不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。学至于行而止矣。</strong></p><p>​                                                                                            ——中国谚语</p></blockquote><hr><p>内容来源：</p><p>🔗 《跟各国人都聊得来-三个月外语流利术》</p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（三）如何记单词</title>
    <link href="http://linyishui.top/2020090502.html"/>
    <id>http://linyishui.top/2020090502.html</id>
    <published>2020-09-05T10:03:08.000Z</published>
    <updated>2020-10-02T08:16:46.865Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何快速记住上千个单词"><a href="#如何快速记住上千个单词" class="headerlink" title="如何快速记住上千个单词"></a><strong>如何快速记住上千个单词</strong></h1><h3 id="为什么我们在学校学到的记忆方法不起作用"><a href="#为什么我们在学校学到的记忆方法不起作用" class="headerlink" title="为什么我们在学校学到的记忆方法不起作用"></a><strong>为什么我们在学校学到的记忆方法不起作用</strong></h3><p>如今我们有了越来越多的信息来源，很多人不再学习、背诵任何东西，因为随时可以Google到。这种情况很令人遗憾，因为我们没有发挥自己大脑的最大潜力。</p><p><strong>信息的重复出现让我们以为自己已经记住了它。</strong>我们在学校时，为了学会一个单词唯一的方法就是死记硬背。经过几十次甚至几百次的重复，你可能会在短期记住它，但能否运用就看运气了。</p><p><strong>与其简单的读出或识别出单词，不如尝试更有效的学习方法。</strong></p><h3 id="两种优秀的记忆方法"><a href="#两种优秀的记忆方法" class="headerlink" title="两种优秀的记忆方法"></a><strong>两种优秀的记忆方法</strong></h3><h4 id="方法一：关键字联想记忆法"><a href="#方法一：关键字联想记忆法" class="headerlink" title="方法一：关键字联想记忆法"></a><strong>方法一：关键字联想记忆法</strong></h4><p>当你要记忆一个单词或句子时，需要构建一个有趣的、栩栩如生的、令人难忘的画面或小故事。</p><p><strong>请自己从认识这个词语的第一印象开始，根据读音想象一个场景或故事。</strong></p><p>刚开始可能每个单词都要花费一两分钟来构思故事，但几天或一周后，你会变得熟练起来。而在三四次回想起故事后，你就可以牢牢记住这个词，以后就可以直接知道其含义。</p><h4 id="方法二：间隔重复记忆法"><a href="#方法二：间隔重复记忆法" class="headerlink" title="方法二：间隔重复记忆法"></a><strong>方法二：间隔重复记忆法</strong></h4><p><strong>通过单词卡和词组卡重新排列来辅助记忆。</strong>将记不住的单词排到前面，已知的单词排在后面。目前很多主流的APP都支持这种记忆法。</p><h3 id="用音乐来学习词组和整句"><a href="#用音乐来学习词组和整句" class="headerlink" title="用音乐来学习词组和整句"></a><strong>用音乐来学习词组和整句</strong></h3><p><strong>从词组和整句来开始学习语言可能效果会比从单词开始要更好。</strong>多使用如“厕所在哪里”、“这个多少钱”这样的常用句子。</p><p>记住这些句子并不容易，几百年来，人们常常通过唱歌来背诵文章。首先可以把句子和关键字记忆法结合，在短句的开头来启发记忆。其次，我们要相处适合的曲调来启发记忆，曲调要简洁，就像大本钟的钟声一样。记住想象越离奇，越有利于记忆。</p><h3 id="1分钟迷你讲话稿"><a href="#1分钟迷你讲话稿" class="headerlink" title="1分钟迷你讲话稿"></a><strong>1分钟迷你讲话稿</strong></h3><p>我们了解了怎样记住单词和词组，接下来就是更难的内容——记住整段文字。</p><p>请准备好陌生人见面的几个基本问题的答案：</p><ol><li>你是哪位？</li><li>你从哪里来？</li><li>你做什么工作？</li><li>你为什么要学这种语言？</li></ol><p>你可以用母语写好稿子，拜托一位以所学语言为母语的人帮忙准确的翻译它，或者从书上或网上找到地道的表述，请不要背电脑翻译或自己翻译的句子。</p><p>为每个问题都准备一张卡片，并用记忆法记住每个句子开头的单词和音节，再为每个句子找到一个调子或歌曲。</p><h3 id="单词就是你的武器"><a href="#单词就是你的武器" class="headerlink" title="单词就是你的武器"></a><strong>单词就是你的武器</strong></h3><blockquote><p><strong>不求与人相比，只求突破自己。</strong></p><p>​                                                ——嘉纳治五郎，柔道创始人</p></blockquote><p>学习语言的每一天，你的词汇量都在增加，同时你的沟通能力也会得到提升。</p><hr><p>内容来源：</p><p>🔗 《跟各国人都聊得来-三个月外语流利术》</p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（二）计划</title>
    <link href="http://linyishui.top/2020090501.html"/>
    <id>http://linyishui.top/2020090501.html</id>
    <published>2020-09-05T09:02:28.000Z</published>
    <updated>2020-10-02T08:15:59.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a><strong>计划</strong></h1><h3 id="设定一个具体化的目标"><a href="#设定一个具体化的目标" class="headerlink" title="设定一个具体化的目标"></a><strong>设定一个具体化的目标</strong></h3><p><strong>如何定义“流利”这个词语？</strong>牛津字典上的定义：流利，形容词，可准确、自如地表达自己的想法。</p><p>请不要错误的把目标定位外语要达到母语的水平。欧洲几个主要的语言测试组织所使用的一套科学、成熟的语言入门标准——《欧洲共同语言参考标准》（Common European Framework of Reference for Languages，CEFRL系统）定义了三个等级：“A”表示初级水平，“B”表示中级，“C”代表高级。每个等级又分“1”（较差）和“2”（较好）两种程度。</p><p>A级水平就是常说的具有基本语言能力的游客水平，可以进行基础的对话交流。C级水平意味着已经掌握了这门语言，能够达到母语使用者的水平。</p><p><strong>我们将B2及以上的水平定位为流利，能够流利地、自然地以该种语言为母语的人经常进行交流，对于双方而言，这种交流都毫无阻碍。</strong></p><h3 id="达到流利需要多长时间"><a href="#达到流利需要多长时间" class="headerlink" title="达到流利需要多长时间"></a><strong>达到流利需要多长时间</strong></h3><p>作者推荐是3个月内先达到基本对话的水平（B1），高强度的语言学习计划需要绝对的集中和专心，即使你是全职工作，也要挤出时间，每天学几小时。<strong>如果你想要迅速的进步，每天至少两个小时的语言学习是必不可少的。</strong>如果你只能每周投入几个小时，那你没有可能在3个月就掌握流利的外语。</p><p>即使你的期限不是3个月、6个月，也请尽量将一年分成更小的、更可控的多个时间段。</p><h3 id="总是朝着更高一级的目标努力"><a href="#总是朝着更高一级的目标努力" class="headerlink" title="总是朝着更高一级的目标努力"></a><strong>总是朝着更高一级的目标努力</strong></h3><p>只要能和其他人交流，你的语言学习就不算失败。但是，<strong>注意不要用“任何一个小进步都是成功”来纵容自己的懒惰。一定要把自己推出“舒适地带”，如果你设定的目标是你百分百能达到的，说明你的目标还是太低了。</strong></p><h3 id="迷你任务：逼自己离开舒适区"><a href="#迷你任务：逼自己离开舒适区" class="headerlink" title="迷你任务：逼自己离开舒适区"></a><strong>迷你任务：逼自己离开舒适区</strong></h3><p>在语言学习的某个特定时期，你会遇到一些具体问题，“迷你任务”可以帮你尽快解决它们。</p><p>在作者刚开始学汉语时，因为语调不对，别人完全不能听懂他的话。所以他只关注语调，不去管词汇和阅读等问题。一周后，人们可以稍微听懂他的一点话了，之后才开始了基本词汇的学习。</p><p>第二周，作者最大的问题是过度依赖词汇书，所以练习自发的说话变成了迷你任务。很快他也能不看书的去说一些词汇了。</p><p>这种迷你任务可以给你一种真实的、辛苦得来的成就感和进步感，使你集中精力应对问题直到解决它们。比如作者学习汉语时没有给自己设定每周的词汇任务，而是每天看60张词汇卡片，卡片上的词汇都是关于怎样点菜的。</p><p>一个月后，作者达到了瓶颈期，可以凭借记忆进行简单的交谈，语调也还可以。但这些交谈只能持续10~15秒，不算是真正的交谈。所以他开始一个新的迷你任务——提升思维速度的“大脑融合”。“大脑融合”强迫你快速思维，根据听到的信息进行推断、搜索词汇的意思，同时根据语境来理解语言的含义。所以他约了汉语母语的朋友来进行一个小时以上的对话。</p><p>迷你任务的目的就是逼迫自己离开舒适区，从而不断升级、挺过艰难的学习阶段。</p><h3 id="倦怠是放弃语言学习的主要原因之一"><a href="#倦怠是放弃语言学习的主要原因之一" class="headerlink" title="倦怠是放弃语言学习的主要原因之一"></a><strong>倦怠是放弃语言学习的主要原因之一</strong></h3><p>如果整个学习过程都充满了“大脑融合”任务，你可能很快会倦怠。适当的休息，在这段时间忘记语言学习，可能会有效的帮助到你。</p><h3 id="制订行动计划"><a href="#制订行动计划" class="headerlink" title="制订行动计划"></a><strong>制订行动计划</strong></h3><p>没有付诸实践，任何好主意都一文不值。请记住以下几点：</p><ul><li>设定稍高的目标。</li><li>设定具体的期限。</li><li>集中学习语言时，使用迷你任务去专注解决眼前的最大问题。</li><li>如果你的全部时间都用来学习，就要保证休息，不要把自己搞得精疲力竭。</li><li>向外界展示你的学习任务，让朋友和家人监督你。</li></ul><h3 id="我的计划"><a href="#我的计划" class="headerlink" title="我的计划"></a><strong>我的计划</strong></h3><p>因为我最近刚好处于择业期，而且技术上有很多短板需要补齐，所以主要学习内容还是专业技术，语言则作为另一项同时进行的学习任务。</p><p><strong>我会把学习周期定为6个月，每天一个小时的语言学习时间。</strong>也就是明年3到4月份验收成果。</p><hr><p>内容来源：</p><p>🔗 《跟各国人都聊得来-三个月外语流利术》</p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>职业规划</title>
    <link href="http://linyishui.top/2020090401.html"/>
    <id>http://linyishui.top/2020090401.html</id>
    <published>2020-09-04T06:28:26.000Z</published>
    <updated>2020-09-04T08:05:56.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a><strong>职业规划</strong></h1><h2 id="岗位选择"><a href="#岗位选择" class="headerlink" title="岗位选择"></a><strong>岗位选择</strong></h2><p>目前情况：Java后端开发，2年工作经验。</p><p>一年后：Java后端 / 大数据开发 ，3年工作经验</p><h2 id="设定目标"><a href="#设定目标" class="headerlink" title="设定目标"></a><strong>设定目标</strong></h2><p>统计岗位薪酬数据：</p><table><thead><tr><th>Java</th><th>北京</th><th>上海</th><th>杭州</th></tr></thead><tbody><tr><td>1-3年年收入-10分位</td><td>79.948</td><td>76.488</td><td>71.014</td></tr><tr><td>1-3年年收入-25分位</td><td>106.167</td><td>100.479</td><td>94.989</td></tr><tr><td>1-3年年收入-50分位</td><td>146.831</td><td>137.871</td><td>130.364</td></tr><tr><td>1-3年年收入-75分位</td><td>208.853</td><td>186.494</td><td>181.281</td></tr><tr><td>1-3年年收入-90分位</td><td>287.424</td><td>251.109</td><td>247.048</td></tr><tr><td>1-3年月平均收入和人数占比</td><td>13.904/19%</td><td>12.900/22%</td><td>12.608/32%</td></tr><tr><td>3-5年月平均收入和人数占比</td><td>18.544/56%</td><td>17.661/56%</td><td>18.103/55%</td></tr><tr><td>5-10年月平均收入和人数占比</td><td>25.207/24%</td><td>24.766/21%</td><td>24.068/12%</td></tr><tr><td>人数样本</td><td>4162601</td><td>2270467</td><td>1604825</td></tr></tbody></table><p><em>数据来源：Boss直聘</em></p><p>设定岗位筛选条件：3-5年经验，20k以上。</p><h2 id="统计要求"><a href="#统计要求" class="headerlink" title="统计要求"></a><strong>统计要求</strong></h2><table><thead><tr><th>要求</th><th>子项</th><th>掌握程度</th><th>次数</th></tr></thead><tbody><tr><td>工龄</td><td>3年</td><td></td><td>12</td></tr><tr><td>学历</td><td>本科</td><td></td><td>7</td></tr><tr><td>Java</td><td>基础</td><td>基础扎实，JDK源码，多态</td><td>11</td></tr><tr><td></td><td>IO</td><td></td><td>5</td></tr><tr><td></td><td>并发/多线程</td><td></td><td>6</td></tr><tr><td></td><td>集合</td><td></td><td>4</td></tr><tr><td></td><td>JVM</td><td>了解原理</td><td>5</td></tr><tr><td></td><td>网络编程</td><td></td><td>2</td></tr><tr><td>Web框架</td><td>Web开发</td><td>深入了解底层实现</td><td>9</td></tr><tr><td></td><td>Spring</td><td></td><td>8</td></tr><tr><td></td><td>SpringMVC</td><td></td><td>2</td></tr><tr><td></td><td>SpringBoot</td><td></td><td>5</td></tr><tr><td>ORM</td><td>Mybatis</td><td>深入了解底层实现</td><td>7</td></tr><tr><td>数据库</td><td>任一</td><td>熟悉数据库优化</td><td>10</td></tr><tr><td></td><td>Mysql</td><td></td><td>8</td></tr><tr><td></td><td>Oracle</td><td></td><td>4</td></tr><tr><td></td><td>db2</td><td></td><td>2</td></tr><tr><td></td><td>sql优化</td><td></td><td>1</td></tr><tr><td>分布式系统</td><td>项目</td><td>熟悉设计和应用</td><td>6</td></tr><tr><td></td><td>监控、部署</td><td></td><td>1</td></tr><tr><td></td><td>负载均衡</td><td></td><td>1</td></tr><tr><td>分布式缓存</td><td>任一</td><td>熟练使用，优化</td><td>9</td></tr><tr><td></td><td>Redis</td><td></td><td>6</td></tr><tr><td></td><td>Memcache</td><td></td><td>2</td></tr><tr><td></td><td>MongoDB</td><td></td><td>2</td></tr><tr><td></td><td>Hbase</td><td></td><td>1</td></tr><tr><td>消息队列</td><td>任一</td><td>熟悉解决方案及应用场景</td><td>9</td></tr><tr><td></td><td>RabbitMQ</td><td></td><td>4</td></tr><tr><td></td><td>ActiveMQ</td><td></td><td>1</td></tr><tr><td></td><td>Kafka</td><td></td><td>2</td></tr><tr><td>Web服务器</td><td>Nginx</td><td>优化配置与使用</td><td>2</td></tr><tr><td></td><td>Tomcat</td><td></td><td>2</td></tr><tr><td></td><td>缓存服务器</td><td></td><td>1</td></tr><tr><td>中间件</td><td>Elasticsearch</td><td>使用和原理</td><td>1</td></tr><tr><td>UML</td><td></td><td>熟悉</td><td>1</td></tr><tr><td>设计模式</td><td></td><td>了解</td><td>1</td></tr><tr><td>微服务</td><td>任一</td><td></td><td>5</td></tr><tr><td></td><td>Dubbo</td><td></td><td>3</td></tr><tr><td></td><td>Spring Cloud</td><td></td><td>2</td></tr><tr><td>工具</td><td>Docker</td><td>熟练掌握</td><td>1</td></tr><tr><td></td><td>K8s</td><td></td><td>1</td></tr><tr><td></td><td>Linux</td><td>熟悉操作，有Linux环境下多线程、并发、网络编程经验，常用命令</td><td>2</td></tr><tr><td>脚本语言</td><td>任一</td><td>熟悉</td><td>2</td></tr><tr><td></td><td>shell</td><td></td><td>2</td></tr><tr><td></td><td>php</td><td></td><td>1</td></tr><tr><td></td><td>python</td><td></td><td>1</td></tr><tr><td>前端</td><td>JS</td><td></td><td>2</td></tr><tr><td></td><td>Jquery</td><td></td><td>2</td></tr><tr><td></td><td>VUE</td><td></td><td>2</td></tr><tr><td>网络</td><td>基础</td><td></td><td>1</td></tr><tr><td></td><td>TCP/IP</td><td>原理</td><td>1</td></tr><tr><td>开源项目</td><td></td><td>有经验</td><td>2</td></tr><tr><td>高并发、高负载、高可用</td><td></td><td>设计和开发，优先</td><td>7</td></tr><tr><td>分布式队列</td><td></td><td>优先</td><td>1</td></tr><tr><td>分布式任务分发框架</td><td></td><td>优先</td><td>1</td></tr><tr><td>全文检索及分词</td><td></td><td>优先</td><td>1</td></tr><tr><td>海量数据存储和处理</td><td></td><td>优先</td><td>4</td></tr><tr><td>分布式存储</td><td></td><td>优先</td><td>1</td></tr><tr><td>Flink、Clickhouse</td><td></td><td>优先</td><td>1</td></tr><tr><td>Java EE、SOA、OSGI、jax-rs</td><td></td><td>熟悉相关技术</td><td>1</td></tr></tbody></table><h2 id="简单规划"><a href="#简单规划" class="headerlink" title="简单规划"></a><strong>简单规划</strong></h2><p>根据岗位要求进行简单规划，先学陌生的技术，再补不足。</p><p>需要学会和精通的技术：</p><ul><li>Java、集合、多线程、并发编程、网络编程、JVM、IO、NIO</li><li>Spring、Spring MVC、Spring Boot</li><li>MyBatis、MySql、Redis、RabbitMQ、ELK</li><li>Dubbo、Zookeeper 、Spring Cloud</li><li>Linux、Docker、k8s、shell</li><li>网络、操作系统、分布式系统、海量数据处理</li></ul><p>将以上内容补充到《<a href="../2018080801.html" title="Title">Java技术栈-学习路线</a>》。</p><p>最后罗列一下学习的优先级：</p><ul><li><p>需要系统学习：Mysql -&gt; RabbitMQ -&gt; Zookeeper + Dubbo -&gt; Spring Cloud -&gt; Redis</p></li><li><p>只要实战学习：MyBatis -&gt; ELK -&gt; Linux + shell -&gt; Docker -&gt; k8s</p></li></ul>]]></content>
    
    <summary type="html">
    
      简单整理一下Java职场信息，为自己设定一个一年后的目标。
    
    </summary>
    
      <category term="笔记杂谈" scheme="http://linyishui.top/categories/%E7%AC%94%E8%AE%B0%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="other" scheme="http://linyishui.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习dubbo（一）简介和搭建</title>
    <link href="http://linyishui.top/2020090301.html"/>
    <id>http://linyishui.top/2020090301.html</id>
    <published>2020-09-03T06:12:39.000Z</published>
    <updated>2020-10-02T08:15:00.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo（一）简介和搭建"><a href="#dubbo（一）简介和搭建" class="headerlink" title="dubbo（一）简介和搭建"></a><strong>dubbo（一）简介和搭建</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a><strong>1.1 背景</strong></h3><p>网站规模的扩大，技术架构经历了从<strong>单一应用架构</strong>到<strong>垂直应用架构</strong>，最后到<strong>分布式服务架构</strong>和<strong>流动计算架构</strong>的发展历程。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-roadmap.jpg" alt></p><ul><li><strong>单一应用架构</strong>：当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<ul><li>适合小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</li><li>缺点：<ul><li>性能扩展比较难</li><li>协同开发问题</li><li>不利于升级维护</li></ul></li></ul></li><li><strong>垂直应用架构</strong>：当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。<ul><li>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</li><li>缺点： 公用模块无法重复利用，开发性的浪费。</li></ul></li><li><strong>分布式服务架构</strong>：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架</strong>(RPC)是关键。</li><li><strong>流动计算架构</strong>：当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong>。</li></ul><p>分布式系统中每个功能模块之间有复杂的联系，需要有一个<strong>治理系统</strong>确保架构有条不紊的演进。</p><h3 id="1-2-RPC和RMI"><a href="#1-2-RPC和RMI" class="headerlink" title="1.2 RPC和RMI"></a><strong>1.2 RPC和RMI</strong></h3><p>RPC是指Remote Procedure Call Protocol，<strong>远程过程调用协议</strong>，是一种进程间通信方式。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>常见的开源框架包括：</p><ul><li><p>单语言：</p><ul><li><p><strong>RMI</strong>：Java RMI （Remote Method Invocation）- 远程方法调用，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化，能够<strong>让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法</strong>。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过<strong>依赖接口</strong>这种更简单自然的方式。</p></li><li><p><strong>Dubbo</strong>：阿里巴巴开发，只支持Java。</p></li><li><strong>Motan</strong>：微博开发，只支持Java。</li><li><strong>Tars</strong>：腾讯开发，只支持C++。</li><li><strong>Spring Cloud</strong>：Pivotal开发，只支持Java。</li></ul></li><li><p>跨语言：</p><ul><li><p><strong>gRPC</strong>：Google开发。</p></li><li><p><strong>Thrift</strong>：Facebook开发，它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的<a href="https://zh.wikipedia.org/wiki/跨平台" target="_blank" rel="noopener">跨平台</a>高效服务。以前是由Facebook开发的，但它现在是<a href="https://zh.wikipedia.org/wiki/Apache软件基金会" target="_blank" rel="noopener">Apache软件基金会</a>的开源项目了。</p></li><li><p><strong>Avro</strong>：一种远程过程调用和数据序列化框架，是在Apache的Hadoop项目之内开发的。它使用JSON来定义数据类型和通讯协议，使用压缩二进制格式来序列化数据。它主要用于Hadoop，它可以为持久化数据提供一种序列化格式，并为Hadoop节点间及从客户端程序到Hadoop服务的通讯提供一种电报格式。</p><p>它类似于Thrift，但当数据库模式改变时，它不要求运行代码生成程序，除非是对静态类型的语言。</p></li></ul></li></ul><h4 id="（1）RMI工作原理"><a href="#（1）RMI工作原理" class="headerlink" title="（1）RMI工作原理"></a><strong>（1）RMI工作原理</strong></h4><ol><li>服务端向 RMI 注册服务绑定自己的地址，</li><li>客户端通过 RMI 注册服务获取目标地址，</li><li>客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致，</li><li>本地存根对象将调用信息打包，通过网络发送到服务端，</li><li>服务端的 Skeleton 对象收到网络请求之后，将调用信息解包，</li><li>然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。</li></ol><p>服务之间的远程调用有两个关键部分：</p><ul><li>服务间通信：客户端与服务端要建立网络连接，并传递数据。所以通信效率决定着RPC框架的性能（如传递二进制流要快于XML或JSON）</li><li>对象序列化与反序列化：参数对象在网络中传递要进行序列化，接收到后要反序列化解析。所以序列化效率也决定着RPC框架的性能。</li></ul><h4 id="（2）RMI基本概念"><a href="#（2）RMI基本概念" class="headerlink" title="（2）RMI基本概念"></a><strong>（2）RMI基本概念</strong></h4><ol><li>通过<strong>接口</strong>进行远程调用：客户端需要依赖接口，而服务端需要提供该接口的实现。</li><li>通过客户端的 <strong>Stub 对象</strong>和服务端的 <strong>Skeleton 对象</strong>的帮助将远程调用伪装成本地调用：在 J2SE 1.5 版本之前需要通过 rmic 预先编译好客户端的 Stub 对象和服务端的 Skeleton 对象。在之后的版本中，不再需要事先生成 Stub 和 Skeleton 对象。</li><li>通过 <strong>RMI 注册服务</strong>完成服务的注册和发现。</li></ol><p>服务端注册方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化服务对象实例</span></span><br><span class="line">Hello obj = <span class="keyword">new</span> HelloImpl(); </span><br><span class="line"><span class="comment">// 生成可以与服务端通讯的 Stub 对象</span></span><br><span class="line">Hello stub = (Hello) UnicastRemoteObject.exportObject(obj, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// 创建一个本地的 RMI 注册服务，监听端口为 1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程</span></span><br><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>); </span><br><span class="line"><span class="comment">// 将 Stub 对象绑定到注册服务上，这样，客户端可以通过 *Hello* 这个名字查找到该远程对象</span></span><br><span class="line">registry.rebind(<span class="string">"Hello"</span>, stub);</span><br></pre></td></tr></table></figure><p>客户端的服务发现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取注册服务实例，在本例中，由于没有传入任何参数，假定要获取的注册服务实例部署在本机，并监听在 1099 端口上</span></span><br><span class="line">Registry registry = LocateRegistry.getRegistry();</span><br><span class="line"><span class="comment">// 从注册服务中查找服务名为 *Hello* 的远程对象</span></span><br><span class="line">Hello stub = (Hello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 通过获取的 Stub 对象发起一次 RMI 调用并获得结果</span></span><br><span class="line">String response = stub.sayHello();</span><br></pre></td></tr></table></figure><h3 id="1-3-为什么需要Dubbo？"><a href="#1-3-为什么需要Dubbo？" class="headerlink" title="1.3 为什么需要Dubbo？"></a><strong>1.3 为什么需要Dubbo？</strong></h3><p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p><p><strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</strong> 此时<strong>需要一个服务注册中心（Eureka、Zookeeper），动态地注册和发现服务，使服务的位置透明</strong>。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p><p><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。</p><p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-service-governance.jpg" alt></p><p>dubbo的核心特性：</p><ul><li><strong>远程方法调用</strong>：面向接口代理的高性能RPC调用，使用时只需调用接口即可。</li><li><strong>智能负载均衡</strong>：同一个服务可能有多台服务器在运行，每台服务器有不同的工作状态，负载均衡会尽量的挑选休闲的服务器。</li><li><strong>服务自动注册和发现</strong>：所有服务都要注册到中心，中心负责管理所有服务的生命周期，服务部署在哪些服务器这些信息可以在中心获取。</li><li><strong>高度可扩展</strong>：遵循微内核和插件的设计原则，核心功能如Protocol、Transport、Serialization都被设计为扩展点，同等对待内置实现和第三方实现。</li><li><strong>运行期流量调度</strong>：内置条件、脚本等路由策略，通过配置不同的路由规则，实现灰度发布、同机房优先等功能。</li><li><strong>可视化的服务治理与运维</strong>：提供丰富的服务治理、运维工具：随时查询服务元数据、服务健康状态以及调用统计，实时下发路由策略、调整配置参数。</li></ul><h3 id="1-4-技术架构"><a href="#1-4-技术架构" class="headerlink" title="1.4 技术架构"></a><strong>1.4 技术架构</strong></h3><p>如下图所示，每个节点角色之间的关系，注意只有消费者调用服务是同步，其他都是异步操作。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt="dubbo-architucture"></p><h5 id="节点角色说明"><a href="#节点角色说明" class="headerlink" title="节点角色说明"></a>节点角色说明</h5><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Provider</code></td><td>暴露服务的<strong>服务提供方</strong></td></tr><tr><td><code>Consumer</code></td><td>调用远程服务的<strong>服务消费方</strong></td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的<strong>注册中心</strong></td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的<strong>监控中心</strong></td></tr><tr><td><code>Container</code></td><td><strong>服务运行容器</strong></td></tr></tbody></table><h5 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h5><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。</p><h5 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h5><ul><li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li><li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li><li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li><li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li><li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li><li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li><li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li><li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li></ul><h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ul><h5 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h5><ul><li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li><li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li></ul><h5 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h5><p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-future.jpg" alt="dubbo-architucture-futures"></p><h5 id="节点角色说明-1"><a href="#节点角色说明-1" class="headerlink" title="节点角色说明"></a>节点角色说明</h5><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Deployer</code></td><td>自动部署服务的本地代理</td></tr><tr><td><code>Repository</code></td><td>仓库用于存储服务应用发布包</td></tr><tr><td><code>Scheduler</code></td><td>调度中心基于访问压力自动增减服务提供者</td></tr><tr><td><code>Admin</code></td><td>统一管理控制台</td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的注册中心</td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的监控中心</td></tr></tbody></table><hr><h2 id="第二节-入门"><a href="#第二节-入门" class="headerlink" title="第二节 入门"></a><strong>第二节 入门</strong></h2><p>项目地址：<a href="https://github.com/apache" target="_blank" rel="noopener">apache</a>/<strong><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">dubbo</a></strong></p><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a><strong>2.1 安装</strong></h3><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/dubbo.git</span><br><span class="line"><span class="built_in">cd</span> dubbo/dubbo-demo/dubbo-demo-xml</span><br><span class="line">运行 dubbo-demo-xml-provider中的org.apache.dubbo.demo.provider.Application</span><br><span class="line">如果使用Intellij Idea 请加上-Djava.net.preferIPv4Stack=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resources/spring/dubbo-provider.xml</span><br><span class="line">修改其中的dubbo:registry，替换成真实的注册中心地址，推荐使用zookeeper，如：</span><br><span class="line">&lt;dubbo:registry address=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span><br></pre></td></tr></table></figure><p>通过Idea打开项目，等待依赖下载完毕后按官网教程启动 <code>dubbo-demo-xml-provider</code> 。</p><p>启动失败，报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\WorkPlace\FromGitHub\dubbo-master\dubbo-config\dubbo-config-api\src\<span class="built_in">test</span>\java\org\apache\dubbo\config\bootstrap\rest\UserService.java</span><br><span class="line">Error:(22, 50) java: 程序包org.apache.dubbo.rpc.protocol.rest.support不存在</span><br><span class="line">Error:(37, 12) java: 找不到符号</span><br><span class="line">  符号: 变量 ContentType</span><br><span class="line">Error:(37, 48) java: 找不到符号</span><br><span class="line">  符号: 变量 ContentType</span><br></pre></td></tr></table></figure><p>找到（dubbo-config-api）<code>pom.xml</code> 并注释掉所有Maven的test作用域。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- FIXME, we shouldn't rely on these modules, even in test scope --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-rpc-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启，OK上述错误不再提示，但有了新的错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error:(26, 52) java: 程序包org.apache.dubbo.common.serialize.nativejava不存在</span><br><span class="line">Error:(99, 43) java: 找不到符号</span><br><span class="line">  符号:   类 NativeJavaSerialization</span><br><span class="line">  位置: 类 org.apache.dubbo.rpc.protocol.hessian.HessianProtocolTest</span><br><span class="line">Warning:(110, 59) java: org.apache.dubbo.common.serialize.ObjectInput中的readObject()已过时</span><br></pre></td></tr></table></figure><p>找到（dubbo-rpc-rest）<code>pom.xml</code> 并注释掉test作用域。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-serialization-jdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次启动，OK顺利运行。</p><h3 id="2-2-简单使用"><a href="#2-2-简单使用" class="headerlink" title="2.2 简单使用"></a><strong>2.2 简单使用</strong></h3><h4 id="（1）服务提供者"><a href="#（1）服务提供者" class="headerlink" title="（1）服务提供者"></a><strong>（1）服务提供者</strong></h4><p>找到 <code>dubbo-demo-interface</code> 子项目，其中有定义接口 <code>DemoService.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(sayHello(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到 <code>dubbo-demo-api</code> 子项目，其中有定义接口实现 <code>DemoServiceImpl.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.rpc.RpcContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Hello "</span> + name + <span class="string">", request from consumer: "</span> + RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">", response from provider: "</span> + RpcContext.getContext().getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过Spring的xml配置来将服务暴露，<code>provider.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.demo.provider.DemoServiceImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后在 <code>dubbo-demo-xml-provider</code> 启动类加载Spring配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/dubbo-provider.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）服务消费者"><a href="#（2）服务消费者" class="headerlink" title="（2）服务消费者"></a><strong>（2）服务消费者</strong></h4><p>首先通过 Spring 配置引用远程服务 dubbo-consumer.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer-of-helloworld-app"</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment">  contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment">  this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment">  The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment">  (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment">  the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"mapping-type"</span> <span class="attr">value</span>=<span class="string">"metadata"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"enable-auto-migration"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    &lt;dubbo:metadata-report address="zookeeper://127.0.0.1:2181"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">provided-by</span>=<span class="string">"demo-provider"</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">provided-by</span>=<span class="string">"demo-provider"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">group</span>=<span class="string">"greeting"</span> <span class="attr">id</span>=<span class="string">"greetingService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.GreetingService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后加载Spring配置，并调用远程服务Consumer.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"META-INF/spring/dubbo-demo-consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = (DemoService)context.getBean(<span class="string">"demoService"</span>); <span class="comment">// 获取远程服务代理</span></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// 执行远程方法</span></span><br><span class="line">        System.out.println( hello ); <span class="comment">// 显示调用结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.GreetingService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before</span></span><br><span class="line"><span class="comment">     * launch the application</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/dubbo-consumer.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = context.getBean(<span class="string">"demoService"</span>, DemoService.class);</span><br><span class="line">        GreetingService greetingService = context.getBean(<span class="string">"greetingService"</span>, GreetingService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String greetings = greetingService.hello();</span><br><span class="line">                System.out.println(greetings + <span class="string">" from separated thread."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            CompletableFuture&lt;String&gt; hello = demoService.sayHelloAsync(<span class="string">"world"</span>);</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + hello.get());</span><br><span class="line"></span><br><span class="line">            String greetings = greetingService.hello();</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + greetings);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li>该接口需单独打包，在服务提供方和消费方共享 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref1" target="_blank" rel="noopener">↩︎</a></li><li>对服务消费方隐藏实现 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref2" target="_blank" rel="noopener">↩︎</a></li><li>也可以使用 IoC 注入 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref3" target="_blank" rel="noopener">↩︎</a></li></ol><hr><p>参考：</p><p>🔗 <a href="http://dubbo.apache.org/zh-cn/docs/user/dependencies.html" target="_blank" rel="noopener">Dubbo官网-文档</a></p><p>🔗 <a href="http://jm.taobao.org/2018/06/13/%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">第一个 Dubbo 应用</a></p>]]></content>
    
    <summary type="html">
    
      从零开始学习Dubbo，第一章《简介和搭建》
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="dubbo" scheme="http://linyishui.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（一）启程</title>
    <link href="http://linyishui.top/2020090101.html"/>
    <id>http://linyishui.top/2020090101.html</id>
    <published>2020-09-01T10:14:30.000Z</published>
    <updated>2020-10-02T08:16:26.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="启程"><a href="#启程" class="headerlink" title="启程"></a><strong>启程</strong></h1><h3 id="为什么要学习英语？"><a href="#为什么要学习英语？" class="headerlink" title="为什么要学习英语？"></a><strong>为什么要学习英语？</strong></h3><p>今天，当我终于下定决心要开始学习英语时，我发现最开始想要学习一门外语到现在已经过去了将近5年的时间。大部分人应该和我一样虽然会觉得自己应该至少学习一门外语，但在思考这个问题时，<strong>总是会想在一个更合适的时间开始学习</strong>。</p><p>在逃避学习的这段时间里，我有时忙于玩乐，有时忙于工作，一直在焦虑和麻木的状态中生活。时间来到这个月，我处于人生中的第二个求职阶段，面试的不顺利和内心的不甘心，让我突然发现，<strong>人生中的大部分时间我都是在被迫学习</strong>：少年时因为要考试而去学习；成年后进入大学，又为了奖学金而短暂学习过；工作后为了更好的岗位和薪水而去强迫自己学习。<strong>我还从来没有因为想要学一个东西而去认真的实现这个想法，这让我意识到不管明天会怎样，我都要从今天开始我的学习计划了</strong>。</p><p>我为自己想了几个学习英语的目的：</p><ul><li>为了和英语世界的人交流，认识更多的朋友。</li><li>不局限于中文环境，去见识和了解到更大范围的世界。</li><li>无障碍的看懂美剧而不用盯着字幕，可以听懂英文歌曲。</li><li>将来有更多的工作机会，以及在其他环境生活的机会。</li><li>增强自信心，提高我对自己的自我评价。</li></ul><p>我首先选择了一本在大学时就收藏的书籍《跟各国人都聊得来-三个月外语流利术》，在开启英语学习之路上，先汲取一下在同样事情上成功的人的经验。</p><hr><h3 id="学习语言的错误观点"><a href="#学习语言的错误观点" class="headerlink" title="学习语言的错误观点"></a><strong>学习语言的错误观点</strong></h3><p><strong>我们为学不会一种语言找的借口往往是对自我的错误认知。</strong></p><h4 id="观点1：年纪太大，不利于学习语言"><a href="#观点1：年纪太大，不利于学习语言" class="headerlink" title="观点1：年纪太大，不利于学习语言"></a>观点1：年纪太大，不利于学习语言</h4><p>这种观点从来没有理论或科学研究的支持，实际上无论学习什么东西，成年人都要比小孩子更有优势，因为我们成年人不是从零开始学习第一语音。根据研究，93%的情感交流都不是通过语言完成的，比如笑也是一种信息的传递方式，成年人不用再花大量时间去学习如何与人交流。</p><p><strong>相比于孩子，成年人要学习的内容更少。</strong>成年人有更多的学习经验应用到学习语言上面，成年人比孩子更有分析力。相反，成年人应该学习孩子不害怕犯错误这一点，享受学习的过程，不要害怕尴尬。</p><h4 id="观点2：我没有学习语言的天赋"><a href="#观点2：我没有学习语言的天赋" class="headerlink" title="观点2：我没有学习语言的天赋"></a>观点2：我没有学习语言的天赋</h4><p>事实上，所有人都有学习语言的天赋，在一些多语种的国家，人们都能在很多语言之间自由的切换，比如卢森堡的学生在毕业时能流利的使用法语、德语、卢森堡语。</p><p>我们在学习刚开始就要抛开这种自我怀疑。</p><h4 id="观点3：我没有时间"><a href="#观点3：我没有时间" class="headerlink" title="观点3：我没有时间"></a>观点3：我没有时间</h4><p>大部分人都有工作要做，这是一个很好的接口。但事实上，大部分学习语言很成功的人都有正式的工作，或是操持家务、照顾家人。</p><p>只要真正的抽出时间去学习，你就能取得进步。比如看电视、浏览各种APP、打游戏等等，这些活动占用了我们大量的时间，甚至还有一些是无意义的活动，还有如等电梯、坐公交车、地铁等。即使是几分钟的时间，用来学习几个单词或日常用语也是足够的。</p><p><strong>当你真正想要学习一门语言时，每一分钟都是可以利用的。</strong></p><p>当然，花几个月的时间去做一件事很不错，但如果没有这个条件，请尽量把能用的时间利用起来，虽然周期会长一些，但你总能达到目标的。</p><h4 id="观点4：学语言是有钱人的专利"><a href="#观点4：学语言是有钱人的专利" class="headerlink" title="观点4：学语言是有钱人的专利"></a>观点4：学语言是有钱人的专利</h4><p>昂贵的课程和学习产品并不比网上的免费工具、博客、以及和外国朋友聊天更有帮助。</p><h4 id="观点5：我在等待完美的语言课程"><a href="#观点5：我在等待完美的语言课程" class="headerlink" title="观点5：我在等待完美的语言课程"></a>观点5：我在等待完美的语言课程</h4><p>没有完美的课程，即使是优秀的语言课程能教给你的东西也是有限的，而且它<strong>并不比你努力学习更有效果</strong>。</p><h4 id="观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败"><a href="#观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败" class="headerlink" title="观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败"></a>观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败</h4><p><strong>最重要的事情是你终于开始学习了</strong>，而早期的错误并没有什么关系。遇到挫折，果断的去解决它，振作精神，重新开始，只要再坚持一下就可以了。</p><p><strong>不要把精力投入到研究哪种学习方法更好，而是把精力投入到学习和使用语言上面。</strong></p><h4 id="观点7：只有学到一定程度，我才能开始练习对话"><a href="#观点7：只有学到一定程度，我才能开始练习对话" class="headerlink" title="观点7：只有学到一定程度，我才能开始练习对话"></a>观点7：只有学到一定程度，我才能开始练习对话</h4><p>事实上，<strong>从学习的第一天开始，你就要尝试去说</strong>。这和传统认知并不相符，<strong>因为你永远不会有准备好的那一天</strong>，哪怕你已经掌握了一门语言，你还是能证明自己没有准备好，单词是永远也学不完的，语法也有很多的学习空间，发音也要更多的练习。</p><p><strong>要从现在就开始尽量去使用自己所学的语言，而不是等待很多年。</strong></p><h4 id="观点8：我不能集中精力"><a href="#观点8：我不能集中精力" class="headerlink" title="观点8：我不能集中精力"></a>观点8：我不能集中精力</h4><p><strong>只专注于眼前的任务，不管有多大的诱惑。</strong>一些优秀的人才也只是把各种兴趣爱好安排好，按照次序一一完成，而不是同时去做很多事情。他们也只是有耐心的、有条理的去做。</p><h4 id="观点9：有些语言太难了"><a href="#观点9：有些语言太难了" class="headerlink" title="观点9：有些语言太难了"></a>观点9：有些语言太难了</h4><p>没有人能在这种无意义的比较中获益，事实上即使是公认的难学习的语种也有很多人在使用它来交流。如果你正在学习一门语言，请忘掉其他学过的语言，集中热情在它上面吧！</p><h4 id="观点10：瓶颈期不可避免"><a href="#观点10：瓶颈期不可避免" class="headerlink" title="观点10：瓶颈期不可避免"></a>观点10：瓶颈期不可避免</h4><p>学习中确实难免遇到瓶颈期，初学者不会遇到此问题，直到有所进步后，比如能够交流后就停滞在那里了。这很可能是我们过往的学习方法在此阶段不再适合了，<strong>“愚蠢”的行为就是一直重复用同样的方法做事，却期望得到不同的结果</strong>。</p><p>不要怕，大胆的改变，改变练习的频率，改变对话的对象。</p><h4 id="观点11：完全掌握是不可能的任务"><a href="#观点11：完全掌握是不可能的任务" class="headerlink" title="观点11：完全掌握是不可能的任务"></a>观点11：完全掌握是不可能的任务</h4><p>如果说学一门语言，就是要用它来辩论各种哲学思想，并且不带一丝口音和停顿的话，那么这确实会花费上数十年。</p><p>但请仔细想想，<strong>你对自己的母语有掌握到什么样的程度，再想想为什么要对一门外语有这样的高要求？</strong></p><p>请把目标放在简单对话，再朝着流利的方向努力。</p><h4 id="观点12：学习过程很枯燥"><a href="#观点12：学习过程很枯燥" class="headerlink" title="观点12：学习过程很枯燥"></a>观点12：学习过程很枯燥</h4><p><strong>语言学习并不枯燥，也许只是你的方法枯燥而已。</strong>比如试试听音乐、看动画片、看电影、读杂志、看笑话。找一个互相帮助的伙伴，或者任何能调动你积极性的方式。</p><h4 id="观点13：当地人不会理我"><a href="#观点13：当地人不会理我" class="headerlink" title="观点13：当地人不会理我"></a>观点13：当地人不会理我</h4><p><strong>请记住，你永远也不会准备好，永远都有要学的东西，所以你可以一直给自己找借口。</strong>这种恶性循环导致很多人学了很多年也不敢开口说话。</p><p>现实中，大家往往会鼓励你、帮助你，会很有耐心和包容。比如你是那个本地人，当你遇到一个尝试努力学习你的母语的外人时，你会有怎样的感受？</p><h4 id="观点14：我总是有口音"><a href="#观点14：我总是有口音" class="headerlink" title="观点14：我总是有口音"></a>观点14：我总是有口音</h4><p>实际上有点口音是好事，这并不影响交流。即使是母语也存在很多发音问题，他们也有各种各样的口音。</p><h4 id="观点15：我的家人朋友不支持我"><a href="#观点15：我的家人朋友不支持我" class="headerlink" title="观点15：我的家人朋友不支持我"></a>观点15：我的家人朋友不支持我</h4><p>这个问题没有很好的解决方法，但你可以尽量的阐述自己很喜欢这门语言，表示出你认真的态度，如果对方能理解也许他们会支持你。</p><p>如果你得不到他们的支持，请相信在这个世界上有很多和你一样怀抱相同梦想的人，你会找到支持和理解的。</p><h4 id="观点16：每个人都说英语-汉语"><a href="#观点16：每个人都说英语-汉语" class="headerlink" title="观点16：每个人都说英语/汉语"></a>观点16：每个人都说英语/汉语</h4><p>学会一门新的语言，并不仅仅意味着你收获了这些知识，它会为你带来新的机会和体验。</p><h4 id="观点17：我跟不上比人的脚步"><a href="#观点17：我跟不上比人的脚步" class="headerlink" title="观点17：我跟不上比人的脚步"></a>观点17：我跟不上比人的脚步</h4><p>把自己和别人作比较这种行为本身就很有问题，但这是人的本性。但你要明白，你看到的只是别人展示给你的一面，他们分享经历时，只会说遇到的各种困难，已显示出其高大的形象。</p><p>遇到困难时，请抛弃“成功的人不会面对这样的问题，我还是放弃吧”这样的想法。而应该问自己“成功的人会怎么解决这个困难呢？”。</p><h4 id="观点18：以前失败，现在还会失败"><a href="#观点18：以前失败，现在还会失败" class="headerlink" title="观点18：以前失败，现在还会失败"></a>观点18：以前失败，现在还会失败</h4><p>如果你以前尝试过学习语言，但最终失败了。你可能会觉得自己不擅长学习语言，但请相信这只能说明过去的方法并不适合你。</p><p><strong>没有一种方法是完美适合每一个语言学习者的。</strong>如果你尝试着某种方法，但根本不起作用，请果断的放弃，并试着换另一种方法。</p><p><strong>请明白失败的并不是你这个人，而是你在用的方法。</strong>请在遇到问题时，多和别人交流，书本并不能解决所有的问题。有可能解决方案在你的已知的知识世界以外，而一个学过的人可以帮你轻松的跨过这个难关。</p><h4 id="观点19：一旦忘了某种语言，我就不可能再重新学会它了"><a href="#观点19：一旦忘了某种语言，我就不可能再重新学会它了" class="headerlink" title="观点19：一旦忘了某种语言，我就不可能再重新学会它了"></a>观点19：一旦忘了某种语言，我就不可能再重新学会它了</h4><p>我们小时候学过的语言，后面没有再学，所以总觉得错过了学习它的最佳机会。但其实只要重新开始努力，你会比初次更顺利的学好这门语言。</p><h4 id="观点20：残障人士学语言比正常人更难"><a href="#观点20：残障人士学语言比正常人更难" class="headerlink" title="观点20：残障人士学语言比正常人更难"></a>观点20：残障人士学语言比正常人更难</h4><p>我们会觉得自己有某种缺陷，在学习语言时会和别人不同。但现实中，很多残疾人士都能很好的克服身体上的缺陷，这些问题在你因为它而止步不前时是难以克服的难关，但请相信在你开始不断尝试之后，总会找到出路的。</p><hr><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a><strong>感受</strong></h3><blockquote><p><strong>不管你觉得自己行或不行，你都是对的。</strong></p><p>​                                                                ——亨利 · 福特</p></blockquote><p>语言学习需要面对挑战，需要付出努力，如果我们确信自己不行，那我们也失去了信心和热情，悲观主义情绪已经占了上风，我们也就注定学不好这种语言了。请大胆的承认失败，不要给自己找没有学好的借口。不管你遇到什么困难，别人都可能遇到过，并且克服过这个困难。</p><p>Benny Lewis的观点很能说动现在的我，好像每个问题都是我曾用来逃避的理由，但还好我现在比起以前有了些许的改变，也许迈出第一步之后，就是焕然一新的自己。</p><p>不仅仅是语言学习，这些常识性的问题在大多数学习场景都是雷同的，我们要克服的是自己的懦弱和懒惰。如果你是一个自命不凡的人，或者只是对现在的自己不够满意，就请不要再浪费时间在准备阶段了，尝试的去做吧。</p><hr><p>内容来源：</p><p>🔗 《跟各国人都聊得来-三个月外语流利术》</p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>大数据量表的优化思路</title>
    <link href="http://linyishui.top/2020082201.html"/>
    <id>http://linyishui.top/2020082201.html</id>
    <published>2020-09-01T05:32:46.000Z</published>
    <updated>2020-10-02T08:22:21.855Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="大数据量表的优化思路"><a href="#大数据量表的优化思路" class="headerlink" title="大数据量表的优化思路"></a><strong>大数据量表的优化思路</strong></h1><h2 id="第一节-问题描述"><a href="#第一节-问题描述" class="headerlink" title="第一节 问题描述"></a><strong>第一节 问题描述</strong></h2><h2 id="1-1-常见问题"><a href="#1-1-常见问题" class="headerlink" title="1.1 常见问题"></a><strong>1.1 常见问题</strong></h2><ol><li>单表数据量达到千万级别后，查询操作耗时过久。</li><li>针对海量的数据表进行修改操作。</li></ol><h2 id="1-2-MySql模拟"><a href="#1-2-MySql模拟" class="headerlink" title="1.2 MySql模拟"></a><strong>1.2 MySql模拟</strong></h2><p>创建千万条模拟数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#创建MyISAM模式表方便批量跑数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`logs1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`logtype`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logurl`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logip`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logdz`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ladduser`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lfadduser`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`laddtime`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`htmlname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM  AUTO_INCREMENT=<span class="number">1811</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'日志表'</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#创建存储过程</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_insert;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> n <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> in_dateTime <span class="keyword">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="string">'2020-01-01 00:00:00'</span>;</span><br><span class="line">        while n &lt;= 10000000 do</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`logs1`</span>(<span class="string">`logtype`</span>,<span class="string">`logurl`</span>,<span class="string">`logip`</span>,<span class="string">`logdz`</span>,<span class="string">`ladduser`</span> ,<span class="string">`lfadduser`</span>,<span class="string">`laddtime`</span>,<span class="string">`htmlname`</span>) <span class="keyword">VALUES</span> (<span class="keyword">FLOOR</span>(<span class="number">1</span> + (<span class="keyword">RAND</span>() * <span class="number">2</span>)), <span class="string">'/index'</span>, <span class="string">'0:0:0:0:0:0:0:1'</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">'null'</span>, in_dateTime, <span class="string">'首页'</span>);</span><br><span class="line">            <span class="keyword">set</span> in_dateTime = in_dateTime + <span class="built_in">interval</span> <span class="number">1</span> MINUTE_SECOND;</span><br><span class="line">            <span class="keyword">SET</span> n = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"> </span><br><span class="line">#执行存储过程</span><br><span class="line"><span class="keyword">CALL</span> my_insert();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#数据插入成功后修改表模式InnoDB 时间稍微久点</span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`logs1`</span> <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查询表中行数，用时2.6s左右</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> logs1;</span><br><span class="line"></span><br><span class="line">#分页查询，id从1811开始，查询第6001条到6010条数据，用时0.025s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">6000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时0.048s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">60000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时0.256s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">600000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时4.372s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">9000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。</strong></p><hr><h2 id="第二节-解决流程"><a href="#第二节-解决流程" class="headerlink" title="第二节 解决流程"></a><strong>第二节 解决流程</strong></h2><h2 id="2-1-索引"><a href="#2-1-索引" class="headerlink" title="2.1 索引"></a><strong>2.1 索引</strong></h2><p>explain得知查询并未走索引，首先增加索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># type=all全表查询，先创建索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> logs1 <span class="keyword">where</span> logtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#增加唯一索引和普通索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_id (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_logtype (logtype)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_laddtime (laddtime)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_logtype</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_laddtime</span><br><span class="line"></span><br><span class="line">#<span class="keyword">type</span>是选择性低的属性，而<span class="keyword">time</span>则不是，所以索引的影响也不同</span><br><span class="line">#全表查询 <span class="number">5.073</span>-&gt;索引 <span class="number">4.226</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> logtype <span class="keyword">from</span> logs1 <span class="keyword">where</span> logtype &gt; <span class="number">1</span>;</span><br><span class="line">#ALL 3.566-&gt;range 0.426</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span>;</span><br></pre></td></tr></table></figure><p>索引并非万能的，如果我们查询的属性列是多个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#index 4.572</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,logtype,laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span>;</span><br><span class="line"></span><br><span class="line">#增加where后判断条件</span><br><span class="line">#0.966-&gt;0.853</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,logtype,laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span> <span class="keyword">and</span> <span class="keyword">id</span> &gt; <span class="string">'9001812'</span> <span class="keyword">and</span> logtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#创建组合索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_union (<span class="keyword">id</span>,logtype,laddtime)</span><br></pre></td></tr></table></figure><h2 id="2-2-优化SQL"><a href="#2-2-优化SQL" class="headerlink" title="2.2 优化SQL"></a><strong>2.2 优化SQL</strong></h2><p>避免select *，将需要查找的字段列出来</p><p>使用连接(join)来代替子查询</p><p>拆分大的delete或insert语句</p><p>通过开启慢查询日志来找出较慢的SQL</p><p>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</p><p>sql语句尽可能简单：一条sql只能在一个cpu运算;大语句拆小语句，减少锁时间;一条大sql可以堵死整个库</p><p>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</p><p>避免%xxx式查询</p><p>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p><p>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</p><p>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</p><h2 id="2-3-分区"><a href="#2-3-分区" class="headerlink" title="2.3 分区"></a><strong>2.3 分区</strong></h2><p>MySql 5.1版本引入，用户需要在建表的时候加上分区参数。分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。</p><p><strong>分区的好处是：</strong></p><ol><li>可以让单表存储更多的数据</li><li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li><li>部分查询能够从查询条件确定只落在少数分区上，速度会很快</li><li>分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备</li><li>可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li><li>可以备份和恢复单个分区</li></ol><p><strong>分区的限制和缺点：</strong></p><ol><li>一个表最多只能有1024个分区</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li>分区表无法使用外键约束</li><li>NULL值会使分区过滤无效</li><li>所有分区必须使用相同的存储引擎</li></ol><p><strong>分区的类型：</strong></p><ol><li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li><li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li><li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li><li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li><li>具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。</li></ol><h2 id="2-4-分表"><a href="#2-4-分表" class="headerlink" title="2.4 分表"></a><strong>2.4 分表</strong></h2><p>分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。</p><p>分表分为垂直拆分和水平拆分，通常以某个字段做拆分项。比如以id字段拆分为100张表： 表名为 tableName_id%100</p><p>但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高!!!而且选择这个方案，都不如选择我提供的第二第三个方案的成本低!故不建议采用。</p><h2 id="2-5-分库"><a href="#2-5-分库" class="headerlink" title="2.5 分库"></a><strong>2.5 分库</strong></h2><p>把一个数据库分成多个，建议做个读写分离就行了，真正的做分库也会带来大量的开发成本，得不偿失!不推荐使用。</p><h2 id="2-5-升级数据库"><a href="#2-5-升级数据库" class="headerlink" title="2.5 升级数据库"></a><strong>2.5 升级数据库</strong></h2><p>选用一款兼容MySql的高性能数据库。</p><h2 id="2-6-换大数据引擎处理数据"><a href="#2-6-换大数据引擎处理数据" class="headerlink" title="2.6 换大数据引擎处理数据"></a><strong>2.6 换大数据引擎处理数据</strong></h2><p>当数据量过亿，可能实现无法支撑，只能更换Hadoop等大数据引擎来代替传统数据库。</p><p>或者购买专业的大数据云解决方案，比较便宜省人力。</p><hr><p>参考：</p><p>🔗 <a href="https://database.51cto.com/art/201902/592522.htm" target="_blank" rel="noopener">记录一次MySQL两千万数据的大表优化解决过程，提供三种解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentSkipListMap</title>
    <link href="http://linyishui.top/2020070801.html"/>
    <id>http://linyishui.top/2020070801.html</id>
    <published>2020-07-08T08:56:37.000Z</published>
    <updated>2020-10-02T08:22:06.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a><strong>ConcurrentSkipListMap</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是ConcurrentSkipListMap"><a href="#1-1-什么是ConcurrentSkipListMap" class="headerlink" title="1.1 什么是ConcurrentSkipListMap"></a><strong>1.1 什么是ConcurrentSkipListMap</strong></h3><p>ConcurrentSkipListMap是由并发包提供的一种线程安全的并发容器，（优点）使我们能够<strong>以无锁方式实现线程安全</strong>，<strong>底层是通过跳表来实现</strong>的能够保证<strong>元素有序</strong>。</p><p>跳表是一个链表，但是通过使用<strong>“跳跃式”</strong>查找的方式使得插入、读取数据时复杂度变成了 <strong>O(logn)</strong> 。注意：<code>size()</code> 由于多个线程可以同时对映射进行操作，所以需要遍历整个映射才能返回元素个数，这是个 <strong>O(logn)</strong> 的操作。</p><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a><strong>1.2 简单使用</strong></h3><p>一个简单的实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ConcurrentSkipListMap&lt;Integer, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(</span><br><span class="line">            Comparator.comparingInt(v -&gt; v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过put添加</span></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(-<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">600</span>);</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//遍历线程集合，构建每个线程，每个线程都分别调用线程安全和不安全的计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="comment">//分别调用安全和不安全的计数器</span></span><br><span class="line">                    map.put(i, i + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历执行所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待所有线程执行完成</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印最终结果</span></span><br><span class="line">    map.forEach((k,v) -&gt; &#123;System.out.println(<span class="string">"k: "</span> + k + <span class="string">" v: "</span> + v);&#125;);</span><br><span class="line">    System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">98</span> <span class="string">v:</span> <span class="number">98</span></span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">82</span></span><br></pre></td></tr></table></figure><p>把 ConcurrentSkipListMap 替换为 TreeMap 。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line"><span class="string">k:</span> <span class="number">3</span> <span class="string">v:</span> <span class="number">3</span></span><br><span class="line"><span class="string">k:</span> <span class="number">4</span> <span class="string">v:</span> <span class="number">4</span></span><br><span class="line"><span class="string">k:</span> <span class="number">5</span> <span class="string">v:</span> <span class="number">5</span></span><br><span class="line"><span class="string">k:</span> <span class="number">6</span> <span class="string">v:</span> <span class="number">6</span></span><br><span class="line"><span class="string">k:</span> <span class="number">7</span> <span class="string">v:</span> <span class="number">7</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line"><span class="string">k:</span> <span class="number">8</span> <span class="string">v:</span> <span class="number">8</span></span><br><span class="line"><span class="string">k:</span> <span class="number">9</span> <span class="string">v:</span> <span class="number">9</span></span><br><span class="line"><span class="string">k:</span> <span class="number">10</span> <span class="string">v:</span> <span class="number">10</span></span><br><span class="line"><span class="string">k:</span> <span class="number">11</span> <span class="string">v:</span> <span class="number">11</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">50</span> <span class="string">v:</span> <span class="number">50</span></span><br><span class="line"><span class="string">k:</span> <span class="number">51</span> <span class="string">v:</span> <span class="number">51</span></span><br><span class="line"><span class="string">k:</span> <span class="number">52</span> <span class="string">v:</span> <span class="number">52</span></span><br><span class="line"><span class="string">k:</span> <span class="number">53</span> <span class="string">v:</span> <span class="number">53</span></span><br><span class="line"><span class="string">k:</span> <span class="number">54</span> <span class="string">v:</span> <span class="number">54</span></span><br><span class="line"><span class="string">k:</span> <span class="number">55</span> <span class="string">v:</span> <span class="number">55</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">56</span> <span class="string">v:</span> <span class="number">56</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">58</span> <span class="string">v:</span> <span class="number">58</span></span><br><span class="line"><span class="string">k:</span> <span class="number">59</span> <span class="string">v:</span> <span class="number">59</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">46</span></span><br></pre></td></tr></table></figure><p>可以得到一个初印象：TreeMap 多线程环境下非线程安全，但单线程的有序映射有较好的性能，而 ConcurrentSkipListMap 则可以在相同需求的多线程场景作为替代品。  </p><hr><h2 id="第二节-跳表"><a href="#第二节-跳表" class="headerlink" title="第二节 跳表"></a><strong>第二节 跳表</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h3><p> 跳表（SkipList）：是一种优秀的数据结构，<strong>使得包含n个元素的有序序列的查找和插入操作的平均时间复杂度都是 O(logn) ，要优于数组的 O(n) </strong>。</p><p>快速的查询效果是<strong>通过维护一个多层次的链表实现的</strong>，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少（见下图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择或确定性选择，其中前者更为常见。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010118.png" alt></p><p><em>一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。</em></p><h3 id="2-2-算法"><a href="#2-2-算法" class="headerlink" title="2.2 算法"></a><strong>2.2 算法</strong></h3><p>跳跃列表是按层建造的。<strong>底层是一个普通的有序链表</strong>。每个更高层都充当下面列表的<strong>“快速通道”</strong>，这里在第 i 层中的元素按某个固定的概率 p（通常为 1/2 或 1/4 ）出现在第 i+1 层中。每个元素平均出现在 1 / 1-p 个列表中，而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）在 log~1/p~n 个列表中出现。</p><p>在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾。如果该元素等于目标元素，则表明该元素已被找到；如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。每层链表中预期的查找步数最多为 1/p ，而层数为 log~1/p~n ，所以查找的总体步数为 -log~p~n / p，由于 p 是常数，查找操作总体的时间复杂度为 O(log n) 。而通过选择不同 p 值，就可以在查找代价和存储代价之间获取平衡。</p><p>跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。跳跃列表在并行计算中也很有用：插入可以在跳跃列表不同的部分并行地进行，而不用对数据结构进行全局的重新平衡。</p><h3 id="2-3-实现细节"><a href="#2-3-实现细节" class="headerlink" title="2.3 实现细节"></a><strong>2.3 实现细节</strong></h3><p>因为跳跃列表中的元素可以在多个列表中，所以每个元素可以有多于一个指针。</p><p>跳跃列表的插入和删除的实现与普通的链表操作类似，但高层元素必须在进行多个链表中进行插入或删除。</p><p>跳跃列表的最坏时间性能具有一定随机性，但是可以通过时间复杂度为 O(n) 的遍历操作（例如在打印列表全部内容时）以无随机的算法重整列表的结构，从而使跳跃列表的实际查找时间复杂度尽量符合理论平均值 O(log n) 。</p><h4 id="（1）插入操作"><a href="#（1）插入操作" class="headerlink" title="（1）插入操作"></a><strong>（1）插入操作</strong></h4><p>往跳跃列表中插入一个元素，如图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/Skip_list_add_element-en.gif" alt></p><ol><li>新节点和各层索引节点逐一比较，确定原链表的插入位置，O(log n)。</li><li>把索引插入到原链表，O(1)。</li><li>利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止，O(log n)。</li></ol><p>总体上，跳跃表插入操作的时间复杂度是 O(log n) ，而这种数据结构所占空间是2N，既空间复杂度是 O(n) 。</p><h4 id="（2）删除操作"><a href="#（2）删除操作" class="headerlink" title="（2）删除操作"></a><strong>（2）删除操作</strong></h4><p>在索引层找到要删除的节点，依次删除每层相同节点即可。若某层索引在删除后只剩下一个节点，可以删除此层。</p><ol><li>自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点，O(log n) 。</li><li>删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外），O(log n) 。</li></ol><p>总体上，跳跃表删除操作的时间复杂度是 O(log n) 。</p><h3 id="2-4-跳跃表和二叉树的区别"><a href="#2-4-跳跃表和二叉树的区别" class="headerlink" title="2.4 跳跃表和二叉树的区别"></a><strong>2.4 跳跃表和二叉树的区别</strong></h3><ul><li>跳表维持结构平衡的成本较低，完全依靠随机；二叉树则在多次插入删除后，通过再平衡操作来重新调整结构平衡。</li><li>跳表非树结构，分索引节点和底层链表节点，索引节点只有右边和下边两条索引，链表节点则只有下个节点索引，而二叉树节点则有左右子结点。</li></ul><p>补充：Redis通过跳跃表的优化实现Sorted-set维护有序集合，而关系型数据库则采用B+树。</p><hr><h2 id="第三节-源码解析"><a href="#第三节-源码解析" class="headerlink" title="第三节 源码解析"></a><strong>第三节 源码解析</strong></h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a><strong>1.1 基本结构</strong></h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank" rel="noopener">ConcurrentSkipListMap</a> 中包括 Node 和 Index 两种节点，其中 Node 即普通链表节点，而 Index 则是索引节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳表的最高头索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护映射内元素顺序的比较器，可以为空表示自然顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 延迟初始化的键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; keySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的条目集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet&lt;K,V&gt; entrySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的值集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Values&lt;V&gt; values;</span><br><span class="line">    <span class="comment">/** 延迟初始化的降序键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ConcurrentNavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> Object value;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个新的标记节点. 标记的区别在于其值字段指向自身。标记节点也具有空键，这一事实在一些地方得到了利用，但这并不能将标记与也具有空键的基本级别标头节点（head.node）区分开。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置value字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置next字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//重新检查链接，然后在每个调用中仅执行一个help-out阶段，这样可以最大程度地减少帮助线程之间的CAS干扰</span></span><br><span class="line">            <span class="comment">//如果f是此节点的下个节点，b是此节点的前个节点</span></span><br><span class="line">            <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">                <span class="comment">//如果f为空或f的value字段不等于f，则尝试CAS将新Node节点插入f前</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">                    casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">                <span class="comment">//否则，用f的下个节点覆盖f</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; node;<span class="comment">//对应链表节点，即value</span></span><br><span class="line">        <span class="keyword">final</span> Index&lt;K,V&gt; down;<span class="comment">//下层索引节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Index&lt;K,V&gt; right;<span class="comment">//右边索引节点</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置right字段，CAS set right value</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casRight</span><span class="params">(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, rightOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否已删除此索引的节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">indexesDeletedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS索引节点newSucc作为当前节点的新右边节点（插入），并将原右边节点succ右移一位</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; n = node;</span><br><span class="line">            newSucc.right = succ;</span><br><span class="line">            <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS覆盖当前节点的右边节点succ。如果已知已删除此节点，则失败(强制调用者进行遍历) </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> rightOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = Index.class;</span><br><span class="line">                rightOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"right"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-get"><a href="#1-2-get" class="headerlink" title="1.2 get"></a><strong>1.2 get</strong></h3><p>通过 <code>get()</code> 获取键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//键不允许为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">//outer配合break，外层循环</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，找到所给键的前驱节点b，并找到键对应节点n</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="comment">//找到节点已为null，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">//若此时数据已发生改变，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//n节点的值已为null，说明已被删除，调用helpDelete删掉此节点，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//b已被删除，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若命中，则返回value</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所给键小于找到的n节点键，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">//否则右移，继续循环判断</span></span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-put"><a href="#1-3-put" class="headerlink" title="1.3 put"></a><strong>1.3 put</strong></h3><p>通过 <code>put()</code> 放置键值对，前面和 <code>get()</code> 流程类似，当新增节点时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非只覆盖value，新增了节点，通过随机数维持平衡</span></span><br><span class="line">    <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">        <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            ++level;</span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">            level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                h = head;</span><br><span class="line">                <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                    newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                    h = newh;</span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find insertion points and splice in</span></span><br><span class="line">        splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = h.level;</span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> splice;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                    <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        findNode(key);</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-remove"><a href="#1-4-remove" class="headerlink" title="1.4 remove"></a><strong>1.4 remove</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-findPredecessor"><a href="#1-5-findPredecessor" class="headerlink" title="1.5 findPredecessor"></a><strong>1.5 findPredecessor</strong></h3><p>通过 <code>findPredecessor()</code> 查找给定键和比较器的前驱节点（小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个其键严格小于给定键的base-level节点，如果没有这样的节点，则返回base-level header。</span></span><br><span class="line"><span class="comment"> * 通过不断右移和下移索引，找到对应链表节点，过程中会unlink发现到的已删除节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    <span class="comment">//外层循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，从头索引开始</span></span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            <span class="comment">//右边还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                K k = n.key;</span><br><span class="line">                <span class="comment">//右边索引对应Node所存值为空，则删掉它，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r)) <span class="comment">//删掉右边索引节点</span></span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    r = q.right;         <span class="comment">// 更新右边索引节点（原右边节点的右边节点）</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若所给键大于右边节点的键，则指针右移，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前索引节点没有下层索引，直接返回其Node节点</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">            <span class="comment">//否则指针q下移到下层索引，同时更新d</span></span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-findNode"><a href="#1-6-findNode" class="headerlink" title="1.6 findNode"></a><strong>1.6 findNode</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns node holding key or null if no such, clearing out any</span></span><br><span class="line"><span class="comment"> * deleted nodes seen along the way.  Repeatedly traverses at</span></span><br><span class="line"><span class="comment"> * base-level looking for key starting at predecessor returned</span></span><br><span class="line"><span class="comment"> * from findPredecessor, processing base-level deletions as</span></span><br><span class="line"><span class="comment"> * encountered. Some callers rely on this side-effect of clearing</span></span><br><span class="line"><span class="comment"> * deleted nodes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Restarts occur, at traversal step centered on node n, if:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (1) After reading n's next field, n is no longer assumed</span></span><br><span class="line"><span class="comment"> *       predecessor b's current successor, which means that</span></span><br><span class="line"><span class="comment"> *       we don't have a consistent 3-node snapshot and so cannot</span></span><br><span class="line"><span class="comment"> *       unlink any subsequent deleted nodes encountered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (2) n's value field is null, indicating n is deleted, in</span></span><br><span class="line"><span class="comment"> *       which case we help out an ongoing structural deletion</span></span><br><span class="line"><span class="comment"> *       before retrying.  Even though there are cases where such</span></span><br><span class="line"><span class="comment"> *       unlinking doesn't require restart, they aren't sorted out</span></span><br><span class="line"><span class="comment"> *       here because doing so would not usually outweigh cost of</span></span><br><span class="line"><span class="comment"> *       restarting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (3) n is a marker or n's predecessor's value field is null,</span></span><br><span class="line"><span class="comment"> *       indicating (among other possibilities) that</span></span><br><span class="line"><span class="comment"> *       findPredecessor returned a deleted node. We can't unlink</span></span><br><span class="line"><span class="comment"> *       the node because we don't know its predecessor, so rely</span></span><br><span class="line"><span class="comment"> *       on another call to findPredecessor to notice and return</span></span><br><span class="line"><span class="comment"> *       some earlier predecessor, which it will do. This check is</span></span><br><span class="line"><span class="comment"> *       only strictly needed at beginning of loop, (and the</span></span><br><span class="line"><span class="comment"> *       b.value check isn't strictly needed at all) but is done</span></span><br><span class="line"><span class="comment"> *       each iteration to help avoid contention with other</span></span><br><span class="line"><span class="comment"> *       threads by callers that will fail to be able to change</span></span><br><span class="line"><span class="comment"> *       links, and so will retry anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The traversal loops in doPut, doRemove, and findNear all</span></span><br><span class="line"><span class="comment"> * include the same three kinds of checks. And specialized</span></span><br><span class="line"><span class="comment"> * versions appear in findFirst, and findLast and their</span></span><br><span class="line"><span class="comment"> * variants. They can't easily share code because each uses the</span></span><br><span class="line"><span class="comment"> * reads of fields held in locals occurring in the orders they</span></span><br><span class="line"><span class="comment"> * were performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node holding key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findNode</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 <a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">跳跃列表</a></p><p>🔗 <a href="https://www.baeldung.com/java-concurrent-skip-list-map" target="_blank" rel="noopener">Guide to the ConcurrentSkipListMap</a></p>]]></content>
    
    <summary type="html">
    
      简单整理了下Java中ConcurrentSkipListMap的实现原理，包括：概述，跳表，源码解析等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
</feed>
