<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-11-18T08:54:23.757Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死亡会是解脱吗</title>
    <link href="http://linyishui.top/2019111201.html"/>
    <id>http://linyishui.top/2019111201.html</id>
    <published>2019-11-12T10:03:51.000Z</published>
    <updated>2019-11-18T08:54:23.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-BrKoEdYO" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-BrKoEdYO"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "曾经我也想过一了百了",              author: "中島美嘉",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/%E4%B8%AD%E5%B3%B6%E7%BE%8E%E5%98%89%20-%20%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp3",              pic: "http://p1.music.126.net/HE-K4mxyNGF84xlyuxx9Wg==/109951163825342747.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-JQTVufgW" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-JQTVufgW"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "僕らの手には何もないけど、",              author: "RAM WIRE",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/RAM%20WIRE%20-%20%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81.mp3",              pic: "http://p2.music.126.net/V1o9XDhAnI1ayWW5elJwFQ==/109951163338252165.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-YMtUyKRI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-YMtUyKRI"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "ごはんを食べよう",              author: "Goose house",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/Goose%20house%20-%20%E3%81%94%E3%81%AF%E3%82%93%E3%82%92%E9%A3%9F%E3%81%B9%E3%82%88%E3%81%86.mp3",              pic: "http://p1.music.126.net/niXAzTEt2zlFpcLiPedX3g==/5754843859843186.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>&emsp;&emsp;可能会有那么一刻感叹自己的人生很空虚，世界好像和我无关，就算在这里死掉也不会有人会发现吧。</p><p>&emsp;&emsp;可能会有那么一刻觉得活着好累，死了就会好一些吧。</p><p>&emsp;&emsp;可能会有那么一刻无力反抗背上的压力，想着死了就轻松了吧。</p><p>&emsp;&emsp;活着似乎总是要担负一些东西，嘴里说着要放下一切，只有死去的那一刻才能真的放下吧。</p><p>&emsp;&emsp;世界是这样吗，不像幻想中那么美好、那么宽容，我好像也没那么坚强。</p><p>&emsp;&emsp;也曾想向世界传递善意，但身边的世界好像是空空的，是不是只有坏的记忆才能留在人的心里。</p><p>&emsp;&emsp;也曾想对世界倾诉，但好像没人有在乎，渐渐的也不知道该怎么说话了。</p><p>&emsp;&emsp;是啊，大家活着都很累啊，慢慢地封闭了自己的内心。</p><p>&emsp;&emsp;为了不受伤害而戴上的面具，也遮挡住了阳光，勉强才能维持着正常人的姿态。</p><p>&emsp;&emsp;“你没事吧”，“休息一下就好了”，“为家人考虑一下”，“再多坚强一些”，“还是内心不够强大”，“看不起这种自私的人”</p><p>&emsp;&emsp;说什么把握当下，生命要活得精彩，只是漂亮话罢了。</p><p>&emsp;&emsp;永别的时候告诉自己这不是放弃，是放下了。</p><p>&emsp;&emsp;好像这一生积攒的勇气终于释放了，好像扮演了一生的舞台剧终于谢幕了。</p><p>&emsp;&emsp;黑暗中死的无声无息，似乎从来没有存在过，直到最后也没有选择在阳光下，是担心围观的人肆意评论吗，人的恶意从来不会消失吧。</p><p>&emsp;&emsp;曾经也活着啊，匆匆的这一生有什么意义？</p><p>&emsp;&emsp;可能最后时刻的你也曾许愿，如果有来生，希望和能相互拥抱的人相遇。</p><p>&emsp;&emsp;哪怕一直聊着没有营养的话题，只想这样呆在一起。</p><p>&emsp;&emsp;就算还是一样活的辛苦，至少能感受到温暖。</p><p>&emsp;&emsp;希望那时可以相信这世界一切美好的存在，希望我也能成为温暖别人的存在。</p><p>&emsp;&emsp;但死了就什么都没有了，如果坚持到明天会不会有不同？</p><p>&emsp;&emsp;已放下所有的你，也许在明天的街头，可以邂逅一个阳光一样的人，也许再尝试一次就能找到一个同样孤独的人相拥取暖。</p><p>&emsp;&emsp;也许是一个多年未联系的老友，敞开心扉后，发现被社会打磨的油滑的他内心也还保留着一颗温热的心。</p><p>&emsp;&emsp;即便因奔忙无法相见，即便相互已无法变得坦率，但只要能够回到每个人都怀念的那个地方的话，是能让时光从那个时候开始延续吧</p><p>&emsp;&emsp;找到一个活下去的理由，只要能继续努力的活着，一切都还有重来的机会。</p><p>&emsp;&emsp;原本以为做不到的事情实际却可以做到的，世界渐渐变得广阔，因为相信现在所处的世界，即使一无所有仍可以顽强的活下去。</p><p>&emsp;&emsp;是啊，活着就是一件麻烦的事情，觉得不行了就暂停一下，无法面对了就逃避一下，总有一天，我们会从所有束缚我们的事之中，从肉眼看不到的微痛之中，得以解放。</p>        <div id="aplayer-KEMTYUUQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KEMTYUUQ"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "面会菜",              author: "林生祥",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/OM/%E6%9E%97%E7%94%9F%E7%A5%A5%20-%20%E9%9D%A2%E4%BC%9A%E8%8F%9C.mp3",              pic: "http://p2.music.126.net/cLoAM3X8pIuCil_oJpxjWw==/18511377767183768.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><blockquote><p>&emsp;&emsp;这篇博客算是记录一下最近几年的一些感想吧，经历了一些生活中、网络中发生的事情会有些感受，这些碎片式的感受还挺难整理的，很多回忆融合到一起，写的时候有些混乱了，写着写着也搞不清想要说什么了。<br>&emsp;&emsp;有些事情发生了，可能并没有一个简单的答案，局外人却可以随心所欲的谈论自己的观点，虽然他们可能什么都不知道，却能没有责任的随便开口。事情已经发生了，当事人也没办法为自己辩护了。<br>&emsp;&emsp;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日志" scheme="http://linyishui.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="diary" scheme="http://linyishui.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>默认方法（未完成）</title>
    <link href="http://linyishui.top/2019092301.html"/>
    <id>http://linyishui.top/2019092301.html</id>
    <published>2019-09-23T03:13:17.000Z</published>
    <updated>2019-11-20T03:18:01.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a><strong>默认方法</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><blockquote><p><strong>把代码传递给方法（方法引用、Lambda）和接口中的默认方法这两种特性的补充可以看作是为Stream而设计的</strong>。</p></blockquote><p>&emsp;&emsp;默认方法的设计初衷是为了支持库设计师，辅助他们写出更容易改进的接口。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students1 = inventory.stream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span></span></span><br><span class="line"><span class="function">                                   .<span class="title">collect</span><span class="params">(toList())</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">List</span>&lt;<span class="title">Student</span>&gt; <span class="title">students2</span> = <span class="title">inventory</span>.<span class="title">parallelStream</span><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span></span></span><br><span class="line"><span class="function">                                   .<span class="title">collect</span><span class="params">(toList())</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 8之前，List是没有stream()或parallelStream()方法的，List所继承的Collection<t>接口也没有。那么对于设计者而言，最简单的做法就是把stream()方法加入Collection接口，并加入ArrayList类的实现。但这样的更新使Collection接口多出一个方法，以前版本中会有大量依照Collection接口而扩展的实体类，他们就必须都实现stream()方法，那么<strong>怎样才能改变已发布的接口而不用破坏已有的实现呢</strong>？</t></p><p>&emsp;&emsp;Java 8采用的做法就是<strong>允许接口包含实现类没有提供实现的方法签名，缺失的这些方法由接口来完成实现</strong>。所以<strong>Java 8提供了default关键字来在接口中实现默认方法</strong>。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List源码中sort方法的默认实现</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="built_in">sort</span>(Comparator&lt;? <span class="keyword">super</span> E&gt; c) &#123;</span><br><span class="line">    <span class="keyword">Object</span>[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">Object</span> e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.<span class="built_in">set</span>((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类可以实现多个接口，当默认实现冲突时，Java有一套处理和限制来避免类似C++的菱形继承问题。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>行为参数化</title>
    <link href="http://linyishui.top/2019092201.html"/>
    <id>http://linyishui.top/2019092201.html</id>
    <published>2019-09-22T06:52:26.000Z</published>
    <updated>2019-11-19T07:32:51.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a><strong>行为参数化</strong></h1><p>&emsp;&emsp;行为参数化是一种开发模式，Lambda只是提供了更简洁的实现方式，让旧版本通过类和接口的实现方式变得更方便罢了。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a><strong>意义</strong></h2><p>&emsp;&emsp;应对频繁变更的需求：行为参数化意味着可以准备一段代码，并推迟它的执行，比如可以当作参数传递给另一个方法，等到需要时再执行。</p><hr><h2 id="旧版本实现行为参数化"><a href="#旧版本实现行为参数化" class="headerlink" title="旧版本实现行为参数化"></a><strong>旧版本实现行为参数化</strong></h2><p>&emsp;&emsp;如书中苹果集合筛选实例，客户从颜色开始提出需求，再到重量等，每个需求我们都需要实现一个filter。你可能会想，还是有办法只用一个filter的，于是你实现了filter(List<apple> inventory, String color, int weight, …)，但这并不能根本解决问题，比如需求变更为根据不同场景筛选对应的属性，或是组合多个属性进行复杂查询，又该如何减少重复代码呢？</apple></p><p>&emsp;&emsp;我们可以对苹果的筛选标准建模，定义一个<strong>谓词</strong>，返回一个boolean值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ApplePredicate&#123;</span><br><span class="line">    boolean test(Apple apple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以我们可以根据需求去扩展ApplePredicate的实现，不同的筛选策略就实现对应的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们把这些不同的策略看作是filter方法的不同行为，这类似于<strong>策略设计模式</strong>，我们可以封装一些算法，在运行时再去选择一个执行。ApplePredicate就是算法族，AppleHeavyWeightPredicate等就是不同策略。</p><p>&emsp;&emsp;下一步我们需要filterApples()方法能接收ApplePredicate对象，这就是行为参数化：<strong>让方法接受多种行为（策略）作为参数，并在内部使用，来完成不同的行为</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">List</span>&lt;Apple&gt; filterApples(<span class="keyword">List</span>&lt;Apple&gt; inventory, ApplePredicate p)&#123;</span><br><span class="line">    <span class="keyword">List</span>&lt;Student&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(Apple apple : inventory)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(apple))&#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述过程中我们已经做到了让filterApples()方法根据我们定义ApplePredicate对象传递的代码来选择行为，实际上就已经做到了行为参数化。</p><p>&emsp;&emsp;我们发现<strong>解决不断变更的需求这一问题时，通过把迭代集合这一行为和筛选逻辑判断行为进行了分离，随着需求而变的行为作为参数传递选择，从而通过重复使用一个方法来应对变化的需求</strong>。</p><hr><h2 id="对行为参数化进行优化"><a href="#对行为参数化进行优化" class="headerlink" title="对行为参数化进行优化"></a><strong>对行为参数化进行优化</strong></h2><p>&emsp;&emsp;因为filterApples()方法只能接受对象，所以我们传递的代码只能包装在对象中，但Java 8后就可以通过Lambda，直接把apple.getWeight() &gt; 150;这种表达式直接传递给filterApples()方法，而不用构建多个ApplePredicate对象。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a><strong>匿名类</strong></h3><p>&emsp;&emsp;熟悉Java的人可能会想到匿名类好像就可以解决重复创建ApplePredicate对象的问题，因为它可以随用随建。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; result = filterApples(<span class="name">inventory</span>, new ApplePredicate()&#123;</span><br><span class="line">    public boolean test(<span class="name">Apple</span> apple)&#123;</span><br><span class="line">        return apple.getWeight() &gt; <span class="number">150</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但匿名类仍存在一些缺点：1.它不太简洁。2.它让用户觉得难以理解。匿名类虽然解决了为ApplePredicate接口构建实体类的问题，但实际上仍需要创建这些对象，实际上并没有彻底的解决啰嗦的问题。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><strong>Lambda表达式</strong></h3><p>&emsp;&emsp;Lambda表达式的实现如下，彻底解决了啰嗦问题。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; result = filterApples(<span class="name">inventory</span>, (<span class="name">Apple</span> a) -&gt; apple.getWeight() &gt; <span class="number">150</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h3><p>&emsp;&emsp;通过泛型进一步抽象，让filterApples()能够适用更多的对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; filter(<span class="keyword">List</span>&lt;T&gt; <span class="keyword">list</span>, Predicate&lt;T&gt; p)&#123;</span><br><span class="line">    <span class="keyword">List</span>&lt;Student&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(T e : <span class="keyword">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(e))&#123;</span><br><span class="line">            result.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍了行为参数化这一概念，行为参数化的意义，在Java 8版本前如何实现行为参数化，Java 8又对行为参数化提供了哪些支持等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Optional（未完成）</title>
    <link href="http://linyishui.top/2019092101.html"/>
    <id>http://linyishui.top/2019092101.html</id>
    <published>2019-09-21T03:12:22.000Z</published>
    <updated>2019-11-20T03:11:44.612Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a><strong>Optional</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;函数式语言会通过更多的描述性数据类型来避免null，Java 8提供了Optional<t>类，使用它可以有效的避免NullPointerException。</t></p><p>&emsp;&emsp;Optional是一个容器对象，可以包含也可以不包含值，其方法可以明确地处理值不存在的情况。</p><p>&emsp;&emsp;未完待续！！！第10章</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>流（未完成）</title>
    <link href="http://linyishui.top/2019092001.html"/>
    <id>http://linyishui.top/2019092001.html</id>
    <published>2019-09-20T02:15:53.000Z</published>
    <updated>2019-11-20T03:11:29.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流"><a href="#流" class="headerlink" title="流"></a><strong>流</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;流的出现是为了在某些场景下能够代替集合，当一些复杂需求需要嵌套遍历运算时，集合就需要公式似的写一串代码，很难让人一眼看明白代码代表的意思。如下案例实现在集合中筛选金额较高的交易，并按货币分组。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建累积交易分组的Map</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Currency, <span class="built_in">List</span>&lt;Transaction&gt;&gt; transactionsByCurrencies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//遍历交易List</span></span><br><span class="line"><span class="keyword">for</span>(Transaction transaction : transactions)&#123;</span><br><span class="line">    <span class="comment">//筛选金额较高的交易</span></span><br><span class="line">    <span class="keyword">if</span>(transaction.getPrice() &gt; <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="comment">//提取交易货币</span></span><br><span class="line">        Currency currency = transaction.getCurrency();</span><br><span class="line">        <span class="built_in">List</span>&lt;Transaction&gt; transactionForCurrency = transactionsByCurrencies.<span class="keyword">get</span>(currency);</span><br><span class="line">        <span class="comment">//如果此货币分组为空，就新建一个</span></span><br><span class="line">        <span class="keyword">if</span>(transactionForCurrency == <span class="keyword">null</span>)&#123;</span><br><span class="line">            transactionForCurrency = <span class="keyword">new</span> ArratList();</span><br><span class="line">            transactionsByCurrencies.put(currency,transactionForCurrency);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前遍历的交易添加到具有同一货币的交易List中</span></span><br><span class="line">        transactionForCurrency.add(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过Stream API，可以改写上述代码如下。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> static java.util.stream.Collectors.toList;</span><br><span class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = transactions.stream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Transaction t) -&gt; t.getPrice() &gt; <span class="number">1000</span>)</span>.<span class="title">collect</span><span class="params">(groupingBy(Transaction::getCurrency))</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;集合需要手动实现迭代和运算处理，这种数据迭代叫<strong>外部迭代</strong>，而流式的迭代完全在库内部实现，叫做<strong>内部迭代</strong>。</p><p>&emsp;&emsp;流则和SQL的思路一样，采用了更高级的语言表达，由<strong>实现</strong>（Streams库）来选择最佳的低级执行机制。这样就可以避免用synchronized编写代码，它不仅容易出错，且在多核环境下需要很大的成本。</p><p>&emsp;&emsp;<strong>集合的主要目的是为了存储和访问数据，而Stream则主要用于描述对数据的计算。</strong></p><p>&emsp;&emsp;筛选一个集合的最快方案就是先转为Stream，再进行并行处理，最后再转换为List。</p><h3 id="流解决了两个问题"><a href="#流解决了两个问题" class="headerlink" title="流解决了两个问题"></a><strong>流解决了两个问题</strong></h3><p>&emsp;&emsp;两个问题是：集合处理时的固定套路和晦涩，以及难以有效利用多核性能。</p><p>&emsp;&emsp;编程中往往会有一些反复出现的数据处理模式，可以根据标准进行<strong>筛选数据</strong>、<strong>提取数据</strong>、<strong>给数据分组</strong>等会很方便</p><p>&emsp;&emsp;<strong>这些操作往往可以并行化</strong>。比如在两个CPU上筛选集合，可以一个处理列表前半部，一个处理后半部，这叫做分支步骤(1)；然后CPU对各自半个集合进行筛选(2)；最后(3)，一个CPU将两个结果合并。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><blockquote><p>流相较集合的优点：</p><ul><li>如果使用SQL这种数据库语言会发现一些查询语句转化为Java要变得很长，Java8的流支持这种简明的数据库查询式编程且用的是Java语法</li><li>然后流被设计为无需同时将数据调入内存，这样就可以处理无法装入内存的流数据了</li><li>可以对流做一些集合不能做的优化操作，如可以将对同一个流的若干操作组合起来，从而只遍历一次数据，而不是花大代价的去多次遍历。</li><li>Java可以自动的将流操作并行化，而集合则不行。</li></ul></blockquote><hr><h2 id="第二节-stream和parallelStream"><a href="#第二节-stream和parallelStream" class="headerlink" title="第二节 stream和parallelStream"></a><strong>第二节 stream和parallelStream</strong></h2><p>&emsp;&emsp;顺序和并行处理</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> static java.util.stream.Collectors.toList;</span><br><span class="line"><span class="regexp">//顺序处理</span></span><br><span class="line"><span class="regexp">List&lt;Student&gt; result = students.stream().filter((Student s) -&gt; s.getAge() &gt; 18).collect(toList());</span></span><br><span class="line"><span class="regexp">//</span>并行处理</span><br><span class="line">List&lt;Student&gt; result = students.parallelStream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span>.<span class="title">collect</span><span class="params">(toList())</span>;</span></span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>Java8的新特性</title>
    <link href="http://linyishui.top/2019091901.html"/>
    <id>http://linyishui.top/2019091901.html</id>
    <published>2019-09-19T01:35:44.000Z</published>
    <updated>2019-11-20T03:23:51.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a><strong>Java8的新特性</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;Java 8是改动较大的一个版本，新增了Lambda表达式、函数式编程、流等，当然也有一些其他扩充功能的更新。这些变化主要反映了Java从注重改变现有值得经典面向对象思想转变为向函数式编程领域转变。这些改动会很大程度上对开发人员起到帮助，让编程更容易更轻松。</p><p>&emsp;&emsp;对于并发编程来说，Java 1.0时有线程和锁，甚至提供了内存模型，但没有相关专业知识的团队很难可靠的使用这些工具。Java 5时添加了工业级的构建模块，如线程池和并发集合。Java 7时添加了分支/合并（fork/join）框架，使得并行变得更加实用，但依旧会有些困难。Java 8则对并行提供了一个更简单的新思路。</p><hr><h2 id="第二节-三个新的编程概念"><a href="#第二节-三个新的编程概念" class="headerlink" title="第二节 三个新的编程概念"></a><strong>第二节 三个新的编程概念</strong></h2><h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a><strong>流处理</strong></h3><p>&emsp;&emsp;流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，以相同方式将数据项写入输出流。</p><p>&emsp;&emsp;比如在Unix或Linux中，很多程序从标准输入中读取数据（Unix和C中的stdin，Java中的System.in），然后把结果写入标准输出（Unix和C中的stdout，Java中的System.out）。如下命令，cat会把两个文件连接起来创建一个流，tr会转换流中的字符，sort会对流中的行进行排序，trail -3则会给出流的最后三行。Unix允许这些程序通过<strong>管道</strong>（|）连接起来。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 | <span class="type">tr</span> <span class="string">"[A-Z]"</span> <span class="string">"[a-z]"</span> | <span class="type">sort</span> | <span class="type">trail</span> <span class="number">-3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述语句会先把字母转为小写，然后打印出排序后的最后三个单词。sort会把一个行流作为输入，产生了另一个行流，进行排序并输出。在Unix中，这些命令是同时执行的，就像工厂式的流水线，虽然整个命令序列像是是一步一步完成的，但各个命令的运行是并行的。</p><p>&emsp;&emsp;基于此思想，Java 8在java.util.stream中添加了一个Stream API；可以把Stream<t>看作是一个迭代器，它可以链接起来形成一个流水线。它带来的好处就是我们可以像SQL那样写查询语句的思路，把这样的流转为那样的流，而不是一次只能处理一个项目，而且Java可以很透明的把输入中不相关的部分分开放到几个CPU内核上分别执行，这样自动的并行就省去我们去开辟线程的功夫了。</t></p><h3 id="用行为参数化把代码传递给方法"><a href="#用行为参数化把代码传递给方法" class="headerlink" title="用行为参数化把代码传递给方法"></a><strong>用行为参数化把代码传递给方法</strong></h3><p>&emsp;&emsp;比如我们有一组学生数据，包括其年龄，学期成绩，班级，学号等信息，我们可能有各种排序需求，真正想要的就是通过给sort一个参数让其定义顺序。我们可以写一个函数compareUsingAge来比较学生的年龄，但Java 8之前我们没法把这个方法传递给另一个方法，所以只能创建一个Comparator对象，然后把对象传递给sort方法。而有了行为参数化后，这样的需求就可以简单的实现了，我们可以把compareUsingAge方法作为参数传递给sort。</p><p>&emsp;&emsp;<strong>把代码传递给方法</strong>这种方式简洁的表达了<strong>行为参数化</strong>，也许你会想可以通过<strong>匿名类</strong>实现行为参数化，但Lambda和方法引用可以更清晰和简单的来实现这一需求。</p><h3 id="并行与共享的可变数据"><a href="#并行与共享的可变数据" class="headerlink" title="并行与共享的可变数据"></a><strong>并行与共享的可变数据</strong></h3><p>&emsp;&emsp;如果我们的代码可以拆分为多个副本并独立工作时，并行是可以确保的，但如果要写入一个共享变量或对象，如果两个线程都要同时修改这个变量，就是不能允许的了。当然你可以通过synchronized来打破<strong>不能有共享的可变数据</strong>这一原则，但打破的同时也就意味着放弃了所有相关的优化，同步就意味着要按照顺序执行，这与并行的宗旨相悖。</p><p>&emsp;&emsp;<strong>没有共享的可变数据</strong>，<strong>将代码传递给方法的能力</strong>这两个概念是<strong>函数式编程范式</strong>的基石。而相反的<strong>命令式编程范式</strong>中，程序是一系列改变状态的指令。</p><blockquote><p>Java 8为并行做的优化：</p><ul><li>库会负责分块，把大的流分成几个小的流，以便于并行处理。</li><li>流所提供的这个免费并行，只有在传递给filter之类的库方法的函数不会互动时才能工作。函数式编程中函数的主要意思是函数可以作为一等值，但也隐含着执行时元素间无互动的意思。</li></ul></blockquote><hr><h2 id="第三节-行为参数化"><a href="#第三节-行为参数化" class="headerlink" title="第三节 行为参数化"></a><strong>第三节 行为参数化</strong></h2><p>&emsp;&emsp;<a href="../2019092201.html" title="Title">行为参数化</a></p><hr><h2 id="第四节-默认方法"><a href="#第四节-默认方法" class="headerlink" title="第四节 默认方法"></a><strong>第四节 默认方法</strong></h2><p>&emsp;&emsp;<a href="../2019092301.html" title="Title">默认方法</a></p><hr><h2 id="第五节-Lambda表达式"><a href="#第五节-Lambda表达式" class="headerlink" title="第五节 Lambda表达式"></a><strong>第五节 Lambda表达式</strong></h2><p>&emsp;&emsp;<a href="../2019031802.html" title="Title">Lambda表达式</a></p><hr><h2 id="第六节-流"><a href="#第六节-流" class="headerlink" title="第六节 流"></a><strong>第六节 流</strong></h2><p>&emsp;&emsp;<a href="../2019092001.html" title="Title">流</a></p><hr><h2 id="第七节-函数式编程"><a href="#第七节-函数式编程" class="headerlink" title="第七节 函数式编程"></a><strong>第七节 函数式编程</strong></h2><p>&emsp;&emsp;函数式编程是一种新的编程风格，核心就是把函数作为值。利用函数式编程可以用更少的时间，写出更清晰、简洁的代码。函数所指的这部分代码，可以被来回传递并加以组合，从而产生强大的编程语汇。</p><hr><h2 id="第八节-模式匹配-Switch"><a href="#第八节-模式匹配-Switch" class="headerlink" title="第八节 模式匹配-Switch"></a><strong>第八节 模式匹配-Switch</strong></h2><p>&emsp;&emsp;模式匹配可以在一些场景下代替if-then-else，但两者孰优孰劣并没有定论。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">expr</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;switch限制值为原始类型和String，函数式语言倾向于允许switch能用在更多的数据类型上。</p><p>&emsp;&emsp;未完待续！！！第14章</p><hr><h2 id="第九节-Optional"><a href="#第九节-Optional" class="headerlink" title="第九节 Optional"></a><strong>第九节 Optional</strong></h2><p>&emsp;&emsp;<a href="../2019092101.html" title="Title">Optional</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍一些Java8的新特性，内容包括：引文，三个新的编程概念（流处理、用行为参数化把代码传递给方法、并行与共享的可变数据），行为参数化，默认方法，Lambda表达式，流，函数式编程，模式匹配，Optional等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（三）主机规划与磁盘分区（未完成）</title>
    <link href="http://linyishui.top/2019091801.html"/>
    <id>http://linyishui.top/2019091801.html</id>
    <published>2019-09-18T09:20:59.000Z</published>
    <updated>2019-11-17T13:52:14.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-Linux"><a href="#第二章-Linux" class="headerlink" title="第二章 Linux"></a><strong>第二章 Linux</strong></h1><h2 id="第一节-硬件搭配"><a href="#第一节-硬件搭配" class="headerlink" title="第一节 硬件搭配"></a><strong>第一节 硬件搭配</strong></h2><p>&emsp;&emsp;Linux系统中，每个装置都会当作一个文件来看待。如IDE接口的硬盘文件名为/dev/sd[a-d]，a-d可选任意一个。几乎所有硬件装置文件都在/dev目录中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010104.png" alt="常见装置在Linux中的文件名"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010105.png" alt="常见装置在Linux中的文件名"></p><p>&emsp;&emsp;如果Linux所在机器是云端，可能得到的是虚拟机，为了加速，虚拟机中磁盘通过仿真器生成，对应的磁盘文件名为/dev/vd[a-p]系列文件名。</p><hr><h2 id="第二节-磁盘分区"><a href="#第二节-磁盘分区" class="headerlink" title="第二节 磁盘分区"></a><strong>第二节 磁盘分区</strong></h2><p>&emsp;&emsp;Linux系统作为一组程序，自然是要安装在磁盘中的。我们知道常见的磁盘接口有：SATA和SAS接口。近些年大部分的Linux distribution将IDE界面的磁盘文件名仿真成SATA了。虚拟机使用的<strong>虚拟磁盘</strong>并非是正规的磁盘界面，<strong>正常的实体机器基本都使用/dev/sd[a-]的磁盘文件名，而虚拟机环境下，为了加速，可能就会使用/dev/vd[a-p]这种装置文件名</strong>。</p><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（三）主机规划与磁盘分区，内容包括：等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（二）Linux简介</title>
    <link href="http://linyishui.top/2019091701.html"/>
    <id>http://linyishui.top/2019091701.html</id>
    <published>2019-09-17T03:20:42.000Z</published>
    <updated>2019-11-15T09:07:21.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-Linux"><a href="#第二章-Linux" class="headerlink" title="第二章 Linux"></a><strong>第二章 Linux</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;Linux就是一套操作系统，也就是核心和系统呼叫接口两层。操作系统是针对特定的硬件平台开发，所以不同的硬件平台自然无法运行一套操作系统，跨平台需要移植，Linux具有可移植性，是开源的操作系统。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010101.png" alt="操作系统的角色"></p><p>&emsp;&emsp;Linux从Unix沿袭了一个完整的操作系统中最底层的硬件控制与资源管理的完整架构，非常稳定和强大。</p><hr><h2 id="第二节-历史"><a href="#第二节-历史" class="headerlink" title="第二节 历史"></a><strong>第二节 历史</strong></h2><p>&emsp;&emsp;1969年，贝尔实验室的员工Ken Thompson以汇编语言写出了一组<strong>核心程序</strong>，以及一个小的<strong>文件系统</strong>。这个文件系统有两个重要的概念：<strong>（1）所有的程序或系统装置都是文件。（2）不管建构编辑器还是附属文件，所写的程序只有一个目的，且要有效的完成目标</strong>。这些概念对后续Linux的发展有很重要的影响。</p><p>&emsp;&emsp;1973年，Unix正式诞生，最开始Tompson和Ritchie合作用高阶语言：B语言来撰写，但实现出的核心效能并不好，后来Ritchie用C语言重新改写和编译Unics的核心，最后发行Unix的正式版本。</p><p>&emsp;&emsp;1977年，Unix分支–<strong>BSD</strong>诞生。1973年后Unix便和学术界进行了合作，加州伯克利大学的Bill Joy对Unix进行了移植，修改为实验室机器适合的版本，并增加了许多工具软件和编译程序，最终命名为Berkeley Software Distribution(BSD)。Bill Joy也是Sun公司的创办者。Unix具有高度可移植性和强大的效能，再加上当时并没有太多版权的纠纷，所以市场上出现了很多商业公司自家的Unix系统。在这个阶段各个公司还没有制定协议的概念，硬件各不相同所以开发出的Unix系统以及相关软件也无法在其他平台使用。</p><p>&emsp;&emsp;1979年，AT&amp;T推出System V第七版Unix，终于有了可以支持x86架构的个人计算机系统。但AT&amp;T在这一代尝试收回Unix版权，特别是限制了不可对学生提供源代码。</p><p>&emsp;&emsp;1984年，Andrew Tanenbaum教授自己手写了Minix这个Unix Like核心程序，为了避免版权纠纷，在开发时他完全脱离了Unix核心源代码，终于在1986年完成。但Minix并不是免费的，它的诞生就是作者为了教学，所以也没有后续的发展和更新。</p><p>&emsp;&emsp;1984年，Richard Mathew Stallman发起了<strong>GNU计划</strong>，对后来的自由和开源软件开启了大门。GNU计划的目的是：<strong>建立一个自由、开放的Unix操作系统</strong>。Stallman从开发免费的Unix程序开始慢慢打响了知名度，然后又撰写了C语言的编译程序：GNU C Compiler(gcc)，在这个过程中他还把写过的Emacs编辑器（可以在编辑时就指出语法的错误）移植到了Unix上，并公布了源代码。Stallman通过Emacs赚到了一定的资金并成立了<strong>自由软件基金会</strong>（FSF，Free Software Foundation），基金会请到了更多的开发者参与终于完成了GCC，之后Stallman还撰写了可以被呼叫的C函式库(GNU C library)，以及可以被使用来操作OS的基本接口BASH shell。</p><p>&emsp;&emsp;1985年，为了避免GNU开发的自由软件被他人注册为专利软件，Stallman和律师草拟了<strong>通用公共许可证</strong>（General Public License，GPL），并称呼为copyleft相比于专利软件的copyright。FSF的核心观念是【<strong>版权只读是促进社会进步的手段，但版权本身不是自然权利</strong>】，自由软件的重点不是指免费，而是指具有自由度的软件，<strong>使用者可以自由的执行、复制、再发行、学习、修改和强化自由软件</strong>。</p><p>&emsp;&emsp;GNU在开发的核心叫hurd，是一款架构非常先进的核心，但开发者对其要求太高，导致一直推迟了发布，也影响了后来Linux的开发。</p><p>&emsp;&emsp;1991年，芬兰的赫尔辛基大学的Linus Torvalds在BBS上贴了一则消息，说他以bash，gcc等GNU工具写了一个小的核心程序，不是GNU那样的专业程序，比较像玩具。但此核心程序可以在Intel的386个人计算机上运作，引起了很多人的兴趣。Torvalds通过学习Minix操作系统学习了核心程序设计的设计概念，但他对个人计算机缺少服务器的<strong>多任务处理能力</strong>不是很满意，所以他测试了很久386的硬件性能。在拿到Minix后，他也发现Minix虽然很棒，但创始人Tanenbaum教授不愿意加强其功能，所以Torvalds就动手开始改写自己的核心程序。</p><p>&emsp;&emsp;撰写程序首先需要的是能够工作的环境，再来则是可以将原始码编译为可执行文件的编译程序。<strong>还好GNU计划提供了bash工作环境和gcc编译程序等自由软件</strong>，Torvalds参考了Minix的设计理念和书籍上的程序代码，开始研究386个人计算机的效能优化，通过GNU自由软件将核心程序代码和386结合起来，最终写出了他需要的核心程序。最终这个玩具可以在386上运行，并且可以读取Minix的文件系统。之后他便将这个程序放到了网上供别人下载，并在BBS上贴了一则消息，而他放置这个程序的FTP目录为Linux，也就成为了它的名字。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010102.png" alt="Linus Torvalds在BBS上发布Linux"></p><p>&emsp;&emsp;之后Torvalds尝试在Linux上运行一些Unix的程序，但大部分都无法启动。所以他现在有两种选择：第一是修改软件，让其可以运行在Linux上；第二是修改Linux，让Linux符合软件运行的规范。Torvalds选择了后者，他希望Linux可以兼容Unix，于是他参考了标准的POSIX规范（可携式操作系统接口，由IEEE发布，主要针对Unix与一些软件运行时的标准），这个决定也是后来Linux发展状大的一个重要原因。</p><p>&emsp;&emsp;Linux的发展离不开社群的贡献，Torvalds在一开始便将Linux发布在网络中，有人使用后出现各种问题和需求，Torvalds就会及时的进行处理和更新。但一个人力量是有限的，因为Linux核心是Open Source的，所以网络和社群上的人很容易就可以跟随Linux的设计架构，并为一些硬件开发出兼容的驱动程序或软件等。Torvalds总是以【<strong>先求有且能运行，再求进一步改良</strong>】为准则，这鼓励到了很多志愿者加入了这个团队。同时<strong>为了适应这种随时都有程序代码加入的状况，Linux发展为具有模块的功能</strong>。将一些功能独立出核心，在需要时再加载进核心中，这样模块化的设计大大的提升了Linux核心的可维护能力。</p><p>&emsp;&emsp;1994年，Linux核心正式版上线。1996年完成了2.0版，2011年更新了3.0版，2015年更新了4.0版。</p><h3 id="自由软件和开源软件"><a href="#自由软件和开源软件" class="headerlink" title="自由软件和开源软件"></a><strong>自由软件和开源软件</strong></h3><blockquote><p>自由软件的特色：</p><ul><li>取得软件与原始码：你可以根据自己的需求来执行这个自由软件。</li><li>复制：你可以自由的复制该软件。</li><li>修改：你可以将取得的原始码进行修改，使其适应你的工作。</li><li>再发行：你可以将你修改过的程序，再度的自由发行，不会和原撰写者发生冲突。</li><li>回馈：你可以将你修改过的程序代码回馈给社群。</li></ul></blockquote><blockquote><p>自由软件禁止：</p><ul><li>修改授权：你不能把一个GPL授权的自由软件，在修改后取消GPL授权。</li><li>单纯贩卖：你不能单纯的贩卖自由软件。</li></ul></blockquote><p>&emsp;&emsp;<em>自由软件也是可以贩卖的，但不能单售卖自由软件，而是厂商自己开发和制作的部分，特别是服务</em></p><blockquote><p>开源软件规则：</p><ul><li>公布原始码且用户具有修改权：用户可以任意的修改和编译程序代码，与自由软件相同。</li><li>任意的再散布：此程序代码全部或部分可以被贩卖，且程序代码可以成为其他软件的组件之一，作者不应该称自己具有所有权，或收取额外的费用。</li><li>必须允许修改或衍生的作品，且可让再发布的软件使用相似的授权来发表即可。</li><li>承上，用户可使用与原本软件不同的名称或编号来散布。</li><li>不可限制某些个体或团体的使用权。</li><li>不可限制某些领域的应用：如不可限制其不能用于商业行为或学术行为等领域</li><li>不可限制在某些产品中，亦即程序代码可以应用于多种不同产品中。</li><li>不可具有排他条款，如不可限制此程序代码不能用于教育类研究中等。</li></ul></blockquote><p>&emsp;&emsp;GPL自由软件在商业上相比开源软件要有更多限制，所以许多商业公司选择拥抱其他open source开源软件授权，因为可以用于商业行为。<em>ps：有些专利软件也会通过Freeware和Shareware的模式来开放免费版本给大众使用噢</em>。</p><hr><h2 id="第三节-版本"><a href="#第三节-版本" class="headerlink" title="第三节 版本"></a><strong>第三节 版本</strong></h2><p>&emsp;&emsp;Linux的核心版本编号如下格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3<span class="selector-class">.10</span><span class="selector-class">.0-123</span><span class="selector-class">.e17</span><span class="selector-class">.x86_64</span></span><br><span class="line">主版本.次版本.释出版本<span class="selector-tag">-</span>修改版本</span><br></pre></td></tr></table></figure><h3 id="奇数偶数版本分类"><a href="#奇数偶数版本分类" class="headerlink" title="奇数偶数版本分类"></a><strong>奇数偶数版本分类</strong></h3><p>&emsp;&emsp;当主次版本为奇数，表示是<strong>发展中版本</strong>（development），如2.5.XX；当主次版本为偶数，则表示为<strong>稳定版本</strong>（stable）。<strong>释出版本</strong>是主次版本的架构不变时，新增功能累积到一定程度后释放的核心版本。修改版本就是使用者各自针对某个进行核心程序代码修改后的版本。</p><h3 id="主线版本和长期维护版本"><a href="#主线版本和长期维护版本" class="headerlink" title="主线版本和长期维护版本"></a><strong>主线版本和长期维护版本</strong></h3><p>&emsp;&emsp;3.0后奇数偶数编号格式就不再使用了，而是依据主线版本（MainLine）来开发，如3.10基于3.9架构继续开发。</p><p>&emsp;&emsp;旧版本在出现新的版本之前会有两种机制来处理，一是结束开发，表示此程序代码已结束不会再维护；二是保持该版本的持续维护，即长期维护版本，如3.10即为一个长期维护版本，如果出现BUG等问题，维护人员会进行更新维护。</p><h3 id="核心版本和发布商版本"><a href="#核心版本和发布商版本" class="headerlink" title="核心版本和发布商版本"></a><strong>核心版本和发布商版本</strong></h3><p>&emsp;&emsp;Linux核心版本和一些distribution的版本不相同，如Linux 7.x 应该是指CentOS这个distribution的版本。</p><p>&emsp;&emsp;为了让更多使用者能够使用Linux，许多商业公司和非盈利团体，将Linux Kernel（包括tools）与一些可运行软件整合起来，再加上了自己一些有创意的工具程序，可以让用户通过存储设备或网络来安装和管理Linux系统。这个【Kernel + Softwares + Tools + 可完全安装程序】就被叫作Linux distribution，Linux发布商套件。</p><p>&emsp;&emsp;比较知名的有Red Hat，SuSE，Ubuntu，Fedora，Debian等，这些系统重复性很高，并都基于<strong>Linux Standard Base</strong>（LSB）标准以及目录架构的<strong>File system Hierarchy Standard</strong>（FHS）来开发，所以不会有太大差异，区别可能就是平台自家开发的管理工具以及套件管理的模式吧。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010103.png" alt="Linux distribution分类"></p><p><em>商业版会稳定些，而社群版可能会有一些潜在的BUG</em></p><hr><h2 id="第四节-应用场景"><a href="#第四节-应用场景" class="headerlink" title="第四节 应用场景"></a><strong>第四节 应用场景</strong></h2><h3 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a><strong>网络服务器</strong></h3><p>&emsp;&emsp;Linux最热门的应用场景。Linux系统网络功能非常稳定和强大，特别适合用作网络服务器，如WWW，Mail Server，File Server等。</p><h3 id="关键任务的应用-金融数据库、大型企业网管环境"><a href="#关键任务的应用-金融数据库、大型企业网管环境" class="headerlink" title="关键任务的应用(金融数据库、大型企业网管环境)"></a><strong>关键任务的应用(金融数据库、大型企业网管环境)</strong></h3><p>&emsp;&emsp;关键任务就是企业最重要的业务，比如金融行业最重要的投资者和账户的数据，这些数据大部分是由数据库系统来作为存取接口，往往都采用Linux。</p><h3 id="学术机构的高效能运算任务"><a href="#学术机构的高效能运算任务" class="headerlink" title="学术机构的高效能运算任务"></a><strong>学术机构的高效能运算任务</strong></h3><p>&emsp;&emsp;Linux具有强大的运算能力，也具有支持度相当广泛的GCC编译软件，很适合一些学术机构的研究软件。</p><h3 id="个人计算机"><a href="#个人计算机" class="headerlink" title="个人计算机"></a><strong>个人计算机</strong></h3><p>&emsp;&emsp;桌面计算机（Desktop）的绝大部分功能需求Linux都已经可以满足了，旧版本缺少的窗口接口在Linux和X Window System结合后也得到了解决，Linux经过多年的发展已经兼容了绝大部分常用的办公和生活软件。</p><h3 id="移动设备"><a href="#移动设备" class="headerlink" title="移动设备"></a><strong>移动设备</strong></h3><p>&emsp;&emsp;Android就是Linux的一个分支。</p><h3 id="嵌入式设备"><a href="#嵌入式设备" class="headerlink" title="嵌入式设备"></a><strong>嵌入式设备</strong></h3><p>&emsp;&emsp;嵌入式系统基本不会有太大的更新，比如路由器、防火墙、收集、IP分享器、交换机、机器人芯片、家电产品等都可以使用Linux系统。</p><h3 id="云端应用"><a href="#云端应用" class="headerlink" title="云端应用"></a><strong>云端应用</strong></h3><p>&emsp;&emsp;随着个人计算机的CPU核心数越来越多，主机的性能有些过于强大，一些硬件资源经常会闲置，促进了虚拟化技术的发展，让数据集中在云程序中，用户通过端点设备联机到云中取到运算资源。<strong>云程序</strong>的底层就是Linux，而云程序搭建出的虚拟机，内容也是Linux操作系统。（通过虚拟化技术可以在一部主机上安装多个同时运作的操作系统，从而充分利用硬件资源）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（二）Linux简介，内容包括：引文，历史，版本，应用场景等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（一）计算机概论</title>
    <link href="http://linyishui.top/2019091601.html"/>
    <id>http://linyishui.top/2019091601.html</id>
    <published>2019-09-16T07:24:33.000Z</published>
    <updated>2019-11-15T03:32:15.678Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-计算机概论"><a href="#第一章-计算机概论" class="headerlink" title="第一章 计算机概论"></a><strong>第一章 计算机概论</strong></h1><h2 id="第一节-五大单元"><a href="#第一节-五大单元" class="headerlink" title="第一节 五大单元"></a><strong>第一节 五大单元</strong></h2><p>&emsp;&emsp;计算机由以下几个单元组成：输入单元、输出单元、CPU内部的控制单元和算数逻辑单元、主存储器。</p><p>&emsp;&emsp;计算机的重点是中央处理器（Central Processing Unit, CPU），CPU是一个具有特定功能的芯片，里面含有微指令集，主要工作是管理和运算，所以CPU又分为两个单元：算数逻辑单元与控制单元。<strong>算数逻辑单元主要负责程序运算与逻辑判断，控制单元主要协调周边组件和各单元间的工作</strong>。</p><p>&emsp;&emsp;所以数据从输入单元传输到主存储器，经过CPU处理后写回主存储器，最后再传输到输出单元。<em>（因为所有数据都要经过主存储器传输，如果内存容量不足，会对性能造成很大影响，所以提升内存被认为是提高机器性能的简单做法）</em></p><hr><h2 id="第二节-指令集"><a href="#第二节-指令集" class="headerlink" title="第二节 指令集"></a><strong>第二节 指令集</strong></h2><p>&emsp;&emsp;CPU的微指令集主要有两种设计理念：精简指令集（RISC）与复杂指令集（CISC）系统。</p><h3 id="精简指令集"><a href="#精简指令集" class="headerlink" title="精简指令集"></a><strong>精简指令集</strong></h3><p>&emsp;&emsp;如字面意思，此微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令执行效能较佳。但对于复杂的任务，就需要多个指令来完成。</p><p>&emsp;&emsp;常见的RISC微指令集CPU主要为：Oracle公司的SPARC系列、IBM公司的PowerPC系列、ARM公司的ARM CPU系列等。SPARC CPU主要用于学术领域的大型工作站，或者金融体系的主服务器。Power PC则有索尼的PS3等。ARM则是绝大部分主流手机、导航设备、网络设备等所采用的CPU。</p><h3 id="复杂指令集"><a href="#复杂指令集" class="headerlink" title="复杂指令集"></a><strong>复杂指令集</strong></h3><p>&emsp;&emsp;CISC每个小指令都可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同，消耗的时间较长，但可以处理较丰富的任务。</p><p>&emsp;&emsp;常见的CISC微指令集CPU主要有AMD、Intel、VIA等x86架构CPU。大量的PC都是采用x86架构CPU。</p><hr><h2 id="第三节-其他单元"><a href="#第三节-其他单元" class="headerlink" title="第三节 其他单元"></a><strong>第三节 其他单元</strong></h2><p>&emsp;&emsp;设备主要通过主板在硬件上连接起来，主板上有个连接沟通所有设备的芯片组，使CPU可以对各个设备下达命令。</p><blockquote><ul><li>系统单元：CPU、内存和主板等相关组件。主板上有很多连接界面和适配卡。</li><li>记忆单元：包括主存储器（RAM）与辅助内存。辅助内存就是硬盘、光盘等存储设备。</li><li>输入、输出单元：触摸屏、键盘、鼠标、打印机、HDMI、投影机、蓝牙等等。</li></ul></blockquote><hr><h2 id="第四节-常见单位"><a href="#第四节-常见单位" class="headerlink" title="第四节 常见单位"></a><strong>第四节 常见单位</strong></h2><h3 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a><strong>容量单位</strong></h3><p>&emsp;&emsp;最基础的单位就是bit，代表二进制0或1。</p><p>&emsp;&emsp;字节 Byte 是很多简单数据都是8比特大小而定义的单位，所以 1 Byte = 8 bit。</p><p>&emsp;&emsp;在字节之上就通过一系列简化单位来表示所代表的位数（K,M,G,T,P,E,Z等），二进制换算是每隔一代代表1024倍，十进制换算是每隔一代代表1000倍。</p><h3 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a><strong>速度单位</strong></h3><p>&emsp;&emsp;CPU的指令周期常用MHz或GHz等单位，Hz表示秒分之一。对于网络传输，因为网络使用bit作为单位，所以为Mbps（Mbits per second）也就是每秒多少Mbit。比如常见的100M宽带，如果转换为字节时，理论最大传输值为：每秒12.5Mbyte。</p><hr><h2 id="第五节-CPU"><a href="#第五节-CPU" class="headerlink" title="第五节 CPU"></a><strong>第五节 CPU</strong></h2><p>&emsp;&emsp;早期主板上的芯片组使用两个网桥来控制各个组件的沟通：(1)<strong>北桥</strong>：负责链接速度较快的CPU、主存储器与显式适配器界面等组件。(2)<strong>南桥</strong>：负责链接速度较慢的装置接口，如硬盘、USB、网卡等。因为北桥最主要的用处是桥接CPU和主存储器，所以后来的架构将北桥内存控制器封装到CPU中了，这样CPU和主存储器不再需要一层北桥，而是直接联系，可以释放浪费的带宽，提高速度。</p><p>&emsp;&emsp;多核CPU可以理解为CPU中有多个CPU处理单元，不同的微指令集也会影响到CPU的性能。CPU的频率就是CPU每秒钟可以进行的工作次数，如3.6GHz表示CPU可以一秒钟进行3.6*10^9次工作，只用频率来判定CPU性能是比较片面的，除了不同微指令集外，架构也不同，可用的第二层快取及其计算器制也可能不同，每次频率能进行的工作指令数也不同。</p><p>&emsp;&emsp;早期因为需要通过北桥来进行连接，所有设备工作频率需要相同，所以就有了<strong>前端总线</strong>（Front Side Bus, FSB）。因为CPU指令周期最快，所以有了外频和倍频的定义，<strong>外频</strong>就是CPU和外部组件进行传输的速度，<strong>倍频</strong>则是CPU内部用来加速工作效能的一个倍数，二者的积才是CPU的频率速度。比如一个CPU内频为3.0GHz，外频是333MHz，所以倍频就是9倍（3G = 3000M = 333M * 9）。</p><p>&emsp;&emsp;<strong>超频</strong>就是将CPU的倍频或外频通过主板设定为较高的频率，倍频通常不允许修改，一般修改的是外频。如333MHz提到400MHz，但超频之后CPU被提速，主板的各个组件都要相应的提速，变为原来的1.333倍（4/3），虽然CPU可能会达到3.6GHz，但可能会导致当机等问题。</p><p>&emsp;&emsp;北桥要慢于CPU，就会变成性能的瓶颈，所以后来就将内存控制器整合到了CPU内部。这时就不需要考虑同步的外频，只要考虑整体频率即可。</p><p>&emsp;&emsp;CPU每次能够处理的数据量称为<strong>字组大小</strong>，根据CPU设计有32位和64位，32位CPU因为能解析数据量有限，最多只能支持最大4GBytes的内存。</p><p>&emsp;&emsp;CPU的<strong>超线程</strong>（Hyper-Threading），CPU指令周期太快了，所以运算核心经常得以闲置，如今的系统基本都是多任务系统，同时会有很多任务让CPU执行，所以就可以让CPU“同时”执行多个程序，来充分利用其性能。多线程的原理在其他博文中已有整理，简单的说就是CPU将缓存器分为两块，多个程序同时竞争CPU的运算单元，这样4核的CPU可以有8核的效果。</p><hr><h2 id="第六节-内存"><a href="#第六节-内存" class="headerlink" title="第六节 内存"></a><strong>第六节 内存</strong></h2><p>&emsp;&emsp;主存储器的主要组件为<strong>动态随机存取内存</strong>（Dynamic Random Access Memory, DRAM），断电后数据即丢失。</p><p>&emsp;&emsp;DDR是所谓的<strong>双倍数据传送速度</strong>（Double Data Rate），可以在一次工作周期进行两次数据传送。</p><p>&emsp;&emsp;内存除了频率/带宽和型号外，其容量是非常重要的，所有数据都要加载到内存后才能被CPU读取，内存不够大会使大容量数据无法完整加载，内存需要释放未被使用的数据，现实使用中这些释放会和影响内存性能。</p><p>&emsp;&emsp;CPU内有<strong>第二层高速缓存</strong>（L2 cache），用来存放常用的程序或数据，避免再从主存储器中读取。L2内存的速度和CPU频率相同，但DRAM无法达到这个频率，所以需要<strong>静态随机存取内存</strong>（Static Random Access Memory, SRAM）。SRAM成本较高，很难做成大容量，所以利用其速度快的优势来作缓存是很好的方案。</p><p>&emsp;&emsp;CMOS主要用来记录主板上重要的参数，包括系统时间、CPU电压和评率、各项设备的I/O地址与IRQ等，记录这些需要通电，所以主板上也会有电池。</p><p>&emsp;&emsp;BIOS（Basic Input Output System）是写死在主板上内存芯片中的一套程序，这个芯片是<strong>只读存储器</strong>（ROM）即使没有通电也可以记录数据。BIOS随着计算机发展，需要不断地进行更新，所以只能放弃ROM，转为写入如闪存（flash）或EEPRO中。BIOS开机时执行，加载CMOS中的参数，并尝试呼叫存储设备中的开机程序从而进入操作系统。</p><p>&emsp;&emsp;显式适配器又叫VGA（Vifeo Graphics Array），图像的显式颜色需要占用内存，一些3D需要一定的运算，而CPU并非针对3D而设计的，所以就在VGA中嵌入了3D加速的芯片，也就是GPU。PCI是VGA的规格，经过了AGP后又发展为PCI-Express。</p><p>&emsp;&emsp;VGA和显示器连接的接口有：D-Sub(VGA端子)，DVI，HDMI，Display port(DP)。</p><hr><h2 id="第七节-机器语言到高级语言"><a href="#第七节-机器语言到高级语言" class="headerlink" title="第七节 机器语言到高级语言"></a><strong>第七节 机器语言到高级语言</strong></h2><p>&emsp;&emsp;<strong>机器语言</strong>就是一种指令集，也叫机器码，可以让CPU直接解读的语言，通过二进制代码来表示一些机器可以直接执行的指令集合。</p><p>&emsp;&emsp;因为机器只能识别0和1这种二进制语言，为了让机器执行特定的程序，需要参考机器自身的功能，程序最重要的运算和逻辑判断是通过CPU进行处理，所以为了让CPU执行程序需要参考CPU特有的微指令集，所以不同CPU微指令集不同时，移植就是一件麻烦事，程序需要和硬件结合才能开发时，程序就无法有效的复用，每次都要重新和硬件打交道。</p><p>&emsp;&emsp;为了解决这些麻烦，经过不断地发展，从机器语言到汇编语言，最后发展到一些现在的高级语言。</p><p>&emsp;&emsp;<strong>汇编语言</strong>通过助记符来代替机器指令的操作码，从而不用面对大量的二进制串，但汇编语言基本是和机器语言指令集一一对应的，所以不能解决不同平台不能移植的问题，不同指令集也就意味着不同的汇编语言，也没有降低编程的复杂度，但其性能和机器语言相当，要高于其他语言，所以到现在也会在一些场景继续发挥作用。</p><p>&emsp;&emsp;<strong>高级语言</strong>是高度封装后的编程语言，相比面向机器的汇编和机器语言，高级语言是面向用户的。高级语言不能直接被机器理解，所以需要一个翻译的过程，变为可以执行的机器语言。翻译方式有：编译和解释，编译就是先翻译程序后再执行，解释则是一边翻译一边执行。翻译的过程由<strong>编译程序</strong>来执行，开发人员只要专注于创造性的内容即可。</p><p>&emsp;&emsp;高级语言接近算法语言，简单易理解，更有结构化，使其开发的程序更具有可读性、可维护性、可靠性等，因为脱离了和硬件的对应，所以也实现了好的可移植性，提高了复用率。</p><hr><h2 id="第八节-操作系统"><a href="#第八节-操作系统" class="headerlink" title="第八节 操作系统"></a><strong>第八节 操作系统</strong></h2><p>&emsp;&emsp;如果程序想要把数据写入内存，必然需要分配一块内存区域用来放置数据，也就意味着要了解内存地址是如何定位的，而操作系统可以完成这种和硬件打交道重复撰写句柄的任务。</p><p>&emsp;&emsp;<strong>操作系统</strong>也是一组程序，其工作重点是管理计算机所由活动以及驱动系统中所有硬件。操作系统可以实现的这些功能就是其<strong>核心</strong>（Kernel），核心主要管控硬件与提供相关的能力，这些功能十分重要，所以核心程序会被放置到内存当中的区块中进行保护，开机后就会驻留在内存当中。</p><p>&emsp;&emsp;程序通过<strong>系统呼叫</strong>（System Call）来和核心交互，只要遵守操作系统提供的开发接口，核心的系统呼叫接口会主动的把程序语言的相关语法转为可以识别的任务函数，而开发人员不需要去了解核心或硬件了。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010101.png" alt="操作系统的角色"></p><p>&emsp;&emsp;核心程序提供的这一整组开发接口叫<strong>系统呼叫层</strong>，操作系统的核心层参考硬件信息来实现，没有其他程序的帮助操作系统只是在管理整个硬件资源，只是让计算机处于准备状态，应用程序开发时参考操作系统的开发接口，也只能运行在这个操作系统上。</p><blockquote><p>核心至少要具有以下功能：</p><ul><li>系统呼叫接口</li><li>程序管理</li><li>内存管理</li><li>文件系统管理</li><li>装置的驱动</li></ul></blockquote><p>&emsp;&emsp;驱动一般由硬件厂商提供，操作系统会提供给硬件厂商一组开发接口，让他们按照接口设计驱动程序，从而使操作系统可以识别任意版本的驱动。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（一）计算机概论，内容包括：计算机五大组成单元，指令集，其他单元，常见单位，CPU，内存，机器语言到高级语言，操作系统等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 &lt;整&gt;</title>
    <link href="http://linyishui.top/2019091501.html"/>
    <id>http://linyishui.top/2019091501.html</id>
    <published>2019-09-15T03:10:59.000Z</published>
    <updated>2019-11-13T07:48:14.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h1><h2 id="第一节-介绍"><a href="#第一节-介绍" class="headerlink" title="第一节 介绍"></a><strong>第一节 介绍</strong></h2><p>&emsp;&emsp;正则表达式（Regular expression）是一组由字母和符号组成的特殊文本, 用来从文本中找出满足条件格式的句子。</p><p>&emsp;&emsp;一个正则表达式是一种从左到右匹配主体字符串的模式。“Regular expression”可以用缩写的术语“regex”或“regexp”代替。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p><p>&emsp;&emsp;假设有如下限制：用户名只能包含小写字母、数字、下划线和连字符，并且限制用户名长度在3~15个字符之间</p><blockquote><p>^[a-z0-9_-]{3,15}&amp;</p></blockquote><p>&emsp;&emsp;^是开始标记，a-z0-9_-表示字母(a-z)、数字(0-9)、下划线和连字符，3-15表示允许3~15个字符长度，$是结束标记。</p><hr><h2 id="第二节-匹配模式"><a href="#第二节-匹配模式" class="headerlink" title="第二节 匹配模式"></a><strong>第二节 匹配模式</strong></h2><h3 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1 基本匹配"></a><strong>1 基本匹配</strong></h3><p>&emsp;&emsp;正则表达式是<strong>大小写敏感</strong>的，简单的“the”就表示规则：t紧接h再紧接e。</p><blockquote><p>“the” =&gt; The fat cat sat on <strong>the</strong> mat.</p></blockquote><h3 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2 元字符"></a><strong>2 元字符</strong></h3><p>&emsp;&emsp;正则表达式主要依赖于<strong>元字符</strong>。 元字符不代表他们本身的字面意思，他们都有特殊的含义。</p><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">句号匹配任意单个字符除了换行符。</td></tr><tr><td style="text-align:center">[ ]</td><td style="text-align:left">字符种类。匹配方括号内的任意字符。</td></tr><tr><td style="text-align:center">[^ ]</td><td style="text-align:left">否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">标记?之前的字符为可选.</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:left">匹配num个大括号之间的字符 (n &lt;= num &lt;= m).</td></tr><tr><td style="text-align:center">(xyz)</td><td style="text-align:left">字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td style="text-align:center">\</td><td style="text-align:left"></td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td style="text-align:center">\</td><td style="text-align:left">转义字符,用于匹配一些保留的字符: [ ] ( ) { } . * + ? ^ $ \ \</td><td></td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">从开始行开始匹配.</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">从末端开始匹配.</td></tr></tbody></table><h4 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a><strong>2.1 点运算符 .</strong></h4><p>&emsp;&emsp;.是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 </p><blockquote><p>“.ar” =&gt; The <strong>car</strong> <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a><strong>2.2 字符集</strong></h4><p>&emsp;&emsp;<strong>字符集</strong>也叫做字符类。方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。在方括号中的字符集不关心顺序。 例如，表达式[Tt]he 匹配 the 和 The。</p><blockquote><p>“[Tt]he” =&gt; <strong>The</strong> car parked in <strong>the</strong> garage.</p></blockquote><p>&emsp;&emsp;方括号的句号就表示句号。</p><blockquote><p>“ar[.]” =&gt; A garage is a good place to park a c<strong>ar.</strong></p></blockquote><h5 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a><strong>2.2.1 否定字符集</strong></h5><p>&emsp;&emsp;一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 =</p><blockquote><p>“[^c]ar” =&gt; The car <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a><strong>2.3 重复次数</strong></h4><p>&emsp;&emsp;后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。</p><h5 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a><strong>2.3.1 * 号</strong></h5><p>&emsp;&emsp;* 号匹配在 * 之前的字符出现大于等于0次。 例如，表达式 a<em> 匹配0或更多个以a开头的字符。表达式[a-z]</em> 匹配一个行中所有以小写字母开头的字符串。</p><blockquote><p>“[a-z]*” =&gt; Th<strong>e car parked in the garage</strong> #21.</p></blockquote><p>&emsp;&emsp;* 字符和 . 字符搭配可以匹配所有的字符 .* 。 * 和表示匹配空格的符号 \s 连起来用，如表达式\s*cat\s* 匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><blockquote><p>“\s<em>cat\s</em>“ =&gt; The fat <strong>cat</strong> sat on the con<strong>cat</strong>enation.</p></blockquote><h5 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a><strong>2.3.2 + 号</strong></h5><p>&emsp;&emsp;+号匹配+号之前的字符出现 &gt;=1 次。 例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。</p><blockquote><p>“c.+t” =&gt; The fat <strong>cat sat on the mat</strong>.</p></blockquote><h5 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a><strong>2.3.3 ? 号</strong></h5><p>&emsp;&emsp;在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 [T]?he 匹配字符串 he 和 The。</p><blockquote><p>“[T]he” =&gt; <strong>The</strong> car is parked in the garage.</p></blockquote><blockquote><p>“[T]?he” =&gt; <strong>The</strong> car is parked in t<strong>he</strong> garage.</p></blockquote><h4 id="2-4-符号"><a href="#2-4-符号" class="headerlink" title="2.4 符号 {}"></a><strong>2.4 符号 {}</strong></h4><p>&emsp;&emsp;在正则表达式中 {} 是一个量词，常用来一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。</p><blockquote><p>“[0-9]{2,3}” =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to <strong>10</strong>.0.</p></blockquote><p>&emsp;&emsp;我们可以省略第二个参数。 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。</p><blockquote><p>“[0-9]{2,}” =&gt; The number was 9.<strong>9997</strong> but we rounded it off to <strong>10</strong>.0.</p></blockquote><p>&emsp;&emsp;如果逗号也省略掉则表示重复固定的次数。 例如，[0-9]{3} 匹配3位数字</p><blockquote><p>“[0-9]{3}” =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to 10.0.</p></blockquote><h4 id="2-5-…-特征标群"><a href="#2-5-…-特征标群" class="headerlink" title="2.5 (…) 特征标群"></a><strong>2.5 (…) 特征标群</strong></h4><p>&emsp;&emsp;特征标群是一组写在 (…) 中的子模式。例如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加入特征标群则表示整个标群内的字符重复 N 次。例如，表达式 (ab)* 匹配连续出现 0 或更多个 ab。</p><p>&emsp;&emsp;我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par.</p><blockquote><p>“(c|g|p)ar” =&gt; The <strong>car</strong> is <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a><strong>2.6 | 或运算符</strong></h4><p>&emsp;&emsp;或运算符就表示或，用作判断条件。例如 (T|t)he|car 匹配 (T|t)he 或 car。</p><blockquote><p>“(T|t)he|car” =&gt; <strong>The car</strong> is parked in <strong>the</strong> garage.</p></blockquote><h4 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a><strong>2.7 转码特殊字符</strong></h4><p>&emsp;&emsp;反斜线 \ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \。</p><p>&emsp;&emsp;例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \. 以下这个例子 \.?是选择性匹配.</p><blockquote><p>“(f|c|m)at.?” =&gt; The <strong>fat cat</strong> sat on the <strong>mat.</strong></p></blockquote><h4 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a><strong>2.8 锚点</strong></h4><p>&emsp;&emsp;在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。</p><h5 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a><strong>2.8.1 ^ 号</strong></h5><p>&emsp;&emsp;^ 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>&emsp;&emsp;例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。</p><p>&emsp;&emsp;例如，^(T|t)he 匹配以 The 或 the 开头的字符串。</p><blockquote><p>“(T|t)he” =&gt; <strong>The</strong> car is parked in <strong>the</strong> garage.</p></blockquote><blockquote><p>“^(T|t)he” =&gt; <strong>The</strong> car is parked in the garage.</p></blockquote><h5 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a><strong>2.8.2 $ 号</strong></h5><p>&emsp;&emsp;同理于 ^ 号，$ 号用来匹配字符是否是最后一个。</p><p>&emsp;&emsp;例如，(at.)$ 匹配以 at. 结尾的字符串。</p><blockquote><p>“(at.)” =&gt; The fat c<strong>at.</strong> s<strong>at.</strong> on the m<strong>at.</strong></p></blockquote><blockquote><p>“(at.)$” =&gt; The fat cat. sat. on the m<strong>at.</strong></p></blockquote><h3 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3 简写字符集"></a><strong>3 简写字符集</strong></h3><p>&emsp;&emsp;正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr><th style="text-align:center">简写</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">除换行符外的所有字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配所有字母数字，等同于 [a-zA-Z0-9_]</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配所有非字母数字，即符号，等同于： [^\w]</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:left">匹配数字： [0-9]</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">匹配非数字： [^\d]</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">匹配所有空格字符，等同于： [\t\n\f\r\p{Z}]</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:left">匹配所有非空格字符： [^\s]</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:left">匹配一个换页符</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:left">匹配一个换行符</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:left">匹配一个回车符</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:left">匹配一个制表符</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:left">匹配一个垂直制表符</td></tr><tr><td style="text-align:center">\p</td><td style="text-align:left">匹配 CR/LF（等同于 \r\n），用来匹配 DOS 行终止符</td></tr></tbody></table><h3 id="4-零宽度断言（前后预查）"><a href="#4-零宽度断言（前后预查）" class="headerlink" title="4 零宽度断言（前后预查）"></a><strong>4 零宽度断言（前后预查）</strong></h3><p>&emsp;&emsp;先行断言和后发断言都属于非捕获簇（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p><p>&emsp;&emsp;例如，我们想要获得所有跟在 $ 符号后的数字，我们可以使用正后发断言 (?&lt;=\$)[0-9.]*。 这个表达式匹配 $ 开头，之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次。</p><p>&emsp;&emsp;零宽度断言如下：</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">?=</td><td style="text-align:left">正先行断言-存在</td></tr><tr><td style="text-align:center">?!</td><td style="text-align:left">负先行断言-排除</td></tr><tr><td style="text-align:center">?&lt;=</td><td style="text-align:left">正后发断言-存在</td></tr><tr><td style="text-align:center">?&lt;!</td><td style="text-align:left">负后发断言-排除</td></tr></tbody></table><h4 id="4-1-…-正先行断言"><a href="#4-1-…-正先行断言" class="headerlink" title="4.1 ?=… 正先行断言"></a><strong>4.1 ?=… 正先行断言</strong></h4><p>&emsp;&emsp;?=… 正先行断言，表示第一部分表达式之后必须跟着 ?=…定义的表达式。</p><p>&emsp;&emsp;返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=…)。</p><p>&emsp;&emsp;正先行断言的内容写在括号中的等号后面。 例如，表达式 (T|t)he(?=\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。</p><blockquote><p>“(T|t)he(?=\sfat)” =&gt; <strong>The</strong> fat cat sat on the mat.</p></blockquote><h4 id="4-2-…-负先行断言"><a href="#4-2-…-负先行断言" class="headerlink" title="4.2 ?!… 负先行断言"></a><strong>4.2 ?!… 负先行断言</strong></h4><p>&emsp;&emsp;负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!…)。</p><p>&emsp;&emsp;表达式 (T|t)he(?!\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。</p><blockquote><p>“(T|t)he(?!\sfat)” =&gt; The fat cat sat on <strong>the</strong> mat.</p></blockquote><h4 id="4-3-lt-…-正后发断言"><a href="#4-3-lt-…-正后发断言" class="headerlink" title="4.3 ?&lt;= … 正后发断言"></a><strong>4.3 ?&lt;= … 正后发断言</strong></h4><p>&emsp;&emsp;正后发断言 记作(?&lt;=…) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 (?&lt;=(T|t)he\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。</p><blockquote><p>“(?&lt;=(T|t)he\s)(fat|mat)” =&gt; The <strong>fat</strong> cat sat on the <strong>mat</strong>.</p></blockquote><h4 id="4-4-lt-…-负后发断言"><a href="#4-4-lt-…-负后发断言" class="headerlink" title="4.4 ?&lt;!… 负后发断言"></a><strong>4.4 ?&lt;!… 负后发断言</strong></h4><p>&emsp;&emsp;负后发断言 记作 (?&lt;!…) 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 例如，表达式 (?&lt;!(T|t)he\s)(cat) 匹配 cat，且其前不跟着 The 或 the。</p><blockquote><p>“(?&lt;!(T|t)he\s)(cat)” =&gt; The cat sat on <strong>cat</strong>.</p></blockquote><h3 id="5-标志"><a href="#5-标志" class="headerlink" title="5 标志"></a><strong>5 标志</strong></h3><p>&emsp;&emsp;标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr><th style="text-align:center">标志</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:left">忽略大小写。</td></tr><tr><td style="text-align:center">g</td><td style="text-align:left">全局搜索。</td></tr><tr><td style="text-align:center">m</td><td style="text-align:left">多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。</td></tr></tbody></table><h4 id="5-1-忽略大小写（Case-Insensitive）"><a href="#5-1-忽略大小写（Case-Insensitive）" class="headerlink" title="5.1 忽略大小写（Case Insensitive）"></a><strong>5.1 忽略大小写（Case Insensitive）</strong></h4><p>&emsp;&emsp;修饰语 i 用于忽略大小写。 例如，表达式 /The/gi 表示在全局搜索 The，在后面的 i 将其条件修改为忽略大小写，则变成搜索 the 和 The，g 表示全局搜索。</p><blockquote><p>“The” =&gt; <strong>The</strong> fat cat sat on the mat.</p></blockquote><blockquote><p>“/The/gi” =&gt; <strong>The</strong> fat cat sat on <strong>the</strong> mat.</p></blockquote><h4 id="5-2-全局搜索（Global-search）"><a href="#5-2-全局搜索（Global-search）" class="headerlink" title="5.2 全局搜索（Global search）"></a><strong>5.2 全局搜索（Global search）</strong></h4><p>&emsp;&emsp;修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 /.(at)/g 表示搜索 任意字符（除了换行）+ at，并返回全部结果。</p><blockquote><p>“/.(at)/“ =&gt; The <strong>fat</strong> cat sat on the mat.</p></blockquote><blockquote><p>“/.(at)/g” =&gt; The <strong>fat cat sat</strong> on the <strong>mat</strong>.</p></blockquote><h4 id="5-3-多行修饰符（Multiline）"><a href="#5-3-多行修饰符（Multiline）" class="headerlink" title="5.3 多行修饰符（Multiline）"></a><strong>5.3 多行修饰符（Multiline）</strong></h4><p>&emsp;&emsp;多行修饰符 m 常用于执行一个多行匹配。</p><p>&emsp;&emsp;像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。</p><p>&emsp;&emsp;例如，表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。</p><blockquote><p>“/.at(.)?$/“ =&gt; The fat<br>                cat sat<br>                on the <strong>mat</strong>.</p></blockquote><blockquote><p>“/.at(.)?$/gm” =&gt; The <strong>fat</strong><br>                  cat <strong>sat</strong><br>                  on the <strong>mat</strong>.</p></blockquote><h3 id="6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）"><a href="#6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）" class="headerlink" title="6 贪婪匹配与惰性匹配（Greedy vs lazy matching）"></a><strong>6 贪婪匹配与惰性匹配（Greedy vs lazy matching）</strong></h3><p>&emsp;&emsp;正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。</p><blockquote><p>“/(.*at)/“ =&gt; <strong>The fat cat sat on the mat</strong>. </p></blockquote><blockquote><p>“/(.*?at)/“ =&gt; <strong>The fat</strong> cat sat on the mat. </p></blockquote><hr><h2 id="第三节-捕获组和非捕获组"><a href="#第三节-捕获组和非捕获组" class="headerlink" title="第三节 捕获组和非捕获组"></a><strong>第三节 捕获组和非捕获组</strong></h2><p>&emsp;&emsp;捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。一般一个小括号括起来就是一个捕获组。捕获组可以进行嵌套。以深度优先进行编号，在js中编号从1开始。</p><p>&emsp;&emsp;参与匹配却不进行分组编号的捕获组，其形式为（?:exp）组成，还有其他的形式</p><hr><h2 id="第四节-贪婪、勉强和独占模式"><a href="#第四节-贪婪、勉强和独占模式" class="headerlink" title="第四节 贪婪、勉强和独占模式"></a><strong>第四节 贪婪、勉强和独占模式</strong></h2><h3 id="1-贪婪模式"><a href="#1-贪婪模式" class="headerlink" title="1 贪婪模式"></a><strong>1 贪婪模式</strong></h3><p>&emsp;&emsp;匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Blog<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Facebook<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：首先 .<em> 匹配任何字符（在非 DOTALL 模式下不匹配 \n,\r,\a 一类字符），在 source 中第一个被匹配的 &lt; li &gt; 后面直至最后一个字符（也就是&lt; /ol &gt;的 &gt;）都符合 .</em> 的匹配规则，但是显然如果 .* 匹配到最后一个字符，那么没有剩余的字符去匹配正则表达式中还未匹配的 &lt; /li &gt; 的，那么会引起匹配失败。但是失败后会回溯（这一点与独占量词不同，下面会讲到）。回溯后这段正则表达式将匹配到 source 中第一个 &lt; li &gt; 和第二个 &lt; /li &gt; 以及之间的内容，如上面的输出所示。</p><h3 id="2-勉强模式"><a href="#2-勉强模式" class="headerlink" title="2 勉强模式"></a><strong>2 勉强模式</strong></h3><p>&emsp;&emsp;匹配最短。在勉强量词模式下，正则表达式会匹配尽可能短的字符串。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*?&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Blog<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Facebook<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：source 中第一个&lt; li &gt;匹配到之后到第一个&lt; /li &gt;之间的字符都符合 .* 的匹配规则，同时如果继续匹配 &lt; /li &gt; 也符合这个规则，但是勉强模式下，它会尽可能短地匹配字符串，故第一个找到的字符串应该是 &lt; li &gt;Ggicci’s Blog&lt; /li &gt;，如上面输出所示。然后它会继续匹配剩余的字符串，找到第二个。</p><h3 id="3-独占模式"><a href="#3-独占模式" class="headerlink" title="3 独占模式"></a><strong>3 独占模式</strong></h3><p>&emsp;&emsp;同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*+&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：这段正则表达式将不会在 source 找到任何匹配的内容，因为 &lt; li &gt; 匹配到后， .*+ 所能匹配的字符尽可能长地匹配下去，直到 source 的最后一个字符，这必将引起匹配失败，但是在独占模式下一旦匹配失败就不会回溯，故不存在像贪婪模式一样回溯之后找到 &lt; /ol &gt;之前的&lt; /li &gt; 的情况。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" title="Title" target="_blank" rel="noopener">learn-regex</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍正则表达式，包括：简单介绍，元字符，用法，捕获组和非捕获组，贪婪、勉强和独占模式等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="regex" scheme="http://linyishui.top/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>CentOS（未完成）</title>
    <link href="http://linyishui.top/2019091401.html"/>
    <id>http://linyishui.top/2019091401.html</id>
    <published>2019-09-14T06:40:30.000Z</published>
    <updated>2019-11-11T08:42:51.676Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;远程连接密码和实例用户密码（root）</p><p>&emsp;&emsp;进入/usr/local目录</p><blockquote><p>cd /usr/local</p></blockquote><p>&emsp;&emsp;创建/usr/local/java目录</p><blockquote><p>mkdir java</p><p>cd java</p></blockquote><p>&emsp;&emsp;通过openjdk安装JDK8</p><blockquote><p>yum -y install java-1.8.0-openjdk</p><p>java -version</p></blockquote><p>&emsp;&emsp;重命名</p><blockquote><p>mv jdk1.8.0_171 jdk1.8</p></blockquote><p>&emsp;&emsp;解压</p><blockquote><p>tar -xzvf jdk-8u171-linux-x64.tar.gz</p></blockquote><p>&emsp;&emsp;未完待续</p>]]></content>
    
    <summary type="html">
    
      简单介绍CentOS系统。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器（三）内存分配与回收策略</title>
    <link href="http://linyishui.top/2019091301.html"/>
    <id>http://linyishui.top/2019091301.html</id>
    <published>2019-09-13T09:38:40.000Z</published>
    <updated>2019-11-11T08:39:53.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a><strong>内存分配与回收策略</strong></h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a><strong>前文</strong></h2><p>&emsp;&emsp;自动内存管理可以总结为自动化的处理两个问题：<strong>给对象分配内存</strong>和<strong>回收分配给对象的内存</strong>。给对象分配内存，宏观的看就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接的栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则也并非百分百固定，细节由当前所使用的收集器组合决定，以及虚拟机中与内存相关的参数的设置。</p><p>&emsp;&emsp;接下来会介绍几个最常见的内存分配规则，并通过代码去验证这些规则。所有代码在测试时使用Client模式虚拟机运行，没有手工的指定收集器组合，验证的是在使用Serial/Serial Old收集器下的内存分配和回收的策略（ParNew / Serial Old收集器组合的规则也基本一致）。</p><hr><h2 id="5-1-对象优先在Eden分配"><a href="#5-1-对象优先在Eden分配" class="headerlink" title="5.1 对象优先在Eden分配"></a><strong>5.1 对象优先在Eden分配</strong></h2><p>&emsp;&emsp;大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p>&emsp;&emsp;虚拟机提供了<strong>-XX:+PrintGCDetails</strong>这个收集器日志参数，使虚拟机在发生垃圾收集时打印内存回收日志，并且在进程退出时输出当前内存各区域的分配情况。在应用中内存回收日志一般是打印到文件后通过日志工具进行分析。</p><p>&emsp;&emsp;下列代码中testAllocation()方法中，尝试分配3个2MB大小和1个4MB大小的对象，在运行时通过-Xms20M、-Xmx20M、-Xmn10M这三个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果可以清晰的看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代总可用空间为9216KB（Eden区+1个Survivor区的总容量）。</p><p>&emsp;&emsp;执行testAllocation()中分配allocation4对象的语句时会发生一次Minor GC，这次GC的结果是新生代6651KB变为148KB，而总内存占用量则几乎没有减少（因为allocation1、allocation2、allocation3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只能通过分配担保机制提前转移到老年代。</p><p>&emsp;&emsp;这次GC结束后，4MB的allocation4顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、allocation2、allocation3占用）。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010128.png" alt="运行结果"></p><blockquote><p>Minor GC和Full GC不同点？</p><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随着至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul></blockquote><hr><h3 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a><strong>5.2 大对象直接进入老年代</strong></h3><p>&emsp;&emsp;所谓大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是较长的字符串或数组。大对象的内存分配是对虚拟机非常考验的事情，特别是一群“朝生夕死”的“短命大对象”，应该在编程时避免出现这种场景。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集来安置它们。</p><p>&emsp;&emsp;虚拟机提供了一个<strong>-XX:PretenureSizeThreshold</strong>参数，大于此参数值的对象会直接在老年代分配。这样的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p><p>&emsp;&emsp;执行下列代码的testPretenureSizeThreshold()后，Eden空间几乎没有被使用，老年代的10MB空间则被使用了40%，所以allocation对象是直接被分配在了老年代，原因就是PretenureSizeThreshold参数设置为3MB。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> * -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation;</span><br><span class="line">    allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010129.png" alt="运行结果"></p><blockquote><p>注意：PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不会识别此参数，此收集器一般不用设置，如果遇到需要使用此参数场景，推荐使用ParNew+CMS收集器组合。</p></blockquote><hr><h3 id="5-3-长期存活的对象将进入老年代"><a href="#5-3-长期存活的对象将进入老年代" class="headerlink" title="5.3 长期存活的对象将进入老年代"></a><strong>5.3 长期存活的对象将进入老年代</strong></h3><p>&emsp;&emsp;虚拟机采用分代收集的思想来管理内存，自然需要能够识别对象应被归属的代，所以虚拟机给每个对象定义了一个<strong>对象年龄计数器</strong>。如果对象在Eden出生并经过第一次Minor GC后仍然存活，且能被Survivor容纳的话，会被移动到Survivor空间，并且年龄设置为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就会增加1岁，当年龄增加到一定程度（默认为15），会被晋升到老年代。对象晋升到老年代的年龄阈值，可以通过参数<strong>-XX:MaxTenuringThreshold</strong>设置。</p><p>&emsp;&emsp;可以尝试分别以1和15为值设置参数MaxTenuringThreshold，测试下列代码的testTenuringThreshold()。对象allocation1需要256KB内存，Survivor空间可以容纳。当MaxTenuringThreshold=1时，allocation1在第二次GC发生时进入老年代，新生代已使用内存GC后非常干净的变为0KB。而MaxTenuringThreshold=15时，第二次GC发生后，allocation1对象还留在新生代Survivor空间，此时新生代仍有40KB占用。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment"> * -XX:PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarning</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    <span class="comment">//什么时候进入老年代取决于-XX:MaxTenuringThreshold设置</span></span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">null</span>;</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;MaxTenuringThreshold=1运行结果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010130.png" alt="运行结果"></p><p>&emsp;&emsp;MaxTenuringThreshold=15运行结果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010131.png" alt="运行结果"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010132.png" alt="运行结果"></p><hr><h3 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a><strong>5.4 动态对象年龄判定</strong></h3><p>&emsp;&emsp;为了更好的适应不同程序的内存状况，虚拟机并不是一直要求对象年龄必须达到MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>。</p><p>&emsp;&emsp;执行下列代码的testTenuringThreshold2()，设置-XX:MaxTenuringThreshold=15，可以发现运行结果中Survivor空间占用依然为0%，而老年代比预期增加6%，所以allocation1、allocation2直接进入了老年代，而不是等到age=15。这两个对象内存和为512KB，且年龄相同，满足同年占比一半的规则，可以注释掉其中一个对象观察结果。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment"> * -XX:PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarning</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testTenuringThreshold2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    <span class="comment">//allocation1+allocation2大于Survivor空间一半</span></span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010133.png" alt="运行结果"></p><hr><h3 id="5-5-空间分配担保"><a href="#5-5-空间分配担保" class="headerlink" title="5.5 空间分配担保"></a><strong>5.5 空间分配担保</strong></h3><p>&emsp;&emsp;在发生Minor GC之前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立则可以保证此Minor GC是安全的。如果不成立，虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则会尝试进行一次Minor GC，尽管这次是承担着风险的。如果HandlePromotionFailure值设置不允许，或者小于平均大小，则改为进行一次Full GC。</p><p>&emsp;&emsp;“冒险”是在承担什么风险？我们知道新生代使用复制收集算法，为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象Minor GC后仍然存活的情况，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。但老年代能进行担保的前提是其自身有足够的空间可以容纳这些对象，有多少对象在GC后会活下来是无法提前知道的，所以只好取每次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p><p>&emsp;&emsp;取平均值进行比较其实是一种动态概率的手段，如果某次Minor GC后存活的对象突然激增，依然会导致担保失败（HandlePromotionFailure）。如果出现了HandlePromotionFailure失败，就只好在失败后再发动一次Full GC。虽然担保失败时最麻烦，但大部分情况下都还会将HandlePromotionFailure开关打开，避免Full GC太过频繁，参考下列代码，在JDK 6 Update 24之前的版本中运行测试。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:HandlePromotionFailure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarning</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testHandlePromotion</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation1 = <span class="keyword">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">null</span>;</span><br><span class="line">    allocation5 = <span class="keyword">null</span>;</span><br><span class="line">    allocation6 = <span class="keyword">null</span>;</span><br><span class="line">    allocation7 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010134.png" alt="运行结果"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010135.png" alt="运行结果"></p><p>&emsp;&emsp;在JDK 6 Update 24之后的版本中结果会有差异，HandlePromotionFailure参数不再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然HandlePromotionFailure参数仍然被定义了，但代码中已不会再使用它，规则改变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> TenuredGeneration::promotion_attempt_is_safe(<span class="keyword">size_t</span></span><br><span class="line">max_promotion_in_bytes) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">//老年代最大可用的连续空间</span></span><br><span class="line">    <span class="keyword">size_t</span> available = max_contiguous_available();</span><br><span class="line">    <span class="comment">//每次晋升到老年代的平均大小</span></span><br><span class="line">    <span class="keyword">size_t</span> av_promo = (<span class="keyword">size_t</span>)gc_status()-&gt;avg_promoted()-&gt;padded_average();</span><br><span class="line">    <span class="comment">//老年代可用空间是否大于平均晋升大小，或者老年代可用空间是否大于当此GC时新生代所有对象容量</span></span><br><span class="line">    <span class="keyword">bool</span> res = (available &gt;= av_promo) || (available &gt;= max_promotion_in_bytes);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：对象优先在Eden分配，大对象直接进入老年代，长期存活的对象将进入老年代，动态对象年龄判定，空间分配担保等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器（二）垃圾收集算法</title>
    <link href="http://linyishui.top/2019091201.html"/>
    <id>http://linyishui.top/2019091201.html</id>
    <published>2019-09-12T09:26:28.000Z</published>
    <updated>2019-11-08T09:13:42.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第二节-垃圾收集算法"><a href="#第二节-垃圾收集算法" class="headerlink" title="第二节 垃圾收集算法"></a><strong>第二节 垃圾收集算法</strong></h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a><strong>2.1 标记-清除算法</strong></h3><p>&emsp;&emsp;<strong>最基础</strong>的收集算法是“标记-清除”算法(Mark-Sweep)算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。最基础是因为后续的收集算法都是基于此思路改进而来。主要有两点不足：一是效率问题，标记和清除过程都不高效；另一个是空间问题，标记和清除之后会产生大量不连续的内存碎片，会导致以后在程序需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010114.png" alt="“标记-清除”算法示意图"></p><hr><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a><strong>2.2 复制算法</strong></h3><p>&emsp;&emsp;复制算法是为了解决效率问题而设计，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活的对象复制到另一块上，然后将已使用过的内存空间一次清理掉。这样的做法使每次都是对整个半区进行内存回收，内存分配时就不用考虑到内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但此算法的代价是会将内存空间缩小一半，代价实在太高。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010115.png" alt="复制算法示意图"></p><p>&emsp;&emsp;<strong>当前的商业虚拟机都采用此算法来回收新生代</strong>，IBM研究表示新生代中对象98%都是“朝生夕死”，所以不需要对半划分内存空间，而是划分为一块大的Eden空间和两块较小的Survivor空间。每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的复制到另外一块Survivor空间上，最后清理掉Eden和用过的Survivor空间。(HotSpot默认Eden和Survivor空间大小比例为8:1，即每次新生代可用内存空间为整体的90%)。当Survivor空间不够用时，需要依赖其他内存(老年代)进行<strong>分配担保</strong>(Handle Promotion)。</p><p>&emsp;&emsp;分配担保类似于银行的担保人，如果一块Survivor空间没有足够的空间存放上次新生代收集下的存活对象，可以通过分配担保机制进入老年代，只要新生代有很好的“信誉”。具体实现此处不作详细描述。</p><hr><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a><strong>2.3 标记-整理算法</strong></h3><p>&emsp;&emsp;复制算法在对象存活率较高时需要进行较多的复制操作，会降低其运行效率。还有就是如果预留空间较小就需要额外的空间进行分配担保，以应对对象存活率极高的情况，所以老年代不会选用复制算法。</p><p>&emsp;&emsp;根据老年代的特点，有了标记-整理算法，标记过程等同于标记-清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010116.png" alt="“标记-整理”算法示意图"></p><hr><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a><strong>2.4 分代收集算法</strong></h3><p>&emsp;&emsp;<strong>当前的商业虚拟机的垃圾收集都采用分代收集算法</strong>，就是根据对象的存活周期的不同将内存划分为几块。一般把Java堆划分为新生代和老年代，可以根据各个代的特点采用最适合的收集算法。新生代中，每次垃圾收集会有大量对象被清理，仅有少量存活，就采用复制算法；老年代中对象存活率较高，没有额外的内存空间作分配担保，就采用标记-清除算法或标记-整理算法。</p><hr><h2 id="第三节-HotSpot算法实现"><a href="#第三节-HotSpot算法实现" class="headerlink" title="第三节 HotSpot算法实现"></a><strong>第三节 HotSpot算法实现</strong></h2><h3 id="3-1-枚举根节点"><a href="#3-1-枚举根节点" class="headerlink" title="3.1 枚举根节点"></a><strong>3.1 枚举根节点</strong></h3><p>&emsp;&emsp;可达性分析中从GC Roots节点找引用链这个操作为例，可以作为GC Roots的节点主要在<strong>全局性的引用</strong>(如常量或类静态属性)与<strong>执行上下文</strong>(如栈帧中的本地变量表)中，有些应用仅方法区就有数百兆，逐个检查这里面的引用是不现实的。</p><p>&emsp;&emsp;可达性分析中的GC停顿用来确保分析工作在一个保证一致性的“快照”中进行。在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不能在分析过程中对象关系还在不断地变化，不能满足这一点就无法保证最终分析结果的准确性。这就是GC进行时必须停顿所有Java执行线程的其中一个原因，即使CMS收集器号称不会发生停顿，枚举根节点时也必须停顿。</p><p>&emsp;&emsp;主流的Java虚拟机都是<strong>准确式GC</strong>(虚拟机可以知道内存中某个位置的数据类型具体是什么类型，如内存中有一个32位整数123456，虚拟机可以得知其是一个reference类型指向123456内存地址或者是一个数值为123456的整数，这样虚拟机才能在GC时判断堆上的数据是否还能被使用)。所以当执行系统停顿下来，并不需要一个不漏的检查完所有<strong>执行上下文</strong>和<strong>全局的引用设置</strong>，虚拟机有办法知道哪些地方存放着对象引用。在HotSpot的实现中，是通过一组被称为<strong>OopMap</strong>的数据结构来达到此目的，在<strong>类加载完成</strong>时，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在<strong>JIT编译过程</strong>中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。所以GC在扫描时就可以直接得知这些信息了。</p><p>&emsp;&emsp;下列代码是HotSpot Client VM生成的一段String.hashCode()方法的本地代码，可以看到在0x026eb7a9处的call指令有OopMap记录，它指明了EBX寄存器和栈中偏移量为16的内存区域中各有一个<strong>普通对象指针</strong>的引用，有效范围从call指令开始直到0x026eb730（指令流的起始位置）+142（OopMap记录的偏移量）=0x026eb7be，即hlt指令为止。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Verified Entry Point]</span><br><span class="line"><span class="number">0x026eb730</span>: <span class="keyword">mov</span>    %eax,-<span class="number">0x8000</span>(%esp)</span><br><span class="line">......</span><br><span class="line"><span class="comment">;; ImplicitNullCheckStub slow case</span></span><br><span class="line"><span class="number">0x026eb7a9</span>: <span class="keyword">call</span>   <span class="number">0x026e83e0</span>         <span class="comment">; OopMap&#123;ebx=Oop [16]=Oop off=142&#125;</span></span><br><span class="line">                                        <span class="comment">;*caload</span></span><br><span class="line">                                        <span class="comment">; - java.lang.String::hashCode@48 (line 1489)</span></span><br><span class="line">                                        <span class="comment">;    &#123;runtime_call&#125;</span></span><br><span class="line">  <span class="number">0x026eb7ae</span>: <span class="keyword">push</span>   <span class="number">$0</span>x83c5c18         <span class="comment">;    &#123;external_word&#125;</span></span><br><span class="line">  <span class="number">0x026eb7b3</span>: <span class="keyword">call</span>   <span class="number">0x026eb7b8</span></span><br><span class="line">  <span class="number">0x026eb7b8</span>: <span class="keyword">pusha</span></span><br><span class="line">  <span class="number">0x026eb7b9</span>: <span class="keyword">call</span>   <span class="number">0x0822bec0</span>         <span class="comment">;    &#123;runtime_call&#125;  </span></span><br><span class="line">  <span class="number">0x026eb7be</span>: <span class="keyword">hlt</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-2-安全点"><a href="#3-2-安全点" class="headerlink" title="3.2 安全点"></a><strong>3.2 安全点</strong></h3><p>&emsp;&emsp;在OopMap的帮助下，HotSpot可以快速且准确地完成GC Roots枚举，但随之而来的一个现实的问题：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样会导致GC的空间成本变得很高。</p><p>&emsp;&emsp;HotSpot实际上并没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为<strong>安全点</strong>（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只会在安全点暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以安全点的选定基本上是以程序“<strong>是否具有让程序长时间执行的特征</strong>”为标准进行选定的——因为每条指令的执行时间都非常短暂，程序不会因为指令流长度太长这个原因而过长时间运行，“<strong>长时间执行</strong>”的最明显特征就是<strong>指令序列复用</strong>，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>&emsp;&emsp;关于Safepoint，另外一个需要考虑的问题是如何在GC发生时让所有线程（不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。有两种实现方案：<strong>抢先式中断</strong>（Preemptive Suspension）和<strong>主动式中断</strong>（Voluntary Suspension）。</p><p>&emsp;&emsp;抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点，就恢复线程，让它“跑”到安全点上。但如今几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p><p>&emsp;&emsp;主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，而只是简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><p>&emsp;&emsp;下面代码中的test指令是HotSpot生成的轮询指令，当需要暂停线程时，虚拟机把0x160100的内存页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01b6d627</span>: <span class="keyword">call</span>   <span class="number">0x01b2b210</span>         <span class="comment">; OopMap&#123;[60]=Oop off=460&#125;</span></span><br><span class="line">                                        <span class="comment">;*invokeinterface size</span></span><br><span class="line">                                        <span class="comment">; - Client::main@113 (line 23)</span></span><br><span class="line">                                        <span class="comment">;    &#123;virtual_call&#125;</span></span><br><span class="line">  <span class="number">0x01b6d62c</span>: <span class="keyword">nop</span>                       <span class="comment">; OopMap&#123;[60]=Oop off=461&#125;</span></span><br><span class="line">                                        <span class="comment">;*if_icmplt</span></span><br><span class="line">                                        <span class="comment">; - Client::main@118 (line 23)</span></span><br><span class="line">  <span class="number">0x01b6d62d</span>: <span class="keyword">test</span>   %eax,<span class="number">0x160100</span>      <span class="comment">;   &#123;poll&#125;</span></span><br><span class="line">  <span class="number">0x01b6d633</span>: <span class="keyword">mov</span>    <span class="number">0x50</span>(%esp),%esi</span><br><span class="line">  <span class="number">0x01b6d637</span>: <span class="keyword">cmp</span>    %eax,%esi</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-安全区域"><a href="#3-3-安全区域" class="headerlink" title="3.3 安全区域"></a><strong>3.3 安全区域</strong></h3><p>&emsp;&emsp;Safepoint并没有完美地解决了如何进入GC的问题。Safepoint机制保证了程序执行时，在不久的时间内就会遇到可进入GC的Safepoint，但程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要<strong>安全区域</strong>（Safe Region）来解决。</p><p>&emsp;&emsp;安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。也可以把Safe Region看做是被扩展了的Safepoint。</p><p>&emsp;&emsp;在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了，在线程需要离开Safe Region时，它就要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><p>&emsp;&emsp;到此，简单介绍了HotSpot虚拟机如何去发起内存回收的问题，但是虚拟机如何具体地进行内存回收动作仍然未涉及，因为内存回收如何进行是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器，之后来看HotSpot中有哪些GC收集器。</p><hr><h2 id="第四节-垃圾收集器"><a href="#第四节-垃圾收集器" class="headerlink" title="第四节 垃圾收集器"></a><strong>第四节 垃圾收集器</strong></h2><p>&emsp;&emsp;如何说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），虚拟机包含的所有收集器如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010117.png" alt="HotSpot虚拟机的垃圾收集器"></p><p>&emsp;&emsp;上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明他们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来各节将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器，了解它们的部分运作细节。</p><h3 id="4-1-Serial收集器"><a href="#4-1-Serial收集器" class="headerlink" title="4.1 Serial收集器"></a><strong>4.1 Serial收集器</strong></h3><p>&emsp;&emsp;Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。此收集器是一个单线程的收集器，但其“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World” 这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了Serial / Serial Old 收集器运行过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010118.png" alt="Serial / Serial Old 收集器运行示意图"></p><p>&emsp;&emsp;对于“Stop The World”带给用户的不良体验，虚拟机设计者的苦衷是“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾，但垃圾收集是比打扫房间要复杂的多。</p><p>&emsp;&emsp;从JDK 1.3 开始，一直到现在HotSpot开发团队仍在致力于消除或减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成果Garbage First（G1）收集器，一个个越来越优秀也越来越复杂的收集器的不断出现，用户线程的停顿时间在不断缩短，但是仍无法完全消除。</p><p>&emsp;&emsp;Serial收集器到现在仍是虚拟机运行在Client模式下的默认新生代收集器，它还有相比于其他收集器的优点：<strong>简单而高效</strong>（单线程下）。对于限定单线程环境下，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以对于运行在Client模式下的虚拟机来说Serial收集器是很好的选择。</p><hr><h3 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a><strong>4.2 ParNew收集器</strong></h3><p>&emsp;&emsp;ParNew收集器其实就是Serial收集器的<strong>多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器一样，在实现上，这两种收集器也共用了很多相当多的代码。ParNew收集器的工作过程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010119.png" alt="ParNew / Serial Old 收集器运行示意图"></p><p>&emsp;&emsp;ParNew收集器除了多线程收集以外并没有其他创新之处，但它是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，<strong>目前只有它能与CMS收集器配合工作</strong>。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep，稍后详细介绍），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程基本上同时工作。</p><p>&emsp;&emsp;不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制执行它。</p><p>&emsp;&emsp;ParNew收集器在单CPU的环境中不会比Serial收集器好，甚至因为存在线程交互的开销，此收集器在通过超线程技术实现的两个CPU的环境中都不能百分百的超过Serial收集器。随着可使用CPU的数量增加，其对于GC时系统资源的有效利用还是很有好处的，它默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><blockquote><p><strong>并发编程</strong>的两个概念名词在垃圾收集器的上下文语境中的解释：</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。</li></ul></blockquote><hr><h3 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a><strong>4.3 Parallel Scavenge收集器</strong></h3><p>&emsp;&emsp;Parallel Scavenge收集器是一个新生代收集器，使用复制算法，还是并行的多线程收集器，似乎和ParNew收集器没什么区别。Parallel Scavenge收集器的特点是它的关注点和其他收集器不同，<strong>CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</strong>（Throughput）。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，如果虚拟机运行了100分钟，其中垃圾收集花费了1分钟，吞吐量就是99%。</p><p>&emsp;&emsp;停顿时间短意味着有较快的响应速度可以提升用户体验，适合与用户交互的程序；高吞吐量则可以高效率的利用CPU时间，尽快的完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>&emsp;&emsp;Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，-XX:MaxGCPauseMills，-XX:GCTimeRatio。</p><p>&emsp;&emsp;Parallel Scavenge收集器也经常被叫做“吞吐量优先”收集器，除了以上两个参数还有一个-XX:UseAdaptiveSizePolicy值得关注。</p><blockquote><ul><li>-XX:MaxGCPauseMills 此参数控制最大垃圾收集停顿时间。MaxGCPauseMills参数的值是大于0的毫秒数，收集器会尽可能地保证内存回收花费时间不超过设定时间。但并不是设置的小就会使垃圾收集速度变快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统会把新生代调小，也就导致垃圾收集会更频繁，所以吞吐量就会降低。</li><li>-XX:GCTimeRatio 此参数直接设置吞吐量大小。GCTimeRatio参数的值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。比如参数值为19，允许的最大GC时间就为1 / (1 + 19) = 5%的最大时间比率，如果为99，结果就为1%。</li><li>-XX:UseAdaptiveSizePolicy 它是一个<strong>开关参数</strong>，开启后就不需要手动指定新生代大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。这种调节方式叫GC自适应的调节策略（GC Ergonomics）。</li></ul></blockquote><p>&emsp;&emsp;如果开发者能力不足以进行优化工作，使用Parallel Scavenge收集器搭配自适应调节策略，把优化任务交给虚拟机来完成会是一个不错的选择。只需要把基本的内存数据设置好（-Xmx设置最大堆等），然后MaxGCPauseMills（关注最大停顿时间）或GCTimeRatio（关注最大吞吐量）参数给虚拟机设置一个优化目标，具体调节就由虚拟机去完成了。</p><p>&emsp;&emsp;自适应调节策略是Parallel Scavenge收集器和ParNew收集器的一个重要区别。</p><hr><h3 id="4-4-Serial-Old收集器"><a href="#4-4-Serial-Old收集器" class="headerlink" title="4.4 Serial Old收集器"></a><strong>4.4 Serial Old收集器</strong></h3><p>&emsp;&emsp;Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。此收集器的主要意义同样是在于给Client模式下的虚拟机使用。但在Server模式下，它还有两大用途：一种用途是在JDK 1.5 以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p><p>&emsp;&emsp;Serial Old收集器工作过程如下图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010118.png" alt="Serial / Serial Old 收集器运行示意图"></p><hr><h3 id="4-5-Parallel-Old收集器"><a href="#4-5-Parallel-Old收集器" class="headerlink" title="4.5 Parallel Old收集器"></a><strong>4.5 Parallel Old收集器</strong></h3><p>&emsp;&emsp;Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。此收集器从JDK 1.6开始提供，在此之前新生代的Parallel Scavenge收集器只能搭配老年代的Serial Old收集器，因为它无法与CMS收集器配合。Serial Old收集器在服务端应用性能上并不可靠，使用了Parallel Scavenge收集器也未必能够在整体应用上获得最大吞吐量的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年大很大而且硬件比较高级的环境中，这种组合甚至不一定比ParNew+CMS的组合更好。</p><p>&emsp;&emsp;Parallel Old收集器出现完善了“吞吐量优先”收集器有了合适的组合，在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的搭配。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010120.png" alt="Parallel Scavenge / Parallel Old 收集器运行示意图"></p><hr><h3 id="4-6-CMS收集器"><a href="#4-6-CMS收集器" class="headerlink" title="4.6 CMS收集器"></a><strong>4.6 CMS收集器</strong></h3><p>&emsp;&emsp;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，从而给用户带来较好的体验，CMS收集器非常适合这种需求。</p><p>&emsp;&emsp;从名字Mark Sweep便可以得知CMS收集器是基于“标记-清除”算法实现的，其运作过程相比前几个收集器相对复杂。</p><blockquote><p>CMS收集器运作过程：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：仅仅是标记一下GC Roots能直接关联到的对象，速度很快。初始标记和重新标记两个步骤仍需要“Stop The World”。</li><li><strong>并发标记</strong>（CMS concurrent mark）：进行GC Roots Tracing的过程。</li><li><strong>重新标记</strong>（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，此阶段的停顿时间一般会比初始标记阶段稍长，但比并发标记阶段短。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：并发清除和并发标记是耗时最长的阶段，这两个阶段收集器线程都可以与用户线程一起工作。</li></ul></blockquote><p>&emsp;&emsp;总体来说CMS收集器的内存回收过程是与用户线程一起并发执行的，下图可以看到CMS收集器的运作步骤中并发和需要停顿的时间。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010121.png" alt="Concurrent Mark Sweep 收集器运行示意图"></p><p>&emsp;&emsp;CMS是一款优秀的收集器，优点就是<strong>并发收集</strong>、<strong>低停顿</strong>，所以Sun公司文档中称其为<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector），但CMS也有明显的缺点。</p><h4 id="CMS的三个缺点"><a href="#CMS的三个缺点" class="headerlink" title="CMS的三个缺点"></a><strong>CMS的三个缺点</strong></h4><p>&emsp;&emsp;1. <strong>对CPU资源十分敏感</strong>，这是并发设计程序的通病。在并发阶段，虽然不会导致用户线程停顿，但会因为占用了一部分线程或者说CPU资源而导致应用程序变慢，总吞吐量会降低。</p><p>&emsp;&emsp;CMS默认启动的回收线程数是 (CPU数量 + 3) / 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就可能变得很大，如果CPU本身负载就比较大，还要分出一半的运算能力去执行收集器线程，就会导致用户程序的执行速度突然下降50%。</p><p>&emsp;&emsp;为了应对这种情况，虚拟机提供了一种称为<strong>增量式并发收集器</strong>（Incremental Concurrent Mark Sweep / i-CMS）的CMS收集器变种，所做的工作和单CPU年代PC机操作系统使用<strong>抢占式</strong>来模拟多任务机制的思路一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少线程独占资源的时间，这样整个垃圾收集的过程会更长，但会降低对用户程序的影响。但实际使用中i-CMS效果非常一般，所以后续版本已经弃用（deprecated）。</p><p>&emsp;&emsp;2. <strong>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生</strong>。因为CMS并发清理阶段用户线程还在运行，所以自然会不断地产生垃圾，这部分垃圾产生在标记过程之后，所以CMS无法在此次收集中处理它们，只能留到下次GC时再进行清理。这部分垃圾就被称为浮动垃圾（Floating Garbage）。因为垃圾收集阶段用户线程还在运行，还意味着需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎被填满了再去收集，而是需要预留一部分空间提供并发收集时的程序运作使用。</p><p>&emsp;&emsp;使用JDK 1.5默认设置时，CMS收集器当老年代使用了68%就会被激活，这个数值比较保守，可以通过提高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，从而降低内存回收次数获取更好的性能。JDK 1.6时，CMS收集器的启动阈值已经提升至92%。如果CMS运行期间预留的内存无法满足程序需要，会出现一次“Concurrent Mode Failure”失败，此时虚拟机将启动后背预案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以CMSInitiatingOccupancyFraction参数谨慎处理，设置太高反而可能导致性能降低。</p><p>&emsp;&emsp;3. <strong>生成大量的空间碎片</strong>。因为CMS收集器基于“标记-清除”算法，所以自然会在收集结束后产生大量的空间碎片，给大对象的分配造成困难，经常老年代仍有大量空间未使用，却无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p><p>&emsp;&emsp;为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，此过程无法并发，解决了空间碎片问题，但代价是延长了停顿时间。</p><p>&emsp;&emsp;虚拟机还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，此参数用来设置执行多少次不压缩Full GC后，跟着来一次带压缩的（默认为0，表示每次进入Full GC时都进行碎片整理）</p><hr><h3 id="4-7-G1收集器"><a href="#4-7-G1收集器" class="headerlink" title="4.7 G1收集器"></a><strong>4.7 G1收集器</strong></h3><p>&emsp;&emsp;G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，早在JDK 1.7时就有了进化特征，在JDK 6u14时有了Early Access版本提供实验、使用。直到JDK 7u4时达到成熟阶段。G1是一款面向服务端应用的垃圾收集器，其使命是替换掉JDK 1.5发布的CMS收集器。</p><blockquote><p>G1相比其它收集器的特点：</p><ul><li><strong>并行与并发</strong> ：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java线程继续执行。</li><li><strong>分代收集</strong> ：和其他收集器一样，G1仍然保留了分代概念。虽然G1能独立管理整个GC堆，不需要其他收集器配合，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li><strong>空间整合</strong> ：与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器。从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。这个特性有利于程序长时间运行，分配大对象不会因为找不到连续空间而提前触发下次GC。</li><li><strong>可预测的停顿</strong> ：这个特点是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul></blockquote><p>&emsp;&emsp;在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1收集器的Java堆内存布局会有很大变化，它将整个Java堆分为对个大小相等的独立区域（Region），虽然还保留了新生代和老年代的概念，但两者之间不再物理隔离，都是一部分Region（不需要连续）的集合。</p><p>&emsp;&emsp;G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（G1由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>&emsp;&emsp;G1把内存“化整为零”的思路，实际实现并不简单。一个细节为例：把Java堆分为多个Region后，垃圾收集是否就真的能以Region为单位进行了？似乎顺理成章，但仔细想想会发现问题所在：Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被此Region中的对象引用，而是可以和整个Java堆中任意的对象发生引用关系。那么在做可达性分析判定确定对象是否存活时，岂不是还要扫描整个Java堆才能保证准确性？这个问题并非G1独有，但G1尤其明显突出。在以前的分代收集中，新生代一般都比老年代要小许多，收集也要频繁许多，那么回收新生代对象时也面临着同样的问题，如果回收新生代对象时不能不同时扫描老年代的话，Minor GC的效率要下降不少。</p><p>&emsp;&emsp;G1收集器中Region间的对象引用，其他收集器中新生代和老年代之间的对象引用，都是通过 Remembered Set 来避免全堆扫描。在G1中每个 Region 都有一个对应的 Remembered Set ，当虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代的对象引用了新生代的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在GC根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。 </p><h4 id="运行步骤"><a href="#运行步骤" class="headerlink" title="运行步骤"></a><strong>运行步骤</strong></h4><p>&emsp;&emsp;G1收集器的前几个步骤和CMS收集器类似。</p><blockquote><p>不考虑维护 Remembered Set 的操作，G1收集器的运作步骤：</p><ul><li><strong>初始标记</strong>（Initial Marking）：仅仅是标记一下GC Roots能直接关联到的对象，并修改TAMS（Next To at Mark Start）的值，使下一阶段用户程序并发运行时，能在正确可用的Region中创建对象，这阶段需要<strong>停顿线程</strong>，但耗时很短。</li><li><strong>并发标记</strong>（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，此阶段耗时较长，但可与用户程序<strong>并发执行</strong>。</li><li><strong>最终标记</strong>（Final Marking）：此阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要<strong>停顿线程</strong>，但可以<strong>并发执行</strong>。</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：此阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，此阶段可以做到与用户程序一起并发执行，但因为只回收一部分 Region ，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ul></blockquote><p>&emsp;&emsp;通过下图可以比较清楚的看到G1收集器的运作步骤中并发和需要停顿的阶段。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010122.png" alt="G1收集器运行示意图"></p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a><strong>性能测试</strong></h4><p>&emsp;&emsp;通过简单的Java代码写个Microbenchmark程序来创建、移除Java对象，用-XX:+PrintGCDetails等参数来查看GC日志是很难去准确衡量其性能的。下面引用Sun实验室论文数据。</p><blockquote><ul><li>硬件：Sun V880 服务器（8×750MHz UltraSPARC Ⅲ CPU、32G内存、Solaris 10 OS）</li><li>软件：SPECjbb（模拟商业数据库应用，堆中存活对象约为165MB，结果反映吐量和最长事物处理时间）、telco（模拟电话应答服务应用，堆中存活对象约为100MB，结果反映系统能支持的最大吞吐量）。</li><li>补充：另外收集了一组用ParNew+CMS收集器的测试数据方便对比，所有测试都配置为与CPU数量相同的8条GC线程</li></ul></blockquote><p>&emsp;&emsp;在反应停顿时间的软实时目标（Soft Real-Time Goal）测试中，横向是两个测试软件的时间片段配置，单位是毫秒，以(X/Y)形式表示，代表在Y毫秒内最大运行GC时间为X毫秒（对于CMS收集器，无法直接指定这个目标，通过调整分代大小的方式大致模拟）。纵向是两个软件在对应配置和不同的Java堆容量下的测试结果，V%、avgV%和wV%分别表示以下含义：</p><blockquote><ul><li>V%：表示测试过程中软实时目标失败的概率，软实时目标失败即某个时间片段中实际GC时间超过了允许的最大GC时间。</li><li>avgV%：表示在所有实际GC时间超标的时间片段里，实际GC时间超过最大GC时间的平均百分比（实际GC时间减去允许最大GC时间，再除以总时间片段）。</li><li>wV%：表示在测试结果最差的时间片段里，实际GC时间占用执行时间的百分比。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010123.png" alt="测试结果"></p><p>&emsp;&emsp;从上图测试结果可见，对于telco，软实时目标失败的概率控制在0.5% ~ 0.7%之间，SPECjbb就要差一些，但也在2% ~ 5%之间。概率随着(X/Y)比值减小而增加。另一方面，失败时超出允许GC时间的比值随着总时间片段增加而变小，在(100/200)+512MB配置下，G1收集器出现了某些时间片段下100%时间在进行GC的最坏情况。相比之下CMS收集器的测试结果要差很多，3种Java堆容量下都出现100%GC情况。</p><p>&emsp;&emsp;吞吐量测试中，测试数据取3次SPECjbb和15次telco的平均结果，如下图所示。在SPECjbb应用下，各种配置下的G1表现了一致的行为，吞吐量看起来只与允许最大GC时间成正比关系，而telco应用下，不同配置对于吞吐量的影响则显得很微弱。与CMS收集器的吞吐量对比可以看到，在SPECjbb测试中，在堆容量超过768MB时，CMS收集器有5% ~ 10%的优势，而在telco测试中，优势要小一些，只有3% ~ 4%左右。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010124.png" alt="吞吐量测试结果"></p><p>&emsp;&emsp;如果你的应用追求低停顿，且对现有的收集器不够满意，可以尝试使用G1收集器，否则没有必要。</p><hr><h3 id="4-8-理解GC日志"><a href="#4-8-理解GC日志" class="headerlink" title="4.8 理解GC日志"></a><strong>4.8 理解GC日志</strong></h3><p>&emsp;&emsp;阅读GC日志是处理Java内存问题的基础技能，每种收集器的日志的形式都由其自身实现决定，虚拟机设计者为了方便用户阅读，是有对收集器维护一些共性。如下图所示两段GC日志，“33.125”和“100.667”表示GC发生时间，数字来源于虚拟机启动后经过的秒数。“[GC”和“[Full GC”表示了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC（比如新生代收集器ParNew的日志也会出现Full GC）。如果有Full表示这次GC发生了Stop-The-World。如果是调用System.gc()方法触发的收集，会显示“[Full GC(System)”。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010125.png" alt="GC日志"></p><p>&emsp;&emsp;“[DefNew”，“[Tenured”，“[Perm”表示GC发生的区域，区域名和收集器密切相关。如上述是Serial收集器，新生代名为“Def New Generation”，所以显示DefNew。如果是ParNew收集器，新生代名为“Parallel New Generation”，就显示“[ParNew”。如果是Parallel Scavenge收集器，新生代叫“PSYoungGen”。老年代和新生代一样也由收集器起名决定。</p><p>&emsp;&emsp;“3324K-&gt;152K(3712K)”含义是<strong>GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量(该内存区域总容量)</strong>。方括号外的“3324K-&gt;152K(11904K)”含义是<strong>GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)</strong>。</p><p>&emsp;&emsp;“0.0025925 secs”表示该内存区域GC所占用时间，单位为秒。有些收集器会给出更具体的时间数据“[Time : user=0.01 sys=0.00, real=0.02 secs]”<br>三个参数分别代表用户态消耗的CPU时间，内核态消耗的CPU时间和操作从开始到结束经过的墙钟时间（Wall Clock Time）。当系统有多CPU或多核时，会叠加这些CPU时间，所以user或sys超过real是正常的。</p><blockquote><p>CPU时间和墙钟时间的区别是：墙钟时间包括各种非运算的等待耗时，如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时。</p></blockquote><hr><h3 id="4-9-垃圾收集器参数总结"><a href="#4-9-垃圾收集器参数总结" class="headerlink" title="4.9 垃圾收集器参数总结"></a><strong>4.9 垃圾收集器参数总结</strong></h3><p>&emsp;&emsp;整理了一下垃圾收集相关的常用参数。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010126.png" alt="垃圾收集相关的常用参数"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010127.png" alt="垃圾收集相关的常用参数"></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：垃圾收集算法(标记-清除算法、复制算法、标记-整理算法、分代收集算法)，枚举根节点，安全点，安全区域，垃圾收集器(Serial收集器、ParNew收集器、Parallel Scavenge收集器、Serial Old收集器、Parallel Old收集器、CMS收集器、G1收集器)，理解GC日志，参数总结等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>GitLab（未完成）</title>
    <link href="http://linyishui.top/2019091101.html"/>
    <id>http://linyishui.top/2019091101.html</id>
    <published>2019-09-11T01:30:56.000Z</published>
    <updated>2019-11-11T08:43:49.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a><strong>GitLab</strong></h1><h2 id="第一节-介绍"><a href="#第一节-介绍" class="headerlink" title="第一节 介绍"></a><strong>第一节 介绍</strong></h2><p>&emsp;&emsp;GitLab是由GitLab Inc.开发，使用MIT许可证的基于网络的Git仓库管理工具。它由 Ruby 写成。后来一些部分用 Go 语言重写。</p><h3 id="github和github区别"><a href="#github和github区别" class="headerlink" title="github和github区别"></a><strong>github和github区别</strong></h3><p>&emsp;&emsp;github和github都是基于git的web代码仓库管理软件。区别主要在于github上的仓库基本上都是开源的，当然也可以创建私有的代码仓库，但是费用比较昂贵。而gitlab是可以在企业内部搭建，可以创建私有的代码仓库，除此之外，gitlab还有一些其他的高级特性。相同之处是他们都是基于版本管理系统git，都使用git的命令进行操作。</p><hr><h2 id="第二节-安装"><a href="#第二节-安装" class="headerlink" title="第二节 安装"></a><strong>第二节 安装</strong></h2><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a><strong>选择版本</strong></h3><p>&emsp;&emsp;GitLab是建立在开放核心模型之上的。这意味着GitLab有两个版本: <strong>社区版</strong>和<strong>企业版</strong>。</p><p>&emsp;&emsp;社区版是开放源码的，拥有MIT的外籍许可证。企业版构建在社区版之上，使用相同的核心，但在此基础上添加了其他特性和功能，这是在专有许可下进行的。</p><p>&emsp;&emsp;对于这两个版本: GitLab中的所有javascript代码都是开源的。所有由GitLab编写的javascript代码都在同一个MIT许可下。</p><p>&emsp;&emsp;社区版升级到企业版的过程中需要停机，如果没有许可证企业版不会和社区版有明显差异。</p><p><a href="https://about.gitlab.com/installation" title="Title" target="_blank" rel="noopener">Install GitLab Enterprise Edition.</a></p><p><a href="https://about.gitlab.com/install/?version=ce" title="Title" target="_blank" rel="noopener">Install GitLab Community Edition.</a></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>&emsp;&emsp;安装环境是Ubuntu + Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不加 tag 则默认为最新版本 latest (一般使用这种)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull gitlab/gitlab-ce</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要下载其他版本，加上对应的 tag 即可，如：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull gitlab/gitlab-ce:rc</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;未完待续…</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://about.gitlab.com/install/ce-or-ee/" title="Title" target="_blank" rel="noopener">gitlab社区版和企业版</a></p></blockquote><blockquote><p><a href="http://jemgeek.com/archives/2019/docker-base-install.html" title="Title" target="_blank" rel="noopener">安装 Docker 和 Docker Compose (Ubuntu)</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/63786567" title="Title" target="_blank" rel="noopener">使用 Docker 搭建 GitLab</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/ade38a53b1ac" title="Title" target="_blank" rel="noopener">搭建gitlab仓库</a></p></blockquote><blockquote><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab" title="Title" target="_blank" rel="noopener">服务器上的 Git - GitLab</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/fb61299086b6" title="Title" target="_blank" rel="noopener">Gitlab详细操作</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      GitLab。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器（一）确认对象生死</title>
    <link href="http://linyishui.top/2019091001.html"/>
    <id>http://linyishui.top/2019091001.html</id>
    <published>2019-09-10T10:56:40.000Z</published>
    <updated>2019-11-06T02:01:38.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><strong>垃圾收集器</strong></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>&emsp;&emsp;诞生于1960年的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。如今内存的动态分配和内存回收技术已经非常成熟，了解垃圾收集(GC)和内存分配的原理，从而可以在排查内存溢出和内存泄漏问题时，在垃圾收集成为系统提高并发量的瓶颈时，我们有足够的能力进行监控和调节。</p><p>&emsp;&emsp;<a href="../2019050801.html" title="Title">Java内存区域和内存溢出异常</a>中介绍了内存运行时的各个区域，其中程序计数器、虚拟机栈、本地方法栈三个区域和线程共享相同生命周期；栈中的栈帧随着方法进入和退出进行入栈出栈操作，每个栈帧分配的内存大小在确定类结构时便可得知(不考虑JIT编译器优化)因此这些区域的内存分配和回收都具有确定性，在方法或线程结束时便已回收，所以无需多考虑回收问题。</p><p>&emsp;&emsp;Java堆和方法区则不同，一个接口的多个实现类需要的内存可能不同，一个方法内的多个分支需要的内存也可能不同，只有程序运行时才能得知要创建多少对象，这些区域的内存分配和回收都是动态的，所以值得讨论。</p><hr><h2 id="第一节-对象已死了吗"><a href="#第一节-对象已死了吗" class="headerlink" title="第一节 对象已死了吗"></a><strong>第一节 对象已死了吗</strong></h2><p>&emsp;&emsp;垃圾回收第一件工作便是确认对象是”存活”还是已”死亡”。</p><hr><h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a><strong>1.1 引用计数算法</strong></h3><p>&emsp;&emsp;常见的判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有地方引用它，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>&emsp;&emsp;<strong>引用计数算法</strong>(Reference Counting)的实现简单，判定效率也很高，所以也有很多著名的应用案例。但主流的Java虚拟机都没有选用引用计数算法来管理内存，主要的原因是它很难解决<strong>对象之间相互循环引用</strong>的问题。</p><p>&emsp;&emsp;比如，以下代码中的testGC()方法。objA和objB互相引用，所以计数都不为0，引用计数算法无法通知GC收集器回收它们。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * testGC()执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testGC()&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设在这行发生GC，objA和objB能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但运行并观察GC日志，发现虚拟机并没有因为对象互相引用就没有回收，也印证了虚拟机没有采用引用计数算法。</p><hr><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a><strong>1.2 可达性分析算法</strong></h3><p>&emsp;&emsp;主流商用程序语言的主流实现都是采用<strong>可达性分析</strong>(Reachability Analysis)来判定对象是否存活。基本思路是：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的。</p><p>&emsp;&emsp;如下图所示，对象5、6、7虽然互有关联，但它们到GC Roots是不可达的，所以会被判定为可回收对象。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010113.png" alt="可达性分析算法判定对象是否可回收"></p><blockquote><p>对于Java语言，可被视作GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li></ul></blockquote><hr><h3 id="1-3-引用"><a href="#1-3-引用" class="headerlink" title="1.3 引用"></a><strong>1.3 引用</strong></h3><p>&emsp;&emsp;无论采用哪种算法，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中对引用的定义很传统：<strong>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用</strong>。这种定义方式使对象只有被引用和没被引用两种状态，而无法描述这样一类对象：<strong>当内存空间还足够时，则能保留在内存中；如果内存空间在垃圾收集后还很紧张，则可以清除的对象</strong>。</p><p>&emsp;&emsp;在JDK 1.2以后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>(Strong Reference)、<strong>软引用</strong>(Soft Reference)、<strong>弱引用</strong>(Weak Reference)、<strong>虚引用</strong>(Phantom Reference)4种，这4种引用强度依次逐渐减弱。</p><blockquote><ul><li>强引用就是指在程序代码中普遍存在的，类似“Object obj = new Object()”这类引用，只要强引用还存在，垃圾收集器就不会回收被引用的对象。</li><li>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象列入回收范围之中进行二次回收。如果此次回收仍没有足够内存，才会抛出内存溢出异常。JDK 1.2以后，提供了SoftReference类来实现软引用。</li><li>弱引用也是用来描述非必需对象的，但相较软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。JDK 1.2以后，提供了WeakReference类来实现软引用。</li><li>虚引用也叫做幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间有任何影响，也无法通过虚引用来获取一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。JDK 1.2以后，提供了PhantomReference类来实现软引用。</li></ul></blockquote><hr><h3 id="1-4-生存还是死亡"><a href="#1-4-生存还是死亡" class="headerlink" title="1.4 生存还是死亡"></a><strong>1.4 生存还是死亡</strong></h3><p>&emsp;&emsp;即使在可达性分析算法中不可达的对象也并非是“非死不可”的，它们会先处于一个“缓刑”阶段，真正的迎来对象的死亡至少还要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机会将这两种情况都视为“没有必要执行”。</p><p>&emsp;&emsp;如果这个对象已经被判定为有必要执行finalize()方法，那么这个对象会被放置在一个叫F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去“执行”它。<strong>执行</strong>指的是虚拟机会触发这个方法，但并不承诺会等待它运行结束，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能导致F-Queue队列中其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象想要在这时“拯救自己”——只要重新与引用链上的任意一个对象建立关联即可(譬如把自己赋值给某个类变量或对象的成员变量)，它会在第二次标记时被移除出“即将回收”的集合。</p><p>&emsp;&emsp;以下代码演示对象在执行finalize()方法后仍可以存活。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> *  1.对象可以在被GC时自我拯救</span></span><br><span class="line"><span class="comment"> *  2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动的调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>&#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Throwable</span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功的拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码与上面完全相同，但这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下。SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，且在被收集前成功逃脱了。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finalize</span> <span class="function"><span class="keyword">method</span> <span class="title">executed</span>!</span></span><br><span class="line"><span class="function"><span class="title">yes</span>, <span class="title">i</span> <span class="title">am</span> <span class="title">still</span> <span class="title">alive</span> :</span>)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个值得注意的地方是，两段相同代码，一次逃脱成功，一次失败。原因就是任何对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，finalize()方法不会再次执行。</p><p>&emsp;&emsp;通过finalize()方法来避免GC并不是一种值得提倡的用法，其运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()方法能做的所有工作try-finally和其他方式都可以做个更好，finalize()可以被开发人员忽略。</p><hr><h3 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a><strong>1.5 回收方法区</strong></h3><p>&emsp;&emsp;方法区(HotSpot中的永久代)不强制要求VM实现垃圾收集，在堆中，尤其是新生代中，一次垃圾收集一般可以回收70%~95%的空间，而永久代要远低于此。</p><p>&emsp;&emsp;永久代的垃圾回收主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。</p><p>&emsp;&emsp;回收废弃常量类似于回收Java堆中的对象，以常量池中字面量的回收为例，假设一个字符串“abc”已经进入了常量池中，但当前系统没有任何一个String对象是叫“abc”的，也就是没有任何String对象或其他地方引用常量池中的“abc”常量，如果此时发生内存回收，有必要的话会将此常量清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。</p><h4 id="判断类是否无用"><a href="#判断类是否无用" class="headerlink" title="判断类是否无用"></a><strong>判断类是否无用</strong></h4><blockquote><p>判断类为无用类的三个条件：</p><ul><li>该类所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></blockquote><p>&emsp;&emsp;判断类是否无用相比判断常量是否废弃要苛刻许多，当类满足以上条件时，虚拟机才可以进行回收，但不会像对象一样，不使用就必然会回收。HotSpot虚拟机提供了-Xnoclassgc参数进行控制是否对类进行回收，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p><p>&emsp;&emsp;在大量使用反射、动态反射、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：引用计数算法，可达性分析算法，引用，对象判断生死过程，回收方法区等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机中程序执行过程（未完成）</title>
    <link href="http://linyishui.top/2019090901.html"/>
    <id>http://linyishui.top/2019090901.html</id>
    <published>2019-09-09T06:37:37.000Z</published>
    <updated>2019-11-11T08:44:20.664Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><strong>类加载过程</strong></h1><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a><strong>引文</strong></h2><p>&emsp;&emsp;在Java语言里，<strong>new表达式</strong>是负责创建实例的，调用<strong>构造器</strong>去对实例做初始化；构造器自身的返回值类型是void，并不是“构造器返回了新创建的对象的引用”，而是new表达式的值是新创建的对象的引用。</p><p>&emsp;&emsp;对应的，在JVM里，“new”字节码指令只负责把实例创建出来（包括分配空间、设定类型、所有字段设置默认值等工作），并且把指向新创建对象的引用压到操作数栈顶。此时该引用还不能直接使用，处于未初始化状态（uninitialized）；如果某方法a含有代码试图通过未初始化状态的引用来调用任何实例方法，那么方法a会通不过JVM的字节码校验，从而被JVM拒绝执行。</p><p>&emsp;&emsp;能对未初始化状态的引用做的唯一一种事情就是通过它调用实例构造器，在Class文件层面表现为特殊初始化方法“&lt; init &gt;”。实际调用的指令是invokespecial，而在实际调用前要把需要的参数按顺序压到操作数栈上。在上面的字节码例子中，压参数的指令包括dup和ldc两条，分别把隐藏参数（新创建的实例的引用，对于实例构造器来说就是“this”）与显式声明的第一个实际参数（”ab”常量的引用）压到操作数栈上。<br>在构造器返回之后，新创建的实例的引用就可以正常使用了。</p><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a><strong>举例分析</strong></h3><p>&emsp;&emsp;假设我们要运行Test类，首先虚拟机启动，尝试执行main方法发现类还未加载，即虚拟机还未包含Test类的二进制表示。加载过程通过引导类加载器查找.class并加载Test类。</p><p>&emsp;&emsp;Test类加载后，在调用main之前需要先进行初始化。所有的类或接口在初始化前要先进行链接。链接包括校验、准备和可选的解析。</p><p>&emsp;&emsp;校验阶段会检查被加载的Test类是否良构，是否具有正确的符号表，代码是否遵循Java编程语言和虚拟机的语义要求。</p><p>&emsp;&emsp;准备阶段涉及到静态存储的内存分配，以及所有在Java虚拟机的实现内部需要使用的数据结构的内存分配，比如方法表。</p><p>&emsp;&emsp;解析是检查Test中对其他类和接口的符号引用的过程，通过加载提及的其他类和接口来检查这些引用是否正确。可以选择非常早的解析也可以选择在符号引用被实际使用时再解析。</p><p>&emsp;&emsp;接着进入初始化过程，初始化顺序有所有的类变量初始化器和静态初始化器按行文顺序构成。要求直接超类的初始化顺序必须先于子类。</p><p>&emsp;&emsp;最后，完成初始化后Test类的main方法才会被调用。要求main函数必须声明为：public static void，且必须指定类型为String数组的形式参数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>... args)</span><br></pre></td></tr></table></figure><hr><h2 id="第一节-虚拟机启动"><a href="#第一节-虚拟机启动" class="headerlink" title="第一节 虚拟机启动"></a><strong>第一节 虚拟机启动</strong></h2><p>&emsp;&emsp;<strong>虚拟机的启动</strong>是通过加载指定的类，然后调用指定类中main方法。</p><p>&emsp;&emsp;Java虚拟机会动态的加载、链接与初始化类和接口。</p><blockquote><ul><li>加载是根据特定名称查找类或接口类型的二进制表示(.class)，并由二进制表示来创建类或接口的过程。</li><li>链接是为了让类或接口可以被Java虚拟机执行，而将类或接口并入虚拟机运行时状态的过程。</li><li>类或接口的初始化是指执行类或接口的初始化方法&lt; clinit &gt;</li></ul></blockquote><hr><h2 id="第二节-加载过程"><a href="#第二节-加载过程" class="headerlink" title="第二节 加载过程"></a><strong>第二节 加载过程</strong></h2><p>&emsp;&emsp;<strong>加载</strong>是指查找到具有特定名的类或接口类型的二进制形式的过程。</p><p>&emsp;&emsp;典型实现：获取之前由Java编译器对源代码进行计算产生的二进制表示，从该二进制形式中构建表示该类或接口的Class对象。二进制格式通常是.class文件格式，但也可以是其他满足虚拟机要求的格式。ClassLoader类的defineClass方法可以被用来从class文件格式的二进制表示中构建Class对象。</p><p>&emsp;&emsp;<strong>加载过程</strong>是由ClassLoader类以及其子类实现的。不同子类可以实现不同的加载策略，类加载器可以缓存类或接口的二进制表示、基于预期使用而预抓取它们，以及一起加载有关联的一组类。</p><p>&emsp;&emsp;类加载过程产生了错误，会抛出LinkageError子类(ClassCircularityError，ClassFormatError，NotClassDefFoundError)之一的异常。因为加载涉及到对新数据结构分配内存，所以有可能会抛出OutOfMemoryError。</p><blockquote><p>&emsp;&emsp;创建一个标记为N的类或接口C，首先虚拟机要在方法区上为C创建与虚拟机中实现匹配的内部表示，C的创建可以由另一个类或接口D触发，其运行时常量池引用了C，也可以由D调用反射等方法触发。(数组类直接由Java虚拟机创建，其没有外部的.class二进制表示，非数组类则由类加载器加载.class来创建)</p><p>&emsp;&emsp;虚拟机首先检查加载器L是否被记录为N的初始加载器，如果是则这次尝试创建操作无效，且加载动作会抛出异常LinkageError；如果不是，虚拟机尝试解析.class文件。解析阶段的异常先省略，解析C的直接父类或直接父接口省略。虚拟机标记C的定义类加载器为L，并记录L是C的初始加载器。</p></blockquote><hr><h2 id="第三节-链接过程"><a href="#第三节-链接过程" class="headerlink" title="第三节 链接过程"></a><strong>第三节 链接过程</strong></h2><p>&emsp;&emsp;<strong>链接</strong>是指获取类或接口类型的二进制形式，并将其与Java虚拟机的运行时状态结合起来，使其可以被执行的过程。</p><blockquote><p>链接涉及三种不同的行为：</p><ul><li>校验</li><li>准备</li><li>符号引用的解析</li></ul></blockquote><p>&emsp;&emsp;因为链接涉及到对新数据结构分配内存，所以有可能会抛出OutOfMemoryError。</p><blockquote><p>&emsp;&emsp;链接包括验证和准备类或接口、其直接父类、其直接父接口、其元素类型。解析这个类或接口中的符号引用是链接过程的可选部分，虚拟机可以选择在用到符号引用时再去解析(延迟解析)，或者验证类时就解析每个引用(预先解析)。要求类或接口链接前必须被成功的加载过，初始化之前必须被成功的验证和准备过。</p></blockquote><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a><strong>校验</strong></h3><p>&emsp;&emsp;校验可以保证类或接口的二进制表示在结构上正确。如果校验过程发生错误，会抛出LinkageError的子类VerifyError的异常。</p><blockquote><p>&emsp;&emsp;验证过程可能会使其他类或接口被加载，但未必需要验证或准备他们。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><p>&emsp;&emsp;准备包括创建类或接口的static域(类变量和类常量)和将这些域初始化为缺省值，不需要执行任何源代码，或者说虚拟机字节码指令，静态域的显式初始化器会作为初始化过程的一部分而执行，而不是准备过程的一部分。</p><blockquote><p>Java虚拟机的实现可以在准备阶段预计算额外的数据结构，以使后续对此类或接口的操作更加高效，特别有用的“方法表”或其他具有相同功能的数据结构，允许在类的实例上调用任何方法而无需在调用时搜索其超类。</p></blockquote><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h3><p>&emsp;&emsp;类或接口的二进制表示会使用其他类或接口的二进制名字来以符号方式引用其他类或接口，以及它们的域、方法和构造器。这些符号引用包括域和方法所属的类或接口类型的名字、域和方法自身的名字，以及恰当的类型信息。</p><blockquote><p>符号引用：一组符号描述锁引用的目标，如CONSTANT_XX_info等常量。其引用目标未必加载到内存中。在编译阶段时，类的实际地址还未可知，所以只能用符号引用来代替。</p><p>直接引用：可以是直接指向目标的指针，相对偏移量，一个能间接定位到目标的句柄。有了直接引用目标一定已经加载到内存了。</p></blockquote><p>&emsp;&emsp;在符号引用可以被使用前，它们必须先被解析，在解析时会检查符号引用是否正确，并且在典型情况下，若某个符号引用被重复的使用，那么它会被可以更高效处理的直接引用所替代。</p><p>&emsp;&emsp;如果在解析过程中发生错误，会抛出IncompatibleClassChangeError或其子类(IllegalAccessError，InstantiationError，NoSuchFieldError，NoSuchMethodError)之一。如果一个类声明了一个native方法，但找不到此方法的实现，就会抛出LinkageError的子类UnsatisfiedLinkError。</p><blockquote><p>&emsp;&emsp;<strong>解析</strong>是根据运行时常量池里的符号引用来动态决定具体指的过程，Java虚拟机通过一些指令将符号引用指向运行时常量池，执行指令(anewarray,checkcast,getfield,getstatic,instanceof,invokedynamic,invokeinterface,invokespecial,invokestatic,invokevirtual,ldc,ldc_w,multianewarray,new,putfield,putstatic)需要对符号引用进行解析。对于除invokedynamic以外的指令，碰到此指令并解析它的符号引用后，表示对其他指令相同的符号引用已被解析过了。各种符号引用的解析过程先省略。</p></blockquote><hr><h2 id="第四节-初始化过程"><a href="#第四节-初始化过程" class="headerlink" title="第四节 初始化过程"></a><strong>第四节 初始化过程</strong></h2><p>&emsp;&emsp;类的初始化包括执行其静态初始化器和执行用于在类中声明的static域(类变量)的初始化器。接口的初始化包括执行用于在接口中声明的域(常量)的初始化器。在类被初始化之前，其直接超类必须先被初始化，但该类实现的接口并没有初始化，类似的，接口的超接口在该接口被初始化之前，还没有被初始化。</p><p>&emsp;&emsp;</p><blockquote><p>&emsp;&emsp;初始化对于类或接口就是执行其初始化方法，只有以下指令会导致初始化：new，getstatic，putstatic，invokestatic。这些指令都会通过字段或方法引用来直接或间接引用某个类。执行new指令时，若指令引用的类或接口没初始化则进行初始化。在初始化以前，类或接口必须已经被链接过，即经过了验证和准备阶段，可能已经解析过了。</p></blockquote><blockquote><p>以下情况第一次方式时，类或接口类型T会在紧靠此时刻之前被初始化：</p><ul><li>T是类，并且创建了T的实例</li><li>T是类，并且T声明的static方法被调用</li><li>T声明的static域被赋值</li><li>T声明的static域被使用，并且该域不是常量变量</li><li>T是顶层类，并且在词法上嵌套在T内的assert语句被执行</li></ul></blockquote><p>&emsp;&emsp;对static域的引用只会导致实际声明它的类或接口被初始化，即使它可能是通过子类名、子接口名或实现了某个接口的类名而被引用的。</p><p>&emsp;&emsp;对Class类中和java.lang.reflect包中的某些反射方法的调用也会导致类和接口被初始化。</p><p>&emsp;&emsp;其他任何情况都不会使类或接口被初始化。</p><h3 id="实例-超类在子类之前被初始化"><a href="#实例-超类在子类之前被初始化" class="headerlink" title="实例 超类在子类之前被初始化"></a><strong>实例 超类在子类之前被初始化</strong></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"Super "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"One "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"Two "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        One o = <span class="keyword">null</span>;</span><br><span class="line">        Two t = <span class="keyword">new</span> Two();</span><br><span class="line">        System.out.<span class="built_in">print</span>((<span class="built_in">Object</span>) o == (<span class="built_in">Object</span>) t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。类One永远不会初始化，因此永远不会被链接。类Two只有在其超类Super被初始化之后才会被初始化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Super</span> Two <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="实例-只有声明static域的类才会被初始化"><a href="#实例-只有声明static域的类才会被初始化" class="headerlink" title="实例 只有声明static域的类才会被初始化"></a><strong>实例 只有声明static域的类才会被初始化</strong></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    static int taxi = <span class="number">1729</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    static &#123; <span class="type">System</span>.out.print(<span class="string">"Sub "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">System</span>.out.print(<span class="type">Sub</span>.taxi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。因为Sub类永远没有被初始化，对Sub.taxi的引用实际上是对在Super类中声明的域的引用，它不会触发对Sub类的初始化。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1729</span></span><br></pre></td></tr></table></figure><h3 id="实例-接口初始化不会初始化超接口"><a href="#实例-接口初始化不会初始化超接口" class="headerlink" title="实例 接口初始化不会初始化超接口"></a><strong>实例 接口初始化不会初始化超接口</strong></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface I &#123;</span><br><span class="line">    int i = 1, ii = Test.out(<span class="string">"ii"</span>,2);</span><br><span class="line">&#125;</span><br><span class="line">interface J extends I &#123;</span><br><span class="line">    int j = Test.out(<span class="string">"j"</span>,3), jj = Test.out(<span class="string">"jj"</span>,4);</span><br><span class="line">&#125;</span><br><span class="line">interface K extends J &#123;</span><br><span class="line">    int k = Test.out(<span class="string">"k"</span>,5);</span><br><span class="line">&#125;</span><br><span class="line">interface Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(J.i);</span><br><span class="line">        System.out.println(K.j);</span><br><span class="line">    &#125;</span><br><span class="line">    static int out(String s, int i)&#123;</span><br><span class="line">        System.out.println(s + <span class="string">"="</span> + i);</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。J.i引用的域是一个常量变量，因此它不会使I被初始化。K.j引用的域实际上是在接口J中声明的，它不是常量变量，它会导致J接口的域被初始化，但超接口I中的域和接口K中的域都不会初始化。</p><p>&emsp;&emsp;尽管K被用来引用接口J中的域j，但接口K并不会被初始化。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">j=<span class="number">3</span></span><br><span class="line">jj=<span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="详细的初始化过程"><a href="#详细的初始化过程" class="headerlink" title="详细的初始化过程"></a><strong>详细的初始化过程</strong></h3><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.4.2</p><hr><h2 id="第五节-创建新的类实例"><a href="#第五节-创建新的类实例" class="headerlink" title="第五节 创建新的类实例"></a><strong>第五节 创建新的类实例</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.5</p><hr><h2 id="第六节-类实例的终结"><a href="#第六节-类实例的终结" class="headerlink" title="第六节 类实例的终结"></a><strong>第六节 类实例的终结</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.6</p><hr><h2 id="第七节-卸载类和接口"><a href="#第七节-卸载类和接口" class="headerlink" title="第七节 卸载类和接口"></a><strong>第七节 卸载类和接口</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.7</p><hr><h2 id="第八节-程序退出"><a href="#第八节-程序退出" class="headerlink" title="第八节 程序退出"></a><strong>第八节 程序退出</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.8</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java语言规范》</p></blockquote><blockquote><p>《Java虚拟机规范》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的程序执行过程，包括：虚拟机启动，举例分析，加载过程，链接过程，初始化过程，创建新的类实例，类实例的终结，卸载类和接口，程序退出等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>Git工作流（未完成）</title>
    <link href="http://linyishui.top/2019090801.html"/>
    <id>http://linyishui.top/2019090801.html</id>
    <published>2019-09-08T06:26:04.000Z</published>
    <updated>2019-11-11T08:44:32.695Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/72769536" title="Title" target="_blank" rel="noopener">一种实用的 Git 工作流</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/20866683" title="Title" target="_blank" rel="noopener">如何优雅的使用 Git？</a></p></blockquote><blockquote><p><a href="https://v2ex.com/t/554218" title="Title" target="_blank" rel="noopener">请教大家 master 分支和 release 分支有什么区别</a></p></blockquote><!--https://www.zhihu.com/question/34540623高效阅读Github源代码(2)https://zhuanlan.zhihu.com/p/56435917盘点一下Github上开源的Java面试/学习相关的仓库https://zhuanlan.zhihu.com/p/53881873拒绝重复造轮子！GitHub推出新功能repository templateshttps://zhuanlan.zhihu.com/p/68492736什么样的 GitHub 可以写在简历上？https://zhuanlan.zhihu.com/p/58386954GitHub 上有哪些优秀的 Java 爬虫项目？https://www.zhihu.com/question/31427895--><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      待整理一套比较适合当前工作和私人项目的Git工作流。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>A successful Git branching model-抠脚翻译</title>
    <link href="http://linyishui.top/2019090701.html"/>
    <id>http://linyishui.top/2019090701.html</id>
    <published>2019-09-07T10:24:04.000Z</published>
    <updated>2019-10-23T06:33:02.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>请一定要结合英文原文观看，以防误导。</em></p><h1 id="经典Git分支模型"><a href="#经典Git分支模型" class="headerlink" title="经典Git分支模型"></a><strong>经典Git分支模型</strong></h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a><strong>前文</strong></h2><p>&emsp;&emsp;文章主要介绍作者在撰文前一年左右在自己的项目中(包括工作和私下的)的开发模型，后续的事实证明真的很有成效。文章不会包含任何的项目相关信息，只会涉及分支策略和发布管理的内容。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010103.png" alt="Git分支图"></p><hr><h2 id="为什么选择Git"><a href="#为什么选择Git" class="headerlink" title="为什么选择Git"></a><strong>为什么选择Git</strong></h2><p>&emsp;&emsp;关于Git与集中式源码控制系统的优缺点的详尽讨论，可以参见<a href="http://git.or.cz/gitwiki/GitSvnComparsion" title="Title" target="_blank" rel="noopener">GitSvnComparsion</a>，那里有诸多的论战。</p><p>&emsp;&emsp;作为一名开发者，我更喜欢Git而不是其他任意一个工具。Git真正的改变了开发者对于合并和分支的认知，我来自于古老的CVS/Subversion世界，合并和分支一直被认为是有些可怕的(小心合并冲突，会让你头疼)和偶尔才会做一次的事情。</p><p>&emsp;&emsp;但是对于Git，这些操作变的十分简单和便捷，甚至被认为是日常工作流的核心部分之一。比如在一些CVS/Subversion的书籍中，合并和分支会在比较靠后的章节中才会初次讨论，属于进阶部分；而在Git书籍中却往往在第三章基础部分就已经出现了。</p><p>&emsp;&emsp;因为其简单性和重复性的特征，合并和分支不再是令人害怕的事情。版本控制工具应该在合并/分支上能相比其他工具提供更多的协助。</p><p>&emsp;&emsp;关于工具的介绍已经足够多了，接下来让我们进入开发模型部分。我将要介绍的模型本质上不过是一组流程，每一个团队成员都必须遵守这些流程才能进入到一个受管理的软件开发过程。</p><hr><h2 id="分散但又集中"><a href="#分散但又集中" class="headerlink" title="分散但又集中"></a><strong>分散但又集中</strong></h2><p>&emsp;&emsp;我们使用的仓库体制与这个分支模型能很好的结合在一起，就是使用一个中心”真实(truth)”仓库。需要注意的是，这个仓库只是被我们视为中央仓库(由于Git是DVCS-分布式版本控制系统，因此在技术层面上并没有中央仓库这个东西)。我们先用origin来指代这个仓库，这个名称对于所有Git用户都不会陌生。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010104.png" alt="子团队协作"></p><p>&emsp;&emsp;每个开发者会推送(push)和拉取(pull)到origin，但是除了集中控制的推拉关系外，每个开发者还可以从其他同伴那里拉取变更的内容从而组成了一个个子团队。例如，可能很有用的情况：两个或更多开发者一起工作开发一个新的大功能，这时将正在进行中的工作推送到origin可能会显得过早了。在上图中，有Alice和Bob, Alice和David，以及Clair和David的子团队。</p><p>&emsp;&emsp;从技术上讲，这意味着Alice定义了一个命名为bob的Git remote，指向Bob的仓库，反之亦然。</p><hr><h2 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a><strong>主分支</strong></h2><p>&emsp;&emsp;根本上讲，发展模式在很大程度上受到现有模式的启发。如中央仓库包括两个主要的分支，其生命周期为无限期。</p><ul><li>master</li><li>develop</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010105.png" alt="主分支"></p><p>&emsp;&emsp;每一个Git用户都很熟悉对应origin的master分支，还存在着另一个与master平行的分支叫做develop。</p><p>&emsp;&emsp;我们认为origin/master是HEAD指向的源码一直对应生产就绪状态(production-ready)的主要分支。</p><p>&emsp;&emsp;我们认为origin/develop是HEAD指向的源码一直对应为下一版本提供开发修改的最新一次交付的状态(production-ready)的主要分支，有些人会把它称为“整合分支”，这是所有每晚自动构建的基础。</p><p>&emsp;&emsp;当develop分支中的源码达到稳定点并准备发布时，所有的修改都应该以某种方式合并到master分支，然后用发布号标记。我们会在后面的内容再详细介绍这一部分。</p><p>&emsp;&emsp;因此，每次将修改合并回master分支时，根据定义这其实就是一个新的生产版本。我们通常会对此非常严格，因此理论上讲，每当有提交到master时，我们可以使用Git hook脚本自动构建和推送我们的软件到生产服务器上。</p><hr><h2 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a><strong>辅助分支</strong></h2><p>&emsp;&emsp;除了主分支master和develop以外，我们的开发模型还使用各种辅助分支以帮助团队成员之间进行并行开发，简化功能跟踪，为生产发布做准备，并协助快速解决生产中的实际问题。但与主分支不同的是这些分支的生命周期有限，最终都会被删除。</p><blockquote><p>我们可以使用的不同类型的分支包括：</p><ul><li>Feature branches 功能分支</li><li>Release branches 发布版本分支</li><li>Hotfix branches 热修复分支</li></ul></blockquote><p>&emsp;&emsp;这些分支中的每一个都有其特定的目的，并受严格的规则约束，包括哪些分支可能是其原始分支，哪些分支必须是其合并目标。我们会马上逐个的简单介绍它们。</p><p>&emsp;&emsp;从技术角度看，这些分支绝不是”特殊”的。分支类型是按照我们的使用方式进行的分类，它们本身仍然只是普通的Git分支。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a><strong>Feature分支</strong></h3><blockquote><p>可能源自于：develop</p><p>必须合并回：develop</p><p>分支命名约束：除了master, develop, release-<em>, or hotfix-</em></p></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010106.png" alt="Feature分支"></p><p>&emsp;&emsp;Feature分支(有时也叫主题分支-topic)用于为即将或较远未来发布的版本开发新的功能。当开始开发功能时，此功能将要被合并到的目标版本可能还未可得知。Feature分支的本质是只要功能还在开发中就会一直存在，但最终会合并回develop分支(以确保将新功能加入即将发布的版本)或直接丢弃(如果开发结果令人失望)。</p><p>&emsp;&emsp;Feature分支通常仅存在于开发人员的本地库中，而不会在origin远程库。</p><h4 id="创建一个Feature分支"><a href="#创建一个Feature分支" class="headerlink" title="创建一个Feature分支"></a><strong>创建一个Feature分支</strong></h4><p>&emsp;&emsp;在开始开发一个新功能时，请从develop分支中开启新的分支。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> myfeature develop</span><br><span class="line">Switched to <span class="selector-tag">a</span> new branch <span class="string">"myfeature"</span></span><br></pre></td></tr></table></figure><h4 id="将已完成分支合并入develop分支"><a href="#将已完成分支合并入develop分支" class="headerlink" title="将已完成分支合并入develop分支"></a><strong>将已完成分支合并入develop分支</strong></h4><p>&emsp;&emsp;已经完成的功能可以合并到develop分支，以确保会将它们添加到即将发布的版本。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line"><span class="symbol">$</span> git merge --<span class="keyword">no</span>-ff myfeature</span><br><span class="line"><span class="function"><span class="title">Updating</span></span> ea1b82a.<span class="number">.05e9557</span></span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="symbol">$</span> git branch -d myfeature</span><br><span class="line">Deleted branch myfeature (was <span class="number">05e9557</span>).</span><br><span class="line"><span class="symbol">$</span> git push origin develop</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;–no-ff指令会使合并总会创建一个新的提交对象，即使合并可以通过fast-forward模式来执行。这样可以避免丢失Feature分支的历史信息，并将所有添加了功能的提交分组在一起。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010107.png" alt="对比"></p><p>&emsp;&emsp;在后一种情况下，很难从Git历史记录中看到那些提交对象一起实现了功能——你将不得不手动读取所有的日志信息。在后一种情况下，还原整个功能(即一组提交)确实很令人头疼，但如果使用–no-ff指令则可以很轻松的还原。</p><p>&emsp;&emsp;是的，这会创建更多的(空)提交对象，但收益远大于成本。</p><h3 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a><strong>release分支</strong></h3><blockquote><p>可能源自于：develop</p><p>必须合并回：develop 和 master</p><p>分支命名约束：release-*</p></blockquote><p>&emsp;&emsp;release分支为新的产品版本的发布准备提供支持，允许开发者在最后时刻进行细致的准备工作。此外允许进行小型错误的修复和准备版本的元数据(包括版本号、构建日期等)。</p><p>&emsp;&emsp;从develop分支分离出新的release分支的关键时刻是develop(差不多)对应上新版本的期望状态。至少在这个时间点上，所有针对待构建版本的功能必须合并到develop分支，所有针对未来版本的功能则可能不会——它们必须等到release分支分离出来。</p><p>&emsp;&emsp;正是在release分支的开始为即将发布的版本分配了版本号，较早则没有。直到这一刻，develop分支都对应着”下个版本”的修改，但是直到release分支开始之前，尚不清楚”下个版本”最终会变成0.3还是1.0。相关操作是在release分支开始才发生的，并且由项目的版本号bump规则来执行。</p><h4 id="创建一个release分支"><a href="#创建一个release分支" class="headerlink" title="创建一个release分支"></a><strong>创建一个release分支</strong></h4><p>&emsp;&emsp;release分支是从develop分支上创建的。比如，可以说版本1.1.5是当前的生产版本，我们会有一个大的版本更新即将发布。develop的状态已为”下个版本”准备就绪，我们决定将其确定为版本1.2(而不是1.1.6或2.0)。因此，我们创建了release分支，并通过版本号进行了命名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="keyword">release</span><span class="number">-1.2</span> develop</span><br><span class="line">Switched <span class="keyword">to</span> a <span class="keyword">new</span> branch <span class="string">"release-1.2"</span></span><br><span class="line">$ ./bump-version.sh <span class="number">1.2</span></span><br><span class="line">Files modified successfully, <span class="keyword">version</span> bumped <span class="keyword">to</span> <span class="number">1.2</span>.</span><br><span class="line">$ git <span class="keyword">commit</span> -a -m <span class="string">"Bumped version number to 1.2"</span></span><br><span class="line">[<span class="keyword">release</span><span class="number">-1.2</span> <span class="number">74</span>d9424] Bumped <span class="keyword">version</span> <span class="built_in">number</span> <span class="keyword">to</span> <span class="number">1.2</span></span><br><span class="line"><span class="number">1</span> files <span class="keyword">changed</span>, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;创建并切换到新的分支后，我们bump版本号。bump-version.sh在这里是一个虚构的shell脚本，它会修改一些工作副本的文件并映射到新的版本。当然这可以是一个手动更改——要点是某些文件会更改。然后提交bump版本号。</p><p>&emsp;&emsp;这个新分支可能已经存在了一定的时间，直到版本可以明确地发布出去。在此期间，一些Bug修复可能会应用在此分支上(而不是develop分支)。禁止在这个分支添加新的大型功能，它们必须合并到develop分支，因此需要等待下次大型版本更新。</p><h4 id="完成一个release分支"><a href="#完成一个release分支" class="headerlink" title="完成一个release分支"></a><strong>完成一个release分支</strong></h4><p>&emsp;&emsp;当release分支的状态就绪，并到真实发布阶段时，需要执行一些操作。首先，将release分支合并到master分支(记住，每次对master分支的提交都是一次新的发布)。然后，必须标记对master分支的提交，以便于将来比较容易的对这个历史版本的参考。最后，需要将release分支上的变更重新合并到develop分支，以便将来的发布版本也会包含这些Bug修复。</p><p>&emsp;&emsp;前两个Git步骤：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br><span class="line">$ git merge --no-ff release-<span class="number">1.2</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此发布版本现在已完成，并标记1.2以供将来参考。</p><blockquote><p>编辑：你可能也想使用 -s 或 -u &lt; key &gt;指令来对标记进行加密签名。</p></blockquote><p>&emsp;&emsp;为了保留release分支上所做的修改，我们仍需要将其合并回develop分支。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'develop'</span></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff release-1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="keyword">of</span> changes)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一步很可能导致合并冲突(非常可能发生，因为我们已经修改了版本号)。如果导致了合并冲突，请修复后再提交。</p><p>&emsp;&emsp;现在我们已经完成了工作，可以删除release分支了，不会再需要它了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="built_in">release</span><span class="number">-1.2</span></span><br><span class="line">Deleted branch <span class="built_in">release</span><span class="number">-1.2</span> (was ff452fe).</span><br></pre></td></tr></table></figure><h3 id="Hotfix分支"><a href="#Hotfix分支" class="headerlink" title="Hotfix分支"></a><strong>Hotfix分支</strong></h3><blockquote><p>可能源自于：master</p><p>必须合并回：develop 和 master</p><p>分支命名约束：hotfix-*</p></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010108.png" alt="Hotfix分支"></p><p>&emsp;&emsp;Hotfix分支非常像release分支，他们都为了新的版本发布做准备工作，尽管是未计划过的。他们源自于对未达到期望的实时生产版本的快速反应。当必须立刻解决生产版本中的严重Bug时，可以从master分支上对应生产版本的标记分离出一个Hotfix分支。</p><p>&emsp;&emsp;本质上当一个开发者在准备一个快速的生产修复时，其他团队成员可以继续工作(在develop分支上)。</p><h4 id="创建一个Hotfix分支"><a href="#创建一个Hotfix分支" class="headerlink" title="创建一个Hotfix分支"></a><strong>创建一个Hotfix分支</strong></h4><p>&emsp;&emsp;Hotfix分支是在master分支上创建的。比如，我们说当前正在运行的版本是1.2，并且因为严重的Bug造成了一些问题。而直接在develop分支上进行修改是不稳定的。所以我们会分离出一个Hotfix分支来解决问题。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix<span class="number">-1.2</span><span class="number">.1</span> master</span><br><span class="line">Switched to a new branch <span class="string">"hotfix-1.2.1"</span></span><br><span class="line">$ ./bump-version.sh <span class="number">1.2</span><span class="number">.1</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span><span class="number">.1</span>.</span><br><span class="line">$ git commit -a -m <span class="string">"Bumped version number to 1.2.1"</span></span><br><span class="line">[hotfix<span class="number">-1.2</span><span class="number">.1</span> <span class="number">41e61</span>bb] Bumped version number to <span class="number">1.2</span><span class="number">.1</span></span><br><span class="line"><span class="number">1</span> files <span class="section">changed</span>, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在分离出分支后别忘了bump版本号。</p><p>&emsp;&emsp;然后，修复Bug并在一次或多次提交中提交所有修改内容。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Fixed severe production problem"</span></span><br><span class="line">[hotfix<span class="number">-1.2</span><span class="number">.1</span> abbe5d6] Fixed severe production problem</span><br><span class="line"><span class="number">5</span> files <span class="section">changed</span>, <span class="number">32</span> insertions(+), <span class="number">17</span> deletions(-)</span><br></pre></td></tr></table></figure><h4 id="完成一个Hotfix分支"><a href="#完成一个Hotfix分支" class="headerlink" title="完成一个Hotfix分支"></a><strong>完成一个Hotfix分支</strong></h4><p>&emsp;&emsp;完成工作后，Bug修复需要合并回master分支，也需要合并回develop分支，以确保下一个版本更新也包括这些修复。这与release分支的完成过程非常类似。</p><p>&emsp;&emsp;首先，更新到master分支并标记版本。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br><span class="line">$ git merge --no-ff hotfix-<span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">1.2</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>编辑：你可能也想使用 -s 或 -u &lt; key &gt;指令来对标记进行加密签名。</p></blockquote><p>&emsp;&emsp;然后，也合并修复内容到develop分支。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'develop'</span></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="keyword">of</span> changes)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此规则的一个例外是：<strong>当已存在一个release分支时，需要把修复内容合并到release分支，而不是develop分支</strong>。当release分支已经完成后，合并到release分支的修复内容最终也会合并到develop分支。(如果开发人员需要立即修复这些Bug，并且不能等到release分支完成，也可以安全的将修复内容合并到develop)</p><p>&emsp;&emsp;最后，删除临时分支。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix<span class="number">-1.2</span><span class="number">.1</span></span><br><span class="line">Deleted branch hotfix<span class="number">-1.2</span><span class="number">.1</span> (was abbe5d6).</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>&emsp;&emsp;尽管这个分支模型并没有什么让人震惊的新东西，但本文开头的”全局图”在我们的项目中被证明是很有用的。它形成了一个易于理解的优雅的思维模型，并可以使团队成员对分支和发布过程形成一种共识。</p><p>&emsp;&emsp;此处提供了图片的高质量PDF版本，你可以把它挂在墙上，以便随时快速的参考。</p><p>&emsp;&emsp;更新：为一些提出要求的人：这里是主图表图片(Apple Keynote)的<a href="http://github.com/downloads/nvie/gitflow/Git-branching-model-src.key.zip" title="Title" target="_blank" rel="noopener">gitflow-model.src.key</a>。</p><p><a href="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/Git-branching-model.pdf" target="_blank">Git-branching-model.pdf</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" title="Title" target="_blank" rel="noopener">A successful Git branching model</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      通过本人捉急的四六级英语水平，结合翻译工具和男性的第六感，翻译一篇比较经典的文章《A successful Git branching model》。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>stanford公开课sql基础题</title>
    <link href="http://linyishui.top/2019090601.html"/>
    <id>http://linyishui.top/2019090601.html</id>
    <published>2019-09-06T07:28:55.000Z</published>
    <updated>2019-10-28T12:12:44.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="sql基础题"><a href="#sql基础题" class="headerlink" title="sql基础题"></a><strong>sql基础题</strong></h1><h2 id="一、课件题目"><a href="#一、课件题目" class="headerlink" title="一、课件题目"></a><strong>一、课件题目</strong></h2><p>&emsp;&emsp;Suppose you’ve started a new movie-rating website, and you’ve been collecting data on reviewers’ ratings of various movies. There’s not much data yet, but you can still try out some interesting queries. Here’s the schema:  </p><p>&emsp;&emsp;Movie ( <u>mID</u>, title, year, director )  There is a movie with ID number mID, a title, a release year, and a director.  </p><p>&emsp;&emsp;Reviewer ( <u>rID</u>, name )  The reviewer with ID number rID has a certain name.  </p><p>&emsp;&emsp;Rating ( <u>rID</u>, <u>mID</u>, stars, ratingDate ) [rID, mID are foreign keys] The reviewer rID gave the movie mID a number of stars rating (1-5) on a certain ratingDate. </p><p>&emsp;&emsp;Write SQL statements to answer the following questions: </p><ol><li>Find the titles of all movies directed by Steven Spielberg.  </li><li>Find all years that have a movie that received a rating of 4 or 5, and sort them in increasing order of rating.  </li><li>Find the titles of all movies that have no ratings.  </li><li>Some reviewers didn’t provide a date with their rating. Find the names of all reviewers who have ratings with a NULL value for the date.  </li><li>Write a query to return the ratings data in a more readable format: reviewer name, movie title, stars, and ratingDate. </li><li>For all cases where the same reviewer rated the same movie twice and gave it a higher rating the second time, return the reviewer’s name and the title of the movie.  </li><li>For each movie that has at least one rating, find the highest number of stars that movie received. Return the movie title and number of stars. Sort by movie title. (hint: use GROUP BY)  </li><li>List movie titles and average ratings, from highest-rated to lowest-rated. If two or more movies have the same average rating, list them in alphabetical order.  </li><li>Find the names of all reviewers who have contributed three or more ratings.  </li><li>Find the names of all reviewers who rated Gone with the Wind. </li><li>For any rating where the reviewer is the same as the director of the movie, return the reviewer name, movie title, and number of stars. </li><li>Return all reviewer names and movie names together in a single column, alphabetized. (Sorting by the first name of the reviewer and first word in the title is fine; no need for special processing on last names or removing “The”.) </li><li>Find the titles of all movies not reviewed by Chris Jackson. </li><li>For all pairs of reviewers such that both reviewers gave a rating to the same movie, return the names of both reviewers. Eliminate duplicates, don’t pair reviewers with themselves, and include each pair only once. For each pair, return the names in the pair in alphabetical order. </li><li>For each rating that is the lowest (fewest stars) in the database, return the reviewer name, movie title, and number of stars of such ratings. </li><li>Find the reviewer who reviewed all movies. </li><li>Find the movies reviewed by Sarah Martinez and not reviewed by Chris Jackson. (hint: use NOT IN) </li><li>Find the movies that have been reviewed by at least two reviewers. Please write an SQL with only one SELECT and without GROUP BY. </li><li>Find the movies that have been reviewed by at least two reviewers. Please write an SQL with subquery. </li><li>Find the reviewers who do not review any movie. </li></ol><p>&emsp;&emsp;Note: When you use XAMPP+MySQL to check the correctness of your solution, please be noted that EXCEPT is not supported in MySQL.</p><h2 id="二、建表、数据"><a href="#二、建表、数据" class="headerlink" title="二、建表、数据"></a><strong>二、建表、数据</strong></h2><p>&emsp;&emsp;基于SqlServer。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> standford;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> standford;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> movie(</span><br><span class="line">    <span class="keyword">mid</span> <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="built_in">int</span>,</span><br><span class="line">    director <span class="built_in">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> reviewer(</span><br><span class="line">    rid <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> rating(</span><br><span class="line">    <span class="keyword">mid</span> <span class="built_in">int</span>,</span><br><span class="line">    rid <span class="built_in">int</span>,</span><br><span class="line">    stars <span class="built_in">int</span>,</span><br><span class="line">    ratingDate <span class="built_in">date</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> rating </span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_rating_movie_mid FOREIGN <span class="keyword">KEY</span> (<span class="keyword">mid</span>) <span class="keyword">references</span> movie(<span class="keyword">mid</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> rating </span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_rating_reviewer_rid FOREIGN <span class="keyword">KEY</span> (rid) <span class="keyword">references</span> reviewer(rid);</span><br><span class="line"></span><br><span class="line"><span class="comment">--填充数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">101</span>,<span class="string">'Gone with the Wind'</span>,<span class="number">1939</span>,<span class="string">'Victor Fleming'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">102</span>,<span class="string">'Star Wars'</span>,<span class="number">1977</span>,<span class="string">'George Lucas'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">103</span>,<span class="string">'The Sound of Music'</span>,<span class="number">1965</span>,<span class="string">'Robert Wise'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">104</span>,<span class="string">'E.T.'</span>,<span class="number">1982</span>,<span class="string">'Steven Spielberg'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">105</span>,<span class="string">'Titanic'</span>,<span class="number">1997</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">106</span>,<span class="string">'Snow White'</span>,<span class="number">1937</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">107</span>,<span class="string">'Avatar'</span>,<span class="number">2009</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">108</span>,<span class="string">'Raiders of the Lost Ark'</span>,<span class="number">1981</span>,<span class="string">'Steven Spielberg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">201</span>,<span class="string">'Sarah Martinez'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">202</span>,<span class="string">'Daniel Lewis'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">203</span>,<span class="string">'Brittany Harris'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">204</span>,<span class="string">'Mike Anderson'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">205</span>,<span class="string">'Chris Jackson'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">206</span>,<span class="string">'Elizabeth Thomas'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">207</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">208</span>,<span class="string">'Ashley White'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">201</span>,<span class="number">101</span>,<span class="number">2</span>,<span class="string">'2011-01-22'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">201</span>,<span class="number">101</span>,<span class="number">4</span>,<span class="string">'2011-01-27'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">202</span>,<span class="number">106</span>,<span class="number">4</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">103</span>,<span class="number">2</span>,<span class="string">'2011-01-20'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">108</span>,<span class="number">4</span>,<span class="string">'2011-01-12'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">108</span>,<span class="number">2</span>,<span class="string">'2011-01-30'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">204</span>,<span class="number">101</span>,<span class="number">3</span>,<span class="string">'2011-01-09'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">103</span>,<span class="number">3</span>,<span class="string">'2011-01-27'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">104</span>,<span class="number">2</span>,<span class="string">'2011-01-22'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">108</span>,<span class="number">4</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">206</span>,<span class="number">107</span>,<span class="number">3</span>,<span class="string">'2011-01-15'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">206</span>,<span class="number">106</span>,<span class="number">5</span>,<span class="string">'2011-01-19'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">207</span>,<span class="number">107</span>,<span class="number">5</span>,<span class="string">'2011-01-20'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">208</span>,<span class="number">104</span>,<span class="number">3</span>,<span class="string">'2011-01-02'</span>);</span><br></pre></td></tr></table></figure><h2 id="三、作答"><a href="#三、作答" class="headerlink" title="三、作答"></a><strong>三、作答</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1. Find the titles of all movies directed by Steven Spielberg.  </span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> director = <span class="string">'Steven Spielberg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2. Find all years that have a movie that received a rating of 4 or 5, and sort them in increasing order of rating.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span></span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> </span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> movie.mid = rating.mid</span><br><span class="line">   <span class="keyword">and</span> rating.stars <span class="keyword">in</span> (<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>),<span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--对应</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> rating</span><br><span class="line"><span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> rating.stars <span class="keyword">in</span> (<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> maxStars,<span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3. Find the titles of all movies that have no ratings.  </span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> movie.mid = rating.mid);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4. Some reviewers didn't provide a date with their rating. Find the names of all reviewers who have ratings with a NULL value for the date.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> reviewer.rid = rating.rid</span><br><span class="line">   <span class="keyword">and</span> ratingDate <span class="keyword">is</span> <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--5. Write a query to return the ratings data in a more readable format: reviewer name, movie title, stars, and ratingDate. </span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,</span><br><span class="line">   rating.stars,</span><br><span class="line">   rating.ratingDate</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid;</span><br><span class="line"></span><br><span class="line"><span class="comment">--6. For all cases where the same reviewer rated the same movie twice and gave it a higher rating the second time, return the reviewer's name and the title of the movie.  </span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,ratingDate,stars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(ratingDate) <span class="keyword">as</span> maxDate,<span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span>,rid</span><br><span class="line">           <span class="keyword">from</span> rating</span><br><span class="line">   <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>,rid) maxSelect</span><br><span class="line"><span class="keyword">on</span> rating.rid = maxSelect.rid <span class="keyword">and</span> rating.mid = maxSelect.mid</span><br><span class="line"><span class="keyword">where</span> rating.ratingDate = maxDate <span class="keyword">and</span> rating.stars = maxStars</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating r</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>,rid</span><br><span class="line">         <span class="keyword">having</span> rating.rid = r.rid</span><br><span class="line">            <span class="keyword">and</span> rating.mid = r.mid</span><br><span class="line">            <span class="keyword">and</span> <span class="keyword">count</span>(*) = <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7. For each movie that has at least one rating, find the highest number of stars that movie received. Return the movie title and number of stars. Sort by movie title. (hint: use GROUP BY)  </span></span><br><span class="line"><span class="keyword">select</span> movie.title,maxStars</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> movie.title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--8. List movie titles and average ratings, from highest-rated to lowest-rated. If two or more movies have the same average rating, list them in alphabetical order.  </span></span><br><span class="line"><span class="keyword">select</span> movie.title,<span class="keyword">AVG</span>(stars) <span class="keyword">as</span> avgStars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> movie.mid,movie.title</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">AVG</span>(stars) <span class="keyword">desc</span>,movie.title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--9. Find the names of all reviewers who have contributed three or more ratings.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> rating.rid = reviewer.rid</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> rid</span><br><span class="line"> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--10. Find the names of all reviewers who rated Gone with the Wind. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> rating.mid = movie.mid</span><br><span class="line"> <span class="keyword">where</span> rating.rid = reviewer.rid</span><br><span class="line">           <span class="keyword">and</span> title = <span class="string">'Gone with the Wind'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--11. For any rating where the reviewer is the same as the director of the movie, return the reviewer name, movie title, and number of stars. </span></span><br><span class="line"><span class="comment">--查询导演作为评论人的电影，返回评论人名和电影名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">where</span> reviewer.name = movie.director;</span><br><span class="line"></span><br><span class="line"><span class="comment">--12. Return all reviewer names and movie names together in a single column, alphabetized. (Sorting by the first name of the reviewer and first word in the title is fine; no need for special processing on last names or removing "The".) </span></span><br><span class="line"><span class="comment">--把所有评论人名和电影名放入一列返回，按评论人名和标题名首字母排序，不需要对姓氏进行特殊处理或删除“the”</span></span><br><span class="line"><span class="keyword">select</span> title <span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--13. Find the titles of all movies not reviewed by Chris Jackson. </span></span><br><span class="line"><span class="comment">--查询所有未受Chris Jackson评论的电影名</span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"> <span class="keyword">where</span> rating.mid = movie.mid</span><br><span class="line">           <span class="keyword">and</span> <span class="keyword">name</span> = <span class="string">'Chris Jackson'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">--14. For all pairs of reviewers such that both reviewers gave a rating to the same movie, return the names of both reviewers. Eliminate duplicates, don't pair reviewers with themselves, and include each pair only once. For each pair, return the names in the pair in alphabetical order. </span></span><br><span class="line"><span class="comment">--当有两个评论人给同个电影评论时返回两个评论人名，删除重复项，按姓名排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> reviewer1.name &lt;= reviewer2.name <span class="keyword">then</span> reviewer1.name <span class="keyword">else</span> reviewer2.name <span class="keyword">end</span> a, <span class="comment">--去除顺序相关</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">when</span> reviewer1.name &lt;= reviewer2.name <span class="keyword">then</span> reviewer2.name <span class="keyword">else</span> reviewer1.name <span class="keyword">end</span> b</span><br><span class="line">            <span class="keyword">from</span> rating r1</span><br><span class="line">            <span class="keyword">join</span> reviewer reviewer1 <span class="keyword">on</span> r1.rid = reviewer1.rid</span><br><span class="line"><span class="keyword">join</span> rating r2 <span class="keyword">on</span> r1.mid = r2.mid <span class="keyword">and</span> r1.rid != r2.rid <span class="comment">--配对</span></span><br><span class="line"><span class="keyword">join</span> reviewer reviewer2 <span class="keyword">on</span> r2.rid = reviewer2.rid) m</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a,b <span class="comment">--分组去重</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a,b; <span class="comment">--按姓名排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--顺序相关去重 select * from tb1 group by A, B having count(*) &gt;0;</span></span><br><span class="line"><span class="comment">--顺序不相关去重 select aa,bb from (select case when a&lt;=b then a else b end aa,case when a&lt;=b then b else a end bb from tbl) tt group by aa,bb;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--15. For each rating that is the lowest (fewest stars) in the database, return the reviewer name, movie title, and number of stars of such ratings. </span></span><br><span class="line"><span class="comment">--查询库中的最低评分，返回评论人名，电影名和评分</span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,</span><br><span class="line">   stars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">where</span> rating.stars = (<span class="keyword">select</span> <span class="keyword">min</span>(stars) <span class="keyword">from</span> rating);</span><br><span class="line"></span><br><span class="line"><span class="comment">--16. Find the reviewer who reviewed all movies. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">       <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">distinct</span> rid,<span class="keyword">mid</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line">             <span class="keyword">where</span> reviewer.rid = rating.rid ) a ) <span class="comment">--统计当前用户观看电影数</span></span><br><span class="line">      = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> movie); <span class="comment">--统计电影总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--17. Find the movies reviewed by Sarah Martinez and not reviewed by Chris Jackson. (hint: use NOT IN) </span></span><br><span class="line"><span class="comment">--查询Sarah Martinez有评论而Chris Jackson未评论的电影</span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">mid</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">mid</span> <span class="keyword">from</span> rating,reviewer <span class="keyword">where</span> rating.rid = reviewer.rid <span class="keyword">and</span> reviewer.name = <span class="string">'Sarah Martinez'</span>)</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">mid</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">mid</span> <span class="keyword">from</span> rating,reviewer <span class="keyword">where</span> rating.rid = reviewer.rid <span class="keyword">and</span> reviewer.name = <span class="string">'Chris Jackson'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--18. Find the movies that have been reviewed by at least two reviewers. Please write an SQL with only one SELECT and without GROUP BY. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.mid</span><br><span class="line"><span class="keyword">from</span> rating <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">join</span> rating <span class="keyword">as</span> b </span><br><span class="line"><span class="keyword">on</span> a.mid = b.mid </span><br><span class="line"><span class="keyword">and</span> a.rid != b.rid;</span><br><span class="line"></span><br><span class="line"><span class="comment">--19. Find the movies that have been reviewed by at least two reviewers. Please write an SQL with subquery. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">mid</span>,title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid) &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--20. Find the reviewers who do not review any movie. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> rating <span class="keyword">where</span> reviewer.rid = rating.rid) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="四、答案"><a href="#四、答案" class="headerlink" title="四、答案"></a><strong>四、答案</strong></h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title <span class="keyword">FROM</span> movie <span class="keyword">Where</span> director=<span class="comment">'Steven Spielberg';</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Year,stars <span class="keyword">From</span> movie, rating <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">and</span> (rating.stars = <span class="number">4</span> <span class="keyword">OR</span> rating.stars= <span class="number">5</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> rating.stars ASC;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title <span class="keyword">from</span> movie <span class="keyword">where</span> <span class="keyword">mID</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">from</span> rating )</span><br><span class="line">(mysql does <span class="keyword">not</span> support except)(<span class="keyword">SELECT</span> title <span class="keyword">FROM</span> movie) EXCEPT (<span class="keyword">SELECT</span> title <span class="keyword">FROM</span> movie, rating  <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span> = rating.<span class="keyword">mID</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Name <span class="keyword">FROM</span> reviewer, rating <span class="keyword">WHERE</span> reviewer.rID=rating.rID <span class="keyword">and</span> rating.ratingDate <span class="keyword">is</span> null;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, title, stars, ratingDate <span class="keyword">FROM</span> movie, rating, reviewer <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span> = rating.<span class="keyword">mID</span> <span class="keyword">AND</span> reviewer.rID = rating.rID;</span><br><span class="line"><span class="number">5.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, title, stars, ratingDate <span class="keyword">FROM</span> movie <span class="keyword">join</span> rating <span class="keyword">join</span> reviewer <span class="keyword">ON</span> movie.<span class="keyword">mID</span> = rating.<span class="keyword">mID</span> <span class="keyword">AND</span> reviewer.rID = rating.rID;</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, title <span class="keyword">From</span> movie , reviewer, rating, rating <span class="keyword">as</span> rating2 <span class="keyword">WHERE</span> rating.<span class="keyword">mID</span>=movie.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID=rating.rID <span class="keyword">and</span> rating.rID=rating2.rID <span class="keyword">and</span> rating.<span class="keyword">mID</span> = rating2.<span class="keyword">mID</span> <span class="keyword">and</span> rating.stars&lt;rating2.stars <span class="keyword">and</span> rating.ratingDate&lt;rating2.ratingDate;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title , MAX(stars) <span class="keyword">From</span> movie,rating <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> movie.<span class="keyword">mID</span> <span class="keyword">Order</span> <span class="keyword">by</span> movie.title;</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title, AVG (stars) <span class="keyword">from</span> movie, rating <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span> = rating.<span class="keyword">mID</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> title <span class="keyword">ORDER</span> <span class="keyword">BY</span> AVG (stars) DESC, title ASC;</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">From</span> ((<span class="keyword">SELECT</span> reviewer.name, count(rating.<span class="keyword">mID</span>) <span class="keyword">From</span> reviewer, rating <span class="keyword">Where</span> reviewer.rID = rating.rID <span class="keyword">Group</span> <span class="keyword">by</span> reviewer.rID Having count(rating.<span class="keyword">mID</span>) &gt; <span class="number">2</span>) <span class="keyword">as</span> r);</span><br><span class="line"><span class="number">9.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">From</span> rating <span class="keyword">as</span> r1, rating <span class="keyword">as</span> r2, rating <span class="keyword">as</span> r3, reviewer <span class="keyword">where</span> reviewer.rID=r1.rID <span class="keyword">and</span> r1.rID = r2.rID <span class="keyword">and</span> r2.rID = r3.rID <span class="keyword">and</span> (r1.<span class="keyword">mID</span> &lt;&gt; r2.<span class="keyword">mID</span> <span class="keyword">or</span> r1.ratingDate&lt;&gt;r2.ratingDate) <span class="keyword">and</span> (r2.<span class="keyword">mID</span>&lt;&gt;r3.<span class="keyword">mID</span> <span class="keyword">or</span> r2.ratingDate&lt;&gt;r3.ratingDate) <span class="keyword">and</span> (r1.<span class="keyword">mID</span>&lt;&gt; r3.<span class="keyword">mID</span> <span class="keyword">or</span> r1.ratingDate&lt;&gt;r3.ratingDate);</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">From</span> movie, reviewer, rating <span class="keyword">Where</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID=rating.rID <span class="keyword">and</span> movie.title=<span class="comment">'Gone with the Wind';</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, stars, title <span class="keyword">From</span> movie, reviewer, rating <span class="keyword">Where</span> reviewer.name=movie.director <span class="keyword">AND</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID=rating.rID;</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">From</span> (<span class="keyword">SELECT</span> name <span class="keyword">From</span> reviewer Union <span class="keyword">SELECT</span> title <span class="keyword">as</span> name <span class="keyword">From</span> movie) <span class="keyword">as</span> a <span class="keyword">Order</span> <span class="keyword">by</span> name</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> M.title <span class="keyword">from</span> movie M, rating R <span class="keyword">where</span> M.<span class="keyword">mID</span> = R.<span class="keyword">mID</span> <span class="keyword">and</span> M.title <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> movie.title <span class="keyword">from</span> movie,reviewer,rating <span class="keyword">where</span> movie.<span class="keyword">mID</span>= rating.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID = rating.rID <span class="keyword">and</span> name =<span class="comment">'Chris Jackson')</span></span><br><span class="line"></span><br><span class="line"><span class="number">14.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> re1.name, re2.name <span class="keyword">FROM</span> rating r1, rating r2, reviewer re1, reviewer re2 <span class="keyword">WHERE</span> r1.rID != r2.rID <span class="keyword">AND</span> r1.<span class="keyword">mID</span> = r2.<span class="keyword">mID</span> <span class="keyword">AND</span> re1.rID = r1.rID <span class="keyword">AND</span> re2.rID = r2.rID <span class="keyword">AND</span> re1.name &lt; re2.name;</span><br><span class="line"></span><br><span class="line"><span class="number">15.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name,title,stars <span class="keyword">FROM</span> reviewer,movie,rating <span class="keyword">WHERE</span> stars <span class="keyword">in</span> (<span class="keyword">SELECT</span> min(stars) <span class="keyword">From</span> rating) <span class="keyword">AND</span> reviewer.rid = rating.rid <span class="keyword">and</span> movie.<span class="keyword">mid</span>= rating.<span class="keyword">mid</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> R.rID, R.name <span class="keyword">FROM</span> reviewer R <span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">FROM</span> movie <span class="keyword">WHERE</span> <span class="keyword">mID</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">FROM</span> rating <span class="keyword">WHERE</span> rID = R.rID));</span><br><span class="line">(mysql does <span class="keyword">not</span> support except)<span class="keyword">SELECT</span> R.rID, R.name <span class="keyword">FROM</span> reviewer R <span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">FROM</span> movie EXCEPT(<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">FROM</span> reviewer, rating <span class="keyword">WHERE</span> reviewer.rID = rating.rID));</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> M.* <span class="keyword">from</span> movie M, rating R, reviewer V <span class="keyword">where</span> M.<span class="keyword">mID</span> = R.<span class="keyword">mID</span> <span class="keyword">and</span> V.rID = R.rID <span class="keyword">and</span> name =<span class="comment">'Sarah Martinez' and title not in (SELECT title from movie M, rating R, reviewer V where M.mID = R.mID and V.rID = R.rID and name ='Chris Jackson')</span></span><br><span class="line">(mysql does <span class="keyword">not</span> support except)(<span class="keyword">SELECT</span> M.* <span class="keyword">from</span> movie M, rating R, reviewer V <span class="keyword">where</span> M.<span class="keyword">mID</span> = R.<span class="keyword">mID</span> <span class="keyword">and</span> V.rID = R.rID <span class="keyword">and</span> name =<span class="comment">'Tom') EXCEPT (SELECT * from movie M, rating R, reviewer V where M.mID = R.mID and V.rID = R.rID and name ='Jerry')</span></span><br><span class="line"></span><br><span class="line"><span class="number">18.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title <span class="keyword">From</span> reviewer, rating, movie, rating <span class="keyword">as</span> rating1 <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID=rating.rID <span class="keyword">and</span> rating.rID!=rating1.rID <span class="keyword">and</span> rating.<span class="keyword">mID</span> = rating1.<span class="keyword">mID</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">19.</span><span class="keyword">SELECT</span> * <span class="keyword">from</span> movie M <span class="keyword">where</span> M.<span class="keyword">mID</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> R.<span class="keyword">mID</span> <span class="keyword">from</span> rating R <span class="keyword">GROUP</span> <span class="keyword">BY</span> R.<span class="keyword">mID</span> having count(rID) &gt;= <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">20.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> reviewer.name <span class="keyword">From</span> reviewer <span class="keyword">where</span> reviewer.name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> reviewer.name <span class="keyword">From</span> reviewer,rating <span class="keyword">Where</span> reviewer.rID=rating.rID);</span><br><span class="line">(mysql does <span class="keyword">not</span> support except)<span class="keyword">SELECT</span> reviewer.name <span class="keyword">From</span> reviewer Except (<span class="keyword">SELECT</span> reviewer.name <span class="keyword">From</span> reviewer,rating <span class="keyword">Where</span> reviewer.rID=rating.rID);</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>stanford-sql课件第二章英文版</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      stanford公开课sql基础题
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
      <category term="database" scheme="http://linyishui.top/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Git &lt;整&gt;</title>
    <link href="http://linyishui.top/2019090501.html"/>
    <id>http://linyishui.top/2019090501.html</id>
    <published>2019-09-05T09:13:47.000Z</published>
    <updated>2019-10-21T10:08:04.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;<em>内容主要整理自<a href="https://www.liaoxuefeng.com/wiki/896043488029600" title="Title" target="_blank" rel="noopener">廖雪峰的官方网站</a>，如果读后有收获可以去链接网站扫码打赏支持一下。</em></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h1><h2 id="第一节-什么是Git"><a href="#第一节-什么是Git" class="headerlink" title="第一节 什么是Git"></a><strong>第一节 什么是Git</strong></h2><p>&emsp;&emsp;Git是一款开源的分布式版本控制系统。分布式即多人多用户，通过拷贝镜像的方式运转，版本控制即对项目的历史版本记录。Git最早来源于Linux的作者Linus，通过C语言开发，后来的GitHub则专门为开源项目提供免费的Git存储服务。</p><p>&emsp;&emsp;CVS和SVN都是集中式的版本控制系统。</p><blockquote><p>集中式和分布式的区别：</p><p>&emsp;&emsp;集中式的版本库存放于中央服务器，开发者需要从服务器获取最新版本，然后将更新内容发送给服务器。所以集中式要求必须要在联网环境下才能工作。分布式系统则没有中央服务器，每台用户电脑都有完整的版本库，所以不需要联网环境，在修改时把各自修改的内容互相推送来进行协作。通常会有一台机器充当”中央服务器”，方便记录所有人的修改。</p></blockquote><hr><h2 id="第二节-安装"><a href="#第二节-安装" class="headerlink" title="第二节 安装"></a><strong>第二节 安装</strong></h2><p>&emsp;&emsp;根据自己的操作系统(Linux，Unix，Mac，Windows等)进行安装，具体过程不贴，网上可以随处找到。</p><hr><h2 id="第三节-版本库"><a href="#第三节-版本库" class="headerlink" title="第三节 版本库"></a><strong>第三节 版本库</strong></h2><p>&emsp;&emsp;<strong>版本库</strong>(repository)，即项目仓库。可以理解为一个盒子或者目录，里面所有文件都会被Git管理，所以每个文件的各种操作都会被记录下来，可以随时追踪其历史，并还原某个时间点所处的状态。</p><h3 id="添加、提交、查看"><a href="#添加、提交、查看" class="headerlink" title="添加、提交、查看"></a><strong>添加、提交、查看</strong></h3><blockquote><p>git init </p></blockquote><p>&emsp;&emsp;此命令可以把当前目录作为Git可以管理的仓库。执行后会多出.git目录，用来跟踪管理版本库，默认隐藏。</p><p>&emsp;&emsp;所有的版本控制系统只能跟踪文本文件的改动，如txt，html，java等，可以记录文件中所有文本的变动。但对于图片和视频这些二进制文件，系统无法记录具体的变化(Word文件是二进制格式，所以无法跟踪其文本变更)。</p><blockquote><p>git add readme.txt</p></blockquote><p>&emsp;&emsp;在目录下创建readme文件，然后执行上述命令，告诉Git将文件添加到仓库。</p><blockquote><p>git commit -m “add a new txt”</p></blockquote><p>&emsp;&emsp;通过git commit指令告诉Git，把文件提交给仓库。-m后跟提交说明，可多次add添加，一次统一提交commit。</p><blockquote><p>git status</p></blockquote><p>&emsp;&emsp;修改readme文件内容，再执行上述指令，返回信息表示文件已修改但未提交</p><p>&emsp;&emsp;再一次执行git add，然后git status，发现返回信息更新，表示文件准备提交，最后git commit。然后git status，发现目录没有需要提交的文件。</p><blockquote><p>git diff</p></blockquote><p>&emsp;&emsp;如果文件修改，可以通过上述指令查看修改内容。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a><strong>版本回退</strong></h3><blockquote><p>git log</p></blockquote><p>&emsp;&emsp;通过上述指令，可以查看操作日志，</p><blockquote><p>git reset –hard HEAD^</p></blockquote><blockquote><p>git reset –hard 1094a</p></blockquote><p>&emsp;&emsp;git reset指令回退目录到指定版本，版本号不需要输入完整，Git会自动查询匹配</p><blockquote><p>git reflog</p></blockquote><p>&emsp;&emsp;可以通过git reflog指令查看每次操作，而回退版本只是修改当前版本为旧版本，并更新文件，但不会影响被覆盖的版本，仍可以随时切换回。</p><hr><h2 id="第四节-工作区和暂存区"><a href="#第四节-工作区和暂存区" class="headerlink" title="第四节 工作区和暂存区"></a><strong>第四节 工作区和暂存区</strong></h2><p>&emsp;&emsp;工作区就是开发人员PC中可以看到的文件目录，工作区有一个隐藏目录.git，是Git的<strong>版本库</strong>。</p><p>&emsp;&emsp;版本库内有一块<strong>暂存区</strong>state，git add指令就是将文件修改添加到暂存区。而git commit则是将暂存区内容提交到当前分支。Git会默认自动创建一个master分支，所以此时会将修改内容提交到master分支。</p><h3 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a><strong>文件修改</strong></h3><p>&emsp;&emsp;Git专注于修改而不是文件，可以通过以下案例来了解相关内容。</p><p>&emsp;&emsp;尝试执行以下指令顺序。</p><blockquote><ol><li>修改文件</li><li>git add xx</li><li>git status</li><li>再修改文件</li><li>git commit -m “git tracks changes”</li><li>git status</li></ol></blockquote><p>&emsp;&emsp;会发现后一次修改并未提交，信息如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        modified:   t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原因是在第一次修改后，执行了git add到暂存区，然后再进行二次修改，再提交时把暂存区内容提交，但二次修改还未加入暂存区。所以修改后必须要先add再提交才会有效果。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a><strong>撤销修改</strong></h3><blockquote><ol><li>修改文件，添加一行文字</li><li>add，commit</li><li>删除此行</li><li>git status</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        modified:   t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>git checkout – <file></file></p></blockquote><p>&emsp;&emsp;git checkout指令表示可以撤销修改，分为两种情况：1.文件修改后还未add到暂存区，撤销后就和版本库一致。2.文件已添加到暂存区，又做了修改，撤销修改就回到add后的状态。总之就是让此文件回到最近一次commit或add的状态。</p><blockquote><p>git reset HEAD <file></file></p></blockquote><p>&emsp;&emsp;通过此指令可以把暂存区的修改撤销，重新放回工作区。</p><p>&emsp;&emsp;如果想回退已经commit的修改，则需要通过前文的版本回退。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h3><p>&emsp;&emsp;先删除文件，再git status。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        deleted:    t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Git发现文件被删除，所以我们通过rm删除，并commit，使文件从版本库也删除。</p><blockquote><p>git rm <file></file></p></blockquote><p>&emsp;&emsp;还有可能删除了，可以通过checkout恢复。</p><hr><h2 id="第五节-远程仓库"><a href="#第五节-远程仓库" class="headerlink" title="第五节 远程仓库"></a><strong>第五节 远程仓库</strong></h2><p>&emsp;&emsp;实际开发中，我们需要一台服务器作为远程仓库来备份版本库以及作为用户的协调中枢。而GitHub就是提供Git仓库托管服务的网站。</p><p>&emsp;&emsp;注册账号过程跳过。本地Git仓库和GitHub远程仓库是通过SSH加密传输的，所以需要配置密钥。</p><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“</p></blockquote><p>&emsp;&emsp;可以通过上述命令创建SSH Key，然后在用户文档，找到.ssh目录，会有id_rsa和id_rsa.pub两个文件，即SSH Key的密钥对，pub表示公钥。然后在github网站配置SSH Keys。</p><p>&emsp;&emsp;然后可以在GitHub上创建一个远程仓库。然后复制SSH地址：Clone with SSH</p><blockquote><p>$ git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xx1/xx2</p></blockquote><p>&emsp;&emsp;通过此命令可以关联本地仓库和远程仓库，xx1是用户名，xx2为项目名。Git默认会给远程库起名origin。</p><blockquote><p>$ git push -u origin master</p></blockquote><blockquote><p>$ git push origin master</p></blockquote><p>&emsp;&emsp;通过此命令把本地库所有内容推送到远程库。由于远程库是空的，所以首次推送添加了-u参数，Git不但会把本地master分支内容推送到远程新的master分支，还会将他们关联，以后的推送或拉取就可以简化命令。</p><blockquote><p>$ git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xx1/xx2</p></blockquote><p>&emsp;&emsp;上面是先有本地库再开启远程库，此命令则是先有远程库时克隆其内容到本地。</p><hr><h2 id="第六节-分支管理"><a href="#第六节-分支管理" class="headerlink" title="第六节 分支管理"></a><strong>第六节 分支管理</strong></h2><p>&emsp;&emsp;Git的分支管理要远远优秀于SVN。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010103.png" alt="Git分支图"></p><p>&emsp;&emsp;master分支即主分支，可以把Head看作指针，HEAD指向当前分支，而分支则指向提交。每个点就是一次提交，所以每次commit就会推动分支前进一步。新的分支则处在一条新的时间线，在平时各个分支间没有任何关系。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a><strong>创建与合并分支</strong></h3><p>&emsp;&emsp;Git创建分支效率很高，创建新的分支指针，再更新HEAD的指向即可。当一个分支上任务结束，则需要合并到主分支上，合并就是matser直接指向当前提交，就完成了合并工作。合并之后可以删除没用的分支。</p><blockquote><p>$ git checkout -b dev</p></blockquote><blockquote><p>$ git branch dev</p><p>$ git checkout dev</p></blockquote><p>&emsp;&emsp;创建并切换到dev分支，-b参数表示创建并切换，等价于后两条指令。</p><blockquote><p>$ git branch</p></blockquote><p>&emsp;&emsp;查看当前分支。</p><blockquote><p>$ git checkout master</p></blockquote><p>&emsp;&emsp;切换回master分支。</p><blockquote><p>$ git merge dev</p></blockquote><p>&emsp;&emsp;合并指定分支到当前分支。</p><blockquote><p>$ git branch -d dev</p></blockquote><p>&emsp;&emsp;合并后删除分支。</p><blockquote><p>$ git switch -c dev</p><p>$ git switch matser</p></blockquote><p>&emsp;&emsp;新版本推荐用switch指令代替checkout来进行切换，后者容易和撤销修改搞混。-c参数表示创建。</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h3><blockquote><ol><li>创建新分支：$ git switch -c feature1</li><li>修改文件内容。</li><li>提交修改到分支：$ git add x.txt  $ git commit -m “feature1 submit”</li><li>切换到master分支(Git提醒当前master分支比origin/master分支超前)：$ git switch master</li><li>在修改文件上新增内容。</li><li>提交：$ git add x.txt $ git commit -m “master submit”</li><li>执行合并分支请求：$ git merge feature1</li></ol></blockquote><p>&emsp;&emsp;结果Git提示发生冲突，可以通过git status查看冲突文件，也可以直接查看冲突文件。修改文件内容，再提交解决冲突部分。可以删除分支feature1了。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a><strong>分支管理策略</strong></h3><p>&emsp;&emsp;通常情况下，合并分支是fast forward模式，但此模式删除分支会失去分支信息。如果禁用fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><blockquote><p>$ git switch -c dev</p></blockquote><p>&emsp;&emsp;创建并切换dev分支</p><blockquote><p>$ git add readme.txt </p><p>$ git commit -m “add merge”</p></blockquote><p>&emsp;&emsp;修改readme.txt，并提交。</p><blockquote><p>$ git switch matser</p></blockquote><p>&emsp;&emsp;切回master</p><blockquote><p>$ git merge –no-ff -m “merge with no-ff” dev</p></blockquote><p>&emsp;&emsp;合并dev分支，–no-ff参数，表示禁用Fast forward</p><blockquote><p>$ git log</p></blockquote><p>&emsp;&emsp;合并后，用git log看看分支历史</p><p>&emsp;&emsp;在实际开发中，master分支应该仅用来发布新版本，不能直接在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a><strong>Bug分支</strong></h3><p>&emsp;&emsp;在Git创建和删除分支是比较简洁的操作，所以每个bug都可以通过一个新的临时分支来修复，修复后再合并分支，然后将临时分支删除。</p><p>&emsp;&emsp;假定一个工作场景：你接到一个编号101的bug修复任务，很自然地你想创建一个分支issue-101来修复它，但是当前正在dev上进行的工作还没有提交。</p><blockquote><p>$ git status</p></blockquote><p>&emsp;&emsp;预计完成还需1天时间。但是必须在两个小时内修复该bug，怎么办？幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p><blockquote><p>$ git stash</p></blockquote><p>&emsp;&emsp;现在用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>&emsp;&emsp;首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支。</p><blockquote><p>$ git switch master</p><p>$ git switch -c issue-101</p></blockquote><p>&emsp;&emsp;然后修复bug，提交。</p><blockquote><p>$ git add readme.txt </p><p>$ git commit -m “fix bug 101”</p></blockquote><p>&emsp;&emsp;修复完成后，切换到master分支，并完成合并，最后删除issue-101分支。</p><blockquote><p>$ git switch master</p><p>$ git merge –no-ff -m “merged bug fix 101” issue-101</p></blockquote><p>&emsp;&emsp;回到dev分支继续工作。</p><blockquote><p>$ git switch dev</p><p>$ git status</p></blockquote><p>&emsp;&emsp;通过git stash list查看之前保存的工作现场</p><blockquote><p>$ git stash list</p></blockquote><p>&emsp;&emsp;找到工作现场后，就要恢复工作现场。一是用git stash apply恢复，但是恢复后stash内容并不删除，需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了。</p><blockquote><p>$ git stash pop</p><p>$ git stash list</p></blockquote><p>&emsp;&emsp;如果保存了多次现场，可以指定恢复。</p><blockquote><p>$ git stash apply stash@{0}</p></blockquote><p>&emsp;&emsp;修改BUG是在master上开分支最后合并的，那么当前dev分支一定还存在相同BUG，为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支。</p><blockquote><p>$ git branch</p><p>$ git cherry-pick 4c805e2</p></blockquote><p>&emsp;&emsp;复制提交：4c805e2 fix bug 101。Git自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2，因为这两个commit只是改动相同，但确实是两个不同的commit。用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>&emsp;&emsp;既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要git stash命令保存现场，才能从dev分支切换到master分支。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a><strong>Feature分支</strong></h3><p>&emsp;&emsp;添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以每添加一个新功能，最好新建一个feature分支，在上面进行开发，完成后再合并，最后删除该feature分支。</p><p>&emsp;&emsp;假设我们收到了一个开发任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><blockquote><p>$ git switch -c feature-vulcan</p></blockquote><p>&emsp;&emsp;开发完毕，提交。</p><blockquote><p>$ git add vulcan.py</p><p>$ git status</p><p>$ git commit -m “add feature vulcan”</p></blockquote><p>&emsp;&emsp;切回dev，准备合并。</p><blockquote><p>$ git switch dev</p></blockquote><p>&emsp;&emsp;正常流程，合并成功然后删除。但是有些特殊情况，比如上级命令因经费不足，新功能必须取消。虽然白干了，但是这个包含机密资料的分支还是必须就地销毁。</p><blockquote><p>$ git branch -d feature-vulcan</p></blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error: </span>The branch 'feature-vulcan' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D feature-vulcan'.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。</p><p>&emsp;&emsp;强行删除。</p><blockquote><p>$ git branch -D feature-vulcan</p></blockquote><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a><strong>多人协作</strong></h3><p>&emsp;&emsp;当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程仓库的默认名称是origin。</p><p>&emsp;&emsp;要查看远程库的信息，就用git remote，或者用git remote -v显示更详细的信息，上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p><blockquote><p>$ git remote</p></blockquote><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a><strong>推送分支</strong></h4><p>&emsp;&emsp;<strong>推送分支</strong>就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样Git就会把该分支推送到远程库对应的远程分支上。</p><blockquote><p>$ git push origin master</p></blockquote><p>&emsp;&emsp;如果要推送其他分支，比如dev，就改成。</p><blockquote><p>$ git push origin dev</p></blockquote><p>&emsp;&emsp;但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><p>master分支是主分支，因此要时刻与远程同步；</p></li><li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a><strong>抓取分支</strong></h4><p>&emsp;&emsp;多人协作时，大家都会往master和dev分支上推送各自的修改。</p><blockquote><p>$ git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xx/xx</p></blockquote><p>&emsp;&emsp;当团队成员从远程库clone时，默认情况下，他只能看到本地的master分支，可以用git branch命令看看。</p><blockquote><p>$ git branch</p></blockquote><p>&emsp;&emsp;当成员需要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支。</p><blockquote><p>$ git switch -c dev origin/dev</p></blockquote><p>&emsp;&emsp;现在，他就可以在dev上继续修改，然后时不时地把dev分支push到远程：</p><blockquote><p>$ git add env.txt</p><p>$ git commit -m “add env”</p><p>$ git push origin dev</p></blockquote><h4 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h4><p>&emsp;&emsp;其他成员已经向origin/dev分支推送了他的提交，可能碰巧你也对同样的文件作了修改，并试图推送。</p><blockquote><p>$ git add env.txt</p><p>$ git commit -m “add new env”</p><p>$ git push origin dev</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:xx/xx</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">'git@github.com:xx/xx'</span></span><br><span class="line">hin<span class="variable">t:</span> Updates were rejected because the tip of your current branch <span class="keyword">is</span> behind</span><br><span class="line">hin<span class="variable">t:</span> its remote counterpart. Integrate the remote <span class="keyword">changes</span> (<span class="keyword">e</span>.g.</span><br><span class="line">hin<span class="variable">t:</span> <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hin<span class="variable">t:</span> See the <span class="string">'Note about fast-forwards'</span> in <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;推送失败，因为他人的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</p><blockquote><p>$ git pull</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">There is <span class="literal">no</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify which branch you want <span class="keyword">to</span> merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you wish <span class="keyword">to</span> <span class="builtin-name">set</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch <span class="attribute">--set-upstream-to</span>=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示设置dev和origin/dev的链接。</p><blockquote><p>$ git branch –set-upstream-to=origin/dev dev</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch <span class="string">'dev'</span> <span class="built_in">from</span> <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再pull。</p><blockquote><p>$ git pull</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (<span class="built_in">add</span>/<span class="built_in">add</span>): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Automatic <span class="built_in">merge</span> failed; fix conflicts <span class="keyword">and</span> <span class="keyword">then</span> commit <span class="keyword">the</span> <span class="built_in">result</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后提交，再push：</p><blockquote><p>$ git commit -m “fix env conflict”</p><p>$ git push origin dev</p></blockquote><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a><strong>Rebase</strong></h3><p>&emsp;&emsp;多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的开发人员不得不先pull，在本地合并，然后才能push成功。</p><p>&emsp;&emsp;所以每次合并再push后，分支变成了这样。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span> d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line"><span class="symbol">*</span>   e5e69f1 Merge branch 'dev'</span><br><span class="line">|<span class="string">\  </span></span><br><span class="line">|<span class="string"> *   57c53ab (origin/dev, dev) fix env conflict</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">\  </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> * 7a5e5dd add env</span></span><br><span class="line">|<span class="string"> * </span>|<span class="string"> 7bd91f1 add new env</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">/  </span></span><br><span class="line"><span class="string">* </span>|<span class="string">   12a631b merged bug fix 101</span></span><br><span class="line">|<span class="string">\ \  </span></span><br><span class="line">|<span class="string"> * </span>|<span class="string"> 4c805e2 fix bug 101</span></span><br><span class="line">|<span class="string">/ /  </span></span><br><span class="line"><span class="string">* </span>|<span class="string">   e1e9c68 merge with no-ff</span></span><br><span class="line">|<span class="string">\ \  </span></span><br><span class="line">|<span class="string"> </span>|<span class="string">/  </span></span><br><span class="line">|<span class="string"> * f52c633 add merge</span></span><br><span class="line">|<span class="string">/  </span></span><br><span class="line"><span class="string">*   cf810e4 conflict fixed</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看上去很乱，Git的提交历史可以是一条干净的直线吗？Git有一种称为rebase的操作，有人把它翻译成“变基”。</p><p>&emsp;&emsp;在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">* <span class="number">582</span>d922 (HEAD -&gt; master) <span class="keyword">add</span><span class="bash"> author</span></span><br><span class="line"><span class="bash">* 8875536 add comment</span></span><br><span class="line"><span class="bash">* d1be385 (origin/master) init hello</span></span><br><span class="line"><span class="bash">*   e5e69f1 Merge branch <span class="string">'dev'</span></span></span><br><span class="line"><span class="bash">|\  </span></span><br><span class="line"><span class="bash">| *   57c53ab (origin/dev, dev) fix env conflict</span></span><br><span class="line"><span class="bash">| |\  </span></span><br><span class="line"><span class="bash">| | * 7a5e5dd add env</span></span><br><span class="line"><span class="bash">| * | 7bd91f1 add new env</span></span><br><span class="line"><span class="bash">...</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。</p><p>&emsp;&emsp;现在我们尝试推送本地分支。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line">To github.com:xx/xx</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch <span class="keyword">first</span>)</span><br><span class="line">error: failed <span class="built_in">to</span> push some refs <span class="built_in">to</span> <span class="string">'git@github.com:xx/xx'</span></span><br><span class="line">hint: Updates were rejected because <span class="keyword">the</span> remote <span class="keyword">contains</span> work that you <span class="built_in">do</span></span><br><span class="line">hint: <span class="keyword">not</span> have locally. This is usually caused <span class="keyword">by</span> another repository pushing</span><br><span class="line">hint: <span class="built_in">to</span> <span class="keyword">the</span> same ref. You may want <span class="built_in">to</span> <span class="keyword">first</span> integrate <span class="keyword">the</span> remote changes</span><br><span class="line">hint: (e.g., <span class="string">'git pull ...'</span>) <span class="keyword">before</span> pushing again.</span><br><span class="line">hint: See <span class="keyword">the</span> <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很不幸失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line">remote: Counting object<span class="variable">s:</span> <span class="number">3</span>, done.</span><br><span class="line">remote: Compressing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">1</span>), reused <span class="number">3</span> (delta <span class="number">1</span>), pack-reused <span class="number">0</span></span><br><span class="line">Unpacking object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">From github.<span class="keyword">com</span>:xx/xx</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [<span class="keyword">new</span> <span class="keyword">tag</span>]         v1.<span class="number">0</span>       -&gt; v1.<span class="number">0</span></span><br><span class="line">Auto-merging hello.<span class="keyword">py</span></span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> hello.<span class="keyword">py</span> | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再用git status看看状态。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Your branch <span class="keyword">is</span> ahead <span class="keyword">of</span> <span class="comment">'origin/master' by 3 commits.</span></span><br><span class="line">  (use <span class="string">"git push"</span> <span class="keyword">to</span> publish your local commits)</span><br><span class="line"></span><br><span class="line"><span class="literal">nothing</span> <span class="keyword">to</span> commit, working tree clean</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。用git log看看。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--graph --pretty=oneline --abbrev-commit</span></span><br><span class="line"></span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch <span class="string">'master'</span> <span class="keyword">of</span> github.com:xx/xx</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) <span class="built_in">set</span> exit=<span class="number">1</span></span><br><span class="line">* | <span class="number">582</span>d922 <span class="built_in">add</span> author</span><br><span class="line">* | <span class="number">8875536</span> <span class="built_in">add</span> comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在的状况就是提交历史分叉了，如果现在把本地分支push到远程，也是正确的，但对于一些人来说会觉得有些影响阅读。这个时候，rebase就派上了用场。我们输入命令git rebase试试。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line"></span><br><span class="line">First, rewinding head <span class="keyword">to</span> replay your work on top of it<span class="built_in">..</span>.</span><br><span class="line">Applying: <span class="builtin-name">add</span> comment</span><br><span class="line">Using index <span class="builtin-name">info</span> <span class="keyword">to</span> reconstruct a base tree<span class="built_in">..</span>.</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back <span class="keyword">to</span> patching base <span class="keyword">and</span> 3-way merge<span class="built_in">..</span>.</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: <span class="builtin-name">add</span> author</span><br><span class="line">Using index <span class="builtin-name">info</span> <span class="keyword">to</span> reconstruct a base tree<span class="built_in">..</span>.</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back <span class="keyword">to</span> patching base <span class="keyword">and</span> 3-way merge<span class="built_in">..</span>.</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出了一大堆操作，到底是啥效果？再用git log看看：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) <span class="builtin-name">add</span> author</span><br><span class="line">* 3611cfe <span class="builtin-name">add</span> comment</span><br><span class="line">* f005ed4 (origin/master) <span class="builtin-name">set</span> <span class="attribute">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原本分叉的提交现在变成一条直线了。原理非常简单，Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。</p><p>&emsp;&emsp;这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>&emsp;&emsp;最后，通过push操作把本地分支推送到远程。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="type">Counting</span> objects: <span class="number">6</span>, <span class="keyword">done</span>.</span><br><span class="line"><span class="type">Delta</span> compression using up <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line"><span class="type">Compressing</span> objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), <span class="keyword">done</span>.</span><br><span class="line"><span class="type">Writing</span> objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), <span class="number">576</span> <span class="built_in">bytes</span> | <span class="number">576.00</span> <span class="type">KiB</span>/s, <span class="keyword">done</span>.</span><br><span class="line"><span class="type">Total</span> <span class="number">6</span> (delta <span class="number">2</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: <span class="type">Resolving</span> deltas: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), completed <span class="keyword">with</span> <span class="number">1</span> local <span class="keyword">object</span>.</span><br><span class="line"><span class="type">To</span> github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..<span class="number">7e61</span>ed4  master -&gt; master</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再用git log看看效果，远程分支的提交历史也是一条直线。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) <span class="builtin-name">add</span> author</span><br><span class="line">* 3611cfe <span class="builtin-name">add</span> comment</span><br><span class="line">* f005ed4 <span class="builtin-name">set</span> <span class="attribute">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;rebase操作可以把本地未push的分叉提交历史整理成直线；rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><hr><h2 id="第七节-标签管理"><a href="#第七节-标签管理" class="headerlink" title="第七节 标签管理"></a><strong>第七节 标签管理</strong></h2><p>&emsp;&emsp;发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以标签也是版本库的一个快照。</p><p>&emsp;&emsp;Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><strong>创建标签</strong></h3><p>&emsp;&emsp;首先切换到需要打标签的分支上。</p><blockquote><p>$ git branch</p><p>$ git checkout master</p></blockquote><p>&emsp;&emsp;然后，敲命令git tag就可以打一个新标签。</p><blockquote><p>$ git tag v1.0</p></blockquote><p>&emsp;&emsp;可以用命令git tag查看所有标签。</p><blockquote><p>$ git tag</p></blockquote><p>&emsp;&emsp;默认标签是打在最新提交的commit上的。有时候如果忘了打标签怎么办？方法是找到历史提交的commit id，然后打上就可以了。</p><blockquote><p>$ git log –pretty=oneline –abbrev-commit</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 <span class="builtin-name">add</span> merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 <span class="keyword">AND</span> simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e <span class="builtin-name">remove</span> test.txt</span><br><span class="line">b84166e <span class="builtin-name">add</span> test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc <span class="builtin-name">add</span> distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令。</p><blockquote><p>$ git tag v0.9 f52c633</p></blockquote><p>&emsp;&emsp;再用命令git tag查看标签。</p><blockquote><p>$ git tag</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">v0</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">v1</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息。</p><blockquote><p>$ git show v0.9</p></blockquote><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">commit f<span class="number">52</span><span class="keyword">c</span><span class="number">63349</span>bc<span class="number">3</span><span class="keyword">c</span><span class="number">1593499807e5</span><span class="keyword">c</span><span class="number">8e972</span>b<span class="number">82</span><span class="keyword">c</span><span class="number">8</span>f<span class="number">286</span> (tag: v<span class="number">0.9</span>)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">54</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，v0.9确实打在add merge这次提交上。</p><p>&emsp;&emsp;还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字。</p><blockquote><p>$ git tag -a v0.1 -m “version 0.1 released” 1094adb</p></blockquote><p>&emsp;&emsp;用命令git show可以看到说明文字：</p><blockquote><p>$ git show v0.1</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tag v0<span class="number">.1</span></span><br><span class="line"><span class="string">Tagger:</span> Michael Liao &lt;askxuefeng<span class="meta">@gmail</span>.com&gt;</span><br><span class="line"><span class="string">Date:</span>   Fri May <span class="number">18</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">43</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">version <span class="number">0.1</span> released</span><br><span class="line"></span><br><span class="line">commit <span class="number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (<span class="string">tag:</span> v0<span class="number">.1</span>)</span><br><span class="line"><span class="string">Author:</span> Michael Liao &lt;askxuefeng<span class="meta">@gmail</span>.com&gt;</span><br><span class="line"><span class="string">Date:</span>   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a<span class="regexp">/readme.txt b/</span>readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a><strong>操作标签</strong></h3><p>&emsp;&emsp;如果标签打错了，也可以删除。</p><blockquote><p>$ git tag -d v0.1</p></blockquote><p>&emsp;&emsp;因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>&emsp;&emsp;如果要推送某个标签到远程，使用命令git push origin。</p><blockquote><p>$ git push origin v1.0</p></blockquote><p>&emsp;&emsp;或者，一次性推送全部尚未推送到远程的本地标签。</p><blockquote><p>$ git push origin –tags</p></blockquote><p>&emsp;&emsp;如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除。</p><blockquote><p>$ git tag -d v0.9</p></blockquote><p>&emsp;&emsp;然后，从远程删除。删除命令也是push，但是格式如下。</p><blockquote><p>$ git push origin :refs/tags/v0.9</p></blockquote><p>&emsp;&emsp;要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><hr><h2 id="第八节-使用GitHub参与开源项目"><a href="#第八节-使用GitHub参与开源项目" class="headerlink" title="第八节 使用GitHub参与开源项目"></a><strong>第八节 使用GitHub参与开源项目</strong></h2><p>&emsp;&emsp;我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>&emsp;&emsp;在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><p>&emsp;&emsp;如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a></p><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/bootstrap.git</p></blockquote><p>&emsp;&emsp;一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p><p>&emsp;&emsp;Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs/<span class="keyword">bootstrap</span>  │────&gt;│  my/<span class="keyword">bootstrap</span>   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ <span class="keyword">local</span>/<span class="keyword">bootstrap</span> │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>&emsp;&emsp;如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>&emsp;&emsp;在GitHub上，可以任意Fork开源仓库；</p><p>&emsp;&emsp;自己拥有Fork后的仓库的读写权限；</p><p>&emsp;&emsp;可以推送pull request给官方仓库来贡献代码。</p><hr><h2 id="第九节-搭建Git服务器"><a href="#第九节-搭建Git服务器" class="headerlink" title="第九节 搭建Git服务器"></a><strong>第九节 搭建Git服务器</strong></h2><p>&emsp;&emsp;GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p><p>&emsp;&emsp;搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样通过几条简单的apt命令就可以完成安装。</p><p>&emsp;&emsp;假设你已经有sudo权限的用户账号，下面正式开始安装。</p><ol><li>第一步，安装git：</li></ol><blockquote><p>$ sudo apt-get install git</p></blockquote><ol start="2"><li>第二步，创建一个git用户，用来运行git服务</li></ol><blockquote><p>$ sudo adduser git</p></blockquote><ol start="3"><li>第三步，创建证书登录：</li></ol><p>&emsp;&emsp;收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p><ol start="4"><li>第四步，初始化Git仓库：</li></ol><p>&emsp;&emsp;先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：</p><blockquote><p>$ sudo git init –bare sample.git</p></blockquote><p>&emsp;&emsp;Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p><blockquote><p>$ sudo chown -R git:git sample.git</p></blockquote><ol start="5"><li>第五步，禁用shell登录：</li></ol><p>&emsp;&emsp;出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p><blockquote><p>git:x:1001:1001:,,,:/home/git:/bin/bash</p></blockquote><p>&emsp;&emsp;改为：</p><blockquote><p>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</p></blockquote><p>&emsp;&emsp;这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p><ol start="6"><li>第六步，克隆远程仓库：</li></ol><p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p><blockquote><p>$ git clone git@server:/srv/sample.git</p></blockquote><p>Cloning into ‘sample’…<br>warning: You appear to have cloned an empty repository.</p><p>&emsp;&emsp;剩下的推送就简单了。</p><h3 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a><strong>管理公钥</strong></h3><p>&emsp;&emsp;如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h3 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a><strong>管理权限</strong></h3><p>&emsp;&emsp;有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>&emsp;&emsp;搭建Git服务器非常简单，通常10分钟即可完成；</p><p>&emsp;&emsp;要方便管理公钥，用Gitosis；</p><p>&emsp;&emsp;要像SVN那样变态地控制权限，用Gitolite。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" title="Title" target="_blank" rel="noopener">廖雪峰的官方网站</a></p></blockquote><blockquote><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" title="Title" target="_blank" rel="noopener">A successful Git branching model</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理Git相关内容和操作，内容来源于：廖雪峰的官方网站
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
</feed>
