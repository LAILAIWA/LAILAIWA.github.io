<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-10-21T07:39:25.727Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>stanford公开课sql基础题</title>
    <link href="http://linyishui.top/2019090601.html"/>
    <id>http://linyishui.top/2019090601.html</id>
    <published>2019-09-06T07:28:55.000Z</published>
    <updated>2019-10-21T07:39:25.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="sql基础题"><a href="#sql基础题" class="headerlink" title="sql基础题"></a><strong>sql基础题</strong></h1><h2 id="一、课件题目"><a href="#一、课件题目" class="headerlink" title="一、课件题目"></a><strong>一、课件题目</strong></h2><p>&emsp;&emsp;Suppose you’ve started a new movie-rating website, and you’ve been collecting data on reviewers’ ratings of various movies. There’s not much data yet, but you can still try out some interesting queries. Here’s the schema:  </p><p>&emsp;&emsp;Movie (<u>mID</u>, title, year, director )  There is a movie with ID number mID, a title, a release year, and a director.  </p><p>&emsp;&emsp;Reviewer (<u>rID</u>, name )  The reviewer with ID number rID has a certain name.  </p><p>&emsp;&emsp;Rating (<u>rID</u>,<u>mID</u>, stars, ratingDate ) [rID, mID are foreign keys] The reviewer rID gave the movie mID a number of stars rating (1-5) on a certain ratingDate. </p><p>&emsp;&emsp;Write SQL statements to answer the following questions: </p><ol><li>Find the titles of all movies directed by Steven Spielberg.  </li><li>Find all years that have a movie that received a rating of 4 or 5, and sort them in increasing order of rating.  </li><li>Find the titles of all movies that have no ratings.  </li><li>Some reviewers didn’t provide a date with their rating. Find the names of all reviewers who have ratings with a NULL value for the date.  </li><li>Write a query to return the ratings data in a more readable format: reviewer name, movie title, stars, and ratingDate. </li><li>For all cases where the same reviewer rated the same movie twice and gave it a higher rating the second time, return the reviewer’s name and the title of the movie.  </li><li>For each movie that has at least one rating, find the highest number of stars that movie received. Return the movie title and number of stars. Sort by movie title. (hint: use GROUP BY)  </li><li>List movie titles and average ratings, from highest-rated to lowest-rated. If two or more movies have the same average rating, list them in alphabetical order.  </li><li>Find the names of all reviewers who have contributed three or more ratings.  </li><li>Find the names of all reviewers who rated Gone with the Wind. </li><li>For any rating where the reviewer is the same as the director of the movie, return the reviewer name, movie title, and number of stars. </li><li>Return all reviewer names and movie names together in a single column, alphabetized. (Sorting by the first name of the reviewer and first word in the title is fine; no need for special processing on last names or removing “The”.) </li><li>Find the titles of all movies not reviewed by Chris Jackson. </li><li>For all pairs of reviewers such that both reviewers gave a rating to the same movie, return the names of both reviewers. Eliminate duplicates, don’t pair reviewers with themselves, and include each pair only once. For each pair, return the names in the pair in alphabetical order. </li><li>For each rating that is the lowest (fewest stars) in the database, return the reviewer name, movie title, and number of stars of such ratings. </li><li>Find the reviewer who reviewed all movies. </li><li>Find the movies reviewed by Sarah Martinez and not reviewed by Chris Jackson. (hint: use NOT IN) </li><li>Find the movies that have been reviewed by at least two reviewers. Please write an SQL with only one SELECT and without GROUP BY. </li><li>Find the movies that have been reviewed by at least two reviewers. Please write an SQL with subquery. </li><li>Find the reviewers who do not review any movie. </li></ol><p>&emsp;&emsp;Note: When you use XAMPP+MySQL to check the correctness of your solution, please be noted that EXCEPT is not supported in MySQL.</p><h2 id="二、建表、数据"><a href="#二、建表、数据" class="headerlink" title="二、建表、数据"></a><strong>二、建表、数据</strong></h2><p>&emsp;&emsp;基于SqlServer。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> standford;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> standford;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> movie(</span><br><span class="line">    <span class="keyword">mid</span> <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="built_in">int</span>,</span><br><span class="line">    director <span class="built_in">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> reviewer(</span><br><span class="line">    rid <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> rating(</span><br><span class="line">    <span class="keyword">mid</span> <span class="built_in">int</span>,</span><br><span class="line">    rid <span class="built_in">int</span>,</span><br><span class="line">    stars <span class="built_in">int</span>,</span><br><span class="line">    ratingDate <span class="built_in">date</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> rating </span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_rating_movie_mid FOREIGN <span class="keyword">KEY</span> (<span class="keyword">mid</span>) <span class="keyword">references</span> movie(<span class="keyword">mid</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> rating </span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_rating_reviewer_rid FOREIGN <span class="keyword">KEY</span> (rid) <span class="keyword">references</span> reviewer(rid);</span><br><span class="line"></span><br><span class="line"><span class="comment">--填充数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">101</span>,<span class="string">'Gone with the Wind'</span>,<span class="number">1939</span>,<span class="string">'Victor Fleming'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">102</span>,<span class="string">'Star Wars'</span>,<span class="number">1977</span>,<span class="string">'George Lucas'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">103</span>,<span class="string">'The Sound of Music'</span>,<span class="number">1965</span>,<span class="string">'Robert Wise'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">104</span>,<span class="string">'E.T.'</span>,<span class="number">1982</span>,<span class="string">'Steven Spielberg'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">105</span>,<span class="string">'Titanic'</span>,<span class="number">1997</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">106</span>,<span class="string">'Snow White'</span>,<span class="number">1937</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">107</span>,<span class="string">'Avatar'</span>,<span class="number">2009</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">108</span>,<span class="string">'Raiders of the Lost Ark'</span>,<span class="number">1981</span>,<span class="string">'Steven Spielberg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">201</span>,<span class="string">'Sarah Martinez'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">202</span>,<span class="string">'Daniel Lewis'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">203</span>,<span class="string">'Brittany Harris'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">204</span>,<span class="string">'Mike Anderson'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">205</span>,<span class="string">'Chris Jackson'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">206</span>,<span class="string">'Elizabeth Thomas'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">207</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">208</span>,<span class="string">'Ashley White'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">201</span>,<span class="number">101</span>,<span class="number">2</span>,<span class="string">'2011-01-22'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">201</span>,<span class="number">101</span>,<span class="number">4</span>,<span class="string">'2011-01-27'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">202</span>,<span class="number">106</span>,<span class="number">4</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">103</span>,<span class="number">2</span>,<span class="string">'2011-01-20'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">108</span>,<span class="number">4</span>,<span class="string">'2011-01-12'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">108</span>,<span class="number">2</span>,<span class="string">'2011-01-30'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">204</span>,<span class="number">101</span>,<span class="number">3</span>,<span class="string">'2011-01-09'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">103</span>,<span class="number">3</span>,<span class="string">'2011-01-27'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">104</span>,<span class="number">2</span>,<span class="string">'2011-01-22'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">108</span>,<span class="number">4</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">206</span>,<span class="number">107</span>,<span class="number">3</span>,<span class="string">'2011-01-15'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">206</span>,<span class="number">106</span>,<span class="number">5</span>,<span class="string">'2011-01-19'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">207</span>,<span class="number">107</span>,<span class="number">5</span>,<span class="string">'2011-01-20'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">208</span>,<span class="number">104</span>,<span class="number">3</span>,<span class="string">'2011-01-02'</span>);</span><br></pre></td></tr></table></figure><h2 id="三、作答"><a href="#三、作答" class="headerlink" title="三、作答"></a><strong>三、作答</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1. Find the titles of all movies directed by Steven Spielberg.  </span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> director = <span class="string">'Steven Spielberg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2. Find all years that have a movie that received a rating of 4 or 5, and sort them in increasing order of rating.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span></span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> </span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> movie.mid = rating.mid</span><br><span class="line">   <span class="keyword">and</span> rating.stars <span class="keyword">in</span> (<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>),<span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--对应</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> rating</span><br><span class="line"><span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> rating.stars <span class="keyword">in</span> (<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> maxStars,<span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3. Find the titles of all movies that have no ratings.  </span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> movie.mid = rating.mid);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4. Some reviewers didn't provide a date with their rating. Find the names of all reviewers who have ratings with a NULL value for the date.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> reviewer.rid = rating.rid</span><br><span class="line">   <span class="keyword">and</span> ratingDate <span class="keyword">is</span> <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--5. Write a query to return the ratings data in a more readable format: reviewer name, movie title, stars, and ratingDate. </span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,</span><br><span class="line">   rating.stars,</span><br><span class="line">   rating.ratingDate</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid;</span><br><span class="line"></span><br><span class="line"><span class="comment">--6. For all cases where the same reviewer rated the same movie twice and gave it a higher rating the second time, return the reviewer's name and the title of the movie.  </span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,ratingDate,stars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(ratingDate) <span class="keyword">as</span> maxDate,<span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span>,rid</span><br><span class="line">           <span class="keyword">from</span> rating</span><br><span class="line">   <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>,rid) maxSelect</span><br><span class="line"><span class="keyword">on</span> rating.rid = maxSelect.rid <span class="keyword">and</span> rating.mid = maxSelect.mid</span><br><span class="line"><span class="keyword">where</span> rating.ratingDate = maxDate <span class="keyword">and</span> rating.stars = maxStars</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating r</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>,rid</span><br><span class="line">         <span class="keyword">having</span> rating.rid = r.rid</span><br><span class="line">            <span class="keyword">and</span> rating.mid = r.mid</span><br><span class="line">            <span class="keyword">and</span> <span class="keyword">count</span>(*) = <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7. For each movie that has at least one rating, find the highest number of stars that movie received. Return the movie title and number of stars. Sort by movie title. (hint: use GROUP BY)  </span></span><br><span class="line"><span class="keyword">select</span> movie.title,maxStars</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> movie.title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--8. List movie titles and average ratings, from highest-rated to lowest-rated. If two or more movies have the same average rating, list them in alphabetical order.  </span></span><br><span class="line"><span class="keyword">select</span> movie.title,<span class="keyword">AVG</span>(stars) <span class="keyword">as</span> avgStars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> movie.mid,movie.title</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">AVG</span>(stars) <span class="keyword">desc</span>,movie.title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--9. Find the names of all reviewers who have contributed three or more ratings.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> rating.rid = reviewer.rid</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> rid</span><br><span class="line"> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--10. Find the names of all reviewers who rated Gone with the Wind. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> rating.mid = movie.mid</span><br><span class="line"> <span class="keyword">where</span> rating.rid = reviewer.rid</span><br><span class="line">           <span class="keyword">and</span> title = <span class="string">'Gone with the Wind'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--11. For any rating where the reviewer is the same as the director of the movie, return the reviewer name, movie title, and number of stars. </span></span><br><span class="line"><span class="comment">--查询导演作为评论人的电影，返回评论人名和电影名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">where</span> reviewer.name = movie.director;</span><br><span class="line"></span><br><span class="line"><span class="comment">--12. Return all reviewer names and movie names together in a single column, alphabetized. (Sorting by the first name of the reviewer and first word in the title is fine; no need for special processing on last names or removing "The".) </span></span><br><span class="line"><span class="comment">--把所有评论人名和电影名放入一列返回，按评论人名和标题名首字母排序，不需要对姓氏进行特殊处理或删除“the”</span></span><br><span class="line"><span class="keyword">select</span> title <span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--13. Find the titles of all movies not reviewed by Chris Jackson. </span></span><br><span class="line"><span class="comment">--查询所有未受Chris Jackson评论的电影名</span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"> <span class="keyword">where</span> rating.mid = movie.mid</span><br><span class="line">           <span class="keyword">and</span> <span class="keyword">name</span> = <span class="string">'Chris Jackson'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">--14. For all pairs of reviewers such that both reviewers gave a rating to the same movie, return the names of both reviewers. Eliminate duplicates, don't pair reviewers with themselves, and include each pair only once. For each pair, return the names in the pair in alphabetical order. </span></span><br><span class="line"><span class="comment">--当有两个评论人给同个电影评论时返回两个评论人名，删除重复项，按姓名排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> reviewer1.name &lt;= reviewer2.name <span class="keyword">then</span> reviewer1.name <span class="keyword">else</span> reviewer2.name <span class="keyword">end</span> a, <span class="comment">--去除顺序相关</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">when</span> reviewer1.name &lt;= reviewer2.name <span class="keyword">then</span> reviewer2.name <span class="keyword">else</span> reviewer1.name <span class="keyword">end</span> b</span><br><span class="line">            <span class="keyword">from</span> rating r1</span><br><span class="line">            <span class="keyword">join</span> reviewer reviewer1 <span class="keyword">on</span> r1.rid = reviewer1.rid</span><br><span class="line"><span class="keyword">join</span> rating r2 <span class="keyword">on</span> r1.mid = r2.mid <span class="keyword">and</span> r1.rid != r2.rid <span class="comment">--配对</span></span><br><span class="line"><span class="keyword">join</span> reviewer reviewer2 <span class="keyword">on</span> r2.rid = reviewer2.rid) m</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a,b <span class="comment">--分组去重</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a,b; <span class="comment">--按姓名排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--顺序相关去重 select * from tb1 group by A, B having count(*) &gt;0;</span></span><br><span class="line"><span class="comment">--顺序不相关去重 select aa,bb from (select case when a&lt;=b then a else b end aa,case when a&lt;=b then b else a end bb from tbl) tt group by aa,bb;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--15. For each rating that is the lowest (fewest stars) in the database, return the reviewer name, movie title, and number of stars of such ratings. </span></span><br><span class="line"><span class="comment">--查询库中的最低评分，返回评论人名，电影名和评分</span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,</span><br><span class="line">   stars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">where</span> rating.stars = (<span class="keyword">select</span> <span class="keyword">min</span>(stars) <span class="keyword">from</span> rating);</span><br><span class="line"></span><br><span class="line"><span class="comment">--16. Find the reviewer who reviewed all movies. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">       <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">distinct</span> rid,<span class="keyword">mid</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line">             <span class="keyword">where</span> reviewer.rid = rating.rid ) a ) <span class="comment">--统计当前用户观看电影数</span></span><br><span class="line">      = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> movie); <span class="comment">--统计电影总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--17. Find the movies reviewed by Sarah Martinez and not reviewed by Chris Jackson. (hint: use NOT IN) </span></span><br><span class="line"><span class="comment">--查询Sarah Martinez有评论而Chris Jackson未评论的电影</span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">mid</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">mid</span> <span class="keyword">from</span> rating,reviewer <span class="keyword">where</span> rating.rid = reviewer.rid <span class="keyword">and</span> reviewer.name = <span class="string">'Sarah Martinez'</span>)</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">mid</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">mid</span> <span class="keyword">from</span> rating,reviewer <span class="keyword">where</span> rating.rid = reviewer.rid <span class="keyword">and</span> reviewer.name = <span class="string">'Chris Jackson'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--18. Find the movies that have been reviewed by at least two reviewers. Please write an SQL with only one SELECT and without GROUP BY. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.mid</span><br><span class="line"><span class="keyword">from</span> rating <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">join</span> rating <span class="keyword">as</span> b </span><br><span class="line"><span class="keyword">on</span> a.mid = b.mid </span><br><span class="line"><span class="keyword">and</span> a.rid != b.rid;</span><br><span class="line"></span><br><span class="line"><span class="comment">--19. Find the movies that have been reviewed by at least two reviewers. Please write an SQL with subquery. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">mid</span>,title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid) &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--20. Find the reviewers who do not review any movie. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> rating <span class="keyword">where</span> reviewer.rid = rating.rid) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="四、答案"><a href="#四、答案" class="headerlink" title="四、答案"></a><strong>四、答案</strong></h2><p>&emsp;&emsp;暂缺。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>stanford-sql课件第二章英文版</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      stanford公开课sql基础题
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
      <category term="database" scheme="http://linyishui.top/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://linyishui.top/2019090501.html"/>
    <id>http://linyishui.top/2019090501.html</id>
    <published>2019-09-05T09:13:47.000Z</published>
    <updated>2019-10-18T10:21:34.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h1><h2 id="第一节-什么是Git"><a href="#第一节-什么是Git" class="headerlink" title="第一节 什么是Git"></a><strong>第一节 什么是Git</strong></h2><p>&emsp;&emsp;Git是一款开源的分布式版本控制系统。分布式即多人多用户，通过拷贝镜像的方式运转，版本控制即对项目的历史版本记录。Git最早来源于Linux的作者Linus，通过C语言开发，后来的GitHub则专门为开源项目提供免费的Git存储服务。</p><p>&emsp;&emsp;CVS和SVN都是集中式的版本控制系统。</p><blockquote><p>集中式和分布式的区别：</p><p>集中式的版本库存放于中央服务器，开发者需要从服务器获取最新版本，然后将更新内容发送给服务器。所以集中式要求必须要在联网环境下才能工作。分布式系统则没有中央服务器，每台用户电脑都有完整的版本库，所以不需要联网环境，在修改时把各自修改的内容互相推送来进行协作。通常会有一台机器充当”中央服务器”，方便记录所有人的修改。</p></blockquote><h2 id="第二节-安装"><a href="#第二节-安装" class="headerlink" title="第二节 安装"></a><strong>第二节 安装</strong></h2><p>&emsp;&emsp;根据自己的操作系统(Linux，Unix，Mac，Windows等)进行安装，具体过程不贴，网上可以随处找到。</p><h2 id="第三节-版本库"><a href="#第三节-版本库" class="headerlink" title="第三节 版本库"></a><strong>第三节 版本库</strong></h2><p>&emsp;&emsp;版本库(repository)，即项目仓库。可以理解为一个盒子或者目录，里面所有文件都会被Git管理，所以每个文件的各种操作都会被记录下来，可以随时追踪其历史，并还原某个时间点所处的状态。</p><h3 id="添加、提交、查看"><a href="#添加、提交、查看" class="headerlink" title="添加、提交、查看"></a><strong>添加、提交、查看</strong></h3><blockquote><p>git init </p></blockquote><p>&emsp;&emsp;此命令可以把当前目录作为Git可以管理的仓库。执行后会多出.git目录，用来跟踪管理版本库，默认隐藏。</p><p>&emsp;&emsp;所有的版本控制系统只能跟踪文本文件的改动，如txt，html，java等，可以记录文件中所有文本的变动。但对于图片和视频这些二进制文件，系统无法记录具体的变化(Word文件是二进制格式，所以无法跟踪其文本变更)。</p><blockquote><p>git add readme.txt</p></blockquote><p>&emsp;&emsp;在目录下创建readme文件，然后执行上述命令，告诉Git将文件添加到仓库。</p><blockquote><p>git commit -m “add a new txt”</p></blockquote><p>&emsp;&emsp;通过git commit指令告诉Git，把文件提交给仓库。-m后跟提交说明，可多次add添加，一次统一提交commit。</p><blockquote><p>git status</p></blockquote><p>&emsp;&emsp;修改readme文件内容，再执行上述指令，返回信息表示文件已修改但未提交</p><p>&emsp;&emsp;再一次执行git add，然后git status，发现返回信息更新，表示文件准备提交，最后git commit。然后git status，发现目录没有需要提交的文件。</p><blockquote><p>git diff</p></blockquote><p>&emsp;&emsp;如果文件修改，可以通过上述指令查看修改内容。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a><strong>版本回退</strong></h3><blockquote><p>git log</p></blockquote><p>&emsp;&emsp;通过上述指令，可以查看操作日志，</p><blockquote><p>git reset –hard HEAD^</p></blockquote><blockquote><p>git reset –hard 1094a</p></blockquote><p>&emsp;&emsp;git reset指令回退目录到指定版本，版本号不需要输入完整，Git会自动查询匹配</p><blockquote><p>git reflog</p></blockquote><p>&emsp;&emsp;可以通过git reflog指令查看每次操作，而回退版本只是修改当前版本为旧版本，并更新文件，但不会影响被覆盖的版本，仍可以随时切换回。</p><h2 id="第四节-工作区和暂存区"><a href="#第四节-工作区和暂存区" class="headerlink" title="第四节 工作区和暂存区"></a><strong>第四节 工作区和暂存区</strong></h2><p>&emsp;&emsp;工作区就是开发人员PC中可以看到的文件目录，工作区有一个隐藏目录.git，是Git的<strong>版本库</strong>。</p><p>&emsp;&emsp;版本库内有一块<strong>暂存区</strong>state，git add指令就是将文件修改添加到暂存区。而git commit则是将暂存区内容提交到当前分支。Git会默认自动创建一个master分支，所以此时会将修改内容提交到master分支。</p><h3 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a><strong>文件修改</strong></h3><p>&emsp;&emsp;Git专注于修改而不是文件，可以通过以下案例来了解相关内容。</p><p>&emsp;&emsp;尝试执行以下指令顺序。</p><blockquote><ol><li>修改文件</li><li>git add xx</li><li>git status</li><li>再修改文件</li><li>git commit -m “git tracks changes”</li><li>git status</li></ol></blockquote><p>&emsp;&emsp;会发现后一次修改并未提交，信息如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        modified:   t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原因是在第一次修改后，执行了git add到暂存区，然后再进行二次修改，再提交时把暂存区内容提交，但二次修改还未加入暂存区。所以修改后必须要先add再提交才会有效果。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a><strong>撤销修改</strong></h3><blockquote><ol><li>修改文件，添加一行文字</li><li>add，commit</li><li>删除此行</li><li>git status</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        modified:   t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>git checkout – <file></file></p></blockquote><p>&emsp;&emsp;git checkout指令表示可以撤销修改，分为两种情况：1.文件修改后还未add到暂存区，撤销后就和版本库一致。2.文件已添加到暂存区，又做了修改，撤销修改就回到add后的状态。总之就是让此文件回到最近一次commit或add的状态。</p><blockquote><p>git reset HEAD <file></file></p></blockquote><p>&emsp;&emsp;通过此指令可以把暂存区的修改撤销，重新放回工作区。</p><p>&emsp;&emsp;如果想回退已经commit的修改，则需要通过前文的版本回退。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h3><p>&emsp;&emsp;先删除文件，再git status。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        deleted:    t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Git发现文件被删除，所以我们通过rm删除，并commit，使文件从版本库也删除。</p><blockquote><p>git rm <file></file></p></blockquote><p>&emsp;&emsp;还有可能删除了，可以通过checkout恢复。</p><h2 id="第五节-远程仓库"><a href="#第五节-远程仓库" class="headerlink" title="第五节 远程仓库"></a><strong>第五节 远程仓库</strong></h2><p>&emsp;&emsp;实际开发中，我们需要一台服务器作为远程仓库来备份版本库以及作为用户的协调中枢。而GitHub就是提供Git仓库托管服务的网站。</p><p>&emsp;&emsp;注册账号过程跳过。本地Git仓库和GitHub远程仓库是通过SSH加密传输的，所以需要配置密钥。</p><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“</p></blockquote><p>&emsp;&emsp;可以通过上述命令创建SSH Key，然后在用户文档，找到.ssh目录，会有id_rsa和id_rsa.pub两个文件，即SSH Key的密钥对，pub表示公钥。然后在github网站配置SSH Keys。</p><p>&emsp;&emsp;然后可以在GitHub上创建一个远程仓库。然后复制SSH地址：Clone with SSH</p><blockquote><p>$ git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xx1/xx2</p></blockquote><p>&emsp;&emsp;通过此命令可以关联本地仓库和远程仓库，xx1是用户名，xx2为项目名。Git默认会给远程库起名origin。</p><blockquote><p>$ git push -u origin master</p></blockquote><blockquote><p>$ git push origin master</p></blockquote><p>&emsp;&emsp;通过此命令把本地库所有内容推送到远程库。由于远程库是空的，所以首次推送添加了-u参数，Git不但会把本地master分支内容推送到远程新的master分支，还会将他们关联，以后的推送或拉取就可以简化命令。</p><blockquote><p>$ git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xx1/xx2</p></blockquote><p>&emsp;&emsp;上面是先有本地库再开启远程库，此命令则是先有远程库时克隆其内容到本地。</p><h2 id="第五节-分支管理"><a href="#第五节-分支管理" class="headerlink" title="第五节 分支管理"></a><strong>第五节 分支管理</strong></h2><p>&emsp;&emsp;Git的分支管理要远远优秀于SVN。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010103.png" alt="Git分支图"></p><p>&emsp;&emsp;master分支即主分支，可以把Head看作指针，HEAD指向当前分支，而分支则指向提交。每个点就是一次提交，所以每次commit就会推动分支前进一步。新的分支则处在一条新的时间线，在平时各个分支间没有任何关系。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a><strong>创建与合并分支</strong></h3><p>&emsp;&emsp;Git创建分支效率很高，创建新的分支指针，再更新HEAD的指向即可。当一个分支上任务结束，则需要合并到主分支上，合并就是matser直接指向当前提交，就完成了合并工作。合并之后可以删除没用的分支。</p><blockquote><p>$ git checkout -b dev</p></blockquote><blockquote><p>$ git branch dev</p><p>$ git checkout dev</p></blockquote><p>&emsp;&emsp;创建并切换到dev分支，-b参数表示创建并切换，等价于后两条指令。</p><blockquote><p>$ git branch</p></blockquote><p>&emsp;&emsp;查看当前分支。</p><blockquote><p>$ git checkout master</p></blockquote><p>&emsp;&emsp;切换回master分支。</p><blockquote><p>$ git merge dev</p></blockquote><p>&emsp;&emsp;合并指定分支到当前分支。</p><blockquote><p>$ git branch -d dev</p></blockquote><p>&emsp;&emsp;合并后删除分支。</p><blockquote><p>$ git switch -c dev</p><p>$ git switch matser</p></blockquote><p>&emsp;&emsp;新版本推荐用switch指令代替checkout来进行切换，后者容易和撤销修改搞混。-c参数表示创建。</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h3><blockquote><ol><li>创建新分支：$ git switch -c feature1</li><li>修改文件内容。</li><li>提交修改到分支：$ git add x.txt  $ git commit -m “feature1 submit”</li><li>切换到master分支(Git提醒当前master分支比origin/master分支超前)：$ git switch master</li><li>在修改文件上新增内容。</li><li>提交：$ git add x.txt $ git commit -m “master submit”</li><li>执行合并分支请求：$ git merge feature1</li></ol></blockquote><p>&emsp;&emsp;结果Git提示发生冲突，可以通过git status查看冲突文件，也可以直接查看冲突文件。修改文件内容，再提交解决冲突部分。可以删除分支feature1了。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a><strong>分支管理策略</strong></h3><p>&emsp;&emsp;</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a><strong>Bug分支</strong></h3><p>&emsp;&emsp;</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a><strong>Feature分支</strong></h3><p>&emsp;&emsp;</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a><strong>多人协作</strong></h3><p>&emsp;&emsp;</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a><strong>Rebase</strong></h3><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" title="Title" target="_blank" rel="noopener">廖雪峰的官方网站</a></p></blockquote><blockquote><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" title="Title" target="_blank" rel="noopener">A successful Git branching model</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍了原子操作的实现原理，atomic包中的原子更新基本类型类，原子更新数组，原子更新引用类型，原子更新字段类，CPU实现和Java实现，缓存一致性机制等内容
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>《设计模式：可复用面向对象软件的基础》读书笔记</title>
    <link href="http://linyishui.top/2019090401.html"/>
    <id>http://linyishui.top/2019090401.html</id>
    <published>2019-09-04T07:26:13.000Z</published>
    <updated>2019-10-17T07:25:39.866Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><h2 id="一、前言、引言"><a href="#一、前言、引言" class="headerlink" title="一、前言、引言"></a><strong>一、前言、引言</strong></h2><p>&emsp;&emsp;<strong>本书主要描述</strong>在面向对象软件设计过程中针对特定问题简洁而优雅的解决方案。根据模式的性质进行<strong>分类</strong>：创建型、结构型和行为型。</p><p>&emsp;&emsp;<strong>粒度</strong>：指的是系统内存扩展增量的最小值，指数据仓库中数据单位保存数据的细化程度。对于程序设计来说，粒度就是程序中的一个最小单元划分，比如面向过程语言中的单元是过程和函数，是程序中的最小组件，而这些组件就可以实现最基本的代码重用。但当程序变大变复杂就会显得粒度太低，过多的函数非常难以管理。</p><p>&emsp;&emsp;<strong>粗/细粒度</strong>：指相对规模的划分，可以理解为抽象程度。</p><p>&emsp;&emsp;很难一次就得到兼具复用性和灵活性的设计，<strong>重复设计</strong>是不可避免的，但有经验的面向对象设计者能做出良好的设计。</p><p>&emsp;&emsp;其中<strong>内行的一点</strong>是，不是解决任何问题都要从头做起，复用以前用过的解决方案，待有好的解决方案时，再一次次的使用新的方案。</p><p>&emsp;&emsp;<strong>本书的目的</strong>就是将面向对象软件的设计经验作为<strong>设计模式</strong>记录下来</p><p>&emsp;&emsp;<strong>本书的设计模式</strong>是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。</p><hr><h2 id="二、模式的四要素"><a href="#二、模式的四要素" class="headerlink" title="二、模式的四要素"></a><strong>二、模式的四要素</strong></h2><p>&emsp;&emsp;模式由四个基本要素组成：</p><ol><li>名称：方便记忆和使用，加强思考。</li><li>问题：描述模式的使用场景，也可以包括使用模式必须包括的一系列先决条件。</li><li>解决方案：模式设计的组成成分，之间的相互关系及各自的职责和协作方式。</li><li>效果：模式应用的效果以及使用模式应权衡的问题。</li></ol><hr><h2 id="三、MVC的设计模式"><a href="#三、MVC的设计模式" class="headerlink" title="三、MVC的设计模式"></a><strong>三、MVC的设计模式</strong></h2><p>&emsp;&emsp;MVC包括三类对象，模型Model是应用对象，视图View是在屏幕上的表示，控制器Controller定义用户界面对用户输入的响应方式。</p><p>&emsp;&emsp;MVC分离了用户界面设计的这些对象，来提高灵活性和复用性。</p><p>&emsp;&emsp;MVC通过创建一个”订购/通知”的协议来<strong>分离</strong>V和M。视图需要保证其显示正确的反映了模型的状态。一旦模型数据发生变化，需要通知相关视图，视图则进行刷新，这样一个模型可以提供不同的多个视图表现，也可以只更新视图而无需重写模型。</p><p>&emsp;&emsp;MVC的这种分离设计也用于进行对象分离，进行解耦，即<strong>观察者模式</strong>(Observer)。</p><p>&emsp;&emsp;MVC另一个特征是视图可以进行嵌套，也就是将对象划分为一组，并将这组对象看作一个对象。即<strong>组合模式</strong>(Composite)。此模式通过创建一个类的层次结构，用一些子类来定义原子对象，其他类来定义组合对象，组合对象即原子对象组合而成的对象。</p><p>&emsp;&emsp;MVC也可以在不改变视图的情况下改变对用户输入的响应方式。这些都是解耦之后带来的灵活性提升。</p><p>&emsp;&emsp;View-Controller关系是策略模式(Strategy)的一个例子。</p><p>&emsp;&emsp;MVC还涉及到的设计模式：用来指定视图缺省控制器的工厂方法模式(Factory method)，用来增加视图滚动的装饰器模式(Decorator)，不过这些都是次要的应用了。</p><hr><h2 id="四、介绍设计模式的统一结构"><a href="#四、介绍设计模式的统一结构" class="headerlink" title="四、介绍设计模式的统一结构"></a><strong>四、介绍设计模式的统一结构</strong></h2><p>&emsp;&emsp;本书通过以下抽象结构来统一介绍设计模式。</p><ol><li>模式名和分类</li><li>意图：回答这些问题(此模式是做什么的？其基本原理和意图是什么？它解决的是什么样的特定设计问题？)</li><li>别名</li><li>动机：用来说明一个设计问题以及如何使用模式中的类和对象来解决此问题的特定情境。</li><li>适用性：什么情况下适用？此模式又改进了哪些不良设计？我们又该如何识别这些情况？</li><li>结构：通过基于对象建模技术(OMT)的表示法对模式中的类进行图形描述。</li><li>参与者：模式中的类和对象以及它们的职责。</li><li>协作：参与者如何协作实现职责。</li><li>效果：模式怎样支持其目标？使用此模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？</li><li>实现：实现此模式时需要知道的提示、技术要点以及应该避免的缺陷，还有是否存在某些特定于实现语言的问题。</li><li>代码示例</li><li>已知应用：实际系统中模式案例。</li><li>相关模式：和此模式紧密相关的模式有哪些？不同之处是什么？此模式应该和哪些模式一起使用？</li></ol><hr><h2 id="五、所有设计模式"><a href="#五、所有设计模式" class="headerlink" title="五、所有设计模式"></a><strong>五、所有设计模式</strong></h2><p>&emsp;&emsp;本书包含的模式：</p><table><thead><tr><th style="text-align:center">参与</th><th style="text-align:center">创建型</th><th style="text-align:center">结构型</th><th style="text-align:center">行为型</th></tr></thead><tbody><tr><td style="text-align:center">类</td><td style="text-align:center">Factory Method <br> 工厂方法</td><td style="text-align:center">Adapter(类) <br> 适配器-类</td><td style="text-align:center">Interpreter <br> 解释器 <br> Template Method <br> 模板方法</td></tr><tr><td style="text-align:center">对象</td><td style="text-align:center">Abstract Factory <br> 抽象工厂 <br> Builder <br> 生成器 <br> Prototype <br> 原型 <br> Singleton <br> 单例</td><td style="text-align:center">Adapter(对象) <br> 适配器-对象 <br> Bridge <br> 桥接 <br> Composite <br> 组合 <br> Decorator <br> 装饰 <br> Facade <br> 外观 <br> Flyweight <br> 享元 <br> Proxy <br> 代理</td><td style="text-align:center">Chain of Responsibility <br> 职责链 <br> Command <br> 命令 <br> Iterator <br> 迭代器 <br> Mediator <br> 中介者 <br> Memento <br> 备忘录 <br> Observer <br> 观察者 <br> State <br> 状态 <br> Strategy <br> 策略 <br> Visitor <br> 访问者</td></tr></tbody></table><p>&emsp;&emsp;根据目的准则划分：创建型、结构型和行为型。其中创建型模式与对象的创建有关；结构型模式处理类和对象的组合；行为型模式对类或对象怎样交互和怎样分配进行描述。</p><p>&emsp;&emsp;根据范围准则划分：类和对象。类模式处理类和子类的关系，关系通过继承建立，是静态的，编译时便确定。对象模式则处理对象间的关系，这些关系在运行时刻可以变换。</p><ol><li>创建型类模式，将对象的部分创建工作延迟到子类。</li><li>创建型对象模式，将对象的部分创建工作延迟到另一个对象。</li><li>结构型类模式，使用继承机制来组合类。</li><li>结构型对象模式，描述了对象的组装方式。</li><li>行为型类模式，使用继承描述算法和控制流。</li><li>行为型对象模式，描述一组对象怎样协作完成单个对象无法完成的任务。</li></ol><p>&emsp;&emsp;组合模式(Composite)常和迭代器模式(Iterator)或访问者模式(Visitor)一起使用。原型模式(Prototype)常用量替代抽象工厂模式(Abstract Factory)。组合模式(Composite)和装饰模式(Decorator)结构类似。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010101.png" alt="设计模式之间的关系"></p><hr><h2 id="六、设计模式怎样解决设计问题"><a href="#六、设计模式怎样解决设计问题" class="headerlink" title="六、设计模式怎样解决设计问题"></a><strong>六、设计模式怎样解决设计问题</strong></h2><h3 id="1-寻找合适的对象"><a href="#1-寻找合适的对象" class="headerlink" title="1 寻找合适的对象"></a><strong>1 寻找合适的对象</strong></h3><p>&emsp;&emsp;客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。因为这些限制，对象的内部状态是被封装的。面向对象设计最困难的部分是将系统分解为对象集合。</p><p>&emsp;&emsp;面向对象设计支持众多的设计方法。可以写出一个问题描述，挑出名词和动词，进而创建相应的类和操作；也可以关注于系统的协作和职责关系；也可以对现实世界建模，再将分析时发现的对象转化至设计中。</p><p>&emsp;&emsp;设计中往往需要抽象出现实世界并不存在的对象的抽象方法，这对设计的灵活性是很重要的。</p><h3 id="2-决定对象的粒度"><a href="#2-决定对象的粒度" class="headerlink" title="2 决定对象的粒度"></a><strong>2 决定对象的粒度</strong></h3><p>&emsp;&emsp;对象可以表示下自硬件上到整个应用的任何事物。</p><p>&emsp;&emsp;外观模式(Facade)描述了怎样用对象表示完整的子系统；享元模式(Flyweight)描述了如何支持大量的最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。抽象工厂模式(Abstract Factory)和生成器模式(Builder)产生那些专门负责生成其他对象的对象。访问者模式(Visitor)和命令模式(Command)生成的对象专门负责实现对其他对象或对象组的请求。</p><h3 id="3-指定对象接口"><a href="#3-指定对象接口" class="headerlink" title="3 指定对象接口"></a><strong>3 指定对象接口</strong></h3><p>&emsp;&emsp;对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构(signature)。对象操作所定义的所有操作型构的集合被称为该对象的接口(interface)。</p><p>&emsp;&emsp;类型(type)是用来标识特定接口的一个名字，当一个类型的接口包含另一个类型的接口时，可以说它是另一个类型的子类型(subtype)，另一个类型则是它的超类型(supertype)</p><p>&emsp;&emsp;当给对象发送请求时，所引起的具体操作既与请求本身有关又与接受对象有关，支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接称之为<strong>动态绑定</strong>。动态绑定就是指发送的请求直到运行时刻才受具体的实现的约束，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称作<strong>多态</strong>。</p><h3 id="4-描述对象的实现"><a href="#4-描述对象的实现" class="headerlink" title="4 描述对象的实现"></a><strong>4 描述对象的实现</strong></h3><p>&emsp;&emsp;<strong>针对接口编程，而不是针对实现编程。</strong></p><p>&emsp;&emsp;理解对象实例化，类继承，抽象类和具体类，混入类。</p><p>&emsp;&emsp;<strong>类继承</strong>和<strong>接口继承</strong>的比较，类继承根据一个对象的实现定义了另一个对象的实现，即代码和表示的共享机制。接口继承则描述了一个对象什么时候能被用来替代另一个对象。</p><p>&emsp;&emsp;类继承实现了可复用，而继承拥有定义具有相同接口的对象族的能力，而多态则依赖于这种能力。只根据抽象类中定义的接口来操纵对象的好处：1.客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口。2.客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。</p><h3 id="5-运用复用机制"><a href="#5-运用复用机制" class="headerlink" title="5 运用复用机制"></a><strong>5 运用复用机制</strong></h3><h4 id="继承和组合的比较"><a href="#继承和组合的比较" class="headerlink" title="继承和组合的比较"></a><strong>继承和组合的比较</strong></h4><p>&emsp;&emsp;<strong>优先使用对象组合，而不是类继承</strong></p><p>&emsp;&emsp;功能复用最常用的技术是<strong>类继承</strong>和<strong>对象组合</strong>。</p><p>&emsp;&emsp;类继承这种通过生成子类的复用通常被称为<strong>白箱复用</strong>，白箱指可视性，即父类内部细节对子类可见。</p><p>&emsp;&emsp;对象组合是类继承之外的另一种复用选择，新的复杂的功能可以通过组装或组合对象来获取。要求被组合的对象具有良好定义的接口，所以被称为<strong>黑箱复用</strong>，因为对象的内部细节是不可见的。</p><p>&emsp;&emsp;继承和组合各有优缺点。</p><blockquote><p>继承优点：</p><ol><li>类继承在编译时静态定义，可以直接应用。</li><li>类继承比较方便的改变被复用的实现。</li></ol></blockquote><blockquote><p>继承缺点：</p><ol><li>类继承在编译时便确定，无法在运行时再改变继承自父类的实现。</li><li>“继承破坏了封装性”，继承对子类揭露父类的内部细节。</li><li>父类任何变化必然导致子类发生变化。这种依赖关系限制了灵活性并最终会限制复用性。一个解决方案是只继承抽象类，因为抽象类提供较少的实现。</li></ol></blockquote><blockquote><p>组合优点：</p><ol><li>对象组合通过获得对其他对象的引用而在运行阶段动态定义。</li><li>组合要求对象遵守彼此的接口约定，进而促进接口制定的规范性。</li><li>这些接口并不会妨碍你将一个对象和其他对象一起使用。而且因为对象只能通过接口访问，所以并没有破坏封装性；</li><li>只要类型一致，运行阶段可以用一个对象替代另一个对象。</li></ol></blockquote><p>&emsp;&emsp;继承实现复用往往比组合要容易许多，所以通常会结合起来使用。</p><h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a><strong>委托</strong></h4><p>&emsp;&emsp;委托是一种组合方法，使组合具有和继承一样的复用能力，是对象组合的一个特例，可以替代继承。</p><p>&emsp;&emsp;在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给他的<strong>代理者</strong>，类似于子类委托给父类。</p><p>&emsp;&emsp;比如我们实现了一个矩形类来处理所有矩形操作，窗口类可以复用矩形类的操作，而不必成为矩形类的子类。</p><blockquote><p>委托优点：便于在运行阶段组合对象操作，以及改变这些操作的组合方式。</p><p>委托缺点：</p><ol><li>动态的、高度参数化的软件比静态软件更难于理解。</li><li>运行时效率相比会降低。</li></ol></blockquote><p>&emsp;&emsp;所以委托适合于其使设计更加简单的情况，委托可以得到的效率与上下文有关，最适合符合特定程式的情景，即标准模式的情景。</p><p>&emsp;&emsp;状态模式(State)、策略模式(Strategy)和访问者模式(Visitor)中都使用了委托。</p><p>&emsp;&emsp;状态模式中，一个对象将请求委托给一个描述当前状态的State对象来处理。策略模式中，一个对象将一个特定的请求委托给一个描述请求执行策略的对象，一个对象只会有一个状态，但对于不同的请求可以有多个策略。而访问者模式中，对象结构的每个元素上的操作总是被委托到Visitor对象。</p><h4 id="继承和参数化类型的比较"><a href="#继承和参数化类型的比较" class="headerlink" title="继承和参数化类型的比较"></a><strong>继承和参数化类型的比较</strong></h4><p>&emsp;&emsp;<strong>参数化类型</strong>是另一种功能复用技术，是类属(generic)或模板(templates)。定义一个类型时并不去指定该类型所用到的其他所有类型，未经指定的类型在使用时通过参数的形式提供。</p><p>&emsp;&emsp;参数化类型和继承都无法在运行阶段改变，但参数化类型允许改变类所用到的类型。</p><h3 id="6-关联运行阶段和编译阶段的结构"><a href="#6-关联运行阶段和编译阶段的结构" class="headerlink" title="6 关联运行阶段和编译阶段的结构"></a><strong>6 关联运行阶段和编译阶段的结构</strong></h3><p>&emsp;&emsp;编译阶段的代码结构由继承关系固定的类组成。而运行阶段的结构则由快速变化的通信对象网络组成。</p><p>&emsp;&emsp;对象间有<strong>聚合</strong>和<strong>相识</strong>的关系。聚合表示一个对象拥有/包含另一个对象或其一部分。相识则表示一个对象仅知道另一个对象，可以说是关联或引用的关系，可以彼此请求但无需负责。聚合意味着对象有相同的生命周期，而相识则是比聚合耦合度更低的关系。</p><h3 id="7-设计应支持变化"><a href="#7-设计应支持变化" class="headerlink" title="7 设计应支持变化"></a><strong>7 设计应支持变化</strong></h3><ol><li><strong>通过显式的指定一个类来创建对象。</strong>这样会使程序受特定实现的约束，而不是特定接口的约束，为了避免这种情况，应该间接的创建对象。(相关模式：Abstract Factory,Factory Method，Prototype)</li><li><strong>对特殊操作的依赖。</strong>当为请求指定一个特殊化的操作时，就固定了请求的方式。为了避免写死代码，应该可以在编译或运行阶段可以方便的改变响应请求的方法。(相关模式：Chain of Responsibility,Command)</li><li><strong>对硬件和软件平台的依赖。</strong>依赖于特定平台，很难进行移植。<br>(相关模式：Abstract Factory,Bridge)</li><li><strong>对对象表示或实现的依赖。</strong>知道对象将怎样表示、保存、定位或实现的客户在对象进行变化时也需要进行变化，最好隐藏这些信息以防连锁变化。<br>(相关模式：Abstract Factory,Bridge,Memento,Proxy)</li><li><strong>算法依赖。</strong>算法在开发和复用时常常被扩展、优化和替代，尽量避免依赖于某个特定算法。<br>(相关模式：Builder,Iterator,Strategy,Template Method,Visitor)</li><li><strong>紧耦合。</strong>紧耦合的类很难独立的被复用，因为他们之间相互依赖。松散耦合可以提高一个类本身被复用的可能性，使系统更易于学习、移植、修改和扩展。设计模式通过抽象耦合和分层技术来提高松散耦合。<br>(相关模式：Abstract Factory,Command,Facade,Mediator,Observer,Chain of Responsibility)</li><li><strong>通过生成子类来扩充功能。</strong>通常很难通过定义子类来定制对象，新类会有固定的实现开销，还需要对父类的深入了解。可以通过对象组合和委托技术，以新的方式来组合已有对象，而不是通过定义已存在类的子类的方式加入程序。<br>(相关模式：Bridge,Chain of Responsibility,Composite,Decorator,Observer,Strategy)</li><li><strong>不能方便的对类进行修改。</strong>有时不得不修改一个难以修改的类，如引用他人代码，但没有源码，或是修改一个类要同时修改关联的众多子类。<br>(相关模式：Adapter,Decorator,Visitor)</li></ol><hr><h2 id="七、怎样选择设计模式"><a href="#七、怎样选择设计模式" class="headerlink" title="七、怎样选择设计模式"></a><strong>七、怎样选择设计模式</strong></h2><ol><li>思考设计模式是怎样解决设计问题</li><li>浏览模式的意图部分</li><li>研究模式怎样互相关联</li><li>研究目的相似的模式</li><li>检查重新设计的原因</li><li>考虑你的设计中哪些是可变的</li></ol><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010102.png" alt="设计模式所支持的设计的可变方面"></p><hr><h2 id="八、怎样使用设计模式"><a href="#八、怎样使用设计模式" class="headerlink" title="八、怎样使用设计模式"></a><strong>八、怎样使用设计模式</strong></h2><ol><li>大致浏览一遍模式</li><li>回头研究结构部分、参与者部分和协作部分</li><li>看代码示例部分，看看这个模式代码形式的具体例子</li><li>选择模式参与者的名字，使他们在应用上下文中有意义</li><li>定义类</li><li>定义模式中专用于应用的操作名称</li><li>实现执行模式中责任和协作的操作</li></ol><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《设计模式：可复用面向对象软件的基础》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《设计模式：可复用面向对象软件的基础》读书笔记，涉及前言，引言和第一章内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="mvc" scheme="http://linyishui.top/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="http://linyishui.top/2019090201.html"/>
    <id>http://linyishui.top/2019090201.html</id>
    <published>2019-09-02T08:42:14.000Z</published>
    <updated>2019-10-14T08:54:14.469Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（未完待续…）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://blog.csdn.net/u014203449/article/details/80888637" title="Title" target="_blank" rel="noopener">六。shiro集群，将session保存到数据库和redis，使用户保持登录状态</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/quanaianzj/article/details/83858575" title="Title" target="_blank" rel="noopener">shiro 登陆成功后subject依然为空</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/swl1993831/article/details/90905040" title="Title" target="_blank" rel="noopener">Shiro+JWT实现用户登陆认证，权限控制</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/u010475041/article/details/78140643" title="Title" target="_blank" rel="noopener">CAS单点登录-客户端集成(shiro、springboot、jwt、pac4j)（十）</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/qq_14952889/article/details/69554670" title="Title" target="_blank" rel="noopener">实现shiro多方式登录系统</a></p></blockquote><blockquote><p><a href="http://www.mamicode.com/info-detail-2337846.html" title="Title" target="_blank" rel="noopener">shiro实战系列(十)之Subject</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_42873937/article/details/82460997" title="Title" target="_blank" rel="noopener">使用JWT实现单点登录（完全跨域方案）</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Shiro。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
      <category term="shiro" scheme="http://linyishui.top/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>Pac4j</title>
    <link href="http://linyishui.top/2019090101.html"/>
    <id>http://linyishui.top/2019090101.html</id>
    <published>2019-09-01T07:54:56.000Z</published>
    <updated>2019-10-14T08:40:59.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Pac4j简介"><a href="#Pac4j简介" class="headerlink" title="Pac4j简介"></a><strong>Pac4j简介</strong></h1><p>&emsp;&emsp;pac4j是一个简单而强大的安全引擎，用于Java对用户进行身份验证、获取其配置文件和管理授权，以确保web应用程序安全。它提供了一套完整的概念和组件。它基于Java 8，并在Apache 2许可下使用。它可用于大多数框架/工具和支持大多数认证/授权机制。</p><hr><h2 id="第一节-主要概念和组件介绍"><a href="#第一节-主要概念和组件介绍" class="headerlink" title="第一节 主要概念和组件介绍"></a><strong>第一节 主要概念和组件介绍</strong></h2><blockquote><ol><li><strong>client</strong>(客户端): 客户端表示身份验证机制（流程），它执行登录过程并返回一个用户概要文件。间接客户端(IndirectClient)用于UI身份验证，而直接客户端(DirectClient)则用于web服务身份验证。</li><li><strong>authenticator</strong>(认证器)：HTTP客户端验证凭证需要一个认证器。它是ProfileService的一个子组件，该组件验证凭证，同时也处理用户的创建、更新和移除操作。</li><li><strong>authorizer</strong>(授权器)：授权器用于检查已认证用户的授权或当前web上下文中的授权。</li><li><strong>matcher</strong>(匹配器)：一个匹配器定义了security是否必须应用到安全过滤器。</li><li><strong>config</strong>(配置)：配置通过客户端、授权器和匹配器定义安全配置。</li><li><strong>user profile</strong>(用户概要文件)：用户概要是已认证用户的概要。它有一个标识符、属性、角色、权限、一个“记住-我”属性和一个链接标识符。</li><li><strong>web context</strong>(web上下文)：web上下文是对pac4j实现特有的HTTP请求和响应的抽象，而关联的SessionStore表示会话的实现。</li><li><strong>security filter</strong>(安全过滤器)：(或者不论使用什么原理去拦截的HTTP请求)根据客户端和授权配置，通过检查用户已认证和已授权来保护一个URL。如果用户没有被认证，它对直接客户端展示认证，对间接客户端启动登录进程。</li><li><strong>callback controller</strong>(回调控制器)：对间接客户端结束登录进程后的回调。</li><li><strong>logout controller</strong>(退出登录控制器)：处理应用程序和/或身份服务器注销。</li></ol></blockquote><hr><h2 id="第二节-认证机制"><a href="#第二节-认证机制" class="headerlink" title="第二节 认证机制"></a><strong>第二节 认证机制</strong></h2><p>&emsp;&emsp;client支持多种认证机制：OAuth - SAML - CAS - OpenID Connect - HTTP - OpenID - Google App Engine - Kerberos (SPNEGO)</p><p>&emsp;&emsp;Authenticators认证器：LDAP - SQL - JWT - MongoDB - CouchDB - IP address - REST API</p><h3 id="1-Clients"><a href="#1-Clients" class="headerlink" title="1 Clients"></a><strong>1 Clients</strong></h3><p>（未完待续…）</p><h3 id="2-Authenticators"><a href="#2-Authenticators" class="headerlink" title="2 Authenticators"></a><strong>2 Authenticators</strong></h3><p>（未完待续…）</p><hr><h2 id="第三节-认证机制-授权器"><a href="#第三节-认证机制-授权器" class="headerlink" title="第三节 认证机制-授权器"></a><strong>第三节 认证机制-授权器</strong></h2><p>▸ Roles/permissions - Anonymous/remember-me/(fully) authenticated - Profile type, attribute<br>▸ CORS - CSRF - Security headers - IP address, HTTP method</p><p>&emsp;&emsp;大多数pac4j组件实现DefaultAuthorizationChecker组件来使用pac4j的逻辑和授权。因此，下列授权器可以通过短名称自动找到：</p><blockquote><ol><li>hsts：StrictTransportSecurityHeader 认证器</li><li>nosniff： XContentTypeOptionsHeader 认证器</li><li>noframe： XFrameOptionsHeader 认证器</li><li>xssprotection： XSSProtectionHeader 认证器</li><li>nocache： CacheControlHeader 认证器</li><li>securityheaders： as a shortcut for hsts,nosniff,noframe,xssprotection,nocache</li><li>csrfToken： CsrfTokenGeneratorAuthorizer 认证器</li><li>csrfCheck： CsrfAuthorizer 认证器</li><li>csrf as a shortcut for csrfToken,csrfCheck</li><li>isAnonymous：IsAnonymousAuthorizer 认证器</li><li>isAuthenticated：IsAuthenticatedAuthorizer 认证器</li><li>isFullyAuthenticated：IsFullyAuthenticatedAuthorizer 认证器</li><li>isRemembered： IsRememberedAuthorizer 认证器</li><li>allowAjaxRequests for a default configuration of the CorsAuthorizer authorizer with the Access-Control-Allow-Origin header set to *.</li></ol></blockquote><p>&emsp;&emsp;这些短名称都作为常量定义在DefaultAuthorizers类中。</p><p>（未完待续…）</p><hr><h2 id="第四节-适配器"><a href="#第四节-适配器" class="headerlink" title="第四节 适配器"></a><strong>第四节 适配器</strong></h2><p>（未完待续…）</p><hr><h2 id="第五节-安全配置"><a href="#第五节-安全配置" class="headerlink" title="第五节 安全配置"></a><strong>第五节 安全配置</strong></h2><p>（未完待续…）</p><hr><h2 id="第六节-用户配置文件"><a href="#第六节-用户配置文件" class="headerlink" title="第六节 用户配置文件"></a><strong>第六节 用户配置文件</strong></h2><p>（未完待续…）</p><hr><h2 id="第七节-会话存储和存储"><a href="#第七节-会话存储和存储" class="headerlink" title="第七节 会话存储和存储"></a><strong>第七节 会话存储和存储</strong></h2><p>（未完待续…）</p><hr><h2 id="第八节-发布说明-向后兼容性"><a href="#第八节-发布说明-向后兼容性" class="headerlink" title="第八节 发布说明 - 向后兼容性"></a><strong>第八节 发布说明 - 向后兼容性</strong></h2><p>（未完待续…）</p><hr><h2 id="第九节-认证流程-大图"><a href="#第九节-认证流程-大图" class="headerlink" title="第九节 认证流程 - 大图"></a><strong>第九节 认证流程 - 大图</strong></h2><p>（未完待续…）</p><hr><h2 id="第十节-自定义"><a href="#第十节-自定义" class="headerlink" title="第十节 自定义"></a><strong>第十节 自定义</strong></h2><p>（未完待续…）</p><hr><h2 id="第十一节-第三方扩展"><a href="#第十一节-第三方扩展" class="headerlink" title="第十一节 第三方扩展"></a><strong>第十一节 第三方扩展</strong></h2><p>（未完待续…）</p><hr><h2 id="第十二节-Java文档"><a href="#第十二节-Java文档" class="headerlink" title="第十二节 Java文档"></a><strong>第十二节 Java文档</strong></h2><p>（未完待续…）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="http://www.pac4j.org/docs/index.html" title="Title" target="_blank" rel="noopener">Pac4j官方文档</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/u010004082/article/details/79744481" title="Title" target="_blank" rel="noopener">Pac4j文档翻译（3.0）</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Pac4j。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
      <category term="pac4j" scheme="http://linyishui.top/tags/pac4j/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://linyishui.top/2019082901.html"/>
    <id>http://linyishui.top/2019082901.html</id>
    <published>2019-08-29T09:21:10.000Z</published>
    <updated>2019-10-12T10:04:48.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><strong>线程池</strong></h1><p>&emsp;&emsp;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。</p><p>&emsp;&emsp;第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>&emsp;&emsp;第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>&emsp;&emsp;第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，</p><p>&emsp;&emsp;还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</p><hr><h2 id="第一节-线程池的实现原理"><a href="#第一节-线程池的实现原理" class="headerlink" title="第一节 线程池的实现原理"></a><strong>第一节 线程池的实现原理</strong></h2><p>&emsp;&emsp;当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？本节来看一下线程池 的主要处理流程，处理流程图如下图所示。从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010109.png" alt="线程池的主要处理流程"></p><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p>&emsp;&emsp;ThreadPoolExecutor执行execute()方法的示意图，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010110.png" alt="ThreadPoolExecutor执行示意图"></p><p>&emsp;&emsp;ThreadPoolExecutor执行execute方法分下面4种情况。</p><ol><li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li><li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li><li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法。</li></ol><p>&emsp;&emsp;ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后 （当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><p>&emsp;&emsp;源码分析：上面的流程分析让我们很直观地了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的，线程池执行任务的方法如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    <span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务 </span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; </span><br><span class="line">        <span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。 </span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;        </span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)                    </span><br><span class="line">                ensureQueuedTaskHandled(command); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量， </span></span><br><span class="line">        <span class="comment">// 则创建一个线程执行任务。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command)) </span><br><span class="line">        <span class="comment">// 抛出RejectedExecutionException异常 </span></span><br><span class="line">        reject(command); </span><br><span class="line">        <span class="comment">// is shutdown or saturated            </span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到这点。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        Runnable <span class="keyword">task</span> = firstTask;        </span><br><span class="line">        firstTask = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;                </span><br><span class="line">            runTask(<span class="keyword">task</span>);</span><br><span class="line">            <span class="keyword">task</span> = <span class="keyword">null</span>;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">        workerDone(<span class="keyword">this</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ThreadPoolExecutor中线程执行任务的示意图如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010111.png" alt="ThreadPoolExecutor执行任务示意图"></p><p>&emsp;&emsp;线程池中的线程执行任务分两种情况，如下。</p><ol><li>在execute()方法中创建一个线程时，会让这个线程执行当前任务。</li><li>这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行。</li></ol><hr><h2 id="第二节-线程池的使用"><a href="#第二节-线程池的使用" class="headerlink" title="第二节 线程池的使用"></a><strong>第二节 线程池的使用</strong></h2><h3 id="1-线程池的创建"><a href="#1-线程池的创建" class="headerlink" title="1 线程池的创建"></a><strong>1 线程池的创建</strong></h3><p>&emsp;&emsp;我们可以通过ThreadPoolExecutor来创建一个线程池。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, <span class="keyword">handler</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;创建一个线程池时需要输入几个参数，如下。</p><ol><li><p>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任 务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p></li><li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p></li></ol><ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通 常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用 移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工 厂方法Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li></ul><ol start="3"><li><p>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p></li><li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设 置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下。</p></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">ThreadFactoryBuilder</span>()<span class="selector-class">.setNameFormat</span>(<span class="string">"XX-task-%d"</span>)<span class="selector-class">.build</span>();</span><br></pre></td></tr></table></figure><ol start="5"><li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</li></ol><ul><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</li><li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li><li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟 （MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</li></ul><h3 id="2-向线程池提交任务"><a href="#2-向线程池提交任务" class="headerlink" title="2 向线程池提交任务"></a><strong>2 向线程池提交任务</strong></h3><p>&emsp;&emsp;可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。 通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;                        </span><br><span class="line">    <span class="meta">@Override</span>                        </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                                </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub                        </span></span><br><span class="line">    &#125;                </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方 法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">Object</span>&gt; future = executor.submit(harReturnValuetask);                </span><br><span class="line"><span class="keyword">try</span> &#123;                        </span><br><span class="line">    <span class="built_in">Object</span> s = future.<span class="keyword">get</span>();                </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        </span><br><span class="line">    <span class="comment">// 处理中断异常                </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;                        </span><br><span class="line">    <span class="comment">// 处理无法执行任务异常                </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;                        </span><br><span class="line">    <span class="comment">// 关闭线程池                        </span></span><br><span class="line">    executor.shutdown();                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-关闭线程池"><a href="#3-关闭线程池" class="headerlink" title="3 关闭线程池"></a><strong>3 关闭线程池</strong></h3><p>&emsp;&emsp;可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线 程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务 可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而 shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>&emsp;&emsp;只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务 都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪 一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭 线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h3 id="4-合理地配置线程池"><a href="#4-合理地配置线程池" class="headerlink" title="4 合理地配置线程池"></a><strong>4 合理地配置线程池</strong></h3><p>&emsp;&emsp;要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p><ul><li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li><li>任务的优先级：高、中和低。</li><li>任务的执行时间：长、中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ul><p>&emsp;&emsp;性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的 线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配 置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务 和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量</p><p>&emsp;&emsp;将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过 Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>&emsp;&emsp;优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。</p><p>&emsp;&emsp;注意如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能<br>执行。</p><p>&emsp;&emsp;执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p><p>&emsp;&emsp;依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越 长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</p><p>&emsp;&emsp;建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任 务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p><h3 id="5-线程池的监控"><a href="#5-线程池的监控" class="headerlink" title="5 线程池的监控"></a><strong>5 线程池的监控</strong></h3><p>&emsp;&emsp;如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</p><ul><li>taskCount：线程池需要执行的任务数量。</li><li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li><li>getActiveCount：获取活动的线程数。</li></ul><p>&emsp;&emsp;通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>9.3　本章小结</p><p>&emsp;&emsp;在工作中我经常发现，很多人因为不了解线程池的实现原理，把线程池配置错误，从而导致了各种问题。本章介绍了为什么要使用线程池、如何使用线程池和线程池的使用原理，相信阅读完本章之后，读者能更准确、更有效地使用线程池。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中线程池，包括：线程池的实现原理和使用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Java常用并发工具类</title>
    <link href="http://linyishui.top/2019082801.html"/>
    <id>http://linyishui.top/2019082801.html</id>
    <published>2019-08-28T08:44:47.000Z</published>
    <updated>2019-10-12T09:20:02.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java中的并发工具类"><a href="#Java中的并发工具类" class="headerlink" title="Java中的并发工具类"></a><strong>Java中的并发工具类</strong></h1><p>&emsp;&emsp;在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数据的一种手段。本章会配合一些应用场景来介绍如何使用这些工具类。</p><hr><h2 id="第一节-等待多线程完成的CountDownLatch"><a href="#第一节-等待多线程完成的CountDownLatch" class="headerlink" title="第一节 等待多线程完成的CountDownLatch"></a><strong>第一节 等待多线程完成的CountDownLatch</strong></h2><p>&emsp;&emsp;CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><p>&emsp;&emsp;假如有这样一个需求：我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的做法是使用 join()方法，如代码清单8-1所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> &#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException </span>&#123;        </span><br><span class="line">        Thread parser1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override   </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;            </span><br><span class="line"></span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;);        </span><br><span class="line">        </span><br><span class="line">        Thread parser2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"parser2 finish"</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;);    </span><br><span class="line">        </span><br><span class="line">        parser1.start();    </span><br><span class="line">        parser2.start();    </span><br><span class="line">        parser1.<span class="keyword">join</span>();    </span><br><span class="line">        parser2.<span class="keyword">join</span>();    </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"all parser finish"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。其中，wait（0）表示永远等待下去，代码片段如下。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(isAlive()</span>) &#123; </span><br><span class="line">    wait<span class="comment">(0)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在JVM里 实现的，所以在JDK里看不到，大家可以查看JVM源码。<br>在JDK 1.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比join的功能更多，如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CountDownLatchTest</span> &#123; </span><br><span class="line">    staticCountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="number">1</span>); </span><br><span class="line">                c.countDown(); </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="number">2</span>); </span><br><span class="line">                c.countDown();            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;).start(); </span><br><span class="line">        c.<span class="keyword">await</span>(); </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"3"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。</p><p>&emsp;&emsp;当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法 会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p><p>&emsp;&emsp;如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使 用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时 间后，就会不再阻塞当前线程。join也有类似的方法。</p><p>&emsp;&emsp;注意　计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数 器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p><hr><h2 id="第二节-同步屏障CyclicBarrier"><a href="#第二节-同步屏障CyclicBarrier" class="headerlink" title="第二节 同步屏障CyclicBarrier"></a><strong>第二节 同步屏障CyclicBarrier</strong></h2><p>&emsp;&emsp;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><h3 id="1-CyclicBarrier简介"><a href="#1-CyclicBarrier简介" class="headerlink" title="1 CyclicBarrier简介"></a><strong>1 CyclicBarrier简介</strong></h3><p>&emsp;&emsp;CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。示例代码如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> &#123; </span><br><span class="line">    staticCyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;                </span><br><span class="line">                <span class="keyword">try</span> &#123;                    </span><br><span class="line">                    c.<span class="keyword">await</span>();                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line"></span><br><span class="line">                &#125;                </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="number">1</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;).start(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;        </span><br><span class="line">            c.<span class="keyword">await</span>();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;        </span><br><span class="line"></span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="number">2</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出，第一种可能输出如下。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二种可能输出如下。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果把new CyclicBarrier(2)修改成new CyclicBarrier(3)，则主线程和子线程会永远等待， 因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。</p><p>&emsp;&emsp;CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景，如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CyclicBarrier; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> &#123;        </span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;                </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;                        </span><br><span class="line">            @Override                        </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;                                </span><br><span class="line">                <span class="keyword">try</span> &#123;                                        </span><br><span class="line">                    c.<span class="keyword">await</span>();                                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;                                </span><br><span class="line"></span><br><span class="line">                &#125;                                </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="number">1</span>);                        </span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;).start();                </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;                        </span><br><span class="line">            c.<span class="keyword">await</span>();                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line"></span><br><span class="line">        &#125;                </span><br><span class="line">        </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="number">2</span>);        </span><br><span class="line">    &#125;        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;                </span><br><span class="line">        @Override                </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;                        </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="number">3</span>);                </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A 都执行完之后，才会继续执行主线程，然后输出2，所以代码执行后的输出如下。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="2-CyclicBarrier的应用场景"><a href="#2-CyclicBarrier的应用场景" class="headerlink" title="2 CyclicBarrier的应用场景"></a><strong>2 CyclicBarrier的应用场景</strong></h3><p>&emsp;&emsp;CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水，如下所示。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map.Entry; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 银行流水处理服务类 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * @authorftf </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankWaterService</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;        </span><br><span class="line">    <span class="comment">/**         </span></span><br><span class="line"><span class="comment">     * 创建4个屏障，处理完之后执行当前类的run方法         </span></span><br><span class="line"><span class="comment">     */</span>        </span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c = <span class="keyword">new</span> <span class="type">CyclicBarrier</span>(<span class="number">4</span>, <span class="built_in">this</span>);        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**         </span></span><br><span class="line"><span class="comment">     * 假设只有4个sheet，所以只启动4个线程         </span></span><br><span class="line"><span class="comment">     */</span>        </span><br><span class="line">    <span class="keyword">private</span> Executor executor = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">4</span>);        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**         </span></span><br><span class="line"><span class="comment">     * 保存每个sheet计算出的银流结果         </span></span><br><span class="line"><span class="comment">     */</span>        </span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;<span class="keyword">String</span>, Integer&gt;sheetBankWaterCount = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>&lt;<span class="keyword">String</span>, Integer&gt;();        </span><br><span class="line">    privatevoid count() &#123;                </span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; <span class="number">4</span>; i++) &#123;                        </span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;                                </span><br><span class="line">                @Override                                </span><br><span class="line">                publicvoid run() &#123;                                        </span><br><span class="line">                    <span class="comment">// 计算当前sheet的银流数据，计算代码省略                                        </span></span><br><span class="line">                    sheetBankWaterCount.put(Thread.currentThread().getName(), <span class="number">1</span>);                                        </span><br><span class="line">                    <span class="comment">// 银流计算完成，插入一个屏障                                        </span></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        c.await();                                        </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;    </span><br><span class="line">                        e.printStackTrace();                                       </span><br><span class="line">                    &#125;                                </span><br><span class="line">                &#125;                        </span><br><span class="line">            &#125;);                </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;        </span><br><span class="line">        </span><br><span class="line">    @Override        </span><br><span class="line">    publicvoid run() &#123;                </span><br><span class="line">        intresult = <span class="number">0</span>;                </span><br><span class="line">        <span class="comment">// 汇总每个sheet计算出的结果                </span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;<span class="keyword">String</span>, Integer&gt;sheet : <span class="type">sheetBankWaterCount</span>.entrySet()) &#123;                        </span><br><span class="line">            result += sheet.getValue();                </span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="comment">// 将结果输出                </span></span><br><span class="line">        sheetBankWaterCount.put(<span class="string">"result"</span>, result);                </span><br><span class="line">        System.out.println(result);        </span><br><span class="line">    &#125;        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> staticvoid main(<span class="keyword">String</span>[] args) &#123;                </span><br><span class="line">        BankWaterService bankWaterCount = <span class="keyword">new</span> <span class="type">BankWaterService</span>();                </span><br><span class="line">        bankWaterCount.count();        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1，再由 BankWaterService线程汇总4个sheet计算出的结果，输出结果如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="3-CyclicBarrier和CountDownLatch的区别"><a href="#3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="3 CyclicBarrier和CountDownLatch的区别"></a><strong>3 CyclicBarrier和CountDownLatch的区别</strong></h3><p>&emsp;&emsp;CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p><p>&emsp;&emsp;CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。上段代码执行完之后会返回true，其中isBroken的使用代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> </span>&#123; </span><br><span class="line">    staticCyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException，BrokenBarrierException </span>&#123;        </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    c.await();                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line"></span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;); </span><br><span class="line">        thread.start(); </span><br><span class="line">        thread.interrupt(); </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            c.await();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            System.out.println(c.isBroken());        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出如下所示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><h2 id="第三节-控制并发线程数的Semaphore"><a href="#第三节-控制并发线程数的Semaphore" class="headerlink" title="第三节 控制并发线程数的Semaphore"></a><strong>第三节 控制并发线程数的Semaphore</strong></h2><p>&emsp;&emsp;Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯。比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路，但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p><h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a><strong>1 应用场景</strong></h3><p>&emsp;&emsp;Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(THREAD_COUNT);    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; THREAD_COUNT; i++) &#123;    </span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;                </span><br><span class="line">                <span class="meta">@Override</span>    </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">                    <span class="keyword">try</span> &#123;    </span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"save data"</span>);    </span><br><span class="line">                        s.release();                    </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    </span><br><span class="line"></span><br><span class="line">                    &#125;                </span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;);        </span><br><span class="line">        &#125; threadPool.shutdown();    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h3 id="2-其他方法"><a href="#2-其他方法" class="headerlink" title="2 其他方法"></a><strong>2 其他方法</strong></h3><p>&emsp;&emsp;Semaphore还提供一些其他方法，具体如下。</p><ul><li>intavailablePermits()：返回此信号量中当前可用的许可证数。</li><li>intgetQueueLength()：返回正在等待获取许可证的线程数。</li><li>booleanhasQueuedThreads()：是否有线程正在等待获取许可证。</li><li>void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。</li><li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li></ul><hr><h2 id="第四节-线程间交换数据的Exchanger"><a href="#第四节-线程间交换数据的Exchanger" class="headerlink" title="第四节 线程间交换数据的Exchanger"></a><strong>第四节 线程间交换数据的Exchanger</strong></h2><p>&emsp;&emsp;Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p>&emsp;&emsp;下面来看一下Exchanger的应用场景。</p><p>&emsp;&emsp;Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致，代码如下所示。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ExchangerTest &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Exchanger&lt;<span class="keyword">String</span>&gt; exgr = <span class="keyword">new</span> Exchanger&lt;<span class="keyword">String</span>&gt;(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123; </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="built_in">try</span> &#123;                    </span><br><span class="line">                    <span class="keyword">String</span> A = <span class="string">"银行流水A"</span>;　　　　</span><br><span class="line">                    <span class="comment">// A录入银行流水数据 </span></span><br><span class="line">                    exgr.exchange(A);                </span><br><span class="line">                &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;                </span><br><span class="line"></span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;); </span><br><span class="line">        </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="built_in">try</span> &#123;                    </span><br><span class="line">                    <span class="keyword">String</span> B = <span class="string">"银行流水B"</span>;　　　　</span><br><span class="line">                    <span class="comment">// B录入银行流水数据                    </span></span><br><span class="line">                    <span class="keyword">String</span> A = exgr.exchange(<span class="string">"B"</span>); </span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span> + A + <span class="string">"，B录入是："</span> + B);                </span><br><span class="line">                &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;                </span><br><span class="line"></span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;); </span><br><span class="line">        </span><br><span class="line">        threadPool.<span class="built_in">shutdown</span>();    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p><p>&emsp;&emsp;本章配合一些应用场景介绍JDK中提供的几个并发工具类，大家记住这个工具类的用途，一旦有对应的业务场景，不妨试试这些工具类。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java常用并发工具类，包括：等待多线程完成的CountDownLatch，同步屏障CyclicBarrier，控制并发线程数的Semaphore，线程间交换数据的Exchanger等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Fork/Join框架</title>
    <link href="http://linyishui.top/2019082601.html"/>
    <id>http://linyishui.top/2019082601.html</id>
    <published>2019-08-26T08:57:17.000Z</published>
    <updated>2019-10-11T09:21:35.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a><strong>Fork/Join框架</strong></h1><p>&emsp;&emsp;本节将会介绍Fork/Join框架的基本原理、算法、设计方式、应用与实现等。</p><hr><h2 id="第一节-什么是Fork-Join框架"><a href="#第一节-什么是Fork-Join框架" class="headerlink" title="第一节 什么是Fork/Join框架"></a><strong>第一节 什么是Fork/Join框架</strong></h2><p>&emsp;&emsp;Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>&emsp;&emsp;我们再通过Fork和Join这两个单词来理解一下Fork/Join框架。Fork就是把一个大任务切分 为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。Fork/Join的运行流程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010107.png" alt="Fork Join的运行流程图"></p><hr><h2 id="第二节-工作窃取算法"><a href="#第二节-工作窃取算法" class="headerlink" title="第二节 工作窃取算法"></a><strong>第二节 工作窃取算法</strong></h2><p>　<br>&emsp;&emsp;工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p>&emsp;&emsp;工作窃取的运行流程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010108.png" alt="工作窃取运行流程图"></p><p>&emsp;&emsp;工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</p><p>&emsp;&emsp;工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><hr><h2 id="第三节-Fork-Join框架的设计"><a href="#第三节-Fork-Join框架的设计" class="headerlink" title="第三节 Fork/Join框架的设计"></a><strong>第三节 Fork/Join框架的设计</strong></h2><p>&emsp;&emsp;我们已经很清楚Fork/Join框架的需求了，那么可以思考一下，如果让我们来设计一个Fork/Join框架，该如何设计？这个思考有助于你理解Fork/Join框架的设计。</p><ul><li>步骤1　分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</li><li>步骤2　执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li></ul><p>&emsp;&emsp;Fork/Join使用两个类来完成以上两件事情。</p><h3 id="1-ForkJoinTask"><a href="#1-ForkJoinTask" class="headerlink" title="1 ForkJoinTask"></a><strong>1 ForkJoinTask</strong></h3><p>&emsp;&emsp;我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。</p><ul><li>RecursiveAction：用于没有返回结果的任务。</li><li>RecursiveTask：用于有返回结果的任务。</li></ul><h3 id="2-ForkJoinPool"><a href="#2-ForkJoinPool" class="headerlink" title="2 ForkJoinPool"></a><strong>2 ForkJoinPool</strong></h3><p>&emsp;&emsp;ForkJoinTask需要通过ForkJoinPool来执行。任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p><hr><h2 id="第四节-使用Fork-Join框架"><a href="#第四节-使用Fork-Join框架" class="headerlink" title="第四节 使用Fork/Join框架"></a><strong>第四节 使用Fork/Join框架</strong></h2><p>&emsp;&emsp;让我们通过一个简单的需求来使用Fork/Join框架，需求是：计算1+2+3+4的结果。</p><p>&emsp;&emsp;使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果。因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package fj; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask; </span><br><span class="line"><span class="keyword">public</span> class CountTask extends RecursiveTask&lt;Integer&gt; &#123;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;　　<span class="comment">// 阈值        </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">end</span>;        </span><br><span class="line">    <span class="keyword">public</span> CountTask(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>) &#123;                </span><br><span class="line">        <span class="keyword">this</span>.start = start;                </span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">end</span> = <span class="built_in">end</span>;        </span><br><span class="line">    &#125;        </span><br><span class="line">    </span><br><span class="line">    @Override        </span><br><span class="line">    <span class="keyword">protected</span> Integer compute() &#123;                </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;                </span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务                </span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (<span class="built_in">end</span> - start) &lt;= THRESHOLD;                </span><br><span class="line">        <span class="built_in">if</span> (canCompute) &#123;                        </span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;                                </span><br><span class="line">                sum += i;                        </span><br><span class="line">            &#125;                </span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;                        </span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算                        </span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + <span class="built_in">end</span>) / <span class="number">2</span>;                        </span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);                        </span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, <span class="built_in">end</span>);                        </span><br><span class="line">            <span class="comment">// 执行子任务                        </span></span><br><span class="line">            leftTask.fork();                        </span><br><span class="line">            rightTask.fork();                        </span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果                        </span></span><br><span class="line">            <span class="keyword">int</span> leftResult=leftTask.join();                        </span><br><span class="line">            <span class="keyword">int</span> rightResult=rightTask.join();                        </span><br><span class="line">            <span class="comment">// 合并子任务                        </span></span><br><span class="line">            sum = leftResult  + rightResult;                </span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="built_in">return</span> sum;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;                </span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();                </span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4                </span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);                </span><br><span class="line">        <span class="comment">// 执行一个任务                </span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);                </span><br><span class="line">        <span class="built_in">try</span> &#123;                        </span><br><span class="line">            System.out.<span class="built_in">println</span>(result.<span class="built_in">get</span>());                </span><br><span class="line">        &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;                </span><br><span class="line"></span><br><span class="line">        &#125; <span class="built_in">catch</span> (ExecutionException e) &#123;                </span><br><span class="line"></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过这个例子，我们进一步了解ForkJoinTask，ForkJoinTask与一般任务的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p><hr><h2 id="第五节-Fork-Join框架的异常处理"><a href="#第五节-Fork-Join框架的异常处理" class="headerlink" title="第五节 Fork/Join框架的异常处理"></a><strong>第五节 Fork/Join框架的异常处理</strong></h2><p>&emsp;&emsp;ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常， 所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">task</span>.isCompletedAbnormally())&#123;                        </span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="keyword">task</span>.getException());                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h2 id="第六节-Fork-Join框架的实现原理"><a href="#第六节-Fork-Join框架的实现原理" class="headerlink" title="第六节 Fork/Join框架的实现原理"></a><strong>第六节 Fork/Join框架的实现原理</strong></h2><p>&emsp;&emsp;ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p><h3 id="（1）ForkJoinTask的fork方法实现原理"><a href="#（1）ForkJoinTask的fork方法实现原理" class="headerlink" title="（1）ForkJoinTask的fork方法实现原理"></a><strong>（1）ForkJoinTask的fork方法实现原理</strong></h3><p>&emsp;&emsp;当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; fork() &#123;        </span><br><span class="line">    ((ForkJoinWorkerThread) Thread.currentThread())            </span><br><span class="line">                                  .pushTask(<span class="keyword">this</span>);        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final void pushTask(ForkJoinTask&lt;&gt; t) &#123;        </span><br><span class="line">    ForkJoinTask&lt;&gt;[] q; int s, m;        </span><br><span class="line">    <span class="keyword">if</span> ((<span class="attr">q</span> = queue) != <span class="literal">null</span>) &#123;　　　　</span><br><span class="line">        // ignore <span class="keyword">if</span> queue removed            </span><br><span class="line">        long <span class="attr">u</span> = (((<span class="attr">s</span> = queueTop) &amp; (<span class="attr">m</span> = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;            </span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t);            </span><br><span class="line">        <span class="attr">queueTop</span> = s + <span class="number">1</span>;　　　　　　</span><br><span class="line">        // <span class="literal">or</span> use putOrderedInt            </span><br><span class="line">        <span class="keyword">if</span> ((s <span class="attr">-=</span> queueBase) &lt;= <span class="number">2</span>)                </span><br><span class="line">            pool.signalWork();            </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">s</span> == m)                </span><br><span class="line">            growQueue();        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）ForkJoinTask的join方法实现原理"><a href="#（2）ForkJoinTask的join方法实现原理" class="headerlink" title="（2）ForkJoinTask的join方法实现原理"></a><strong>（2）ForkJoinTask的join方法实现原理</strong></h3><p>&emsp;&emsp;Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function">V <span class="title">join</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (doJoin() != NORMAL)            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">reportResult</span><span class="params">()</span></span>;        </span><br><span class="line">    <span class="keyword">else</span>            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">getRawResult</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function">V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; </span><br><span class="line">    Throwable ex;        </span><br><span class="line">    <span class="keyword">if</span> ((s = status) == CANCELLED)            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();        </span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)            </span><br><span class="line">        UNSAFE.throwException(ex);        </span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getRawResult</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）。</p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出CancellationException。</li><li>如果任务状态是抛出异常，则直接抛出对应的异常。</li></ul><p>&emsp;&emsp;让我们再来分析一下doJoin()方法的实现代码。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; </span><br><span class="line">    ForkJoinWorkerThread w; </span><br><span class="line">    <span class="keyword">int</span> s; </span><br><span class="line">    <span class="keyword">boolean</span> completed;        </span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;            </span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)                </span><br><span class="line">            <span class="keyword">return</span> s;            </span><br><span class="line">        <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;                </span><br><span class="line">            <span class="keyword">try</span> &#123;                    </span><br><span class="line">                completed = exec();                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;                    </span><br><span class="line">                <span class="function"><span class="keyword">return</span> <span class="title">setExceptionalCompletion</span><span class="params">(rex)</span></span>;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)                    </span><br><span class="line">                <span class="function"><span class="keyword">return</span> <span class="title">setCompletion</span><span class="params">(NORMAL)</span></span>;            </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> w.<span class="title">joinTask</span><span class="params">(<span class="keyword">this</span>)</span></span>;        </span><br><span class="line">    &#125; <span class="keyword">else</span>            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">externalAwaitDone</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中Fork/Join框架，包括：基本介绍，工作窃取算法，Fork/Join框架的设计，使用Fork/Join框架，Fork/Join框架的异常处理等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="http://linyishui.top/2019082501.html"/>
    <id>http://linyishui.top/2019082501.html</id>
    <published>2019-08-25T08:44:25.000Z</published>
    <updated>2019-10-11T09:21:34.798Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a><strong>Java中的阻塞队列</strong></h1><p>&emsp;&emsp;本篇将介绍什么是阻塞队列，以及Java中阻塞队列的4种处理方式，并介绍Java 7中提供的7种阻塞队列，最后分析阻塞队列的一种实现方式。</p><hr><h2 id="第一节-什么是阻塞队列"><a href="#第一节-什么是阻塞队列" class="headerlink" title="第一节 什么是阻塞队列"></a><strong>第一节 什么是阻塞队列</strong></h2><p>&emsp;&emsp;阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p><ol><li><p>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p></li><li><p>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p></li></ol><p>&emsp;&emsp;阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><p>&emsp;&emsp;在阻塞队列不可用时，这两个附加操作提供了4种处理方式，如表6-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010106.png" alt="插入和移除操作的4中处理方式"></p><ul><li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li><li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li><li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li></ul><p>&emsp;&emsp;这两个附加操作的4种处理方式不方便记忆，所以我找了一下这几个方法的规律。put和 take分别尾首含有字母t，offer和poll都含有字母o。</p><p>&emsp;&emsp;注意: 如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永 远不会被阻塞，而且使用offer方法时，该方法永远返回true。</p><hr><h2 id="第二节-Java里的阻塞队列"><a href="#第二节-Java里的阻塞队列" class="headerlink" title="第二节 Java里的阻塞队列"></a><strong>第二节 Java里的阻塞队列</strong></h2><p>&emsp;&emsp;JDK 7提供了7个阻塞队列，如下。</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><h3 id="1-ArrayBlockingQueue"><a href="#1-ArrayBlockingQueue" class="headerlink" title="1 ArrayBlockingQueue"></a><strong>1 ArrayBlockingQueue</strong></h3><p>&emsp;&emsp;ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。</p><p>&emsp;&emsp;默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span>  <span class="type">ArrayBlockingQueue</span>(<span class="number">1000</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问者的公平性是使用可重入锁实现的，代码如下。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayBlockingQueue(int capacity, boolean fair) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>();        </span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="type">Object</span>[capacity];        </span><br><span class="line">    lock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>(fair);        </span><br><span class="line">    notEmpty = lock.<span class="keyword">new</span><span class="type">Condition</span>();        </span><br><span class="line">    notFull =  lock.<span class="keyword">new</span><span class="type">Condition</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2 LinkedBlockingQueue"></a><strong>2 LinkedBlockingQueue</strong></h3><p>&emsp;&emsp;LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h3 id="3-PriorityBlockingQueue"><a href="#3-PriorityBlockingQueue" class="headerlink" title="3 PriorityBlockingQueue"></a><strong>3 PriorityBlockingQueue</strong></h3><p>&emsp;&emsp;PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h3 id="4-DelayQueue"><a href="#4-DelayQueue" class="headerlink" title="4 DelayQueue"></a><strong>4 DelayQueue</strong></h3><p>&emsp;&emsp;DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。</p><p>&emsp;&emsp;只有在延迟期满时才能从队列中提取元素。</p><p>&emsp;&emsp;DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。</p><ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li></ul><h4 id="（1）如何实现Delayed接口"><a href="#（1）如何实现Delayed接口" class="headerlink" title="（1）如何实现Delayed接口"></a><strong>（1）如何实现Delayed接口</strong></h4><p>&emsp;&emsp;DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现，一共有三步。</p><p>&emsp;&emsp;第一步：在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可 以使用，使用sequenceNumber来标识元素在队列中的先后顺序。代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>); </span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123; </span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;            </span><br><span class="line">    <span class="keyword">super</span>(r, result);            </span><br><span class="line">    <span class="keyword">this</span>.time = ns;            </span><br><span class="line">    <span class="keyword">this</span>.period = period;            </span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;            </span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。</p><p>&emsp;&emsp;第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> int compareTo(Delayed other) &#123;            </span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>)　　<span class="comment">// compare zero ONLY if same object                </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;                </span><br><span class="line">        ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;                </span><br><span class="line">        long diff = time - x.time;                </span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;                </span><br><span class="line">        <span class="keyword">else</span>                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    </span><br><span class="line">    long d = (getDelay(TimeUnit.NANOSECONDS) other.getDelay(TimeUnit.NANOSECONDS));            </span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>)  <span class="number">0</span> : ((d &lt; <span class="number">0</span>)  <span class="number">-1</span> : <span class="number">1</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）如何实现延时阻塞队列"><a href="#（2）如何实现延时阻塞队列" class="headerlink" title="（2）如何实现延时阻塞队列"></a><strong>（2）如何实现延时阻塞队列</strong></h4><p>&emsp;&emsp;延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="built_in">delay</span> = first.getDelay(TimeUnit.NANOSECONDS); </span><br><span class="line"><span class="built_in">if</span> (<span class="built_in">delay</span> &lt;= <span class="number">0</span>)    </span><br><span class="line">    <span class="built_in">return</span> q.poll(); </span><br><span class="line"><span class="built_in">else</span> <span class="built_in">if</span> (leader != null)        </span><br><span class="line">    <span class="built_in">available</span>.await(); </span><br><span class="line"><span class="built_in">else</span> &#123;    </span><br><span class="line">    Thread thisThread = Thread.currentThread(); </span><br><span class="line">    leader = thisThread;        </span><br><span class="line">    <span class="built_in">try</span> &#123;                </span><br><span class="line">        <span class="built_in">available</span>.awaitNanos(<span class="built_in">delay</span>);            </span><br><span class="line">    &#125; finally &#123;                </span><br><span class="line">        <span class="built_in">if</span> (leader == thisThread)                </span><br><span class="line">            leader = null;            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p><h3 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5 SynchronousQueue"></a><strong>5 SynchronousQueue</strong></h3><p>&emsp;&emsp;SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</p><p>&emsp;&emsp;它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;        </span><br><span class="line">    transferer = fair  <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。</p><p>&emsp;&emsp;SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p><h3 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6 LinkedTransferQueue"></a><strong>6 LinkedTransferQueue</strong></h3><p>&emsp;&emsp;LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p><h4 id="（1）transfer方法"><a href="#（1）transfer方法" class="headerlink" title="（1）transfer方法"></a><strong>（1）transfer方法</strong></h4><p>&emsp;&emsp;如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。transfer方法的关键代码如下。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node pred = tryAppend(<span class="name">s</span>, haveData)<span class="comment">; </span></span><br><span class="line">return awaitMatch(<span class="name">s</span>, pred, e, (<span class="name">how</span> == TIMED), nanos)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。</p><h4 id="（2）tryTransfer方法"><a href="#（2）tryTransfer方法" class="headerlink" title="（2）tryTransfer方法"></a><strong>（2）tryTransfer方法</strong></h4><p>&emsp;&emsp;tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p><p>&emsp;&emsp;对于带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p><h3 id="7-LinkedBlockingDeque"><a href="#7-LinkedBlockingDeque" class="headerlink" title="7 LinkedBlockingDeque"></a><strong>7 LinkedBlockingDeque</strong></h3><p>&emsp;&emsp;LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、 addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、 获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。</p><p>&emsp;&emsp;在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</p><hr><h2 id="第三节-阻塞队列的实现原理"><a href="#第三节-阻塞队列的实现原理" class="headerlink" title="第三节 阻塞队列的实现原理"></a><strong>第三节 阻塞队列的实现原理</strong></h2><p>&emsp;&emsp;如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢？如果让你来设计阻塞队列你会如何设计，如何让生产者和消费者进行高效率的通信呢？让我们先来看看JDK是如何实现的。</p><p>&emsp;&emsp;使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现ArrayBlockingQueue使用了Condition来实现，代码如下。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final Condition notFull; </span><br><span class="line"><span class="keyword">private</span> final Condition notEmpty; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span>(<span class="params"><span class="keyword">int</span> capacity, boolean fair</span>) </span>&#123;        </span><br><span class="line">    <span class="comment">// 省略其他代码        </span></span><br><span class="line">    notEmpty = <span class="keyword">lock</span>.newCondition();        </span><br><span class="line">    notFull =  <span class="keyword">lock</span>.newCondition();    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException </span>&#123;        </span><br><span class="line">    checkNotNull(e);        </span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;        </span><br><span class="line">    <span class="keyword">lock</span>.lockInterruptibly();        </span><br><span class="line">    <span class="keyword">try</span> &#123;            </span><br><span class="line">        <span class="keyword">while</span> (count == items.length)                </span><br><span class="line">            notFull.<span class="keyword">await</span>();            </span><br><span class="line">            insert(e);        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            <span class="keyword">lock</span>.unlock();        </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;      </span><br><span class="line">        final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;        </span><br><span class="line">        <span class="keyword">lock</span>.lockInterruptibly();        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)                </span><br><span class="line">            notEmpty.<span class="keyword">await</span>();            </span><br><span class="line">            <span class="keyword">return</span> extract();        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            <span class="keyword">lock</span>.unlock();        </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span>(<span class="params">E x</span>) </span>&#123;        </span><br><span class="line">        items[putIndex] = x;        </span><br><span class="line">        putIndex = inc(putIndex);        </span><br><span class="line">        ++count;        </span><br><span class="line">        notEmpty.signal();    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过LockSupport.park（this）来实现。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;            </span><br><span class="line">    if (Thread.interrupted())                </span><br><span class="line">        throw new InterruptedException();            </span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();            </span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);            </span></span><br><span class="line"><span class="title">    int</span> interruptMode = <span class="number">0</span>;            </span><br><span class="line">    </span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;                </span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);                </span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)                    </span><br><span class="line">            break;            </span><br><span class="line">    &#125;            </span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)                </span><br><span class="line">        interruptMode = REINTERRUPT;            </span><br><span class="line">        </span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null) // clean up if cancelled                </span><br><span class="line">        unlinkCancelledWaiters();            </span><br><span class="line">        </span><br><span class="line">    if (interruptMode != <span class="number">0</span>)                </span><br><span class="line">        reportInterruptAfterWait(interruptMode);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;继续进入源码，发现调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span>(<span class="params">Object blocker</span>) </span>&#123;        </span><br><span class="line">    Thread t = Thread.currentThread();        </span><br><span class="line">    setBlocker(t, blocker);        </span><br><span class="line">    <span class="keyword">unsafe</span>.park(<span class="literal">false</span>, <span class="number">0</span>L);        </span><br><span class="line">    setBlocker(t, <span class="literal">null</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;unsafe.park是个native方法，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;park这个方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回。</p><ul><li>与park对应的unpark执行或已经执行时。“已经执行”是指unpark先执行，然后再执行park的情况。</li><li>线程被中断时。</li><li>等待完time参数指定的毫秒数时。</li><li>异常现象发生时，这个异常现象没有任何原因。</li></ul><p>&emsp;&emsp;继续看一下JVM是如何实现park方法：park在不同的操作系统中使用不同的方式实现，在 Linux下使用的是系统方法pthread_cond_wait实现。实现代码在JVM源码路径src/os/linux/vm/os_linux.cpp里的os::PlatformEvent::park方法，代码如下。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void os::PlatformEvent::park() &#123;    </span><br><span class="line">    int v ;            </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                </span><br><span class="line">        v = <span class="variable">_Event</span> ;            </span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg (v-<span class="number">1</span>, &amp;<span class="variable">_Event</span>, v) == v)  break ;            </span><br><span class="line">    &#125;            </span><br><span class="line">    </span><br><span class="line">    guarantee (v &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;            </span><br><span class="line">        <span class="comment">// Do this the hard way by blocking ...            </span></span><br><span class="line">        int status = pthread_mutex_lock(<span class="variable">_mutex</span>);            </span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_lock"</span>);            </span><br><span class="line">        guarantee (<span class="variable">_nParked</span> == <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">        ++ <span class="variable">_nParked</span> ;            </span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">_Event</span> &lt; <span class="number">0</span>) &#123;            </span><br><span class="line">            status = pthread_cond_wait(<span class="variable">_cond</span>, <span class="variable">_mutex</span>);            </span><br><span class="line">            <span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...            </span></span><br><span class="line">            <span class="comment">// Treat this the same as if the wait was interrupted            </span></span><br><span class="line">            <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;            </span><br><span class="line">            assert_status(status == <span class="number">0</span> || status == EINTR, status, <span class="string">"cond_wait"</span>);            </span><br><span class="line">        &#125;            </span><br><span class="line">        -- <span class="variable">_nParked</span> ;            </span><br><span class="line">        <span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),            </span></span><br><span class="line">        <span class="comment">// but then we'd need a MEMBAR after the ST.            </span></span><br><span class="line">        <span class="variable">_Event</span> = <span class="number">0</span> ;            </span><br><span class="line">        status = pthread_mutex_unlock(<span class="variable">_mutex</span>);            </span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_unlock"</span>);            </span><br><span class="line">    &#125;            </span><br><span class="line">    guarantee (<span class="variable">_Event</span> &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;pthread_cond_wait是一个多线程的条件变量函数，cond是condition的缩写，字面意思可以理解为线程在等待一个条件发生，这个条件是一个全局变量。这个方法接收两个参数：一个共享变量_cond，一个互斥量_mutex。而unpark方法在Linux下是使用pthread_cond_signal实现的。park方法在Windows下则是使用WaitForSingleObject实现的。想知道pthread_cond_wait是如何实现的，可以参考glibc-2.5的nptl/sysdeps/pthread/pthread_cond_wait.c。</p><p>&emsp;&emsp;当线程被阻塞队列阻塞时，线程会进入WAITING（parking）状态。我们可以使用jstack dump阻塞的生产者线程看到这点，如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007fc83c000000 nid=<span class="number">0</span>x10164e000 waiting on condition [<span class="number">0</span>x0000000101        </span><br><span class="line">       java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (parking)              </span><br><span class="line">             at sun<span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)              </span><br><span class="line">             - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0</span>x0000000140559fe8&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span> AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)        at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport<span class="selector-class">.java</span>:<span class="number">186</span>)              </span><br><span class="line">             at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.AbstractQueuedSynchronizer</span><span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer<span class="selector-class">.java</span>:<span class="number">2043</span>)         at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ArrayBlockingQueue</span><span class="selector-class">.put</span>(ArrayBlockingQueue<span class="selector-class">.java</span>:<span class="number">32</span>              </span><br><span class="line">             at blockingqueue<span class="selector-class">.ArrayBlockingQueueTest</span><span class="selector-class">.main</span>(ArrayBlockingQueueTest<span class="selector-class">.java</span>:</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中阻塞队列，包括：内容简介，Java提供的7个阻塞队列，阻塞队列的实现原理等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentLinkedQueue的实现原理</title>
    <link href="http://linyishui.top/2019082401.html"/>
    <id>http://linyishui.top/2019082401.html</id>
    <published>2019-08-24T08:31:43.000Z</published>
    <updated>2019-10-11T09:21:39.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentLinkedQueue的实现原理"><a href="#ConcurrentLinkedQueue的实现原理" class="headerlink" title="ConcurrentLinkedQueue的实现原理"></a><strong>ConcurrentLinkedQueue的实现原理</strong></h1><p>&emsp;&emsp;在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：一种是使用<strong>阻塞算法</strong>，另一种是使用<strong>非阻塞算法</strong>。</p><p>&emsp;&emsp;使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。本篇内容主要整理Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的。</p><p>&emsp;&emsp;ConcurrentLinkedQueue是一个<strong>基于链接节点的无界线程安全队列</strong>，它采用<strong>先进先出</strong>的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait-free”算法（即CAS算法）来实现，该算法在Michael&amp;Scott算法上进行了一些修改。</p><hr><h2 id="第一节-ConcurrentLinkedQueue的结构"><a href="#第一节-ConcurrentLinkedQueue的结构" class="headerlink" title="第一节 ConcurrentLinkedQueue的结构"></a><strong>第一节 ConcurrentLinkedQueue的结构</strong></h2><p>&emsp;&emsp;通过ConcurrentLinkedQueue的类图来分析一下它的结构，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010103.png" alt="ConcurrentLinkedQueue的类图"></p><p>&emsp;&emsp;ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; tail = head;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-入队列"><a href="#第二节-入队列" class="headerlink" title="第二节 入队列"></a><strong>第二节 入队列</strong></h2><p>&emsp;&emsp;本节将介绍入队列的相关知识。</p><h3 id="1-入队列的过程"><a href="#1-入队列的过程" class="headerlink" title="1 入队列的过程"></a><strong>1 入队列的过程</strong></h3><p>&emsp;&emsp;入队列就是将入队节点添加到队列的尾部。为了方便理解入队时队列的变化，以及head节点和tail节点的变化，这里以一个示例来展开介绍。假设我们想在一个队列中依次插入4个节点，为了帮助大家理解，每添加一个节点就做了一个队列的快照图，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010104.png" alt="队列添加元素的快照图"></p><p>&emsp;&emsp;上图所示的过程如下。</p><ul><li>添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li><li>添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li><li>添加元素3，设置tail节点的next节点为元素3节点。</li><li>添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li></ul><p>&emsp;&emsp;通过调试入队过程并观察head节点和tail节点的变化，发现入队主要做两件事情：第一是将入队节点设置成当前队列尾节点的下一个节点；第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点（理解这一点对于我们研究源码会非常有帮助）。</p><p>&emsp;&emsp;通过对上面的分析，我们从单线程入队的角度理解了入队过程，但是多个线程同时进行入队的情况就变得更加复杂了，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再通过源码来详细分析一下它是如何使用CAS算法来入队的。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    </span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点        </span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);        </span><br><span class="line">    retry:        </span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。        </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;            </span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用            </span></span><br><span class="line">        Node&lt;E&gt; t = tail;            </span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。            </span></span><br><span class="line">        Node&lt;E&gt; p = t;            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;            </span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。                </span></span><br><span class="line">            Node&lt;E&gt; <span class="keyword">next</span> = succ(p);    </span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点                </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点                    </span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)                        </span><br><span class="line">                    <span class="keyword">continue</span> retry;                     </span><br><span class="line">                p = <span class="keyword">next</span>;                </span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。                </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;                    </span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，                      </span></span><br><span class="line"><span class="comment">                更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span> </span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)                        </span><br><span class="line">                    casTail(t, n); </span><br><span class="line">                    <span class="comment">// 更新tail节点，允许失败                    </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;                </span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点                </span></span><br><span class="line">            <span class="keyword">else</span> &#123;                    </span><br><span class="line">                p = succ(p);                </span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从源代码角度来看，整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p><h3 id="2-定位尾节点"><a href="#2-定位尾节点" class="headerlink" title="2 定位尾节点"></a><strong>2 定位尾节点</strong></h3><p>&emsp;&emsp;tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。获取p节点的next节点代码如下。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; succ(<span class="keyword">Node</span><span class="title">&lt;E</span>&gt; p) &#123;        </span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next = p.getNext();        </span><br><span class="line">    return (p == next)  </span><br><span class="line">    head : next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-设置入队节点为尾节点"><a href="#3-设置入队节点为尾节点" class="headerlink" title="3 设置入队节点为尾节点"></a><strong>3 设置入队节点为尾节点</strong></h3><p>&emsp;&emsp;p.casNext（null，n）方法用于将入队节点设置为当前队列尾节点的next节点，如果p是null，表示p是当前队列的尾节点，如果不为null，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p><h3 id="4-HOPS的设计意图"><a href="#4-HOPS的设计意图" class="headerlink" title="4 HOPS的设计意图"></a><strong>4 HOPS的设计意图</strong></h3><p>&emsp;&emsp;上面分析过对于先进先出的队列入队所要做的事情是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么，我用以下方式来实现是否可行？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)                        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                </span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);                </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                        </span><br><span class="line">        Node&lt;E&gt; t = tail;                        </span><br><span class="line">        <span class="keyword">if</span> (t.casNext(<span class="keyword">null</span>, n) &amp;&amp; casTail(t, n)) &#123;                                </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;                        </span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑清晰和易懂。但是，这么做有个缺点，每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意入队方法永远返回true，所以不要通过返回值判断入队是否成功。</p><h2 id="第三节-出队列"><a href="#第三节-出队列" class="headerlink" title="第三节 出队列"></a><strong>第三节 出队列</strong></h2><p>&emsp;&emsp;出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察一下head节点的变化，如下图所示。</p><p>&emsp;&emsp;从图中可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。</p><p>&emsp;&emsp;让我们再通过源码来深入分析下出队过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010105.png" alt="队列出节点快照图"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E poll() &#123;                </span><br><span class="line">    Node&lt;E&gt; h = head;        </span><br><span class="line">    <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">    Node&lt;E&gt; p = h;                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>;; hops++) &#123;                        </span><br><span class="line">        <span class="comment">// 获取p节点的元素                        </span></span><br><span class="line">        E item = p.getItem();                        </span><br><span class="line">        <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,                        </span></span><br><span class="line">        <span class="comment">// 如果成功则返回p节点的元素。                        </span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;                                </span><br><span class="line">            <span class="keyword">if</span> (hops &gt;= HOPS) &#123;                                        </span><br><span class="line">                <span class="comment">// 将p节点下一个节点设置成head节点                                        </span></span><br><span class="line">                Node&lt;E&gt; q = p.getNext();                                        </span><br><span class="line">                updateHead(h, (q != <span class="keyword">null</span>)  q : p);                                </span><br><span class="line">            &#125;                                </span><br><span class="line">            <span class="keyword">return</span> item;                        </span><br><span class="line">        &#125;                        </span><br><span class="line">        <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外                        </span></span><br><span class="line">        <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点                        </span></span><br><span class="line">        Node&lt;E&gt; <span class="keyword">next</span> = succ(p);                        </span><br><span class="line">        <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了                        </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            <span class="comment">// 更新头节点。                                </span></span><br><span class="line">            updateHead(h, p);                                </span><br><span class="line">            <span class="keyword">break</span>;                        </span><br><span class="line">        &#125;                        </span><br><span class="line">        <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点                        </span></span><br><span class="line">        p = <span class="keyword">next</span>;                </span><br><span class="line">    &#125;               </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中ConcurrentLinkedQueue的实现原理，包括：ConcurrentLinkedQueue的结构，入队列，出队列等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap的实现原理与使用</title>
    <link href="http://linyishui.top/2019082301.html"/>
    <id>http://linyishui.top/2019082301.html</id>
    <published>2019-08-23T07:53:56.000Z</published>
    <updated>2019-10-11T09:21:42.736Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a><strong>ConcurrentHashMap的实现原理与使用</strong></h1><p>&emsp;&emsp;ConcurrentHashMap是线程安全且高效的HashMap。我们需要了解该容器是如何在保证线程安全的同时又能保证高效的操作。</p><hr><h2 id="第一节-为什么要使用ConcurrentHashMap"><a href="#第一节-为什么要使用ConcurrentHashMap" class="headerlink" title="第一节 为什么要使用ConcurrentHashMap"></a><strong>第一节 为什么要使用ConcurrentHashMap</strong></h2><p>&emsp;&emsp;在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。</p><h3 id="1-线程不安全的HashMap"><a href="#1-线程不安全的HashMap" class="headerlink" title="1 线程不安全的HashMap"></a><strong>1 线程不安全的HashMap</strong></h3><p>&emsp;&emsp;在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。例如，执行以下代码会引起死循环。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;(<span class="number">2</span>);        </span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">    @Override            </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;<span class="comment">//重写run函数，循环创建并启动新线程                </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                    </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;                        </span><br><span class="line">                @Override                        </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;<span class="comment">//线程向HashMap写入一组随机字符键值对                    </span></span><br><span class="line">                    <span class="built_in">map</span>.put(UUID.randomUUID().toString(), <span class="string">""</span>);                        </span><br><span class="line">                &#125;                    </span><br><span class="line">            &#125;, <span class="string">"ftf"</span> + i).start();                </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;, <span class="string">"ftf"</span>);        </span><br><span class="line">t.start();        </span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><h3 id="2-效率低下的HashTable"><a href="#2-效率低下的HashTable" class="headerlink" title="2 效率低下的HashTable"></a><strong>2 效率低下的HashTable</strong></h3><p>&emsp;&emsp;HashTable容器使用<strong>synchronized</strong>来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><h3 id="3-ConcurrentHashMap的锁分段技术可有效提升并发访问率"><a href="#3-ConcurrentHashMap的锁分段技术可有效提升并发访问率" class="headerlink" title="3 ConcurrentHashMap的锁分段技术可有效提升并发访问率"></a><strong>3 ConcurrentHashMap的锁分段技术可有效提升并发访问率</strong></h3><p>&emsp;&emsp;HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。<strong>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong>。</p><hr><h2 id="第二节-ConcurrentHashMap的结构"><a href="#第二节-ConcurrentHashMap的结构" class="headerlink" title="第二节 ConcurrentHashMap的结构"></a><strong>第二节 ConcurrentHashMap的结构</strong></h2><p>&emsp;&emsp;通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构，如下图所示。ConcurrentHashMap是由<strong>Segment数组结构</strong>和<strong>HashEntry数组结构</strong>组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010101.png" alt="ConcurrentHashMap的类图"></p><p>&emsp;&emsp;Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010102.png" alt="ConcurrentHashMap的结构图"></p><hr><h2 id="第三节-ConcurrentHashMap的初始化"><a href="#第三节-ConcurrentHashMap的初始化" class="headerlink" title="第三节 ConcurrentHashMap的初始化"></a><strong>第三节 ConcurrentHashMap的初始化</strong></h2><p>&emsp;&emsp;ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p><h3 id="1-初始化segments数组"><a href="#1-初始化segments数组" class="headerlink" title="1 初始化segments数组"></a><strong>1 初始化segments数组</strong></h3><p>&emsp;&emsp;让我们来看一下初始化segments数组的源代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)            </span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;        </span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;            </span><br><span class="line">    ++sshift;            </span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;<span class="comment">//左移一位，左边移除，右边补0，相当于*2        </span></span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;<span class="comment">//计算得到段偏移量        </span></span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;<span class="comment">//计算得到段掩码        </span></span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由上面的代码可知，segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方 （power-of-two size），所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。</p><p>&emsp;&emsp;注意concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位。</p><h3 id="2-初始化segmentShift和segmentMask"><a href="#2-初始化segmentShift和segmentMask" class="headerlink" title="2 初始化segmentShift和segmentMask"></a><strong>2 初始化segmentShift和segmentMask</strong></h3><p>&emsp;&emsp;这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。 （ssize: 1-&gt;2-&gt;4-&gt;8-&gt;16 sshift = 4）</p><p>&emsp;&emsp;segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。</p><p>&emsp;&emsp;segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><h3 id="3-初始化每个segment"><a href="#3-初始化每个segment" class="headerlink" title="3 初始化每个segment"></a><strong>3 初始化每个segment</strong></h3><p>&emsp;&emsp;输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)            </span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;   </span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;     </span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)<span class="comment">//ssize不是initialCapacity的约数，则c+1</span></span><br><span class="line">    ++c;    </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">cap</span> = <span class="number">1</span>; </span><br><span class="line">while (<span class="built_in">cap</span> &lt; c) <span class="comment">//cap为2的c次方        </span></span><br><span class="line">    <span class="built_in">cap</span> &lt;&lt;= <span class="number">1</span>;        </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; this.segments.length; ++i)            </span><br><span class="line">    this.segments[i] = <span class="built_in">new</span> Segment&lt;K,V&gt;(<span class="built_in">cap</span>, loadFactor);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。 </p><p>&emsp;&emsp;segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于 0.75，通过运算cap等于1，threshold等于零。</p><hr><h2 id="第四节-定位Segment"><a href="#第四节-定位Segment" class="headerlink" title="第四节 定位Segment"></a><strong>第四节 定位Segment</strong></h2><p>&emsp;&emsp;既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次<strong>再散列</strong>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">private</span> static int hash(int h) &#123;        </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">15</span>)<span class="regexp"> ^</span> 0xffffcd7d;        </span><br><span class="line">    <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">10</span>);       </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">3</span>);        </span><br><span class="line">    <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">6</span>);        </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);        </span><br><span class="line">    <span class="attribute">return</span> h<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">16</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之所以进行再散列，目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存取效率。假如散列的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。原作者做了一个测试，不通过再散列而直接执行散列计算。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0001111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0011111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"1111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;计算后输出的散列值全是15，通过这个例子可以发现，如果不进行再散列，散列冲突会非常严重，因为只要低位一样，无论高位是什么数，其散列值总是一样。我们再把上面的二进制数据进行再散列后结果如下（为了方便阅读，不足32位的高位补了0，每隔4位用竖线分割下）。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0100</span>｜<span class="number">0111</span>｜<span class="number">0110</span>｜<span class="number">0111</span>｜<span class="number">1101</span>｜<span class="number">1010</span>｜<span class="number">0100</span>｜<span class="number">1110</span> </span><br><span class="line"><span class="number">1111</span>｜<span class="number">0111</span>｜<span class="number">0100</span>｜<span class="number">0011</span>｜<span class="number">0000</span>｜<span class="number">0001</span>｜<span class="number">1011</span>｜<span class="number">1000</span> </span><br><span class="line"><span class="number">0111</span>｜<span class="number">0111</span>｜<span class="number">0110</span>｜<span class="number">1001</span>｜<span class="number">0100</span>｜<span class="number">0110</span>｜<span class="number">0011</span>｜<span class="number">1110</span> </span><br><span class="line"><span class="number">1000</span>｜<span class="number">0011</span>｜<span class="number">0000</span>｜<span class="number">0000</span>｜<span class="number">1100</span>｜<span class="number">1000</span>｜<span class="number">0001</span>｜<span class="number">1010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现，每一位的数据都散列开了，通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。ConcurrentHashMap通过以下散列算法定位segment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中，(hash&gt;&gt;&gt;segmentShift) &amp; segmentMask的运算结果分别是4、15、7和8，可以看到散列值没有发生冲突。</p><hr><h2 id="第五节-ConcurrentHashMap的操作"><a href="#第五节-ConcurrentHashMap的操作" class="headerlink" title="第五节 ConcurrentHashMap的操作"></a><strong>第五节 ConcurrentHashMap的操作</strong></h2><p>&emsp;&emsp;本节介绍ConcurrentHashMap的3种操作——get操作、put操作和size操作。</p><h3 id="1-get操作"><a href="#1-get操作" class="headerlink" title="1 get操作"></a><strong>1 get操作</strong></h3><p>&emsp;&emsp;Segment的get操作实现非常简单和高效。先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素，代码如下。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;        </span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());        </span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).<span class="built_in">get</span>(<span class="built_in">key</span>, hash);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。</p><p>&emsp;&emsp;我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写 （有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient <span class="keyword">volatile</span> <span class="built_in">int</span> <span class="built_in">count</span>; </span><br><span class="line"><span class="keyword">volatile</span> V <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样， 都与数组的长度减去1再相“与”，但是相“与”的值不一样，定位Segment使用的是元素的 hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask　<span class="comment">// 定位Segment所使用的hash算法 </span></span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = hash &amp; (tab.<span class="built_in">length</span> - <span class="number">1</span>);　<span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure><h3 id="2-put操作"><a href="#2-put操作" class="headerlink" title="2 put操作"></a><strong>2 put操作</strong></h3><p>&emsp;&emsp;由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必 须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置，然后将其放在HashEntry数组里。</p><h4 id="（1）是否需要扩容"><a href="#（1）是否需要扩容" class="headerlink" title="（1）是否需要扩容"></a><strong>（1）是否需要扩容</strong></h4><p>&emsp;&emsp;在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p><h4 id="（2）如何扩容"><a href="#（2）如何扩容" class="headerlink" title="（2）如何扩容"></a><strong>（2）如何扩容</strong></h4><p>&emsp;&emsp;在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p><h3 id="3-size操作"><a href="#3-size操作" class="headerlink" title="3 size操作"></a><strong>3 size操作</strong></h3><p>&emsp;&emsp;如果要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是可能累加前使用的count发生了变化，那么统计结果就不准了。所以，最安全的做法是在统计size的时候把所有Segment的put、remove和clean方法<br>全部锁住，但是这种做法显然非常低效。</p><p>&emsp;&emsp;因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以 ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p><p>&emsp;&emsp;那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中ConcurrentHashMap的实现原理与使用，包括：来源(相比HashMap以及HashTable的改善)，ConcurrentHashMap的结构，初始化过程，定位Segment，ConcurrentHashMap的相关操作等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>基于CAS+Pa4j+Spring Boot+Shiro实现单点登录</title>
    <link href="http://linyishui.top/2019082201.html"/>
    <id>http://linyishui.top/2019082201.html</id>
    <published>2019-08-22T06:38:20.000Z</published>
    <updated>2019-10-14T07:45:51.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于CAS-Pa4j-Spring-Boot-Shiro实现单点登录"><a href="#基于CAS-Pa4j-Spring-Boot-Shiro实现单点登录" class="headerlink" title="基于CAS+Pa4j+Spring Boot+Shiro实现单点登录"></a><strong>基于CAS+Pa4j+Spring Boot+Shiro实现单点登录</strong></h1><hr><h2 id="第一节-依赖"><a href="#第一节-依赖" class="headerlink" title="第一节 依赖"></a><strong>第一节 依赖</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- pac4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-cas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.buji<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>buji-pac4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="第二节-配置部分"><a href="#第二节-配置部分" class="headerlink" title="第二节 配置部分"></a><strong>第二节 配置部分</strong></h2><p>&emsp;&emsp;Pac4jConfig对PAC4J相关部件进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pac4jConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工程路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.serverName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String projectUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器cas服务路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.casServerUrlPrefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String casServerUrlPrefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas登陆路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.casServerLoginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String casServerLoginUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目cas客户端名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.client-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String clientName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.callbackUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String callbackUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JWT Token 生成器，对CommonProfile生成然后每次携带token访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JwtGenerator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JwtGenerator <span class="title">jwtGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtGenerator(<span class="keyword">new</span> SecretSignatureConfiguration(SecurityConsts.LOGIN_SALT.getValue()),</span><br><span class="line">                <span class="keyword">new</span> SecretEncryptionConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JwtAuthenticator用于认证由JwtGenerator或其他方法生成的JWT令牌，即JWT校验器</span></span><br><span class="line"><span class="comment">     * 即目前设置的ParameterClient-jwtClient进行的校验器，是rest或者前后端分离的核心校验器</span></span><br><span class="line"><span class="comment">     * HTTP客户端验证凭证需要一个认证器。它是ProfileService的一个子组件，该组件验证凭证，同时也处理用户的创建、更新和移除操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JwtAuthenticator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JwtAuthenticator <span class="title">jwtAuthenticator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JwtAuthenticator jwtAuthenticator = <span class="keyword">new</span> JwtAuthenticator();</span><br><span class="line">        <span class="comment">//签名配置：SecretSignatureConfiguration，RSASignatureConfiguration，ECEncryptionConfiguration</span></span><br><span class="line">        jwtAuthenticator.addSignatureConfiguration(<span class="keyword">new</span> SecretSignatureConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">        <span class="comment">//加密配置：SecretEncryptionConfiguration，RSAEncryptionConfiguration，ECEncryptionConfiguration</span></span><br><span class="line">        jwtAuthenticator.addEncryptionConfiguration(<span class="keyword">new</span> SecretEncryptionConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">        <span class="keyword">return</span> jwtAuthenticator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求cas服务端配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasConfiguration <span class="title">casConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CasConfiguration configuration = <span class="keyword">new</span> CasConfiguration();</span><br><span class="line">        <span class="comment">//CAS server登录地址</span></span><br><span class="line">        configuration.setLoginUrl(casServerLoginUrl);</span><br><span class="line">        <span class="comment">//CAS 版本，默认为 CAS30，我们使用的是 CAS20</span></span><br><span class="line">        configuration.setProtocol(CasProtocol.CAS20);</span><br><span class="line">        configuration.setAcceptAnyProxy(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setPrefixUrl(casServerUrlPrefix);</span><br><span class="line">        configuration.setLogoutHandler(<span class="keyword">new</span> ShiroCasLogoutHandler());</span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置多个Client，每个Client对应一种登陆协议，可以在Clients中配置所有协议，默认Client，以及如何区分回调哪个Client</span></span><br><span class="line"><span class="comment">     * client支持多种认证机制：OAuth、SAML、CAS、OpenID Connect、HTTP、OpenID、Google APP Engine、Kerberos(SPNEGO)</span></span><br><span class="line"><span class="comment">     * Authenticators：LDAP、SQL、JWT、MongoDB、CouchDB、IP address、REST API</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> casClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Clients <span class="title">clients</span><span class="params">(CasClient casClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              CasRestFormClient casRestFormClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ParameterClient jwtClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              FormClient formClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              IndirectBasicAuthClient ibaClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              DirectBasicAuthClient dbaClient)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以设置默认client</span></span><br><span class="line">        Clients clients = <span class="keyword">new</span> Clients();</span><br><span class="line">        <span class="comment">//支持的client全部设置进去</span></span><br><span class="line">        clients.setClients(casClient,casRestFormClient,jwtClient,formClient,ibaClient,dbaClient);</span><br><span class="line">        clients.setCallbackUrl(<span class="string">"https://localhost:8443/"</span>);</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas客户端配置</span></span><br><span class="line"><span class="comment">     * 客户端表示身份验证机制（流）。它执行登录过程并返回一个用户概要文件。间接客户端用于UI身份验证，而直接客户端则用于web服务身份验证。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> casConfig 配置通过客户端、授权器和匹配器定义安全配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cas客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasClient <span class="title">casClient</span><span class="params">(CasConfiguration casConfig)</span></span>&#123;</span><br><span class="line">        CasClient casClient = <span class="keyword">new</span> CasClient(casConfig);</span><br><span class="line">        <span class="comment">//客户端回调地址</span></span><br><span class="line">        casClient.setCallbackUrl(callbackUrl);</span><br><span class="line">        casClient.setName(clientName);</span><br><span class="line">        <span class="keyword">return</span> casClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过rest接口可以获取tgt,获取service ticket,甚至可以获取casProfile</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasRestFormClient <span class="title">casRestFormClient</span><span class="params">(CasConfiguration casConfig)</span></span>&#123;</span><br><span class="line">        CasRestFormClient casRestFormClient = <span class="keyword">new</span> CasRestFormClient();</span><br><span class="line">        casRestFormClient.setConfiguration(casConfig);</span><br><span class="line">        casRestFormClient.setName(<span class="string">"rest"</span>);</span><br><span class="line">        <span class="keyword">return</span> casRestFormClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParameterClient <span class="title">jwtClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// token校验器，可以用HeaderClient更安全</span></span><br><span class="line">        ParameterClient jwtClient = <span class="keyword">new</span> ParameterClient(<span class="string">"token"</span>, jwtAuthenticator());</span><br><span class="line">        jwtClient.setSupportGetRequest(<span class="keyword">true</span>);</span><br><span class="line">        jwtClient.setSupportPostRequest(<span class="keyword">true</span>);</span><br><span class="line">        jwtClient.setName(<span class="string">"jwt"</span>);</span><br><span class="line">        <span class="keyword">return</span> jwtClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormClient <span class="title">formClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FormClient formClient = <span class="keyword">new</span> FormClient();</span><br><span class="line">        formClient.setLoginUrl(<span class="string">"https://localhost:8443/loginForm.html"</span>);</span><br><span class="line">        formClient.setName(<span class="string">"form"</span>);</span><br><span class="line">        formClient.setAuthenticator(<span class="keyword">new</span> UserIdPasswordAuthenticator(userRepository,environment));</span><br><span class="line"><span class="comment">//        formClient.setCallbackUrl("https://localhost:8443/callback?client_name=form");</span></span><br><span class="line">        <span class="keyword">return</span> formClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IndirectBasicAuthClient <span class="title">ibaClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IndirectBasicAuthClient ibaClient = <span class="keyword">new</span> IndirectBasicAuthClient();</span><br><span class="line">        ibaClient.setName(<span class="string">"iba"</span>);</span><br><span class="line">        ibaClient.setAuthenticator(<span class="keyword">new</span> UserIdPasswordAuthenticator(userRepository,environment));</span><br><span class="line">        <span class="keyword">return</span> ibaClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectBasicAuthClient <span class="title">dbaClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DirectBasicAuthClient dbaClient = <span class="keyword">new</span> DirectBasicAuthClient();</span><br><span class="line">        dbaClient.setName(<span class="string">"dba"</span>);</span><br><span class="line">        dbaClient.setAuthenticator(<span class="keyword">new</span> UserIdPasswordAuthenticator(userRepository,environment));</span><br><span class="line">        <span class="keyword">return</span> dbaClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  pac4j配置</span></span><br><span class="line"><span class="comment">     *    配置自定义的cas客户端和session存储</span></span><br><span class="line"><span class="comment">     *    配置通过客户端、授权器和匹配器定义安全配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clients 客户端s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"authConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Config <span class="title">config</span><span class="params">(Clients clients)</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config(clients);</span><br><span class="line"><span class="comment">//        config.setSessionStore(shiroSessionStore);</span></span><br><span class="line"><span class="comment">//        config.addAuthorizer();</span></span><br><span class="line"><span class="comment">//        config.addMatcher();</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;配置了6种认证客户端：casClient是cas客户端用于cas认证，casRestFormClient是REST风格的cas认证客户端，jwtClient是JWT认证客户端，formClient是表单认证客户端，ibaClient是间接认证客户端，dbaClient是直接认证客户端。</p><p>&emsp;&emsp;ShiroConfig</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line"><span class="keyword">public</span> class ShiroConfig &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目工程路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.serverName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> serverName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目cas服务路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerUrlPrefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerUrlPrefix;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerLoginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerLoginUrl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerLogoutUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerLogoutUrl;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.client-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> clientName;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.loginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> loginUrl;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.logoutUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> logoutUrl;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casFilterUrlPattern&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casFilterUrlPattern;</span><br><span class="line">    @Value(<span class="string">"$&#123;cookie-path&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> cookiePath;</span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">public</span> ShiroCacheManager shiroCacheManager;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> Pac4jSubjectFactory subjectFactory() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> Pac4jSubjectFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册自定义CasRealm</span></span><br><span class="line"><span class="comment">     * @return CasRealm</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> CasRealm casRealm() &#123;</span><br><span class="line">        CasRealm realm = <span class="keyword">new</span> CasRealm();</span><br><span class="line">        realm.setName(<span class="string">"casRealm"</span>);</span><br><span class="line">        <span class="built_in">return</span> realm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册和配置SecurityManager</span></span><br><span class="line"><span class="comment">     * 需要注意：</span></span><br><span class="line"><span class="comment">     *   1.多realm认证只会抛出AuthenticationException，因此如果要想在外部判断到底是在认证的哪一步发生的错误需要自己定义一些异常类型。</span></span><br><span class="line"><span class="comment">     *   2.shiro没有提供根据条件指定realm的功能，如果需要实现这样的功能只能通过继承与重写来实现。</span></span><br><span class="line"><span class="comment">     * @return SecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean(<span class="string">"securityManager"</span>)</span><br><span class="line">    <span class="keyword">public</span> SecurityManager securityManager() &#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line"><span class="comment">//      // TODO-多个realms进配置在这里</span></span><br><span class="line"><span class="comment">//        ModularRealmAuthenticator modularRealmAuthenticator = new ModularRealmAuthenticator();</span></span><br><span class="line"><span class="comment">//        modularRealmAuthenticator.setAuthenticationStrategy(new FirstSuccessfulStrategy());</span></span><br><span class="line"><span class="comment">//        //Shiro提供了三种策略：AllSuccessFulStrategy, AtLeastOneSuccessFulAtrategy, FirstSuccessFulStrategy，默认使用AtLeastOneSuccessFulAtrategy，通常不需要特别配置</span></span><br><span class="line"><span class="comment">//        manager.setAuthenticator(modularRealmAuthenticator);</span></span><br><span class="line"><span class="comment">//        List&lt;Realm&gt; realms = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        realms.add(getAdminRealm(userService, roleService, authService, jedisUtils));</span></span><br><span class="line"><span class="comment">//        realms.add(getCasRealm(userService, roleService, authService,jedisUtils));</span></span><br><span class="line"><span class="comment">//        manager.setRealms(realms);</span></span><br><span class="line">        <span class="comment">// 设置自定义Realm</span></span><br><span class="line">        manager.setRealm(casRealm());</span><br><span class="line"><span class="comment">//        // 指定 SubjectFactory</span></span><br><span class="line"><span class="comment">//        manager.setSubjectFactory(subjectFactory());</span></span><br><span class="line"><span class="comment">//        // 记住密码管理</span></span><br><span class="line"><span class="comment">//        manager.setRememberMeManager(rememberMeManager());</span></span><br><span class="line"><span class="comment">//        // session管理</span></span><br><span class="line"><span class="comment">//        manager.setSessionManager(sessionManager());</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 关闭shiro自带的session，详情见文档</span></span><br><span class="line"><span class="comment">         * http://shiro.apache.org/session-management.html#SessionManagement-StatelessApplications%28Sessionless%29</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DefaultSubjectDAO subjectDAO = <span class="keyword">new</span> DefaultSubjectDAO();</span><br><span class="line">        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = <span class="keyword">new</span> DefaultSessionStorageEvaluator();</span><br><span class="line">        defaultSessionStorageEvaluator.setSessionStorageEnabled(false);</span><br><span class="line">        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);</span><br><span class="line">        manager.setSubjectDAO(subjectDAO);</span><br><span class="line">        <span class="comment">// 设置缓存管理器</span></span><br><span class="line">        manager.setCacheManager(shiroCacheManager);</span><br><span class="line">        <span class="built_in">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册shiroFilter，配置相关过滤器</span></span><br><span class="line"><span class="comment">     * @return ShiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean(<span class="string">"shiroFilter"</span>)</span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean factory(SecurityManager securityManager,</span><br><span class="line">                                          Config <span class="built_in">config</span>) &#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 必须设置 SecurityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 如果不设置默认会自动寻找Web工程根目录下的"/login.jsp"页面</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(casFilterUrlPattern);</span><br><span class="line">        <span class="comment">// 登录成功后要跳转的链接</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">"/hello"</span>);</span><br><span class="line">        <span class="comment">// 未授权界面;</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">"/403"</span>);</span><br><span class="line">        <span class="comment">//自定义拦截器</span></span><br><span class="line">        Map&lt;<span class="keyword">String</span>, Filter&gt; filters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//Cas资源认证拦截器</span></span><br><span class="line">        <span class="comment">//(或者不论使用什么原理去拦截的HTTP请求)根据客户端和授权配置，通过检查用户已认证和已授权来保护一个URL。</span></span><br><span class="line">        <span class="comment">// 如果用户没有被认证，它对直接客户端展示认证，对间接客户端启动登录进程。</span></span><br><span class="line">        SecurityFilter formSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        formSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        formSecurityFilter.setClients(<span class="string">"form"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"formSecurityFilter"</span>, formSecurityFilter);</span><br><span class="line">        SecurityFilter basicAuthSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        basicAuthSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        basicAuthSecurityFilter.setClients(<span class="string">"iba"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"basicAuthSecurityFilter"</span>, basicAuthSecurityFilter);</span><br><span class="line">        SecurityFilter casSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        casSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        casSecurityFilter.setClients(<span class="string">"cas"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"casSecurityFilter"</span>, casSecurityFilter);</span><br><span class="line">        SecurityFilter jwtSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        jwtSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        jwtSecurityFilter.setClients(<span class="string">"jwt"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"jwtSecurityFilter"</span>, jwtSecurityFilter);</span><br><span class="line">        SecurityFilter dbaSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        dbaSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        dbaSecurityFilter.setClients(<span class="string">"dba,jwt"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"dbaSecurityFilter"</span>, dbaSecurityFilter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Cas认证后回调拦截器</span></span><br><span class="line">        <span class="comment">//对间接客户端结束登录进程后的回调</span></span><br><span class="line">        io.buji.pac4j.filter.CallbackFilter callbackFilter = <span class="keyword">new</span> io.buji.pac4j.filter.CallbackFilter();</span><br><span class="line">        callbackFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        callbackFilter.setDefaultUrl(<span class="string">"https://localhost:8443/"</span>);</span><br><span class="line">        callbackFilter.setMultiProfile(true);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"callbackFilter"</span>, callbackFilter);</span><br><span class="line">        <span class="comment">//Cas注销拦截器</span></span><br><span class="line">        <span class="comment">//处理应用程序和/或身份服务器注销</span></span><br><span class="line">        LogoutFilter logoutFilter = <span class="keyword">new</span> LogoutFilter();</span><br><span class="line">        logoutFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        logoutFilter.setCentralLogout(true);</span><br><span class="line">        logoutFilter.setLocalLogout(true);</span><br><span class="line">        logoutFilter.setDefaultUrl(serverName + <span class="string">"callback?client_name"</span> + clientName);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"logoutFilter"</span>, logoutFilter);</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filters);</span><br><span class="line">        loadShiroFilterChain(shiroFilterFactoryBean);</span><br><span class="line">        <span class="built_in">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载shiroFilter权限控制规则（从数据库读取然后配置）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param shiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> loadShiroFilterChain(ShiroFilterFactoryBean shiroFilterFactoryBean) &#123;</span><br><span class="line">        <span class="comment">/*下面这些规则配置最好配置到配置文件中 */</span></span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// authc：该过滤器下的页面必须登录后才能访问，它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span></span><br><span class="line">        <span class="comment">// anon: 可以理解为不拦截</span></span><br><span class="line">        <span class="comment">// user: 登录了就不拦截</span></span><br><span class="line">        <span class="comment">// roles["admin"] 用户拥有admin角色</span></span><br><span class="line">        <span class="comment">// perms["permission1"] 用户拥有permission1权限</span></span><br><span class="line">        <span class="comment">// filter顺序按照定义顺序匹配，匹配到就验证，验证完毕结束。</span></span><br><span class="line">        <span class="comment">// url匹配通配符支持：? * **,分别表示匹配1个，匹配0-n个（不含子路径），匹配下级所有路径</span></span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/form/**"</span>, <span class="string">"formSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/cas/**"</span>, <span class="string">"casSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/iba/**"</span>, <span class="string">"basicAuthSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/jwt/**"</span>, <span class="string">"noSessionCreation,jwtSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/dba/**"</span>, <span class="string">"noSessionCreation,dbaSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/callback"</span>, <span class="string">"callbackFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/logout"</span>, <span class="string">"logoutFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/token"</span>, <span class="string">"formSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/**"</span>, <span class="string">"noSessionCreation,jwtSecurityFilter"</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面的代码是添加注解支持</span></span><br><span class="line"><span class="comment">     * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证</span></span><br><span class="line"><span class="comment">     * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    @DependsOn(<span class="string">"lifecycleBeanPostProcessor"</span>)</span><br><span class="line">    <span class="keyword">public</span> DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() &#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        <span class="comment">// 强制使用cglib，防止重复代理和可能引起代理出错的问题</span></span><br><span class="line">        <span class="comment">// https://zhuanlan.zhihu.com/p/29161098</span></span><br><span class="line">        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);</span><br><span class="line">        <span class="built_in">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor advisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        advisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="built_in">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;自定义Realm-CasRealm，继承Pac4jRealm，支持Pac4jToken，重写相关方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasRealm</span> <span class="keyword">extends</span> <span class="title">Pac4jRealm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(CasRealm.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CasRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个唯一的Realm名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断此Realm是否支持此Token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> Pac4jToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证</span></span><br><span class="line"><span class="comment">     * Shiro登录认证(原理：用户提交 用户名和密码 --- shiro 封装令牌 ---- realm 通过用户名将密码查询返回 ---- shiro</span></span><br><span class="line"><span class="comment">     * 自动去比较查询出密码和用户输入密码是否一致---- 进行登陆控制 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Shiro开始登录认证"</span>);</span><br><span class="line">        Pac4jToken pac4jToken = (Pac4jToken) authenticationToken;</span><br><span class="line">        List&lt;CommonProfile&gt; profiles = pac4jToken.getProfiles();</span><br><span class="line">        Pac4jPrincipal principal = <span class="keyword">new</span> Pac4jPrincipal(profiles,getPrincipalNameAttribute());</span><br><span class="line">        System.out.println(<span class="string">"Pac4jPrincipal: "</span> + principal.toString());</span><br><span class="line">        CommonProfile profile = principal.getProfile();</span><br><span class="line">        System.out.println(<span class="string">"CommonProfile: "</span> + profile.toString());</span><br><span class="line">        <span class="comment">//获取用户信息</span></span><br><span class="line">        String userId = profile.getId();</span><br><span class="line">        System.out.println(<span class="string">"userId: "</span> + userId);</span><br><span class="line">        User user = userService.findByUserId(userId);</span><br><span class="line">        <span class="comment">// 账号不存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 账号未启用</span></span><br><span class="line">        <span class="keyword">if</span> (user.getDelFlag()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Role&gt; roles = userService.findAllRoleByUserId(user.getUserId());</span><br><span class="line">        List&lt;Auth&gt; auths = userService.findAllAuthByUserId(user.getUserId());</span><br><span class="line">        Set&lt;String&gt; roleSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; authSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            roleSet.add(role.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Auth auth : auths) &#123;</span><br><span class="line">            authSet.add(auth.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        profile.addAttribute(<span class="string">"userId"</span>,user.getUserId());</span><br><span class="line">        profile.addAttribute(<span class="string">"userName"</span>,user.getName());</span><br><span class="line">        profile.addAttribute(<span class="string">"orgId"</span>,user.getUnit().getUnitId());</span><br><span class="line">        profile.addAttribute(<span class="string">"currentTimeMillis"</span>,<span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toString());</span><br><span class="line">        profile.setRoles(authSet);</span><br><span class="line">        profile.setPermissions(roleSet);</span><br><span class="line">        <span class="keyword">final</span> PrincipalCollection principalCollection = <span class="keyword">new</span> SimplePrincipalCollection(principal,getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(principalCollection, pac4jToken.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权/验权（todo 后续有权限在此增加）</span></span><br><span class="line"><span class="comment">     *  单点登陆只需关心角色权限数据即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"doGetAuthorizationInfo()获取角色权限等信息进行校验"</span>);</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        Pac4jPrincipal principal = (Pac4jPrincipal)principals.getPrimaryPrincipal();</span><br><span class="line">        CommonProfile profile = principal.getProfile();</span><br><span class="line">        authorizationInfo.setRoles(profile.getRoles());</span><br><span class="line">        authorizationInfo.addStringPermissions(profile.getPermissions());</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;application.properties相关配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">cookie-path</span>=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目工程路径</span></span><br><span class="line">cas.<span class="attribute">serverName</span>=https://127.0.0.1:8443/</span><br><span class="line"><span class="comment"># 项目cas服务路径</span></span><br><span class="line">cas.<span class="attribute">casServerUrlPrefix</span>=https://xxx.xxx.xxx.xxx/authserver/</span><br><span class="line"><span class="comment"># 项目cas登陆</span></span><br><span class="line">cas.<span class="attribute">casServerLoginUrl</span>=<span class="variable">$&#123;cas.casServerUrlPrefix&#125;</span>login</span><br><span class="line"><span class="comment"># 项目cas登出</span></span><br><span class="line">cas.<span class="attribute">casServerLogoutUrl</span>=<span class="variable">$&#123;cas.casServerUrlPrefix&#125;</span>logout</span><br><span class="line"><span class="comment"># 项目cas回调</span></span><br><span class="line">cas.<span class="attribute">casServerCallbackUrl</span>=<span class="variable">$&#123;cas.serverName&#125;</span>callback</span><br><span class="line"><span class="comment"># 项目cas客户端名</span></span><br><span class="line">cas.<span class="attribute">client-name</span>=cas</span><br><span class="line"><span class="comment"># casFilter UrlPattern</span></span><br><span class="line">cas.<span class="attribute">casFilterUrlPattern</span>=cas</span><br><span class="line"><span class="comment"># 登录地址</span></span><br><span class="line">cas.<span class="attribute">loginUrl</span>=<span class="variable">$&#123;cas.casServerLoginUrl&#125;</span>?service=$&#123;cas.serverName&#125;<span class="variable">$&#123;cas.casFilterUrlPattern&#125;</span></span><br><span class="line"><span class="comment"># 登出地址（casserver启用service跳转功能，需在webapps\cas\WEB-INF\cas.properties文件中启用cas.logout.followServiceRedirects=true）</span></span><br><span class="line">cas.<span class="attribute">logoutUrl</span>=<span class="variable">$&#123;cas.casServerLogoutUrl&#125;</span>?service=$&#123;cas.serverName&#125;<span class="variable">$&#123;cas.casFilterUrlPattern&#125;</span></span><br><span class="line"><span class="comment"># 登录地址</span></span><br><span class="line">cas.<span class="attribute">callbackUrl</span>=<span class="variable">$&#123;cas.serverName&#125;</span>callback?client_name=$&#123;cas.client-name&#125;</span><br><span class="line">cas.<span class="attribute">salt</span>=12345678901234567890123456789012</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-测试部分"><a href="#第三节-测试部分" class="headerlink" title="第三节 测试部分"></a><strong>第三节 测试部分</strong></h2><p>&emsp;&emsp;MainController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtGenerator jwtGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String index()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"https://localhost:8443/form/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    FormClient:               Protected url by form authentication 需要(use login = pwd) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/iba/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    IndirectBasicAuthClient:  Protected url by indirect basic auth 需要(use login = pwd) &lt;/br&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/cas/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    CasClient:                Protected url by CAS 需要(use login = pwd) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/token &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    Generate a JWT token - after being authenticated &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/dba/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    DirectBasicAuthClient:    Protected url by DirectBasicAuthClient  &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              需要POST the Authorization header with value: (Basic amxlbGV1OmpsZWxldQ==) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              then by (/dba/index) ParameterClient: /dba/index (with request parameter: token=jwt_generated_token &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/jwt/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              ParameterClient:  Protected url by ParameterClient 需要(with request parameter: token=jwt_generated_token) &lt;/br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/token"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String token()&#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        String token = <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">final</span> PrincipalCollection collection = subject.getPrincipals();</span><br><span class="line">        <span class="keyword">if</span> (collection != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal != <span class="literal">null</span>) &#123;</span><br><span class="line">                CommonProfile profile = principal.getProfile();</span><br><span class="line">                token = jwtGenerator.generate(profile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FormController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/form/index"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String index() &#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span>(subject == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"subject is null"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"isAuthenticated ? "</span> + subject.isAuthenticated());</span><br><span class="line">            PrincipalCollection collection = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"user is null"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> principal.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;JwtController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/jwt/index"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object index() &#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span>(subject == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"subject is null"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"isAuthenticated ? "</span> + subject.isAuthenticated());</span><br><span class="line">            PrincipalCollection collection = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"user is null"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> principal.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其他类似：/iba/index，/dba/index，/cas/index</p><p>&emsp;&emsp;分别访问主页面：<a href="https://localhost:8443/" target="_blank" rel="noopener">https://localhost:8443/</a></p><p>&emsp;&emsp;表单提交账号密码：<a href="https://localhost:8443/callback?client_name=form，携带username&amp;password，表单登录获得JSESSIONID。" target="_blank" rel="noopener">https://localhost:8443/callback?client_name=form，携带username&amp;password，表单登录获得JSESSIONID。</a></p><p>&emsp;&emsp;表单客户端访问：<a href="https://localhost:8443/form/index，返回用户信息Pac4jPrincipal。" target="_blank" rel="noopener">https://localhost:8443/form/index，返回用户信息Pac4jPrincipal。</a></p><p>&emsp;&emsp;获得令牌：<a href="https://localhost:8443/token，返回token。" target="_blank" rel="noopener">https://localhost:8443/token，返回token。</a></p><p>&emsp;&emsp;JWT客户端访问：<a href="https://localhost:8443/jwt/index?client_name=jwt&amp;token=eyJjdH...，返回用户信息Pac4jPrincipal。" target="_blank" rel="noopener">https://localhost:8443/jwt/index?client_name=jwt&amp;token=eyJjdH...，返回用户信息Pac4jPrincipal。</a></p><p>（未完待续…）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="http://www.pac4j.org/docs/index.html" title="Title" target="_blank" rel="noopener">pac4j官网文档</a></p></blockquote><blockquote><p><a href="https://github.com/pac4j/pac4j/" title="Title" target="_blank" rel="noopener">GitHub pac4j/pac4j</a></p></blockquote><blockquote><p><a href="https://github.com.cnpmjs.org/bujiio/buji-pac4j" title="Title" target="_blank" rel="noopener">GitHub bujiio/buji-pac4j</a></p></blockquote><blockquote><p><a href="https://github.com/pac4j/buji-pac4j-demo" title="Title" target="_blank" rel="noopener">GitHub pac4j/buji-pac4j-demo</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理了一个基于CAS+Pa4j+Spring Boot+Shiro实现单点登录的项目DEMO的部分代码。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="spring boot" scheme="http://linyishui.top/tags/spring-boot/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
      <category term="pac4j" scheme="http://linyishui.top/tags/pac4j/"/>
    
      <category term="shiro" scheme="http://linyishui.top/tags/shiro/"/>
    
      <category term="cas" scheme="http://linyishui.top/tags/cas/"/>
    
  </entry>
  
  <entry>
    <title>Condition接口及实现原理</title>
    <link href="http://linyishui.top/2019081601.html"/>
    <id>http://linyishui.top/2019081601.html</id>
    <published>2019-08-16T07:13:38.000Z</published>
    <updated>2019-09-19T07:53:42.247Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a><strong>Condition接口</strong></h1><p>&emsp;任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</p><p>&emsp;通过对比Object的监视器方法和Condition接口，可以更详细地了解Condition的特性，对比项与结果如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160120.jpg" alt="Object的监视器方法与Condition接口的对比"></p><hr><h2 id="Condition接口与示例"><a href="#Condition接口与示例" class="headerlink" title="Condition接口与示例"></a><strong>Condition接口与示例</strong></h2><p>&emsp;Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p><p>&emsp;Condition的使用方式比较简单，需要注意在调用方法前获取锁，使用方式如下列代码所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.<span class="keyword">await</span>();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;如示例所示，一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p><p>&emsp;Condition定义的（部分）方法以及描述如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160121.jpg" alt="Condition的（部分）方法以及描述"></p><p>&emsp;获取一个Condition必须通过Lock的newCondition()方法。下面通过一个有界队列的示例来深入了解Condition的使用方式。有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”，如下列代码所示。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">private</span> Object[] <span class="built_in">items</span>;</span><br><span class="line">    <span class="comment">// 添加的下标，删除的下标和数组当前数量</span></span><br><span class="line">    <span class="built_in">private</span> int addIndex, removeIndex, <span class="built_in">count</span>;</span><br><span class="line">    <span class="built_in">private</span> <span class="built_in">Lock</span> <span class="built_in">lock</span> = new ReentrantLock();</span><br><span class="line">    <span class="built_in">private</span> Condition notEmpty = <span class="built_in">lock</span>.newCondition();</span><br><span class="line">    <span class="built_in">private</span> Condition notFull = <span class="built_in">lock</span>.newCondition();</span><br><span class="line">    public BoundedQueue(int <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="built_in">items</span> = new Object[<span class="built_in">size</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"</span></span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="built_in">items</span>.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="built_in">items</span>[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span> (++addIndex == <span class="built_in">items</span>.length)</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            ++<span class="built_in">count</span>;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="built_in">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = <span class="built_in">items</span>[removeIndex];</span><br><span class="line">            <span class="keyword">if</span> (++removeIndex == <span class="built_in">items</span>.length)</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            --<span class="built_in">count</span>;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="built_in">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;上述示例中，BoundedQueue通过add(T t)方法添加一个元素，通过remove()方法移出一个元素。以添加方法为例。</p><p>&emsp;首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。</p><p>&emsp;在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p><hr><h2 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a><strong>Condition的实现分析</strong></h2><p>&emsp;ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p><p>&emsp;下面将分析Condition的实现，主要包括：等待队列、等待和通知，下面提到的Condition如果不加说明均指的是ConditionObject。</p><h3 id="1-等待队列"><a href="#1-等待队列" class="headerlink" title="1.等待队列"></a><strong>1.等待队列</strong></h3><p>&emsp;等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p><p>&emsp;一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列的基本结构如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160122.jpg" alt="等待队列的基本结构"></p><p>&emsp;如图所示，Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p><p>&emsp;在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，其对应关系如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160123.jpg" alt="同步队列与等待队列"></p><p>&emsp;如图所示，Condition的实现是同步器的内部类，因此每个Condition实例都能够访问同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。</p><h3 id="2-等待"><a href="#2-等待" class="headerlink" title="2.等待"></a><strong>2.等待</strong></h3><p>&emsp;调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p><p>&emsp;如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p><p>&emsp;Condition的await()方法，如下列代码所示。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">    throw new InterruptedException();</span><br><span class="line">    // 当前线程加入等待队列</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();</span><br><span class="line">    // 释放同步状态，也就是释放锁</span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</span><br><span class="line">            break;</span><br><span class="line">    &#125;    </span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。</p><p>&emsp;当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><p>&emsp;如果从队列的角度去看，当前线程加入Condition的等待队列，该过程如下图示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160124.jpg" alt="当前线程加入等待队列"></p><p>&emsp;如图所示，同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p><h3 id="3-通知"><a href="#3-通知" class="headerlink" title="3.通知"></a><strong>3.通知</strong></h3><p>&emsp;调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。</p><p>&emsp;Condition的signal()方法，如下列代码所示。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p><p>&emsp;节点从等待队列移动到同步队列的过程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160125.jpg" alt="节点从等待队列移动到同步队列"></p><p>&emsp;通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。</p><p>&emsp;被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p><p>&emsp;成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>&emsp;Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的并发包中Condition接口相关内容：Condition接口与示例，Condition的实现分析：1.等待队列，2.等待，3.通知。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>LockSupport工具</title>
    <link href="http://linyishui.top/2019081501.html"/>
    <id>http://linyishui.top/2019081501.html</id>
    <published>2019-08-15T07:12:42.000Z</published>
    <updated>2019-09-19T07:45:19.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a><strong>LockSupport工具</strong></h1><p>&emsp;回顾<a href="../2019040401.html" title="Title">同步器AQS的实现原理</a>，当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。</p><p>&emsp;LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。Park有停车的意思，假设线程为车辆，那么park方法代表着停车，而unpark方法则是指车辆启动离开，这些方法以及描述如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160118.jpg" alt="LockSupport提供的阻塞和唤醒方法"></p><p>&emsp;在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p><p>&emsp;下面的示例中，将对比parkNanos(long nanos)方法和parkNanos(Object blocker,long nanos)方法来展示阻塞对象blocker的用处，代码片段和线程dump（部分）如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160119.jpg" alt="Blocker在线程dump中的作用"></p><p>&emsp;从表的线程dump结果可以看出，代码片段的内容都是阻塞当前线程10秒，但从线程dump结果可以看出，有阻塞对象的parkNanos方法能够传递给开发人员更多的现场信息。这是由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的并发包中LockSupport工具相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>锁Q&amp;A</title>
    <link href="http://linyishui.top/2019081401.html"/>
    <id>http://linyishui.top/2019081401.html</id>
    <published>2019-08-14T02:40:27.000Z</published>
    <updated>2019-09-17T02:43:17.977Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h2><blockquote><p><strong>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</strong></p><p>&emsp;阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p><p>&emsp;这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>&emsp;阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>&emsp;JDK7提供了7个阻塞队列。分别是：</p><p>&emsp;* ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p><p>&emsp;* LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p><p>&emsp;* PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p><p>&emsp;* DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p><p>&emsp;* SynchronousQueue：一个不存储元素的阻塞队列。</p><p>&emsp;* LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p><p>&emsp;* LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p>&emsp;Java 5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized这些关键字。而在java 5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p><p>&emsp;BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。</p><p>&emsp;阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p></blockquote><blockquote><p><strong>互斥锁和自旋锁、信号量的区别？</strong></p><p>&emsp;互斥锁也可以叫互斥量，广义上讲可以值所有实现互斥作用的同步机制。狭义上讲指的就是mutex这种特定的二元锁机制。互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的 。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。</p><p>&emsp;信号量（semaphore） 是一种更高级的同步机制，mutex（互斥锁） 可以说是 semaphore（信号量） 在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p><p>&emsp;自旋锁 是一种 互斥锁 的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock） 则是不断循环并测试锁的状态，这样就一直占着cpu。所以相比于自旋锁和信号量，在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒休眠的线程。</p><p>&emsp;同步锁 好像没啥特殊说法，你可以理解为能实现同步作用的都可以叫同步锁，比如信号量。最后，不要钻这些名词的牛角尖，更重要的是理解这些东西背后的原理，叫什么名字并没有什么好说的。这些东西在不同的语言和平台上又有可能会有不同的叫法，其实本质上就这么回事。</p></blockquote><p>未完待续..</p>]]></content>
    
    <summary type="html">
    
      锁相关内容问与答
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>条件等待队列</title>
    <link href="http://linyishui.top/2019081301.html"/>
    <id>http://linyishui.top/2019081301.html</id>
    <published>2019-08-13T01:08:52.000Z</published>
    <updated>2019-09-19T07:54:15.687Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="条件等待队列"><a href="#条件等待队列" class="headerlink" title="条件等待队列"></a><strong>条件等待队列</strong></h1><p>&emsp;当多个线程 await() 在同一个条件变量上时，会形成一个条件等待队列。同一个锁可以创建多个条件变量，就会存在多个条件等待队列。这个队列和 AQS 的队列结构很接近，只不过它不是双向队列，而是单向队列。队列中的节点和 AQS 等待队列的节点是同一个类，但是节点指针不是 prev 和 next，而是 nextWaiter。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class AQS &#123;</span><br><span class="line">  ...</span><br><span class="line">  class ConditionObject &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">firstWaiter</span>;  // 指向第一个节点</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">lastWaiter</span>;  // 指向第二个节点</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    static</span> final int CONDITION = -<span class="number">2</span>;</span><br><span class="line">    static final int SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    Thread thread;  // 当前等待的线程</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">nextWaiter</span>;  // 指向下一个条件等待节点</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Node</span> <span class="title">prev</span>;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    int waitStatus;  // waitStatus = CONDITION</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160107.jpg" alt=""></p><p>&emsp;ConditionObject 是 AQS 的内部类，这个对象里会有一个隐藏的指针 this$0 指向外部的 AQS 对象，ConditionObject 可以直接访问 AQS 对象的所有属性和方法（加锁解锁）。位于条件等待队列里的所有节点的 waitStatus 状态都被标记为 CONDITION，表示节点是因为条件变量而等待。</p><hr><h1 id="队列转移"><a href="#队列转移" class="headerlink" title="队列转移"></a><strong>队列转移</strong></h1><p>&emsp;当条件变量的 signal() 方法被调用时，条件等待队列的头节点线程会被唤醒，该节点从条件等待队列中被摘走，然后被转移到 AQS 的等待队列中，准备排队尝试重新获取锁。这时节点的状态从 CONDITION 转为 SIGNAL，表示当前节点是被条件变量唤醒转移过来的。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AQS &#123;</span><br><span class="line">  ...</span><br><span class="line">  boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    // 重置节点状态</span><br><span class="line">    if (!<span class="keyword">node</span>.<span class="title">compareAndSetWaitStatus</span>(<span class="keyword">Node</span>.<span class="title">CONDITION</span>, <span class="number">0</span>))</span><br><span class="line">      return <span class="literal">false</span></span><br><span class="line">    <span class="keyword">Node</span> <span class="title">p</span> = enq(<span class="keyword">node</span><span class="title">); // 进入 AQS</span> 等待队列</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    // 再修改状态为SIGNAL</span><br><span class="line">    if (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</span><br><span class="line">       LockSupport.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</span><br><span class="line">       return <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;被转移的节点的 nextWaiter 字段的含义也发生了变更，在条件队列里它是下一个节点的指针，在 AQS 等待队列里它是共享锁还是互斥锁的标志。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160108.jpg" alt="Java 并发包常用类库依赖结构"></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java核心技术 卷Ⅰ》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的条件等待队列相关内容：条件等待队列和队列转移
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Lock接口</title>
    <link href="http://linyishui.top/2019081201.html"/>
    <id>http://linyishui.top/2019081201.html</id>
    <published>2019-08-12T08:36:10.000Z</published>
    <updated>2019-09-19T09:47:11.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><strong>Lock</strong></h1><p>&emsp;Lock提供了和synchronized类似的同步功能，但需要显式的获取和释放锁，缺少了便捷性，但增加了锁获取与释放的可操作性、可中断的获取锁以 及超时获取锁等多种synchronized关键字所不具备的同步特性。</p><h2 id="第一节-创建和使用Lock"><a href="#第一节-创建和使用Lock" class="headerlink" title="第一节 创建和使用Lock"></a><strong>第一节 创建和使用Lock</strong></h2><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//不要将获取锁的过程放入try块，若获取锁时发生异常，异常抛出也会导致锁的释放</span></span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    <span class="comment">//保证释放</span></span><br><span class="line">    <span class="keyword">lock</span>.unlock()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-Lock接口源码"><a href="#第二节-Lock接口源码" class="headerlink" title="第二节 Lock接口源码"></a><strong>第二节 Lock接口源码</strong></h2><p>&emsp;Lock是一个接口，它定义了锁获取和释放的基本操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;Lock的API如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010102.png" alt="Lock的API"></p><hr><h2 id="第三节-Lock具备synchronized没有的特性"><a href="#第三节-Lock具备synchronized没有的特性" class="headerlink" title="第三节 Lock具备synchronized没有的特性"></a><strong>第三节 Lock具备synchronized没有的特性</strong></h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010101.png" alt="Lock接口提供的synchronized关键字不具备的主要特性"></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的并发包中Lock接口相关内容：显式获取和释放锁，Lock接口，Lock所具备的synchronized没有的特性等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>自学习</title>
    <link href="http://linyishui.top/2019081101.html"/>
    <id>http://linyishui.top/2019081101.html</id>
    <published>2019-08-11T08:23:41.000Z</published>
    <updated>2019-09-16T09:01:45.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要学习锁机制，可能浅学会更加容易一些，但脱离的理论和底层细节，在知识点的理解上面就会有不确定的偏差值，久而久之点和点之间矛盾越来越多，知识也没有了统一性了，所以在回顾锁的应用之前，要先学习一下Java中怎么定义和实现锁这个东西的。</p><p>&emsp;学习一个知识点的时候，习惯上我会先搞清楚几个问题：</p><blockquote><ol><li><strong>为什么我要用这个技术？</strong> </li></ol><p>&emsp;确定学习必要性，理由可以如：当前工作需要，准备面试，个人兴趣等。编程的知识内容太多了，而我们的时间是有限的，所以不管是为了工作还是怎样高效的学习都是很有必要的，还有就是不要急于”跳级”学习，由基础开始由浅到深，身边有很多同学Java基础还未掌握好就开始学架构，分布式，服务集群等，一方面是当前不大可能有工作需要，另一方面是代码量和项目经验没有达到一定程度的情况下，可能不会那么容易的理解这些知识，因人而异吧，请在学习前根据自身情况做好规划，这还是蛮重要的。</p></blockquote><blockquote><ol start="2"><li>我怎么去使用这个技术？</li></ol><p>&emsp;学习一个技术，首先就是要会使用它，就像学数学公式一样，可能你不理解它的原理，也没精力或没能力去推理证明，但对于考试来说可能你只要会用就已经足够了。对于工作也是一样，往往我们学一个技术，要先能把它”跑起来”，然后在固定的场景下我们就可以解决一些问题了，但很多人可能就只停留在这个阶段了。这个程度连”了解xx技术”的水平都还没到，不然面试时可能就全是”用过XX吗？”，可能会是很荒诞的一个场景。</p></blockquote><blockquote><ol start="3"><li>如果有其它可以实现同样功能的技术，他们之间的优缺点是什么？引申一下就是什么场景下用什么技术？</li></ol><p>&emsp;不了解一个知识前，我们肯定是总结不出其优缺点，更别说和其它技术的对比了。但因为开发这类工作的特点，就是进度总是比较赶的，总会遇到陌生的难题，也算是工作和学习的区别之一吧，没有时间给你去闷头弄清楚这个，所以我个人会习惯在深入学习前，先查阅资料了解一下技术的相关背景，然后了解一下前人的使用经验，个人感觉这样会节省很多时间来应付一些比较紧急或不太重要的情况。</p></blockquote><p>&emsp;如果一个知识点能够准确回答以上三个问题，表示我已经基本能够正确的使用这个知识点了，大不了就多花点功夫在测试上嘛，但为了能串联知识，加强记忆，真正的掌握一项技术，在有多余时间和精力的情况下还需要再理解更深层的问题：</p><blockquote><ol><li>这个技术怎么运转的？或者说它的工作流程或工作原理是怎样的？</li></ol><p>&emsp;了解一下技术的每一步执行，弄清楚其底层实现，尝试自己手动实现一下。</p></blockquote><blockquote><ol start="2"><li>为什么会这样设计？</li></ol><p>&emsp;再清楚了技术是怎样运作之后，可以思考一下为什么会这样设计？比如是根据什么样的场景或需求所以这样设计，在怎样的情况下使用可能这样的设计会变得糟糕等。</p></blockquote><blockquote><ol start="3"><li>与其相关的知识点有哪些？</li></ol><p>&emsp;了解了以上内容后，对于单个知识点可以说已经掌握了，知识间都是相互联系的，我们为了方便学习而划分为一个个的学科，一个个的章节，一个个的知识点，当知识间可以串联起来汇聚为知识海后就可以成为我们的核心技能了，这是我目前努力的目标。</p></blockquote><p>&emsp;在工作以后，对于学习一定要有一个深刻的意识，即考虑经济效益，知识是没有边界的，人的精力和时间却是很有限的，我们在学习特别是工作后的学习中一定要做好规划，怎样保持适合自己的学习节奏？既能保持一定的学习频率和强度，利用好时间，又能在自己的职业生涯上实现快速的成长？是一个值得深思熟虑的问题。</p><p>&emsp;对于我来讲，现在的方法就是</p><ol><li>先确立一个目标：在短时间内保持一定深度的质量下快速学完Java后端开发技术栈。</li><li>然后制订一个自己会执行的计划：在工作之中留意知识的整理，并通过实战有一定的认知之后，在工作之余抽时间整理为博客文章，根据记忆曲线定期的回顾所整理的内容。</li><li>在一定的积累之后通过项目开发的方式把知识内容再一次的融入到某个自己的项目中，这个项目没有特定的业务需求，只有技术需求。</li></ol>]]></content>
    
    <summary type="html">
    
      闲谈，不泛用
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="other" scheme="http://linyishui.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>线程实际应用</title>
    <link href="http://linyishui.top/2019081001.html"/>
    <id>http://linyishui.top/2019081001.html</id>
    <published>2019-08-10T07:38:35.000Z</published>
    <updated>2019-09-19T08:10:02.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a><strong>等待超时模式</strong></h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>&emsp;调用方法后需要等待一段时间，若时间内可以得到结果，则立即返回结果，否则超时返回默认结果。</p><p>&emsp;等待/通知模式无法做到超时等待，步骤为加锁、条件循环和处理逻辑。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a><strong>内容</strong></h2><p>&emsp;超时则需要添加一个时间段T，所以可以得到等待时间为T，超时的时间节点为nowTime+T。所以在原等待/通知模式上可以加入一个超时处理，在等待返回后判断是否超时即可。</p><p>&emsp;伪代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前对象加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">long</span> mills) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="keyword">long</span> future = System.currentTimeMills() + mills;</span><br><span class="line">    <span class="keyword">long</span> remaining = mills;</span><br><span class="line">    <span class="comment">//当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMills();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;即使方法执行时间很长，也不会”永久”阻塞调用者，而是会按时返回。</p><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a><strong>数据库连接池</strong></h1><h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>&emsp;模拟从连接池中获取、使用和释放连接的过程。而客户端获取连接的过程被设定为等待超时模式。所以在一定时间若无法获取到可用连接，就会返回给客户端null。</p><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a><strong>内容</strong></h2><p>&emsp;ConnectionPool.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池：通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，</span></span><br><span class="line"><span class="comment"> * 调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，</span></span><br><span class="line"><span class="comment"> * 当连接使用完毕后，需要调用releaseConnection(Connection)方法将连接放回线程池。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向队列-维护连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(initialSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; initialSize;i++)&#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool)&#123;</span><br><span class="line">                <span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在mills内无法获取到连接，将会返回null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool)&#123;</span><br><span class="line">            <span class="comment">// 完全超时</span></span><br><span class="line">            <span class="keyword">if</span>(mills &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty())&#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">return</span> pool.<span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(!pool.isEmpty())&#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;ConnectionDriver.java</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * 通过动态代理实现了Connection接口，代理只实现了在commit方法调用时休眠100毫秒</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</span><br><span class="line">            <span class="keyword">if</span>(method.getName().equals(<span class="string">"commit"</span>))&#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个Connection的代理，在commit时休眠100毫秒</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> Connection createConnection()&#123;</span><br><span class="line">        <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(ConnectionDriver.<span class="keyword">class</span>.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class&lt;?&gt;[]&#123; Connection.<span class="keyword">class</span>&#125;,<span class="keyword">new</span> ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;ConnectionPoolTest.java</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟客户端ConnectionRunner获取、使用、最后释放连接的过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ConnectionPoolTest &#123;</span><br><span class="line">    <span class="keyword">static</span> ConnectionPool pool = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//保证所有ConnectionRunner能够同时开始</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//main线程将会等待所有ConnectionRunner结束后才能继续执行</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)<span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//线程数量，可以修改线程数量进行观察</span></span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">10</span>;</span><br><span class="line">        end = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">20</span>;</span><br><span class="line">        AtomicInteger got = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        AtomicInteger notGot = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadCount;i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConnectionRunner(<span class="keyword">count</span>,got,notGot),<span class="string">"ConnectionRunnerThread"</span>);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        start.countDown();</span><br><span class="line">        end.await();</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"total invoke: "</span> + (threadCount * <span class="keyword">count</span>));</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"got connection: "</span> + got);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"not got connection "</span> + notGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> ConnectionRunner <span class="keyword">implements</span> Runnable&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line">        AtomicInteger got;</span><br><span class="line">        AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ConnectionRunner(<span class="keyword">int</span> <span class="keyword">count</span>, AtomicInteger got, AtomicInteger notGot) &#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">count</span> = <span class="keyword">count</span>;</span><br><span class="line">            <span class="keyword">this</span>.got = got;</span><br><span class="line">            <span class="keyword">this</span>.notGot = notGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span></span><br><span class="line">                <span class="comment">//分别统计连接获取的数量got和未获取到的数量notGot</span></span><br><span class="line">                start.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">count</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    Connection connection = pool.fetchConnection(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span>(connection != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                            got.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        notGot.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">count</span>--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;执行结果如下。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total invoke: 200</span><br><span class="line">got connection: 200</span><br><span class="line"><span class="keyword">not</span> got<span class="built_in"> connection </span>0</span><br></pre></td></tr></table></figure><p>&emsp;上述事例中使用了CountDownLatch来确保ConnectionRunnerThread能够同时开始执行，并且在全部执行结束后，才使main线程从等待状态返回。当前设定的场景是10个线程同时运行获取连接池中的连接，通过调节线程数量来观察未获取到连接的情况。线程数、总获取次数、获取到的数量、未获取到的数量以及未获取到的比率，如表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/201905170157.png" alt="线程数量与连接获取的关系"></p><p>&emsp;从表中的数据统计可以看出，在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率不断升高。虽然客户端线程在这种超时获取的模式下会出现连接无法获取的情况，但是它能够保证客户端线程不会一直挂在连接获取的操作上，而是“按时”返回，并告知客户端连接获取出现问题，是系统的一种自我保护机制。数据库连接池的设计也可以复用到其他的资源获取的场景，针对昂贵资源（比如数据库连接）的获取都应该加以超时限制。</p><h1 id="线程池技术及其示例"><a href="#线程池技术及其示例" class="headerlink" title="线程池技术及其示例"></a><strong>线程池技术及其示例</strong></h1><h2 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>&emsp;对于服务端的程序，经常面对的是客户端传入的短小（执行时间短、工作内容较为单一）任务，需要服务端快速处理并返回结果。如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这在原型阶段是个不错的选择，但是面对成千上万的任务递交进服务器时，如果还是采用一个任务一个线程的方式，那么将会创建数以万记的线程，这不是一个好的选择。因为这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。</p><p>&emsp;线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。这样做的好处是，一方面，消除了频繁创建和消亡线程的系统资源开销，另一方面，面对过量任务的提交能够平缓的劣化。</p><h2 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a><strong>内容</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 增加工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 减少工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。除了execute(Job)方法以外，线程池接口提供了增大/减少工作者线程以及关闭线程池的方法。这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池最大限制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 线程池默认的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 线程池最小的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS    = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 工作者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line">    <span class="comment">// 工作者线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    <span class="comment">// 线程编号生成</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加一个工作，然后进行通知</span></span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="comment">// 限制新增的Worker数量不能超过最大值</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 按照给定的数量停止Worker</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.            incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否工作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span>    running    = <span class="keyword">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作者列表是空的，那么就wait</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                            <span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        <span class="comment">// 忽略Job执行中的Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;从线程池的实现可以看到，当客户端调用execute(Job)方法时，会不断地向任务列表jobs中 添加Job，而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态。</p><p>&emsp;添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够 确定有工作者线程被唤醒，这时使用notify()方法将会比notifyAll()方法获得更小的开销（避免将等待队列中的线程全部移动到阻塞队列中）。</p><p>&emsp;可以看到，线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。</p><h1 id="一个基于线程池技术的简单Web服务器"><a href="#一个基于线程池技术的简单Web服务器" class="headerlink" title="一个基于线程池技术的简单Web服务器"></a><strong>一个基于线程池技术的简单Web服务器</strong></h1><h2 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>&emsp;目前的浏览器都支持多线程访问，比如说在请求一个HTML页面的时候，页面中包含的图片资源、样式资源会被浏览器发起并发的获取，这样用户就不会遇到一直等到一个图片完全下载完成才能继续查看文字内容的尴尬情况。</p><p>&emsp;如果Web服务器是单线程的，多线程的浏览器也没有用武之地，因为服务端还是一个请求 一个请求的顺序处理。因此，大部分Web服务器都是支持并发访问的。常用的Java Web服务器，如Tomcat、Jetty，在其处理请求的过程中都使用到了线程池技术。</p><h2 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a><strong>内容</strong></h2><p>&emsp;下面通过使用前一节中的线程池来构造一个简单的Web服务器，这个Web服务器用来处理 HTTP请求，目前只能处理简单的文本和JPG图片内容。这个Web服务器使用main线程不断地接 受客户端Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处 理多个客户端请求，示例如代码所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleHttpServer</span> &#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;HttpRequestHandler&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span>(<span class="params"><span class="keyword">int</span> port</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span>(<span class="params">String basePath</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="literal">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).</span><br><span class="line">                isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>) throws Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span>(<span class="params">Socket socket</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            String line = <span class="literal">null</span>;</span><br><span class="line">            BufferedReader br = <span class="literal">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="literal">null</span>;</span><br><span class="line">            PrintWriter <span class="keyword">out</span> = <span class="literal">null</span>;</span><br><span class="line">            InputStream <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                <span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                <span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = <span class="keyword">in</span>.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath)));</span><br><span class="line">                    <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">out</span>.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">out</span>.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">out</span>.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                <span class="keyword">out</span>.println(<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">out</span>.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, <span class="keyword">in</span>, reader, <span class="keyword">out</span>, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span>(<span class="params">Closeable... closeables</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;该Web服务器处理用户请求的时序图如图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/201905170158.png" alt="SimpleHttpServer时序图"></p><p>&emsp;在图中，SimpleHttpServer在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成HttpRequestHandler并交由线程池处理。在线程池中的Worker处理客户端请求的同时，SimpleHttpServer能够继续完成后续客户端连接的建立，不会阻塞后续客户端的请求。</p><p>&emsp;接下来，通过一个测试对比来认识线程池技术带来服务器吞吐量的提高。我们准备了一个简单的HTML页面，内容如代码所示。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一张图片<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>  /&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第二张图片<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"2.jpg"</span>  /&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第三张图片<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"3.jpg"</span>  /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;将SimpleHttpServer的根目录设定到该HTML页面所在目录，并启动SimpleHttpServer，通过Apache HTTP server benchmarking tool（版本2.3）来测试不同线程数下，SimpleHttpServer的吞吐量表现。</p><p>&emsp;测试场景是5000次请求，分10个线程并发执行，测试内容主要考察响应时间（越小越好）和每秒查询的数量（越高越好），测试结果如表所示（机器CPU：i7-3635QM，内存为 8GB，实际输出可能与此表不同）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/201905170159.png" alt="测试结果"></p><p>&emsp;可以看到，随着线程池中线程数量的增加，SimpleHttpServer的吞吐量不断增大，响应时间不断变小，线程池的作用非常明显。</p><p>&emsp;但是，线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h1><p>&emsp;本章从介绍多线程技术带来的好处开始，讲述了如何启动和终止线程以及线程的状态，详细阐述了多线程之间进行通信的基本方式和等待/通知经典范式。在线程应用示例中，使用了等待超时、数据库连接池以及简单线程池3个不同的示例巩固本章前面章节所介绍的Java多线程基础知识。最后通过一个简单的Web服务器将上述知识点串联起来，加深我们对这些知识点的理解。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍线程实际应用：等待超时模式，数据库连接池，线程池技术及其示例，一个基于线程池技术的简单Web服务器。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信</title>
    <link href="http://linyishui.top/2019080901.html"/>
    <id>http://linyishui.top/2019080901.html</id>
    <published>2019-08-09T03:26:52.000Z</published>
    <updated>2019-09-10T07:35:14.487Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a><strong>线程间通信</strong></h1><p>&emsp;线程拥有自己的栈空间，线程并不是孤立的运行，除了公共区域，线程间也要进行协作。</p><h2 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a><strong>volatile和synchronized</strong></h2><p>&emsp;Java支持多个线程同时访问一个对象或者对象的成员变量，由于各个线程各自拥有拷贝，所以线程看到和处理的变量未必是最新值。</p><p>&emsp;关键字volatile可以保证线程访问变量的可见性，但会降低运行效率。而synchronized关键字保证了线程访问变量的可见性和排他性。</p><p>&emsp;synchronized锁同步块通过monitorenter和monitorexit指令，同步方法则是通过方法修饰符的ACC_SYNCHRONIZED来实现。无论是哪种方法，本质都是获取对象的监视器(monitor)，获取过程是排他的，只有一个线程可以拿到synchronized保护对象的监视器。</p><p>&emsp;更多内容可以参考<a href="../2019040201.html" title="Title">volatile</a>，<a href="../2019032701.html" title="Title">synchronized</a></p><hr><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a><strong>等待/通知机制</strong></h2><p>&emsp;”生产者”线程修改了一个对象的值，”消费者”线程会感知到变化，最简单的实现就是让消费者线程不断地循环检查变量是否符合预期，如下所示。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">while</span> (value != desire)&#123;<span class="comment">//满足条件则跳出循环</span></span><br><span class="line">    <span class="selector-tag">Thread</span><span class="selector-class">.sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">doSomething</span>();</span><br></pre></td></tr></table></figure><p>&emsp;但以上方式存在许多问题：1. 难以保证及时性，睡眠时间过长无法及时发现条件已修改，过短则会进行过多无效的尝试。2. 难以降低开销，通过降低睡眠时间会导致消耗更多的处理器资源。</p><p>&emsp;<strong>等待/通知机制</strong>则有效的解决了上述问题，并设计在Java的Object对象上。</p><p>&emsp;回顾一下Object的notify()和wait()方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知一个在对象上等待的线程，使其从wait()方法返回，返回的前提是该线程已获取了对象的锁</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知所有等待在该对象上的线程</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，在调用此方法后会释放对象的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待给定时间后若无通知，则超时返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;<strong>notify()</strong>：唤醒正在监听此对象的监视线程，同时多个线程等待时随机唤醒一个，选择是任意的可以由执行部分来决定，线程通过调用wait()等待对象，在当前线程放弃对象锁之前被唤醒的线程只能继续等待。唤醒的线程将和其它任意线程竞争并没有优先权力。</p><p>&emsp;<strong>wait()</strong> 使当前线程等待，直到它被唤醒，当前线程需要拥有此对象的监视器锁。此方法会将当前线程放入此对象的等待集合中，放弃在此对象上的同步声明(只是此对象的锁)，当线程等待时，所有可以同步此线程的任何其它对象都会保持锁定状态。(因为只能通过synchronized来获取监视器锁，所以这几个方法应该在同步代码块内调用，否则会抛出异常java.lang.IllegalMonitorStateException)</p><p>&emsp;出于线程调度的目的，线程将会被禁用，并处于休眠状态，直到被notify()任意选择中此线程唤醒，或其它线程调用notifyAll()唤醒，或其它线程调用interrupt()中断了当前线程，或指定的等待时间不为0且已到指定时间</p><p>&emsp;等待/通知机制就是指一个线程A调用了对象O的wait()进入等待状态，另一个线程B调用了对象O的notify()或notifyAll()，线程A收到通知后从对象O的wait()返回，进而执行后续操作，两个线程通过对象O作为中介进行交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(),<span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(),<span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//加锁，拥有lock的monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="comment">//当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">" flag is true. wait @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//条件满足时，完成工作</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" flag is false. running @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//加锁，拥有lock的monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="comment">//获取lock的锁，然后进行通知，通知时不会释放lock的锁</span></span><br><span class="line">                <span class="comment">//直到当前线程释放了lock后，WaitThread才能从wait()中返回</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock. notify @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再次加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="comment">//当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock again. sleep @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果如下。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[WaitThread,5,main]</span> <span class="selector-tag">flag</span> <span class="selector-tag">is</span> <span class="selector-tag">true</span>. <span class="selector-tag">wait</span> @ <span class="selector-tag">18</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:32</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[NotifyThread,5,main]</span> <span class="selector-tag">hold</span> <span class="selector-tag">lock</span>. <span class="selector-tag">notify</span> @ <span class="selector-tag">18</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:33</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[NotifyThread,5,main]</span> <span class="selector-tag">hold</span> <span class="selector-tag">lock</span> <span class="selector-tag">again</span>. <span class="selector-tag">sleep</span> @ <span class="selector-tag">18</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:38</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[WaitThread,5,main]</span> <span class="selector-tag">flag</span> <span class="selector-tag">is</span> <span class="selector-tag">false</span>. <span class="selector-tag">running</span> @ <span class="selector-tag">18</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:43</span></span><br></pre></td></tr></table></figure><ol><li>调用wait()，notify()和notifyAll()时，需要先对调用对象加锁。</li><li>调用wait()后，线程由RUNNING转为WAITING，并将当前线程放置到对象的等待队列。</li><li>notify()和notifyAll()调用后，等待线程依旧不会从wait()返回，需要等调用notify()和notifyAll()的线程释放锁后，等待线程才有机会从wait()返回</li><li>notify()方法将等待队列中的一个等待线程转移到同步队列中，而notifyAll()则将等待队列所有线程转移到同步队列中，被移动的线程状态由WAITING转为BLOCKED。</li><li>从wait()方法返回的前提是获取了调用对象的锁。</li></ol><p>&emsp;等待/通知机制依托于同步机制，目的就是确保等待线程从wait()返回时能够感知到通知线程对变量做出的修改。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/201905170156.png" alt="WaitNotify.java运行过程"></p><p>&emsp;WaitThread线程和NotifyThread线程模拟了线程间等待通知机制流程，WaitThread首先获取了对象的锁，然后调用了对象的wait()方法，从而放弃锁并进入对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行。</p><hr><h2 id="等待-通知机制的经典范式"><a href="#等待-通知机制的经典范式" class="headerlink" title="等待/通知机制的经典范式"></a><strong>等待/通知机制的经典范式</strong></h2><h3 id="等待方-消费者"><a href="#等待方-消费者" class="headerlink" title="等待方-消费者"></a><strong>等待方-消费者</strong></h3><blockquote><p>遵守如下原则</p><ol><li>获取对象的锁。</li><li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li><li>条件满足则执行对应的逻辑。</li></ol></blockquote><p>&emsp;伪代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="selector-tag">while</span>(条件不满足)&#123;</span><br><span class="line">        对象<span class="selector-class">.wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通知方-生产者"><a href="#通知方-生产者" class="headerlink" title="通知方-生产者"></a><strong>通知方-生产者</strong></h3><blockquote><p>遵守如下原则</p><ol><li>获取对象的锁。</li><li>改变条件。</li><li>通知所有等待在对象上的线程。</li></ol></blockquote><p>&emsp;伪代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span>(对象)&#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象<span class="selector-class">.notifyAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a><strong>管道输入/输出流</strong></h2><p>&emsp;管道输入/输出流和文件输入/输出流或者网络输入/输出流的不同在于它主要用于线程之间的数据传输，传输的媒介为内存。</p><ol><li>PipedOutputStream 面向字节</li><li>PipedInputStream 面向字节</li><li>PipedReader 面向字符</li><li>PipedWriter 面向字符</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Piped</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)throws Exception</span>&#123;</span><br><span class="line">        PipedWriter <span class="keyword">out</span> = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader <span class="keyword">in</span> = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">//将输入输出流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        <span class="keyword">out</span>.connect(<span class="keyword">in</span>);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(<span class="keyword">in</span>),<span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.<span class="keyword">in</span>.read()) != <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">out</span>.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">out</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Print</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader <span class="keyword">in</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span>(<span class="params">PipedReader <span class="keyword">in</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">in</span> = <span class="keyword">in</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = <span class="keyword">in</span>.read()) != <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//char转asc码</span></span><br><span class="line">                    System.<span class="keyword">out</span>.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果如下。main线程接收console的输入字符串，通过PipedWriter写入，然后PrintThread则通过PipedReader读出内容并打印。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>word</span><br><span class="line"><span class="keyword">test </span>word</span><br><span class="line">ok ok ok</span><br><span class="line">ok ok ok</span><br></pre></td></tr></table></figure><hr><h2 id="join"><a href="#join" class="headerlink" title="join()"></a><strong>join()</strong></h2><p>&emsp;当有线程A执行了thread.join()，表示线程A需要等待thread线程终止后才能从join()返回。等待前驱线程结束，接收前驱线程的结束通知即等待通知机制。</p><p>&emsp;更多内容请参考<a href="../2019051301.html" title="Title">Thread类源码剖析</a></p><hr><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><strong>ThreadLocal</strong></h2><p>&emsp;ThreadLocal，即线程变量，以ThreadLocal为键、以任意对象为值得存储结构。所以可以根据ThreadLocal给线程绑定值。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次get()调用会进行初始化(若没有调用set())，每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function">Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> System.<span class="title">currentTimeMillis</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function"><span class="keyword">long</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果如下。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Cost:</span> <span class="number">2001</span> mills</span><br></pre></td></tr></table></figure><p>&emsp;Profiler可以用来计算函数耗时，在函数调用前执行begin()，调用后执行end()，而且两次调用不用再一个方法或类内，比如AOP编程中，在调用前切入点执行begin()，在调用后切入点执行end()。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍线程间通信：volatile和synchronized，等待/通知机制，经典范式，管道输入/输出流，join()，ThreadLocal等
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
</feed>
