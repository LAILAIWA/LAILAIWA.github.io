<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2021-05-13T13:10:02.965Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>林沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="http://linyishui.top/2021051001.html"/>
    <id>http://linyishui.top/2021051001.html</id>
    <published>2021-05-10T13:27:05.000Z</published>
    <updated>2021-05-13T13:10:02.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是ZooKeeper？"><a href="#1-1-什么是ZooKeeper？" class="headerlink" title="1.1 什么是ZooKeeper？"></a>1.1 什么是ZooKeeper？</h3><ul><li>Apache ZooKeeper 由 Apache Hadoop 子项目发展而来。</li><li>ZooKeeper是一个开源的分布式协调服务，由雅虎创建，Google Chubby 的开源实现。</li><li>设计目标是将那些复杂易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</li><li>ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如<strong>统一命名服务</strong>、<strong>配置关联</strong>和<strong>分布式锁</strong>等分布式的基础服务。</li><li>ZooKeeper并没有直接采用 Paxos 算法，而是一种被称为 ZAB（ZooKeeper Atomic Broadcast）的一致性协议。</li></ul><p>ZooKeeper 是一个典型的分布式数据一致性的解决方案，应用可以基于它实现诸如<strong>数据发布/订阅</strong>、<strong>负载均衡</strong>、<strong>命名服务</strong>、<strong>分布式协调/通知</strong>、<strong>集群管理</strong>、<strong>Master选举</strong>、<strong>分布式锁</strong>和<strong>分布式队列</strong>等功能。</p><h3 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h3><ul><li><strong>顺序一致性：</strong>从同一客户端发起的事务请求，将会严格的按照发送顺序被应用到ZooKeeper中。</li><li><strong>原子性：</strong>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，要么整个集群所有机器都成功应用了某个事务，要么都没有应用。</li><li><strong>单一视图：</strong>无论客户端连接哪个ZooKeeper服务器，看到的服务端数据模型都是一致的。</li><li><strong>可靠性：</strong>一旦服务端成功应用了一个事务，并完成对客户端的响应，事务引起的服务端状态一直保留到下个事务进行变更。</li><li><strong>实时性：</strong>ZooKeeper仅保证在一定时间段内，客户端最终一定能够从服务端读取到最新的数据状态。</li></ul><h3 id="1-3-设计目标"><a href="#1-3-设计目标" class="headerlink" title="1.3 设计目标"></a>1.3 设计目标</h3><ol><li><strong>简单的数据模型：</strong>分布式程序通过一个共享的、树型结构的名字空间来相互协调</li><li><strong>可以构建集群：</strong>一般3~5台机器可以组成一个可用的ZooKeeper集群，每台机器都会在内存中维护当前的服务器状态，机器之间互相都保持着通信。ZooKeeper客户端会与任意一台机器创建一个TCP连接，一旦连接断开，客户端会自动连接到其他机器。</li><li><strong>顺序访问：</strong>ZooKeeper为客户端的每个更新请求分配一个全局唯一的递增编号，反映了事务操作的先后顺序。</li><li><strong>高性能：</strong>ZooKeeper将全量数据存储在内存中，直接服务于客户端的所有非事务请求，非常适合于读操作为主的场景。</li></ol><h3 id="1-4-核心概念"><a href="#1-4-核心概念" class="headerlink" title="1.4 核心概念"></a>1.4 核心概念</h3><ul><li><p><strong>集群角色：</strong></p><ul><li>最典型的集群模式是Master/Slave（主备模式），能够处理所有写操作的是Master机器，所有通过异步复制方式获取最新数据，并提供读服务的机器是Slave机器。</li><li>ZooKeeper并没有采用这种模式，而是引入了新的三个角色：<ul><li><strong>Leader：</strong>集群中所有机器通过选举过程选定一个Leader，其为客户端提供读和写服务。</li><li><strong>Follower：</strong>提供读服务。</li><li><strong>Observer：</strong>提供读服务，不参与Leader选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以在不影响写性能的情况下提高集群的读性能。</li></ul></li></ul></li><li><p><strong>会话（Session）：</strong></p><ul><li>在ZooKeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。</li><li>ZooKeeper对外的服务端口默认是2181，客户端启动时首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始，客户端通过这个连接进行心跳检测与服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接收响应，同时还能通过该连接接收服务器的Watch事件通知。</li><li>sessionTimeout值用来设置一个客户端会话的超时时间。因服务器压力过大、网络故障或客户端主动断开连接等导致的连接断开，只要在sessionTimeout规定时间内重新连上一台服务器，之前创建的会话仍会有效。</li></ul></li><li><p><strong>数据节点（ZNode）：</strong>分布式中节点即每台机器，在ZooKeeper中，节点分为两类：</p><ul><li><strong>机器节点：</strong>构成集群的机器</li><li><strong>数据节点：</strong>数据模型中的数据单元，即ZNode，又可以分为<ul><li><strong>持久节点：</strong>一旦此ZNode被创建，除非主动进行移除操作，否则将一直保存。</li><li><strong>临时节点：</strong>生命周期和客户端会话绑定，一旦客户端会话失效，该客户端创建的所有临时节点都会被移除。</li></ul></li></ul><p>数据模型是一棵树，由斜杠（<code>/</code>）进行分割的路径，就是一个ZNode，如 <code>/foo/path1</code> 。每个ZNode上都会保存自己的数据内容，以及一系列属性信息。</p><p>ZooKeeper允许用户为每个节点添加一个特殊的属性：SEQUENTIAL，当节点标记此属性，在节点创建时会自动在节点名后追加一个由父节点维护的自增整型数字。</p></li><li><p><strong>版本：</strong>ZooKeeper的每个ZNode都会维护一个叫做 <strong>Stat</strong> 的数据结构，Stat中记录了节点的三个数据版本：</p><ul><li>version：当前ZNode的版本</li><li>cversion：当前ZNode子节点的版本</li><li>aversion：当前ZNode的ACL版本</li></ul></li><li><p><strong>Watcher：</strong>即事件监听器，用户可以在指定节点上注册一些Watcher，在一些特定事件触发时，ZooKeeper服务端会将事件通知到感兴趣的客户端上。</p></li><li><p><strong>ACL：</strong>ZooKeeper采用 Access Control Lists 策略来进行权限控制，类似于UNIX文件系统的权限控制，定义了5种权限：</p><ul><li><strong>CREATE：</strong>创建子节点的权限</li><li><strong>READ：</strong>获取节点数据和子节点列表的权限</li><li><strong>WRITE：</strong>更新节点数据的权限</li><li><strong>DELETE：</strong>删除子节点的权限</li><li><strong>ADMIN：</strong>设置节点ACL的权限</li></ul></li></ul><h2 id="二-ZAB-协议"><a href="#二-ZAB-协议" class="headerlink" title="二. ZAB 协议"></a>二. ZAB 协议</h2><h3 id="2-1-什么是ZAB协议？"><a href="#2-1-什么是ZAB协议？" class="headerlink" title="2.1 什么是ZAB协议？"></a>2.1 什么是ZAB协议？</h3><p>ZooKeeper并没有完全采用 Paxos 算法，而是使用了一个称为 ZooKeeper Atomic Broadcast（ZAB，ZooKeeper<strong>原子消息广播协议</strong>）的协议来作为其数据一致性的核心算法。</p><p>ZAB协议是一种支持崩溃恢复的原子广播协议，最初只是为雅虎公司内部一些<strong>高吞吐量、低延迟、健壮、简单</strong>的分布式系统场景设计的，并不像Paxos算法那样通用和可扩展。</p><p>基于该协议，ZooKeeper实现了一种<strong>主备模式</strong>的系统架构来保持集群中各副本之间的数据一致性。ZooKeeper使用一个单一的主进程来接收并处理客户端所有的事务请求，通过ZAB的原子广播协议将服务器的数据状态以事务Proposal的形式广播到所有的副本进程。该主备模型保证了<strong>同一时刻集群中只能有一个主进程来广播服务器的状态变更</strong>，因此能够很好的处理客户端大量的并发请求。并且<strong>支持分布式环境中对于顺序状态的需求</strong>（有些状态变更必须依赖于比它早生成的状态变更），保证了一个全局的变更序列被顺序应用。因为主进程随时可能崩溃或重启，还要做到主进程有问题时仍能正常工作。</p><p>所有事务请求必须由一个全局唯一的服务器来协调处理，即Leader服务器，余下的服务器成为Follower服务器。Leader服务器负责将一个客户端事务请求转换为一个事务 Proposal（提议），并将该提议分发给集群中所有的Follower服务器。之后Leader服务器等待所有Follower服务器的反馈，一旦超过半数进行了正确的反馈，Leader服务器再次向所有的Follower服务器分发Commit消息，要求将前一个提议提交。</p><h3 id="2-2-协议介绍"><a href="#2-2-协议介绍" class="headerlink" title="2.2 协议介绍"></a>2.2 协议介绍</h3><p>ZAB协议包含两种基本模式：</p><ul><li><strong>崩溃恢复：</strong><ul><li>当整个服务框架在启动过程，或是Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB进入该模式选举产生新的Leader服务器。</li><li>选出新的Leader，且集群中已有过半的机器与新的Leader完成状态同步（指数据同步，用来保证过半机器与Leader保持一致）之后，ZAB退出该模式。</li></ul></li><li><strong>消息广播：</strong><ul><li>集群中有过半的Follower服务器完成了与Leader服务器的状态同步，服务框架进入该模式。</li><li>当一台遵守ZAB协议的服务器启动并加入集群时，若此时已存在Leader服务器，它会自觉的进入数据恢复模式：找到Leader所在服务器，并与其进行数据同步，然后一起参与到消息广播流程中。</li></ul></li></ul><h4 id="（1）消息广播"><a href="#（1）消息广播" class="headerlink" title="（1）消息广播"></a>（1）消息广播</h4><p>消息广播的过程类似于二阶段提交：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200111.png" alt></p><p>ZAB没有中断逻辑，所以Follower服务器反馈Ack后就可以提交事务Proposal，这种简化模型自然存在Leader单点故障引起的数据不一致问题。ZAB协议通过崩溃恢复模式来解决这个问题。</p><p>整个消息广播协议基于具有FIFO特性的TCP协议来进行网络通信，很容易保证消息接收和发送的顺序性。Leader为每个事务Proposal分配一个全局单调递增的事务ID（ZXID），每个事务按照ZXID的先后顺序进行排序和处理。</p><p>Leader服务器为每个Follower服务器各自分配一个队列，将需要广播的事务Proposal依次放入队列中，根据FIFO的策略进行消息发送。每个Follower服务器收到事务Proposal后，首先以事务日志的形式写入到本地磁盘中，在成功写入后反馈给Leader一个Ack响应。收到超过半数的Ack响应后，Leader会广播一个Commit消息给所有Follower服务器以通知进行事务提交，同时Leader完成自己的事务提交。</p><h4 id="（2）崩溃恢复"><a href="#（2）崩溃恢复" class="headerlink" title="（2）崩溃恢复"></a>（2）崩溃恢复</h4><p>进入崩溃恢复模式后，需要选举出一个新的Leader服务器，这需要一个高效且可靠的选举算法，不仅需要让新Leader自己知道已被选举为Leader，还要让集群中所有机器快速感知到这点。</p><p><strong>ZAB协议要确保那些已经在Leader服务器上提交的事务最终被所有服务器提交。</strong></p><p>假设一个事务已在Leader服务器提交，但在将Commit消息发送给所有Follower之前，Leader挂掉了：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200112.png" alt></p><p><strong>ZAB协议要确保丢弃那些只在Leader服务器上被提出的事务。</strong></p><p>相反，在崩溃恢复过程中出现一个需要被丢弃的提案，在崩溃恢复结束后需要跳过该事务Proposal：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200113.png" alt></p><p>针对以上两点，如果Leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号（ZXID）的事务Proposal，就可以保证新选举出的Leader一定具有所有已经提交的提案，还可以省区Leader服务器检查Proposal的提交和丢弃工作这一步。</p><p>完成Leader选举后，在正式工作前，Leader服务器首先要确认事务日志中所有的Proposal是否都已经被集群中过半的机器提交了，即<strong>是否完成数据同步</strong>。</p><ul><li>Leader为每个Follower准备一个队列，将没有被各Follower同步的事务以Proposal消息的形式逐个发送给Follower，并每个都跟着发送一个Commit消息。</li><li>等到所有Follower都将其尚未同步的事务Proposal从Leader上同步过来并成功应用到本地数据库后，Leader将该Follower加如到真正可用的Follower列表，并开始之后流程。</li></ul><p><strong>如何处理需要丢弃的事务Proposal？</strong></p><p>ZXID时一个64位的数字，低32位可以看作简单的递增计数器，高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader服务器，就会从Leader上取出其本地日志中最大事务Proposal的ZXID，解析出epoch值并加1，将此编号作为新的epoch，并将低32位置0。</p><p>这样可以区分开不同的Leader周期变化，从而避免不同的Leader服务器错误的使用相同的ZXID提出不同的事务Proposal。</p><p>当一个包含了上个周期尚未提交的事务Proposal的服务器启动时，其肯定无法成为Leader。因为当前集群一定包含一个Quorum集合，集合中的机器一定包含了更高epoch的事务Proposal，因此该机器肯定非最高编号事务。当其连接上Leader后，Leader根据自己记录的最后被提交的Proposal对比，并要求Follower进行一个回退操作—回退到一个确实已经被集群过半机器提交的最新的事务Proposal（如上图4-4 Server1连接后，会被要求去除P3）。</p><h3 id="2-3-深入剖析"><a href="#2-3-深入剖析" class="headerlink" title="2.3 深入剖析"></a>2.3 深入剖析</h3><p>未完待续…</p><h4 id="（1）-系统模型"><a href="#（1）-系统模型" class="headerlink" title="（1） 系统模型"></a>（1） 系统模型</h4><h4 id="（2）-问题描述"><a href="#（2）-问题描述" class="headerlink" title="（2） 问题描述"></a>（2） 问题描述</h4><h4 id="（3）-算法描述"><a href="#（3）-算法描述" class="headerlink" title="（3） 算法描述"></a>（3） 算法描述</h4><h4 id="（4）-运行分析"><a href="#（4）-运行分析" class="headerlink" title="（4） 运行分析"></a>（4） 运行分析</h4><h3 id="2-4-ZAB与Paxos算法的异同"><a href="#2-4-ZAB与Paxos算法的异同" class="headerlink" title="2.4 ZAB与Paxos算法的异同"></a>2.4 ZAB与Paxos算法的异同</h3><ul><li>二者都存在一个Leader进程角色，负责协调多个Follower进程的运行。</li><li><p>Leader进程都会等待超过半数的Follower进程正确反馈后，才会将提案提交。</p></li><li><p>ZAB协议中标识Leader周期的epoch值，Paxos算法中叫Ballot。</p></li></ul><p>二者的本质区别在于设计目标不同，ZAB协议用于构建一个高可用的分布式数据主备系统，而Paxos算法则用于构建一个分布式的一致性状态机系统。</p><h2 id="三-简单使用"><a href="#三-简单使用" class="headerlink" title="三. 简单使用"></a>三. 简单使用</h2><h3 id="3-1-部署与运行"><a href="#3-1-部署与运行" class="headerlink" title="3.1 部署与运行"></a>3.1 部署与运行</h3><p>ZooKeeper使用Java语言编写，所以需要1.6以上版本的Java环境。ZooKeeper包含集群和单机两种运行模式。</p><h4 id="（1）部署"><a href="#（1）部署" class="headerlink" title="（1）部署"></a>（1）部署</h4><ol><li><p>下载安装包并解压：<code>http:zookeeper.apache.org/releases.html</code></p></li><li><p>配置文件 <code>zoo.cfg</code> ：</p><p><code>%ZK_HOME%/conf</code> 目录下 <code>zoo_sample.cfg</code> 重命名为 <code>zoo.cfg</code> </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tickTime=2000</span></span><br><span class="line"><span class="string">dataDir=/var/lib/zookeeper/</span></span><br><span class="line"><span class="string">clientPort=2181</span></span><br><span class="line"><span class="string">initLimit=5</span></span><br><span class="line"><span class="string">syncLimit=2</span></span><br><span class="line"><span class="comment"># server.id=host:port:port 用来感知集群由哪些机器构成，id表示机器序号，dataDir目录下需要有一个myid文件，内容为一个数字对应此id</span></span><br><span class="line"><span class="string">server.1=&lt;IP1&gt;:2888:3888</span></span><br><span class="line"><span class="string">server.2=&lt;IP2&gt;:2888:3888</span></span><br><span class="line"><span class="string">server.3=&lt;IP3&gt;:2888:3888</span></span><br></pre></td></tr></table></figure><ul><li>集群模式下所有cfg文件都应是一致的，最好使用代码仓库管理起来。</li><li>id取值范围为 ：1~255。</li></ul></li><li><p>创建 <code>myid</code> 文件，在dataDir指定目录下，内容为数字id</p></li><li><p>为所有机器配置2和3步内容</p></li><li><p>启动服务器：使用 <code>%ZK_HOME%/bin</code> 目录下的 <code>zkServer.sh</code> 脚本启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh zkServer.sh start</span></span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.4.3/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li><li><p>验证服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> telnet 127.0.0.1 2181</span></span><br><span class="line">stat</span><br></pre></td></tr></table></figure></li></ol><p>单机模式与集群模式只是在 <code>zoo.cfg</code> 的配置上有些差异，<code>server.id</code> 只有一项 <code>server.1</code> 。</p><h4 id="（2）运行和停止"><a href="#（2）运行和停止" class="headerlink" title="（2）运行和停止"></a>（2）运行和停止</h4><p>启动服务：</p><ul><li>Java命令行：在 <code>%ZK_HOME%</code> 目录下执行命令 <code>java -cp zookeeper -3.4.3 jar:lib/ slf4j-api-1.6. 1. jar:lib/slf4j- log4j12-1.6.1.jar:lib/log4j-1.2.15.jar:conf org. apache. zookeeper. server.quorum.QuorumPeerMain conf/zoo.cfg</code> 注意log4j和slf4j版本</li><li>自带的启动脚本</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200114.png" alt></p><p>停止服务：<code>sh zkServer.sh stop</code></p><h4 id="（3）常见异常"><a href="#（3）常见异常" class="headerlink" title="（3）常见异常"></a>（3）常见异常</h4><ul><li><strong>端口被占用：</strong><code>java.net.BindException: Address already in use</code> 异常是因为2181端口被其他进程占用，关闭对应进程并重启ZK即可。</li><li><strong>磁盘没有剩余空间：</strong><code>java.io.IOException: No space left on device</code> 遇到此异常，ZK会立即执行Failover策略，从而退出进程。清理磁盘空间，为了避免后续再次遇到此问题，最好加上对ZK服务器磁盘使用的监控和ZK日志的自动清理。</li><li><strong>无法找到 <code>myid</code> 文件：</strong>缺少此文件，创建即可。</li><li><strong>集群中其他机器Leader选举端口未开：</strong> <code>Cannot open channel to 2 at election adress /xx.xx.xx.xx:3888</code> 这是由于启动过程中，虽然当前机器启动了，但其他机器还未启动完。ZK使用3888端口进行Leader选举过程的投票通信。</li></ul><h3 id="3-2-客户端脚本"><a href="#3-2-客户端脚本" class="headerlink" title="3.2 客户端脚本"></a>3.2 客户端脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入bin目录，确认是否连接上ZK服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sh zkCli.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接指定ZK服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sh zkCli.sh -server ip:port</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个ZK节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s或e分别指定节点特性顺序或临时节点，不加则默认为持久节点；acl进行权限控制，默认不加控制</span></span><br><span class="line">create [-s] [-e] path data acl</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在根节点下创建一个叫/zk-book的节点，内容为123</span></span><br><span class="line">create /zk-book 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls列出ZK指定节点下所有子节点</span></span><br><span class="line">ls path [watch]</span><br><span class="line">ls /</span><br><span class="line"><span class="meta">#</span><span class="bash"> get命令获取指定节点的数据内容和属性信息</span></span><br><span class="line">get path [watch]</span><br><span class="line">get /zk-book</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新指定节点的数据内容，version参数指定本次更新基于ZNode哪个数据版本进行</span></span><br><span class="line">set path data [version]</span><br><span class="line">set /zk-book 456</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除，要删除节点，其不能包含子节点</span></span><br><span class="line">delete path [version]</span><br></pre></td></tr></table></figure><h2 id="四-Java客户端API使用"><a href="#四-Java客户端API使用" class="headerlink" title="四. Java客户端API使用"></a>四. Java客户端API使用</h2><h3 id="4-1-创建会话"><a href="#4-1-创建会话" class="headerlink" title="4.1 创建会话"></a>4.1 创建会话</h3><p>通过构建一个ZooKeeper对象来创建会话，这是一个异步过程，构造函数会在处理完客户端初始化后立即返回，此时会话处于CONNECTING状态。会话真正创建完毕后，服务端向客户端发送一个事件通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数API</span></span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher);</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly);</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd);</span><br><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200115.png" alt></p><p>实例代码如图：重写了process方法负责处理收到的Watcher通知，收到服务端发送的SyncConnected事件后，解除主程序在CountDownLatch上的等待阻塞。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200116.png" alt></p><p>复用sessionId，维持之前会话：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200117.png" alt></p><h3 id="4-2-创建节点"><a href="#4-2-创建节点" class="headerlink" title="4.2 创建节点"></a>4.2 创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步创建节点</span></span><br><span class="line"><span class="function">String <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], List&lt;ACL&gt; acl, CreateMode createMode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], List&lt;ACL&gt; acl, CreateMode createMode, StringCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p>ZooKeeper节点内容只支持字节数组类型（byte[]），即ZooKeeper不负责为节点内容进行序列化，需要开发人员自己使用序列化工具操作。</p><p>默认不需要关注权限参数，只需在acl中传入 <code>Ids.OPEN_ACL_UNSAFE</code> ，表示不受权限控制。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200118.png" alt></p><p>创建同步节点，分别创建临时节点和临时顺序节点，二者返回值不一样。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200119.png" alt></p><p>创建异步节点，只需要实现 <code>AsyncCallback.StringCallback()</code> 接口即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200120.png" alt></p><p>AsyncCallback包括七种不同的回调接口：</p><ul><li>StatCallback</li><li>DataCallback</li><li>ACLCallback</li><li>ChildrenCallback</li><li>Children2Callback</li><li>StringCallback</li><li>VoidCallback</li></ul><p>同步接口调用过程需要关注抛出异常的可能，异步接口本身不抛出异常，素有异常都在回调函数中通过响应码（Result Code）体现。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200121.png" alt></p><h3 id="4-3-删除节点"><a href="#4-3-删除节点" class="headerlink" title="4.3 删除节点"></a>4.3 删除节点</h3><p>ZooKeeper只允许删除叶子节点，即如果节点存在子节点就无法被直接删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">int</span> version, VoidCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200122.png" alt></p><h3 id="4-4-读取数据"><a href="#4-4-读取数据" class="headerlink" title="4.4 读取数据"></a>4.4 读取数据</h3><h4 id="（1）getChildren"><a href="#（1）getChildren" class="headerlink" title="（1）getChildren"></a>（1）getChildren</h4><p>获取一个节点下的所有子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watcher)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, ChildrenCallback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, ChildrenCallback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, Stat stat)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, Children2Callback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, Children2Callback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200123.png" alt></p><p>当有子节点被添加或删除时，服务端会向客户端发送一个 <code>NodeChildrenChanged(EventType.NodeChildrenChanged)</code> 类型的事件通知。要注意该通知不包含最新的节点列表，客户端必须主动重新获取。</p><p>使用同步接口获取子节点列表：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200124.png" alt></p><p>注意，Watcher通知是一次性的，一旦触发一次通知，该Watcher就失效了，因此客户端需要反复注册Watcher。</p><p>使用异步接口获取子节点列表：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200125.png" alt></p><p>异步接口经常被应用在这样的使用场景：应用启动时获取一些配置信息，如“机器列表”，这些配置通常较大，并且不希望配置的获取影响应用的主流程。</p><h4 id="（2）getData"><a href="#（2）getData" class="headerlink" title="（2）getData"></a>（2）getData</h4><p>获取一个节点的数据内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] getData(String path, <span class="keyword">boolean</span> watcher, Stat stat);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, DataCallback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, DataCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200126.png" alt></p><p>当节点的状态发生变更，ZooKeeper服务端向客户端发送一个 <code>NodeDataChanged(EventType.NodeDataChanged)</code> 的事件通知。节点的数据内容和数据版本变化都被看作是节点的变化。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200127.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200128.png" alt></p><h3 id="4-5-更新数据"><a href="#4-5-更新数据" class="headerlink" title="4.5 更新数据"></a>4.5 更新数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stat <span class="title">setData</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, StatCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200129.png" alt></p><p><code>getData</code> 读取数据接口并未提供根据指定数据版本来获取数据的接口，<code>setData</code> 此处的version类似于CAS比较并交换原理，对应预期值表示针对此版本更新，这样在一个客户端读取并修改中间其他客户端的修改会使这次修改无效，从而避免并发问题。</p><p>分别使用不同的version进行了三次更新操作：数据版本从0开始，-1非合法的数据版本，这里用来告诉服务端，客户端要基于最新版本进行更新操作。第三次操作使用了之前的数据版本1所以导致更新失败。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200130.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200131.png" alt></p><h3 id="4-6-检测节点是否存在"><a href="#4-6-检测节点是否存在" class="headerlink" title="4.6 检测节点是否存在"></a>4.6 检测节点是否存在</h3><p>检测节点是否存在，返回一个stat对象，当节点被创建、被删除或数据被更新会通过Watcher通知客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watcher)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, StatCallback cb, Object ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watcher, StatCallback cb, Object ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200132.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200133.png" alt></p><p>上述示例中，先后进行了如下操作：</p><ol><li>通过exists接口检测是否存在指定节点，同时注册了一个Watcher。</li><li>创建节点/zk-book，此时服务端马上会向客户端发送一个事件通知：NodeCreated。客户端收到该事件通知后，再次调用exists接口，同时注册Watcher。</li><li>更新该节点的数据，这个时候，服务端又会向客户端发送一个事件通知：NodeDataChanged。客户端收到该事件通知后，继续调用exists接口，同时注册Watcher。</li><li>创建子节点/zk-book/c1。</li><li>删除子节点/zk-book/c1。</li><li>删除节点/zk-book。此时客户端会收到服务端的事件通知：NodeDeleted。</li></ol><p>综上所述，可以得知：</p><ul><li>无论指定节点是否存在，通过调用exists接口都可以注册Watcher。</li><li>exists接口中注册的Watcher，能够对节点创建、节点删除和节点数据更新事件进行监听。</li><li>对于指定节点的子节点的各种变化，都不会通知客户端。</li></ul><h3 id="4-7-权限控制"><a href="#4-7-权限控制" class="headerlink" title="4.7 权限控制"></a>4.7 权限控制</h3><p>集群模式下的ZooKeeper，不同的应用之间往往是不会存在共享数据的使用场景的，因此需要解决不同应用之间的权限问题。</p><p>通过设置服务端上数据节点的ACL，来控制客户端对该节点的访问权限。ZooKeeper提供了多种权限控制模式：</p><ul><li>world</li><li>auth</li><li>digest：主要讲解该模式</li><li>ip</li><li>super</li></ul><p>客户端在会话创建后，调用 <code>addAuthInfo(String scheme, byte[] auth)</code> 接口进行权限信息的设置：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200134.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200135.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200136.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200137.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200138.png" alt></p><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      简单整理了ZooKeeper相关知识，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="zookeeper" scheme="http://linyishui.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://linyishui.top/2021042101.html"/>
    <id>http://linyishui.top/2021042101.html</id>
    <published>2021-04-21T13:27:05.000Z</published>
    <updated>2021-05-13T08:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="一-从ACID到CAP-BASE"><a href="#一-从ACID到CAP-BASE" class="headerlink" title="一. 从ACID到CAP/BASE"></a>一. 从ACID到CAP/BASE</h2><h3 id="1-1-ACID"><a href="#1-1-ACID" class="headerlink" title="1.1 ACID"></a>1.1 ACID</h3><p>数据库事务和ACID可以参看：<a href="2020120801.html">《高性能MySQL》（一）架构和历史</a> 中事务章节。</p><h3 id="1-2-什么是分布式事务"><a href="#1-2-什么是分布式事务" class="headerlink" title="1.2 什么是分布式事务"></a>1.2 什么是分布式事务</h3><p>分布式数据库中，数据分散在不同的机器上，分布式事务中事务的参与者、支持事务的服务器、资源服务器以及事务管理器可能分别位于不同的节点上。</p><p>思考如何实现分布式的事务处理？</p><p>首先我们要把分布式事务看作一组分布式的操作序列，即一组子事务，所以分布式事务也具有ACID的事务特性。</p><p>实现分布式事务，保证数据的严格一致性时必然要牺牲掉部分系统可用性。</p><h3 id="1-3-CAP"><a href="#1-3-CAP" class="headerlink" title="1.3 CAP"></a>1.3 CAP</h3><p>CAP理论：一个分布式系统不可能同时满足<strong>一致性</strong>（Consistency）、<strong>可用性</strong>（Availability）和<strong>分区容错性</strong>（Partition tolerance），最多同时满足其中两项。</p><ul><li>一致性：分布式中指数据在多个副本间能否保持一致。对一个数据更新且执行成功后，所有用户都要能读到最新的值。</li><li>可用性：系统服务必须一直处于可用的状态，用户的每个操作请求总是能在<strong>有限的时间</strong>内<strong>返回结果</strong>。系统存在一个合理的响应时间，否则就会使用户对系统失望。</li><li>分区容错性：分布式系统在遇到任何网络分区故障时，仍要保证对外提供满足一致性和可用性的服务。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200102.png" alt></p><p>对于分布式系统来说，分区容错性是一个最基本的要求，因为分布式必然要把组件部署到不同的节点，网络问题必定会出现，所以架构设计师往往需要把精力花在如何根据业务特点在一致性和可用性之间寻求平衡。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200101.png" alt></p><h3 id="1-4-BASE理论"><a href="#1-4-BASE理论" class="headerlink" title="1.4 BASE理论"></a>1.4 BASE理论</h3><p>BASE 是 <strong>Basically Available（基本可用），Soft state（软状态）和 Eventually consistent（最终一致性）</strong>，是对CAP中一致性和可用性权衡的结果，核心思想是即使无法做到强一致性（Strong consistency），每个应用都可以根据自身业务特点采用适当的方式来使系统最终一致性（Eventual consistency）。</p><p><strong>基本可用</strong>，指分布式系统在出现不可预知的故障时，允许损失部分可用性，但这不等价于系统不可用：</p><ul><li><strong>响应时间上的损失</strong>：如正常情况下，搜索引擎要在0.5秒内返回给用户查询结果，但由于故障导致响应时间增加到1到2秒。</li><li><strong>功能上的损失</strong>：如正常情况下，消费者能在商城平台顺利完成每一笔订单，但在一些节日购物高峰为了保证系统稳定，部分消费者可能被引导到一个降级页面。</li></ul><p><strong>弱状态</strong>：也叫软状态，指允许系统中的数据存在中间状态，并认为该中间状态的存在不影响系统整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程出现延时。</p><p><strong>最终一致性</strong>：系统中所有的数据副本，经过一段时间的同步后，最终能够达到一个一致的状态。最终一致性的5种变种：</p><ul><li><strong>因果一致性（Causial consistency）：</strong>进程A在更新完某个数据后通知了进程B，进程B能读取到A更新后的最新值，如果B要对数据进行更新要基于此最新值，即不能发生丢失更新的情况；而与此无关的进程C无此限制。</li><li><strong>读己之所写（Read your writes）：</strong>进程A更新一个数据后，自己总能访问更新后的最新值，是一种特殊的因果一致性。</li><li><strong>会话一致性（Session consistency）：</strong>系统保证在同一个有效的会话中实现读己之所写的一致性。</li><li><strong>单调读一致性（Monotonic read consistency）：</strong>如果一个进程从系统中读出一个数据后，系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li><li><strong>单调写一致性（Monotonic write consistency）：</strong>系统保证来自同一个进程的写操作被顺序的执行。</li></ul><p>现代的关系型数据库中，往往会采用同步和一步的方式来实现主备数据复制技术：</p><ul><li>同步方式：数据的复制过程通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。</li><li>异步方式：备库的更新往往存在延时，取决于事务日志在主备数据库之间传输的时间长短，如果时间过久或传输中出现异常导致无法及时将事务应用到备库，就会导致数据不一致。</li></ul><p>BASE理论不同于传统事务ACID的强一致性模型，提出牺牲强一致性来获得可用性，允许数据在一段时间内不一致，但最终达到一致性状态。</p><h2 id="二-一致性协议"><a href="#二-一致性协议" class="headerlink" title="二. 一致性协议"></a>二. 一致性协议</h2><p>有很多的经典的一致性协议和算法来解决分布式一致性问题，最著名的有<strong>二阶段提交协议</strong>、<strong>三阶段提交协议</strong>和<strong>Paxos算法</strong>。</p><h3 id="2-1-二阶段提交-2PC"><a href="#2-1-二阶段提交-2PC" class="headerlink" title="2.1 二阶段提交-2PC"></a>2.1 二阶段提交-2PC</h3><p>2PC，即二阶段提交，Two-Phase Commit 的缩写，为了使分布式系统下所有的节点在进行事务处理过程中能保持<strong>原子性</strong>和<strong>一致性</strong>而设计的算法。目前大部分关系型数据库都采用2PC来完成分布式事务处理。</p><p>执行流程：</p><ul><li><strong>阶段一：提交事务请求</strong>（也叫投票阶段）<ol><li><strong>事务询问：</strong>协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，等待各参与者响应。</li><li><strong>执行事务：</strong>各参与者执行事务操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志。</li><li><strong>各参与者向协调者反馈事务询问的响应：</strong>参与者成功执行了事务操作，反馈给协调者Yes响应，表示事务可以执行；若未执行成功，反馈No。</li></ol></li><li><strong>阶段二：执行事务提交</strong>（所有参与者都反馈Yes，进行阶段二）<ol><li><strong>发送提交请求：</strong>协调者向所有参与者节点发出 <code>Commit</code> 请求。</li><li><strong>事务提交：</strong>参与者收到 <code>Commit</code> 请求，正式执行事务提交操作，在完成提交后释放事务资源。</li><li><strong>反馈事务提交结果：</strong>参与者在完成事务提交之后，向协调者发送 <code>Ack</code> 消息。</li><li><strong>完成事务：</strong>协调者收到所有参与者的 <code>Ack</code> 消息后，完成事务。</li></ol></li><li><strong>中断事务：</strong>当某个参与者反馈了No响应、或等待接收所有参与者反馈超时之后，执行中断事务<ol><li><strong>发送回滚请求：</strong>协调者向所有参与者节点发出 <code>Rollback</code> 请求。</li><li><strong>事务回滚：</strong>参与者接收到 <code>Rollback</code> 请求后，利用其在阶段一中记录的 <code>Undo</code> 信息来执行事务回滚操作，并释放事务占用资源。</li><li><strong>反馈事务回滚结果：</strong>参与者完成回滚后，向协调者发送 <code>Ack</code> 消息。</li><li><strong>中断事务：</strong>协调者收到所有参与者反馈的 <code>Ack</code> 消息后，完成事务中断。</li></ol></li></ul><p>2PC的核心是每个事务都采用<strong>先尝试后提交</strong>的处理方式，可以看作一个强一致性算法。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200104.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200105.png" alt></p><p>优缺点：</p><ul><li>优点：原理简单，实现方便。</li><li>缺点：同步阻塞、单点问题、脑裂、太过保守<ul><li><strong>同步阻塞：</strong>在二阶段的提交过程，所有参与该事务操作的逻辑都处于阻塞状态，各个参与者在等待其他参与者响应的过程无法进行其他操作。</li><li><strong>单点问题：</strong>协调者太过重要，一旦出现问题整个流程就无法运作，如果是在阶段二出现问题，更会导致参与者都处于锁定事务资源的状态。</li><li><strong>数据不一致：</strong>在阶段二执行事务提交时，当协调者向所有参与者发生Commit请求后，发生局部网络异常或是协调者自身未发送完即崩溃，导致只有部分参与者收到了Commit请求。收到的提交事务，未收到的无法提交，出现数据不一致现象。</li><li><strong>太过保守：</strong>参与者出现故障而导致协调者始终无法获取到所有响应，此时只能依靠协调者自身的超时机制来判断是否需要中断事务，显得过于保守，没有完善的容错机制，导致一个节点的失败导致整个事务失败。</li></ul></li></ul><h3 id="2-2-三阶段提交-3PC"><a href="#2-2-三阶段提交-3PC" class="headerlink" title="2.2 三阶段提交-3PC"></a>2.2 三阶段提交-3PC</h3><p>3PC，即三阶段提交，Three-Phase Commit的缩写，针对2PC的缺陷进行了优化，将2PC的提交事务请求过程一分为2。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200106.png" alt></p><p>执行阶段：</p><ul><li><strong>阶段一：CanCommit</strong><ol><li><strong>事务询问：</strong>协调者向所有参与者发送一个包含事务内容的 <code>canCommit</code> 请求，询问是否可以执行事务提交操作，并开始等待各参与者响应。</li><li><strong>各参与者向协调者反馈事务询问的响应：</strong>参与者接收到 <code>canCommit</code> 请求后，若判断自己可以顺利执行事务则反馈Yes响应，并进入预备状态，否则反馈No响应。</li></ol></li><li><strong>阶段二：PreCommit</strong><ul><li><strong>执行事务预提交：</strong>协调者收到所有Yes反馈<ol><li><strong>发送预提交请求：</strong>协调者向所有参与者发送一个包含事务内容的 <code>preCommit</code> 请求，并进入 <code>Prepared</code> 阶段。</li><li><strong>事务预提交：</strong>参与者接收到 <code>preCommit</code> 请求后，执行事务操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志。</li><li><strong>各参与者向协调者反馈事务执行的响应：</strong>参与者成功执行了事务操作，反馈给协调者 <code>Ack</code> 响应，同时等待最终指令（commit或abort）。</li></ol></li><li><strong>中断事务：</strong>任意一个参与者反馈了No响应、或等待超时后仍未收到所有参与者的反馈响应<ol><li><strong>发送中断请求：</strong>协调者向所有参与者发送 <code>abort</code> 请求。</li><li><strong>中断事务：</strong>无论是收到协调者的 <code>abort</code> 请求，或是等待协调者请求超时，参与者都会中断事务。</li></ol></li></ul></li><li><strong>阶段三：doCommit</strong><ul><li><strong>执行提交：</strong>协调者处于正常状态，且收到了所有参与者的 <code>Ack</code> 响应<ol><li><strong>发送提交请求：</strong>协调者将从预提交状态转换为提交状态，并向所有参与者发送 <code>doCommit</code> 请求。</li><li><strong>事务提交：</strong>参与者收到 <code>doCommit</code> 请求，正式执行事务提交操作，完成提交后释放事务资源。</li><li><strong>反馈事务提交结果：</strong>参与者完成事务提交后，向协调者发送 <code>Ack</code> 消息。</li><li><strong>完成事务：</strong>协调者收到所有参与者的 <code>Ack</code> 消息后，完成事务。</li></ol></li><li><strong>中断事务：</strong>协调者处于正常状态，且有任一的参与者反馈了No响应，或者等待超时后仍未收到所有参与者响应<ol><li><strong>发送中断请求：</strong>协调者向所有参与者发送 <code>abort</code> 请求。</li><li><strong>事务回滚：</strong>参与者接收到 <code>abort</code> 请求后，利用其在阶段二中记录的 <code>Undo</code> 信息来执行事务回滚操作，并释放事务占用资源。</li><li><strong>反馈事务回滚结果：</strong>参与者完成回滚后，向协调者发送 <code>Ack</code> 消息。</li><li><strong>中断事务：</strong>协调者收到所有参与者反馈的 <code>Ack</code> 消息后，完成事务中断。</li></ol></li></ul></li></ul><p>进入阶段三后可能会出现两种故障：</p><ul><li>协调者出现问题</li><li>协调者和参与者之间网络出现故障</li></ul><p>最终都会导致参与者无法及时收到 <code>doCommit</code> 请求或 <code>abort</code> 请求，这时参与者会在等待超时后继续进行事务提交。</p><p>优缺点：</p><ul><li>优点：相较2PC降低了参与者的阻塞范围，能够在出现单点故障后达成一致。</li><li>缺点：3PC在去除阻塞的同时也带来了新问题，就是在参与者收到 <code>preCommit</code> 请求后，如果网络出现分区，这时协调者所在的节点和参与者无法进行正常的网络通信，这个参与者仍会进行事务的提交，导致了数据不一致性。</li></ul><h3 id="2-3-Paxos-算法"><a href="#2-3-Paxos-算法" class="headerlink" title="2.3 Paxos 算法"></a>2.3 Paxos 算法</h3><p>Paxos 算法由 Leslie Lamport 于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题的最有效算法之一。Paxos 算法解决了分布式系统中发生任何的机器宕机或网络异常，都不会破坏整个系统的一致性。</p><p>Paxos算法支持分布式节点角色之间的轮换，避免了分布式单点的出现，既解决了无限期等待问题，也解决了脑裂问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拜占庭将军问题：</span><br><span class="line"></span><br><span class="line">拜占庭帝国有多支军队，不同军队的将军之间需要制定一个统一的行动计划，从而做出进攻或撤退的决定，各个将军在地理上被分割开，只能依靠通讯员进行联络。通讯员中可能存在叛徒，可以任意的篡改消息。</span><br></pre></td></tr></table></figure><p>理论上来说，在异步系统和不可靠通道上来达到一致性状态是不可能的，因此往往假设信道是可靠的。现实中，大部分系统都部署在同一个局域网，消息被篡改的情况比较罕见；硬件或网络原因导致的消息不完整问题，只需一套简单的校验算法即可避免。因此实际工程实践中，可以假设不存在拜占庭将军问题，我们需要什么样的算法来保证一致性？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">古希腊有一个叫 Paxos 的小岛，岛上采用议会的形式来通过法令，议员间通过信使进行消息的传递，议员或信使都是兼职的，随时可能离开议会厅，信使可能会重复的传递消息，也可能一去不回。议会协议要保证在这种情况下仍能正确的产生法令，并且不出现冲突。</span><br></pre></td></tr></table></figure><p>Paxos算法的核心是一个一致性算法，即 Lamport 的论文 The Part-Time Parliament 中提到的 synod 算法。</p><h4 id="2-3-1-问题描述"><a href="#2-3-1-问题描述" class="headerlink" title="2.3.1 问题描述"></a>2.3.1 问题描述</h4><p>对于一个一致性算法来说要保证几点：</p><ul><li>在这些被提出的提案中，只有一个会被选定。</li><li>如果没有提案被提出，就不会有被选定的提案。</li><li>当一个提案被选定后，进程应该可以获取被选定的提案信息。</li></ul><p>一致性的安全性需求：（Paxos的目标就是保证最终有一个提案被选定）</p><ul><li>只有被提出的提案才能被选定。</li><li>只能有一个值被选定。</li><li>如果某个进程认为某个提案被选定了，这个提案必须是真的被选定的那个。</li></ul><p>在该一致性算法中，有三种参与角色：Proposer（提议人）、Acceptor（接收人）和 Learner ，一个进程可能充当不只一种角色，假设不同参与者之间可以通过收发消息来进行通信：</p><ul><li>每个参与者以任意的速度执行，可能会因为出错而停止，也可能会重启。即使一个提案被选定后，所有参与者也有可能失败或重启，因此除非失败或重启的参与者可以记录某些信息，否则将无法确定最终的值。</li><li>消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被损坏，即消息内容不会被篡改。</li></ul><h4 id="2-3-2-提案的选定"><a href="#2-3-2-提案的选定" class="headerlink" title="2.3.2 提案的选定"></a>2.3.2 提案的选定</h4><p>选定一个唯一提案，最简单的方案是只允许一个 Acceptor 存在，Proposer 只能发送提案给它，Acceptor 选择它接收到的第一个提案，这种方案存在单点故障。</p><p>存在多个 Acceptor ：Proposer 向一个 Acceptor 集合发送提案，集合中每个 Acceptor 都可能会批准该提案，当有足够多的 Acceptor 批准这个提案时，就可以认为它被选定了。</p><h4 id="2-3-3-推导过程"><a href="#2-3-3-推导过程" class="headerlink" title="2.3.3 推导过程"></a>2.3.3 推导过程</h4><p>需求：在没有失败和消息丢失的情况下，即使只有一个提案被提出，也要选出一个提案。</p><p>这就意味着<strong>P1：一个 Acceptor 必须批准它收到的第一个提案</strong>。这可能会导致每个 Acceptor 都批准了第一个提案，但没有一个提案是多数人批准的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200107.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200108.png" alt></p><p>一个提案需要由半数以上的 Acceptor 批准的需求暗示着<strong>一个 Acceptor 必须能够批准不止一个提案</strong>。</p><p>Paxos 使用一个<strong>全局编号</strong>来唯一标识每一个被 Acceptor 批准的提案，当一个具有某 Value 值的提案被半数以上的 Acceptor 批准后，即该 Value 被选定了和该提案被选定了。提案变成了一个由编号和 Value 组成的组合体 “【编号, Value】”。</p><p><strong>P2：如果编号为M~0~、Value值为V~0~的提案被选定了，那么所有比编号M~0~更高的，且被选定的（被 Acceptor 批准的）提案，其Value值必须也是V~0~</strong></p><p>通信是异步的，一个提案可能会在某个 Acceptor 还未收到任何提案时就被选定了，所以仍需要P1来保证提案会被选定。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200109.png" alt></p><p><strong>P2b：如果一个提案[M~0~, V~0~]被选定后，那么之后任何 Proposer 产生的编号更高的提案，其Value值必须也是V~0~</strong></p><p>因为一个提案必须在被 Proposer 提出后才能被 Acceptor 批准，所以P2b包含P2。</p><h4 id="2-3-4-数学归纳法证明"><a href="#2-3-4-数学归纳法证明" class="headerlink" title="2.3.4 数学归纳法证明"></a>2.3.4 数学归纳法证明</h4><p>需要证明结论：<strong>假设某个提案[M~0~, V~0~]被选定了，证明任何编号M~n~&gt;M~0~的提案，其Value值都是V~0~</strong>。</p><p>我们可以通过对M~n~进行第二数学归纳法进行证明，即证明：<strong>假设编号在M~0~到M~n-1~之间的提案，其Value值都是V~0~，证明编号为M~n~的提案的Value值也为V~0~</strong>。</p><p>因为M~0~的提案已被选定，意味着肯定存在一个由半数以上的 Acceptor 组成的集合C，都批准了提案。<strong>C中的每个 Acceptor 都批准了在M~0~到M~n-1~范围内的提案，并且每个编号在M~0~到M~n-1~之间的被批准的提案，其Value值都是V~0~</strong>。</p><p>因为任何包含半数以上的 Acceptor 组成的集合都至少包含一个C的成员，所以如果保持下面P2c的不变性，可以认为编号为M~n~的提案的Value值也为V~0~。</p><p><strong>P2c：对于任意的M~n~和V~n~，如果提案[M~n~, V~n~]被提出，那么肯定存在一个由半数以上的 Acceptor 组出的集合S，满足以下两个两个条件中的任意一个：</strong></p><ul><li>要么，S中不存在任何批准过编号小于M~n~的提案的 Acceptor。</li><li>要么，选取S中所有 Acceptor 批准的编号小于 M~n~ 的提案，其中编号最大的哪个提案其 Value 值是 V~n~ 。</li></ul><p>P2c=&gt;P2b=&gt;P2，通过P2和P1保证一致性。</p><p>假设提案[M~0~, V~0~]被选定了，需要证明在P2c的前提下，对于所有的[M~n~, V~n~]，存在 V~n~ = V~0~ ：（第二数学归纳法）</p><ol><li>当 M~n~ = M~0~ + 1 时，因为[M~0~, V~0~]被选定了，一定会存在一个 Acceptor 的子集S，S中的 Acceptor 已批准了小于 M~n~ 的提案，因此 V~n~ 只能是S中编号小于  M~n~ 但为最大编号的提案。因为 M~n~ = M~0~ + 1 ，所以提案是 [M~0~, V~0~] ；同时由于S和通过[M~0~, V~0~]的集合都是多数集，所以二者一定存在交集，这样 Proposer 在确定 V~n~ 取值时一定会选择 V~0~ 。</li><li>编号在 M~0~ + 1 到 M~n~ - 1 之间的Value值都为 V~0~ ，要证明编号为 M~n~ 的提案的Value值也为 V~0~ 。根据P1c，一定会存在一个 Acceptor 的子集S，S中的 Acceptor 已批准了小于 M~n~ 的提案，那么编号为 M~n~ 的提案的Value值只能是S中编号小于 M~n~ 但为最大编号的提案的值。只要编号落在 M~0~ + 1 到 M~n~ - 1 之间，那么Value值就是 V~0~ ；如果不落在区间内，那肯定是 M~0~ ，因为S肯定会和批准[M~0~, V~0~]的集合有交集，如果编号为 M~0~ ，那么其Value值也为 V~0~ 。</li></ol><h4 id="2-3-5-Proposer-生成提案"><a href="#2-3-5-Proposer-生成提案" class="headerlink" title="2.3.5 Proposer 生成提案"></a>2.3.5 Proposer 生成提案</h4><p>对于 Proposer 来说，获取已经被通过的提案远比预测未来可能被通过的提案简单。因此 <strong>Proposer 在产生一个编号为 M~n~ 的提案时，必须要知道当前一个将要或已经被半数以上 Acceptor 批准的编号小于 M~n~ 的最大提案编号。并且 Proposer 会要求所有 Acceptor 不再批准任何编号小于 M~n~ 的提案</strong>。  </p><p><strong>提案生成算法</strong>：</p><ol><li>Proposer 选择一个新的提案编号 M~n~ ，然后向某个 Acceptor 集合的成员发送请求（即编号为 M~n~ 的提案的 Prepare 请求），要求该集合中的 Acceptor 做出如下回应。<ul><li>向 Proposer 承诺，保证不再批准任何编号小于 M~n~ 的提案。</li><li>如果 Acceptor 已经批准过任何提案，那么其就向 Proposer 反馈当前该 Acceptor 已经批准的编号小于 M~n~ 但为最大编号的那个提案的值。</li></ul></li><li>如果 Proposer 收到了来自半数以上的 Acceptor 的响应结果，那么它可以产生编号为 M~n~ 、Value值为 V~n~ 的提案，V~n~ 是所有响应中编号最大的提案的 Value 值。还有一种情况，即半数以上都未批准过任何提案，也即响应中不包含任何提案，此时 V~n~ 值可以由 Proposer 任意选择。</li></ol><p>Proposer 发送给 Acceptor 选定的提案期望获得批准的请求叫Accept请求。接受请求的 Acceptor 集合不一定是之前响应Prepare请求的那一个。</p><h4 id="2-3-6-Acceptor-批准提案"><a href="#2-3-6-Acceptor-批准提案" class="headerlink" title="2.3.6 Acceptor 批准提案"></a>2.3.6 Acceptor 批准提案</h4><p>一个 Acceptor 可能接收到两种来自 Proposer 的请求：</p><ul><li><strong>Prepare请求：</strong>Acceptor 可以在任何时候响应。</li><li><strong>Accept请求：</strong>在不违背Accept现有承诺的前提下，任意响应Accept请求。</li></ul><p><strong>P1a：一个 Acceptor 只要尚未响应过任何编号大于 M~n~ 的Prepare请求，它就可以接受这个编号为 M~n~ 的提案。</strong></p><h4 id="2-3-7-算法优化"><a href="#2-3-7-算法优化" class="headerlink" title="2.3.7 算法优化"></a>2.3.7 算法优化</h4><p>假设一个 Acceptor 收到了一个编号为 M~n~ 的Prepare请求，但此时它已经对大于 M~n~ 的Prepare请求做出了响应，因此它肯定不会再批准编号 M~n~ 的提案，所以 Acceptor 没有必要对此请求做出响应，可以选择忽略这种Prepare请求。同理还可以忽略已经批准过的提案的Prepare请求。</p><p>这样 Acceptor 只需记住它已经批准的提案的最大编号和它已经做出Prepare请求响应的提案的最大编号，以便再出现故障或节点重启时也能保证P2c的不变性。</p><p>对于 Proposer 来说，只要保证不会产生相同编号的提案，可以丢弃任意提案和运行时状态信息。</p><h4 id="2-3-8-算法陈述"><a href="#2-3-8-算法陈述" class="headerlink" title="2.3.8 算法陈述"></a>2.3.8 算法陈述</h4><p>综上所述，可以得到一个类似二阶段提交的算法执行过程：</p><ul><li>阶段一<ol><li>Proposer 选择一个提案编号 M~n~ ，然后向 Acceptor 的某个超过半数的子集成员发送编号为 M~n~ 的Prepare请求。</li><li>如果一个 Acceptor 收到一个编号为 M~n~ 的Prepare请求，且编号 M~n~ 大于它已经响应的所有Prepare请求的编号，那么它会将它已经批准过的最大编号的提案作为响应反馈给 Proposer ，同时承诺不会再批准小于编号 M~n~ 的任何提案。</li></ol></li><li>阶段二<ol><li>如果 Proposer 收到来自半数以上的 Acceptor 对于其发出的编号为 M~n~ 的Prepare请求的响应，它就会发送一个针对[M~n~, V~n~]提案的 Accept 请求给 Acceptor （ V~n~ 为收到的响应中编号最大的提案的值，若响应中不包含提案，它可以是任意值）。</li><li>如果 Acceptor 收到此 Accept 请求，只要该 Acceptor 尚未对编号大于 M~n~ 的Prepare请求做出响应，它就可以通过这个提案。</li></ol></li></ul><h4 id="2-3-9-提案的获取"><a href="#2-3-9-提案的获取" class="headerlink" title="2.3.9 提案的获取"></a>2.3.9 提案的获取</h4><p>Learner 获取提案的几种方案：</p><ol><li>Learner 获取提案的前提是此提案已被半数以上的 Acceptor 批准。因此最简单的做法是一旦 Acceptor 批准了提案，就把其发送给所有的 Learner 。这种做法会让每个 Acceptor 与所有的 Learner 通信，通信次数至少为二者个数的乘积。</li><li>让所有的 Acceptor 对提案的批准情况统一发送给一个<strong>主Learner</strong>，主Learner 被通知一个提案已被选定后会负责通知其他 Learner 。此方案通过多加一个步骤，大大减少了通信次数，但带来了主Learner可能发生故障这个隐患。</li><li>针对方案二，将主Learner扩大为特定的Learner集合，从而提高可靠性。</li></ol><h4 id="2-3-10-通过选取主Proposer保证算法的活性"><a href="#2-3-10-通过选取主Proposer保证算法的活性" class="headerlink" title="2.3.10 通过选取主Proposer保证算法的活性"></a>2.3.10 通过选取主Proposer保证算法的活性</h4><p>Paxos算法可能会出现多个Proposer相互导致对方提案请求被忽略的死循环：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200110.png" alt></p><p>解决方案：选定一个主Proposer，并规定只有主Proposer才能提出议案。</p><p><strong>基于Best Efforts 1PC模式的事务</strong>，参考spring-data-neo4j的实现。鉴于Best Efforts 1PC模式的性能优势，以及相对简单的实现方式，它被大多数的sharding框架和项目采用</p><p><strong>事务补偿（幂等值）</strong></p><p>对于那些对性能要求很高，但对一致性要求并不高的系统，往往并不苛求系统的实时一致性，只要在一个允许的时间周期内达到最终一致性即可，这使得事务补偿机制成为一种可行的方案。事务补偿机制最初被提出是在“长事务”的处理中，但是对于分布式系统确保一致性也有很好的参考意义。笼统地讲，与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查并补救的措施，它只期望在一个容许时间周期内得到最终一致的结果就可以了。事务补偿的实现与系统业务紧密相关，并没有一种标准的处理方式。一些常见的实现方式有：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步，等等。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24036067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24036067</a></p><p>事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</p><p>复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。</p></blockquote><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由。</p><ol><li>利用数据库自增ID和UUID</li></ol><p>优点：最简单。</p><p>缺点：单点风险、单机性能瓶颈。</p><blockquote><p>使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p></blockquote><ol start="2"><li>结合数据库维护一个Sequence表</li></ol><p>此方案的思路也很简单，在数据库中建立一个Sequence表，表的结构类似于：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`SEQUENCE`</span> (  </span><br><span class="line">    <span class="symbol">`table_name`</span> varchar(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="symbol">`nextid`</span> bigint(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`table_name`</span>)  </span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><p>每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应表的nextid,并将nextid的值加1后更新到数据库中以备下次使用。此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。有人提出使用Master-Slave进行主从同步，但这也只能解决单点问题，并不能解决读写比为1:1的访问压力问题。</p><ol start="3"><li>利用数据库集群并设置相应的步长（Flickr方案）</li></ol><p>优点：高可用、ID较简洁。</p><p>缺点：需要单独的数据库集群。</p><ol start="4"><li>Twitter Snowflake</li></ol><p>优点：高性能高可用、易拓展。</p><p>缺点：需要独立的集群以及ZK。</p><blockquote><p><a href="http://blog.sina.com.cn/s/blog_6b7c2e660102vbi2.html" title="Title" target="_blank" rel="noopener">Twitter的分布式自增ID算法Snowflake</a></p><p>在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt;*</span> <span class="number">10</span><span class="bullet">---0000000000</span> <span class="number">0000000000</span> <span class="number">0000000000</span> <span class="number">0000000000</span> <span class="number">0</span> <span class="meta">---</span> <span class="number">00000</span> <span class="bullet">---00000</span> <span class="bullet">---000000000000</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。</p><p>这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。</p></blockquote><ol start="5"><li>一大波GUID、Random算法</li></ol><p>优点：简单。</p><p>缺点：生成ID较长，有重复几率。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24036067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24036067</a> 博主团队采用的策略是：时间戳+用户标识码+随机数</p><p>优点有：</p><ul><li><p>方便、成本低。</p></li><li><p>基本无重复的可能。</p></li><li><p>自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订</p></li><li><p>单号尽可能的短一些，并且评估下来四位已经足够。</p></li><li><p>可排序，因为时间戳在最前面。</p></li></ul><p>当然也有一些缺点，比如长度稍长，性能要比int/bigint的稍差等。</p></blockquote><p><a href="https://www.cnblogs.com/mayundalao/p/11798502.html" target="_blank" rel="noopener">分布式事务的四种解决方案</a></p><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      简单整理了分布式事务相关知识，内容包括：ACID到CAP/BASE，2PC二阶段提交，3PC三阶段提交，Paxos算法等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="transaction" scheme="http://linyishui.top/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://linyishui.top/2021042001.html"/>
    <id>http://linyishui.top/2021042001.html</id>
    <published>2021-04-20T13:26:57.000Z</published>
    <updated>2021-05-13T08:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p>我们先了解一下什么叫幂等？在分布式应用中，幂等是非常重要的，也就是相同条件下对一个业务的操作，不管操作多少次，结果都是一样。</p><p>为什么要有幂等这种场景？因为在大的系统中，都是分布式部署，如：订单业务 和 库存业务有可能都是独立部署的，都是单独的服务。用户下订单，会调用到订单服务和库存服务。</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/ee6b8a81617a444fb8bac512ee7d3ebd?from=pc" alt="海量订单产生的业务高峰期，如何避免消息的重复消费？"></p><p>因为分布式部署，很有可能在调用库存服务时，因为网络等原因，订单服务调用失败，但其实库存服务已经处理完成，只是返回给订单服务处理结果时出现了异常。这个时候一般系统会作补偿方案，也就是订单服务再此放起库存服务的调用,库存减1.</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="built_in">count</span> = <span class="built_in">count</span> <span class="number">-1</span> <span class="keyword">where</span> good_id=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样就出现了问题，其实上一次调用已经减了1，只是订单服务没有收到处理结果。现在又调用一次，又要减1，这样就不符合业务了，多扣了。</p><p>幂等这个概念就是，不管库存服务在相同条件下调用几次，处理结果都一样。这样才能保证补偿方案的可行性。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="乐观锁方案"><a href="#乐观锁方案" class="headerlink" title="乐观锁方案"></a>乐观锁方案</h3><p>借鉴数据库的乐观锁机制，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">count</span> = <span class="keyword">count</span> <span class="number">-1</span> , <span class="keyword">version</span> = <span class="keyword">version</span> + <span class="number">1</span> <span class="keyword">where</span> good_id=<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</p><h3 id="唯一ID-指纹码"><a href="#唯一ID-指纹码" class="headerlink" title="唯一ID + 指纹码"></a>唯一ID + 指纹码</h3><p>原理就是利用数据库主键去重，业务完成后插入主键标识</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> t_check <span class="keyword">where</span> <span class="keyword">ID</span>=唯一<span class="keyword">ID</span> + 指纹码</span><br></pre></td></tr></table></figure><ul><li>唯一ID就是业务表的唯一的主键，如商品ID</li><li>指纹码就是为了区别每次正常操作的码，每次操作时生成指纹码；可以用时间戳+业务编号的方式。</li></ul><p>上面的sql语句：</p><ul><li>返回如果为0 表示没有操作过，那业务操作后就可以insert into t_check(唯一ID+指纹码)</li><li>返回如果大于0 表示操作过，就直接返回</li></ul><p>好处：实现简单</p><p>坏处：高并发下数据库瓶颈</p><p>解决方案：根据ID进行分库分表进行算法路由</p><h3 id="redis原子操作"><a href="#redis原子操作" class="headerlink" title="redis原子操作"></a>redis原子操作</h3><p>利用redis的原子操作，做个操作完成的标记。这个性能就比较好。但会遇到一些问题。</p><p>第一：我们是否需要把业务结果进行数据落库，如果落库，关键解决的问题时数据库和redis操作如何做到原子性？</p><blockquote><p>这个意思就是库存减1了，但redis进行操作完成标记时，失败了怎么办？也就是一定要保证落库和redis 要么一起成功，要么一起失败</p></blockquote><p>第二：如果不进行落库，那么都存储到缓存中，如何设置定时同步策略？</p><blockquote><p>这个意思就是库存减1，不落库，直接先操作redis操作完成标记，然后由另外的同步服务进行库存落库，这个就是增加了系统复杂性，而且同步策略如何设置</p></blockquote><ul><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/zhishixingqiu/%3Fzhihu" target="_blank" rel="noopener">《Java 2019 超神之路》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Dubbo/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Dubbo 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Spring/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Spring 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/MyBatis/good-collection/%3Fzhihu" target="_blank" rel="noopener">《MyBatis 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Spring-MVC/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Spring MVC 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Spring-Boot/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Spring Boot 实现原理与源码解析 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Entity/good-collection/%3Fzhihu" target="_blank" rel="noopener">《数据库实体设计合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Interview/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Java 面试题 —— 精品合集》</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iocoder.cn/Interview/good-collection/%3Fzhihu" target="_blank" rel="noopener">《Java 学习指南 —— 精品合集》</a></li></ul><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      简单整理了分布式锁相关知识，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性</title>
    <link href="http://linyishui.top/2021041901.html"/>
    <id>http://linyishui.top/2021041901.html</id>
    <published>2021-04-19T13:26:49.000Z</published>
    <updated>2021-05-13T08:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h1><h2 id="一-引文"><a href="#一-引文" class="headerlink" title="一. 引文"></a>一. 引文</h2><h3 id="1-1-什么是并发？"><a href="#1-1-什么是并发？" class="headerlink" title="1.1 什么是并发？"></a>1.1 什么是并发？</h3><p>并发：当逻辑控制流（一次程序操作，如读取或更新内存变量的值）在时间上重叠，那它就是并发的。</p><p>一般并发都特指更新操作的并发，即有多个线程同时更新内存中变量的值。</p><h3 id="1-2-数据复制延时问题"><a href="#1-2-数据复制延时问题" class="headerlink" title="1.2 数据复制延时问题"></a>1.2 数据复制延时问题</h3><p>数据复制一般会有延时问题，即无法及时读取到更新后的最新数据。</p><h3 id="1-3-分布式一致性问题"><a href="#1-3-分布式一致性问题" class="headerlink" title="1.3 分布式一致性问题"></a>1.3 分布式一致性问题</h3><p>分布式系统一般采用数据复制都是基于两类需求：</p><ul><li>增加系统的可用性，防止单点故障引起的系统不可用；</li><li>提供系统整体性能，通过负载均衡技术，让分布在不同位置的数据副本都为用户提供服务。</li></ul><p><strong>分布式一致性问题</strong>：在<strong>分布式环境</strong>引入<strong>数据复制机制</strong>后，不同数据节点间可能出现的，并无法依靠应用程序自身解决的<strong>数据不一致情况</strong>。</p><p><strong>数据一致性</strong>：指对一个副本数据进行更新的同时，必须确保能够更新其他的副本。</p><h3 id="1-4-如何解决一致性问题？"><a href="#1-4-如何解决一致性问题？" class="headerlink" title="1.4 如何解决一致性问题？"></a>1.4 如何解决一致性问题？</h3><p>既然是由于延时引起的问题，可以将写入的动作阻塞，直到数据复制完成后，才完成写入动作。</p><p>这样能解决问题，但带来了新的问题：<strong>写入的性能很差</strong>。后续的写请求都要阻塞在前一个请求的写操作上，不适用于有大量写请求的场景。</p><p>所以我们需要在保证数据一致性和不影响系统运行的性能间做一个权衡，从而划分出<strong>一致性级别</strong>：</p><ul><li>强一致性：系统写入什么，读出来就是什么，会对性能有较大影响。</li><li>弱一致性：系统写入成功后不保证可以立刻读到写入的值，只尽可能的保证在某个时间级别（如秒级别）后，数据能达到一致性状态，细分：<ul><li>会话一致性：只保证对于写入的值，在同一个客户端会话中可以读取到一致的值，其他会话不能保证。</li><li>用户一致性：只保证对于写入的值，在同一个用户中可以读取到一致的值，其他用户不能保证。</li></ul></li><li>最终一致性：特殊的弱一致性，非常重要的一种一致性模型。</li></ul><p>接下来引入几种典型的分布式一致性协议，学习它们是如何解决分布式一致性问题。</p><p>## </p><hr><p>参考：</p><p>🔗 《从Paxos到Zookeeper-分布式一致性原理与实践》</p>]]></content>
    
    <summary type="html">
    
      简单整理了分布式一致性相关知识，内容包括：引文等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="consistency" scheme="http://linyishui.top/tags/consistency/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（未完成）</title>
    <link href="http://linyishui.top/2021031501.html"/>
    <id>http://linyishui.top/2021031501.html</id>
    <published>2021-03-15T13:57:00.000Z</published>
    <updated>2021-05-13T08:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是动态规划？"><a href="#1-1-什么是动态规划？" class="headerlink" title="1.1 什么是动态规划？"></a>1.1 什么是动态规划？</h3><p><strong>动态规划</strong>（英语：Dynamic Programming，简称DP）是一种<strong>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</strong>。常常适用于<strong>有重叠子问题</strong>和<strong>最优子结构</strong>（Optimal substructure）性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>在20世纪50年代初，由美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：<strong>一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表</strong>。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><h3 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h3><p>在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法 [4] 。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有<a href="https://baike.baidu.com/item/最优值" target="_blank" rel="noopener">最优值</a>的解。动态规划算法与<a href="https://baike.baidu.com/item/分治法" target="_blank" rel="noopener">分治法</a>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从<a href="https://baike.baidu.com/item/这些子" target="_blank" rel="noopener">这些子</a>问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式 [5] 。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>多阶段决策问题</strong></li></ul><p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题 [6] 。</p><p>各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果 [6] 。</p><ul><li><strong>动态规划问题中的术语</strong></li></ul><p><a href="https://baike.baidu.com/item/阶段" target="_blank" rel="noopener">阶段</a>：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的 [6] 。</p><p><a href="https://baike.baidu.com/item/状态" target="_blank" rel="noopener">状态</a>：状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点 [6] 。</p><p><a href="https://baike.baidu.com/item/无后效性" target="_blank" rel="noopener">无后效性</a>：我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性 [6] 。</p><p><a href="https://baike.baidu.com/item/决策" target="_blank" rel="noopener">决策</a>：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称<a href="https://baike.baidu.com/item/决策变量" target="_blank" rel="noopener">决策变量</a>，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史 [6] 。</p><p>决策变量的范围称为允许决策集合 [6] 。</p><p><a href="https://baike.baidu.com/item/策略" target="_blank" rel="noopener">策略</a>：由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合 [6] 。</p><p>允许策略集合中达到最优效果的策略称为最优策略 [6] 。</p><p>给定k阶段状态变量x(k)的值后，如果这一阶段的决策变量一经确定，第k+1阶段的状态变量x(k+1)也就完全确定，即x(k+1)的值随x(k)和第k阶段的决策u(k)的值变化而变化，那么可以把这一关系看成(x(k)，u(k))与x(k+1)确定的对应关系，用x(k+1)=Tk(x(k),u(k))表示。这是从k阶段到k+1阶段的状态转移规律，称为状态转移方程 [6] 。</p><p>最优化原理：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略” [6] 。</p><p>最优性原理实际上是要求问题的最优策略的子策略也是最优 [6] 。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>多阶段决策问题中，各个阶段采取的<a href="https://baike.baidu.com/item/决策" target="_blank" rel="noopener">决策</a>，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法 [7] 。</p><h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性 [8] 。</p><ul><li><strong><a href="https://baike.baidu.com/item/最优化原理" target="_blank" rel="noopener">最优化原理</a>**</strong>（最优子结构性质）**</li></ul><p>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质 [8] 。</p><ul><li><strong><a href="https://baike.baidu.com/item/无后效性" target="_blank" rel="noopener">无后效性</a></strong></li></ul><p>将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性 [8] 。</p><ul><li><strong>子问题的重叠性</strong></li></ul><p>动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间</p><h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><p>动态规划在查找有很多<strong>重叠子问题</strong>的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p><p>动态规划只能应用于有<strong>最优子结构</strong>的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p><p>适用情况：</p><ul><li><p><strong>最优子结构性质</strong>：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p></li><li><p><strong>无后效性</strong>：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p></li><li><strong>子问题重叠性质</strong>：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。</li></ul><h3 id="1-3-动态规划与记忆化搜索"><a href="#1-3-动态规划与记忆化搜索" class="headerlink" title="1.3 动态规划与记忆化搜索"></a>1.3 动态规划与记忆化搜索</h3><p><a href="https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp</a></p><h2 id="二-算法"><a href="#二-算法" class="headerlink" title="二. 算法"></a>二. 算法</h2><h3 id="2-1-DP的两种实现方式"><a href="#2-1-DP的两种实现方式" class="headerlink" title="2.1 DP的两种实现方式"></a>2.1 DP的两种实现方式</h3><ul><li>递归实现</li><li>记忆化搜索</li></ul><h3 id="2-2-DP常用来解决的问题"><a href="#2-2-DP常用来解决的问题" class="headerlink" title="2.2 DP常用来解决的问题"></a>2.2 DP常用来解决的问题</h3><ul><li>切割钢条问题</li><li>Floyd最短路问题</li><li>最大不下降子序列</li><li>矩阵链乘</li><li>凸多边形三角剖分</li><li>0-1背包</li><li>最长公共子序列</li><li>最优二分搜索树</li></ul><h3 id="2-3-使用动态规划的算法"><a href="#2-3-使用动态规划的算法" class="headerlink" title="2.3 使用动态规划的算法"></a>2.3 使用动态规划的算法</h3><ul><li>最长公共子序列</li><li>Floyd-Warshall算法</li><li>Viterbi算法</li><li>求解马可夫决策过程下最佳策略</li></ul><h3 id="2-4-实现原理"><a href="#2-4-实现原理" class="headerlink" title="2.4 实现原理"></a>2.4 实现原理</h3><ul><li><strong>基本思想：</strong>问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题<strong>有较多的重复出现</strong>，则可以<strong>自底向上</strong>从最终子问题向原问题逐步求解。</li><li>使用条件：<strong>可分为多个相关子问题，子问题的解被重复使用</strong><ul><li>Optimal substructure（优化子结构）：<ul><li>一个问题的优化解包含了子问题的优化解</li><li>缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性</li><li>我们可以自下而上的</li></ul></li><li>Subteties（重叠子问题）：在问题的求解过程中，很多子问题的解将被多次使用。</li></ul></li><li>动态规划算法的设计步骤：<ul><li>分析优化解的结构</li><li>递归地定义最优解的代价</li><li>自底向上地计算优化解的代价保存之，并获取构造最优解的信息</li><li>根据构造最优解的信息构造优化解</li></ul></li><li>动态规划特点：<ul><li>把原始问题划分成一系列子问题；</li><li>求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间</li><li>自底向上地计算。</li><li>整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解）</li></ul></li></ul><h2 id="三-算法题"><a href="#三-算法题" class="headerlink" title="三. 算法题"></a>三. 算法题</h2><p>动态规划等价于记忆化搜索，学习深度优先搜索和记忆化搜索，方便快速理解动态规划</p><p>解决DP算法问题，写出记忆化搜索的递归函数，列出方程后，可以用数学方法，魔改优化。</p><h3 id="3-1-背包问题"><a href="#3-1-背包问题" class="headerlink" title="3.1 背包问题"></a>3.1 背包问题</h3><p>背包问题作为NP完全问题，暂时不存在多项式时间算法。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有贪心法等，分数背包问题有最优贪心解等。 背包问题具有最优子结构和重叠子问题。动态规划一般用于求解背包问题中的整数背包问题（即每种物品所选的个数必须是整数）。 </p><p>解整数背包问题： 设有n件物品，每件价值记为 P~i~ ，每件体积记为 V~i~ ，用一个最大容积为 V~max~ 的背包，求装入物品的最大价值。 用一个数组 f[i,v] 表示取i件商品填充一个容积为v的背包的最大价值，显然问题的解就是 f[n,V~max~] 。</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81" alt="{\displaystyle f[i,v]={\begin{cases}f[i-1,v],v&lt;V_{i}\\\max\{f[i-1,v],f[i-1,v-V_{i}]+P_{i}\},v\geq V_{i}\\0,iv=0\\\end{cases}}}"></p><p>对于特例0-1背包问题（即每件物品最多放1件，否则不放入）的问题，状态转移方程：</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81" alt="{\displaystyle f[i,v]={\begin{cases}f[i-1,v],v&lt;V_{i}\\\max\{f[i-1,v],f[i-1,v-V_{i}]+P_{i}\},v\geq V_{i}\\0,iv=0\\\end{cases}}}"></p><h3 id="3-2-切割钢条问题"><a href="#3-2-切割钢条问题" class="headerlink" title="3.2 切割钢条问题"></a>3.2 切割钢条问题</h3><p>（1）剑指14-剪绳子1</p><p>此案例中动态规划效率要低于贪心解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剪绳子1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），</span></span><br><span class="line"><span class="comment"> * 每段绳子的长度记为 k[0],k[1]...k[m-1] 。</span></span><br><span class="line"><span class="comment"> * 请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？</span></span><br><span class="line"><span class="comment"> * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 2</span></span><br><span class="line"><span class="comment"> * 输出: 1</span></span><br><span class="line"><span class="comment"> * 解释: 2 = 1 + 1, 1 × 1 = 1</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 10</span></span><br><span class="line"><span class="comment"> * 输出: 36</span></span><br><span class="line"><span class="comment"> * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2 &lt;= n &lt;= 58</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 数学</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz14CuttingRope1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">2</span>));</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 剪了第一段后，剩下(i - j)长度可以剪也可以不剪。</span></span><br><span class="line"><span class="comment">     * 如果不剪的话长度乘积即为j * (i - j)；</span></span><br><span class="line"><span class="comment">     * 如果剪的话长度乘积即为j * dp[i - j]。</span></span><br><span class="line"><span class="comment">     * 取两者最大值max(j * (i - j), j * dp[i - j])</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 最后返回dp[n]即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(n ^ 2)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 核心思路是：尽可能把绳子分成长度为3的小段，这样乘积最大</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 步骤如下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1</span></span><br><span class="line"><span class="comment">     * 如果 n == 4，返回4</span></span><br><span class="line"><span class="comment">     * 如果 n &gt; 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段</span></span><br><span class="line"><span class="comment">     * 以上2和3可以合并</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）剑指14-剪绳子2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剪绳子2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），</span></span><br><span class="line"><span class="comment"> * 每段绳子的长度记为 k[0],k[1]...k[m - 1] 。</span></span><br><span class="line"><span class="comment"> * 请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？</span></span><br><span class="line"><span class="comment"> * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 2</span></span><br><span class="line"><span class="comment"> * 输出: 1</span></span><br><span class="line"><span class="comment"> * 解释: 2 = 1 + 1, 1 × 1 = 1</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 10</span></span><br><span class="line"><span class="comment"> * 输出: 36</span></span><br><span class="line"><span class="comment"> * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2 &lt;= n &lt;= 1000</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 数学</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与剪绳子1唯一不同在于本题目涉及 “大数越界情况下的求余问题”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz14CuttingRope2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">2</span>));</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res  = res * <span class="number">3</span> % <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-正则表达式匹配"><a href="#3-3-正则表达式匹配" class="headerlink" title="3.3 正则表达式匹配"></a>3.3 正则表达式匹配</h3><p>剑指19-正则表达式匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式匹配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请实现一个函数用来匹配包含'. '和'*'的正则表达式。</span></span><br><span class="line"><span class="comment"> * 模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。</span></span><br><span class="line"><span class="comment"> * 在本题中，匹配是指字符串的所有字符匹配整个模式。</span></span><br><span class="line"><span class="comment"> * 例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aa"</span></span><br><span class="line"><span class="comment"> * p = "a"</span></span><br><span class="line"><span class="comment"> * 输出: false</span></span><br><span class="line"><span class="comment"> * 解释: "a" 无法匹配 "aa" 整个字符串。</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aa"</span></span><br><span class="line"><span class="comment"> * p = "a*"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。</span></span><br><span class="line"><span class="comment"> * 示例 3:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "ab"</span></span><br><span class="line"><span class="comment"> * p = ".*"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span></span><br><span class="line"><span class="comment"> * 示例 4:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aab"</span></span><br><span class="line"><span class="comment"> * p = "c*a*b"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。</span></span><br><span class="line"><span class="comment"> * 示例 5:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "mississippi"</span></span><br><span class="line"><span class="comment"> * p = "mis*is*p*."</span></span><br><span class="line"><span class="comment"> * 输出: false</span></span><br><span class="line"><span class="comment"> * s 可能为空，且只包含从 a-z 的小写字母。</span></span><br><span class="line"><span class="comment"> * p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。</span></span><br><span class="line"><span class="comment"> * 注意：本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz19IsMatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"aa"</span>;</span><br><span class="line">        String p = <span class="string">"a"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"aa"</span>;</span><br><span class="line">        p = <span class="string">"a*"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"ab"</span>;</span><br><span class="line">        p = <span class="string">".*"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"aab"</span>;</span><br><span class="line">        p = <span class="string">"c*a*b"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"mississippi"</span>;</span><br><span class="line">        p = <span class="string">"mis*is*p*."</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符非.或*，则直接比较。</span></span><br><span class="line"><span class="comment">     * 字符为.，则直接匹配，跳到下一个字符。</span></span><br><span class="line"><span class="comment">     * 字符为*，则找到下一个与其匹配的字符。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = p.length();</span><br><span class="line">        <span class="comment">// 存放已处理结果</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">2</span>) || p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题思路：</p><p>假设主串为 A，模式串为 B 从最后一步出发，需要关注最后进来的字符。假设 A 的长度为 n ，B 的长度为 m ，关注正则表达式 B 的最后一个字符是谁，它有三种可能，正常字符、<code>*</code> 和 <code>.</code>（点），那针对这三种情况讨论即可，如下：</p><ol><li>如果 B 的最后一个字符是正常字符，那就是看 <code>A[n-1]</code> 是否等于 <code>B[m-1]</code> ，相等则看 A~0..n-2~ 与 B~0..m−2~ ，不等则是不能匹配，这就是子问题。</li><li>如果 B 的最后一个字符是 <code>.</code> ，它能匹配任意字符，直接看 A~0..n-2~ 与 B~0..m−2~ </li><li>如果 BB 的最后一个字符是 <code>*</code> 它代表 <code>B[m-2]=c</code> 可以重复0次或多次，它们是一个整体 c*<ul><li>情况一：<code>A[n-1]</code> 是 0 个 c，B 最后两个字符废了，能否匹配取决于  A~0..n-1~ 与 B~0..m−3~ 是否匹配</li><li>情况二：<code>A[n-1]</code> 是多个 c 中的最后一个（这种情况必须 A[n-1]=c 或者 c=’.’），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A~0..n-2~ 与 B~0..m−1~ 是否匹配。</li></ul></li></ol><p>转移方程:</p><p><code>f[i][j]</code> 代表 A 的前 i 个和 B 的前 j 个能否匹配:</p><ul><li>对于前面两个情况，可以合并成一种情况 <code>f[i][j]</code> = <code>f[i-1][j-1]</code> </li><li>对于第三种情况，对于 c* 分为看和不看两种情况<ul><li>不看：直接砍掉正则串的后面两个， <code>f[i][j]</code> = <code>f[i][j-2]</code></li><li>看：正则串不动，主串前移一个，<code>f[i][j]</code> = <code>f[i-1][j]</code></li></ul></li></ul><p>初始条件</p><p>特判：需要考虑空串空正则</p><ul><li>空串和空正则是匹配的，<code>f[0][0]</code> = true</li><li>空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如A=’’ ,B=a∗b∗c∗）</li><li>非空串和空正则必不匹配，<code>f[1][0]</code> =…= <code>f[n][0]</code> =false</li><li>非空串和非空正则，那肯定是需要计算的了。</li></ul><p>大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 <em> 和不是 </em> 两种情况了。</p><p>复杂度分析</p><p>时间复杂度：O(mn)，其中 m 和 n 分别是字符串 s 和 p 的长度。我们需要计算出所有的状态，并且每个状态在进行转移时的时间复杂度为 O(1)。</p><p>空间复杂度：O(mn)，即为存储所有状态使用的空间。</p><h3 id="3-4-编号动态规划：最大不下降子序列"><a href="#3-4-编号动态规划：最大不下降子序列" class="headerlink" title="3.4 编号动态规划：最大不下降子序列"></a>3.4 编号动态规划：最大不下降子序列</h3><p>　　本类的状态是基础的基础，大部分的动态规划都要用到它，成为一个维。</p><ul><li><strong>最长不下降子序列定义：</strong>从序列中选出若干个数组成一个新的序列，不改变他们的队伍的顺序，要求新的序列里xi≤xi+1≤xi+1…..举个例子{4,6,5,7,3}，最长不下降子序列就是{4,6,7}。</li><li><strong>子问题的表示：</strong>令dp[i]表示以第i个元素结尾的前i个元素构成的最长不下降子序列的长度</li><li><strong>优化子结构</strong>：若最长不下降子序列包括ak，则必有一个解包含a1,a2…ak-1的最长不下降子序列，dp[i]表示为前i个元素的序列的最长不下降子序列</li><li><strong>方程</strong>： <em>dp[i] = max{dp[j] | 0&lt;j&lt;i , aj≥ai} + 1</em></li><li><strong>伪代码</strong>：</li></ul><p>　　　　输入a[1,…,n]　　输出：最长子序列</p><p> 　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626142332007-952080845.png" alt="img"></p><p><strong>时间复杂度：O(n^2)</strong></p><h3 id="3-5-划分动态规划：矩阵链乘、凸多边形三角剖分"><a href="#3-5-划分动态规划：矩阵链乘、凸多边形三角剖分" class="headerlink" title="3.5 划分动态规划：矩阵链乘、凸多边形三角剖分"></a>3.5 划分动态规划：矩阵链乘、凸多边形三角剖分</h3><p><strong>【矩阵链乘】</strong></p><ul><li><strong>优化子结构</strong>：若计算A1~n的优化顺序在k处断开矩阵链, 即A1~n=A1~k × Ak+1~n，则在A1~n的优化顺序中，对应于子问题A1~k的解必须是A1-k的优化解，对应于子问题Ak+1~n的解必须是Ak+1~n的优化解</li><li><strong>子问题重叠性：</strong></li></ul><p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626144646962-1290294296.png" alt="img"></p><ul><li><strong>方程：</strong></li></ul><p>假设：m[i, j] = 计算Ai~j的最小乘法数；  A1 … AkAk+1 …. An 是优化解(k实际上是不可预知)</p><p> 　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626143827583-1699093130.png" alt="img"></p><p>　  <img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626144206832-946860971.png" alt="img"></p><ul><li><strong>伪代码：</strong></li></ul><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：&lt;A1, A2, ..., An&gt;, Ai是矩阵</span><br><span class="line">输出：计算A1 x A2 x ... x An的最小代价方法</span><br><span class="line"></span><br><span class="line">Matrix-Chain-Order(p)</span><br><span class="line">n=length(p)-<span class="number">1</span>；</span><br><span class="line"><span class="keyword">FOR</span> i=<span class="number">1</span> <span class="keyword">TO</span> n <span class="keyword">DO</span></span><br><span class="line">    m[i, i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">FOR</span> l=<span class="number">2</span> <span class="keyword">TO</span> n <span class="keyword">DO</span> <span class="comment">/* 计算地l对角线*/</span></span><br><span class="line">    <span class="keyword">FOR</span> i=<span class="number">1</span> <span class="keyword">TO</span> n-l+<span class="number">1</span> <span class="keyword">DO</span></span><br><span class="line">        j=i+l-<span class="number">1</span>;</span><br><span class="line">        m[i, j]= ∞;</span><br><span class="line">        <span class="keyword">FOR</span> k←i <span class="keyword">To</span> j←<span class="number">1</span> <span class="keyword">DO</span> <span class="comment">/* 计算m[i,j] */</span></span><br><span class="line">             q=m[i, k]+m[k+<span class="number">1</span>, j]+ <span class="built_in">pi</span>-<span class="number">1</span>pkpj</span><br><span class="line">             <span class="keyword">IF</span> q&lt;m[i, j] <span class="keyword">THEN</span>                  m[i,j]=q; s[i,j]=k;</span><br><span class="line">Return m <span class="built_in">and</span> s.</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Print</span>-Optimal-Parens(s, i, j) <span class="comment">//构建最优解，输出A1-n的优化计算顺序</span></span><br><span class="line"> <span class="keyword">IF</span> j=<span class="built_in">i</span></span><br><span class="line"> THEN <span class="keyword">Print</span> “A”i;</span><br><span class="line"> <span class="keyword">ELSE</span> <span class="keyword">Print</span> “(”</span><br><span class="line">     <span class="keyword">Print</span>-Optimal-Parens(s, i, s[i, j])</span><br><span class="line">     <span class="keyword">Print</span>-Optimal-Parens(s, s[i, j]+1, j)</span><br><span class="line">     <span class="keyword">Print</span> “)”</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><ul><li>算法复杂度<ul><li>计算代价的时间：三层循环 O(n3)</li><li>构建最优解的时间： O(n)</li><li><strong>总时间复杂度：O(n3)</strong></li></ul></li><li><p>空间复杂度</p><ul><li>使用数组m和s</li><li>需要<strong>空间O(n3)</strong></li></ul><p><strong>【三角剖分】</strong></p></li><li><p><strong>优化子结构</strong>：将多边形P划分为不相交三角形的弦的集合</p></li><li><strong>优化问题</strong>:</li></ul><p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626150321546-748343160.png" alt="img"></p><ul><li><p><strong>方程</strong>：设t[i,j] = &lt;vi-1,vi,…..,vj&gt;的优化三角剖分代价</p><p>　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626150546681-278989483.png" alt="img"></p></li></ul><h3 id="3-6-数轴动态规划：0-1背包"><a href="#3-6-数轴动态规划：0-1背包" class="headerlink" title="3.6 数轴动态规划：0-1背包"></a>3.6 数轴动态规划：0-1背包</h3><p>### </p><ul><li><strong>问题描述</strong>：给定n种物品和一个背包，物品i的重量是wi，价值vi，背包容量为C，问如何选择装入背包的物品，使装入背包中的物品的总价值最大？对于每种物品总能选择完全装入或不装入，一个物品最多装入一次。</li><li><strong>等价整数规划问题：</strong></li></ul><p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626151529727-1771169615.png" alt="img"></p><ul><li><strong>Naive的方法</strong>：每个物品只有两种选择：不装或装，n个物品共2n个装取方案，每个装取方案的计算代价为n，总计算代价为O(n2n)</li><li><p><strong>问题的划分：</strong></p><p>　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626151725491-1249436922.png" alt="img"></p></li><li><p><strong>定义代价矩阵m与方程</strong>：  </p></li><li><ul><li><strong><em>定义m(i, j)\</em> :</strong>背包容量为j，可选物品为xi,xi+1…xn时，问题的最优解代价时m[i,j]</li><li><em>m(n, j) = 0,  0</em> ≤ <em>j &lt;wn</em></li><li><em>m(n, j) = vn,  j ≥**wn</em></li><li><em>m(i, j) = m(i+1, j), 　　   0≤</em> <em>j&lt; wi</em></li><li><em>m(i, j) = max{m(i+1, j), m(i+1, j-wi)+vi},   j ≥</em> <em>wi</em></li></ul></li><li><p><strong>优化子结构和自底向上的代价</strong></p></li></ul><p>　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626154205161-1543350290.png" alt="img"><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626154222124-1568769512.png" alt="img"></p><ul><li><strong>伪代码</strong></li></ul><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>输入：C&gt;0, wi&gt;0, vi&gt;0, 1≤ i≤n<br>输出：(x1, x2, …, xn), xi∈{0, 1}, 满足 ∑1≤i≤nwi xi ≤C, ∑1≤i≤nvi xi 最大</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> <span class="attribute">j</span>=0 <span class="keyword">To</span> min(wn-1, C) <span class="keyword">Do</span></span><br><span class="line">      m[n, j] = 0;</span><br><span class="line"><span class="keyword">For</span> <span class="attribute">j</span>=wn <span class="keyword">To</span> C <span class="keyword">Do</span></span><br><span class="line">      m[n, j] = vn;</span><br><span class="line"><span class="keyword">For</span> <span class="attribute">i</span>=n-1 <span class="keyword">To</span> 2 <span class="keyword">Do</span></span><br><span class="line">    <span class="keyword">For</span> <span class="attribute">j</span>=0 <span class="keyword">To</span> min(wi -1, C)  <span class="keyword">Do</span></span><br><span class="line">      m[i, j] = m[i+1, j];</span><br><span class="line">    <span class="keyword">For</span> <span class="attribute">j</span>=wi  <span class="keyword">To</span> C   <span class="keyword">Do</span></span><br><span class="line">      m[i, j]=max&#123;m[i+1, j], m[i+1, j-wi]+vi&#125;;</span><br><span class="line"><span class="keyword">If</span>  C&lt;w1  Then  m[1, C]=m[2, C];</span><br><span class="line">      <span class="keyword">Else</span>  m[1, C]=max&#123;m[2, C], m[2, C-w1]+v1&#125;;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">m</span>(1, C)是最优解代价值，相应解计算如下: <span class="comment">//构造优化解</span></span><br><span class="line">    <span class="keyword">If</span> <span class="built_in">m</span>(1, C) = <span class="built_in">m</span>(2, C)</span><br><span class="line">    Then x1 = 0;</span><br><span class="line">    <span class="keyword">Else</span> x1 = 1;</span><br><span class="line">如果x1=0, 由<span class="built_in">m</span>(2, C)继续构造最优解;</span><br><span class="line">如果x1=1, 由<span class="built_in">m</span>(2, C-w1)继续构造最优解.</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><ul><li>时间复杂度：<ul><li>计算代价的时间为O(Cn)</li><li>构造最优解的时间:O(Cn)</li><li><strong>总时间复杂度为:O(Cn)</strong></li></ul></li><li>空间复杂度：<ul><li><strong>使用数组m，需要空间O(Cn)</strong></li></ul></li></ul><h3 id="3-7-前缀动态规划：最长公共子序列（LCS）"><a href="#3-7-前缀动态规划：最长公共子序列（LCS）" class="headerlink" title="3.7 前缀动态规划：最长公共子序列（LCS）"></a>3.7 前缀动态规划：最长公共子序列（LCS）</h3><p>### </p><ul><li><strong>问题描述</strong>：Z是序列X与Y的公共子序列如果Z是X的子序列也是Y的子序列。</li><li><p><strong>Naive方法：</strong></p><ul><li>枚举X的每个子序列Z</li><li>检查Z是否为Y的子序列</li><li><strong>T(n)=O(n2m)</strong></li></ul></li><li><p><strong>优化子结构：</strong></p></li><li><ul><li><em>设X=(x1, …, xm)、Y=(y1, …, yn)是两个序列， LCSXY=(z1, …, zk)是X与Y的LCS，我们有：</em></li><li><em>如果xm=yn, 则zk=xm=yn, LCSXY = LCSXm-1Yn-1 + &lt;xm=yn&gt;,  LCSXm-1Yn-1是Xm-1和Yn-1的LCS.</em></li><li><em>如果xm<strong>≠yn，且zk≠</strong>xm，则LCSXY是Xm-1和Y的LCS，即 LCSXY = LCSXm-1Y</em></li><li><em>如果xm≠<strong>yn,且zk≠</strong>yn,则LCSXY是X与Yn-1的LCS，即 LCSXY = LCSXYn-1</em></li></ul></li></ul><p>　　　　<em><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161250797-846687005.png" alt="img"></em></p><ul><li><strong>子问题重叠性</strong></li></ul><p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161407046-1649798663.png" alt="img"></p><ul><li><strong>方程：</strong></li></ul><p>　　　　<strong><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161153121-2116602929.png" alt="img"></strong></p><ul><li><strong>自底向上计算：</strong></li></ul><p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161510812-1390787212.png" alt="img"></p><ul><li><strong>伪代码</strong></li></ul><p><strong><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626164412918-1817122808.png" alt="img"></strong></p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入：X = (x1,x2,...,xm)，Y = (y1,y2,...yn)</span><br><span class="line">输出：Z = X与Y的最长公共子序列</span><br><span class="line"></span><br><span class="line"><span class="keyword">C</span>[<span class="number">0</span>:m,<span class="number">0</span>:n]: <span class="keyword">C</span>[i,j]是Xi与Yj的LCS的长度   B[<span class="number">1</span>:m,<span class="number">1</span>:n]:</span><br><span class="line">B[i,j]是指针，指向计算<span class="keyword">C</span>[i,j]时所选择的子问题的优化解所对应的<span class="keyword">C</span>表的表项</span><br><span class="line"></span><br><span class="line">LCS-length(X, Y)</span><br><span class="line">m←length(X)；n←length(Y)；</span><br><span class="line"><span class="keyword">For</span> i←<span class="number">0</span> To m <span class="keyword">Do</span> <span class="keyword">C</span>[i,<span class="number">0</span>]←<span class="number">0</span>;</span><br><span class="line"><span class="keyword">For</span> j←<span class="number">0</span> To n <span class="keyword">Do</span> <span class="keyword">C</span>[<span class="number">0</span>,j]←<span class="number">0</span>;</span><br><span class="line"><span class="keyword">For</span> i←<span class="number">1</span> To m <span class="keyword">Do</span></span><br><span class="line">  <span class="keyword">For</span> j←<span class="number">1</span> To n <span class="keyword">Do</span></span><br><span class="line">    <span class="keyword">If</span> xi = yj</span><br><span class="line">    Then <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i<span class="number">-1</span>,j<span class="number">-1</span>]+<span class="number">1</span>；B[i,j]←“↖”;</span><br><span class="line">      Else <span class="keyword">If</span> <span class="keyword">C</span>[i<span class="number">-1</span>,j]≥<span class="keyword">C</span>[i,j<span class="number">-1</span>] Then</span><br><span class="line">              <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i<span class="number">-1</span>,j]; B[i,j]←“↑”;</span><br><span class="line">           Else <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i,j<span class="number">-1</span>]; B[i,j]←“←”;</span><br><span class="line"><span class="keyword">Return</span> <span class="keyword">C</span> and B.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Print</span>-LCS(B, X, i, j)</span><br><span class="line">IF i=<span class="number">0</span> or j=<span class="number">0</span> THEN <span class="keyword">Return</span>;</span><br><span class="line">IF B[i, j]=“↖”</span><br><span class="line">THEN <span class="keyword">Print</span>-LCS(B, X, i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">Print</span> xi;</span><br><span class="line">ELSE <span class="keyword">If</span> B[i, j]=“↑”</span><br><span class="line">    THEN <span class="keyword">Print</span>-LCS(B, X, i<span class="number">-1</span>, j);</span><br><span class="line">    ELSE <span class="keyword">Print</span>-LCS(B, X, i, j<span class="number">-1</span>).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Print</span>-LCS(B, X, length(X), length(Y))</span><br><span class="line">      可打印出X与Y的LCS。</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><ul><li><p>时间复杂度</p><p>：</p><ul><li>计算代价的时间：O(mn)</li><li>构造最优解的时间：O(m+n)</li><li><strong>总时间复杂度为： O(mn)</strong></li></ul></li><li><p>空间复杂度</p><p>：</p><ul><li>使用数组C和B，需要<strong>空间O(mn)</strong></li></ul></li></ul><h3 id="3-8-树形动态规划：最优二分搜索树"><a href="#3-8-树形动态规划：最优二分搜索树" class="headerlink" title="3.8 树形动态规划：最优二分搜索树"></a>3.8 树形动态规划：最优二分搜索树</h3><hr><p>参考：</p><p>🔗 《<a href="https://zh.wikipedia.org/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">维基百科-动态规划</a>》</p><p>🔗 《<a href="https://www.cnblogs.com/hithongming/p/9229871.html" target="_blank" rel="noopener">【算法复习】动态规划</a>》</p><p>🔗 《<a href="https://www.cnblogs.com/hithongming/p/9229871.html" target="_blank" rel="noopener">如何理解动态规划？</a>》</p>]]></content>
    
    <summary type="html">
    
      内容包括：概述，实现，算法题等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>算法复习 (三) 图-无向图（未完成）</title>
    <link href="http://linyishui.top/2021030401.html"/>
    <id>http://linyishui.top/2021030401.html</id>
    <published>2021-03-04T13:36:06.000Z</published>
    <updated>2021-04-20T05:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法复习-三-图-无向图"><a href="#算法复习-三-图-无向图" class="headerlink" title="算法复习 (三) 图-无向图"></a>算法复习 (三) 图-无向图</h1><h2 id="一-图"><a href="#一-图" class="headerlink" title="一. 图"></a>一. 图</h2><h3 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1 应用场景"></a>1.1 应用场景</h3><ul><li>地图。正在计划旅行的人也许想知道“从普罗维登斯到普林斯顿的最短路线”。对最短路径上经历过交通堵塞的旅行者可能会问：“从普罗维登斯到普林斯顿的哪条路线最快？”要回答这些问题，我们都要处理有关结点（十字路口）之间多条连接（公路）的信息。</li><li>网页信息。当我们在浏览网页时，页面上都会包含其他网页的引用（链接）。通过单击链接，我们可以从一个页面跳到另一个页面。整个互联网就是一张图，结点是网页，连接就是超链接。图算法是帮助我们在网络上定位信息的搜索引擎的关键组件。</li><li>电路。在一块电路板上，晶体管、电阻、电容等各种元件是精密连接在一起的。我们使用计算机来控制制造电路板的机器并检查电路板的功能是否正常。我们既要检查短路这类简单问题，也要检查这幅电路图中的导线在蚀刻到芯片上时是否会出现交叉等复杂问题。第一类问题的答案仅取决于连接（导线）的属性，而第二个问题则会涉及导线、各种元件<br>以及芯片的物理特性等详细信息。</li><li>任务调度。商品的生产过程包含了许多工序以及一些限制条件，这些条件会决定某些任务的先后次序。如何安排才能在满足限制条件的情况下用最少的时间完成这些生产工序呢？<br>商业交易。零售商和金融机构都会跟踪市场中的买卖信息。在这种情形下，一条连接可以表示现金和商品在买方和卖方之间的转移。在此情况下，理解图的连接结构原理可能有助于增强人们对市场的理解。</li><li>配对。学生可以申请加入各种机构，例如社交俱乐部、大学或是医学院等。这里结点就对应学生和机构，而连接则对应递交的申请。我们希望找到申请者与他们感兴趣的空位之间配对的方法。</li><li>计算机网络。计算机网络是由能够发送、转发和接收各种消息的站点互相连接组成的。我们感兴趣的是这种互联结构的性质，因为我们希望网络中的线路和交换设备能够高效率地处理网络流量。</li><li>软件。编译器会使用图来表示大型软件系统中各个模块之间的关系。图中的结点即构成整个系统的各种类和模块，连接则为类的方法之间的可能调用关系（静态分析），或是系统运行时的实际调用关系（动态分析）。我们需要分析这幅图来决定如何以最优的方式为程序分配资源。</li><li>社交网络。当你在使用社交网站时，会和你的朋友之间建立起明确的关系。这里，结点对应人而连接则联系着你和你的朋友或是关注者。分析这些社交网络的性质是当前图算法的一个重要应用。对它感兴趣的不止是社交网络的公司，还包括政治、外交、娱乐、教育、市场等许多其他机构。</li></ul><table><thead><tr><th>应用</th><th>结点</th><th>连接</th></tr></thead><tbody><tr><td>地图</td><td>十字路口</td><td>公路</td></tr><tr><td>网络内容</td><td>网页</td><td>超链接</td></tr><tr><td>电路</td><td>元器件</td><td>导线</td></tr><tr><td>任务调度</td><td>任务</td><td>限制条件</td></tr><tr><td>商业交易</td><td>客户</td><td>交易</td></tr><tr><td>配对</td><td>学生</td><td>申请</td></tr><tr><td>计算机网络</td><td>网站</td><td>物理连接</td></tr><tr><td>软件</td><td>方法</td><td>调用关系</td></tr><tr><td>社交网络</td><td>人</td><td>友谊关系</td></tr></tbody></table><h3 id="1-2-常用术语"><a href="#1-2-常用术语" class="headerlink" title="1.2 常用术语"></a>1.2 常用术语</h3><ul><li>某个顶点的度数即为依附于它的边的总数。</li><li>子图是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。许多计算问题都需要识别各种类型的子图，特别是由能够顺序连接一系列顶点的边所组成的子图。</li><li>路径是由边顺序连接的一系列顶点。</li><li>简单路径是一条没有重复顶点的路径。环是一条至少含有一条边且起点和终点相同的路径。</li><li>简单环是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。</li><li>路径或者环的长度为其中所包含的边数。</li><li>当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另一个顶点是连通的。</li><li>如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是<strong>连通图</strong>。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。</li><li>无环图是一种不包含环的图。</li><li>图的密度是指已经连接的顶点对占所有可能被连接的顶点对的比例。在稀疏图中，被连接的顶点对很少；而在稠密图中，只有少部分顶点对之间没有边连接。</li><li>二分图是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010113.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010116.png" alt></p><h3 id="1-3-图与树的关系"><a href="#1-3-图与树的关系" class="headerlink" title="1.3 图与树的关系"></a>1.3 图与树的关系</h3><p>树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一棵树。图的生成树森林是它的所有连通子图的生成树的集合。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010114.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010115.png" alt></p><p>当且仅当一幅含有V个结点的图满足下列 5 个条件之一时，它就是一棵树：</p><ul><li>G有V-1条边且不含有环；</li><li>G有V-1条边且是连通的；</li><li>G是连通的，但删除任意一条边都会使它不再连通；</li><li>G是无环图，但添加任意一条边都会产生一条环；</li><li>G中的任意一对顶点之间仅存在一条简单路径。</li></ul><h3 id="1-4-四种图模型"><a href="#1-4-四种图模型" class="headerlink" title="1.4 四种图模型"></a>1.4 四种图模型</h3><p>4 种最重要的图模型：</p><ul><li>无向图（简单连接）</li><li>有向图（连接有方向性）</li><li>加权图（连接带有权值）</li><li>加权有向图（连接既有方向性又带有权值）</li></ul><h2 id="二-无向图"><a href="#二-无向图" class="headerlink" title="二. 无向图"></a>二. 无向图</h2><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>定义：图是由一组顶点和一组能够将两个顶点相连的边组成的。</p><p>一般使用 0 至 V-1 来表示一张含有 V 个顶点的图中的各个顶<br>点。用 v-w 的记法来表示连接 v 和 w 的边，w-v 是这条边的另一种表示方法。</p><p>绘制出的图有时会误导我们，因为图的定义和绘出的图像是无关的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010111.png" alt></p><p>特殊的图。我们的定义允许出现两种简单而特殊的情况：</p><ul><li>自环，即一条连接一个顶点和其自身的边；</li><li>连接同一对顶点的两条边称为平行边。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010112.png" alt></p><p>数学家常常将含有平行边的图称为多重图，而将没有平行边或自环的图称为简单图。后续不会出现这种特殊情况，所以用两个顶点就可以指代一条边了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first; <span class="comment">// 链表的首结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123; <span class="comment">// 和Stack 的push() 方法完全相同</span></span><br><span class="line">        Node oldfirst = first;</span><br><span class="line">        first = <span class="keyword">new</span> Node();</span><br><span class="line">        first.item = item;</span><br><span class="line">        first.next = oldfirst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node current = first;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Item item = current.item;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">// 顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E; <span class="comment">// 边的数目</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj; <span class="comment">// 邻接表：数组+链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V]; <span class="comment">// 创建邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) <span class="comment">// 将所有链表初始化为空</span></span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(In in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in.readInt()); <span class="comment">// 读取V并将图初始化</span></span><br><span class="line">        <span class="keyword">int</span> E = in.readInt(); <span class="comment">// 读取E</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123; <span class="comment">// 添加一条边</span></span><br><span class="line">            <span class="keyword">int</span> v = in.readInt(); <span class="comment">// 读取一个顶点</span></span><br><span class="line">            <span class="keyword">int</span> w = in.readInt(); <span class="comment">// 读取另一个顶点</span></span><br><span class="line">            addEdge(v, w); <span class="comment">// 添加一条连接它们的边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        adj[v].add(w); <span class="comment">// 将w添加到v的链表中</span></span><br><span class="line">        adj[w].add(v); <span class="comment">// 将v添加到w的链表中</span></span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-深度优先搜索"><a href="#三-深度优先搜索" class="headerlink" title="三. 深度优先搜索"></a>三. 深度优先搜索</h2><h3 id="3-1-什么是深度优先搜索？"><a href="#3-1-什么是深度优先搜索？" class="headerlink" title="3.1 什么是深度优先搜索？"></a>3.1 什么是深度优先搜索？</h3><p><strong>深度优先搜索算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的递归算法，它会沿着图的边寻找和起点连通的所有顶点。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p><p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的拓扑排序，利用拓扑排序表可以方便的解决很多相关的图论问题，如无权最长路径问题等等。这种算法不会根据图的结构等信息调整执行策略来源请求。</p><h3 id="3-2-迷宫问题和-Tremaux-搜索"><a href="#3-2-迷宫问题和-Tremaux-搜索" class="headerlink" title="3.2 迷宫问题和 Tremaux 搜索"></a>3.2 迷宫问题和 Tremaux 搜索</h3><p>思考图的搜索过程的一种有益的方法是，考虑另一个和它等价的问题：在一个由各种通道和路口组成的迷宫中找到出路。有些迷宫的规则很简单，但大多数迷宫则需要很复杂的策略才行。</p><p>用迷宫代替图、通道代替边、路口代替顶点仅仅只是一些文字游戏，但就目前来说，这么做可以帮助我们直观地认识问题，参见下图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010102.png" alt></p><p>探索迷宫而不迷路的一种古老办法（至少可以追溯到忒修斯和米诺陶的传说）叫做 <strong>Tremaux 搜索</strong>，参见下图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010103.png" alt></p><p>要探索迷宫中的所有通道，我们需要：</p><ul><li>选择一条没有标记过的通道，在你走过的路上铺一条绳子；</li><li>标记所有你第一次路过的路口和通道；</li><li>当来到一个标记过的路口时（用绳子）回退到上个路口；</li><li>当回退到的路口已没有可走的通道时继续回退。</li></ul><p>绳子可以保证你总能找到一条出路，标记则能保证你不会两次经过同一条通道或者同一个路口。要知道是否完全探索了整个迷宫需要的证明更复杂，只有用图搜索才能够更好地处理问题。</p><p>Tremaux 搜索很直接，但它与完全搜索一张图仍然稍有不同，因此我们接下来看看图的搜索方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearch</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v))</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) dfs(G, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-算法描述"><a href="#3-3-算法描述" class="headerlink" title="3.3 算法描述"></a>3.3 算法描述</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010104.png" alt></p><p>搜索连通图的经典递归算法<strong>深度优先搜索</strong>（遍历所有的顶点和边）和 Tremaux 搜索类似。要搜索一幅图，只需用一个递归方法来遍历所有顶点。<strong>深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比</strong>。</p><p>在访问其中一个顶点时：</p><ul><li>将它标记为已访问；</li><li>递归地访问它的所有没有被标记过的邻居顶点。</li></ul><p>它使用一个 boolean 数组来记录和起点连通的所有顶点。递归方法会标记给定的顶点并调用自己来访问该顶点的相邻顶点列表中所有没有被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。</p><p>算法遍历边和访问顶点的顺序与图的表示是有关的，而不只是与图的结构或是算法有关。因为深度优先搜索只会访问和起点连通的顶点，使用下图所示的一幅小型连通图为例，一幅连通的无向图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010105.png" alt></p><ul><li>在示例中，顶点 2 是顶点 0 之后第一个被访问的顶点，因为它正好是 0 的邻接表的第一个元素。</li><li>深度优先搜索中每条边都会被访问两次，且在第二次时总会发现这个顶点已经被标记过。这意味着深度优先搜索的轨迹可能会比你想象的长一倍！示例图仅含有 8 条边，但需要追踪算法在邻接表的 16 个元素上的操作。</li></ul><p>下图显示的是示例中每个顶点被标记后算法使用的数据结构，起点为顶点 0。使用深度优先搜索的轨迹，寻找所有和顶点 0 连通的顶点：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010106.png" alt></p><p>查找开始于构造函数调用递归的 <code>dfs()</code> 来标记和访问顶点0，后续处理如下所述：</p><ul><li>因为顶点 2 是 0 的邻接表的第一个元素且没有被标记过，<code>dfs()</code> 递归调用自己来标记并访问顶点 2（效果是系统会将顶点 0 和 0 的邻接表的当前位置压入栈中）。</li><li>现在，顶点 0 是 2 的邻接表的第一个元素且已经被标记过了，因此 <code>dfs()</code> 跳过了它。接下来，顶点 1 是 2 的邻接表的第二个元素且没有被标记，<code>dfs()</code> 递归调用自己来标记并访问顶点 1。</li><li>对顶点 1 的访问和前面有所不同：因为它的邻接表中的所有顶点（0 和 2）都已经被标记过了，因此不需要再进行递归，方法从 <code>dfs(1)</code> 中返回。下一条被检查的边是 2-3（在 2 的邻接表中顶点 1 之后的顶点是 3），因此 <code>dfs()</code> 递归调用自己来标记并访问顶点3。</li><li>顶点 5 是 3 的邻接表的第一个元素且没有被标记，因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 5。</li><li>顶点 5 的邻接表中的所有顶点（3 和 0）都已经被标记过了，因此不需要再进行递归。</li><li>顶点 4 是 3 的邻接表的下一个元素且没有被标记过，因此 <code>dfs()</code> 递归调用自己来标记并访问顶点 4。这是最后一个需要被标记的顶点。</li><li>在顶点 4 被标记了之后，<code>dfs()</code> 会检查它的邻接表，然后再检查 3 的邻接表，然后是 2 的邻接表，然后是 0 的，最后发现不需要再进行任何递归调用，因为所有的顶点都已经被标记过了。</li></ul><h3 id="3-4-使用场景"><a href="#3-4-使用场景" class="headerlink" title="3.4 使用场景"></a>3.4 使用场景</h3><ul><li><strong>连通性问题</strong> / <strong>路径检测问题</strong> ：比如给定一幅图，回答“两个给定的顶点是否连通？”或者“图中有多少个连通子图？”等类似问题。问题“两个给定的顶点是否连通？”等价于“两个给定的顶点之间是否存在一条路径？”</li><li><strong>单点路径</strong>：给定一幅图和一个起点 s，回答“从 s 到给定目的顶点 v 是否存在一条路径？如果有，找出这条路径。”等类似问题。</li></ul><p>深度优先搜索算法之所以极为简单，是因为它所基于的概念为人所熟知并且非常容易实现。事实上，它是一个既小巧而又强大的算法，研究人员用它解决了无数困难的问题。上述两个问题只是我们将要研究的许多问题的开始。</p><h3 id="3-5-算法题"><a href="#3-5-算法题" class="headerlink" title="3.5 算法题"></a>3.5 算法题</h3><p>剑指第12题-矩阵中的路径：深度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 矩阵中的路径</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</span></span><br><span class="line"><span class="comment"> * 路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。</span></span><br><span class="line"><span class="comment"> * 如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</span></span><br><span class="line"><span class="comment"> * 例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [["a","b","c","e"],</span></span><br><span class="line"><span class="comment"> * ["s","f","c","s"],</span></span><br><span class="line"><span class="comment"> * ["a","d","e","e"]]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入：board = [["a","b"],["c","d"]], word = "abcd"</span></span><br><span class="line"><span class="comment"> * 输出：false</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1 &lt;= board.length &lt;= 200</span></span><br><span class="line"><span class="comment"> * 1 &lt;= board[i].length &lt;= 200</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 深度优先搜索</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz12Exist</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] board = &#123;</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'S'</span>, <span class="string">'F'</span>, <span class="string">'C'</span>, <span class="string">'S'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String word = <span class="string">"ABCCED"</span>;</span><br><span class="line">        System.out.println(exist(board, word));</span><br><span class="line">        <span class="keyword">char</span>[][] board1 = &#123;&#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;, &#123;<span class="string">'c'</span>, <span class="string">'d'</span>&#125;&#125;;</span><br><span class="line">        String word1 = <span class="string">"abcd"</span>;</span><br><span class="line">        System.out.println(exist(board1, word1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间复杂度 O(3^K * M * N) ：</span></span><br><span class="line"><span class="comment">     *      最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K)；</span></span><br><span class="line"><span class="comment">     *      矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。</span></span><br><span class="line"><span class="comment">     *      方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3^K) 。</span></span><br><span class="line"><span class="comment">     * 空间复杂度 O(K) ：</span></span><br><span class="line"><span class="comment">     *      搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K)</span></span><br><span class="line"><span class="comment">     *      （因为函数返回后，系统调用的栈空间会释放）。</span></span><br><span class="line"><span class="comment">     *      最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, words, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board 二维矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 单词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 单词坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否命中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未命中：横纵坐标越界，矩阵对应位置元素不等于单词对应位置元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单词遍历结束，全部命中</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记表示已访问过</span></span><br><span class="line">        board[i][j] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">// 递归访问相邻矩阵元素</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, word, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剑指第13题-机器人的运动范围：深度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。</span></span><br><span class="line"><span class="comment"> * 一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），</span></span><br><span class="line"><span class="comment"> * 也不能进入行坐标和列坐标的数位之和大于k的格子。</span></span><br><span class="line"><span class="comment"> * 例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。</span></span><br><span class="line"><span class="comment"> * 但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：m = 2, n = 3, k = 1</span></span><br><span class="line"><span class="comment"> * 输出：3</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：m = 3, n = 1, k = 0</span></span><br><span class="line"><span class="comment"> * 输出：1</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1 &lt;= n,m &lt;= 100</span></span><br><span class="line"><span class="comment"> * 0 &lt;= k &lt;= 20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz13MovingCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">        m = <span class="number">3</span>;</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">        m = <span class="number">16</span>;</span><br><span class="line">        n = <span class="number">8</span>;</span><br><span class="line">        k = <span class="number">4</span>;</span><br><span class="line">        System.out.println(movingCount(m, n , k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(mn)，其中 m 为方格的行数， n 为方格的列数。</span></span><br><span class="line"><span class="comment">     * 一共有 O(mn) 个状态需要计算，每个状态递推计算的时间复杂度为 O(1)，所以总时间复杂度为 O(mn)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(mn)，其中 m 为方格的行数，n 为方格的列数。我们需要 O(mn) 大小的结构来记录每个位置是否可达。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; getSum(i) + getSum(j) || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, m, n, k, visited) + dfs(i, j + <span class="number">1</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = a / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tmp % <span class="number">10</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-寻找路径"><a href="#四-寻找路径" class="headerlink" title="四. 寻找路径"></a>四. 寻找路径</h2><h3 id="4-1-路径API"><a href="#4-1-路径API" class="headerlink" title="4.1 路径API"></a>4.1 路径API</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010107.png" alt></p><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Graph G = <span class="keyword">new</span> Graph(<span class="keyword">new</span> In(args[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">int</span> s = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">    Paths search = <span class="keyword">new</span> Paths(G, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">        StdOut.print(s + <span class="string">" to "</span> + v + <span class="string">": "</span>);</span><br><span class="line">        <span class="keyword">if</span> (search.hasPathTo(v))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : search.pathTo(v))</span><br><span class="line">                <span class="keyword">if</span> (x == s) StdOut.print(x);</span><br><span class="line">                <span class="keyword">else</span> StdOut.print(<span class="string">"-"</span> + x);</span><br><span class="line">        StdOut.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h3><p>DepthFirstPaths使用深度优先搜索查找图中的路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用深度优先搜索查找图中的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此顶点上是否调用过 dfs()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从起点到一个顶点的已知路径上的最后一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 G 中找出所有起点为 s 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在从 s 到 v 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s 到 v 的路径，如果不存在则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x]) &#123;</span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算轨迹如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010109.png" alt></p><p>为了保存到达每个顶点的已知路径，这段代码使用了一个以顶点编号为索引的数组 edgeTo[]，edgeTo[w]=v 表示 v-w 是第一次访问 w 时经过的边。edgeTo[] 数组是一棵用父链接表示的以 s 为根且含有所有与 s 连通的顶点的树。</p><p>下图显示的是示例中每个顶点被标记后 edgeTo[] 的内容，起点为顶点 0。marked[] 和 adj[] 的内容与  DepthFirstSearch 的轨迹相同，递归调用和边检查的详细描述也完全一样，这里不再赘述。深度优先搜索向 edgeTo[] 数组中顺序添加了 0-2、2-1、2-3、3-5 和 3-4。这些边构成了一棵以起点为根结点的树并提供了 pathTo() 方法所需的信息，使得调用者可以按照前文所述的方法找到从 0 到顶点 1、2、3、4、5 的路径。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210301/202103010110.png" alt></p><h2 id="五-广度优先搜索"><a href="#五-广度优先搜索" class="headerlink" title="五. 广度优先搜索"></a>五. 广度优先搜索</h2><h3 id="5-1-什么是广度优先搜索？"><a href="#5-1-什么是广度优先搜索？" class="headerlink" title="5.1 什么是广度优先搜索？"></a>5.1 什么是广度优先搜索？</h3><p>广度优先搜索算法（Breadth-First Search，BFS）</p><p>单点最短路径。给定一幅图和一个起点 s，回答“从 s 到给定目的顶点 v 是否存在一条路径？如果有，找出其中最短的那条（所含边数最少）。”等类似问题。</p><p>解决这个问题的经典方法叫做广度优先搜索（BFS)。深度优先搜索在这个问题上没有什么作为，因为它遍历整个图的顺序和找出最短路径的目标没有任何关系。相比之下，广度优先搜索正是为了这个目标才出现的。</p><p>要找到从 s 到 v 的最短路径，从 s 开始，在所有由一条边就可以到达的顶点中寻找 v，如果找不到我们就继续在与 s 距离两条边的所有顶点中查找v，如此一直进行。深度优先搜索就好像是一个人在走迷宫，广度优先搜索则好像是一组人在一起朝各个方向走这座迷宫，每个人都有自己的绳子。当出现新的叉路时，可以假设一个探索者可以分裂为更多的人来搜索它们，当两个探索者相遇时，会合二为一（并继续使用先到达者的绳子），参见下图-广度优先的迷宫搜索。</p><p><img src="C:\Users\hspcadmin\Desktop\文档\202104120101.png" alt></p><h3 id="5-2-算法描述"><a href="#5-2-算法描述" class="headerlink" title="5.2 算法描述"></a>5.2 算法描述</h3><p>在深度优先搜索中，我们用了一个可以下压的栈（这是由系统管理的，以支持递归搜索方法）。使用 LIFO（后进先出）的规则来描述压栈和走迷宫时先探索相邻的通道类似。从有待搜索的通道中选择最晚遇到过的那条。在广度优先搜索中，我们希望按照与起点的距离的顺序来遍历所有顶点，看起来这种顺序很容易实现：使用（FIFO，先进先出）队列来代替栈（LIFO，后进先出）即可。我们将从有待搜索的通道中选择最早遇到的那条。</p><p>算法 4.2 实现了广度优先搜索算法。它使用了一个队列来保存所有已经被标记过但其邻接表还未被检查过的顶点。先将起点加入队列，然后重复以下步骤直到队列为空：</p><ul><li>取队列中的下一个顶点 v 并标记它；</li><li>将与 v 相邻的所有未被标记过的顶点加入队列。</li></ul><p><img src="C:\Users\hspcadmin\Desktop\文档\202104120102.png" alt></p><p>步骤：</p><p><img src="C:\Users\hspcadmin\Desktop\文档\202104120103.png" alt></p><ul><li>从队列中删去顶点 0 并将它的相邻顶点 2、1 和 5 加入队列中，标记它们并分别将它们在 <code>edgeTo[]</code> 中的值设为 0。</li><li>从队列中删去顶点 2 并检查它的相邻顶点 0 和 1，发现两者都已经被标记。将相邻的顶点 3 和 4 加入队列，标记它们并分别将它们在 <code>edgeTo[]</code> 中的值设为 2。</li><li>从队列中删去顶点 1 并检查它的相邻顶点 0 和 2，发现它们都已经被标记了。</li><li>从队列中删去顶点 5 并检查它的相邻顶点 3 和 0，发现它们都已经被标记了。</li><li>从队列中删去顶点 3 并检查它的相邻顶点 5、4 和 2，发现它们都已经被标记了。</li><li>从队列中删去顶点 4 并检查它的相邻顶点 3 和 2，发现它们都已经被标记了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用广度优先搜索查找图中的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 到达该顶点的最短路径是否已知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 到达该顶点的已知路径上的最后一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        bfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 标记起点</span></span><br><span class="line">        marked[s] = <span class="keyword">true</span>; </span><br><span class="line">        <span class="comment">// 将它加入队列</span></span><br><span class="line">        queue.enqueue(s); </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队列中删去下一顶点</span></span><br><span class="line">            <span class="keyword">int</span> v = queue.dequeue(); </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="comment">// 对于每个未被标记的相邻顶点</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    <span class="comment">// 保存最短路径的最后一条边</span></span><br><span class="line">                    edgeTo[w] = v; </span><br><span class="line">                    <span class="comment">// 标记它，因为最短路径已知</span></span><br><span class="line">                    marked[w] = <span class="keyword">true</span>; </span><br><span class="line">                    <span class="comment">// 并将它添加到队列中</span></span><br><span class="line">                    queue.enqueue(w); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">return</span> marked[v]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x]) &#123;</span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-使用场景"><a href="#5-3-使用场景" class="headerlink" title="5.3 使用场景"></a>5.3 使用场景</h3><h2 id="六-连通分量"><a href="#六-连通分量" class="headerlink" title="六. 连通分量"></a>六. 连通分量</h2><hr><p>参考：</p><p>🔗 《算法-第4版》</p>]]></content>
    
    <summary type="html">
    
      内容主要来自《算法-第4版》，内容包括：图，无向图，深度优先搜索，寻找路径，广度优先搜索等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="graph" scheme="http://linyishui.top/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（六）高级特性</title>
    <link href="http://linyishui.top/2021020101.html"/>
    <id>http://linyishui.top/2021020101.html</id>
    <published>2021-02-01T13:16:33.000Z</published>
    <updated>2021-03-03T13:23:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（六）高级特性"><a href="#《高性能MySQL》（六）高级特性" class="headerlink" title="《高性能MySQL》（六）高级特性"></a>《高性能MySQL》（六）高级特性</h1><h2 id="一-分区表"><a href="#一-分区表" class="headerlink" title="一. 分区表"></a>一. 分区表</h2><h3 id="1-1-什么是分区表？"><a href="#1-1-什么是分区表？" class="headerlink" title="1.1 什么是分区表？"></a>1.1 什么是分区表？</h3><p>分区表是一个独立的逻辑表，底层由多个物理子表组成。一组底层表的句柄对象的封装，对分区表的请求通过句柄对象转换为对存储引擎的接口调用。</p><p>MySQL索引根据分区的子表定义，没有全局索引，不能像Oracle那样指定索引和表是否分区。</p><p>创建表时使用 PARTITION BY 子句定义每个分区存放的数据。每次查询时优化器根据分区定义过滤掉其它分区，使查询只须扫描包含数据的分区。</p><h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><ul><li>无法全部放入内存的大表，或是大部分历史数据、只有少量热点数据。</li><li>分区表的数据易于维护，批量删除大量数据可以直接清除整个分区；还可以对一个分区进行优化、检查、修复等操作。</li><li>分区表的数据可以分布在不同的物理设备上。</li><li>使用分区表可以避免一些特殊瓶颈，如InnoDB的单个索引的互斥访问、ext3文件系统的inode锁竞争等。</li><li>可以备份和恢复独立的分区，在大数据集的场景有很好的效果。</li></ul><h3 id="1-3-使用限制"><a href="#1-3-使用限制" class="headerlink" title="1.3 使用限制"></a>1.3 使用限制</h3><ul><li>一个表最多有1024个分区。</li><li>MySQL 5.1中分区表达式必须返回整数，MySQL 5.5的某些场景可以直接使用列进行分区。</li><li>若分区字段中有主键或唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</li><li>分区表无法使用外键约束。</li></ul><h3 id="1-4-实现原理"><a href="#1-4-实现原理" class="headerlink" title="1.4 实现原理"></a>1.4 实现原理</h3><p>分区表由多个相关底层表实现，底层表由句柄对象表示，存储引擎管理分区的各个底层表与普通表相同，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。</p><p>几种操作的逻辑：虽然都要锁住所有底层表，但其实只是行级锁</p><ul><li>SELECT 查询：查询一个分区表时，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后调用对应存储引擎接口访问各个分区的数据。</li><li>INSERT 操作：写入一条记录时，分区层先打开并锁住所有的底层表，然后确定在哪个分区接收这条记录，并把记录写入底层表。</li><li>DELETE 操作：删除一条记录时，分区层先打开并锁住所有底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作。</li><li>UPDATE 操作：更新一条记录时，分区层先打开并锁住所有底层表，MySQL要先确定更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据所在底层表进行删除操作。</li></ul><h3 id="1-5-分区表的类型"><a href="#1-5-分区表的类型" class="headerlink" title="1.5 分区表的类型"></a>1.5 分区表的类型</h3><p>分区表达式可以使用各种函数，但返回值一定要是一个确定的整数，且不能是一个常数（案例使用YEAR函数根据时间进行分区）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqles (</span><br><span class="line">order_date DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">--other columns</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(order_date)) (</span><br><span class="line"><span class="keyword">PARTITION</span> p_2010 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2011 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2011</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_2012 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2012</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p_catchall <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>MySQL支持键值、哈希和列表分区，以及使用 RANGE COLUMNS 类型的分区。</p><p>系统通过子分区可降低索引的互斥访问竞争。最近一年的分区数据会被频繁访问，导致大量的互斥量的竞争。使用哈希子分区可以将数据切成多个小片，大大降低互斥量的竞争问题。</p><h3 id="1-6-合理使用分区表"><a href="#1-6-合理使用分区表" class="headerlink" title="1.6 合理使用分区表"></a>1.6 合理使用分区表</h3><p>假设一个需求：需要从一个大表中查出一段时间的记录，表中包含多年的历史数据，按照时间排序。仅仅几个月的数据可能会有上亿或十亿条记录。</p><p>首先不能每次查询时扫描全表，并且考虑索引在空间和维护上的消耗也不能使用（可能会产生大量的碎片，导致一个查询有成千上万的随机I/O）。</p><p>只能<strong>让所有的查询只在数据表上做顺序扫描</strong>，或者<strong>将数据表和索引都缓存在内存中</strong>。</p><p><strong>数据量大时，除非是索引覆盖查询，否则B-Tree索引无法起作用了，数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，若数据量巨大，这将产生大量随机I/O，导致响应时间过长，并且索引的维护代价也很高</strong>。</p><p>分区可以看作初始形态的索引，以非常小的代价定位到数据在哪一片区域，在区域内可以做顺序扫描、可以建索引、可以将数据缓存到内存。分区无需额外的数据结构记录每个分区有哪些数据（因为不需要精确定位数据位置）。</p><p>保证大数据量可扩展性的策略：</p><ul><li><strong>全量扫描数据，不要任何索引</strong>：只要能用WHERE条件将需要的数据限制在少数分区中，效率是很高的，需要一些简单运算保证响应时间能够满足要求，此策略适用于正常方式访问大量数据时。</li><li><strong>索引数据，并分离热点</strong>：当数据有明显的热点，此外的数据很少会被访问到，可以将这部分热点数据单独放在一个分区，从而有机会全部缓存到内存中，使查询只用访问一个很小的分区表，能够有效的使用索引和缓存。</li></ul><h3 id="1-7-常见问题"><a href="#1-7-常见问题" class="headerlink" title="1.7 常见问题"></a>1.7 常见问题</h3><p>上述两种分区策略都基于查询能够过滤到额外分区、分区本身并不会带来额外的代价，但在一些场景下这两种假设会有问题：</p><ul><li><strong>NULL值使分区过滤无效</strong>：<ul><li>所有的NULL值或非法值会被存放到第一个分区；所以如查询 <code>WHERE order_date BETWEEN &#39;2012-01-01&#39; AND &#39;2012-01-31&#39;</code> 会检查2012分区和第一个分区，因为YEAR函数在接收非法值时可能会返回NULL。</li><li>当第一个分区特别大时，代价会很高，尤其是策略<strong>全量扫描数据，不要任何索引</strong>；为了避免此状况，可以创建一个不用的第一分区，通过 <code>PARTITION p_nulls VALUES LESS THAN(0)</code> 来创建，这样如果插入的数据都是有效的情况下第一分区是空的，即使需要检测第一分区也不会有太高代价。</li></ul></li><li><strong>分区列和索引列不匹配</strong>：二者不匹配会导致查询无法进行分区过滤，比如在列a上定义了索引，在列b上进行分区，这样每个分区都有独立的索引，所以扫描列b上的索引需要扫描每个分区对应的索引，虽然扫描速度并不是特别慢，但还是应该尽量避免建立和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。</li><li><strong>选择分区的成本可能很高</strong>：不同的分区类型实现方式不同，性能也不同；范围分区在判断记录数据属于哪一分区的成本很高，因为服务器要扫描所有的分区定义的列表，这样的线性搜索会随分区数增多成本变高。对于键分区或哈希分区则没有此问题，100个左右的分区数不会有问题。</li><li><strong>打开并锁住所有底层表的成本可能很高</strong>：此操作发生于分区过滤之前，无法通过分区过滤降低开销，对于一些本来很快的操作，如根据主键查询单行，会带来额外的开销；可以通过批量操作的方式来降低单个开销，如批量插入或 LOAD DATA INFILE、一次删除多行数据等，同时需要限制分区的个数。</li><li><strong>维护分区的成本可能很高</strong>：新增或删除分区等操作很快（不包括删除大分区），而重组分区（先创建一个临时分区，然后将数据复制到其中，最后删除原分区）或类似ALTER语句的操作需要复制数据。</li></ul><p>使用分区表的限制：</p><ul><li>所有分区要使用相同的存储引擎；</li><li>分区可以使用的函数或表达式受限；</li><li>一些存储引擎不支持分区或有更多限制；</li></ul><h3 id="1-8-优化查询"><a href="#1-8-优化查询" class="headerlink" title="1.8 优化查询"></a>1.8 优化查询</h3><p>分区这种粗粒度索引可以让查询扫描更少的数据，对于访问分区表来说，重要的一点是WHERE条件中加入分区列，即使看起来很多余，因为这样可以使优化器过滤掉无需访问的分区。</p><p>通过EXPLAIN PARTITION观察优化器是否执行了分区过滤，需要注意的是MySQL只能在使用分区函数的列本身进行比较时才能过滤分区，而不能根据表达式的值去过滤分区：<strong>查询时只能通过列来过滤分区</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--无法过滤分区：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales_by_day <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(<span class="keyword">day</span>) = <span class="number">2010</span></span><br><span class="line"><span class="comment">--可以过滤分区：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales_by_day <span class="keyword">WHERE</span> <span class="keyword">day</span> <span class="keyword">BETWEEN</span> <span class="string">'2010-01-01'</span> <span class="keyword">AND</span> <span class="string">'2010-12-31'</span></span><br></pre></td></tr></table></figure><h3 id="1-9-合并表"><a href="#1-9-合并表" class="headerlink" title="1.9 合并表"></a>1.9 合并表</h3><p>合并表（Merge Table）是简单版的分区实现，分区表是一种逻辑上的概念，用户无法访问底层的各个分区，但用户可以单独访问合并表的各个子表。</p><p>分区表与优化器更紧密结合，而合并表则是要被淘汰的技术。</p><p>后续省略。</p><h2 id="二-视图"><a href="#二-视图" class="headerlink" title="二. 视图"></a>二. 视图</h2><h3 id="2-1-什么是视图？"><a href="#2-1-什么是视图？" class="headerlink" title="2.1 什么是视图？"></a>2.1 什么是视图？</h3><ul><li>视图在MySQL 5.0版本引入；</li><li>本身是虚拟表，不存储数据，访问视图时从实体表获取数据；</li><li>视图与表在同一个命名空间，不能对视图创建触发器；</li></ul><h3 id="2-2-视图的两种实现算法"><a href="#2-2-视图的两种实现算法" class="headerlink" title="2.2 视图的两种实现算法"></a>2.2 视图的两种实现算法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Oceania <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> Oceania <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure><p>视图的两种实现：</p><ul><li><p><strong>临时表算法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> TMP_Oceania <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> TMP_Oceania <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>合并算法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> code, <span class="keyword">name</span> <span class="keyword">FROM</span> Country <span class="keyword">WHERE</span> Continent = <span class="string">'Oceania'</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure></li></ul><p>可以在 <code>EXPLAIN EXTENDED</code> 后使用 <code>SHOW WARNINGS</code> 查看使用视图的查询重写后的结果，临时表算法实现的视图会显示为派生表（DERIVED）：<code>EXPLAIN SELECT * FROM View</code> 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010101.png" alt></p><p>只要无法在原表记录和视图记录建立一对一映射的场景都无法使用临时表算法实现视图，如 GROUP BY，DISTINCT，聚合函数，UNION，子查询等。</p><h3 id="2-3-可更新视图"><a href="#2-3-可更新视图" class="headerlink" title="2.3 可更新视图"></a>2.3 可更新视图</h3><p>可更新视图就是能够通过更新视图来更新视图涉及的表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Oceania <span class="keyword">SET</span> Population = Population * <span class="number">1.1</span> <span class="keyword">WHERE</span> <span class="keyword">Name</span> = <span class="string">'Australia'</span>;</span><br></pre></td></tr></table></figure><p>视图定义包含 GROUP BY，聚合函数，UNION等情况不能更新相关表，所有使用临时表算法实现的视图不能更新，被更新的列必须来自同一张表。</p><p><code>CHECK OPTION</code> 表示任何通过视图更新的行，都必须符合视图本身的WHERE条件定义，不能更新视图定义列外的列。</p><h3 id="2-4-视图对性能的影响"><a href="#2-4-视图对性能的影响" class="headerlink" title="2.4 视图对性能的影响"></a>2.4 视图对性能的影响</h3><p>视图在某些场景也可以帮助提高性能，</p><ul><li><p>重构Schema时使用视图，修改表结构时不会影响应用运行；</p></li><li><p>使用视图实现基于列的权限控制，不需要真正的在系统创建权限，没有额外开销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> XX <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> XXX;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> public.* <span class="keyword">TO</span> public_user;</span><br></pre></td></tr></table></figure></li><li><p>视图并没有看起来那样简单，使用视图提示性能需要做比较详细的测试，临时表算法实现的视图在很多场景下性能很糟糕，合并算法实现的视图也会有额外开销，并且视图的性能很难预测。</p></li></ul><h3 id="2-5-使用视图的一些限制"><a href="#2-5-使用视图的一些限制" class="headerlink" title="2.5 使用视图的一些限制"></a>2.5 使用视图的一些限制</h3><ul><li>MySQL不支持物化视图，指将视图结果数据存放在一个可以查看的表，并定时从原始表刷新数据到这个表；</li><li>MySQL视图不支持创建索引，但可以使用缓存表或汇总表模拟物化视图和索引；</li><li>MySQL不会保存视图定义的原始SQL语句，可以通过使用视图的 <code>.frm</code> 文件最后一行获取信息2，如果有FILE权限，可以直接使用SQL语句的 <code>LOAD_FILE()</code> 读取 <code>.frm</code> 的视图创建信息，再处理掉转义字符等。</li></ul><h2 id="三-外键约束"><a href="#三-外键约束" class="headerlink" title="三. 外键约束"></a>三. 外键约束</h2><p>InnoDB引擎支持外键。</p><p>优点：</p><ul><li>如果想确保两个表始终有一致性的数据，使用外键比在应用中保证一致性要高效的多，级联更新和删除也要更快。</li></ul><p>缺点：</p><ul><li>InnoDB强制外键使用索引，当外键列的选择性很低，会导致一个非常大且选择性很低的索引，且该索引除了做外键限制没有其他作用。</li><li>使用外键需要成本，每次修改数据时都要在另一张表中多执行一次查询操作。</li><li>查询需要额外访问一些表，意味着需要额外的锁。若向子表写入一条记录，外键约束使InnoDB检查父表中对应的记录进行加锁操作，确保该记录不会在事务完成时被删除，会导致额外的锁等待，甚至导致一些难以排查的死锁。</li></ul><p>可以使用触发器来代替外键，当外键只是用作数值约束。如果只是把外键做约束，在应用层实现会更好，因为外键会带来大量的额外消耗，很多过往的经验告诉我们在删除外键时性能会有大幅提升。</p><h2 id="四-在MySQL内部存储代码"><a href="#四-在MySQL内部存储代码" class="headerlink" title="四. 在MySQL内部存储代码"></a>四. 在MySQL内部存储代码</h2><h3 id="4-1-存储代码的方式"><a href="#4-1-存储代码的方式" class="headerlink" title="4.1 存储代码的方式"></a>4.1 存储代码的方式</h3><p>主要区别在于执行的上下文—输入和输出</p><ul><li>触发器</li><li>存储过程：可以接收参数返回值</li><li>函数：可以接收参数返回值</li><li>定时任务 / 事件</li></ul><h3 id="4-2-存储代码的优缺点"><a href="#4-2-存储代码的优缺点" class="headerlink" title="4.2 存储代码的优缺点"></a>4.2 存储代码的优缺点</h3><p>优点：</p><ul><li>服务器内部执行，离数据最近，可以节省带宽和网络延迟；</li><li>这是一种代码重用，方便统一业务规则，保证某些行为总是一致，所以也带来了一定的安全性；</li><li>简化代码的维护和版本更新；</li><li>帮助提升安全性，提供了更细粒度的权限控制，应用可以通过存储过程的接口访问没有权限的表；</li><li>服务器端可以缓存存储过程的执行计划，降低了需要反复调用的过程的消耗；</li><li>在服务器端部署，备份和维护都在服务器端完成；</li><li>可以在应用开发和数据库开发间更好的分工。</li></ul><p>缺点：</p><ul><li>MySQL没有提供好用的开发和调试工具，编写存储代码难度较高；</li><li>存储代码相比应用代码效率要差一些，很难实现复杂逻辑；</li><li>存储代码可能会带来额外的复杂性，原本只需部署应用代码和库表结构变更，还需要额外部署内部存储代码；</li><li>部署在服务器会带来安全隐患，只要破解数据库就将功能和数据全部获取；</li><li>存储过程给数据库服务器带来额外的压力，数据库服务器的扩展性要远差于应用服务器。</li><li>无法控制存储程序的资源消耗，可能一个错误就把服务器拖死。</li><li>存储代码的实现有很多限制，调试也很困难，难以定位问题。</li><li>与基于语句的二进制日志复制合作的不好。</li></ul><h3 id="4-3-存储过程和函数"><a href="#4-3-存储过程和函数" class="headerlink" title="4.3 存储过程和函数"></a>4.3 存储过程和函数</h3><p>优化器对存储代码的限制：</p><ul><li>优化器无法使用关键字DETERMINISTIC来优化单个查询中多次调用存储函数的情况。</li><li>优化器无法评估存储函数的执行成本。</li><li>每个连接都有独立的存储过程的执行计划缓存，如果有多个连接需要调用同一个存储过程，就会浪费空间来反复缓存同样的执行计划（连接池或持久化连接会造成缓存更长的生命周期）。</li><li>存储过程和复制是一对诡异的组合，最好不要复制对存储程序的调用，直接复制其改变的数据。MySQL 5.1 后引入行复制。</li></ul><h3 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a>4.4 触发器</h3><h4 id="4-4-1-什么是触发器？"><a href="#4-4-1-什么是触发器？" class="headerlink" title="4.4.1 什么是触发器？"></a>4.4.1 什么是触发器？</h4><ul><li>触发器可以让你在执行 INSERT、UPDATE或DELETE时，执行一些特定的操作。</li><li>可以指定是在SQL语句前或后触发，触发器本身没有返回值，但可以读取或改变触发SQL语句所影响的数据。</li><li>使用触发器可以减少客户端和服务器之间的通信，简化应用逻辑，一定程度上提高性能。</li></ul><h4 id="4-4-2-使用注意"><a href="#4-4-2-使用注意" class="headerlink" title="4.4.2 使用注意"></a>4.4.2 使用注意</h4><ul><li>对每个表的每个事件，最多只能定义一个触发器（如不能再AFTER INSERT上定义两个触发器）。</li><li>MySQL只支持基于行的触发，即触发器始终针对一条记录，而不是针对整个SQL语句，当数据集变得很大时，效率会很低。</li><li>触发器会掩盖服务器背后很多工作，而触发器的问题很难排查。</li><li>触发器可能会导致死锁和锁等待，触发器执行失败会导致SQL也失败，但不会有直接明确的提示。</li><li>触发器在InnoDB表上是在同一个事务中完成的，执行操作是原子的，原子操作和触发器操作会同时失败或成功。</li><li>在InnoDB上使用触发器去检查数据一致性要小心MVCC，可能会得到错误结果。</li></ul><h3 id="4-5-事件"><a href="#4-5-事件" class="headerlink" title="4.5 事件"></a>4.5 事件</h3><ul><li>MySQL 5.1 引入事件作为一种新的存储代码的方式，MySQL内部实现的类似于Linux的定时任务。</li><li>指定MySQL在某个时间执行一段SQL代码，或者每隔一个时间间隔。其中复杂的SQL封装在一个存储过程中，事件执行时只需做一个简单的调用。</li><li>事件在一个独立事件调度线程中被初始化，该线程和处理连接的线程没有关系，它不接收任何参数，也没有任何返回值。可以在MySQL的日志中看到命令的执行日志，在表 INFORMATION_SCHEMA.EVENTS 中看到各个事件状态。</li><li>事件实现机制本身开销不大，但事件需要执行SQL，这可能会对性能有很大影响；事件和其他存储程序一样，在和基于语句的复制一起工作时可能会导致一些问题。</li><li>定时事件可能会执行很久，前一个事件未执行完，后一个事件开始执行，开发要自己处理这种情况下的并发（可以使用 <code>GET_LOCK()</code> 确保当前总是只有一个事件在执行-加锁）。</li><li>通过 <code>SET GLOBAL event_scheduler := 1;</code> 设置事件调度线程，设置后此线程执行各个用户指定的事件中的各段SQL代码。</li><li>事件调度本身是一个单独的线程，MySQL创建一个新的进程用于事件执行，进程和线程的生命周期是事件的执行过程，状态总为 Connect 。</li></ul><h2 id="五-游标"><a href="#五-游标" class="headerlink" title="五. 游标"></a>五. 游标</h2><p>暂略。</p><h2 id="六-绑定变量"><a href="#六-绑定变量" class="headerlink" title="六. 绑定变量"></a>六. 绑定变量</h2><h3 id="6-1-什么是绑定变量？"><a href="#6-1-什么是绑定变量？" class="headerlink" title="6.1 什么是绑定变量？"></a>6.1 什么是绑定变量？</h3><ul><li><p>MySQL 4.1 版本引入绑定变量（prepared statement），用于提高客户端和服务器端数据传输的效率。</p></li><li><p>流程：创建一个绑定变量的SQL时，客户端向服务端发送一个SQL语句的原型；服务端收到后，解析并存储这个SQL语句的部分执行计划，返回给客户端一个SQL语句处理句柄，以后每次执行此类查询，客户端都指定使用这个句柄。</p></li><li><p>语法：用问号标记可以接收参数的位置，通过向服务器端发送各个问号的取值和这个SQL的句柄来执行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb1(col1, col2, col3) <span class="keyword">VALUES</span> (?, ?, ?);</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-绑定变量为何能提高性能？"><a href="#6-2-绑定变量为何能提高性能？" class="headerlink" title="6.2 绑定变量为何能提高性能？"></a>6.2 绑定变量为何能提高性能？</h3><ul><li>在服务器端只需解析一次SQL语句。</li><li>在服务器端某些优化器的工作只需执行一次，因为会缓存一部分执行计划。</li><li>以二进制的方式只发送参数和句柄，比每次都发送ASCII码文本效率要高，比如一个二进制的日期只需三个字节，而后者则需要十个字节；可以分块传输，而无需一次性传输；还节省了将数据从原始格式转为文本格式的开销。</li><li>只传输参数，而不是整个语句，网络开销降低。</li><li>MySQL直接将参数存储到缓存，不需要在内存中多次复制。</li></ul><h3 id="6-3-优化"><a href="#6-3-优化" class="headerlink" title="6.3 优化"></a>6.3 优化</h3><p>比如当执行计划需要根据传入的参数计算时，MySQL无法缓存这部分计划。</p><p>根据优化器工作阶段，划分三类优化：</p><ol><li><strong>准备阶段</strong>：服务器解析SQL语句，移除不可能条件，并且重写子查询。</li><li><strong>第一次执行</strong>：服务器先简化嵌套循环的关联，并将外关联转换成内关联。</li><li><strong>每次SQL语句执行</strong>：<ul><li>过滤分区</li><li>尽量移除 <code>COUNT()</code> 、<code>MIN()</code> 和 <code>MAX()</code> </li><li>移除常数表达式</li><li>做必要的等值传播</li><li>分析和优化 ref 、range 和索引优化等访问数据的方法</li><li>优化关联顺序</li></ul></li></ol><h3 id="6-4-SQL接口的绑定变量"><a href="#6-4-SQL接口的绑定变量" class="headerlink" title="6.4 SQL接口的绑定变量"></a>6.4 SQL接口的绑定变量</h3><p>MySQL 在 4.1 版本中支持了SQL接口的绑定变量，不需要使用二进制传输协议也可以直接以SQL的方式使用绑定变量。</p><p>服务器会将SQL语句翻译，无需使用二进制协议：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> := <span class="string">'SELECT actor_id, first_name, last_name FROM actor WHERE first_name = ?'</span>;</span><br><span class="line"><span class="keyword">PREPARE</span> stmt_fetch_actor <span class="keyword">FROM</span> @<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SET</span> @actor_name := <span class="string">'Penelope'</span></span><br><span class="line"><span class="keyword">EXECUTE</span> stmt_fetch_actor <span class="keyword">USING</span> @actor_name;</span><br><span class="line">DEALLOATE <span class="keyword">PREPARE</span> stmt_fetch_actor;</span><br></pre></td></tr></table></figure><p>这种写法的主要用途是在存储过程中使用，可以灵活的拼接字符串等参数构建SQL语句，除此外相比二进制协议就没什么优势了。</p><p>使用限制：</p><ul><li>绑定变量是会话级别，连接之间不能共用绑定变量句柄。一旦连接断开，原来的句柄也不能使用，使用连接池和持久化连接可以缓解此问题。</li><li>MySQL 5.1 之前版本，绑定变量的SQL不能使用查询缓存。</li><li>只执行一次的SQL，使用绑定变量会多一次额外的准备阶段消耗，和一次额外的网络开销。</li><li>不能在存储函数中使用。</li><li>未释放的绑定变量资源容易造成资源泄露，对所有线程造成影响。</li><li>如BEGIN等操作无法在绑定变量中完成。</li></ul><h3 id="6-5-三种绑定变量的区别"><a href="#6-5-三种绑定变量的区别" class="headerlink" title="6.5 三种绑定变量的区别"></a>6.5 三种绑定变量的区别</h3><ul><li><strong>客户端模拟的绑定变量</strong>：接收一个带参数的SQL，将指定的值带入，最后将完整的查询发送到服务器端。</li><li><strong>服务端的绑定变量</strong>：客户端使用特殊的二进制协议将带参数的字符串发送到服务器端，然后使用二进制协议将具体的参数值发送给服务器端并执行。</li><li><strong>SQL接口的绑定变量</strong>：客户端先发送一个带参数的字符串到服务器，类似于使用PREPARE的SQL语句，然后发送设置参数的SQL，最后使用EXECUTE来执行SQL，使用普通的文本传输协议。</li></ul><h2 id="七-用户自定义函数"><a href="#七-用户自定义函数" class="headerlink" title="七. 用户自定义函数"></a>七. 用户自定义函数</h2><p>暂略。</p><h2 id="八-插件"><a href="#八-插件" class="headerlink" title="八. 插件"></a>八. 插件</h2><p>暂略。</p><h2 id="九-字符集和校对"><a href="#九-字符集和校对" class="headerlink" title="九. 字符集和校对"></a>九. 字符集和校对</h2><p>暂略。</p><h2 id="十-全文索引"><a href="#十-全文索引" class="headerlink" title="十. 全文索引"></a>十. 全文索引</h2><h3 id="10-1-什么是全文索引？"><a href="#10-1-什么是全文索引？" class="headerlink" title="10.1 什么是全文索引？"></a>10.1 什么是全文索引？</h3><ul><li><strong>场景</strong>：如果想要通过关键字的匹配来进行查询过滤，需要基于相似度的查询而不是精确的数据比较，全文索引专为此场景设计。</li><li><strong>支持</strong>：各种字符串内容的搜索，包括CHAR、VARCHAR和TEXT类型，支持自然语言搜索和布尔搜索。</li><li>互联网搜索引擎技术和全文索引基本原理相同。</li></ul><h3 id="10-2-自然语言的全文索引"><a href="#10-2-自然语言的全文索引" class="headerlink" title="10.2 自然语言的全文索引"></a>10.2 自然语言的全文索引</h3><p>该引擎会计算每一个文档对象和查询的相关度，相关度基于匹配的关键词个数，以及关键词在文档中出现的次数。出现次数越少的词语，匹配时的相关度就越高，常见的词语将不会搜索（超过50%的记录都出现），即使不在停用词列表中出现。</p><p>可以根据WHERE子句中的MATCH AGAINST来区分查询是否使用全文索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> film_text;</span><br><span class="line"><span class="comment">--index_type为FULLTEXT，假设两个字段title, description建立了全文索引</span></span><br><span class="line"><span class="keyword">select</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>), <span class="keyword">MATCH</span>(title, description) AGAINST(<span class="string">'factory casualties'</span>) <span class="keyword">AS</span> relevance </span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description) AGAINST(<span class="string">'factory casualties'</span>);</span><br><span class="line"><span class="comment">--MySQL将搜索词语分为两个独立的关键词进行搜索，函数MATCH()会返回关键词匹配的相关度</span></span><br></pre></td></tr></table></figure><p>在MATCH函数中指定的列必须和全文索引指定的列相同，否则无法使用全文索引，因为全文索引不会记录关键字来自哪一列。也意味着无法使用全文索引来查询某个关键字是否在某一列中存在。</p><h3 id="10-3-布尔全文索引"><a href="#10-3-布尔全文索引" class="headerlink" title="10.3 布尔全文索引"></a>10.3 布尔全文索引</h3><p>用户可以在布尔搜索的查询中自定义某个被搜索词语的相关性，通过停用词列表过滤掉“噪声”词，要求搜索关键词长度需要大于 <code>ft_min_word_len</code> 且小于 <code>ft_max_word_len</code> ，搜索结果未经排序。</p><p>通过<strong>前缀修饰符</strong>来定制布尔搜索：</p><ul><li>dinosaur：包含dinosaur的行rank值更高</li><li>~dinosaur：包含dinosaur的行rank值更低</li><li>+dinosaur：行记录必须包含dinosaur</li><li>-dinosaur：行记录不可以包含dinosaur</li><li>dino*：包含以dino开头的单词的行rank值更高</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询必须同时包含factory和casualties</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description)</span><br><span class="line">AGAINST(<span class="string">'+factory +casualties'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询中使用括号进行短语搜索</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, title, <span class="keyword">RIGHT</span>(description, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">FROM</span> film_text</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, description)</span><br><span class="line">AGAINST(<span class="string">'"spirited casualties"'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure><p>短语搜索较慢，因为单使用全文索引无法判断是否精确匹配到短语，通常还要查询原文确定记录是否包含完整的短语，因为需要回表过滤，所以效率不高。</p><h3 id="10-4-使用限制"><a href="#10-4-使用限制" class="headerlink" title="10.4 使用限制"></a>10.4 使用限制</h3><ul><li>全文索引只能通过词频来判断相关性，索引不会记录索引词在字符串的位置。</li><li>全文索引只有全部在内存中时才有较好的性能，使用精确短语搜索时，需要数据和索引都在内存中。</li><li>全文索引相比其他索引在 INSERT、UPDATE 和 DELETE 操作的代价都很大：<ul><li>修改文本中的100个单词，需要100次索引操作，而不是一次。</li><li>一般情况，列长度不会影响其他索引类型，但对于全文索引，个位数单词文本和10000个单词的文本，性能可能相差几个数量级。</li><li>全文索引有更多碎片，可能需要做更多的 <code>OPTIMIZE TABLE</code> 操作。</li></ul></li><li>全文索引影响优化器：<ul><li>查询中使用了 <code>MATCH AGAINST</code> 子句，对应列有可用的全文索引，这种情况一定会使用全文索引，即使可能有性能更好的其他索引。</li><li>全文索引只能用作全文搜索匹配，任何其他操作，如WHERE条件比较，都需要在MySQL完成全文搜索返回记录后才能进行，普通索引可以在处理WHERE条件时一次判断多个比较表达式。</li><li>全文索引不存储索引列的实际值，索引不能用作索引覆盖扫描。</li><li>除了相关性排序，全文索引不能用于其他排序。</li></ul></li></ul><h2 id="十一-分布式（XA）事务"><a href="#十一-分布式（XA）事务" class="headerlink" title="十一. 分布式（XA）事务"></a>十一. 分布式（XA）事务</h2><h3 id="11-1-MySQL中的XA事务"><a href="#11-1-MySQL中的XA事务" class="headerlink" title="11.1 MySQL中的XA事务"></a>11.1 MySQL中的XA事务</h3><p>存储引擎的事务特性能保证在存储引擎级别实现ACID，分布式事务则可以扩展到数据库层面，以及多个数据库之间。通过<strong>两阶段提交</strong>来实现。</p><p>MySQL 在 5.0 版本支持 XA 事务，XA事务需要有一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）；如果协调器收到所有参与者都准备好的消息，就会告诉事务可以提交了（第二阶段）。MySQL在 XA 事务中的角色是参与者而不是协调者。</p><h3 id="11-2-内部XA事务"><a href="#11-2-内部XA事务" class="headerlink" title="11.2 内部XA事务"></a>11.2 内部XA事务</h3><h4 id="（1）二进制日志在使用XA事务"><a href="#（1）二进制日志在使用XA事务" class="headerlink" title="（1）二进制日志在使用XA事务"></a>（1）二进制日志在使用XA事务</h4><p>MySQL本身的插件式架构导致其内部需要使用XA事务。MySQL中各个存储引擎相互独立，无法感知对方的存在，所以一个跨存储引擎的事务需要一个外部的协调者，否则无法满足ACID。</p><p>存储引擎提交的同时，需要将提交信息写入二进制日志，这就是一个分布式事务，可以把二进制日志操作看作一个独立的存储引擎。</p><h4 id="（2）XA事务影响性能"><a href="#（2）XA事务影响性能" class="headerlink" title="（2）XA事务影响性能"></a>（2）XA事务影响性能</h4><p>XA事务导致MySQL性能大幅下降，直接破坏了MySQL内部的批量提交（一种通过单磁盘I/O操作完成多个事务提交的技术，已有多种解决方案），使得MySQL不得不进行多次额外的 <code>fsync()</code> 调用。</p><p>一个事务若是开启了二进制日志，不仅需要对二进制日志进行持久化操作，InnoDB事务日志还需要两次日志持久化操作。即<strong>二进制日志安全的事务实现需要至少三次 <code>fsync()</code> 操作。</strong></p><h4 id="（3）配置项"><a href="#（3）配置项" class="headerlink" title="（3）配置项"></a>（3）配置项</h4><p>可以通过将 <code>innodb_support_xa</code> 设置为0 关闭二进制日志（复制需要二进制日志和XA事务的支持，所以此设置也会使复制无法使用）。</p><p>将 <code>sync_binlog</code> 设置为1，保证存储引擎和二进制日志是真正同步的。否则事务提交了二进制日志却可能未“提交”到磁盘。</p><h3 id="11-3-外部XA事务"><a href="#11-3-外部XA事务" class="headerlink" title="11.3 外部XA事务"></a>11.3 外部XA事务</h3><p>MySQL能够作为参与者完成一个外部的分布式事务，但其对XA协议的支持还不完整，如当前版本还不支持一个事务中多个连接可以做关联。</p><p>因为通信延迟和参与者本身可能失败，外部XA事务会比内部的消耗更大。对于网络环境不稳定或用户长时间等待而不提交，需要避免使用XA事务，它会影响所有参与者。</p><p>XA事务是一种在多个服务器之间同步数据的方法，不能使用MySQL本身的复制，以及性能非瓶颈时可以尝试使用。</p><h2 id="十二-查询缓存"><a href="#十二-查询缓存" class="headerlink" title="十二. 查询缓存"></a>十二. 查询缓存</h2><h3 id="12-1-什么是查询缓存？"><a href="#12-1-什么是查询缓存？" class="headerlink" title="12.1 什么是查询缓存？"></a>12.1 什么是查询缓存？</h3><p>MySQL可以缓存查询的执行计划，相同类型的SQL可以跳过SQL的解析和执行计划生成阶段；查询缓存是另一种缓存类型，缓存完整的SELECT结果。</p><p>命中查询缓存后会直接返回结果，跳过了解析、优化和执行阶段。</p><p>查询缓存系统会跟踪查询涉及的每张表，当表发生变化会导致相关的缓存数据失效；虽然看起来这种实现比较低效率，因为表变化时未必会导致数据查询结果有变更，但这样的实现代价很小。</p><p>查询缓存对于应用程序来说是完全透明的。</p><h3 id="12-2-谨慎使用查询缓存"><a href="#12-2-谨慎使用查询缓存" class="headerlink" title="12.2 谨慎使用查询缓存"></a>12.2 谨慎使用查询缓存</h3><p>查询缓存是一个影响服务器扩展性的因素，可能会变成整个服务器的资源竞争点，在多核服务器上甚至可能导致服务器僵死。默认建议关闭查询缓存，如果判断查询缓存很有作用，也应该只配置一个较小的查询缓存空间（如几十兆）。</p><h3 id="12-3-MySQL如何判断缓存命中？"><a href="#12-3-MySQL如何判断缓存命中？" class="headerlink" title="12.3 MySQL如何判断缓存命中？"></a>12.3 MySQL如何判断缓存命中？</h3><p>缓存存放在一个引用表中，通过一个哈希值引用，哈希值包括查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能会影响返回结果的信息。</p><p>当判断缓存是否命中时，MySQL不会解析、正规化或参数化查询语句，而是直接使用SQL语句和其他收到的原始信息来判断。<strong>任何字符上的不同，如空格、注释等都会导致缓存不命中</strong>。</p><p>当查询语句中有一些不确定的数据时，不会被缓存。如函数 <code>NOW()</code> 或 <code>CURRENT_DATE()</code> 的查询不会被缓存，以及 <code>CURRENT_USER</code> 或 <code>CONNECTION_ID()</code> 。总结，<strong>查询包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库的系统表，或任何包含列级别权限的表，都不会被缓存</strong>。</p><p>MySQL并不解析SQL，它如何知道查询中含有不确定的函数？MySQL通过一个大小写不敏感的检查确认SQL语句是否以SEL开头。查询缓存是在完整的SELECT语句基础之上，只有在刚收到SQL语句时检查，所以子查询和存储过程都无法使用查询缓存。</p><h3 id="12-4-使用限制"><a href="#12-4-使用限制" class="headerlink" title="12.4 使用限制"></a>12.4 使用限制</h3><ul><li>开启查询缓存会对读写操作都带来额外的消耗：<ul><li>读查询在开始前要检查是否命中缓存；</li><li>读查询可以被缓存，在执行完成后，MySQL检查还未被缓存，会将结果存入查询缓存；</li><li>向某个表写入数据时，MySQL要将相关缓存设置失效。如果查询缓存很大或者碎片很多</li></ul></li><li>对查询缓存操作是一个加锁排他操作。</li><li>事务中修改某表会使对应查询缓存都设置失效，但InnoDB的多版本特性会暂时将这个修改对其他事务屏蔽，此事务提交前，这个表的相关查询无法被缓存，只能在事务提交后才被缓存。因此，长时间运行的事务会大大降低查询缓存的命中率。</li><li>查询缓存可能会使用大量的内存，并且因为操作靠一个全局锁保护，所有需要做该操作的查询都要等待这个锁。</li></ul><h3 id="12-5-查询缓存如何使用内存"><a href="#12-5-查询缓存如何使用内存" class="headerlink" title="12.5 查询缓存如何使用内存"></a>12.5 查询缓存如何使用内存</h3><p>查询缓存全部存储在内存中。除了查询结果，还要存放一些维护相关的数据，类似于文件系统：（大概需要40KB的内存资源）</p><ul><li>确定哪些内存目前可用；</li><li>哪些已经用掉；</li><li>哪些用来存储数据表和查询结果之前的映射；</li><li>哪些用来存储数据表和查询结果之前的映射；</li><li>哪些用来存储查询字符串和查询结果。</li></ul><p>MySQL用于查询缓存的内存被分为一个个的数据块，数据块是变长的。每个数据块存储了自己的类型、大小和数据本身，还外加指向前一个和后一个数据块的指针。</p><p>数据块类型：不同存储块在内存使用上没有不同</p><ul><li>存储查询结果</li><li>存储查询和数据表的映射</li><li>存储查询文本</li></ul><p>使用流程：</p><ul><li>服务器启动时，先初始化查询缓存需要的内存，内存池初始是一个完整的空闲块。空闲块的大小就是所配置查询缓存大小再减去用于维护元数据的数据结构所消耗的空间。</li><li>当有查询结果需要缓存时，MySQL先从大的空间块中申请一个数据块用于存储结果。这个数据块需要大于配置 <code>query_cache_min_res_unit</code> ，即使查询结果远远小于此。因为需要在查询开始返回结果的时候就分配空间，此时是无法预知查询结果有多大，MySQL无法为每个查询结果精确分配空间。</li></ul><p>分配内存块操作很慢，需要先锁住空间块，然后找到合适大小的数据块。当需要缓存一个查询结果时，MySQL先选择一个尽可能小的内存块，然后将结果存入其中。如果数据块全部用完，但仍有数据需要存储，MySQL会申请一块新数据块（尽量小）。查询完成后有剩余会被释放。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010102.png" alt></p><p>上述分配内存块并非指<strong>通过函数 <code>malloc()</code> 向操作系统申请内存</strong>，此操作只在初次创建查询缓存时执行一次。指的是在空闲块列表中找到一个合适的内存块，或者从正在使用的、待淘汰的内存块中回收再使用（MySQL自己管理内存）。</p><p>假设平均查询结果很小，服务器在并发地向不同的两个连接返回结果，返回结果后MySQL回收剩余数据块空间时会发现，回收的数据块小于 <code>query_cache_min_res_unit</code> ，所以不能直接在后续的内存块中分配使用：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010103.png" alt></p><h3 id="12-6-适用场景"><a href="#12-6-适用场景" class="headerlink" title="12.6 适用场景"></a>12.6 适用场景</h3><p>理论上可以通过对比打开和关闭查询缓存的系统效率来判断：关闭查询缓存时，每个查询都需要完整的执行，每次写操作执行完成后立刻返回；打开查询缓存时，每次读请求先检查缓存是否命中，如果命中则立刻返回，否则就完整地执行查询，每次写操作则需要检查查询缓存中是否有需要失效的缓存，然后再返回。</p><p>对于一些需要消耗大量资源的查询通常都适合使用缓存，如汇总计算查询 <code>COUNT()</code> ；较为复杂的SELECT语句，如多表JOIN后还需要做排序和分页，此类查询每次执行消耗都很大，但返回结果集很小，非常适合查询缓存（UPDATE、DELETE 和 INSERT 操作要占比小）。</p><p>一个判断查询缓存是否有效的直接数据是命中率，即使用查询缓存返回结果占总查询的比率。当MySQL接收到一个SELECT查询时，要么增加 <code>Qcache_hits</code> 的值，要么增加 <code>Com_select</code> 的值。计算查询缓存命中率： <code>Qcache_hits / ( Qcache_hits + Com_select )</code> 。命中率多大才合适很难判断，有时即使很低的命中率对于性能提升也有好处。</p><p>缓存未命中的几种可能：</p><ul><li>查询语句无法被缓存，如包含不确定的函数、查询结果太大而无法缓存，都会导致状态值 <code>Qcache_not_cached</code> 增加。</li><li>MySQL从未处理这个查询，所以结果也不曾被缓存过。</li><li>虽然缓存了结果，但由于查询缓存的内存用完，需要将某些缓存移除；或是数据表被修改导致缓存失效。</li><li>大量缓存未命中，但实际上绝大数查询都缓存了：<ul><li>查询缓存还未完成预热；</li><li>查询语句之前从未执行，若应用不会重复执行一条查询语句，即使完成预热仍会有很多缓存未命中；</li><li>缓存失效操作过多。</li></ul></li></ul><p>几种检查方案：</p><ul><li>通过参数 <code>Com_*</code> 来查看数据修改的情况，包括 Com_update，Com_delete等。</li><li>通过 <code>Qcache_lowmem_prunes</code> 来查看有多少次失效是由于内存不足导致的。</li><li>通过查看 <code>Com_select</code> 和 <code>Qcache_inserts</code> 的相对值来查看是否缓存结果未被其他SELECT语句使用。如果每次查询都是缓存未命中，然后需要将查询结果放到缓存中，那么二者值应该相当，所以期望的情况应该是 <code>Qcache_inserts</code> 远远小于 <code>Com_select</code> 。</li><li>更直观的方案：命中和写入的比率，即 <code>Qcache_hits</code> 和 <code>Qcache_inserts</code> 的比值，当结果大于3 : 1时一般表示缓存是有效的，最好是能达到10 : 1。</li></ul><h3 id="12-7-配置和维护"><a href="#12-7-配置和维护" class="headerlink" title="12.7 配置和维护"></a>12.7 配置和维护</h3><p>配置参数：</p><ul><li>query_cache_type：是否打开查询缓存，有 OFF、ON或DEMAND，DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才放入查询缓存。</li><li>query_cache_size：查询缓存使用的总内存空间，单位为字节，必须是1024的整数倍。</li><li>query_cache_min_res_unit：在查询缓存中分配内存块时的最小单位。</li><li>query_cache_limit：MySQL能缓存的最大查询结果，超过此值不会被缓存，只有结果全部返回时才能知道是否超出限制。</li><li>query_cache_wlock_invalidate：某个表被其他连接锁住，是否依然可以从查询缓存中返回结果。</li></ul><p>如何减少碎片：暂略。</p><p>提供查询缓存的使用率：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210201/202102010104.png" alt></p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：分区表，视图，外键约束，内部存储代码，游标，绑定变量，用户自定义函数，全文索引，分布式事务，查询缓存等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（五）查询性能优化</title>
    <link href="http://linyishui.top/2020122901.html"/>
    <id>http://linyishui.top/2020122901.html</id>
    <published>2020-12-29T12:13:34.000Z</published>
    <updated>2021-03-03T13:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（五）查询性能优化"><a href="#《高性能MySQL》（五）查询性能优化" class="headerlink" title="《高性能MySQL》（五）查询性能优化"></a>《高性能MySQL》（五）查询性能优化</h1><p>查询优化、索引优化、库表结构优化需要齐头并进。</p><h2 id="一-为什么查询速度会慢"><a href="#一-为什么查询速度会慢" class="headerlink" title="一. 为什么查询速度会慢"></a>一. 为什么查询速度会慢</h2><p>查询是一项任务，由一系列子任务组成，每个子任务都要消耗一定时间，优化查询就是要么消除一部分子任务、要么减少子任务的执行次数、要么提供子任务的执行速度。</p><p>查询的生命周期大致包括：从客户端、到服务器、服务器进行解析、生成执行计划、执行、返回结果给客户端。其中执行是最重要的阶段，包括大量检索数据到存储引擎以及后续数据处理，如排序、分组等。</p><p>查询会在如网络、CPU计算、生成统计信息和执行计划、锁等待（互斥等待）等操作上花费时间。慢查询普遍都会存在如操作被额外的重复执行了多次、某些操作执行的太慢等问题。</p><h2 id="二-优化数据访问"><a href="#二-优化数据访问" class="headerlink" title="二. 优化数据访问"></a>二. 优化数据访问</h2><p>大部分性能低下的查询都可以通过减少访问的数据量来优化：</p><ol><li>检查是否访问了太多的行或列；</li><li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li></ol><h3 id="2-1-是否向数据库请求了不需要的数据"><a href="#2-1-是否向数据库请求了不需要的数据" class="headerlink" title="2.1 是否向数据库请求了不需要的数据"></a>2.1 是否向数据库请求了不需要的数据</h3><ul><li><strong>查询不需要的记录</strong>：比如查询大量数据后，再仅显示前面N行。最简单的解决方案是查询加LIMIT。</li><li><strong>多表关联时返回全部列</strong>：比如 SELECT <em> FROM A JOIN B JOIN C ，实际上仅需要A表的列，改为 SELECT A.</em> 最好明确指定每个返回列。</li><li><strong>总是取出全部列</strong>：每次使用 <code>SELECT *</code> 时都要仔细思考是否需要全部列，有时DBA会禁止类似写法。</li><li><strong>重复查询相同的数据</strong>：比如用户评论时要获取头像URL，可以考虑缓存这类数据，避免每次都要重复查询。</li></ul><h3 id="2-2-是否在扫描额外的记录"><a href="#2-2-是否在扫描额外的记录" class="headerlink" title="2.2 是否在扫描额外的记录"></a>2.2 是否在扫描额外的记录</h3><p>衡量查询开销的三个指标：慢查询日志包含这三项内容</p><ul><li><strong>响应时间</strong>：服务时间+排队时间，但实际测量往往无法区分二者；</li><li><strong>扫描的行数</strong>：EXPLAIN的type列反应了访问类型，如全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等，速度由慢至快，扫描行数由多到少；访问类型不够合适时，最好创建一个合适的索引；<strong>MySQL不会返回真实的扫描行数，只会告知生成结果时一共扫描了多少行，但可能大部分行是被WHERE条件过滤</strong>；</li><li><strong>返回的行数</strong>：扫描的行数和返回行数的比值通常应该很小，介于1:1和1:10之间，当然有时也会很大（比如分组统计查询）。</li></ul><p>EXPLAIN的 Using where 表示MySQL将通过WHERE条件筛选存储引擎返回的记录，MySQL应用Where条件有三种方式，由好到坏依次是：</p><ol><li>在索引中使用WHERE条件来过滤不匹配的记录，在存储引擎层完成。</li><li>使用索引覆盖扫描（Extra列出现Using index）返回记录，直接从索引中过滤不需要的记录并返回命中的结果，在服务器层完成，但无需回表查询记录。</li><li>从数据表返回数据，过滤不满足条件的记录（Extra列出现Using where），在服务器层完成，需要先从数据表读出记录然后过滤。</li></ol><p>扫描行数远远大于返回行数，需要优化：</p><ul><li>使用索引覆盖扫描。</li><li>改变库表结构，如使用单独的汇总表。</li><li>重写复杂查询，让MySQL优化器可以以更优化的方式执行。</li></ul><h3 id="2-3-重构查询的方式"><a href="#2-3-重构查询的方式" class="headerlink" title="2.3 重构查询的方式"></a>2.3 重构查询的方式</h3><h4 id="2-3-1-判断一个复杂查询还是多个简单查询"><a href="#2-3-1-判断一个复杂查询还是多个简单查询" class="headerlink" title="2.3.1 判断一个复杂查询还是多个简单查询"></a>2.3.1 判断一个复杂查询还是多个简单查询</h4><p>设计查询时需要考虑的一个问题是：是否需要将一个复杂查询拆分为多个简单查询？我们普遍会选择让数据库尽可能的完成更多的工作，因为下意识会认为网络通信、查询解析和优化是一件代价很高的事情。</p><p>但对于MySQL来说，这种常识是不准确的：</p><ol><li>MySQL的连接和断开都很轻量；</li><li>现代网络速度越来越快，无论是带宽还是延迟；</li><li>MySQL每秒能在内存扫描上百万行数据，相比下响应数据给客户端要慢很多，其他条件不变的情况下越少查询是更好；</li><li>一些情况下切为小查询能减少工作量，并且能够带来整体性能的提升，小事务经常能更高效，并且若中间暂停一段时间，也可以把一次性的压力分散到大的时间段，降低对服务器的影响和锁的持有时间。</li></ol><h4 id="2-3-2-切分查询"><a href="#2-3-2-切分查询" class="headerlink" title="2.3.2 切分查询"></a>2.3.2 切分查询</h4><p>最常见的案例，比如要<strong>定期清除大量数据</strong>，如果一个语句一次完成可能会锁住很多数据、占满整个事务日志、消耗过多系统资源、阻塞很多小但重要的查询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一万行删除一次</span></span><br><span class="line">rows_affected = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">rows_affected = do_query(<span class="string">"DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-分解关联查询"><a href="#2-3-3-分解关联查询" class="headerlink" title="2.3.3 分解关联查询"></a>2.3.3 分解关联查询</h4><p><strong>对每个表进行一次单表查询，在应用层对结果进行关联</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--关联查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post</span><br><span class="line"><span class="keyword">ON</span> tag_post.tag_id = tag.tag_id</span><br><span class="line"><span class="keyword">JOIN</span> post</span><br><span class="line"><span class="keyword">ON</span> tag_post.post_id = post.post_id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="comment">--分解为三次单表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post_id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>让缓存效率更高，单表结果方便进行缓存，已缓存的数据下次就可以跳过；关联的表发生变化会使MySQL查询缓存失效；</li><li>查询分解后可以减少锁的竞争；</li><li>应用层做关联更容易对数据库进行拆分，方便高性能和可扩展；</li><li>查询效率本身也有提升，上述例子使用 <code>IN()</code> 代替关联查询可以使MySQL按照ID顺序查询，要比随机关联高效。</li><li>减少冗余记录的查询，在应用层做关联意味着某条记录只需查询一次，而在数据库关联查询可能需要重复的访问一部分数据。</li></ul><p>适用场景：</p><ul><li>应用方便缓存单个查询的结果时；</li><li>可以将数据分布到不同的MySQL服务器时；</li><li>能够使用 <code>IN()</code> 代替关联查询时；</li><li>当查询中使用同一个数据表时。</li></ul><h2 id="三-查询执行的基础"><a href="#三-查询执行的基础" class="headerlink" title="三. 查询执行的基础"></a>三. 查询执行的基础</h2><h3 id="3-1-一个查询在MySQL中的执行过程"><a href="#3-1-一个查询在MySQL中的执行过程" class="headerlink" title="3.1 一个查询在MySQL中的执行过程"></a>3.1 一个查询在MySQL中的执行过程</h3><p>MySQL执行一个查询的过程：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280108.png" alt></p><ol><li>客户端发送一条查询给服务器。</li><li>服务器先检查缓存，若命中缓存就立即返回结果。否则进入下一步。</li><li>服务器进行SQL解析、预处理，再由优化器生成对应的执行计划。</li><li>根据执行计划调用存储引擎的API来执行查询。</li><li>将结果返回客户端。</li></ol><h3 id="3-2-MySQL-客户端-服务器通信协议"><a href="#3-2-MySQL-客户端-服务器通信协议" class="headerlink" title="3.2 MySQL 客户端 / 服务器通信协议"></a>3.2 MySQL 客户端 / 服务器通信协议</h3><p>MySQL 客户端 / 服务器通信协议是<strong>半双工协议</strong>，即要么服务器向客户端发送数据、要么客户端向服务器发送数据，两个动作不能同时发生。</p><p>优点是通信简单快速，缺点是无法进行流量控制。一方一旦开始发送消息，另一方只能接收完整消息后才能进行响应。一方不能使另一方停止，MySQL一般要等所有数据都发送给客户端后才能释放查询所占用的资源，所以客户端缓存数据可以减轻服务器压力，让查询尽快结束早点释放资源。</p><p>查看MySQL连接/线程的状态：<code>SHOW FULL PROCESSLIST</code> </p><ul><li>Sleep：线程正在等待客户端发送新的请求。</li><li>Query：线程正在执行查询或正在将结果发送给客户端。</li><li>Locked：在MySQL服务器层，该线程正在等待表锁；存储引擎级别的锁（如行锁）不会体现在线程状态。</li><li>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li><li>Copying to tmp table [on disk]：线程正在执行查询，并将结果集都复制到一个临时表中，一般是在做GROUP BY操作、文件排序、UNION操作等；on disk表示正在将一个内存表放到磁盘。</li><li>Sorting result：线程正在对结果集进行排序。</li><li>Sending data：线程可能在多个状态间传送数据、或者生成结果集、或者在向客户端返回数据。</li></ul><h3 id="3-3-查询优化处理"><a href="#3-3-查询优化处理" class="headerlink" title="3.3 查询优化处理"></a>3.3 查询优化处理</h3><p>查询的生命周期中下一步是<strong>将一个SQL转换为一个执行计划</strong>，MySQL按照执行计划和存储引擎交互：</p><ul><li><strong>解析SQL</strong>：MySQL通过关键字将SQL语句进行解析，生成一棵解析树，通过MySQL语法规则进行验证和解析查询（如关键字是否正确、顺序是否正确、引号前后是否匹配）。</li><li><strong>预处理</strong>：根据一些MySQL规则进一步检查解析树是否合法（数据表和列是否存在、名字或别名是否有歧义），验证权限。</li><li><strong>优化SQL执行计划</strong></li></ul><p><strong>查询优化器</strong>：MySQL使用基于成本的优化器，预测一个查询使用某种执行计划时的成本并选择最小的一个。</p><p>导致优化器选择错误执行计划的原因：</p><ul><li>统计信息不准确，评估成本依赖存储引擎提供的统计信息，有时信息的偏差会很大，如MVCC架构并不维护数据表行数的精确统计。</li><li>执行计划的成本估算并不等价于实际执行的成本，如读取的页面可能在内存或磁盘，具体要多少次物理I/O无法得知。</li><li>MySQL的最优并不一定是最快的执行方式，只是基于成本模型的最优计划。</li><li>MySQL并不考虑其他并发执行的查询。</li><li>MySQL并不考虑不受控制的操作的成本，如存储过程或自定义函数。</li><li>有些特殊情况并不基于成本选择优化，如全文搜索的 <code>MATCH()</code> 子句，存在全文索引就会使用，即使有时别的索引和WHERE条件会更快。</li></ul><p>优化器的优化策略：</p><ul><li>静态优化：直接对解析树进行分析，并完成优化。</li><li>动态优化：与查询的上下文或其他因素有关，如WHERE条件取值、索引中条目对应的数据行数等，需要每次查询时重新评估。</li></ul><p>能够优化的类型：</p><ul><li>重新定义关联表的顺序</li><li>将外连接转化为内连接</li><li>使用等价变换规则</li><li>优化 <code>COUNT()</code> 、<code>MIN()</code> 和 <code>MAX()</code> ，找到某一列最小值只需查询对应B-Tree索引最左端的记录，使用此类优化在EXPLAIN中会出现 <code>Select tables optimized away</code> 表示优化器从执行计划中移除该表，用一个常数取代。</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表 <code>IN()</code> 的比较</li></ul><h3 id="3-4-MySQL如何执行关联查询"><a href="#3-4-MySQL如何执行关联查询" class="headerlink" title="3.4 MySQL如何执行关联查询"></a>3.4 MySQL如何执行关联查询</h3><h4 id="3-4-1-MySQL中的关联查询"><a href="#3-4-1-MySQL中的关联查询" class="headerlink" title="3.4.1 MySQL中的关联查询"></a>3.4.1 MySQL中的关联查询</h4><p>MySQL中每个查询都是一次关联。比如对于UNION查询，MySQL先将一系列单个查询的结果放在一个临时表中，然后再重新读出临时表数据完成UNION查询。</p><p>MySQL中关联查询流程：</p><ul><li>MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去直到找到所有表中匹配的行为止。</li><li>然后根据各个表匹配的行，返回查询中需要的各个列。</li><li>MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行，返回到上一层关联表继续查找更多匹配的记录，依次迭代执行。</li></ul><p>关联操作1如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tab1.col1, tab2.col2</span><br><span class="line"><span class="keyword">FROM</span> tab1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tab2 <span class="keyword">USING</span>(col3)</span><br><span class="line"><span class="keyword">WHERE</span> tab1.col1 <span class="keyword">IN</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>伪代码如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030101.png" alt></p><p>关联操作2如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tab1.col1, tab2.col2</span><br><span class="line"><span class="keyword">FROM</span> tab1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> tab2 <span class="keyword">USING</span>(col3)</span><br><span class="line"><span class="keyword">WHERE</span> tab1.col1 <span class="keyword">IN</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>伪代码如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030102.png" alt></p><p>关联操作1的内连接使用泳道图表示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030103.png" alt></p><h4 id="3-4-2-执行计划"><a href="#3-4-2-执行计划" class="headerlink" title="3.4.2 执行计划"></a>3.4.2 执行计划</h4><p>MySQL并不像其他关系型数据库那样生成查询字节码来执行查询，而是<strong>生成查询的一棵指令树</strong>，最终的执行计划包含了重构查询的全部信息。</p><p>对某个查询执行 <code>EXPLAIN EXTENDED</code> ，然后再执行 <code>SHOW WARNINGS</code> 可以看到重构出的查询。</p><p>任意多表查询都可以使用一棵树表示，如下图为一个四表关联操作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030104.png" alt></p><p>上图这种平衡树并非MySQL执行查询的方式，MySQL总是从一个表开始嵌套循环、回溯完成所有表关联，所以是下图这种<strong>左侧深度优先树</strong>：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030105.png" alt></p><h4 id="3-4-3-关联查询优化器"><a href="#3-4-3-关联查询优化器" class="headerlink" title="3.4.3 关联查询优化器"></a>3.4.3 关联查询优化器</h4><p>关联查询优化是优化器最重要的部分，决定多个表关联的顺序。优化器通过评估不同顺序的成本选择一个代价最小的关联顺序。</p><p>有时优化器选择的并非一定是最优顺序，此时可以使用 <code>STRAIGHT_JOIN</code> 关键字重写查询，让优化器按指定顺序执行，绝大部分情况优化器的判断要比开发者精准。</p><p>优化器如何计算成本：</p><ul><li>一般会遍历每个表逐个做嵌套循环计算每一棵执行计划树的成本。</li><li>但如果有超过N个表关联，需要检查N的阶乘种关联顺序；比如N=10时就有3628800种关联顺序，过多的可能导致优化器不可能逐一评估每种顺序的成本；</li><li>当搜索空间特别大时，优化器选择贪婪搜索方式，而非逐个评估。</li></ul><h3 id="3-5-排序优化"><a href="#3-5-排序优化" class="headerlink" title="3.5 排序优化"></a>3.5 排序优化</h3><ul><li>无论怎样，排序都是一个成本很高的操作，在不能使用索引排序时，数据量小的排序会在内存中进行，数据量大时需要使用磁盘；</li><li>判断条件是需要排序的数据量是否小于<strong>排序缓冲区</strong>；</li><li>内存中直接使用快速排序；内存不够排序，先将数据分块，每个块进行快速排序，结果存放在磁盘，然后将排好序的各个块合并，并返回最终结果。</li><li>在关联查询时如果需要排序，MySQL分两种情况来处理：<ul><li>ORDER BY 子句中所有列都来自于关联的第一个表，MySQL在处理第一个表时就进行文件排序，这种情况EXPLAIN 的 Extra 字段会有 <code>Using filesort</code> ；</li><li>其他情况下，MySQL都会将关联的结果放到一个临时表中，然后在所有的关联结束后再进行文件排序，这种情况EXPLAIN 的 Extra 字段会有 <code>Using temporary; Using filesort</code> ；查询中有LIMIT会在排序后应用，MySQL 5.6 版本后，当只需返回部分排序结果时不会对所有结果进行排序。</li></ul></li></ul><h2 id="四-查询优化器"><a href="#四-查询优化器" class="headerlink" title="四. 查询优化器"></a>四. 查询优化器</h2><h3 id="4-1-查询优化器的局限性"><a href="#4-1-查询优化器的局限性" class="headerlink" title="4.1 查询优化器的局限性"></a>4.1 查询优化器的局限性</h3><h4 id="4-1-1-关联子查询"><a href="#4-1-1-关联子查询" class="headerlink" title="4.1.1 关联子查询"></a>4.1.1 关联子查询</h4><p>MySQL子查询十分糟糕，特别是WHERE条件包含 <code>IN()</code> 的子查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id = <span class="number">1</span>);</span><br><span class="line"><span class="comment">--MySQL会先执行子查询，返回所有actor_id = 1的film_id，所以我们会认为会如下执行：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span>(XXX, XXX, ......, XXX);</span><br><span class="line"><span class="comment">--但实际上，MySQL会将外层表压到子查询中，因为它认为这样可以更快的找到数据行：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> film_actor <span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film.film_id = film_actor.film_id);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101030106.png" alt></p><p>MySQL选择先对file表进行全表扫描，根据返回的film_id逐个执行子查询，当数据量大时这种执行性能会很糟糕，所以我们可以改写查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用内连接代替IN子查询：</span></span><br><span class="line"><span class="keyword">SELECT</span> film.* <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">--使用函数GROUP_CONCAT拼接一个逗号分隔的列表：</span></span><br><span class="line">（省略）</span><br></pre></td></tr></table></figure><h4 id="4-1-2-UNION取LIMIT时内外层优化"><a href="#4-1-2-UNION取LIMIT时内外层优化" class="headerlink" title="4.1.2 UNION取LIMIT时内外层优化"></a>4.1.2 UNION取LIMIT时内外层优化</h4><p>有时我们希望对UNION的结果集只获取前N条记录，可以在每个子句中添加LIMIT，为了保证获取正确的顺序，需要在外层再增加一个全局的 ORDER BY 和 LIMIT 操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a)</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">20</span></span><br><span class="line"><span class="comment">-- 改写为</span></span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">20</span>)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(<span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> xx2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">20</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-索引合并优化"><a href="#4-1-3-索引合并优化" class="headerlink" title="4.1.3 索引合并优化"></a>4.1.3 索引合并优化</h4><p>WHERE子句包含多个复杂条件时，MySQL可以访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</p><h4 id="4-1-4-等值传递"><a href="#4-1-4-等值传递" class="headerlink" title="4.1.4 等值传递"></a>4.1.4 等值传递</h4><p>如一个非常大的 <code>IN()</code> 列表，优化器发现有WHERE、ON或USING的子句，将这个列表的值和另外一个表的某个列关联。优化器会将列表都复制应用到关联的各个表中，列表特别大会导致无法高效的从表中过滤记录。</p><h4 id="4-1-5-并行执行"><a href="#4-1-5-并行执行" class="headerlink" title="4.1.5 并行执行"></a>4.1.5 并行执行</h4><p>MySQL无法利用多核来并行执行查询。</p><h4 id="4-1-6-哈希关联"><a href="#4-1-6-哈希关联" class="headerlink" title="4.1.6 哈希关联"></a>4.1.6 哈希关联</h4><p>MySQL只支持嵌套循环关联，只能通过建立哈希索引来变相的实现哈希关联</p><h4 id="4-1-7-松散索引扫描"><a href="#4-1-7-松散索引扫描" class="headerlink" title="4.1.7 松散索引扫描"></a>4.1.7 松散索引扫描</h4><p>MySQL不支持松散索引扫描，无法按照不连续的方式扫描一个索引。假设有索引 <code>(A,B)</code> 查询 <code>SELECT ... FROM TB WHERE B BETWEEN 2 AND 3</code> 因为索引前导字段是A，但查询只指定了B，所以无法使用索引，只能全表扫描。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210101.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210102.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210101/202101210103.png" alt></p><h4 id="4-1-8-最大值和最小值优化"><a href="#4-1-8-最大值和最小值优化" class="headerlink" title="4.1.8 最大值和最小值优化"></a>4.1.8 最大值和最小值优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(actor_id) <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> first_name = <span class="string">'XX'</span>;</span><br><span class="line"><span class="comment">--因为first_name并没有索引，所以MySQL会进行一次全表扫描，通过SHOW STATUS确认</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ...;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="comment">--优化：使用LIMIT重写</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">USE</span> <span class="keyword">INDEX</span>(PRIMARY) <span class="keyword">WHERE</span> first_name = <span class="string">'XX'</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-查询优化器的提示"><a href="#4-2-查询优化器的提示" class="headerlink" title="4.2 查询优化器的提示"></a>4.2 查询优化器的提示</h3><p>暂略。</p><h3 id="4-3-优化特定类型的查询"><a href="#4-3-优化特定类型的查询" class="headerlink" title="4.3 优化特定类型的查询"></a>4.3 优化特定类型的查询</h3><h4 id="4-3-1-优化COUNT"><a href="#4-3-1-优化COUNT" class="headerlink" title="4.3.1 优化COUNT()"></a>4.3.1 优化COUNT()</h4><p>COUNT(*) 统计结果集的行数，COUNT(row) 统计某个列值的数量，二者含义不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--一个查询统计不同颜色</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">IF</span>(color = <span class="string">'blue'</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">AS</span> blue, <span class="keyword">SUM</span>(<span class="keyword">IF</span>(color = <span class="string">'red'</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(color = <span class="string">'blue'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> blue, <span class="keyword">COUNT</span>(color = <span class="string">'red'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br></pre></td></tr></table></figure><p>不需要精确值时可以使用近似值代替，比如EXPLAIN的估算行数。</p><p>COUNT() 一般都需要扫描大量的数据行才能获得精确的结果，只能加索引覆盖扫描，如果这样还不能解决性能问题，只能考虑修改应用的架构，比如增加汇总表 / 缓存系统等。</p><h4 id="4-3-2-优化关联查询"><a href="#4-3-2-优化关联查询" class="headerlink" title="4.3.2 优化关联查询"></a>4.3.2 优化关联查询</h4><ul><li>确保ON或USING子句的列上有索引，创建索引时要考虑关联的顺序，当表A和B用列c关联，若优化器的关联顺序的B、A，那么B表就不需要创建索引，<strong>一般关联只需在关联顺序的第二张表对应列上创建索引</strong>。</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li><li>升级MySQL时注意关联语法、运算符优先级等其他可能会发生变化的地方，普通关联可能会变成笛卡尔积，不同类型的关联可能会生成不同的结果。</li></ul><h4 id="4-3-3-优化子查询"><a href="#4-3-3-优化子查询" class="headerlink" title="4.3.3 优化子查询"></a>4.3.3 优化子查询</h4><p>尽可能用关联查询代替子查询。</p><h4 id="4-3-4-优化GROUP-BY和DISTINCT"><a href="#4-3-4-优化GROUP-BY和DISTINCT" class="headerlink" title="4.3.4 优化GROUP BY和DISTINCT"></a>4.3.4 优化GROUP BY和DISTINCT</h4><p>MySQL优化器会在内部处理时相互转换这两类查询，使用索引来优化；若索引无法使用，GROUP BY 会使用<strong>临时表</strong>或<strong>文件排序</strong>来做分组。</p><p>对关联查询做分组，并且按照查找表中的某个列进行分组，采用查找表的标识列效率会较高：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--效率差</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name,actor.last_name, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.first_name,actor.last_name</span><br><span class="line"><span class="comment">--效率高</span></span><br><span class="line"><span class="keyword">SELECT</span> actor.first_name,actor.last_name, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.actor_id</span><br><span class="line"><span class="comment">--这种写法只是在姓名和actor_id直接关联的情况下可以这样用，且有一些问题</span></span><br></pre></td></tr></table></figure><h4 id="4-3-5-优化LIMIT分页"><a href="#4-3-5-优化LIMIT分页" class="headerlink" title="4.3.5 优化LIMIT分页"></a>4.3.5 优化LIMIT分页</h4><p>分页操作：使用LIMIT加偏移量实现，加上合适的ORDER BY子句。</p><p>偏移量非常大时，比如 LIMIT 10000,20 只返回20条数据抛弃前面10000条记录。优化要么在页面中限制分页的数量，要么优化大偏移量的性能。</p><ul><li><p><strong>延迟关联</strong>：最简单就是使用索引覆盖扫描，而不是返回所有列。然后根据需要再做一次关联操作返回所有列，这种改法对于偏移量大的情况效率提升比较高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>;</span><br><span class="line"><span class="comment">--优化为：</span></span><br><span class="line"><span class="keyword">SELECT</span> film.film_id, film.description </span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span>(<span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>) <span class="keyword">AS</span> lim <span class="keyword">USING</span>(film_id)</span><br></pre></td></tr></table></figure></li><li><p>LIMIT可以转换为已知位置的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--上述查询可改为：</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, description </span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">position</span> <span class="keyword">BETWEEN</span> <span class="number">50</span> <span class="keyword">TO</span> <span class="number">54</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">position</span>;</span><br></pre></td></tr></table></figure></li><li><p>LIMIT查询主要问题是OFFSET会导致MySQL扫描大量不需要的行并且丢弃掉，可以记录上次取数据的位置，下次直接从该位置开始扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--第一次查询，返回主键为16049到16030的租借记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">--下次查询直接从16030开始</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">WHERE</span> rental_id &lt; <span class="number">16030</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-6-优化-SQL-CALC-FOUND-ROWS"><a href="#4-3-6-优化-SQL-CALC-FOUND-ROWS" class="headerlink" title="4.3.6 优化 SQL_CALC_FOUND_ROWS"></a>4.3.6 优化 SQL_CALC_FOUND_ROWS</h4><p>分页的一个常用技巧是<strong>在LIMIT语句中加上SQL_CALC_FOUND_ROWS提示</strong>，从而获得去掉LIMIT以后满足条件的行数，作为分页的总数，好像是MySQL预测到了总行数，但实际上MySQL需要扫描扫描所有满足条件的行来得到行数。</p><p>所以添加此提示后，不管是否需要，MySQL都会扫描所有满足条件的行，而不是满足LIMIT的行数后就终止扫描。</p><h4 id="4-3-7-优化-UNION-查询"><a href="#4-3-7-优化-UNION-查询" class="headerlink" title="4.3.7 优化 UNION 查询"></a>4.3.7 优化 UNION 查询</h4><p>MySQL总是会通过创建并填充临时表的方式来执行 UNION 查询，所以导致很多优化策略受限（经常要手工将WHERE，LIMIT，ORDER BY放到UNION子查询中以便优化器优化）。</p><p>除非必须要服务器消除重复的行，否则一定要使用UNION ALL，没有ALL时MySQL会给临时表增加DISTINCT选项，这会导致整个临时表做唯一性检查，这样的代价非常高。</p><h4 id="4-3-8-静态查询分析"><a href="#4-3-8-静态查询分析" class="headerlink" title="4.3.8 静态查询分析"></a>4.3.8 静态查询分析</h4><p>Percona Toolkit中的pt-query-advisor能够解析查询日志，分析查询模式，给出所有可能存在潜在问题的查询，并给出足够详细的建议。</p><h4 id="4-3-9-使用用户自定义变量"><a href="#4-3-9-使用用户自定义变量" class="headerlink" title="4.3.9 使用用户自定义变量"></a>4.3.9 使用用户自定义变量</h4><p>暂略。</p><h3 id="4-4-案例"><a href="#4-4-案例" class="headerlink" title="4.4 案例"></a>4.4 案例</h3><h3 id="4-4-1-构建一个队列表"><a href="#4-4-1-构建一个队列表" class="headerlink" title="4.4.1 构建一个队列表"></a>4.4.1 构建一个队列表</h3><ul><li><p>一个表包含多种类型的记录：未处理的记录、已处理记录、正在处理记录。</p></li><li><p>一个或多个消费者线程在表中查找未处理的记录，然后标记为正在处理，处理完成后再更新为已处理状态。</p></li><li><p>不合理的地方：</p><ul><li>随着队列表越来越大和索引深度的增加，找到未处理记录的速度越来越慢；可以将队列表拆分为已处理和未处理两部分来优化。</li><li>处理过程一般包括两步：找到未处理记录，然后加锁。前者增加服务器压力，加锁则让各个消费者线程增加竞争。</li></ul></li><li><p>如何让消费者标记正在处理的记录，而不使多个消费者重复处理同一记录？</p><ul><li><p>任何情况都应避免使用 SELECT FOR UPDATE ，会导致大量事务阻塞并等待；</p></li><li><p>用一个属性列标识正在处理记录的连接ID。</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">--查找未有线程处理且状态为待发送的记录ID</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span> unsent_emails</span><br><span class="line"><span class="keyword">WHERE</span> owner = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'unsent'</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">--result：123，456，789</span></span><br><span class="line"><span class="comment">--更新这些记录状态，并且将连接ID写入owner</span></span><br><span class="line"><span class="keyword">UPDATE</span> unsent_emails</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>, owner = CONNECTION_ID()</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span>(<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>上述SELECT走了索引，但FOR UPDATE锁会使其他查询阻塞，可以改进如下（无需用SELECT查询哪些记录还未被处理，可以用来改写所有的SELECT FOR UPDATE）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">UPDATE</span> unsent_emails</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>, owner = CONNECTION_ID()</span><br><span class="line"><span class="keyword">WHERE</span> owner = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'unsent'</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span> unsent_emails</span><br><span class="line"><span class="keyword">WHERE</span> owner = CONNECTION_ID()</span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">status</span> = <span class="string">'claimed'</span>;</span><br><span class="line"><span class="comment">--result：123，456，789</span></span><br><span class="line"><span class="comment">--更新这些记录状态，并且将连接ID写入owner</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>基础原则：</p><ul><li>除非不得已，否则不要使用轮询。</li><li>尽量用UPDATE代替 SELECT FOR UPDATE，事务提交越快，持有锁的时间就越短，可以大大减少竞争和加速串行执行效率。</li><li>将已经处理完成和未处理数据分开，保证数据集足够小。</li><li>无法优化的查询尝试用不同策略来实现相同目的。</li><li>任务队列最好能从数据库移除，使用Redis、memcached、Q4M引擎等方案。</li></ul></li></ul><h3 id="4-4-2-计算两点之间的距离"><a href="#4-4-2-计算两点之间的距离" class="headerlink" title="4.4.2 计算两点之间的距离"></a>4.4.2 计算两点之间的距离</h3><p>感觉不是常用的场景，暂略。</p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：为什么查询速度会慢，优化数据访问，查询执行的基础，查询优化器等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（四）创建高性能索引</title>
    <link href="http://linyishui.top/2020122501.html"/>
    <id>http://linyishui.top/2020122501.html</id>
    <published>2020-12-25T12:14:26.000Z</published>
    <updated>2020-12-29T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（四）创建高性能索引"><a href="#《高性能MySQL》（四）创建高性能索引" class="headerlink" title="《高性能MySQL》（四）创建高性能索引"></a>《高性能MySQL》（四）创建高性能索引</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是索引？"><a href="#1-1-什么是索引？" class="headerlink" title="1.1 什么是索引？"></a>1.1 什么是索引？</h3><p>索引就像是书的目录，在MySQL中，存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> actor_id = <span class="number">5</span>;</span><br><span class="line"><span class="comment">--若actor_id列上有创建索引，MySQL先在索引上按值查找，然后返回所有包含值得数据行</span></span><br></pre></td></tr></table></figure><p><strong>MySQL只能高效的使用索引的最左前缀列，索引中列的顺序很重要</strong>。</p><h3 id="1-2-索引的类型"><a href="#1-2-索引的类型" class="headerlink" title="1.2 索引的类型"></a>1.2 索引的类型</h3><h4 id="1-2-1-B-Tree-索引"><a href="#1-2-1-B-Tree-索引" class="headerlink" title="1.2.1 B-Tree 索引"></a>1.2.1 B-Tree 索引</h4><p>虽然叫B-Tree索引，但存储引擎可能使用不同的存储结构，比如InnoDB使用的是 B+Tree、NDB集群使用的是 T-Tree 。MyISAM使用前缀压缩技术使得索引更小，InnoDB则按原数据格式存储；MyISAM索引通过数据的物理位置引用被索引的行，InnoDB则根据主键引用被索引的行。</p><p>B-Tree索引中所有值按顺序存储，每个叶子页到根的距离相同：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280101.png" alt></p><p>存储引擎从索引的根节点开始搜索，根节点的槽中存放了指向子节点的指针，通过指针向下层查找，通过比较节点页和要查找的值大小可以找到合适的指针到下一个子节点。叶子节点的指针指向被索引的数据。这种顺序存储很适合范围查询。</p><p>对于People表有索引包含last_name、first_name和dob，索引结构如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280102.png" alt></p><p>B-Tree 索引适用于<strong>全键值、键值范围或键前缀查找</strong>，键前缀查找只适用最左前缀：</p><ul><li><strong>全值匹配</strong>：和索引中所有列匹配，如查询叫 Cuba Allen、出生于XXX年的人。</li><li><strong>匹配最左前缀</strong>：只匹配索引第一列，如查询所有姓Allen的人。</li><li><strong>匹配列前缀</strong>：只匹配列值的开头部分，如查询所有J开头姓的人。</li><li><strong>匹配范围值</strong>：匹配列值得某个范围，如查询所有姓Allen与Barry之间的人。</li><li><strong>精确匹配某一列并范围匹配另外一列</strong>：第一列全匹配，第二列范围匹配，如查询所有姓Allen，名以K开头的人。</li><li><strong>只访问索引的查询</strong>：即查询只需访问索引，无须访问数据行，即<strong>覆盖索引</strong>。</li></ul><p>B-Tree索引支持的查询同样可以支持 ORDER BY 操作。</p><p>限制：</p><ul><li>非最左列开始无法命中索引；</li><li>不能跳过索引中的列；</li><li>查询中若有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ul><p>即从左到右依次扫描索引列，到遇到第一个范围查询（&gt;=, &gt;,&lt;, &lt;=, between ….. and ….）就停止扫描。</p><h4 id="1-2-2-哈希索引"><a href="#1-2-2-哈希索引" class="headerlink" title="1.2.2 哈希索引"></a>1.2.2 哈希索引</h4><ul><li>Memory和NDB存储引擎支持，基于哈希表实现，只有精确匹配索引所有列的查询才有效。</li><li>InnoDB有一个特殊的自适应哈希索引，在某些索引值使用非常频繁时，会在内存中基于B-Tree索引再创建一个哈希索引，从而加快查找速度。</li><li>每行数据会计算得到一个哈希码，存放在哈希索引中，同时在哈希表中保存指向每个数据行的指针。</li><li>哈希索引只包含哈希值和行指针，不存储字段值，所以不能像B-Tree索引那样避免读取行，但一般读行速度很快。</li><li>不按索引值顺序存储，无法用于排序。</li><li>不支持部分索引列匹配查找。</li><li>只支持等值比较查询，不支持任何范围查询。</li><li>哈希冲突需要遍历链表所有行指针，所以会影响性能。</li></ul><h4 id="1-2-3-空间数据索引（R-Tree）"><a href="#1-2-3-空间数据索引（R-Tree）" class="headerlink" title="1.2.3 空间数据索引（R-Tree）"></a>1.2.3 空间数据索引（R-Tree）</h4><ul><li>MyISAM支持空间索引，用来存储地理位置。</li></ul><h4 id="1-2-4-全文索引"><a href="#1-2-4-全文索引" class="headerlink" title="1.2.4 全文索引"></a>1.2.4 全文索引</h4><ul><li>全文索引类似于搜索引擎，查找的是文本中的关键词，而不是直接比较索引的值。</li><li>适用于 MATCH AGAINST 操作，而不是普通的 WHERE 条件操作。</li></ul><h3 id="1-3-索引的优点"><a href="#1-3-索引的优点" class="headerlink" title="1.3 索引的优点"></a>1.3 索引的优点</h3><ul><li>提高查询效率。</li><li>避免排序和临时表：B-Tree索引可以用于 ORDER BY 和 GROUP BY 操作。</li><li>减少了需要扫描的数据量：某些情况只使用索引就可以完成查询。</li><li>将随机I/O变为顺序I/O。</li></ul><p>索引非银弹，只有在索引能大大提高查询的效率，大于其带来的额外工作时，才是有效的，对于特别小的表全表查询可能会更高效，而特别大的表创建和使用索引的代价可能过于高昂。</p><h2 id="二-高性能索引策略"><a href="#二-高性能索引策略" class="headerlink" title="二. 高性能索引策略"></a>二. 高性能索引策略</h2><h3 id="2-1-独立的列"><a href="#2-1-独立的列" class="headerlink" title="2.1 独立的列"></a>2.1 独立的列</h3><p><strong>索引列不能是表达式的一部分，也不能是函数的参数</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> <span class="keyword">TO_DAYS</span>(<span class="keyword">CURRENT_DATE</span>) - <span class="keyword">TO_DAYS</span>(date_col) &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-前缀索引和索引选择性"><a href="#2-2-前缀索引和索引选择性" class="headerlink" title="2.2 前缀索引和索引选择性"></a>2.2 前缀索引和索引选择性</h3><p>当需要索引很长的字符列时（特别是BLOB、TEXT或很长的VARCHAR只能使用前缀索引），可以选择模拟哈希索引，也可以只索引开始的部分字符。</p><p>我们需要选择足够长的前缀保证有较高的选择性，可以通过真实数据统计前缀长度为多少时最合适。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建前缀索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">ADD</span> <span class="keyword">KEY</span> (city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure><p>前缀索引无法用于 ORDER BY 和 GROUP BY，也无法做覆盖扫描。</p><h3 id="2-3-多列索引"><a href="#2-3-多列索引" class="headerlink" title="2.3 多列索引"></a>2.3 多列索引</h3><p>为多列的每个列创建单独的索引一般不能提高查询性能，最好情况下也可能与最优索引的效率差几个数量级。</p><p>在EXPLAIN中看到索引合并（index_merge）大部分情况说明索引构建的很糟糕，有时甚至不如直接改写为UNION的方式。</p><h3 id="2-4-选择合适的索引列顺序"><a href="#2-4-选择合适的索引列顺序" class="headerlink" title="2.4 选择合适的索引列顺序"></a>2.4 选择合适的索引列顺序</h3><p>一个多列的B-Tree索引会按照最左列排序，然后是第二列、第三列等等。<strong>在不考虑排序和分组时，将选择性最高的列（根据条件命中条数最少）放到索引的最前列</strong>。</p><p>案例：</p><ol><li><p>慢查询SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> threadId) <span class="keyword">AS</span> COUNT_VALUE</span><br><span class="line"><span class="keyword">FROM</span> Message</span><br><span class="line"><span class="keyword">WHERE</span> (groupId = <span class="number">10137</span>) <span class="keyword">AND</span> (userId = <span class="number">1288826</span>) <span class="keyword">AND</span> (anonymous = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">priority</span> <span class="keyword">DESC</span>, modifiedDate <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></li><li><p>执行计划：看似选择了索引 <code>(groupId, userId)</code> 很合理</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id：<span class="number">1</span></span><br><span class="line">select_type：SIMPLE</span><br><span class="line"><span class="keyword">table</span>：Message</span><br><span class="line"><span class="keyword">type</span>：<span class="keyword">ref</span></span><br><span class="line">key：ix_groupId_userId</span><br><span class="line">key_len：<span class="number">18</span></span><br><span class="line"><span class="keyword">ref</span>: <span class="keyword">const</span>,<span class="keyword">const</span></span><br><span class="line">rows：<span class="number">1251162</span></span><br><span class="line">Extra：Using where</span><br></pre></td></tr></table></figure></li><li><p>选择性分析：条件几乎命中所有行，即索引没起到什么用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),              <span class="comment">--4142217</span></span><br><span class="line">       <span class="keyword">SUM</span>(groupId = <span class="number">10137</span>),  <span class="comment">--4092654</span></span><br><span class="line">       <span class="keyword">SUM</span>(userId = <span class="number">1288826</span>), <span class="comment">--1288496</span></span><br><span class="line">       <span class="keyword">SUM</span>(anonymous = <span class="number">0</span>)     <span class="comment">--4141934</span></span><br><span class="line"><span class="keyword">FROM</span> Message</span><br></pre></td></tr></table></figure></li><li><p>解决方案是修改应用代码，区分这部分异常数据。</p></li></ol><h3 id="2-5-聚簇索引"><a href="#2-5-聚簇索引" class="headerlink" title="2.5 聚簇索引"></a>2.5 聚簇索引</h3><p>聚簇索引是一种数据存储方式，InnoDB的聚簇索引实际上在同一结构中保存了B-Tree索引和数据行。聚簇表示数据行和相邻的键值紧凑的存储在一起，当表存在聚簇索引时，其数据行实际存放在索引的叶子页（leaf page）中。</p><p>如下图，叶子页包含了行的全部数据，而节点页只包含索引列：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280103.png" alt></p><p>InnoDB通过主键聚集数据，若没有指定主键，InnoDB会选择一个唯一的非空索引代替，没有这样的索引则会隐式的定义一个主键来作为聚簇索引。InnoDB只聚集同一个页面的记录，非同一页即使相邻键值也可能相距甚远。</p><p>聚集的优点：</p><ul><li>将相关的数据保存在一起，减少磁盘I/O操作；</li><li>数据访问更快，因为索引和数据保存在同一个B-Tree。</li><li>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</li></ul><p>聚集的缺点：</p><ul><li>若数据存放在内存，访问顺序就没那么重要，聚簇索引对于I/O的提升就不明显了。</li><li>插入速度严重依赖于插入顺序，最快是按照主键顺序插入，若非此顺序最好加载完成后通过 OPTIMIZE TABLE 重新组织一下表。</li><li>更新聚簇索引的代价高昂，会强制InnoDB将每个被更新的行移动到新位置。</li><li>基于聚簇索引的表在插入新行、或主键更新导致需要移动行时，会面临页分裂问题。行需要插入到某个已满的页中，存储引擎要把页分裂成两个页来容纳新行。</li><li>可能导致全表扫描变慢，特别是行比较稀疏或页分裂导致数据存储不连续的时候。</li><li>二级索引（非聚簇索引）要比想象的大，因为叶子节点包含了引用行的主键列。</li><li>二级索引访问需要两次索引查找，而不是一次。因为二级索引叶子节点保存的不是行的物理位置，而是行的主键值。在找到二级索引获得主键值后，仍需要去聚簇索引找到对应的行。所以InnoDB引入自适应哈希索引减少这样的重复工作。</li></ul><p>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。若主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280104.png" alt></p><p>AUTO_INCREMENT 自增列保证数据行是按顺序写入，从性能考虑使用UUID作为聚簇索引会很糟糕，插入变得完全随机。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280105.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280106.png" alt></p><h3 id="2-6-覆盖索引"><a href="#2-6-覆盖索引" class="headerlink" title="2.6 覆盖索引"></a>2.6 覆盖索引</h3><p>设计索引时不仅仅要考虑WHERE条件部分，特别是能直接通过索引获取列数据的情况。<strong>如果一个索引包含所有需要查询的字段的值，可以被称为覆盖索引</strong>。只有B-Tree索引可以作为覆盖索引。在EXPLAIN的Extra对应 <code>Using index</code> 信息。</p><p>InnoDB的二级索引的叶子节点包含主键的值，所以即使本身没有包含主键，二级索引也可以额外用于对主键做覆盖查询。</p><p>优点：</p><ul><li>减少数据访问量；</li><li>索引至少在单个页内是按列值顺序存储的，所以范围查询相比随机读取的I/O少很多。</li><li>由于聚簇索引的原因，覆盖索引对InnoDB特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，若二级主键可以覆盖查询，就可以避免对主键索引的二次查询。</li></ul><p>全字段模糊查询优化：<strong>延迟关联</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> actor = <span class="string">'SEAN CARREY'</span></span><br><span class="line">                                 <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'%APOLLO%'</span>;</span><br><span class="line"><span class="comment">--type：ref</span></span><br><span class="line"><span class="comment">--possible_keys：ACTOR,IX_PROD_ACTOR</span></span><br><span class="line"><span class="comment">--key：ACTOR</span></span><br><span class="line"><span class="comment">--key_len：52</span></span><br><span class="line"><span class="comment">--Extra：Using where</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询选择了表的所有列，而没有索引覆盖了这么多列，但WHERE条件actor命中了索引，MySQL不能再索引中执行LIKE操作</span></span><br><span class="line"><span class="comment">--优化方案：创建索引(artist,title,prod_id)</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products </span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> prod_id <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> actor = <span class="string">'SEAN CARREY'</span></span><br><span class="line">                                     <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'%APOLLO%'</span>;) AS T1 ON (t1.prod_id=products.prod_id)</span><br><span class="line"><span class="comment">--1.select_type: PRIMARY</span></span><br><span class="line"><span class="comment">--2.select_type: PRIMARY</span></span><br><span class="line"><span class="comment">--3.select_type: DERIVED</span></span><br><span class="line"><span class="comment">--3.type: ref</span></span><br><span class="line"><span class="comment">--3.key: ACTOR_2</span></span><br><span class="line"><span class="comment">--3.Extra: Using where; Using index</span></span><br></pre></td></tr></table></figure><h3 id="2-7-使用索引扫描来做排序"><a href="#2-7-使用索引扫描来做排序" class="headerlink" title="2.7 使用索引扫描来做排序"></a>2.7 使用索引扫描来做排序</h3><p>两种方式生成有序结果：</p><ol><li>排序操作；</li><li>按索引顺序扫描。EXPLAIN得到type值为index。</li></ol><p>只扫描索引本身很快，但如果不能覆盖所有列，就需要回表查询一次，而回表查询基本是随机I/O，相比顺序地全表扫描要慢。</p><p>只有索引顺序和 ORDER BY 操作顺序一样时，才可以作为排序结果。</p><h3 id="2-8-压缩索引"><a href="#2-8-压缩索引" class="headerlink" title="2.8 压缩索引"></a>2.8 压缩索引</h3><p>MyISAM使用前缀压缩来减小索引的大小，比如索引块第一个值是“perform”，第二个值是“performance”，压缩后第二个值是“7,ance”，减少空间的代价是某些操作会更慢，因为前后的依赖性所以无法使用二分查找。</p><h3 id="2-9-冗余和重复索引"><a href="#2-9-冗余和重复索引" class="headerlink" title="2.9 冗余和重复索引"></a>2.9 冗余和重复索引</h3><ul><li><strong>产生冗余和重复索引的原因</strong>：<ul><li>MySQL允许在相同列上创建多个索引，但需要单独维护重复的索引，且优化器在优化查询时也要逐个考虑。</li><li>重复索引可能会因为一些失误构建出来，如若发现应移除。表中索引越多会导致INSERT、UPDATE、DELETE速度越慢</li></ul></li><li><strong>区分冗余索引</strong>：(A)是(A,B)的冗余索引，但(B,A)或(B)则不是冗余索引。尽量扩展旧索引而不是创建新索引，有时也会需要冗余索引，因为扩展已有索引可能会导致其变得太大，从而影响其他使用该索引的查询。</li><li><strong>如何找到冗余和重复索引</strong>：<ul><li>可以通过自己编写查询访问 INFORMATION_SCHEMA 表；</li><li>或是通过如 Shlomi Noach 的 common_schema 以及 Percona Tookit 的 pt-duplicate-key-checker 等工具找出冗余和重复的索引并删除。</li></ul></li></ul><h3 id="2-10-索引和锁"><a href="#2-10-索引和锁" class="headerlink" title="2.10 索引和锁"></a>2.10 索引和锁</h3><p>索引可以使查询锁定更少的行，InnoDB只有在访问行时才会对其加锁，索引可以减少访问的行数，需要存储引擎能够过滤掉不需要的行。</p><p>查询只返回2~4之间的行，但却获取了1到4之间行的排它锁，因为MySQL为查询选择的执行计划是索引范围扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id &lt; <span class="number">5</span></span><br><span class="line">  <span class="keyword">AND</span> actor_id &lt;&gt; <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>存储引擎从索引开头获取满足 <code>actor_id &lt; 5</code> 的记录，并不知道可以过滤第一行记录，<code>Using where</code> 表示MySQL服务器将存储引擎返回行以后再应用过滤条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id &lt; <span class="number">5</span></span><br><span class="line">  <span class="keyword">AND</span> actor_id &lt;&gt; <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">--type: range</span></span><br><span class="line"><span class="comment">--key: PRIMARY</span></span><br><span class="line"><span class="comment">--Extra: Using where; Using index</span></span><br></pre></td></tr></table></figure><p>此时保证第一个连接打开，再开启第二个连接查询第一行记录，此查询会被挂起：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> XXX </span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排它锁（写锁），从而无法使用覆盖索引，使SELECT FOR UPDATE 比 LOCK IN SHARE MODE 或非锁定查询要慢很多。</p><h3 id="2-11-实用技巧"><a href="#2-11-实用技巧" class="headerlink" title="2.11 实用技巧"></a>2.11 实用技巧</h3><ul><li>实际创建索引时经常会将一些选择性不高但频繁使用的列作为索引前缀列，如性别SEX，即使某些查询不需要这些列作为查询条件，也可以加上 <code>SEX IN(&#39;m&#39;,&#39;f&#39;)</code> 来匹配索引（仅使用列表值不多时）。</li><li>一些常用于范围查询的列尽量放在组合索引的最后，比如日期、年纪等，因为匹配索引会在第一个范围查询终止，当然一些情况也可以用IN来代替范围查询。</li><li>通过执行 <code>OPTIMIZE TABLE</code> 或者导出再导入的方式重新整理数据，这样可以消除索引和数据的碎片化。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012280107.png" alt></p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：索引概述，常见索引类型，索引优缺点，高性能索引策略包括前缀索引、组合索引、聚簇索引、覆盖索引等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（三）Schema与数据类型优化</title>
    <link href="http://linyishui.top/2020122001.html"/>
    <id>http://linyishui.top/2020122001.html</id>
    <published>2020-12-20T12:14:19.000Z</published>
    <updated>2020-12-29T12:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（三）Schema与数据类型优化"><a href="#《高性能MySQL》（三）Schema与数据类型优化" class="headerlink" title="《高性能MySQL》（三）Schema与数据类型优化"></a>《高性能MySQL》（三）Schema与数据类型优化</h1><h2 id="一-选择优化的数据类型"><a href="#一-选择优化的数据类型" class="headerlink" title="一. 选择优化的数据类型"></a>一. 选择优化的数据类型</h2><ul><li>尽量使用能正确存储数据的最小数据类型；</li><li>整型比字符串操作代价更低，字符比较的字符集和校对规则更复杂，如时间等应该用数字存储；</li><li>尽量避免NULL，可为NULL的列需要更多的空间，索引构建更复杂，所以需要创建索引的列尽量是NOT NULL；</li><li>相同类型的数据，但长度范围不同、精度不同、需要的物理空间也不同，例如 DATETIME 和 TIMESTAMP 都存储时间和日期，精确到秒，TIMESTAMP只会用DATETIME一半的空间</li><li>MySQL的数字类型分整数类型和实数类型，其中 DECIMAL 支持高精度计算，如 DECIMAL(18, 9) 小数点两边将各存9个数字，小数点占一个字节，总共占9个字节。内部浮点计算统一使用 DOUBLE ，DECIMAL 只是存储类型。DECIMAL 会需要额外的空间和计算开销</li><li>字符串类型：<ul><li>VARCHAR：可变长字符串，仅使用必要空间（除非ROW_FORMAT=FIXED），使用一个或两个字节存储字符串长度。没有银弹，节省空间的带来的是UPDATE需要额外的开销（页已满InnoDB会分裂页使新行可以放入页内）</li><li>CHAR：定长字符串，根据定义的长度分配足够的空间。适合存储定长或经常修改的字符串，因为定长类型不容易产生碎片；短列如CHAR(1)只需一个字节，而VARCHAR(2)需要两个字节，一个字节存放长度。</li></ul></li><li>BLOB和TEXT：分别采用二进制和字符串存储较大数据。<ul><li>不同类型家族：TINYBLOB、SMALLBLOB / BLOB、MEDIUMBLOB、LONGBLOB 和 TINYTEXT、SMALLTEXT / TEXT、MEDIUMTEXT、LONGTEXT</li><li>当数据较大时，MySQL会使用外部区域存放值，行内需要为每个值放1~4个字节的指针。</li><li>排序时只会对前 <code>max_sort_length</code> 个字节排序，也可以使用 <code>ORDER BY SUSTRING(column, length)</code> 。</li></ul></li><li>日期和时间类型：<ul><li>DATETIME：1001年到9999年，精度为秒，格式为YYYYMMDDHHMMSS的整数，与时区无关，占用8个字节的存储空间，时间值的显式会因为时区不同而不同。</li><li>TIMESTAMP：1970年到2038年，保存从1970年1月1日午夜以来的秒数（格林尼治时间），只使用4个字节的存储空间，时间值的显式会因为时区不同而不同。</li></ul></li><li>位数据类型：<ul><li>BIT：旧版本BIT等价于TINYINT，BIT(1)存放一个位，最大为64位。BIT属于字符串类型，不建议使用。</li><li>SET</li></ul></li><li>特殊类型：<ul><li>低于秒精度的时间戳</li><li>IPv4地址，经常用 VARCHAR(15) 存放IP地址，实际上本质是32位无符号整数，小数点只是方便阅读，使用无符号整数存放，MySQL还提供了 <code>INET_ATON()</code> 和 <code>INET_NTOA()</code> 来在二者间转换。 </li></ul></li></ul><h2 id="二-选择合适的标识列"><a href="#二-选择合适的标识列" class="headerlink" title="二. 选择合适的标识列"></a>二. 选择合适的标识列</h2><p>标识列要常用于比较（如关联操作）、作为查询条件、外键等。不同表的相同标识列要保持数据类型一致，并且在选择数据类型时考虑MySQL如何执行计算和比较（如ENUM和SET使用整数存储，比较时转换为字符串）。</p><ul><li><strong>整数类型</strong>：最适合的标识列类型，效率高并且可以 AUTO_INCREMENT 。</li><li><strong>ENUM和SET类型</strong>：糟糕的选择。</li><li><strong>字符串类型</strong>：消耗空间，并且效率差于数字，特别是一些随机生成的字符串会任意分布在很大的空间内，导致INSERT或SELECT执行很慢。存储UUID应该去掉 <code>-</code> ，直接用 <code>UNHEX()</code> 函数转换为16字节数字存放在 BINARY(16) 列中，检索时使用 <code>HEX()</code> 格式化为十六进制格式。<ul><li>插入值随机写到索引的不同位置，使INSERT变慢，会导致页分裂、磁盘随机访问、对于聚簇存储引擎产生聚簇索引碎片。</li><li>逻辑上相邻的行分布在磁盘和内存的不同地方，使SELECT变慢。</li><li>随机值导致缓存赖以工作的访问局部性原理失效，整个数据集都一样“热”，缓存带来的好处就消失了。</li></ul></li></ul><h2 id="三-常见设计陷阱"><a href="#三-常见设计陷阱" class="headerlink" title="三. 常见设计陷阱"></a>三. 常见设计陷阱</h2><ol><li><strong>太多的列</strong>：MySQL存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，在服务器层将缓冲转码为各个列，将编码后的内容转码为各个行的数据格式操作代价较高，所以尽量避免上千个属性这种极端情况。</li><li><strong>太多的关联</strong>：期望查询能够快速的执行且并发性好，单个查询不要超过12个表关联。</li><li><strong>避免滥用枚举</strong>：修改枚举中值会进行一次 ALTER TABLE 操作。</li></ol><h2 id="四-范式和反范式"><a href="#四-范式和反范式" class="headerlink" title="四. 范式和反范式"></a>四. 范式和反范式</h2><p>范式化的数据库中，事实数据仅出现一次；反范式化的数据库中，信息是冗余的。</p><p>范式的优点：</p><ul><li>更新操作更快；</li><li>很少有重复数据，需要修改的数据更少；</li><li>表空间更小，在内存中执行更快；</li><li>很少有多余数据，所以更少需要 DISTINCT 或 GROUP BY 语句。</li></ul><p>范式的缺点：</p><ul><li>常常需要关联，不但代价昂贵，也可能使索引策略无效。</li></ul><p>反范式的优点：</p><ul><li>数据都在一张表，所以很少关联；</li><li>全表扫描基本是顺序I/O，不需要关联表避免了随机I/O；</li><li>可以构建有效的索引策略；</li></ul><p>真实的开发中很少会极端的遵循范式或反范式，而是混用二者；常见如<strong>复制</strong>或<strong>缓存</strong>，在不同的表存储相同的列，冗余的字段往往有其意义，比如排序需求、避免关联、避免多次查询等等。</p><h2 id="五-缓存表和汇总表"><a href="#五-缓存表和汇总表" class="headerlink" title="五. 缓存表和汇总表"></a>五. 缓存表和汇总表</h2><p>虽然冗余数据能够很好的提升性能，但有时还是需要创建一张完全独立的汇总表或缓存表。</p><p>一般缓存表用来存放那些可以简单获取但获取速度较慢的数据（逻辑上冗余的数据）；汇总表则存放使用 GROUP BY 语句聚合的数据。</p><p>例如，一个网站需要计算之前24小时发送的消息数，可以每小时生成一张汇总表（Redis应该是更好的解决方案），这样比实时维护计数器要高效的多，但并不精确。这种方案要远远快于统计message中所有行，实时计算统计值需要扫描表中的大部分数据，需要的索引也一般会影响到UPDATE操作（所以一般不希望创建这类索引）。</p><p>缓存表可以采用不同的存储引擎，比如主表是InnoDB，缓存表则使用MyISAM，这样可以得到更小的索引占用空间，并且可以做全文搜索。</p><p>使用缓存表和汇总表需要决定是实时维护数据还是定期重建，重建需要保证数据在操作时依然可用，所以需要“影子表”实现，即根据真实表创建一张影子表，完成建表后，通过一个原子性的重命名操作切换影子表和原表。</p><p><strong>更快的读，更慢的写</strong>，为了增加读查询的速度，会经常建一些额外索引、增加冗余列，甚至创建缓存表和汇总表。这些都会导致写查询变慢，开发难度提升，但能显著提高读操作的性能。</p><h2 id="六-提高-ALTER-TABLE-操作的速度"><a href="#六-提高-ALTER-TABLE-操作的速度" class="headerlink" title="六. 提高 ALTER TABLE 操作的速度"></a>六. 提高 ALTER TABLE 操作的速度</h2><p>ALTER TABLE 对于大表会执行很慢，大部分修改表操作会按新结构创建一个新的空表，从旧表查出所有数据插入新表，最后删除旧表。<strong>大部分 ALTER TABLE 操作会导致MySQL服务中断</strong>。 </p><p>常规场景的技巧：</p><ul><li>先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库切换；</li><li>“影子拷贝”，用要求的表结构创建一张和原表无关的新表，然后通过<strong>重命名</strong>和<strong>删表</strong>操作交换两张表。</li></ul><p>不是所有 ALTER TABLE 操作都要重建表，如下修改字段默认值，前者创建新表，后者直接修改 <code>.frm</code> 文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX</span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> xxx TINYINT(<span class="number">3</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> xxx <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="6-1-只修改-frm-文件，不重建表"><a href="#6-1-只修改-frm-文件，不重建表" class="headerlink" title="6.1 只修改 .frm 文件，不重建表"></a>6.1 只修改 .frm 文件，不重建表</h3><p>只修改 .frm 文件要远远快于重建表，而MySQL有时会在没必要重建表的时候仍去重建。比如移除一个列的 AUTO_INCREMENT 属性；增加、移除、修改ENUM和SET常量。</p><p>这类情况可以创建新的 <code>.frm</code> 文件，替换旧的：</p><ol><li>创建一张有相同结构的空表，进行需要的修改；</li><li>执行 <code>FLUSH TABLES WITH READ LOCK</code> ，会关闭所有正在使用的表，且禁止任何表被打开；</li><li>交换 <code>.frm</code> 文件；</li><li>执行 <code>UNLOCK TABLES</code> 释放第二步的读锁。</li></ol><h3 id="6-2-快速创建-MyISAM-索引"><a href="#6-2-快速创建-MyISAM-索引" class="headerlink" title="6.2 快速创建 MyISAM 索引"></a>6.2 快速创建 MyISAM 索引</h3><p>先禁用索引、载入数据，然后重新启用索引：因为构建索引的工作被延迟到数据完全载入后，这个时候可以利用排序来创建索引，相比会快很多，并且使索引树的碎片更少、更紧凑（只对非唯一索引有效）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">DISABLE</span> <span class="keyword">KEYS</span>;</span><br><span class="line"><span class="comment">--LOAD THE DATA</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">ENABLE</span> <span class="keyword">KEYS</span>;</span><br></pre></td></tr></table></figure><p>InnoDB也可以先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引。</p><p>操作步骤：</p><ol><li>用需要的表结构创建一张新表，但不包含索引；</li><li>载入数据到表中以构建 <code>.MYD</code> 文件；</li><li>按照需要的结构创建另一张空表，并包含索引，创建出 <code>.frm</code> 和 <code>.MYI</code> 文件；</li><li>获取读锁并刷新表；</li><li>重命名第二张表的 <code>.frm</code> 和 <code>.MYI</code> 文件，使MySQL认为是第一张表的文件；</li><li>释放读锁；</li><li>使用 <code>REPAIR TABLE</code> 重建表的索引，此操作通过排序来构建所有索引，包括唯一索引。</li></ol><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：数据类型优化，选择合适的标识列，常见Schema设计陷阱，范式与反范式，缓存表和汇总表，提高ALTER TABLE操作的速度等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（二）基准测试和服务器性能剖析</title>
    <link href="http://linyishui.top/2020121701.html"/>
    <id>http://linyishui.top/2020121701.html</id>
    <published>2020-12-17T12:12:06.000Z</published>
    <updated>2020-12-29T12:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（二）基准测试和服务器性能剖析"><a href="#《高性能MySQL》（二）基准测试和服务器性能剖析" class="headerlink" title="《高性能MySQL》（二）基准测试和服务器性能剖析"></a>《高性能MySQL》（二）基准测试和服务器性能剖析</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是基准测试？"><a href="#1-1-什么是基准测试？" class="headerlink" title="1.1 什么是基准测试？"></a>1.1 什么是基准测试？</h3><p>基准测试是针对系统设计的一种压力测试，通常是为了掌握系统的行为或重现某个系统状态、做新硬件的可靠性测试等。</p><h3 id="1-2-为什么需要基准测试？"><a href="#1-2-为什么需要基准测试？" class="headerlink" title="1.2 为什么需要基准测试？"></a>1.2 为什么需要基准测试？</h3><p>基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。观察系统在不同压力下的行为、评估系统的容量、观察系统如何处理不同的数据。</p><h2 id="二-基准测试的策略"><a href="#二-基准测试的策略" class="headerlink" title="二. 基准测试的策略"></a>二. 基准测试的策略</h2><p>两种主要策略：</p><ul><li>集成式：针对整个系统的整体测试；</li><li>单组件式：单独测试MySQL。</li></ul><p>一般建议做集成式测试，少数如需要比较不同的schema或查询的性能、针对某个具体问题的测试、避免过长的基准测试来检测某些调整的效果，可以考虑只测试MySQL。如果使用的是真实数据，那么只测试MySQL也是有效的。</p><h3 id="2-1-测试指标"><a href="#2-1-测试指标" class="headerlink" title="2.1 测试指标"></a>2.1 测试指标</h3><ul><li><strong>吞吐量</strong>：单位时间内处理的事务数，单位为每秒事务数TPS。</li><li><strong>响应时间或者延迟</strong>：任务所需的整体时间，通常使用百分比响应时间，如95%的响应时间都是5毫秒。</li><li><strong>并发性</strong>：同时工作的并发操作 / 线程数 / 连接数，当并发性增加时，要关注吞吐量是否下降，响应时间是否变长。可以通过 sysbench 指定多个线程，记录MySQL数据库的 Threads_running 状态值。</li><li><strong>可扩展性</strong>：给系统增加一倍的资源，理想情况下可以获得两倍的结果。</li></ul><h2 id="三-基准测试工具"><a href="#三-基准测试工具" class="headerlink" title="三. 基准测试工具"></a>三. 基准测试工具</h2><p>集成式测试工具：</p><ul><li>ab：Apache HTPP服务器基准测试工具，测试HTTP服务器每秒最多可以处理多少请求，只能针对单个URL进行尽可能快的压力测试。</li><li>http_load：可以通过输入文件提供多个URL随机选择进行测试。</li><li>JMeter：Java开发的测试工具，除了Web也可以测试FTP或JDBC等。</li></ul><p>单组件式测试工具：</p><ul><li>mysqlslap：MySQL 5.1发行包提供，模拟服务器的负载，输出计时信息。</li><li>MySQL Benchmark Suite（sql-bench）：MySQL发行包提供的基准测试套件，主要用于测试服务器执行查询的速度。可以用于比较不同存储引擎或不同配置的性能测试，也可以比较两个服务器的总体性能。单线程且串行执行，只能比较单CPU服务器的性能差别。</li><li>Super Smack：提供压力测试和负载生成，可以模拟多用户访问，加载测试数据到数据库，支持使用随机数据填充测试表。</li><li>Database Test Suite：OSDL开源实验室开发。</li><li>sysbench：多线程系统压测工具，支持Lua脚本语言，全能测试工具，支持MySQL、操作系统和硬件测试。</li></ul><h2 id="四-性能剖析概述"><a href="#四-性能剖析概述" class="headerlink" title="四. 性能剖析概述"></a>四. 性能剖析概述</h2><h3 id="4-1-常见场景"><a href="#4-1-常见场景" class="headerlink" title="4.1 常见场景"></a>4.1 常见场景</h3><p>常见性能相关的服务请求：</p><ul><li>如何确认服务器是否达到了性能最佳状态？</li><li>分析某条语句为什么执行的不够快？</li><li>诊断“停顿”，“堆积”或“卡死”的某些间歇性疑难故障？</li></ul><h3 id="4-2-性能剖析的标准"><a href="#4-2-性能剖析的标准" class="headerlink" title="4.2 性能剖析的标准"></a>4.2 性能剖析的标准</h3><p>定义一个性能的标准：完成某件任务的所需时间度量，也就是<strong>响应时间</strong>。对于数据库来说就是查询的响应时间，不管是DDL还是DML都用查询来泛指。优化就是在一定的工作负载下尽可能地降低响应时间。</p><p>无法测试就无法有效地优化，首先应该测量查询时间花在什么地方，要准确测量需要注意两点：</p><ul><li>不要在错误的时间启动和停止测量；</li><li>测量的是目标活动本身，而不是聚合后的信息。</li></ul><p>如测量慢查询时去排查整个服务器来判断问题出处，测量应该从慢查询开始到结束的时间，而不是查询之前或之后的时间。</p><p>查询时间包括：</p><ul><li>执行时间：只需测量定位不同的子任务花费的时间，优化去掉一些子任务、降低一些子任务执行频率、提高子任务执行效率。</li><li>等待时间：可能因为其他系统间接影响，任务间也可能因为竞争磁盘或CPU资源而相互影响，</li></ul><p>通过性能剖析可以分析定位是哪些子任务是优化的目标。</p><h2 id="五-如何进行性能剖析"><a href="#五-如何进行性能剖析" class="headerlink" title="五. 如何进行性能剖析"></a>五. 如何进行性能剖析</h2><h3 id="5-1-性能剖析步骤"><a href="#5-1-性能剖析步骤" class="headerlink" title="5.1 性能剖析步骤"></a>5.1 性能剖析步骤</h3><p>性能剖析包括两步：</p><ul><li>测量任务所花费的时间；</li><li>对结果进行统计和排序，把重要的任务排在前面。</li></ul><h3 id="5-2-性能剖析的输出信息"><a href="#5-2-性能剖析的输出信息" class="headerlink" title="5.2 性能剖析的输出信息"></a>5.2 性能剖析的输出信息</h3><p>性能剖析工具通常都是计时器，记录任务的开始和结束时间。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012010102.png" alt></p><p>性能剖析需要系统可测量化，系统需要有一些测量点可以捕获并收集数据，MySQL直到版本5.5才首次提供Performance Schema 包含一些基于时间的可测量点，在此之前只能收集到记录活动发生次数的 show status 计数器。而 Percona Server 可以提供更多更详细的查询级别测量点。</p><p>性能剖析输出的排名、总计、平均值之外缺失的信息：</p><ul><li>值得优化的查询：性能剖析不会自动给出需要优化的查询，总响应时间占比小的查询不值得优化，优化成本大于收益的查询不值得优化。</li><li>异常情况：有些查询虽然执行频率不高，但每次执行都很慢。</li><li>未知的未知：丢失时间-任务的总时间和测量得到的时间之差，如CPU时间为10秒，剖析得到任务时间为9.7秒，存在300毫秒的丢失时间。可能会忽略某些重要信息。</li><li>被隐藏的细节：只分析平均值会忽略到一些情况，如医院只看所有病人的平均体温，可以输出更多响应时间的信息，如直方图、百分比、标准差、偏差指数等。</li></ul><h2 id="六-剖析MySQL查询"><a href="#六-剖析MySQL查询" class="headerlink" title="六. 剖析MySQL查询"></a>六. 剖析MySQL查询</h2><h3 id="6-1-慢查询日志"><a href="#6-1-慢查询日志" class="headerlink" title="6.1 慢查询日志"></a>6.1 慢查询日志</h3><h4 id="（1）相关参数"><a href="#（1）相关参数" class="headerlink" title="（1）相关参数"></a>（1）相关参数</h4><ol><li>slow_query_log ：是否开启慢查询日志，1表示开启，0表示关闭。</li><li>log-slow-queries ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>long_query_time ：慢查询时间设置，当查询时间多于设定的时间值时，记录日志。</li></ol><h4 id="（2）慢查询日志配置"><a href="#（2）慢查询日志配置" class="headerlink" title="（2）慢查询日志配置"></a>（2）慢查询日志配置</h4><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：</p><ol><li><p>查询慢日志是否开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--OFF 为关闭 ON为开启</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slow_query_log%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>开启慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：使用set global slowquerylog=1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）</strong></p></li><li><p>永久开启慢查询日志：</p><p>修改my.cnf文件，增加或修改参数slow_query_log 和slow_query_log_file后，然后重启MySQL服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log =1</span><br><span class="line">slow_query_log_file=/usr/local/mysql/data/localhost-slow.log</span><br></pre></td></tr></table></figure></li></ol><h4 id="（3）慢查询时间设置"><a href="#（3）慢查询时间设置" class="headerlink" title="（3）慢查询时间设置"></a>（3）慢查询时间设置</h4><p>这个是由参数 long_query_time 控制，默认情况下 long_query_time 的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。</p><ol><li><p>查询慢日志时间设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置慢查询日志时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2-剖析服务器负载"><a href="#6-2-剖析服务器负载" class="headerlink" title="6.2 剖析服务器负载"></a>6.2 剖析服务器负载</h3><p>最简单的方式就是使用<strong>慢查询日志</strong>，是MySQL开销最低、精度最高的测量查询工具，使用时只需注意磁盘空间开销，MySQL 5.1 版本后可以通过 <code>long_query_time</code> 为 0 来捕获所有的查询，查询的响应时间可以做到微秒级。</p><p>Percona Server 的慢查询日志相比MySQL会记录更多信息，如执行计划、锁、I/O活动等。</p><p>可以在业务高峰期开启一个小时的记录查询，首先生成一个剖析报告，需要一个适合的剖析工具，如 <code>pt-query-digest</code> 分析 tcpdump。</p><h3 id="6-3-剖析单条查询"><a href="#6-3-剖析单条查询" class="headerlink" title="6.3 剖析单条查询"></a>6.3 剖析单条查询</h3><p>定位到需要优化的查询语句后，</p><ul><li><p>SHOW PROFILE：</p><ul><li><p>作用：会测量所有服务器上执行的语句，记录耗费时间和执行状态变更相关的数据。</p></li><li><p>开启：<code>SET profiling = 1;</code> </p></li><li><p>使用：<code>SHOW PROFILES</code> 和 <code>SHOW PROFILE FOR QUERY 1;</code> 结果按照执行顺序排序，而不是花费时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @query_id = <span class="number">252</span>;</span><br><span class="line"><span class="keyword">SELECT</span> STATE, <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) <span class="keyword">AS</span> Total_R,</span><br><span class="line"> <span class="keyword">ROUND</span>(</span><br><span class="line"><span class="number">100</span> * <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) /</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>)</span><br><span class="line"> <span class="keyword">FROM</span> information_schema.PROFILING</span><br><span class="line"> <span class="keyword">WHERE</span> QUERY_ID = @query_id), <span class="number">2</span></span><br><span class="line"> ) <span class="keyword">AS</span> Pct_R, </span><br><span class="line"> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> Calls,</span><br><span class="line"> <span class="keyword">SUM</span>(<span class="keyword">DURATION</span>) / <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="string">"R/Call"</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.PROFILING</span><br><span class="line"><span class="keyword">WHERE</span> QUERY_ID = @query_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> STATE</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Total_R <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></li><li><p>排序后可以明显的找到查询的耗时步骤，找到其中值得优化的部分去优化。</p></li></ul></li><li><p>SHOW STATUS：</p><ul><li><p>作用：返回一些计数器，有服务器级别和单个连接会话级别的计数器，如 <code>Queries</code> 在会话开始前为0，每提交一条查询增加1。</p></li><li><p>使用：<code>SHOW GLOBAL STATUS</code> 查看服务器级别的次数统计。<code>SHOW STATUS</code> 包含两种级别的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--重置计数器</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="comment">--执行SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tv_tallymaster_bak <span class="keyword">where</span> book_id <span class="keyword">in</span> (<span class="string">'100199100'</span>,<span class="string">'100200000'</span>);</span><br><span class="line"><span class="comment">--查看指定计数器结果</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">WHERE</span> Variable_name <span class="keyword">LIKE</span> <span class="string">'Handler%'</span> <span class="keyword">OR</span> Variable_name <span class="keyword">LIKE</span> <span class="string">'Created%'</span></span><br><span class="line"><span class="comment">-- Created_tmp_tables 表示使用临时表数目</span></span><br><span class="line"><span class="comment">-- Created_tmp_disk_tables 磁盘临时表</span></span><br><span class="line"><span class="comment">-- Handler_read_rnd_next 没有用到索引的读操作</span></span><br></pre></td></tr></table></figure></li><li><p>只能显示某种活动的频繁程度（如读索引），只有一个参数指全局级别的操作时间（Innodb_row_lock_time）。</p></li><li><p>比较有用的计数器：</p><ul><li>句柄计数器（handler counter）</li><li>临时文件</li><li>表计数器</li></ul></li><li><p>SHOW STATUS 本身也会创建一个临时表，通过句柄操作访问此表，会影响计数器数字。</p></li><li><p>EXPLAIN 有类似的结果，但基于统计；SHOW STATUS 的结果基于测量。</p></li></ul></li><li><p>检查慢查询日志的条目：</p><ul><li>使用 Percona Server 得到更详细有用的信息。</li><li><code>pt-query-digest</code> 标题一般会打印出字节偏移值（3214），使用tail指令直接跳转到对应部分：<code>tail -c +3214 /path/to/query.log | head -n100</code></li></ul></li><li><p>使用 <code>Performance Schema</code> </p></li></ul><h3 id="6-4-诊断间歇性问题"><a href="#6-4-诊断间歇性问题" class="headerlink" title="6.4 诊断间歇性问题"></a>6.4 诊断间歇性问题</h3><p>例如一个简单查询，正常情况下使用很快，但有几次不合理的执行了很久。手工执行一遍，非常快；然后用EXPLAIN查询执行计划，也正确的使用了索引。修改WHERE条件的值，排除缓存命中的可能性。</p><p>慢查询日志没有执行计划或详细的时间信息，可能是系统有其他东西消耗了资源，比如正在备份，或是某种类型的锁或争用阻塞了查询进度。</p><p>尽量避免试错的诊断方式，以下是一些常见的案例，某些是数据库问题，但也有的不是：</p><ul><li>应用通过 curl 从一个运行很慢的外部服务获取汇率报价的数据。</li><li>memcached 缓存中一些重要条目过期，导致大量请求落到MySQL重新生成缓存条目。</li><li>DNS查询偶尔有超时现象。</li><li>可能由于互斥锁争用，或者内部删除查询缓存的算法效率太低的缘故，MySQL的查询缓存有时候会导致服务有短暂的停顿。</li><li>当并发度超过某个阈值时，InnoDB的扩展性限制导致查询计划的优化需要很长时间。</li></ul><p>只能在问题发生的地方通过观察资源的使用情况，并尽可能的测量出数据，才能避免在没问题的地方耗费精力。</p><ul><li><p><strong>确认单条查询问题还是服务器问题</strong>：</p><ul><li><p>服务器整体没问题，只是某条查询慢，可以将注意力放在这条特定的查询上面。</p></li><li><p>判断方法：</p><ul><li><p>使用 <code>SHOW GLOBAL STATUS</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每秒捕获一次SHOW GLOBAL STATUS的数据，输出给awk计算并输出每秒的查询数、Threads_connected和Threads_running表示当前正在执行查询的线程数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysqladmin ext -i1 | awk <span class="string">'/Queries/&#123;q=$4-qp;qp=$4&#125; /Threads_connected/&#123;tc=$4&#125; /Threads_running/&#123;printf "%5d %5d %5d\n", q, tc, $4&#125;'</span></span></span><br></pre></td></tr></table></figure><p>每秒查询数一般会下跌，其他两个至少会出现一个尖刺。可能是服务器内部碰到了某种瓶颈，导致新查询在开始执行前因为要获取老查询正在等待的锁而造成堆积（一般也会导致后端服务器出现排队）；也可能是服务区突然收到大量查询请求，比如前端memcached突然失效导致的查询风暴。</p></li><li><p>使用 <code>SHOW PROCESSLIST</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过不停捕获SHOW PROCESSLIST的输出，观察是否有大量现场处于不正常状态或有不正常的特征，如statistics状态一般服务器在查询优化阶段确定表关联顺序—非常快，所以查询不应长时间处与此状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \G垂直输出结果，方便使用 sort|uniq|sort 计算某一列值出现次数，一般State列会很有用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -e <span class="string">'SHOW PROCESSLIST\G'</span> | grep State: | sort | uniq -c | sort -rn</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 大量线程处于freeing items说明出现了大量有问题查询</span></span><br></pre></td></tr></table></figure><ul><li>也可以直接查询表：<code>SELECT * FROM information_schema.PROCESSLIST</code></li><li>使用 innotop 工具。</li></ul></li><li><p>使用查询日志：</p><ul><li>开启慢查询日志，并在全局级别设置 <code>long_query_time=0</code> ，确认所有连接都采用了新设置，可能需要重置所有连接，或是使用 Percona Server。</li><li>也可以通过 tcpdump 和 pt-query-digest 工具替代。</li><li>找到吞吐量突然下降时间段的日志，一般是吞吐量下降后第一个完成的查询。</li></ul></li></ul></li></ul></li><li><p><strong>捕获诊断数据</strong>：</p><ul><li><p>辅助工具：</p><ul><li>一个可靠且实时的触发器；</li><li>一个收集诊断数据的工具。</li></ul></li><li><p>找到能和正常时的阈值进行比较的指标，如正在运行的线程数量、处于“freeing items”状态的线程数量等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -e <span class="string">'SHOW PROCESSLIST/G'</span> | grep -c <span class="string">"State: freeing items"</span></span></span><br></pre></td></tr></table></figure></li><li><p>Percona Toolkit 的 pt-stalk 可以在触发条件时收集数据。</p></li><li><p>需要收集的数据：系统状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存使用率、MySQL的几个SHOW STATUS / SHOW PROCESSLIST / SHOW INNODB STATUS</p></li></ul></li></ul><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：基准测试和服务器性能剖析，MySQL查询剖析等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（一）架构和历史</title>
    <link href="http://linyishui.top/2020120801.html"/>
    <id>http://linyishui.top/2020120801.html</id>
    <published>2020-12-08T12:03:19.000Z</published>
    <updated>2021-05-12T12:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《高性能MySQL》（一）架构和历史"><a href="#《高性能MySQL》（一）架构和历史" class="headerlink" title="《高性能MySQL》（一）架构和历史"></a>《高性能MySQL》（一）架构和历史</h1><p>MySQL的存储引擎架构将<strong>查询处理</strong>及其他<strong>系统任务</strong>和<strong>数据的存储/提取</strong>相分离。从而可以在使用时根据性能、特性等需求来选择数据存储的方式。</p><h2 id="一-MySQL逻辑架构"><a href="#一-MySQL逻辑架构" class="headerlink" title="一. MySQL逻辑架构"></a>一. MySQL逻辑架构</h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201201/202012010101.png" alt></p><ul><li>第一层：连接处理、授权认证、安全等等。</li><li>第二层：查询解析、分析、优化、缓存以及所有的内置函数，还有所有的跨存储引擎的实现：存储过程、触发器、视图。</li><li>第三层：存储引擎，服务器通过API与存储引擎进行通信，包括几十个底层函数，如“开始一个事务”、“根据主键提取一行记录”。存储引擎不会解析SQL（Innodb会解析外键，因为MySQL服务器本身没有实现此功能），存储引擎只会简单的响应上层服务器的请求。</li></ul><h3 id="1-1-连接与安全"><a href="#1-1-连接与安全" class="headerlink" title="1.1 连接与安全"></a>1.1 连接与安全</h3><p>每个客户端连接对应服务器进程中的一个线程，连接的所有查询都在此线程中进行，服务器会负责缓存线程而不必每次都创建新线程，MySQL 5.5后支持线程池来支持大量连接。</p><p>认证基于用户名、原始主机信息和密码。使用安全套接字SSL的方式连接，可以使用X5.09证书认证。连接成功后会继续验证用户是否有相应请求的权限。</p><h3 id="1-2-优化与执行"><a href="#1-2-优化与执行" class="headerlink" title="1.2 优化与执行"></a>1.2 优化与执行</h3><p>MySQL会解析查询，并创建内部数据结构-解析树，然后对其进行各种优化，包括重写查询、决定表的读写顺序、选择合适的索引等。</p><ul><li>可以通过特殊关键字 <strong>hint</strong> 提示优化器，影响其决策过程；</li><li>可以通过 <strong>explain</strong> 请求优化器解释优化过程的各个因素，从而了解到服务的优化决策，便于用户重构查询和schema、修改相关配置。</li></ul><p>对于如 SELECT 语句，在解析查询前会检查查询缓存，若有相应查询就可以直接返回结果。 </p><h2 id="二-并发控制"><a href="#二-并发控制" class="headerlink" title="二. 并发控制"></a>二. 并发控制</h2><p>MySQL在两个层控制并发：服务器层和存储引擎层。</p><h3 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1 读写锁"></a>2.1 读写锁</h3><p>并发读数据不会有问题，但当一个用户读取数据，另外一个用户删除数据时，可能读取会报错，也可能读到了不一致的数据。</p><p>通过实现共享锁（shared lock）和排它锁（exclusive lock），也叫读锁和写锁，这两种锁组成的锁系统来解决问题。写锁会阻塞其他写锁和读锁，</p><h3 id="2-2-锁粒度"><a href="#2-2-锁粒度" class="headerlink" title="2.2 锁粒度"></a>2.2 锁粒度</h3><p>为了提高共享资源的并发性，减少锁定的对象，避免锁住所有资源。但锁的所有操作，如获取锁、检查是否锁已释放、释放锁等都会增加系统开销。<strong>锁策略就是在锁的开销和数据的安全性之间寻找平衡</strong>。</p><ul><li><strong>表锁</strong>：<ul><li>表锁是开销最小的锁，会锁定整张表，写操作时会阻塞其他读写操作，写锁未被持有时其他用户才能获取读锁，读锁间不相互阻塞。</li><li>写锁的优先级比读锁要高，所以写请求可能会被插入到读请求前，服务器可能会忽略存储引擎的表锁实现为如 <code>ALTER TABLE</code> 之类的语句加表锁。</li></ul></li><li><strong>行锁</strong>：<ul><li>行锁可以提供更好的并发性，但也带来了最大的锁开销。行锁由存储引擎实现（InnoDB和XtraDB等）</li></ul></li></ul><h3 id="2-3-锁类型"><a href="#2-3-锁类型" class="headerlink" title="2.3 锁类型"></a>2.3 锁类型</h3><p>MySQL包括如下锁类型：</p><ul><li><p><strong>读写锁</strong>：同Java一样，写锁持有时其他事务不能获取任何锁，读锁持有时其他事务可以获取读锁，但不能获取写锁。</p><ul><li><strong>互斥锁</strong>：简称X锁，又叫写锁。</li><li><strong>共享锁</strong>：简称S锁，又叫读锁。</li></ul></li><li><p><strong>意向锁</strong>：更容易的支持多粒度的封锁，在同时存在行级锁和表级锁的情况下，事务想要对表加锁，要首先分别检查是否有其他事务加表锁或行锁，这个过程需要对每一行都进行一次检测，这相当耗时。</p><p><strong>意向锁在 X/S 锁之上引入了 IX/IS，二者都是表锁，规定事务获取某行的X或S锁前要先获取IX或IS锁</strong>。这样当事务想对表加写锁时只需检测是否有其他事务对表加了 X/IX/S/IS 锁，只需做一次检测。（<strong>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁</strong>）</p><ul><li><strong>意向共享锁</strong>（IS Lock）：事务想要获得一张表中某几行的共享锁；</li><li><strong>意向排他锁</strong>（IX Lock）：事务想要获得一张表中某几行的排他锁；</li><li><strong>插入意向锁</strong>（Insert Intention Lock）：插入意向锁是间隙锁的一种，专门针对insert操作的。即多个事务在同一个索引、同一个范围区间内插入记录时，如果插入的位置不冲突，则不会阻塞彼此</li></ul></li><li><p><strong>自增锁</strong>（Auto-inc Locks）：自增锁是一种特殊的<strong>表级别锁</strong>，专门针对事务插入 AUTO-INCREMENT 类型的列。即一个事务正在往表中插入记录时，其他事务的插入必须等待，以便第1个事务插入的行得到的主键值是连续的。</p></li><li><p><strong>记录锁</strong>（Record Locks）：</p><ul><li>记录锁是的单个行记录上的锁，会阻塞其他事务对其插入、更新、删除；</li><li><code>locks rec but not gap</code> 。</li></ul></li><li><p><strong>间隙锁</strong>（Gap Lock）：间隙锁锁定记录的一个间隔，但不包含记录本身。</p></li><li><p><strong>临键锁</strong>（Next-Key Lock）：</p><ul><li><code>Next-Key Lock = Gap Lock + Record Lock</code> 临建锁是记录锁与间隙锁的组合，即：既包含索引记录，又包含索引区间，主要是为了解决幻读。</li></ul></li></ul><p>总结：</p><ul><li>表锁：意向锁，自增锁。</li><li>行锁：读写锁，记录锁，间隙锁，临键锁。</li></ul><h2 id="三-事务"><a href="#三-事务" class="headerlink" title="三. 事务"></a>三. 事务</h2><h3 id="3-1-什么是事务？"><a href="#3-1-什么是事务？" class="headerlink" title="3.1 什么是事务？"></a>3.1 什么是事务？</h3><p>事务是<strong>一组原子性的SQL查询</strong>，一个独立的工作单元。全部语句能够被数据库引擎成功应用，则执行该组查询；有任一语句无法执行，事务的所有语句都不会执行。<strong>要么全部执行成功，要么全部执行失败</strong>。</p><h3 id="3-2-ACID"><a href="#3-2-ACID" class="headerlink" title="3.2 ACID"></a>3.2 ACID</h3><ul><li><strong>原子性（Atomicity）</strong>：事务作为一个不可分割的整体被执行，包含在其中的对数据库的操作要么<strong>全部被执行</strong>，要么<strong>全部不执行</strong>。</li><li><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。数据库发生故障导致事务中断，未完成的修改不能写入物理数据库。</li><li><strong>隔离性（Isolation）</strong>：一个事务在最终提交前应该对其他事务是不可见的，在并发操作相同数据时，每个事务都有独立的数据空间；多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。</li></ul><p>事务所带来的安全性也需要额外的工作和开销，而MySQL的存储引擎架构可以支持用户根据业务是否需要事务选择合适的存储引擎。</p><h3 id="3-3-隔离级别"><a href="#3-3-隔离级别" class="headerlink" title="3.3 隔离级别"></a>3.3 隔离级别</h3><ol><li><strong>读未提交</strong>（READ UNCOMMITTED）：<ul><li>事务中的修改，即使没有提交，对其它事务也是可见的。</li><li>会<strong>导致脏读</strong>（读到未提交的数据），性能也并未比其它级别好很多。</li></ul></li><li><strong>读已提交</strong>（READ COMMITTED）： <ul><li>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li><li>也叫不可重复读，因为两次执行相同的查询可能会得到不同的结果。</li><li>大部分数据库的默认隔离级别，MySQL因为历史遗留问题，默认隔离级别是可重复读。</li></ul></li><li><strong>可重复读</strong>（REPEATABLE READ）：<ul><li>保证在同一个事务中多次读取同一数据的结果是一样的。</li><li>不可重复读在同一事务中多次读取可能会读到不同的数据结果，可重复读则保证同一个事务中只会读到相同结果</li></ul></li><li><strong>可串行化</strong>（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</li></ol><table><thead><tr><th>隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th><th style="text-align:center">加锁读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>READ COMMITTED</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>REPEATABLE READ</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td>SERIALIZABLE</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr></tbody></table><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210401/202104200103.png" alt></p><h4 id="（1）为什么MySQL默认是可重复读？"><a href="#（1）为什么MySQL默认是可重复读？" class="headerlink" title="（1）为什么MySQL默认是可重复读？"></a>（1）为什么MySQL默认是可重复读？</h4><p>MySql的历史版本中，主从复制基于binlog（记录数据库修改的文件），当时binlog只有 <strong>statement</strong> 这种模式（记录修改SQL语句），后来还有<strong>row</strong>（记录每行数据变更）和 <strong>mixed</strong>（前两种模式混合）总共三种模式。</p><p><strong>statement</strong>模式在<strong>读已提交</strong>下进行主从复制有BUG，在master上执行的顺序为先删后插，而binlog的记录顺序为先插后删，所以slave同步binlog后导致执行顺序和master不一致。</p><p>解决方法：</p><ol><li>调整隔离级别为<strong>可重复读</strong>。</li><li>更新模式为<strong>row</strong>（5.1版本后引入）。</li></ol><h4 id="（2）为什么选择读已提交？"><a href="#（2）为什么选择读已提交？" class="headerlink" title="（2）为什么选择读已提交？"></a>（2）为什么选择读已提交？</h4><p>首先排除<strong>读未提交</strong>和<strong>可串行化</strong>，前者会出现脏读，后者每次读操作都要加锁。</p><p>选读已提交/不可重复读的原因：</p><ol><li><strong>可重复读下，存在间隙锁</strong>（封锁索引记录中的间隔）导致死锁概率增加：如 <code>SELECT * FROM test WHERE id BETWEEN 5 AND 7</code> ，表中有id（1，5，7，10），所以存在5个间隙，上述sql会锁住(5,7]和(7,10]这两个区间，导致区间无法插入数据。而<strong>读已提交不存在间隙锁</strong>。</li><li><strong>可重复读下，条件未命中索引会锁表</strong>，而<strong>读已提交，只会锁行</strong>。</li><li><strong>读已提交，因为半一致性读的特性会增加update操作的并发性</strong>。一个事务执行完update操作，但尚未提交，另一事务获取锁时发现已占用，InnoDB开启半一致性读返回最新的已提交版本，MySql会重新发起一次读操作，此时可以读到此行的最新版本并加锁，而可重复读这时事务只能等待前一事务提交。</li><li><strong>不可重复读问题可以接受</strong>，已经提交了数据，即使不一样通常也不会造成问题。</li></ol><h3 id="3-4-并发一致性问题"><a href="#3-4-并发一致性问题" class="headerlink" title="3.4 并发一致性问题"></a>3.4 并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，所以有几种并发一致性问题：</p><ol><li><strong>修改丢失</strong>：即一个事务的更新背另一个事务的更新替换。</li><li><strong>读脏数据</strong>：指当前事务读到另外事务未提交的数据。</li><li><strong>不可重复读</strong>：指一个事务多次读取同一数据集合，在此期间另外事务也访问了此集合并做出修改，导致前个事务两次读取数据不一致。</li><li><strong>幻影读</strong>：本质也是不可重复读，指一个事务读取某个范围的数据，另一事务在此范围插入新数据，导致前个事务再次读取结果不一致。<strong>区别在要避免幻读需要锁整张表，而避免不可重复读只需锁住行即可</strong>。</li></ol><p>通过锁机制来解决此问题，MySql提供了对应的封锁机制来实现，<strong>通过三级封锁协议来处理并发一致性问题</strong>。</p><h3 id="3-5-封锁协议"><a href="#3-5-封锁协议" class="headerlink" title="3.5 封锁协议"></a>3.5 封锁协议</h3><ul><li><strong>三级封锁协议</strong>：<ul><li>一级：<strong>事务 T 要修改数据 A 时必须加写锁，直到 T 结束才释放锁</strong>。可以解决修改丢失问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</li><li>二级：<strong>在一级的基础上，要求读取数据 A 时必须加读锁，读取完马上释放读锁</strong>。可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</li><li>三级：<strong>在二级的基础上，要求读取数据 A 时必须加读锁，直到事务结束了才能释放读锁</strong>。可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</li></ul></li><li><strong>两段封锁协议</strong>：<strong>加锁和解锁分为两个阶段进行</strong>。</li></ul><h3 id="3-6-死锁"><a href="#3-6-死锁" class="headerlink" title="3.6 死锁"></a>3.6 死锁</h3><ul><li>死锁指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</li><li>InnoDB有死锁检测和死锁超时机制，处理死锁时会将持有最少行级排他锁的事务进行回滚。</li><li>死锁可能是因为真正的数据冲突，有时可能完全是由于存储引擎的实现方式导致的。</li><li>应用程序需要考虑如何处理死锁，大部分情况只需重新执行因死锁回滚的事务即可。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看数据库隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line"><span class="keyword">select</span> @@global.tx_isolation,@@tx_isolation;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看innodb状态，打印死锁日志，NaviCat复制出去看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--设置隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> XXX;</span><br><span class="line"><span class="comment">--只改变当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">READ</span> COMMITED;</span><br></pre></td></tr></table></figure><h3 id="3-7-事务日志"><a href="#3-7-事务日志" class="headerlink" title="3.7 事务日志"></a>3.7 事务日志</h3><p>事务日志用来提高事务的执行效率，存储引擎在修改表的数据时只需修改内存拷贝，再把修改行为记录在持久的硬盘上的事务日志中，而不是每次都把修改的数据持久到硬盘。</p><p>事务日志通过追加的方式，操作是磁盘小块区域上的顺序I/O，要比随机I/O快得多。所以每次修改数据需要<strong>写两次磁盘</strong>。</p><h3 id="3-8-存储引擎与事务"><a href="#3-8-存储引擎与事务" class="headerlink" title="3.8 存储引擎与事务"></a>3.8 存储引擎与事务</h3><p>MySQL有很多支持事务的存储引擎，如InnoDB、NDB Cluster、XtraDB和PBXT等。</p><h4 id="（1）自动提交（AUTO-COMMIT）"><a href="#（1）自动提交（AUTO-COMMIT）" class="headerlink" title="（1）自动提交（AUTO COMMIT）"></a>（1）自动提交（AUTO COMMIT）</h4><p>MySQL默认采用自动提交模式。每个查询都会被当做一个事务执行提交操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'AUTOCOMMIT'</span></span><br><span class="line"></span><br><span class="line">Variable_name<span class="keyword">Value</span></span><br><span class="line">autocommit    <span class="keyword">ON</span></span><br><span class="line"><span class="comment">--1启用0禁用</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>数据定义语言（DDL）中涉及大量数据改变的操作（如Alter Table、Lock Tables）会强制执行COMMIT提交当前活动事务。</p><h4 id="（2）在事务中混合使用存储引擎"><a href="#（2）在事务中混合使用存储引擎" class="headerlink" title="（2）在事务中混合使用存储引擎"></a>（2）在事务中混合使用存储引擎</h4><p>事务由存储引擎实现，所以在一个事务中使用多种存储引擎不可靠，如果在事务中混合使用了多个包括事务型和非事务型存储引擎的表，正常提交不会有问题，但需要回滚时非事务型的表无法撤销变更。而且仅仅在回滚时提示一个警告，其余情况不会有提示。</p><h4 id="（3）隐式和显式锁定"><a href="#（3）隐式和显式锁定" class="headerlink" title="（3）隐式和显式锁定"></a>（3）隐式和显式锁定</h4><ul><li><p>隐式锁定：InnoDB采用<strong>两阶段锁定协议</strong>，事务执行过程中可以随时锁定，但只有事务提交或回滚时才会释放，并且是同一时刻释放。InnoDB根据隔离级别在需要时自动加锁。</p></li><li><p>显式锁定：通过特点语句进行锁定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><p><code>LOCK TABLES</code> 和 <code>UNLOCK TABLES</code> 由服务器层实现，与存储引擎无关，不能用来代替事务。</p></li></ul><h2 id="四-多版本并发控制-MVCC"><a href="#四-多版本并发控制-MVCC" class="headerlink" title="四. 多版本并发控制-MVCC"></a>四. 多版本并发控制-MVCC</h2><h3 id="4-1-什么是多版本并发控制？"><a href="#4-1-什么是多版本并发控制？" class="headerlink" title="4.1 什么是多版本并发控制？"></a>4.1 什么是多版本并发控制？</h3><p>大部分事务型存储引擎实现的都不是简单的行级锁，一般都同时实现了多版本并发控制-MVCC，<strong>该机制可以在很多情况下避免加锁操作，所以可以降低开销，一般都会实现非阻塞的读操作和只锁定必要行的写操作</strong>。</p><p>MVCC实现机制各不相同：</p><ul><li>乐观并发控制</li><li>悲观并发控制</li></ul><p><strong>MVCC只兼容于 REPEATABLE READ 和 READ COMMITED 这两个隔离级别，而 READ UNCOMMITED 总是读取最新的数据行而不是符合当前事务版本的数据行，SERIALIZABLE 则会对所有读取的行加锁</strong>。</p><h3 id="4-2-如何实现多版本并发控制？"><a href="#4-2-如何实现多版本并发控制？" class="headerlink" title="4.2 如何实现多版本并发控制？"></a>4.2 如何实现多版本并发控制？</h3><p><strong>通过保存数据在某个时间点的快照来实现</strong>。</p><p>InnoDB通过在每行记录后面保存两个隐藏的列，一个保存了行的创建时间，一个保存行的过期时间（实际存储的非时间而是系统版本号）。每开启一个新事务，版本号都会自动递增，事务开始时刻的版本号作为事务的版本号与查询到的每行记录进行比较。</p><p>在REPEATABLE READ隔离级别下：</p><ul><li>SELECT：根据两个条件检查每行记录，符合才作为查询结果返回。<ul><li>只查找版本早于当前事务版本的数据行，确保事务读取的行是事务开始前存在或自己修改过的。</li><li>行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行在事务开始前未被删除。</li></ul></li><li>INSERT：为新插入的每一行保存当前系统版本号作为<strong>行版本号</strong>。</li><li>DELETE：为删除的每一行保存当前系统版本号作为<strong>行删除标识</strong>。</li><li>UPDATE：插入一行新纪录，保存当前系统版本号作为<strong>行版本号</strong>，同时保存当前系统版本号到原来的行作为<strong>行删除标识</strong>。</li></ul><p>通过这两个版本号可以使大部分读操作都不需加锁（乐观），以少量的额外存储空间和检查维护工作换取好的性能。</p><h2 id="五-存储引擎"><a href="#五-存储引擎" class="headerlink" title="五. 存储引擎"></a>五. 存储引擎</h2><p>文件系统中，MySQL将每个数据库保存为数据目录下的一个子目录。创建表时在数据库子目录下创建一个和表同名的 <code>.frm</code> 文件保存表的定义。表的定义统一在服务层处理，数据和索引则在不同的存储引擎中保存方式不同。</p><p>正因为使用了文件系统的目录文件，所以MySQL大小写敏感和平台相关，Windows中不敏感，而类Unix中则敏感。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看表信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'表名'</span></span><br></pre></td></tr></table></figure><p>返回字段：</p><table><thead><tr><th>字段</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>Name</td><td>表名</td><td>version</td></tr><tr><td>Engine</td><td>存储引擎类型</td><td>InnoDB</td></tr><tr><td>Version</td><td></td><td>10</td></tr><tr><td>Row_format</td><td>行格式：<br>-Dynamic的行长度可变，一般会有如VARCHAR或BLOB这种可变长字段<br>-Fixed的行长度固定，只包含如CHAR何INTEGER这种固定长度字段<br>-Compressed只在压缩表存在<br>….</td><td>Compact</td></tr><tr><td>Rows</td><td>表的行数，对于InnoDB是估计值，MyISAM则是精确值</td><td>25</td></tr><tr><td>Avg_row_length</td><td>平均每行包含的字节数</td><td>655</td></tr><tr><td>Data_length</td><td>表数据的大小，单位字节</td><td>16384</td></tr><tr><td>Max_data_length</td><td>表数据的最大容量</td><td>0</td></tr><tr><td>Index_length</td><td>索引大小</td><td>16384</td></tr><tr><td>Data_free</td><td>表示已分配但目前没有使用的空间。包括已删除的行以及后续可以被Insert利用的空间</td><td>0</td></tr><tr><td>Auto_increment</td><td>下一个自增的值</td><td></td></tr><tr><td>Create_time</td><td>表的创建时间</td><td>2020-12-02 13:04:02</td></tr><tr><td>Update_time</td><td>表数据的最后修改时间</td><td></td></tr><tr><td>Check_time</td><td>使用CHECK TABLE命令或myisamchk等工具最后一次检查表的时间</td><td></td></tr><tr><td>Collation</td><td>表的默认字符集和字符列排序规则</td><td>gbk_chinese_ci</td></tr><tr><td>Checksum</td><td>启用时保存整个表的实时校验和</td><td></td></tr><tr><td>Create_options</td><td>创建表时指定的其他选项</td><td></td></tr><tr><td>Comment</td><td>额外信息，InnoDB表空间的剩余空间信息，视图VIEW文本等</td></tr></tbody></table><h3 id="5-1-InnoDB"><a href="#5-1-InnoDB" class="headerlink" title="5.1 InnoDB"></a>5.1 InnoDB</h3><p>MySQL默认的事务型存储引擎，设计用来执行大量<strong>短期事务</strong>，短期事务很少回滚。</p><p>MySQL 5.1后，新的InnoDB plugin提供很多新特性，如利用排序创建索引、删除或增加索引时不需要复制全表数据、新的支持压缩的存储格式、新的大型列值如BLOB的存储方式、以及文件格式管理等。</p><p>InnoDB：</p><ul><li>数据存储在<strong>表空间</strong>（tablespace）中，由一系列数据文件组成，InnoDB可以将每个表的数据和索引存放在单独的文件中。</li><li>采用MVCC来支持高并发，实现了四个标准的隔离级别，默认是<strong>可重复读</strong>（REPEATABLE READ），<strong>通过间隙锁策略防止幻读出现</strong>，间隙锁使InnoDB不仅锁行，还未锁定索引中的间隙以防止幻影行的插入。</li><li>表基于<strong>聚簇索引</strong>建立，主键查询有很好的性能，但其二级索引（非主键索引）必须包含主键列，若主键列很大会导致所有索引都很大（主键应尽量小一些）。</li><li>内部优化：从磁盘读取数据时采用了<strong>可预测性预读</strong>、自动在内存中创建hash索引以加速读操作的<strong>自适应哈希索引</strong>、能够加速插入操作的<strong>插入缓冲区</strong>等。</li><li>InnoDB支持热备份，如 MySQL Enterprise Backup、XtraBackup都可以实现。</li></ul><h3 id="5-2-MyISAM"><a href="#5-2-MyISAM" class="headerlink" title="5.2 MyISAM"></a>5.2 MyISAM</h3><p>支持如全文索引、压缩、空间函数等，但不支持事务和行级锁，崩溃后无法安全恢复。对于只读数据或小表且可以接受修复操作的场景仍可以继续使用该引擎。</p><p>MyISAM：</p><ul><li><strong>存储</strong>：表存储在两个文件中：数据文件和索引文件，分别以 <code>.MYD</code> 和 <code>.MYI</code> 为扩展名。</li><li><strong>加锁与并发</strong>：对整张表加锁，不能针对行；读取时对所有需要的表加共享锁，写入时则加排它锁，但允许表读取时向表中插入新纪录（<strong>允许并发插入</strong>）。</li><li><strong>修复</strong>：可以手工或自动执行检查和修复操作，修复操作可能会导致数据丢失而且执行速度很慢。<ul><li><code>CHECK TABLE mytable</code> 检查表错误。</li><li><code>REPAIR TABLE mytable</code> 修复错误。</li><li><code>myisamchk</code> 命令行工具。</li></ul></li><li><strong>索引</strong>：即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引。支持全文索引，基于分词创建的索引，可以支持复杂查询。</li><li><strong>延迟更新索引键</strong>：创建表时，若指定了 <code>DELAY_KEY_WRITE</code> 选项，在每次修改执行成功后不会马上把修改的索引数据写入磁盘，而是写入内存的键缓冲区，只有清理键缓冲区或关闭表时才写入磁盘；这种方式可以极大的提升写入性能，但在崩溃时会造成索引损坏，需要进行修复。</li><li><strong>压缩表</strong>：使用 <code>myisampack</code> 将表压缩（打包pack），压缩状态不允许修改，可以极大的减少磁盘空间占用，压缩表支持索引，但索引也是只读的。</li><li><strong>性能</strong>：数据以紧密格式存储，在某些场景下性能很好。主要问题是表锁，容易导致查询处于 Locked 状态。</li></ul><h3 id="5-3-MySQL内建其他存储引擎"><a href="#5-3-MySQL内建其他存储引擎" class="headerlink" title="5.3 MySQL内建其他存储引擎"></a>5.3 MySQL内建其他存储引擎</h3><ul><li><p><strong>Archive引擎</strong>：</p><ul><li>只支持INSERT和SELECT操作。</li><li><strong>高速插入和压缩</strong>：插入缓存所有的写，利用zli对插入的行进行压缩，比MyISAM更少的磁盘I/O。</li><li>每次查询都要执行全表扫描，适合日志和数据采集类应用。</li><li>支持行级锁和专用缓冲区，可以实现高并发的插入。</li><li>查询在返回前会阻止其他查询执行以保证一致性读。</li></ul></li><li><p><strong>Blackhole引擎</strong>：不保存任何数据，服务器会记录Blackhole表的日志，可以用于复制数据到备库或记录日志。</p></li><li><p><strong>CSV引擎</strong>：将CSV文件当做MySQL表来处理，不支持索引。可以作为一种数据交换的机制。</p></li><li><p><strong>Federated引擎</strong>：访问其他MySQL服务器的一个代理，创建一个客户端连接，并将查询传输到远程服务器执行，然后提取或发送需要的数据。市场化设计，经常有问题，默认禁用。</p></li><li><p><strong>Memory引擎</strong>：所有数据都存在内存，不需要磁盘I/O，表结构重启后仍能保留，但数据会丢失，比MyISAM要快一个数量级。</p><ul><li>支持Hash索引，只支持表级锁，不支持BLOB或TEXT类型，且行长度固定，即使指定VARCHAR实际存储时也会转换成CHAR。</li><li>MySQL执行查询时如果需要临时表来保存中间结果，内部就是使用Memory表，如果结果太大超过内存表限制或含有BLOB和TEXT字段，会转换为MyISAM表。</li></ul><p>适用场景：</p><ul><li>查找或映射表。</li><li>缓存周期性聚合数据的结果。</li><li>保存数据分析中产生的中间数据。</li></ul></li><li><p><strong>Merge引擎</strong>：由多个MyISAM表合并成的虚拟表，引入分区功能后已被废弃。</p></li><li><p><strong>NDB引擎</strong>：MySQL服务器、NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合被称为MySQL集群。</p></li></ul><h3 id="5-4-第三方存储引擎"><a href="#5-4-第三方存储引擎" class="headerlink" title="5.4 第三方存储引擎"></a>5.4 第三方存储引擎</h3><ul><li><strong>OLTP类引擎</strong>：<ul><li>Percona的XtraDB存储引擎基于InnoDB改进，可以作为InnoDB引擎的替代品</li><li>PBXT，支持ACID事务和MVCC等。</li><li>TokuDB，使用一种叫分形树的索引数据结构，是一种大数据存储引擎，拥有很高的压缩比。</li><li>RethinkDB，采用只能追加的写时复制B树作为索引的数据结构。</li></ul></li><li><strong>面向列的引擎</strong>：MySQL默认面向行，每行数据一起存储，查询也以行为单位处理。大数据量时面向列的方式可以传输更少的数据，压缩效率也更好。</li><li><strong>社区引擎</strong>：如Aria、Groonga、OQGraph、Q4M、SphinxSE、Spider、VPForMySQL等。</li></ul><h3 id="5-5-如何选择合适的存储引擎"><a href="#5-5-如何选择合适的存储引擎" class="headerlink" title="5.5 如何选择合适的存储引擎"></a>5.5 如何选择合适的存储引擎</h3><p>大部分情况选择InnoDB，除非需要用到InnoDB不具备的特性，并且没有替代方案，否则请尽量选择InnoDB引擎。</p><p>尽量不要混合使用多种存储引擎，会带来一系列复杂和预想不到的问题。</p><h3 id="5-6-转换表的存储引擎"><a href="#5-6-转换表的存储引擎" class="headerlink" title="5.6 转换表的存储引擎"></a>5.6 转换表的存储引擎</h3><ul><li><p><code>ALTER TABLE</code> ：<code>ALTER TABLE mytable ENGINE = InnoDB;</code> 需要执行较长时间，MySQL会按行将数据从原表复制到一张新表，复制期间可能会消耗系统所有I/O能力，同时对原表加上读锁。注意，即使后续再恢复原引擎，也会丢失如外键等和引擎相关的特性。</p></li><li><p><strong>导出与导入</strong>：使用 <code>mysqldump</code> 工具将数据导出到文件，修改文件中 CREATE TABLE 语句的存储引擎选项，注意修改表名（避免重复），工具默认会在 CREATE TABLE 语句前加上 DROP TABLE 可能会导致数据丢失。</p></li><li><p><strong>创建与查询</strong>：综合前两种方法，先创建一个新的存储引擎的表，然后利用 <code>INSERT...SELECT</code> 语句来导入数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">LIKE</span> myisam_table;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> innodb_table <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table;</span><br></pre></td></tr></table></figure><p>数据量大时可以考虑分批处理，针对每一段数据执行事务提交操作，避免大事务产生过多的undo。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> innodb_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myisam_table</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> x <span class="keyword">AND</span> y;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>如果有必要，可以在执行时对原表加锁，以确保新表和原表数据一致。</p><p>Percona Toolkit提供了 pt-online-schema-change 工具方便简单安全的执行上述过程。</p></li></ul><h2 id="六-时间线-Timeline"><a href="#六-时间线-Timeline" class="headerlink" title="六. 时间线-Timeline"></a>六. 时间线-Timeline</h2><ul><li>版本  3.23 2001</li><li>版本  4.0   2003</li><li>版本  4.1   2005</li><li>版本  5.0   2006</li><li>版本  5.1   2008</li><li>版本  5.5   2010 ：Oracle收购，InnoDB成为默认存储引擎。</li><li>版本  5.6   </li><li>….</li></ul><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    <summary type="html">
    
      《高性能MySQL》读书笔记，内容：MySQL逻辑架构，并发控制，事务，多版本并发控制，存储引擎，时间线等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构设计模式（三）进程间通信</title>
    <link href="http://linyishui.top/2020112801.html"/>
    <id>http://linyishui.top/2020112801.html</id>
    <published>2020-11-28T15:28:34.000Z</published>
    <updated>2020-12-17T14:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-微服务架构中要频繁使用进程间通信"><a href="#1-1-微服务架构中要频繁使用进程间通信" class="headerlink" title="1.1 微服务架构中要频繁使用进程间通信"></a>1.1 微服务架构中要频繁使用进程间通信</h3><p>FIGO有一个REST API供移动端和Web端使用，还使用了一些云服务如Twilio消息服务和Stripe支付服务，但在单体应用内是语言级方法或函数相互调用，除了开发API和集成云服务不会考虑<strong>进程间通信</strong>（IPC）。</p><p>微服务架构中各个服务实例通常是在多台机器上运行的进程，所以必须使用进程间通信进行交互。选择合适的进程间通信机制是一个重要的架构决策，除了影响应用的可用性，甚至还与事务管理互相影响。<strong>理想的微服务架构应该在内部由松散耦合的若干服务组成，服务间使用异步消息相互通信</strong>。</p><h3 id="1-2-常见进程间通信技术"><a href="#1-2-常见进程间通信技术" class="headerlink" title="1.2 常见进程间通信技术"></a>1.2 常见进程间通信技术</h3><p>进程间通信技术有很多：</p><ul><li>基于同步请求 / 响应的通信机制：如 HTTP REST 或 gRPC，REST（JSON）主要用于服务与外部其他应用程序的通信。</li><li>异步的基于消息的通信机制：如 AMQP 或 STOMP。</li></ul><p>消息格式也有：</p><ul><li>基于文本的 JSON 或 XML，有可读性。</li><li>基于二进制的 Avro 或 Protocol Buffers 格式，更加高效。</li></ul><h3 id="1-3-交互方式"><a href="#1-3-交互方式" class="headerlink" title="1.3 交互方式"></a>1.3 交互方式</h3><p>选择进程间通信机制要先考虑服务与其客户端的交互方式，从而可以专注于需求而不是单纯技术层面的考量，交互方式的选择会影响可用性和后续的集成测试策略。</p><p>交互方式关注两个维度：</p><ul><li>映射关系：<ul><li><strong>一对一</strong>：每个客户端由一个服务实例来处理。</li><li><strong>一对多</strong>：每个客户端由多个服务实例来处理。</li></ul></li><li>同步异步：<ul><li><strong>同步模式</strong>：客户端请求需要服务端实时响应，客户端等待响应时可能导致阻塞。</li><li><strong>异步模式</strong>：客户端请求不会阻塞进程，服务端响应可以非实时。</li></ul></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">一对一</th><th style="text-align:center">一对多</th></tr></thead><tbody><tr><td style="text-align:center">同步模式</td><td style="text-align:center">请求/响应</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">异步模式</td><td style="text-align:center">异步请求/响应<br>单向通知</td><td style="text-align:center">发布/订阅<br>发布/异步响应</td></tr></tbody></table><ul><li>一对一的交互方式：<ul><li><strong>请求/响应</strong>：一个客户端向服务端发起请求，等待响应；客户端期望服务端很快发送响应。在一个基于线程的应用中，等待过程可能造成线程阻塞，这种方式会导致服务紧耦合。</li><li><strong>异步请求/响应</strong>：客户端发送请求到服务端，服务端异步响应请求。客户端等待时不会阻塞线程，而服务端响应也不一定会马上返回。</li><li><strong>单向通知</strong>：客户端请求发送到服务端，但不期望服务端做出任何响应。</li></ul></li><li>一对多的交互方式：<ul><li><strong>发布/订阅</strong>：客户端发布通知消息，被零个或多个感兴趣的服务订阅。</li><li><strong>发布/异步响应</strong>：客户端发布请求消息，然后等待从感兴趣的服务发回的响应。</li></ul></li></ul><p>注意：底层的进程间通信技术并不会影响所选择的交互方式，可以是REST或消息机制，但选择同步请求/响应方式都会使客户端等待响应。</p><h3 id="1-4-定义API"><a href="#1-4-定义API" class="headerlink" title="1.4 定义API"></a>1.4 定义API</h3><p>设计良好的接口在暴漏有用功能的同时隐藏实现细节，实现可以被修改，但接口尽量保持不变以不对客户端产生影响。</p><p>Java是静态类型编程语言，如果接口与客户端不兼容，应用程序会无法通过编译。微服务架构的挑战是：没有一个简单的编程语言结构可以用来构造和定义服务的API。若使用不兼容的API部署新版本的服务，编译阶段不会出错，但会导致运行时故障。</p><p>使用<strong>接口定义语言</strong>（IDL）精确定义服务的API很重要，API优先设计，迭代几轮API定义后再开始具体的服务实现编程。</p><ul><li>使用消息机制，API由消息通道、消息类型和消息格式组成。</li><li>使用HTTP，API由URL、HTTP动词以及请求和响应格式组成。</li></ul><h3 id="1-5-API演化"><a href="#1-5-API演化" class="headerlink" title="1.5 API演化"></a>1.5 API演化</h3><p>微服务中API的使用者很有可能是另外的开发团队或组织外的人，不能够要求客户端跟服务端API版本保持一致，现代应用程序有着极高的可用性要求，一般会采用滚动升级的方式来更新服务，所以一个服务的新版本和旧版本肯定会共存。</p><ul><li><p><strong>语义化版本控制</strong>：是一组规则，用于指定如何使用版本号，并且以正确的方式递增版本号。</p><p>版本号由三部分组成：</p><ul><li>MAJOR：对API进行不兼容的更改时。</li><li>MINOR：对API进行向后兼容的增强时。</li><li>PATCH：进行向后兼容的错误修复时。</li></ul><p>如使用REST API时，可以使用主要版本作为URL路径的第一个元素；使用消息机制的服务，可以在发布的消息中包含版本号。</p></li><li><p><strong>进行次要并且向后兼容的改变</strong>：向后兼容是对API的附加更改或功能增强。</p><ul><li>客户端和服务端应该遵守健壮性原则，服务为缺少的请求属性提供默认值，客户端忽略额外的响应属性。</li></ul></li><li><p><strong>进行主要并且不向后兼容的改变</strong>：因为无法强制客户端升级，所以需要在一段时间内同时支持新旧版本的API。</p><ul><li>使用基于HTTP的进程间通信机制，如REST，可以在URL中嵌入主要版本号，版本1对应 <code>/v1/...</code> 和 版本2对应 <code>/v2/...</code> 为前缀。</li></ul></li></ul><h3 id="1-6-消息格式"><a href="#1-6-消息格式" class="headerlink" title="1.6 消息格式"></a>1.6 消息格式</h3><ul><li>基于文本：消息过度冗长，解析文本引入了额外开销。<ul><li>XML：相比JSON更长。</li><li>JSON</li></ul></li><li>基于二进制：提供了一个强类型定义的IDL（接口描述文件），用于定义消息的格式。编译器自动根据格式生成序列化和反序列化代码。<ul><li>Protocol Buffers：使用tagged fields，带标记的字段。</li><li>Avro：其消费者在解析消息前要知道格式。</li></ul></li></ul><h2 id="二-基于同步远程过程调用模式的通信"><a href="#二-基于同步远程过程调用模式的通信" class="headerlink" title="二. 基于同步远程过程调用模式的通信"></a>二. 基于同步远程过程调用模式的通信</h2><p>基于同步远程过程调用（RPI）的通信机制中，客户端假定消息将及时到达。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010131.jpg" alt></p><p>代理接口通常封装底层通信协议，可以选如REST何gRPC等。</p><h3 id="2-1-REST"><a href="#2-1-REST" class="headerlink" title="2.1 REST"></a>2.1 REST</h3><h4 id="2-1-1-RESTful风格"><a href="#2-1-1-RESTful风格" class="headerlink" title="2.1.1 RESTful风格"></a>2.1.1 RESTful风格</h4><p>REST是一种总是使用HTTP协议的进程间通信机制，提供了一系列架构约束，强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，其强化了安全性也能封装遗留系统。</p><p>REST使用<strong>资源</strong>表示单个业务对象，使用<strong>HTTP动词</strong>来操作资源，使用<strong>URL</strong>引用资源。</p><ul><li>GET获取资源</li><li>POST创建资源</li><li>PUT更新资源</li><li>DELETE删除资源</li></ul><h4 id="2-1-2-成熟度模型"><a href="#2-1-2-成熟度模型" class="headerlink" title="2.1.2 成熟度模型"></a>2.1.2 成熟度模型</h4><ul><li>Level 0：客户端只是向服务端点发起HTTP POST请求，进行服务调用。每个请求指明了需要执行的操作、针对的目标和必要的参数。</li><li>Level 1：该层级引入资源的概念，客户端需要发出指定要执行的操作和包含任何参数的POST请求。</li><li>Level 2：使用HTTP动词来执行操作，请求查询参数和主体指定操作的参数，这能够让服务借助Web基础设施服务，如通过CDN缓存GET请求。</li><li>Level 3：基于HATEOAS（Hypertext As The Engine Of Application State）原则设计，基本思想是由GET请求返回的资源信息中包含链接，链接能够执行该资源允许的操作。如客户端通过订单资源包含的链接取消某一订单或获取该订单详情。优点包括无需在客户端代码中写入硬链接的URL，因为资源包括允许操作的链接，客户端无需猜测在当前状态应执行何操作。</li></ul><h4 id="2-1-3-需要解决的问题"><a href="#2-1-3-需要解决的问题" class="headerlink" title="2.1.3 需要解决的问题"></a>2.1.3 需要解决的问题</h4><ul><li>在一个请求中获取多个资源：<ul><li>API允许获取资源时检索相关资源，如 <code>GET/orders/order-id-1345?expand=consumer</code> 检索order和consumer。但对于复杂的场景不太适用。</li><li>GraphQL 和 Netflix Falcor 实现了高效的数据获取。</li></ul></li><li>把操作映射为HTTP动词：有可能有多种更新操作，如取消或修改订单。<ul><li>使用子资源，如 <code>POST/orders/{orderId}/cancel</code> 和 <code>POST/orders/{orderId}/revise</code>  端点。</li><li>将动词指定为URL的查询参数。</li><li>此两种解决方案都有些违背了RESTful的要求。</li></ul></li></ul><h4 id="2-1-4-优缺点"><a href="#2-1-4-优缺点" class="headerlink" title="2.1.4 优缺点"></a>2.1.4 优缺点</h4><p>优点：</p><ul><li>简单直观</li><li>可以使用浏览器扩展（如Postman插件）或 curl 之类的命令行来测试HTTP API</li><li>直接支持请求 / 响应方式的通信</li><li>HTTP对防火墙友好</li><li>不需要中间代理，简化了系统架构</li></ul><p>缺点：</p><ul><li>只支持请求 / 响应方式的通信</li><li>可能导致可用性降低。由于客户端和服务直接通信，而未通过代理缓冲消息，二者在调用期间都要保持在线。</li><li>客户端必须知道服务实例的位置-URL，但现代应用要求客户端必须使用<strong>服务发现机制</strong>来定位服务实例。</li><li>在单个请求中获取多个资源具有挑战性。</li><li>很难将多个更新操作映射为HTTP动词。</li></ul><h3 id="2-2-gRPC"><a href="#2-2-gRPC" class="headerlink" title="2.2 gRPC"></a>2.2 gRPC</h3><p>gRPC是一个用于编写跨语言客户端和服务端的框架，是一种基于二进制消息的协议，所以必须采用API优先的服务设计方法。</p><p>可以使用Protocol Buffer的IDL定义gRPC的API，是谷歌公司用于序列化结构化数据的一套语言中立机制，使用Protocol Buffer编译器生成客户端的<strong>桩</strong>（sub，也叫存根）和服务器<strong>骨架</strong>（skeleton），支持如Java、C#、Node.js 和 Golang等。<strong>客户端和服务端使用 HTTP/2 以Protocol Buffer格式交换二进制消息</strong>。</p><p>gRPC API 由一个或多个服务和请求/响应消息定义组成。服务定义类似于Java接口，是强类型方法的集合，支持请求/响应RPC和流式RPC。服务器可以使用消息流回复客户端，客户端也可以向服务器发送消息流。</p><p>Protocol Buffers是一种高效的二进制消息格式，消息的每个字段都有编号和一个类型代码；消息接收方可以提取所需字段，跳过无法识别的字段。因此特性gRPC API可以保持向后兼容的同时进行变更。</p><p>如OrderService的gRPC API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateOrderRequest和CreateOrderReply是具有类型的消息</span></span><br><span class="line">service OrderService &#123;</span><br><span class="line">    <span class="function">rpc <span class="title">createOrder</span><span class="params">(CreateOrderRequest)</span> <span class="title">returns</span> <span class="params">(CreateOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">rpc <span class="title">cancelOrder</span><span class="params">(CancelOrderRequest)</span> <span class="title">returns</span> <span class="params">(CancelOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">rpc <span class="title">reviseOrder</span><span class="params">(ReviseOrderRequest)</span> <span class="title">returns</span> <span class="params">(ReviseOrderReply)</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateOrderRequest &#123;</span><br><span class="line">    int64 restaurantId = <span class="number">1</span>;</span><br><span class="line">    int64 consumerId = <span class="number">2</span>;</span><br><span class="line">    repeated LineItem lineItems = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message LineItem &#123;</span><br><span class="line">    string menuItemId = <span class="number">1</span>;</span><br><span class="line">    int32 quantity = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateOrderReply &#123;</span><br><span class="line">    int64 orderId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>设计具有复杂更新操作的API很简单</li><li>具有高效、紧凑的进程间通信机制，特别是交换大量消息时</li><li>支持在远程过程调用和消息传递过程中使用双向流式消息方式</li><li>实现了客户端和各种语言编写的服务端之间的互操作性</li></ul><p>缺点：</p><ul><li>与基于REST/JSON的API机制相比，JavaScript客户端使用基于gRPC的API需要做更多工作</li><li>旧式防火墙可能不支持HTTP/2</li></ul><h3 id="2-3-使用断路器模式处理局部故障"><a href="#2-3-使用断路器模式处理局部故障" class="headerlink" title="2.3 使用断路器模式处理局部故障"></a>2.3 使用断路器模式处理局部故障</h3><p>服务间通信总是无法避免会遇到局部故障，可以通过断路器模式来应对故障。</p><p>断路器模式：<strong>远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内，这个代理会立即拒绝其他调用</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010132.jpg" alt></p><p>OrderServiceProxy会无限期阻塞，等待响应，在带来糟糕体验的同时，消耗如线程等宝贵资源，最终API Gateway 将耗尽资源无法处理请求，整个API都不可用。</p><p>解决此问题：</p><ul><li><p><strong>开发可靠的远程过程调用代理</strong>：如 Netflix Hystrix 等开源库。</p><p>当服务同步调用一个服务时，需要保证：</p><ul><li><strong>网络超时</strong>：等待请求的响应时，不要无限阻塞，设定一个超时，保证不会一直在无响应的请求上浪费资源。</li><li><strong>限制客户端向服务器发出请求的数量</strong>：对特定请求服务设置上限，达到上限后新的请求会立即失败。</li><li><strong>断路器模式</strong>：监控客户端发出请求的成功和失败数目，失败比例超过阈值，启动断路器，让后续调用立即失效。大量的请求失败表示被调服务不可用，即使再发送请求也无济于事，而是经过一段时间后再尝试，若请求成功则解除断路器。</li></ul></li><li><p><strong>从服务失效故障中恢复</strong>：</p><p>根据具体情况选择如何从无响应的远程服务中恢复服务：</p><ul><li>返回错误：如图 3-3 创建Order失败时，只能将失败返回给移动端。</li><li>返回备用值：如图 3-3 使用API组合模式实现，调用了多个服务并将结果组合在一起。结果的重要性不同，如Order服务不可用时要返回其数据的缓存版本或错误信息；其他则不重要，可以返回缓存版本或忽略。</li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010133.jpg" alt></p><h3 id="2-4-服务发现"><a href="#2-4-服务发现" class="headerlink" title="2.4 服务发现"></a>2.4 服务发现</h3><h4 id="2-4-1-为什么需要服务发现？"><a href="#2-4-1-为什么需要服务发现？" class="headerlink" title="2.4.1 为什么需要服务发现？"></a>2.4.1 为什么需要服务发现？</h4><p>发送请求需要知道服务实例的网络位置，现代基于云的微服务应用程序中，服务实例具有动态分配的IP地址，还会因为自动扩展、故障和升级等导致服务实例集动态修改。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010134.jpg" alt></p><h4 id="2-4-2-服务发现机制会做什么？"><a href="#2-4-2-服务发现机制会做什么？" class="headerlink" title="2.4.2 服务发现机制会做什么？"></a>2.4.2 服务发现机制会做什么？</h4><p>服务发现的关键组件是服务注册表，是包含服务实例网络位置信息的数据库。服务实例启动和停止时，服务发现机制都会更新服务注册表，客户端调用服务时，服务发现机制会查询服务注册表获取服务实例的列表，并将请求路由到其中一个服务实例。</p><h4 id="2-4-3-实现方式"><a href="#2-4-3-实现方式" class="headerlink" title="2.4.3 实现方式"></a>2.4.3 实现方式</h4><ul><li>服务及其客户直接与服务注册表交互；</li><li>通过部署基础设施来处理服务发现。</li></ul><h4 id="2-4-4-应用层服务发现模式"><a href="#2-4-4-应用层服务发现模式" class="headerlink" title="2.4.4 应用层服务发现模式"></a>2.4.4 应用层服务发现模式</h4><p>服务实例使用服务注册表来注册网络位置，客户端先查询表获取信息再向其中一个实例发送请求。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010135.jpg" alt></p><ul><li><strong>自注册模式</strong>：服务实例向服务注册表注册自己，服务注册表定期调用<strong>运行状况检查</strong>端点来验证服务实例是否正常且能接收请求，服务实例要定期调用心跳API以防止注册过期。</li><li><strong>客户端发现模式</strong>：客户端从服务注册表检索可用服务实例的列表，客户端可以缓存服务实例，并且使用负载均衡算法来选择服务实例。</li></ul><p>应用层服务发现工具：Spring Cloud默认使用Eureka进行服务发现。</p><ul><li>Eureka：高可用的注册中心</li><li>Ribbon：Eureka的 HTTP 客户端</li></ul><p>优点：</p><ul><li>服务发现与部署平台无关，可以解决多平台部署问题。如同时使用Kubernetes和遗留环境，基于Eureka能同时适用二者，而基于平台的服务发现只能用于Kubernetes平台。</li></ul><p>弊端：</p><ul><li>需要为每种编程语言提供服务发现库，Spring Cloud 只能服务于 Spring 开发，如 Node.js 或 Golang 需要相应的服务发现框架。</li><li>开发者负责设置和管理服务注册表，最好使用部署基础设施提供的服务发现机制。</li></ul><h4 id="2-4-5-平台层服务发现模式"><a href="#2-4-5-平台层服务发现模式" class="headerlink" title="2.4.5 平台层服务发现模式"></a>2.4.5 平台层服务发现模式</h4><p>现代部署平台，如Docker和Kubernetes都有内置的服务注册表和服务发现机制。平台为每个服务提供DNS名称、虚拟IP地址（VIP地址）和解析为VIP地址的DNS名称。客户端向DNS名称和VIP发出请求，部署平台自动将请求路由到其中一个可用实例，整个流程完全由平台处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010136.jpg" alt></p><ul><li><strong>第三方注册模式</strong>：由注册服务器（第三方）负责处理注册，服务不用再自己注册。</li><li><strong>服务端发现模式</strong>：客户端不需要查询注册表，而是向DNS名称发出请求，对此名称的请求会解析到路由器，路由器查询服务注册表并对请求进行负载均衡。</li></ul><p>优点：</p><ul><li>服务和客户端不需包含服务发现代码，不论任何语言和框架都可以使用。</li></ul><p>弊端：</p><ul><li>仅限于使用此平台部署的服务，但尽管如此还是推荐平台提供的服务发现。</li></ul><h2 id="三-基于异步消息模式的通信"><a href="#三-基于异步消息模式的通信" class="headerlink" title="三. 基于异步消息模式的通信"></a>三. 基于异步消息模式的通信</h2><p>使用消息机制时，服务之间的通信采用异步交换消息的方式完成。</p><p>实现方案：</p><ul><li>通常会使用<strong>消息代理</strong>，它充当服务之间的中介。</li><li><strong>无代理架构</strong>，直接向服务发送消息，因为通信是异步的，所有客户端不会堵塞和等待回复。</li></ul><h3 id="3-1-消息传递"><a href="#3-1-消息传递" class="headerlink" title="3.1 消息传递"></a>3.1 消息传递</h3><p>消息通过消息通道进行交换，发送方将消息写入通道，接受方从通道读取消息：</p><ul><li><p><strong>消息</strong>：</p><ul><li>组成结构：消息头部 + 消息主体。</li><li>内容：<ul><li>标题：名称与值对的集合，描述正在发送的数据的元数据。</li><li>消息ID：唯一标识。</li><li>返回地址：指定发送回复的消息通道。</li><li>正文：文本或二进制格式的数据。</li></ul></li><li>消息类型：<ul><li>文档：仅包含数据的通用消息。</li><li>命令：一条等同于RPC请求的消息，指定要调用的操作及参数。</li><li>事件：标识发送方发生了重要事件，通常是领域事件，表示领域对象状态更改。</li></ul></li></ul></li><li><p><strong>消息通道</strong>：消息传递基础设施的抽象。</p><ul><li>消息通道类型：<ul><li><strong>点对点通道</strong>：向正在从通道读取的一个消费者传递消息，实现一对一交互方式，常用于命令式消息。</li><li><strong>发布-订阅通道</strong>：将一条消息发给所有订阅的接收方，实现一对多交互方式，常用于事件式消息。</li></ul></li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010137.jpg" alt></p><h3 id="3-2-使用消息机制实现交互方式"><a href="#3-2-使用消息机制实现交互方式" class="headerlink" title="3.2 使用消息机制实现交互方式"></a>3.2 使用消息机制实现交互方式</h3><p>消息机制本质是异步的，只提供异步请求/响应，客户端和服务端通过交换一对消息来实现异步请求/响应方式的交互。</p><p>如下图，客户端发送命令式消息，内容通过服务拥有的点对点消息通道传递，服务处理请求后将包含结果的回复消息发送到客户端拥有的点对点通道。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010138.jpg" alt></p><p>客户端必须告诉服务发送回复消息的位置，并且要对回复和请求进行匹配。msgId叫相关性ID，用来匹配二者。</p><p>消息机制可以实现的交互方式：</p><ul><li><strong>实现请求/响应和异步请求/响应</strong>，前者期望立即响应。</li><li><strong>实现单向通知</strong>：客户端将消息发送到服务所拥有的点对点通道，服务订阅并处理消息，但并不回复。</li><li><strong>实现发布/订阅</strong>：客户端将消息发布到由多个接收方读取的发布/订阅通道，微服务中可以用发布/订阅来发布领域事件，如OrderService将Order事件发布到Order通道，对特定领域事件感兴趣的服务只要订阅即可。</li><li><strong>实现发布/异步响应</strong>：是发布/订阅和请求/响应两种方式的元素组合在一起，客户端发布一条消息，在消息的头部中指定<strong>回复通道</strong>（同时也是一个发布-订阅通道）。消费者将包含<strong>相关性ID</strong>的回复消息写入回复通道，客户端通过相关性ID来收集响应，以此将回复消息与请求匹配。</li></ul><h3 id="3-3-为基于消息机制的服务API创建API规范"><a href="#3-3-为基于消息机制的服务API创建API规范" class="headerlink" title="3.3 为基于消息机制的服务API创建API规范"></a>3.3 为基于消息机制的服务API创建API规范</h3><p>服务的异步API包含供客户端调用的操作和由服务对外发布的事件：</p><ul><li>记录异步操作：<ul><li>请求/异步响应式API：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式，以及服务发送的回复消息的类型和格式。</li><li>单向通知式API：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式。</li></ul></li><li>记录事件发布：服务还可以使用发布/定义的方式对外发布事件，API风格的规范包括事件通道以及服务发布到通道的事件式消息的类型和格式。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010139.jpg" alt></p><h3 id="3-4-使用消息代理"><a href="#3-4-使用消息代理" class="headerlink" title="3.4 使用消息代理"></a>3.4 使用消息代理</h3><p>消息代理，即服务通信的基础设施服务。除了消息代理架构，还有基于无代理的消息传递架构，其中服务相互通信。二者各有利弊，通常会选择消息代理架构。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010140.jpg" alt></p><ul><li><p>无代理消息：服务直接交换消息</p><ul><li>ZeroMQ是一种流行的无代理消息技术，支持各种传输协议（如TCP、UNIX）风格的套接字和多播。</li><li>优点：<ul><li>允许更轻的网络流量和更低的延迟，因为消息直接从发送方到接收方，少了一层代理；</li><li>消除了消息代理可能成为性能瓶颈或单点故障的可能性；</li><li>具有较低的操作复杂性，因为不需要设置和维护消息代理。</li></ul></li><li>缺点：<ul><li>服务需要知道彼此的位置，必须使用服务发现机制。</li><li>会导致可用性降低，因为在交换消息时，消息的发送方和接收方必须同时在线。</li><li>在实现例如确保消息能够成功投递这些复杂功能时的挑战性更大。</li></ul></li><li>这些弊端和同步请求响应的交互方式相同，所以大多数企业应用选择基于消息代理的架构。</li></ul></li><li><p>基于代理的消息：消息代理作为所有消息的中介节点。</p><ul><li><p>开源消息代理技术：</p><ul><li>Apache ActiveMQ</li><li>RabbitMQ</li><li>Apache Kafka</li><li>AWS Kinesis 和 AWS SQS ：基于云的消息服务。</li></ul></li><li><p>优点：</p><ul><li>发送方不需知道接收方的网络位置。</li><li>消息代理可以缓冲消息，直到接收方能够处理它们。</li></ul></li><li>需要考虑：<ul><li>支持的编程语言</li><li>支持的消息标准：如AMQP何STOMP</li><li>消息排序</li><li>投递保证</li><li>持久性：消息能否持久化到磁盘并在代理崩溃时恢复</li><li>耐久性：接收方重连到消息代理，是否会收到断开连接时发送的消息</li><li>可扩展性</li><li>延迟</li><li>竞争性（并发）接收方</li></ul></li><li>每种消息代理只能尽量侧重以上的几点，需要根据场景需求选择合适的消息代理。</li></ul></li></ul><p>使用消息代理实现消息通道：</p><ul><li>ActiveMQ等JMS消息代理具有队列和主题；</li><li>RabbitMQ等基于AMQP的消息代理具有交换和队列；</li><li>Kafka有主题；</li><li>AWS Kinesis有流</li><li>AWS SQS有队列。</li></ul><table><thead><tr><th>消息代理</th><th>点对点通道</th><th>发布-订阅通道</th></tr></thead><tbody><tr><td>JMS</td><td>队列</td><td>主题</td></tr><tr><td>Kafka</td><td>主题</td><td>主题</td></tr><tr><td>AMQP</td><td>队列</td><td>组播式交换和每客户端队列</td></tr><tr><td>AWS Kinesis</td><td>流</td><td>流</td></tr><tr><td>AWS SQS</td><td>队列</td><td>/</td></tr></tbody></table><p>只有AWS SQS只支持点对点通道，其余都支持发布-订阅通道。</p><p>消息代理的优点：</p><ul><li>松耦合：</li><li>消息缓存</li><li>灵活的通信</li><li>明确的进程间通信</li></ul><p>消息代理的缺点：</p><ul><li>潜在的性能瓶颈</li><li>潜在的单点故障</li><li>额外的操作复杂性</li></ul><h3 id="3-5-处理并发和消息顺序"><a href="#3-5-处理并发和消息顺序" class="headerlink" title="3.5 处理并发和消息顺序"></a>3.5 处理并发和消息顺序</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010141.jpg" alt></p><h3 id="3-6-处理重复消息"><a href="#3-6-处理重复消息" class="headerlink" title="3.6 处理重复消息"></a>3.6 处理重复消息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010142.jpg" alt></p><h3 id="3-7-事务性消息"><a href="#3-7-事务性消息" class="headerlink" title="3.7 事务性消息"></a>3.7 事务性消息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010143.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010144.jpg" alt></p><h3 id="3-8-消息相关类库和框架"><a href="#3-8-消息相关类库和框架" class="headerlink" title="3.8 消息相关类库和框架"></a>3.8 消息相关类库和框架</h3><h2 id="四-使用异步消息提供可用性"><a href="#四-使用异步消息提供可用性" class="headerlink" title="四. 使用异步消息提供可用性"></a>四. 使用异步消息提供可用性</h2><h3 id="4-1-同步消息会降低可用性"><a href="#4-1-同步消息会降低可用性" class="headerlink" title="4.1 同步消息会降低可用性"></a>4.1 同步消息会降低可用性</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010145.jpg" alt></p><h3 id="4-2-消除同步交互"><a href="#4-2-消除同步交互" class="headerlink" title="4.2 消除同步交互"></a>4.2 消除同步交互</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010146.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010147.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010148.jpg" alt></p><hr><p>参考：</p><p>🔗 《微服务架构设计模式》</p>]]></content>
    
    <summary type="html">
    
      《微服务架构设计模式》读书笔记，内容：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="microservice" scheme="http://linyishui.top/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构设计模式（二）服务的拆分策略</title>
    <link href="http://linyishui.top/2020111001.html"/>
    <id>http://linyishui.top/2020111001.html</id>
    <published>2020-11-10T12:07:16.000Z</published>
    <updated>2020-11-26T13:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="服务的拆分策略"><a href="#服务的拆分策略" class="headerlink" title="服务的拆分策略"></a>服务的拆分策略</h1><h2 id="第一节-微服务架构是什么？"><a href="#第一节-微服务架构是什么？" class="headerlink" title="第一节 微服务架构是什么？"></a>第一节 微服务架构是什么？</h2><h3 id="1-1-软件架构是什么？"><a href="#1-1-软件架构是什么？" class="headerlink" title="1.1 软件架构是什么？"></a>1.1 软件架构是什么？</h3><p><strong>软件架构</strong>是一种抽象的结构，由软件的各个组成部分和它们之间的依赖关系构成。<strong>计算机系统的软件架构是构建这个系统所需要的一组结构，包含软件元素、它们之间的关系以及两者的属性</strong>。</p><p>将软件分解成元素和定义这些元素之间的关系，决定了软件的能力。</p><p>应用程序有两个层次的需求：<strong>功能性需求</strong>和<strong>质量性需求</strong>，后者决定一个应用在运行和开发时的质量，由所选择的软件架构决定。</p><h3 id="1-2-软件架构的-4-1-视图模型"><a href="#1-2-软件架构的-4-1-视图模型" class="headerlink" title="1.2 软件架构的 4 + 1 视图模型"></a>1.2 软件架构的 4 + 1 视图模型</h3><p>软件架构可以像建筑一样有多个架构视角（+1指场景，把视图串联在一起）：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010108.jpg" alt></p><p>每个视图的目的：</p><ul><li>逻辑视图：开发人员创建的元素，在面向对象语言中是类（Class）和包（Package），关系包括继承、关联和依赖。</li><li>实现视图：构建编译系统的输出，组件是由一个或多个模块组成的可执行或可部署单元。在Java中模块是JAR文件，组件是WAR文件或可执行JAR文件；关系包括模块间的依赖关系和组件模块间的组合关系。</li><li>进程视图：运行时的组件，元素是进程，进程间关系即进程间通信。</li><li>部署视图：进程如何映射到机器，元素由计算机和进程组成，机器之间的关系即网络。</li></ul><h3 id="1-3-架构的风格"><a href="#1-3-架构的风格" class="headerlink" title="1.3 架构的风格"></a>1.3 架构的风格</h3><p>分层架构将软件元素按层的方式组织，每层都有自己的职责，上一层只能依赖于下方的层。</p><p>应用程序可以根据分层结构分为：</p><ul><li>表现层</li><li>业务逻辑层</li><li>数据持久化层</li></ul><p>但表现层无法体现应用可能由多个系统调用的情况，持久化层也无法体现多个数据库交互，业务逻辑层实际上也并不一定依赖于数据持久化层。</p><p>六边形结构是分层结构的替代架构：业务逻辑不再依赖于适配器，而是相反适配器都依赖于业务逻辑。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010109.jpg" alt></p><ul><li>入栈端口是业务逻辑公开的API，外部程序都可以调用它。</li><li><p>出栈端口是业务逻辑调用外部系统的方式，比如存储接口定义了一系列数据访问操作。</p></li><li><p>入栈适配器调用入栈端口处理外部的请求，Spring MVC Controller 或 订阅消息的消息代理客户端。</p></li><li>出栈适配器调用外部应用或服务处理业务逻辑的请求，如数据访问对象（DAO）类或调用远程服务的代理类。</li></ul><h3 id="1-4-微服务架构风格"><a href="#1-4-微服务架构风格" class="headerlink" title="1.4 微服务架构风格"></a>1.4 微服务架构风格</h3><p>单体架构是一种架构风格，实现视图是单个组件，将应用构建为单个可执行或可部署组件。</p><p>微服务架构是一种架构风格，实现视图由多个组件构成，将应用构建为松耦合、可独立部署的一组服务。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010110.jpg" alt></p><h4 id="1-4-1-什么是服务？"><a href="#1-4-1-什么是服务？" class="headerlink" title="1.4.1 什么是服务？"></a>1.4.1 什么是服务？</h4><p>单一的、可独立部署的软件组件就是服务，其API封装了内部实现，强制实现了应用程序的模块化。每个服务都有自己的架构甚至技术栈，往往都是六边形架构，业务逻辑和适配器交互。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010111.jpg" alt></p><h4 id="1-4-2-什么是松耦合？"><a href="#1-4-2-什么是松耦合？" class="headerlink" title="1.4.2 什么是松耦合？"></a>1.4.2 什么是松耦合？</h4><p>服务自身的持久化数据就像类的私有属性一样被封装，这样开发者就可以任意修改服务的数据结构而不用担心影响到别的服务。</p><h4 id="1-4-3-共享类库的角色"><a href="#1-4-3-共享类库的角色" class="headerlink" title="1.4.3 共享类库的角色"></a>1.4.3 共享类库的角色</h4><p>开发时会把常用的功能打包以便多个应用可以重用，而不必复制代码，这是减少重复代码的好方法，但有可能会意外的在服务之间引入耦合。</p><p>把可能会变更的功能作为服务来实现（如业务功能），而不变的可以打包成库。</p><h4 id="1-4-4-服务大小并不重要"><a href="#1-4-4-服务大小并不重要" class="headerlink" title="1.4.4 服务大小并不重要"></a>1.4.4 服务大小并不重要</h4><p>“微”并不特指服务很小，更多的含义应该是单一，我们需要能够识别服务，并确定它们之间如何协作。</p><h2 id="第二节-为应用程序定义微服务架构"><a href="#第二节-为应用程序定义微服务架构" class="headerlink" title="第二节 为应用程序定义微服务架构"></a>第二节 为应用程序定义微服务架构</h2><p>定义程序架构和软件开发一样，没有一个机械化的流程可以保证输出一个合理的架构，我们只能使用一些不断迭代和创新的方法：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010112.jpg" alt></p><p>大致流程：</p><ul><li>第一步将应用程序的需求提炼为各种<strong>系统操作</strong>，是程序必须要处理的请求。</li><li>第二步确定如何<strong>分解服务</strong>。</li><li>第三步<strong>确定每个服务的API</strong>。将每个系统操作分配给服务，服务可以独立或协作实现操作。</li></ul><p>服务分解的几个障碍：</p><ul><li><strong>网络延迟</strong>：服务间往返太多会出现问题。</li><li><strong>同步通信</strong>：服务间的同步通信会降低可用性，需要使用<strong>自包含服务</strong>。</li><li><strong>跨服务的数据一致性</strong>：使用<strong>Saga</strong>。</li><li><strong>上帝类</strong>（God Class）：使用<strong>领域驱动设计</strong>（DDD）消除上帝类。</li></ul><h3 id="2-1-识别系统操作"><a href="#2-1-识别系统操作" class="headerlink" title="2.1 识别系统操作"></a>2.1 识别系统操作</h3><p>第一步创建由关键类组成的抽象领域模型，关键类提供用于描述系统操作的词汇表。第二步确定系统操作，根据领域模型描述每个系统操作的行为。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010113.jpg" alt></p><p>领域模型来源于用户故事中的名词，系统操作来源于动词。</p><h4 id="（1）创建抽象领域模型"><a href="#（1）创建抽象领域模型" class="headerlink" title="（1）创建抽象领域模型"></a>（1）创建抽象领域模型</h4><p>通过需求整理用户故事，从中提炼得到：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010114.jpg" alt></p><p>每个类的作用：</p><ul><li>Consumer：下订单的用户。</li><li>Order：用户下的订单，描述订单信息并跟踪状态。</li><li>OrderLineItem：订单的一个条目。</li><li>DeliveryInfo：送餐的时间和地址。</li><li>Restaurant：餐馆，准备生产订单，同时要发起送货。</li><li>MenuItem：餐馆菜单的一个条目。</li><li>Courier：送餐员负责把订单送到用户手里，可跟踪送餐员可用性和位置。</li><li>Address：用户和餐馆的地址。</li><li>Location：送餐员当前经纬度。</li></ul><h4 id="（2）定义系统操作"><a href="#（2）定义系统操作" class="headerlink" title="（2）定义系统操作"></a>（2）定义系统操作</h4><p>系统操作包括：</p><ul><li>命令型：创建、更新或删除数据的系统操作。</li><li>查询型：查询和读取数据的系统操作。</li></ul><p>分析用户故事中的动词，识别系统指令：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010121.jpg" alt></p><p>命令规范定义了命令对应的参数、返回值和领域模型类的行为，行为规范包括前置条件和后置条件：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010122.jpg" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010123.jpg" alt></p><p>抽象的领域模型和系统操作可以回答这个应用是做什么的问题，每一个系统操作的行为都通过领域模型的方式来描述。</p><h3 id="2-2-根据业务能力进行服务拆分"><a href="#2-2-根据业务能力进行服务拆分" class="headerlink" title="2.2 根据业务能力进行服务拆分"></a>2.2 根据业务能力进行服务拆分</h3><h4 id="（1）什么是业务能力？"><a href="#（1）什么是业务能力？" class="headerlink" title="（1）什么是业务能力？"></a>（1）什么是业务能力？</h4><p>业务能力：指一些能够为公司产生价值的商业活动。</p><p>组织的业务能力指组织的业务是什么，这通常是固定的，而组织采用何种方式来实现其业务能力往往是不断变化的。每个组织有哪些业务能力，通过对组织的目标、结构和商业流程的分析得来。每个业务都可以看作是一个服务，除非只面向业务而非技术。</p><p>业务能力集中在业务对象上，如理赔业务对象是理赔管理功能的重点，能力又可以划分为子能力，理赔管理又包括理赔信息管理、理赔审核和理赔付款管理。</p><blockquote><p>FTGO的业务能力：</p><ul><li>供应商管理<ul><li>Courier management：送餐员相关信息管理</li><li>Restaurant information management：餐馆菜单和其他信息管理（如营业地址和时间）</li></ul></li><li>消费者管理<ul><li>消费者有关信息的管理</li></ul></li><li>订单获取和履行<ul><li>Order management：让消费者可以创建和管理订单</li><li>Restaurant order management：让餐馆可以管理订单的生产过程</li><li>送餐管理</li><li>Courier availability management：送餐员实时状态</li><li>Delivery management：把订单送到用户手中</li></ul></li><li>会计记账<ul><li>Consumer accounting：管理跟消费者相关的会计记账</li><li>Restaurant accounting：管理跟餐馆相关的会计记账</li><li>Courier accounting：管理跟送餐员相关的会计记账</li></ul></li><li>其他</li></ul></blockquote><h4 id="（2）根据业务能力映射到服务"><a href="#（2）根据业务能力映射到服务" class="headerlink" title="（2）根据业务能力映射到服务"></a>（2）根据业务能力映射到服务</h4><p>确定了业务能力后可以为每个能力定义服务，能力有级别划分，哪层级别映射到服务是很主观的判断，有以下理由：</p><ul><li>供应商管理映射到两个服务，因为餐馆和送餐员是完全不同的供应商。</li><li>订单获取和履行映射到三个服务，每个服务负责流程的不同阶段。其中送餐员可用性管理和交付管理结合在一起，映射到单个服务，因为二者交织在一起。</li><li>会计记账能力映射到一个独立服务，不同类型的会计也很相似。</li></ul><p>如下图所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010124.jpg" alt></p><p>架构定义流程的一个重要步骤是调查服务如何在每个关键架构服务中协作，比如你发现由于过多的进程间通信导致特定的分解效率低下，导致必须要把一些服务组合在一起。而在复杂性方面则会增长到很值得拆分的程度。</p><h3 id="2-3-根据DDD子域进行服务拆分"><a href="#2-3-根据DDD子域进行服务拆分" class="headerlink" title="2.3 根据DDD子域进行服务拆分"></a>2.3 根据DDD子域进行服务拆分</h3><p>DDD通过定义多个领域模型解决传统模型难以让所有团队保持一致的难题（如术语），每个领域模型都有明确的范围。</p><ul><li><strong>子域</strong>：领域驱动为每个子域定义单独的领域模型，领域用来描述应用程序问题域的一个术语。识别子域和识别业务能力一样，分析业务并识别业务的不同专业领域，如FTGO的子域有（订单获取、订单管理、餐馆管理、送餐与会计）</li><li><strong>限界上下文</strong>（bounded context）：领域模型的边界被称为限界上下文，包括实现这个模型的代码集合。</li></ul><p>通过DDD的方式定义一个个子域，并把每个子域对应为对应的一个服务，从而完成微服务的设计工作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010125.jpg" alt></p><h3 id="2-4-拆分的原则"><a href="#2-4-拆分的原则" class="headerlink" title="2.4 拆分的原则"></a>2.4 拆分的原则</h3><p>面向对象的设计原则也可以应用于微服务架构：</p><ul><li><strong>单一职责原则</strong>（SRP）：每个类都应该只有一个职责，这样就只有一个理由对它进行修改。多个职责就会使类变得不稳定，对于微服务而言就如FTGO中为客户获取餐食中每个方面（订单获取、订单准备、送餐）都由单一的服务承载。</li><li><strong>闭包原则</strong>（CCP）：在包中所包含的类都是对同类变化的集合，如果要对包进行修改，需要调整的类都应该在包内。若两个类的修改必须耦合的先后发生，它们应该在同一个包内，这样开发者只须对一个交付包进行修改，而不是大规模的修改整个应用。对于微服务架构，CCP是解决分布式单体的利器。</li></ul><h3 id="2-5-拆分单体应用为服务的难点"><a href="#2-5-拆分单体应用为服务的难点" class="headerlink" title="2.5 拆分单体应用为服务的难点"></a>2.5 拆分单体应用为服务的难点</h3><ul><li><strong>网络延迟</strong>：<ul><li>问题：服务分解导致两个服务间大量的往返调用。</li><li>解决：可以通过批处理一次往返多个对象，或者把多个相关服务组合用编程语言的函数调用代替高昂的进程间通信来解决。</li></ul></li><li><strong>同步进程间通信导致可用性降低</strong>：<ul><li>问题：如新增订单 <code>createOrder()</code> 通常让 OrderService 使用REST同步调用其他服务，REST这样的协议会降低服务可用性，任一被调用服务不在可用状态就导致订单无法创建。</li><li>解决：异步消息降低同步调用的紧耦合，同时提高可用性。</li></ul></li><li><strong>在服务之间维持数据一致性</strong>：<ul><li>问题：需要更新多个服务的数据时，保持服务间的数据一致性。如餐馆接受订单时，要在KitchenService和DeliveryService中同时更新，前者修改Ticket状态，后者安排订单交付，都要以原子化的方式完成更新。</li><li>解决：传统的解决方案是基于两阶段提交的分布式事务管理，但并非最好的选择；Saga是一系列使用消息协作的本地事务，唯一的限制是最终一致性，需要原子更新数据都在单个服务中。</li></ul></li><li><strong>获取一致的数据视图</strong>：<ul><li>问题：无法跨过多个数据库获得一致的真实视图。单体应用中ACID保证返回一致视图，微服务即使每个服务数据库都一致也无法得到。</li><li>解决：视图必须驻留在单个服务中。</li></ul></li><li><strong>上帝类阻碍了拆分</strong>：<ul><li>问题：整个应用程序都要使用的全局类，上帝类代表对应用至关重要的概念如银行账户、电子商务订单、保险政策等等。对于FIGO就是Order类，系统大部分服务都涉及订单。如下图2-10是传统建模创建的Order类结构。</li><li>解决：<ul><li>将Order类打包到库，创建一个中央数据库，处理订单的所有服务都要访问该库。但此方案破坏了微服务架构的原则，并导致了紧耦合。</li><li>将Order数据库封装到OrderService供其他服务调用，但OrderService将成为一个纯数据服务，成为缺乏业务逻辑的<strong>贫血领域模型</strong>。</li><li>好的方案是遵循DDD将每个服务视为领域模型的单独子域，FTGO的每个与订单相关的服务都有自己的领域模型及对应的Order类的版本。如下图2-11，对于DeliveryService，Order可以命名为更合适的Delivery。</li></ul></li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010126.jpg" alt></p><p>DeliveryService对Order的其他属性不感兴趣：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010127.jpg" alt></p><p>KitchenService的Order就是一个Ticket（后厨工单），只包含状态、请求送餐时间、准备时间等，以及告诉餐馆准备的订单项列表。而不关心如消费者、付款、交付这些无关属性。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010128.jpg" alt></p><p>每个领域模型的Order类都表示同一个订单业务实体的不同方面，应用必须维持不同服务中这些不同对象之间的一致性。比如一旦OrderService授权消费者的信用卡，必须触发KitchenService中创建Ticket。同样，如果KitchenService拒绝订单，必须在OrderService中取消订单，并为客户退款。</p><p><strong>可以通过事件驱动机制Saga来维护服务间的一致性</strong>。</p><h3 id="2-6-定义服务API"><a href="#2-6-定义服务API" class="headerlink" title="2.6 定义服务API"></a>2.6 定义服务API</h3><p>到这个阶段，我们有了一个系统操作列表和潜在服务列表，下一步是定义每个服务的API：<strong>服务的操作和事件</strong>。</p><p>定义API操作的原因：</p><ol><li>某些操作对应系统操作，由外部客户端调用，或者其他服务调用。</li><li>支持服务之间协作的操作，仅供其他服务调用。</li></ol><p>服务通过对外发布事件，使其能与其他服务协作。</p><h4 id="（1）将系统操作分配给服务"><a href="#（1）将系统操作分配给服务" class="headerlink" title="（1）将系统操作分配给服务"></a>（1）将系统操作分配给服务</h4><p>第一步，确定哪个服务是请求的初始入口点。如 <code>noteUpdateLocation()</code> 更新送餐员位置，因为与送餐员相关，所以应该分配给CourierService，但它也是需要送餐地点的DeliveryService。这种情况最好把操作分配给需要操作所提供信息的服务，其他情况下分配给具有处理它所需信息的服务更有意义。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010129.jpg" alt></p><h4 id="（2）确定支持服务协作所需要的API"><a href="#（2）确定支持服务协作所需要的API" class="headerlink" title="（2）确定支持服务协作所需要的API"></a>（2）确定支持服务协作所需要的API</h4><p>第二步，是确定在处理每个系统操作时，服务之间如何交互。</p><p>如 <code>createOrder()</code> 操作需要OrderService调用一下服务以验证其前置条件并使后置条件成立：</p><ul><li>ConsumerService：验证消费者是否可以下订单并获取付款信息。</li><li>RestaurantService：验证订单行项目，验证送货地址和时间是否在餐厅的服务区域内，验证订单最低要求，并获得订单行项目的价格。</li><li>KitchenService：创建Ticket后厨工单。</li><li>AccountingService：授权消费者的信用卡。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010130.jpg" alt></p><hr><p>参考：</p><p>🔗 《微服务架构设计模式》</p>]]></content>
    
    <summary type="html">
    
      《微服务架构设计模式》读书笔记，内容：微服务架构是什么，微服务架构风格，为应用定义微服务架构的流程（识别系统操作、根据业务能力或DDD子域进行服务拆分、拆分的原则和难点、定义服务的API）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="microservice" scheme="http://linyishui.top/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构设计模式（一）逃离单体地狱</title>
    <link href="http://linyishui.top/2020110701.html"/>
    <id>http://linyishui.top/2020110701.html</id>
    <published>2020-11-07T13:09:35.000Z</published>
    <updated>2020-11-09T14:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="逃离单体地狱"><a href="#逃离单体地狱" class="headerlink" title="逃离单体地狱"></a>逃离单体地狱</h1><h2 id="第一节-为什么要使用微服务架构"><a href="#第一节-为什么要使用微服务架构" class="headerlink" title="第一节 为什么要使用微服务架构"></a>第一节 为什么要使用微服务架构</h2><h3 id="1-1-单体架构的优点"><a href="#1-1-单体架构的优点" class="headerlink" title="1.1 单体架构的优点"></a>1.1 单体架构的优点</h3><ul><li>应用开发简单：只须构建一个项目。</li><li>方便进行大规模修改</li><li>测试简单直观：测试只须启动程序，调用REST API，使用如Selenium等测试工具。</li><li>部署简单：复制war包到Tomcat。</li><li>横向扩展容易：只须部署多个实例并进行负载均衡。</li></ul><h3 id="1-2-单体地狱"><a href="#1-2-单体地狱" class="headerlink" title="1.2 单体地狱"></a>1.2 单体地狱</h3><ul><li>程序代码规模不断壮大，复杂性越来越高。</li><li>开发速度缓慢，编译、构建、运行都十分耗时。</li><li>代码提交到实际部署周期长，且容易发生问题：代码太过复杂，一个更改所造成的影响难以预测，导致即使是微小的修改也需要测试人员全面的测试。</li><li>难以扩展：不同模块需求如内存、CPU等需要同时被满足。</li><li>缺乏可靠性：应用庞大难以进行全面的测试，错误的代码会进入生产环境；应用缺乏<strong>故障隔离</strong>，一处内存泄漏会导致应用所有实例崩溃。</li><li>长期依赖过时的技术栈：单体架构难以更新框架和语言，因为应用要被重写。</li></ul><p>架构并不影响功能性需求（业务），主要影响的是<strong>非功能性需求</strong>，也叫<strong>质量属性</strong>或其他能力。最常见的就是影响软件交付速度的<strong>可维护性</strong>、<strong>可扩展性</strong>和<strong>可测试性</strong>。</p><h3 id="1-3-扩展立方体"><a href="#1-3-扩展立方体" class="headerlink" title="1.3 扩展立方体"></a>1.3 扩展立方体</h3><ul><li>X轴扩展：<strong>水平复制</strong>，通过克隆实例的方式来扩展。<ul><li>将用户请求通过负载均衡算法路由到几个相同的应用实例。</li><li>可以提供吞吐量和可用性。</li></ul></li><li>Y轴扩展：<strong>功能性分解</strong>，通过分解不同的功能模块的方式来扩展。<ul><li><strong>将应用程序拆分为一组服务，每个服务负责特定的功能，每个服务可以进行X轴或Z轴扩展</strong>。</li><li>解决了开发问题和应用复杂性。</li></ul></li><li>Z轴扩展：<strong>数据分区</strong>，通过类似用户ID切分相似的数据分区的方式来扩展。<ul><li>每个应用实例仅负载数据的一个子集，路由器根据请求的UserId来决定路由到哪个实例。</li><li>可以提供吞吐量和可用性，适用于增长的事务和数据量。</li></ul></li></ul><h3 id="1-4-什么是微服务？"><a href="#1-4-什么是微服务？" class="headerlink" title="1.4 什么是微服务？"></a>1.4 什么是微服务？</h3><p>针对微服务的定义有很多，比如<strong>强调尺寸</strong>的如服务的代码应该在100行内，<strong>强调开发周期</strong>的如两周内；微服务可以定义为<strong>面向服务的架构，由松耦合和具有边界上下文的元素组成</strong>。</p><p>容易理解的概括：<strong>微服务是把应用程序功能性分解为一组服务的架构风格，是一种模块化的形式</strong>。</p><p>在单体应用中，模块由一组编程语言所提供的结构（如Java的 Package 或 Jar 这样的构建制品）定义。微服务则使用服务作为模块化的单元，服务的API即自身的边界，只能通过API来访问服务内部的类。</p><p>微服务架构的关键特性是<strong>每个服务之间都是松耦合的，只通过API进行通信</strong>。实现这种松耦合，需要<strong>每个服务都有自己的私有数据库</strong>。</p><h3 id="1-5-微服务与SOA的异同"><a href="#1-5-微服务与SOA的异同" class="headerlink" title="1.5 微服务与SOA的异同"></a>1.5 微服务与SOA的异同</h3><table><thead><tr><th></th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>服务间通信</td><td>智能管道如ESB，往往采用重量级协议，如SOAP或其他WS*标准</td><td>使用哑管道，如消息代理，或服务之间点对点通信，如REST或gRPC等轻量级协议</td></tr><tr><td>数据管理</td><td>全局数据模型并共享数据库</td><td>每个服务都有自己的数据模型和数据库</td></tr><tr><td>典型服务的规模</td><td>较大的单体应用（几个）</td><td>较小的服务（几百个）</td></tr></tbody></table><h3 id="1-6-微服务架构的优缺点"><a href="#1-6-微服务架构的优缺点" class="headerlink" title="1.6 微服务架构的优缺点"></a>1.6 微服务架构的优缺点</h3><p>优点：</p><ul><li><p>使大型复杂应用程序可以<strong>持续交付和持续部署</strong>：持续交付和持续部署是DevOps的一部分，</p><ul><li><p>三种实现方式：</p><ul><li>拥有可测试性：自动化测试是持续交付和持续部署的重要环节，每个服务都很小，所以易于编写和执行自动化测试。</li><li>拥有可部署性：每个服务都可以独立于其他服务进行部署，而不需要互相协调。</li><li>使开发团队可以自主且松散耦合：开发团队可以分为一个个小团队，每个团队负责一个或多个相关服务的开发与部署。</li></ul></li><li><p>三个作用：</p><ul><li>缩短产品或新功能的上市时间，更快响应客户的反馈。</li><li>提供客户所期望的可靠服务。</li><li>提高员工满意度，因为他们不用再此处担任救火队员。</li></ul></li></ul></li><li><p>每个服务都相对<strong>较小</strong>并<strong>容易维护</strong>：</p><ul><li>较小的代码规模更有利于开发者理解。</li><li>IDE等开发工具使用起来更快速，提高开发效率。</li><li>服务启动速度快很多，提高了研发、调试、部署等效率。</li></ul></li><li><p>服务可以<strong>独立部署</strong>：</p><ul><li>每次修改或新增功能后，不需要再将整个应用重新部署。</li></ul></li><li><p>服务可以<strong>独立扩展</strong>：</p><ul><li>服务可以再进行X轴、Z轴扩展。</li><li>服务可以部署在适合的硬件上，需要高内存的和需要高CPU的可以分别部署。</li></ul></li><li><p><strong>实现团队的自治</strong>：</p><ul><li>小规模团队可以自行治理，专注于解决服务内问题。</li></ul></li><li><p><strong>更易实验和接纳新技术</strong>：</p><ul><li>每一个新服务都可以自由选择适宜的语言和框架，现实往往公司会有很多限制和规范，但至少有了选择的权利。</li><li>服务更小也使用新技术重写一个服务变得可能，如果实验失败也可以承担这部分损失而不至于毁掉整个项目。</li></ul></li><li><p><strong>更好的容错性</strong>：</p></li><li>可以实现更好的故障隔离，一个服务的问题不会影响其他服务。</li></ul><p>缺点：</p><ul><li>服务的拆分和定义是一项挑战：<ul><li>没有一个具体的、优质的算法来完成服务拆分。</li><li>一旦拆分失误，可能会构建出一个分布式的单体应用，一大堆紧耦合的服务又必须部署在一起的分布式系统。</li></ul></li><li>分布式系统带来各种复杂性，使开发、测试和部署变得更困难：<ul><li>服务间必须使用进程间通信机制。</li><li>必须处理局部故障和远程服务不可用或高延迟的情况。</li><li>每个服务都有自己的数据库，跨服务的事务和查询比较复杂。</li><li>运维难度增高，需要高度自动化的技术：<ul><li><strong>自动化部署工具</strong>：如 Netflix Spinnaker。</li><li><strong>产品化的PaaS平台</strong>：如 Pivotal Cloud Foundry 或 Red Hat OpenShift。</li><li><strong>Docker容器编排平台</strong>：如 Docker Swarm 或 Kubernates。</li></ul></li></ul></li><li>当部署跨越多个服务的功能时需要谨慎的协调更多开发团队：<ul><li>需要制定一个发布计划，按照服务的依赖关系排序。</li></ul></li><li>开发者需要思考到底应该在应用的什么阶段使用微服务架构：<ul><li>项目初创阶段往往并不需要微服务架构来解决问题，此时单体架构是更高效的选择。</li><li>微服务是一把双刃剑，不过面向消费者的Web应用或SaaS类复杂程序往往适用于微服务架构。</li></ul></li></ul><h2 id="第二节-模式语言"><a href="#第二节-模式语言" class="headerlink" title="第二节 模式语言"></a>第二节 模式语言</h2><h3 id="2-1-为什么需要模式？"><a href="#2-1-为什么需要模式？" class="headerlink" title="2.1 为什么需要模式？"></a>2.1 为什么需要模式？</h3><p>1986年，《人月神话》作者曾说过：软件工程的世界没有银弹。任何技术都有其利弊，但开发人员还是会坚信新的技术会是万能钥匙，人的大脑中情绪化的部分会进行大部分的决策。所以<strong>我们需要一种客观的工具，来克服情绪化的本能</strong>，这种工具即模式（Pattern）。</p><h3 id="2-2-什么是模式和模式语言？"><a href="#2-2-什么是模式和模式语言？" class="headerlink" title="2.2 什么是模式和模式语言？"></a>2.2 什么是模式和模式语言？</h3><p><strong>模式是针对上下文中发生的问题的可重用解决方案</strong>，<strong>模式语言是解决特定领域内问题的相关模式的集合</strong>。1994年，《设计模式：可复用面向对象软件的基础》采用模式语言来解决设计和架构问题，在开发人员中普及了模式的概念。</p><p>模式需要描述其适用的上下文环境，结构：</p><ul><li>需求（Forces）</li><li>结果上下文（Resulting context）</li><li>相关模式（Related patterns）</li></ul><h4 id="2-2-1-需求-必须解决的问题"><a href="#2-2-1-需求-必须解决的问题" class="headerlink" title="2.2.1 需求-必须解决的问题"></a>2.2.1 需求-必须解决的问题</h4><p>需求需要按优先级排序，重要性取决于上下文环境。比如代码要求可读性和好的性能在一些情况下是冲突的，只能尽量满足其中一种。</p><h4 id="2-2-2-结果上下文-采用模式后可能带来的后果"><a href="#2-2-2-结果上下文-采用模式后可能带来的后果" class="headerlink" title="2.2.2 结果上下文-采用模式后可能带来的后果"></a>2.2.2 结果上下文-采用模式后可能带来的后果</h4><p>包含三个部分：</p><ul><li>好处：这个模式的好处和它解决了什么需求。</li><li>弊端：这个模式的弊端和它未解决什么需求。</li><li>问题：使用这个模式引入的新问题。 </li></ul><h4 id="2-2-3-相关模式-5种不同类型的关系"><a href="#2-2-3-相关模式-5种不同类型的关系" class="headerlink" title="2.2.3 相关模式-5种不同类型的关系"></a>2.2.3 相关模式-5种不同类型的关系</h4><p>相关模式描述该模式和其他模式间的关系：</p><ul><li><strong>前导</strong>（Predecessor）：<strong>催生这个模式的需求的模式</strong>。<ul><li>如微服务架构模式是除了单体架构模式以外整个模式语言中所有模式的前导模式。</li></ul></li><li><strong>后续</strong>（Successor）：<strong>指用来解决当前模式引入新问题的模式</strong>。<ul><li>如引入微服务模式后需要解决如服务发现、断路器等微服务带来的新问题。</li></ul></li><li><strong>替代</strong>（Alternative）：<strong>当前模式的替代模式，提供了另外的解决方案</strong>。<ul><li>如单体模式和微服务模式互为替代模式。</li></ul></li><li><strong>泛化</strong>（Generalization）：<strong>针对一个问题的一般性解决方案</strong>。<ul><li>如“每主机单个服务”这个模式存在多种不同的技术实现。</li></ul></li><li><strong>特化</strong>（Specialization）：<strong>针对特定模式的具体解决方案</strong>。<ul><li>如将服务部署为容器模式是针对“每主机单个服务”的具体解决方案。</li></ul></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010101.jpg" alt></p><p>通过这些关系可以将相关的模式集合形成所谓的模式语言，共同解决特定领域的问题。</p><h3 id="2-3-微服务架构的模式语言"><a href="#2-3-微服务架构的模式语言" class="headerlink" title="2.3 微服务架构的模式语言"></a>2.3 微服务架构的模式语言</h3><p>左侧是应用程序架构模式组，应用相关模式组解决引入微服务架构后带来的新问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010102.jpg" alt></p><h4 id="2-3-1-服务拆分的相关模式"><a href="#2-3-1-服务拆分的相关模式" class="headerlink" title="2.3.1 服务拆分的相关模式"></a>2.3.1 服务拆分的相关模式</h4><p>根据业务或子域切分服务：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010103.jpg" alt></p><h4 id="2-3-2-通信的相关模式"><a href="#2-3-2-通信的相关模式" class="headerlink" title="2.3.2 通信的相关模式"></a>2.3.2 通信的相关模式</h4><p>分布式系统中进程间通信是重要组成部分，通信模式包括：</p><ul><li><strong>通信风格</strong>：使用哪一类进程间通信机制？</li><li><strong>服务发现</strong>：客户端如何获得服务具体事例（如HTTP请求）的IP地址？</li><li><strong>可靠性</strong>：在服务不可用的情况下，如何确保服务之间的可靠通信？</li><li><strong>事务性消息</strong>：如何将消息发送、事件发布这样的动作与更新业务数据的数据库事务集成？</li><li><strong>外部API</strong>：应用程序的客户端如何与服务通信？</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010104.jpg" alt></p><h4 id="2-3-3-实现事务管理的数据一致性的相关模式"><a href="#2-3-3-实现事务管理的数据一致性的相关模式" class="headerlink" title="2.3.3 实现事务管理的数据一致性的相关模式"></a>2.3.3 实现事务管理的数据一致性的相关模式</h4><p>为什么常用的两步式提交（2PC）分布式事务机制在微服务架构场景不再适用？而是需要使用Saga来确保数据一致性？</p><h4 id="2-3-4-微服务架构查询数据的相关模式"><a href="#2-3-4-微服务架构查询数据的相关模式" class="headerlink" title="2.3.4 微服务架构查询数据的相关模式"></a>2.3.4 微服务架构查询数据的相关模式</h4><p>传统SQL JOIN在微服务场景需要从多个服务的数据源获取数据，服务的数据只能通过API访问，所以不能直接针对服务的数据库执行分布式查询：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010105.jpg" alt></p><p>API组合模式，逐一调用服务的API再把所有返回聚合在一起，即<strong>命令查询职责隔离方式</strong>（CQRS）。</p><h4 id="2-3-5-服务部署的相关模式"><a href="#2-3-5-服务部署的相关模式" class="headerlink" title="2.3.5 服务部署的相关模式"></a>2.3.5 服务部署的相关模式</h4><p>微服务架构需要高度自动化部署的基础设施，即一个部署平台，至少有一个简单的界面来部署和管理服务。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010106.jpg" alt></p><h4 id="2-3-6-可观测性的相关模式"><a href="#2-3-6-可观测性的相关模式" class="headerlink" title="2.3.6 可观测性的相关模式"></a>2.3.6 可观测性的相关模式</h4><p>理解和诊断微服务架构下的问题是一项复杂的工作，在返回结果给客户端前，请求往往会在多个服务之间跳转，只看一个日志文件是不够的。</p><p>可以通过以下模式设计具备可观测性的服务：</p><ul><li><strong>健康检查API</strong>：可以返回服务健康状态的API。</li><li><strong>日志聚合</strong>：把服务产生的日志写入一个集中式的日志服务器，这个服务器可以提供日志搜索，也可以根据日志情况触发报警。</li><li><strong>分布式追踪</strong>：为每一个外部请求分配一个唯一的ID，用于在各个服务之间追踪外部请求。</li><li><strong>异常跟踪</strong>：把程序异常发送到异常跟踪服务，这个服务会排除重复异常，给开发者发送告警并跟踪每一个异常的解决。</li><li><strong>应用指标</strong>：供维护使用的指标，例如计数器等，导出到指标服务器。</li><li><strong>审计日志</strong>：记录用户的行为。</li></ul><h4 id="2-3-7-服务自动化测试的相关模式"><a href="#2-3-7-服务自动化测试的相关模式" class="headerlink" title="2.3.7 服务自动化测试的相关模式"></a>2.3.7 服务自动化测试的相关模式</h4><p>单一的服务测试变得更容易，但还要测试不同的服务是否协同工作，避免使用复杂、缓慢和脆弱的端到端测试来测试多个服务。</p><ul><li><strong>消费端驱动的契约测试</strong>：验证服务满足客户端所期望的功能。</li><li><strong>消费端契约测试</strong>：验证服务的客户端可以正常与服务通信。</li><li><strong>服务组件测试</strong>：在隔离的环境中测试服务。</li></ul><h4 id="2-3-8-解决基础设施和边界问题的相关模式"><a href="#2-3-8-解决基础设施和边界问题的相关模式" class="headerlink" title="2.3.8 解决基础设施和边界问题的相关模式"></a>2.3.8 解决基础设施和边界问题的相关模式</h4><p>每个服务都需要实现与基础设施相关的功能，如可观测模式和服务发现模式。还必须实现外部化配置模式，在运行时向服务提供数据库凭据等配置参数。</p><h4 id="2-3-9-安全的相关模式"><a href="#2-3-9-安全的相关模式" class="headerlink" title="2.3.9 安全的相关模式"></a>2.3.9 安全的相关模式</h4><p>微服务架构中，用户身份验证的工作由API Gateway完成，它必须将用户信息传递给需要的服务。常见的解决方案是<strong>应用访问令牌模式</strong>（JWT），将Token传递给服务，服务验证Token获得用户信息。</p><h2 id="第三节-流程和组织"><a href="#第三节-流程和组织" class="headerlink" title="第三节 流程和组织"></a>第三节 流程和组织</h2><p>架构、流程和组织的关系：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201101/202011010107.jpg" alt></p><p>《人月神话》提到沟通成本随着团队规模增加呈O(N^2^)速度上升，解决办法是大团队切分为一个个小团队，每个团队都是跨职能的，可以独立完成开发、测试和部署等任务，而不需要频繁和其他团队沟通或协调。</p><p>微服务架构适用于 Scrum 或 Kanban 这类敏捷开发和部署实践，需要积极实践持续交付和持续部署。</p><blockquote><p>持续交付能够以可持续的方式安全、快速的将所有类型的更改（包括新功能、配置更改、错误修复和实验）交付到生产环境或用户手中。</p></blockquote><p>持续交付依赖于高水平的自动化，包括自动化测试。持续部署有效的支持持续交付，每天多次部署到生产环境，很少发生生产中断，并且可以从任意事件中快速恢复。</p><blockquote><p>持续交付和持续部署的四个有用指标：</p><ul><li>部署频率：软件部署到生产环境的频率。</li><li>交付时间：从开发人员提交变更到变更被部署的时间。</li><li>平均恢复时间：从生产环境问题中恢复的时间。</li><li>变更失败率：导致生产环境问题的变更提交百分比。</li></ul></blockquote><hr><p>参考：</p><p>🔗 《微服务架构设计模式》</p>]]></content>
    
    <summary type="html">
    
      《微服务架构设计模式》读书笔记，内容：为什么要使用微服务架构，微服务架构的模式语言，架构、流程和组织的变化等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="microservice" scheme="http://linyishui.top/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（八）高阶</title>
    <link href="http://linyishui.top/2020101301.html"/>
    <id>http://linyishui.top/2020101301.html</id>
    <published>2020-10-13T03:20:01.000Z</published>
    <updated>2020-11-03T13:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（八）高阶"><a href="#RabbitMQ（八）高阶" class="headerlink" title="RabbitMQ（八）高阶"></a>RabbitMQ（八）高阶</h1><h2 id="第一节-存储机制"><a href="#第一节-存储机制" class="headerlink" title="第一节 存储机制"></a>第一节 存储机制</h2><h3 id="1-1-消息如何存储"><a href="#1-1-消息如何存储" class="headerlink" title="1.1 消息如何存储"></a>1.1 消息如何存储</h3><p>消息：</p><ul><li>持久化消息：到达队列时写入磁盘，允许的话在内存保留备份，内存吃紧时清除。</li><li>非持久化消息：一般保存在内存，内存吃紧时转移到磁盘。</li></ul><p>消息进入磁盘的处理在<strong>持久层</strong>完成，持久层包含：</p><ul><li><p><strong>队列索引</strong>（rabbit_queue_index）：负责维护队列中落盘消息的信息，包括消息的存储地点、是否己被交付给消费者、是否己被消费者 ack 等。每个队列都有一个对应的队列索引。</p><ul><li>存储方式：以顺序（文件名从0开始累加）的<strong>段文件</strong>来进行存储，后缀为 <code>.idx</code> ，每个段文件包含固定的 <code>SEGMENT_ENTRY_COUNT</code> 条记录，默认为16384。</li></ul></li><li><p><strong>消息存储</strong>（rabbit_msg_store）：以键值对的形式存储消息，它被所有队列共享，在每个节点中有且只有一个。</p><p>可以分为：</p><ul><li>msg_store_persistent：负责持久化消息的持久化，重启后消息不会丢失；</li><li>msg_store_transient：负责非持久化消息的持久化，重启后消息会丢失。</li></ul><p>存储方式：经过消息存储处理的消息都会以追加的方式写入到文件中，大小超过指定的限制 <code>file_size_limit</code> 后，关闭文件再创建一个新文件。<strong>在进行消息的存储时， 会在 ETS (Erlang Term Storage）表中记录消息在文件中的位置映射（Index）和文件的相关信息（FileSummary）</strong>。</p></li></ul><p>消息（包括消息体、属性和 headers ）可以直接存储在队列索引中，也可以被保存在消息存储中。一般按消息大小来划分，小消息放入前者，大消息放入后者。通过 <code>queue_index_embed_msgs_below</code> 来配置，默认为4096B（指消息体+属性+headers的整体大小）。</p><p><strong>读取消息</strong>流程：</p><ul><li>先根据消息的 ID（msg_id）找到对应存储的文件，</li><li>如果文件存在并且未被锁住，则直接打开文件，从指定位置读取消息的内容。</li><li>如果文件不存在或者被锁住了， 则发送请求由 rabbit_msg_store 进行处理。</li></ul><p><strong>删除消息</strong>只是从ETS表删除相关信息，同时更新对应的存储文件，所以不会立即对文件中的消息进行删除，只是标记为垃圾数据（类似GC？）。</p><p>触发垃圾回收的条件：</p><ul><li>一个文件全是垃圾数据，会删除此文件。</li><li>检测到前后两个文件（<strong>相邻</strong>）的有效数据可以合并在一个文件中，且所有垃圾数据的大小与文件总大小比值超过设定阈值 <code>GARBAGE_FRACTION</code>（默认0.5）时，触发垃圾回收，将文件合并。</li></ul><p>合并时先<strong>锁定</strong>两个文件，先<strong>整理前个文件</strong>的有效数据，再将后面文件的有效数据<strong>写入前个文件</strong>，同时<strong>更新ETS表</strong>的记录，最后<strong>删除后面的文件</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010152.png" alt></p><p>如果消息投递的目的队列是空的，并且有消费者订阅了这个队列，那么该消息会直接发送给消费者，不会经过队列这一步。而当消息无法直接投递给消费者时，需要暂时将消息存入队列，以便重新投递。</p><h3 id="1-2-队列的结构"><a href="#1-2-队列的结构" class="headerlink" title="1.2 队列的结构"></a>1.2 队列的结构</h3><h4 id="1-2-1-消息在队列中有四种状态"><a href="#1-2-1-消息在队列中有四种状态" class="headerlink" title="1.2.1 消息在队列中有四种状态"></a>1.2.1 消息在队列中有四种状态</h4><p>消息在队列中存在，其状态可能会不断发生变化：</p><ul><li>alpha ：消息内容（包括消息体、属性和 headers ）和消息索引都存储在内存中。</li><li>beta ：消息内容保存在磁盘中，消息索引保存在内存中。</li><li>gamma ：消息内容保存在磁盘中，消息索引在磁盘和内存中都有。<ul><li>只有持久化消息会处于此状态；</li><li>durable 属性设置为 true 的消息一定进入此状态；</li><li>在开启 publisher confirm 机制时， 只有到了 gamma 状态时才会确认该消息己被接收，若消息消费速度足够快，内存也充足，这些消息也不会继续走到下一个状态。</li></ul></li><li>delta ：消息内容和索引都在磁盘中。<strong>需要两次I/O操作才能读到消息，一次读消息索引（rabbit_queue_index），一次读消息内容（rabbit_msg_store）</strong>。前面状态则只需一次，直接读rabbit_msg_store，因为索引在内存中，而delta的索引在磁盘中。</li></ul><p>状态转换：</p><ul><li>在运行时可以根据消息的传送速度计算一个当前内存能够保存的最大消息数量 <code>target_ram_count</code> ，当 alpha 的消息数量大于此值时，会把多余的消息转为后续状态。</li><li>状态机制为了满足不同的内存和CPU需求，alpha 耗内存，但不怎么耗CPU；而如 delta 不消耗内存，但会消耗很多CPU和I/O操作。</li></ul><h4 id="1-2-2-队列子结构"><a href="#1-2-2-队列子结构" class="headerlink" title="1.2.2 队列子结构"></a>1.2.2 队列子结构</h4><p>队列结构包括：</p><ul><li>rabbit_amqqueue_process：负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认（包括生产端的 confirm 和消费端的 ack ）等。</li><li>backing_queue：是消息存储的具体形式和引擎，并向 rabbit_amqqueue_process 提供相关的接口以供调用。<ul><li>默认实现：rabbit_variable_queue，通过5个子队列Q1、Q2、Delta、Q3和Q4实现各个消息状态。</li></ul></li></ul><p>队列结构如图：Q1和Q4只包含alpha状态，Delta只包含delta状态，Q2和Q3包含beta和gamma状态；所以消息按这个顺序流动就是从内存到磁盘再回内存的过程，能够适应负载升高和降低的变化。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010153.png" alt></p><h4 id="1-2-3-从子队列消费消息"><a href="#1-2-3-从子队列消费消息" class="headerlink" title="1.2.3 从子队列消费消息"></a>1.2.3 从子队列消费消息</h4><p>消费者获取消息：</p><ul><li>尝试从Q4获取，成功则返回；</li><li>否则尝试从Q3获取，此时判断Q3是否为空，为空表示队列无消息；</li><li>Q3不为空则取出消息，再判断此时Q3和Delta的长度：<ul><li>若都为空，可以认为Q2到Q4都为空，将Q1消息转移到Q4方便下次读取。</li><li>若Q3为空，Delta不为空，将消息转移至Q3，方便下次获取。转移的过程按索引分段读取。</li></ul></li><li><strong>为什么Q3为空可以认为整个队列为空？</strong>因为若Q3为空时，Delta不为空，在取Q3取最后一条消息时必然会将Delta的消息转移过来，所有前面的子队列都可以类推。</li></ul><h4 id="1-2-4-为什么消息堆积很棘手"><a href="#1-2-4-为什么消息堆积很棘手" class="headerlink" title="1.2.4 为什么消息堆积很棘手"></a>1.2.4 为什么消息堆积很棘手</h4><p><strong>当负载较高时，消息不能很快被消费掉，就会进入到比较靠后的队列中，这就增加了处理每个消息的平均开销。因为要花更多的时间和资源来处理堆积的消息，自然处理新流入的消息的能力就会降低，新流入的消息又积压，这就构成了负循环，使情况越来越差。</strong></p><p><strong>处理方案</strong>：</p><ul><li><strong>增加 prefetch_count 的值，即一次发送多条消息给消费者，加快消息被消费的速度</strong>；</li><li><strong>采用 multiple ack ，降低处理 ack 带来的开销</strong>；</li><li><strong>流量控制</strong>。</li></ul><h3 id="1-3-惰性队列"><a href="#1-3-惰性队列" class="headerlink" title="1.3 惰性队列"></a>1.3 惰性队列</h3><p>RabbitMQ 在 3.6.0 版本引入了惰性队列，惰性队列会<strong>尽可能地将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中</strong>。</p><ul><li>设计目标：能够<strong>支持更长的队列</strong>，即<strong>支持更多的消息存储</strong>。</li><li>使用场景：当消费者由于各种各样的原因（比如消费者下线、宕机或者由于维护而关闭等）致使长时间内不能消费消息而造成堆积时，惰性队列就很有必要了。</li></ul><h4 id="1-3-1-为什么要使用惰性队列？"><a href="#1-3-1-为什么要使用惰性队列？" class="headerlink" title="1.3.1 为什么要使用惰性队列？"></a>1.3.1 为什么要使用惰性队列？</h4><p>默认情况下，消息生产到队列后会尽可能的存储到内存，以便更快速的发送给消费者。即使是持久化的消息，也在存入磁盘的同时驻留在内存一份备份。</p><p>内存占用过高时，需要释放内存将消息转移到磁盘，这一操作会耗费很长的时间，并且阻塞队列的操作，导致无法接收新的消息。</p><p>惰性队列则会将消息直接存到文件系统中，从而减少了内存的损耗。但相应的增加了I/O的使用，但其实对于持久化消息，I/O操作是无法避免的，所以<strong>持久化消息和惰性队列是绝配</strong>。</p><h4 id="1-3-2-使用惰性队列"><a href="#1-3-2-使用惰性队列" class="headerlink" title="1.3.2 使用惰性队列"></a>1.3.2 使用惰性队列</h4><p>可以在声明队列时设置惰性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-queue-mode"</span>, <span class="string">"lazy"</span>);</span><br><span class="line"><span class="comment">// 可以在声明队列时设置惰性</span></span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><p>也可以通过策略Policy的方式设置：（优先级大于前者）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy Lazy <span class="string">"^myqueue$"</span> <span class="string">'&#123;"queue-mode":"lazy"&#125;'</span> --apply-tO queues</span></span><br></pre></td></tr></table></figure><h4 id="1-3-3-惰性与普通队列的性能差距"><a href="#1-3-3-惰性与普通队列的性能差距" class="headerlink" title="1.3.3 惰性与普通队列的性能差距"></a>1.3.3 惰性与普通队列的性能差距</h4><p>假如发送1千万条消息，每条消息的大小为1KB ，并且此时没有任何的消费者，那么普通队列会消耗 1.2GB 的内存，而惰性队列只消耗 1.5MB 的内存。</p><p>对于普通队列，如果要发送1千万条消息，需要耗费 801 秒，平均发送速度约为 13000 条/秒。如果使用惰性队列，那么发送同样多的消息时，耗时是 421 秒，平 均发送速度约为 24000 条/秒。</p><p>出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近 40MB 的空间来发送消息，对于一个消费者的情况，平均的消费速度约为 14000 条/秒。</p><h2 id="第二节-内存及磁盘告警"><a href="#第二节-内存及磁盘告警" class="headerlink" title="第二节 内存及磁盘告警"></a>第二节 内存及磁盘告警</h2><p>内存有使用上限阈值，磁盘有剩余空间阈值，达到时都会使RabbitMQ暂时阻塞 客户端的连接并停止接收从客户端发来的消息，以此避免服务崩溃。心跳检测也会失效。</p><p>检测状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_connections</span></span><br></pre></td></tr></table></figure><ul><li>blocking：不发送消息的连接处于此状态。</li><li>blocked：一直有发送消息的处于此状态。</li></ul><h3 id="2-1-内存告警"><a href="#2-1-内存告警" class="headerlink" title="2.1 内存告警"></a>2.1 内存告警</h3><p>RabbitMQ 服务器会在启动或者执行 <code>rabbitmqctl set_vm_memory_high_watermark fraction</code> 命令时计算系统内存的大小，默认 <code>vm_memory_high_watermark</code> 为0.4，表示内存阈值为0.4，当RabbitMQ使用内存超过40%就会告警并阻塞。</p><p><strong>设置内存阈值</strong>：（不建议取值超过0.7）</p><ul><li><p>通过 <code>rabbitmq.config</code> 配置文件来配置：（需要重启服务器来启用）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">rabbit,</span> <span class="string">[</span></span><br><span class="line"><span class="string">&#123;vm_memory_high_watermark,</span> <span class="number">0.4</span><span class="string">&#125;</span></span><br><span class="line"><span class="comment"># 绝对值方式: &#123;vm_memory_high_watermark, &#123;absolute, 1073741824&#125;&#125; 也可以带单位&#123;absolute，"1024MiB"&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li><p>通过 rabbitmqctl 指令来配置：（服务器重启后会失效）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_vm_memory_high_watermark 0.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_vm_memory_high_watermark absolute &#123;memory_limit&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>当 Broker 节点达到内存阈值前会尝试将消息从内存换页到磁盘来释放空间</strong>（持久化和非持久化都会，持久化只须清除内存的副本即可），一般在内存阈值的50%会进行此操作。</p><p><strong>设置换页阈值</strong>：</p><ul><li><p>通过 <code>rabbitmq.config</code> 配置文件来配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">rabbit,</span> <span class="string">[</span></span><br><span class="line"><span class="string">&#123;vm_memory_high_watermark_paging_ratio,</span> <span class="number">0.75</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;vm_memory_high_watermark,</span> <span class="number">0.4</span><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-磁盘告警"><a href="#2-2-磁盘告警" class="headerlink" title="2.2 磁盘告警"></a>2.2 磁盘告警</h3><p>默认磁盘阈值为50MB，当磁盘空间低于这个值使会阻塞生产者并停止内存的换页操作。</p><p>RabbitMQ 会定期检测磁盘剩余空间，检测的频率与上一次执行检测到的磁盘剩余空间大小有关。正常情况下，每 10 秒执行一次检测，随着磁盘剩余空间与磁盘阈值的接近，检测频率会有所增加。当要到达磁盘阑值时，检测频率为每秒 10 次，这样有可能会增加系统的负载。</p><p><strong>设置磁盘阈值</strong>：（不建议取值超过0.7）</p><ul><li><p>通过 <code>rabbitmq.config</code> 配置文件来配置：（需要重启服务器来启用）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">rabbit,</span> <span class="string">[</span></span><br><span class="line"><span class="string">&#123;disk_free_limit,</span> <span class="number">1000000000</span><span class="string">&#125;</span></span><br><span class="line"><span class="comment"># &#123;disk_free_limit, "1GB"&#125; 或 &#123;disk_free_limit, &#123;mem_relative, 1.0&#125;&#125; 磁盘与内存大小的比值，建议1到2</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li><p>通过 rabbitmqctl 指令来配置：（服务器重启后会失效）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_disk_free_limit &#123;disk_limit&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_disk_free_limit mem_relative &#123;fraction&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第三节-流量控制"><a href="#第三节-流量控制" class="headerlink" title="第三节 流量控制"></a>第三节 流量控制</h2><p>RabbitMQ 从 2.8.0 版本引入流控（Flow Control）机制来保证稳定性。流控机制是用来避免消息的发送速率过快而导致服务器难以支撑的情形。</p><p><strong>内存及磁盘告警相当于全局的流控，一旦触发会阻塞集群中所有的连接；而流控则只针对单个连接。</strong></p><h3 id="3-1-流控的原理-信用证算法"><a href="#3-1-流控的原理-信用证算法" class="headerlink" title="3.1 流控的原理-信用证算法"></a>3.1 流控的原理-信用证算法</h3><p>Erlang 进程之间并不共享内存（binary 类型的除外），而是通过消息传递来通信，每个进程都有自己的进程邮箱（mailbox）。进程邮箱默认没有大小限制，所以大量消息发往某个进程会导致内存溢出并崩溃。对于RabbitMQ来说没有流控，很容易达到使邮箱大小达到内存阈值。</p><p>RabbitMQ 使用了一种<strong>基于信用证算法（credit-based algorithm）的流控机制来限制发送消息的速率</strong>以解决前面所提出的问题：它通过<strong>监控</strong>各个进程的进程邮箱，当某个进程负载过高而来不及处理消息时，这个进程的进程邮箱就会开始堆积消息。当堆积到一定量时，就会<strong>阻塞</strong>而不接收上游的新消息。从而慢慢地，上游进程的进程邮箱也会开始堆积消息。当堆积到一定量时也会阻塞而停止接收上游的消息，最后就会使负责网络数据包接收的进程阻塞而暂停接收新的数据。</p><h4 id="3-1-1-信用证算法说明"><a href="#3-1-1-信用证算法说明" class="headerlink" title="3.1.1 信用证算法说明"></a>3.1.1 信用证算法说明</h4><p>如图 9-4 ，进程A接收消息并转发至进程B，进程B接收消息并转发至进程C。<strong>每一个进程中都有一对关于收发消息的 credit 值</strong>。</p><p>以进程B为例：</p><ul><li><code>{ {credit_from, C}, value}</code> 表示能发送多少条消息给C，每发送一条消息该值减1，当为0时，进程B不再往进程C发送消息也不再接收进程A的消息。</li><li><code>{ {credit_to, A}, value}</code> 表示再接收多少条消息就向进程A发送增加 credit 值的通知，进程A接收到该通知后就增加 <code>{ {credit_from, B}, value}</code> 所对应的值，这样进程A就能持续发送消息。</li></ul><p>当上游发送速率高于下游接收速率时， credit 值就会被逐渐耗光，这时进程就会被阻塞，阻塞的情况会一直传递到最上游。当上游进程收到来自下游进程的增加 credit 值的通知时，若此时上游进程处于阻塞状态则解除阻塞，开始接收更上游进程的消息，一个一个传导最终能够解除最上游的阻塞状态。由此可知，基于信用证的流控机制最终将消息发送进程的发送速率限制在消息处理进程的处理能力范围之内。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010154.png" alt></p><p>可以通过 <code>rabbitmqctl list_connections</code> 命令或者Web管理界面来查看Connection的状态。</p><p>Connection触发流控时会处于flow状态，这个状态值并没有什么作用。</p><h4 id="3-1-2-流控链"><a href="#3-1-2-流控链" class="headerlink" title="3.1.2 流控链"></a>3.1.2 流控链</h4><p>流控机制不只是作用于 Connection ，同样作用于信道和队列。<strong>从Connection到Channel，再到队列，最后是消息持久化存储形成一个完整的流控链，对于处于整个流控链中的任意进程，只要该进程阻塞，上游的进程必定全部被阻塞</strong>。也就是说，如果某个进程达到性能瓶颈，必然会导致上游所有的进程被阻塞。所以我们可以利用流控机制的这个特点找出瓶颈之所在，处理消息的几个关键进程及其对应的顺序关系如图 9-6 所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010155.png" alt></p><ul><li>rabbit_reader：Connection 的处理进程，负责接收、解析 AMQP 协议数据包等。</li><li>rabbit_channel：Channel 的处理进程，负责处理 AMQP 协议的各种方法、进行路由解析等。</li><li>rabbit_amqqueue_process：队列的处理进程，负责实现队列的所有逻辑。</li><li>rabbit_msg_store：负责实现消息的持久化。</li></ul><h4 id="3-1-3-判断瓶颈情况"><a href="#3-1-3-判断瓶颈情况" class="headerlink" title="3.1.3 判断瓶颈情况"></a>3.1.3 判断瓶颈情况</h4><ul><li>当某个 Connection 处于flow状态，但此 Connection 中没有一个Channel处于flow状态，表示有一个或多个Channel出现了性能瓶颈。<ul><li>某些 Channel 进程的运作（比如处理路由逻辑）会使得服务器 CPU 负载过高从而导致了此种情形，尤其是在发送大量较小的非持久化消息时，此种情形最易显现。</li></ul></li><li>当某个 Connection 处于flow状态，且此 Connection 中有若干个Channel处于flow状态，但没有一个队列处于flow状态，表示有一个或多个队列出现了性能瓶颈。<ul><li>这可能是由于将消息存入队列的过程中引起服务器 CPU 负载过高，或者是将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较小的持久化消息时，此种情形最易显现。</li></ul></li><li>当某个 Connection 处于flow状态，且此 Connection 中有若干个Channel处于flow状态，且有若干个队列处于flow状态，表示在消息持久化时出现了性能瓶颈。<ul><li>在将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较大的持久化消息时，此种情形最易显现。</li></ul></li></ul><h3 id="3-2-案例：打破队列的瓶颈"><a href="#3-2-案例：打破队列的瓶颈" class="headerlink" title="3.2 案例：打破队列的瓶颈"></a>3.2 案例：打破队列的瓶颈</h3><p>通常会在rabbit_amqqueue_process即队列进程产生性能瓶颈，所以其上游的连接和信道会处于flow状态。</p><p>如何提高队列的性能？</p><ol><li>开启Erlang的HiPE功能，保守可以提升30%~40%的性能。</li><li>打破队列的瓶颈，指用多个rabbit_amqqueue_process来打破单个队列的性能上限，充分利用上游被流控的性能。</li></ol><p>如图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010156.png" alt></p><p>多个队列会导致应用复杂化，所以首先要<strong>封装</strong>，将交换器、队列、绑定关系、生成和消费的方法全部封装，使应用就像仍在操作一个队列。</p><p>封装实现步骤：</p><ol><li>声明交换器、队列、绑定关系：先与 Broker 建立连接，声明交换器一样，声明队列和绑定关系实际上是多个物理队列，先规划好分片数，分别声明对应数量的二者，如图 9-8。</li><li>封装生产者：</li><li>封装消费者：</li></ol><h4 id="（1）声明交换器、队列、绑定关系"><a href="#（1）声明交换器、队列、绑定关系" class="headerlink" title="（1）声明交换器、队列、绑定关系"></a>（1）声明交换器、队列、绑定关系</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010157.png" alt></p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * host，port，vhost，username，password值可以在rmq_cfg.properties 文件中配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmqEncapsulation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">5672</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String vhost = <span class="string">"/"</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username = <span class="string">"guest"</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"guest"</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> subdivisionNum;<span class="comment">//分片数，表示一个逻辑队列背后的实际队列数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RmqEncapsulation</span><span class="params">(<span class="keyword">int</span> subdivisionNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subdivisionNum = subdivisionNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建Connection</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(host);</span><br><span class="line">        connectionFactory.setVirtualHost(vhost);</span><br><span class="line">        connectionFactory.setPort(port);</span><br><span class="line">        connectionFactory.setUsername(username);</span><br><span class="line">        connectionFactory.setPassword(password);</span><br><span class="line">        connection = connectionFactory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Connection</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">            newConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭Connection</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明交换器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchangeDeclare</span><span class="params">(Channel channel, String exchange, String type, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        channel.exchangeDeclare(exchange, type, durable, autoDelete, autoDelete, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明队列，这里针对单个Broker设计，若集群有多个节点，需要让分片队列能均匀的散开到各个节点，达到负载均衡</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueDeclare</span><span class="params">(Channel channel, String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; subdivisionNum;i++) &#123;</span><br><span class="line">            String queueName = queue + <span class="string">"_"</span> + i;</span><br><span class="line">    channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建绑定关系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueBind</span><span class="params">(Channel channel, String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; subdivisionNum;i++) &#123;</span><br><span class="line">            String rkName = routingKey + <span class="string">"_"</span> + i;</span><br><span class="line">    channel.queueBind(queueName, exchange, rkName, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用封装工具来声明交换、队列和绑定关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RmqEncapsulation rmqEncapsulation = <span class="keyword">new</span> RmqEncapsulation(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       Connection connection = RmqEncapsulation.getConnection();</span><br><span class="line">       Channel channel = connection.createChannel();</span><br><span class="line">       rmqEncapsulation.exchangeDeclare(channel, <span class="string">"exchange"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">       rmqEncapsulation.queueDeclare(channel, <span class="string">"queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">       rmqEncapsulation.queueBind(channel, <span class="string">"queue"</span>, <span class="string">"exchange"</span>, <span class="string">"rk"</span>, <span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           RmqEncapsulation.closeConnection();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="（2）封装生产者"><a href="#（2）封装生产者" class="headerlink" title="（2）封装生产者"></a>（2）封装生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(Channel channel, String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, AMQP.BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">       <span class="comment">//随机挑选一个队列发送</span></span><br><span class="line">       Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">int</span> index = random.nextInt(subdivisionNum);</span><br><span class="line">       String rkName = routingKey + <span class="string">"_"</span> + index;</span><br><span class="line">       channel.basicPublish(exchange, rkName, mandatory, props, body); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用发送100条消息</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">       <span class="comment">// Message用来封装消息</span></span><br><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">       <span class="comment">// msgSeq表示消息的序号，有序</span></span><br><span class="line">message.setMsgSeq(i);</span><br><span class="line">       <span class="comment">// msgBody表示消息体，还有deliveryTag用于消息确认</span></span><br><span class="line">message.setMsgBody(<span class="string">"rabbitmq encapsulation"</span>);</span><br><span class="line">       <span class="comment">// 通过Serializable接口来实现序列化，实际使用建议用ProtoBuff这种性能高的序列化工具</span></span><br><span class="line">       <span class="comment">// 对象转换为字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] body = getBytesFromObject(message);</span><br><span class="line">rmqEncapsulation.basicPublish(channel, <span class="string">"exchange"</span>, <span class="string">"rk"</span>, <span class="keyword">false</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, body);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>封装4个物理队列与单个独立队列的QPS对比：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010158.png" alt></p><h4 id="（3）封装消费者"><a href="#（3）封装消费者" class="headerlink" title="（3）封装消费者"></a>（3）封装消费者</h4><p>消费分推模式和拉模式，拉模式的封装实现比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GetResponse <span class="title">basicGet</span><span class="params">(Channel channel, String queue, <span class="keyword">boolean</span> autoAck)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">       <span class="comment">// 首先随机拉取一个物理队列的数据</span></span><br><span class="line">       GetResponse getResponse = <span class="keyword">null</span>;</span><br><span class="line">       Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">int</span> index = random.nextInt(subdivisionNum);</span><br><span class="line">       getResponse = channel.basicGet(queue+<span class="string">"_"</span>+index, autoAck); </span><br><span class="line">       <span class="comment">// 若返回为空，再顺序拉取</span></span><br><span class="line">       <span class="keyword">if</span> (getResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; subdivisionNum;i++) &#123;</span><br><span class="line">               String queueName = queue + <span class="string">"_"</span> + i;</span><br><span class="line">               getResponse = channel.basicGet(queueName, autoAck); </span><br><span class="line">               <span class="keyword">if</span> (getResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> getResponse;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getResponse;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当生产者发送速度大于消费者消费速度时，顺序拉取可能只拉取到第一个物理队列的数据，而其余3个物理队列的数据可能会被长久积压。</p><p>推模式封装需要在 <code>RmqEncapsulation</code> 中添加一个 <code>ConcurrentLinkedDeque&lt;Message&gt;</code> 类型的成员变量 blockingQueue，用来缓存推送的数据以方便消费者消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmqEncapsulation</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> subdivisionNum;<span class="comment">//分片数，表示一个逻辑队列背后的实际队列数</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedDeque&lt;Message&gt; blockingQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RmqEncapsulation</span><span class="params">(<span class="keyword">int</span> subdivisionNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subdivisionNum = subdivisionNum;</span><br><span class="line">        blockingQueue = <span class="keyword">new</span> ConcurrentLinkedDeque&lt;Message&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//省略 newConnection 方法、 getConnection 方法、 closeConnect on 方法的实现</span></span><br><span class="line">    <span class="comment">//省略 exchangeDeclare 方法、 queue Declare 方法、 queueBind 方法的实现</span></span><br><span class="line">    <span class="comment">//省略 basicPublish 方法和 basicGet 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startConsume</span><span class="params">(Channel channel, String queue, <span class="keyword">boolean</span> autoAck, String consumerTag, ConcurrentLinkedDeque&lt;Message&gt; newblockingQueue)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; subdivisionNum;i++)&#123;</span><br><span class="line">String queueName = queue + <span class="string">"_"</span> + i;</span><br><span class="line">channel.basicConsume(queueName, autoAck, consumerTag + i, <span class="keyword">new</span> NewConsumer(channel, newblockingQueue));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicConsume</span><span class="params">(Channel channel, String queue, <span class="keyword">boolean</span> autoAck, String consumerTag, ConcurrentLinkedDeque&lt;Message&gt; newblockingQueue, IMsgCallback iMsgCallback)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">startConsume(channel, queue, autoAck, consumerTag, newblockingQueue);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">Message message = newblockingQueue.peekFirst();</span><br><span class="line"><span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// IMsgCallback包含一个回调函数consumeMsg(Message message)</span></span><br><span class="line">ConsumeStatus consumeStatus = iMsgCallback.consumeMsg(message);</span><br><span class="line"><span class="function">newblock ngQueue <span class="title">removeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(consumeStatus == ConsumeStatus.SUCCESS)</span> </span>&#123;</span><br><span class="line">channel.basicAck(message.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">channel.basicReject(message.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Broker中的数据然后存入blockingQueue中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedDeque&lt;Message&gt; newblockingQueue;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NewConsumer</span><span class="params">(Channel channel, ConcurrentLinkedDeque&lt;Message&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">newblockingQueue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(channel);</span><br><span class="line"><span class="keyword">this</span>.newblockingQueue = newblockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, </span></span></span><br><span class="line"><span class="function"><span class="params">AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">Message message = (Message) getObjectFromBytes(body);</span><br><span class="line">message.setDeliveryTag(envelope.getDeliveryTag());</span><br><span class="line">newblockingQueue.addLast(message);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace(); </span><br><span class="line">       &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推模式使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.basicQos(<span class="number">64</span>);</span><br><span class="line">rmqEncapsulation.basicConsume(channel, <span class="string">"queue"</span>, <span class="keyword">false</span>, <span class="string">"consumer_zzh"</span>, rmqEncapsulation.blockingQueue, <span class="keyword">new</span> IMsgCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConsumeStatus <span class="title">consumeMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">ConsumeStatus consumeStatus = ConsumeStatus.FAIL;</span><br><span class="line"><span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(message);</span><br><span class="line">consumeStatus = ConsumeStatus.SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">           <span class="keyword">return</span> consumeStatus; </span><br><span class="line">       &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>示例省去了很多的功能，局限性很强，比如没有使用 publisher confirm 机制；没有设置 mandatory mandory 参数；只能使用一个 Connection；消息没有使用 Protostuff 进行序列化等。</p><p>发送端根据 Message 的消息序号 msgSeq 对分片个数进行取模运算，之后将对应的消息发送到对应的队列中，这样消息可以均匀且顺序地在每个队列中存储。在消费端为每个队列创建一个消息槽（slot），从队列中读取的消息都存入对应的槽中，发送到下游的消息可以依次从slot0到slot3进行读取。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010159.png" alt></p><h2 id="第四节-镜像队列"><a href="#第四节-镜像队列" class="headerlink" title="第四节 镜像队列"></a>第四节 镜像队列</h2><p>如果RabbitMQ 集群中只有一个Broker节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的 durable 属性也设置为true ，但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗。通过 publisher confirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此， 一般不希望遇到因单点故障导致的服务不可用。</p><p>尽管交换器和绑定关系能够在单点故障问题上幸免于难，但是队列和其上的存储的消息却不行，这是因为队列进程及其内容仅仅维持在单个节点之上，所以一个节点的失效表现为其对应的队列不可用。</p><p>引入镜像队列（Mirror Queue）的机制，可以将队列镜像到集群中的其他Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。在通常的用法中，针对每一个配置镜像的队列（以下简称镜像队列〉都包含一个主节点(master ）和若干个从节点（ slave ），相应的结构可以参考图 9-11 ：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010160.png" alt></p><p>slave 会准确地按照 master 执行命令的顺序进行动作，故 slave 与 master 上维护的状态应该是相同的。如果 master 由于某种原因失效，那么“资历最老”的 slave 会被提升为新的 master 。根据 slave 加入的时间排序，时间最长的 slave 即为“资历最老”。发送到镜像队列的所有消息会被同时发往 master 和所有的 slave 上，如果此时 master 挂掉了，消息还会在 slave 上，这样 slave 提升为 master 的时候消息也不会丢失。除发送消息（Basic.Publish）外的所有动作都只会向 master 发送，然后再由 master 将命令执行的结果广播给各个 slave 。</p><p>如果消费者与slave 建立连接井进行订阅消费，其实质上都是从master 上获取消息，只不过看似是从slave 上消费而己。比如消费者与slave 建立了TCP 连接之后执行一个Basic.Get的操作，那么首先是由slave 将Basic.Get 请求发往master ，再由master 准备好数据返回给slave ，最后由slave 投递给消费者。</p><p>大多的读写压力都落到了master 上，那么这样是否负载会做不到有效的均衡？或者说是否可以像MySQL 一样能够实现master 写而slave 读呢？注意这里master 和slave 是针对队列而言的，而队列可以均匀地散落在集群的各个Broker 节点中以达到负载均衡的目的，因为真正的负载还是针对实际的物理机器而言的，而不是内存中驻留的队列进程。</p><p>在图 9-12 中， 集群中的每个Broker 节点都包含1 个队列的master 和2 个队列的slave, Q1的负载大多都集中在broker1 上， Q2 的负载大多都集中在broker2 上， Q3 的负载大多都集中在broker3 上，只要确保队列的master 节点均匀散落在集群中的各个Broker 节点即可确保很大程度上的负载均衡（每个队列的流量会有不同，因此均匀散落各个队列的master 也无法确保绝对的负载均衡）。至于为什么不像MySQL 一样读写分离， RabbitMQ 从编程逻辑上来说完全可以实现，但是这样得不到更好的收益，即读写分离并不能进一步优化负载，却会增加编码实现的复杂度，增加出错的可能，显得得不偿失。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010161.png" alt></p><p>RabbitMQ 的镜像队列同时支持publisher confirm 和事务两种机制．在事务机制中，只有当前事务在全部镜像中执行之后，客户端才会收到Tx.Commit-Ok 的消息。同样的，在publisherconfirm 机制中， 生产者进行当前消息确认的前提是该消息被全部进行所接收了。</p><p>不同于普通的非镜像队列（参考图9-2 ），镜像队列的backing_queue 比较特殊，其实现并非是rabbit_variable_queue ，它内部包裹了普通backing_queue 进行本地消息消息持久化处理，在此基础上增加了将消息和ack 复制到所有镜像的功能。镜像队列的结构可以参考图9-13, master 的backing_queue 采用的是rabbit_mirror_queue_master ，而slave的backing queue 实现是rabbit_mirror_queue_slave。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010162.png" alt></p><p>所有对 rabbit_mirror_queue_master 的操作都会通过组播GM (Guaranteed Multicast) 的方式同步到各个slave 中。GM 负责消息的广播， rabbit_mirror_queue_slave 负责回调处理，而master 上的回调处理是由coordinator 负责完成的。如前所述，除了 Basic.Publish ，所有的操作都是通过master 来完成的， master 对消息进行处理的同时将消息的处理通过GM 广播给所有的slave , s lave 的GM 收到消息后，通过回调交由 rabbit_mirror queue_slave 进行实际的处理。</p><p>GM 模块实现的是一种可靠的组播通信协议， 该协议能够保证组播消息的原子性，即保证组中活着的节点要么都收到消息要么都收不到，它的实现大致为：将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上：当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。在master 和slave 上的这些GM 形成一个组（gm_group），这个组的信息会记录在Mnesia 中。不同的镜像队列形成不同的组。操作命令从master 对应的GM 发出后，顺着链表传送到所有的节点。由于所有节点组成了一个循环链表， master 对应的GM 最终会收到自己发送的操作命令，这个时候master 就知道该操作命令都同步到了所有的slave 上。</p><p>新节点的加入过程可以参考图9-14 ，整个过程就像在链表中间插入一个节点。注意每当一个节点加入或者重新加入到这个镜像链路中时，之前队列保存的内容会被全部清空。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010163.png" alt></p><p>当slave 挂掉之后，除了与slave 相连的客户端连接全部断开，没有其他影响。当master 挂掉之后，会有以下连锁反应：</p><ol><li>与master 连接的客户端连接全部断开。</li><li>选举最老的slave 作为新的master ，因为最老的s lave 与旧的master 之间的同步状态应该是最好的。如果此时所有slave 处于未同步状态，则未同步的消息会丢失。</li><li>新的master 重新入队所有unack 的消息，因为新的slave 无法区分这些unack 的消息是否己经到达客户端，或者是ack 信息丢失在老的master 链路上，再或者是丢失在老的master 组播ack 消息到所有slave 的链路上，所以出于消息可靠性的考虑，重新入队所有unack 的消息，不过此时客户端可能会有重复消息。</li><li>如果客户端连接着slave ，并且Basic.Consume 消费时指定了x-cancel-on-ha-failover 参数，那么断开之时客户端会收到一个Consumer Cancellation Notification 的通知，消费者客户端中会回调Consumer 接口 handleCancel 方法。如果未指定 x-cancel-on-ha-failover 参数，那么消费者将无法感知master 岩机。</li></ol><p>x-cancel-on-ha-failover 参数的使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Channel channel= ... ;</span><br><span class="line">Consumer consumer= ... ;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap &lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-cancel-on-ha-failover"</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.basicConsume (<span class="string">"my-queue"</span>, <span class="keyword">false</span>, args, consumer);</span><br></pre></td></tr></table></figure><p>镜像队列的配置主要是通过添加相应的Policy 来完成的，<code>rabbitmqctl set_policy [-p vhost] [--priority priority] [ --apply-to apply-to] {name} {pattern} {definition}</code> 命令中的 definition 部分，对于镜像队列的配置来说， definition 中需要包含3个部分： ha-mode 、ha-params 和ha-sync-mode ：</p><ul><li>ha-mode ： 指明镜像队列的模式，有效值为all 、exactly 、nodes ，默认为all 。<ul><li>all 表示在集群中所有的节点上进行镜像；</li><li>exactly 表示在指定个数的节点上进行镜像，节点个数由ha-params 指定；</li><li>nodes 表示在指定节点上进行镜像，节点名称通过ha-params 指定，节点的名称通常类似于rabbit@hostname ，可以通过 <code>rabbitmqctl cluster_status</code> 命令查看到。</li></ul></li><li>ha-params ： 不同的ha-mode 配置中需要用到的参数。</li><li>ha-sync-mode ： 队列中消息的同步方式，有效值为automatic 和manual。</li></ul><p>ha-mode 参数对排他（exclusive）队列并不生效，因为排他队列是连接独占的，当连接断开时队列会自动删除，所以实际上这个参数对排他队列没有任何意义。</p><p>将新节点加入己存在的镜像队列时，默认情况下ha-sync-mode 取值为manual ，镜像队列中的消息不会主动同步到新的s lav e 中，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行其他操作，直到同步完成。当ha-sync-mode 设置为automatic 时，新加入的slave 会默认同步己知的镜像队列。由于同步过程的限制，所以不建议对生产环境中正在使用的队列进行操作。使用<code>rabbitrnqctl list_queues {name} slave_pids synchronised_slave_pids</code> 命令可以查看哪些slaves 已经完成同步。通过手动方式同步一个队列的命令为 <code>rabbitrnqctl sync queue {name}</code> ，同样也可以取消某个队列的同步操作：<code>rabbitrnqctl cancel sync queue {name}</code> 。</p><p>当所有slave 都出现未同步状态，并且ha-promote-on-shutdown 设置为when-synced（默认）时，如果master 因为主动原因停掉，比如通过rabbitrnqctl stop 命令或者优雅关闭操作系统，那么slave 不会接管master ，也就是此时镜像队列不可用；但是如果master 因为被动原因停掉，比如Erlang 虚拟机或者操作系统崩溃，那么slave 会接管master 。这个配置项隐含的价值取向是保证消息可靠不丢失，同时放弃了可用性。如果ha-promote-on-shutdown 设置为always ，那么不论master 因为何种原因停止， slave 都会接管master ，优先保证可用性，不过消息可能会丢失。</p><p>镜像队列中最后一个停止的节点会是master ，启动顺序必须是master 先启动。如果slave先启动，它会有30 秒的等待时间，等待master 的启动，然后加入到集群中。如果30 秒内master没有启动， slave 会自动停止。当所有节点因故（断电等）同时离线时，每个节点都认为自己不是最后一个停止的节点，要恢复镜像队列，可以尝试在30 秒内启动所有节点。</p><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第八章《高阶》，内容来自于《RabbitMQ实战指南》，内容：存储机制，内存及磁盘告警，流量控制，镜像队列等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（七）Federation与Shovel</title>
    <link href="http://linyishui.top/2020101001.html"/>
    <id>http://linyishui.top/2020101001.html</id>
    <published>2020-10-10T08:26:47.000Z</published>
    <updated>2020-10-13T03:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（七）集群"><a href="#RabbitMQ（七）集群" class="headerlink" title="RabbitMQ（七）集群"></a>RabbitMQ（七）集群</h1><h2 id="第一节-Federation"><a href="#第一节-Federation" class="headerlink" title="第一节 Federation"></a>第一节 Federation</h2><p>Federation 插件的设计目标是<strong>使 RabbitMQ 在不同的 Broker 节点之间进行消息传递而无须建立集群</strong>。</p><p>适用场景下：</p><ul><li>Federation 插件能够在不同管理域（可能设置了不同的用户和 vhost ，也可能运行在不同版本的 RabbitMQ Erlang 上）中的 Broker 或者集群之间传递消息。</li><li>Federation 插件基于 AMQP 0-9-1 协议在不同的 Broker 之间进行通信，并设计成能够容忍不稳定的网络连接情况。</li><li>一个 Broker 节点中可以同时存在联邦交换器（或队列）或者本地交换器（或队列），只需要对特定的交换器（或队列）创建 Federation 连接（Federation link ）</li><li>Federation 需要在 Broker 节点之间创建 O(N^2^）个连接（尽管这是最简单的使用方式），这也就意味着 Federation 在使用时更容易扩展。</li></ul><p>Federation 插件可以让多个交换器或者多个队列进行<strong>联邦</strong>。一个联邦交换器（federated exchange）或者一个联邦队列（federated queue）接收上游（upstream）的消息，这里的<strong>上游是指位于其他 Broker 上的交换器或者队列</strong>。</p><ul><li><strong>联邦交换器能够将原本发送给上游交换器（upstream exchange）的消息路由到本地的某个队列中</strong>；</li><li><strong>联邦队列则允许一个本地消费者接收到来自上游队列（upstream queue）的消息</strong>。</li></ul><h3 id="1-1-联邦交换器"><a href="#1-1-联邦交换器" class="headerlink" title="1.1 联邦交换器"></a>1.1 联邦交换器</h3><h4 id="1-1-1-案例：Federation优化服务器通信网络延迟问题"><a href="#1-1-1-案例：Federation优化服务器通信网络延迟问题" class="headerlink" title="1.1.1 案例：Federation优化服务器通信网络延迟问题"></a>1.1.1 案例：Federation优化服务器通信网络延迟问题</h4><p>例如有如下集群：broker1部署于北京，broker2部署于上海，broker3部署于广州，因为物理距离的问题，所以要考虑网络延迟问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010129.png" alt></p><p>有一个广州的业务ClientA需要连接 broker3 ，并向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，<strong>ClientA 可以迅速将消息发送至 exchangeA 中</strong>，就算在开启了 publisher confirm 机制或者事务机制的情况下，也可以迅速收到确认信息。</p><p>此时又有一个在北京的业务 ClientB 需要向 exchangeA 发送消息，那么 <strong>ClientB 与 broker3 之间有很大的网络延迟</strong>， ClientB 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisher confirm 机制或者事务机制的情况下， ClientB 会等待很长的延迟时间来接收 broker3 的确认信息，进而必然造成这条 发送线程的性能降低，甚至造成一定程度上的阻塞。</p><p>那么要<strong>怎么优化业务 ClientB </strong>呢？将业务 ClientB 部署到广州的机房中可以解决这个问题，但是如果 ClientB 调用的另一些服务都部署在北京，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？这里<strong>使用 Federation 插件就可以很好地解决这个问题</strong>。</p><p>如图 8-2 所示，在广州的 broker3 中为交换器 exchangeA（broker3 中的队列 queueA 通过 <code>rkA</code> 与 exchangeA 进行了绑定）与北京的 broker1 之间建立一条单向的 Federation link ：</p><ul><li>此时 Federation 插件会在 broker1 上建立一个同名的交换器 exchangeA（这个名称可以配置，默认同名），</li><li>同时建立一个内部的交换器 <code>exchangeA-&gt;broker3 B</code> ，并通过路由键 <code>rkA</code> 将这两个交换器绑定起来。</li><li>这个交换器 <code>exchangeA-&gt;broker3 B</code> 名字中的 <code>broker3</code> 是集群名，可以通过 <code>rabbitmqctl set_cluster_name {new name}</code> 命令进行修改。</li><li>与此同时 Federation 插件还会在 broker1 上建立一个队列 <code>federation: exchangeA-&gt;broker3 B</code> 并与交换器 <code>exchangeA-&gt;broker3 B</code> 进行绑定。 </li><li>Federation 插件会在队列 <code>federation: exchangeA-&gt;broker3 B</code> 与 broker3 中的交换器 exchangeA 之间建立一条 AMQP 连接来实时地消费队列 <code>federation: exchangeA-&gt;broker3 B</code> 中的数据。</li><li>这些操作都是内部的，对外部业务客户端来说这条 Federation link 建立在 broker1 的 exchangeA 和broker3 的 exchangeA 之间。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010130.png" alt></p><p>因此部署在北京的业务 ClientB 可以连接 broker1（北京）并向 exchangeA 发送消息，这样 ClientB 可以迅速发送完消息并收到确认信息，而之后消息通过 Federation link 转发到 broker3（广州）的交换器 exchangeA 中。最终消息会存入与 exchangeA 绑定的队列 queueA 中，消费者最终可以消费队列 queueA 中的消息。</p><p>经过 Federation link 转发的消息会带有特殊的 headers 性标记。例如向 broker1 中的交换器 exchangeA 发送一条内容为“federation test payload ”的持久化消息，之后可以在 broker3 中的队列 queueA 消费到这条消息：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010131.png" alt></p><h4 id="1-1-2-联邦交换器和普通无明显差异"><a href="#1-1-2-联邦交换器和普通无明显差异" class="headerlink" title="1.1.2 联邦交换器和普通无明显差异"></a>1.1.2 联邦交换器和普通无明显差异</h4><p>Federation 不仅便利于消息生产方，同样也便利于消息消费方。假设某生产者将消息存入 broker1 中的某个队列 queueB，在广州的业务 ClientC 想要消费 queueB 消息，消息的流转及确认必然要忍受较大的网络延迟，内部编码逻辑也会因这一因素变得更加复杂，这样不利于 ClientC 的发展。</p><p>不如将这个消息转发的过程以及内部复杂的编程逻辑交给 Federation 去完成， 而业务方在编码时不必再考虑网络延迟的问题。 Federation 使得生产者和消费者可以异地部署而又让这两方感受不到过多的差异（类似RPC的特性？）。</p><p>上个案例的队列 <code>federation: exchangeA-&gt;broker3 B</code> 是一个相对普通的队列，可以直接通过客户端进行消费。假设此时还有一个客户端 ClientD 通过 <code>Basic.Consume</code> 来消费队列 <code>federation: exchangeA-&gt;broker3 B</code> 的消息，会导致发往 broker1 的 exchangeA 中的消息会有一半被 ClientD 消费掉，另一半会发往 broker3 的 exchangeA 。<strong>如果业务方要求所有发往 broker1 的 exchangeA 中的消息都要转发到 broker3 的 exchangeA 中，要注意不要使队列 <code>federation: exchangeA-&gt;broker3 B</code> 有其他消费者</strong>。</p><p>但也可以注意到，队列 <code>federation: exchangeA-&gt;broker3 B</code> 本身就是普通的队列，天然支持“异地均摊消费”类似的需求。一个 federated exchange 同样可以成为另一个交换器的 upstream exchange 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010132.png" alt></p><p>两方的交换器可以互为 federated exchange 和 upstream exchange 其中 <code>max_hops=1</code> 表示一条消息最多被转发的次数为1。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010133.png" alt></p><p>注意：<strong>对于默认的交换器（每个 vhost 下都会默认创建一个名为“”的交换 器）和内部交换器而言，不能对其使用 Federation 功能</strong>。</p><h4 id="1-1-3-联邦交换器组成复杂的拓扑逻辑部署方式"><a href="#1-1-3-联邦交换器组成复杂的拓扑逻辑部署方式" class="headerlink" title="1.1.3 联邦交换器组成复杂的拓扑逻辑部署方式"></a>1.1.3 联邦交换器组成复杂的拓扑逻辑部署方式</h4><p>“fan-out”的多叉树形式：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010134.png" alt></p><p>“三足鼎立”形式：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010135.png" alt></p><p>环形的拓扑部署：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010136.png" alt></p><h3 id="1-2-联邦队列"><a href="#1-2-联邦队列" class="headerlink" title="1.2 联邦队列"></a>1.2 联邦队列</h3><p>联邦队列（federated queue）：可以在多个 Broker 节点（或者集群）之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列（upstream queue），并从这些上游队列中获取消息以满足本地消费者消费消息的需求。</p><p>图 8-9 演示了两个Broker中的联邦队列（灰色）和非联邦队列（白色）部署：queue1 和 queue2 位于 broker2，配置为联邦队列并设置 broker1 为上游， Federation 插件会在 broker1 创建两个同名队列，并且分别和 broker2 的队列建立单向独立的 Federation link 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010137.png" alt></p><p>当有消费者 ClientA 连接 broker2 并通过 <code>Basic.Consume</code> 消费队列 queue1 （或 queue2 ）中的消息时：</p><ul><li>如果此时队列已有消息堆积就可以直接被消费，且 broker2 的队列不会拉取 broker1 的队列中的消息；</li><li>如果此时队列没有消息，会通过 Federation link 拉取在 broker1 的上游队列中的消息，然后存储到本地，再被 ClientA 消费。</li></ul><p><strong>既可以消费联邦队列，又可以消费上游队列，这种分布式队列的部署可以提高单个队列的容量</strong>。如果上游一端部署的消费者来不及消费上游队列的消息，下游的消费者可以帮其分担消费，有一定的负载均衡的效果。</p><p><strong>与联邦交换器不同的是，一条消息可以在联邦队列间转发无限次</strong>，因为队列可以互为联邦队列：消息会转向有多余消费能力的一方，所以可能会导致消费在队列间来回转发。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010138.png" alt></p><p>如下图，broker2 的队列 queue 没有消息堆积或者消息被消费完之后并不能通过 <code>Basic.Get</code> 来获取 broker1 中队列 queue 消息。因为 <code>Basic.Get</code> 是一个异步的方法，如果要从 broker1 中队列 queue 拉取消息，必须要阻塞等待通过 Federation link 拉取消息存入 broker2 中的队列 queue 之后再消费消息，所以<strong>对于 federated queue 而言只能使用 <code>Basic.Consume</code> 进行消费</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010139.png" alt></p><p><strong>联邦队列不具备传递性</strong>：队列 queue2 作为联邦队列与 queue1 进行联邦，而队列 queue2 又作为队列 queue3 的上游队列，但是这样队列 queue1 和 queue3 之间并没有产生任何联邦的关系。如果队列 queue1 有消息堆积，消费者连接 broker3 消费 queue3 中的消息，无论 queue3 处于何种状态，这些消费者都消费不到 queue1 中的消息， 除非 queue2 有消费者。</p><h3 id="1-3-Federation的使用"><a href="#1-3-Federation的使用" class="headerlink" title="1.3 Federation的使用"></a>1.3 Federation的使用</h3><p>使用Federation前要配置两个内容：</p><ul><li>需要配置一个或多个 upstream，每个 upstream 均定义了到其他节点的 Federation link。这个配置可以通过设置运行时的参数（Runtime Parameter）来完成，也可以通过 federation management 插件来完成。</li><li>需要定义匹配交换器或者队列的一种/多种策略（Policy）。</li></ul><h4 id="1-3-1-启用Federation"><a href="#1-3-1-启用Federation" class="headerlink" title="1.3.1 启用Federation"></a>1.3.1 启用Federation</h4><p>开启Federation功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation </span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>开启Federation的管理插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation_management</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>开启后在RabbitMQ的管理界面中【Admin】右侧会多出两个Tab页：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010140.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010150.png" alt></p><p>注意：<strong>当需要在集群中使用 Federation 功能的时候，集群中所有的节点都应该开启 Federation 插件</strong>。</p><h4 id="1-3-2-相关配置和工具"><a href="#1-3-2-相关配置和工具" class="headerlink" title="1.3.2 相关配置和工具"></a>1.3.2 相关配置和工具</h4><p>有关 Federation upstream 信息全部都保存在 RabbitMQ 的 Mnesia 数据库中，包括用户信息、权限信息、队列信息等。</p><p>在Federation中有三种级别的配置：</p><ul><li>Upstreams：每个 upstream 用于定义与其他 Broker 建立连接的信息。 属于运行时参数。</li><li>Upstream sets：每个 upstream set 用于对一系列使用 Federation 功能的 upstream 行分组。 实际的简单使用场景可忽略，所有upstreambuild添加到一个名叫 <code>all</code> 且隐式定义的 upstream set 中。</li><li>Policies：每一个 Policy 会选定出一组交换器，或者队列，亦或者两者皆有而进行限定，进而作用于一个单独的 upsteam 或者 upstream set 之上。</li></ul><p>Federation 相关的运行时参数和策略都可以通过3种方式进行设置：</p><ul><li>通过 rabbitmqctl 工具；</li><li>通过 RabbitMQ Management 插件提供的 HTTP API 接口；</li><li>通过 rabbitmq federation management 插件提供的 Web 管理界面的方式（最方便且通用）。不过基于 Web 管理界面的方式不能提供全部功能，比如无法针对 upstream set 进行管理。</li></ul><h4 id="1-3-3-使用流程"><a href="#1-3-3-使用流程" class="headerlink" title="1.3.3 使用流程"></a>1.3.3 使用流程</h4><p>以图 8-2 中broker1和broker3为例描述<strong>如何建立联邦交换器</strong>：</p><ul><li><p>第一步，在 broker1 和 broker3 中开启 <code>rabbitmq_federation</code> 插件，最好同时开启 <code>rabbitmq_federation_management</code> 插件。</p></li><li><p>第二步，在 broker3 中定义一个 upstream，有三种设置方式：</p><ul><li><p>第一种是通过 rabbitmqctl 工具的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter federation-upstream f1</span></span><br><span class="line">uri '&#123;"uri":"amqp://root:root123 192.168.0.2:5672","ack-mode":"on-confirm"&#125;'</span><br></pre></td></tr></table></figure></li><li><p>第二种是通过调用 HTTP API 接口的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XPUT -d</span></span><br><span class="line">'&#123;"value":&#123;"uri":"amqp://root:root123 192.168.0.2:5672","ack-mode":"on-confirm"&#125;&#125;' </span><br><span class="line">http://192.168.0.4:15672/api/parameters/federation-upstream/%2f/f1</span><br></pre></td></tr></table></figure></li><li><p>第三种是通过在Web管理界面中添加的方式，【Admin】-&gt;【Federation Upstreams】-&gt;【Add a new upstream】，各个参数的含义：</p><ul><li><p>Name ：定义这个 upstream 的名称，必填项。</p></li><li><p>URI (uri）：定义 upstream 的 AMQP 连接，必填项。本示例中可以填写为 <code>amqp://root:root123 192.168.0.2:5672</code> 。</p></li><li><p>Prefetch count（prefetch count）：定义 Federation 内部缓存的消息条数，即在收到上游消息之后且在发送到下游之前缓存的消息条数。 </p></li><li><p>Reconnect delay（reconnect-delay）: Federation link 由于某种原因断开之后， 需要等待多少秒开始重新建立连接。 </p></li><li><p>Acknowledgement Mode（ack-mode）：定义 Federation link 的消息确认方式。共有3种： </p><ul><li>on-confirm：默认为 on-confirm，表示在接收到下游的确认消息（等待下游的 Basic.Ack ）之后再向上游发送消息确认，这个选项 可以确保网络失败或者 Broker 密机时不会丢失消息，但也是处理速度最慢的选项。</li><li>on-publish：表示消息发送到下游后（并需要等待下游的 <code>Basic.Ack</code> ) 再向上游发送消息确认，这个选项可以确保在网络失败的情况下不会丢失消息，但不能确保 Broker 岩机时不会丢失消息。</li><li>no-acko：表示无须进行消息确认，这个选项处理速度最快，但也最容易丢失消息。  </li></ul></li><li><p>Trust User-ID（trust-user-id）：设定 Federation 是否使用 <code>Validated User-ID</code> 这个功能。如果设置为 false 或者没有设置，那么 Federation 会忽略消息的 user_id 这个属性；如果设置为 true ，则 Federation 只会转发 user_id 为上游任意有效的用户的消息。</p></li><li><p>所谓的 <code>Validated User-ID</code> 功能是指发送消息时验证消息的 user_id 的属性。<code>channel.basicPublish</code> 方法中有个参数是 <code>BasicProperties</code> 有一个属性 user_id ：</p><ul><li><p>设置 user_id 属性为 root ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties();</span><br><span class="line">properties.setUserid(<span class="string">"root"</span>);</span><br><span class="line">channel.basicPublish(<span class="string">"amq.fanout"</span>,<span class="string">""</span>, properties,<span class="string">"test user id"</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>如果在连接 Broker 时所用的用户名为 root，当发送 test user id 这条消息时设置的 user_id 的属性为 guest ，那么这条消息会发送失败，具体报错为 <code>406 PRECONDITION_FAILED - user_id property set to &#39;guest&#39; but authenticated user was &#39;root&#39;</code> ，只有当 user_id 设置为 root 时，这条消息才会发送成功。</p></li></ul></li></ul></li></ul></li><li><p>第三步，定义一个 Policy 用于匹配交换器 exchangeA ，并使用第二步中所创建的 upstream ，有三种设置方式：</p><ul><li><p>第一种是通过 rabbitmqctl 工具的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义所有以exchange开头的交换器作为 federated exchange</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy --apply-to exchanges p1 <span class="string">"^exchange"</span> <span class="string">'&#123;"federation upstream":"f1"&#125;'</span></span></span><br></pre></td></tr></table></figure></li><li><p>第二种是通过调用 HTTP API 接口的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XPUT -d <span class="string">'&#123;"pattern":"^exchange","definition":&#123;"federation-upstream":"f1"&#125;,"apply-to":"exchanges"&#125;'</span> </span></span><br><span class="line">http://192.168.0.4:15672/api/policies/%2F/p1</span><br></pre></td></tr></table></figure></li><li><p>第三种是通过在Web管理界面中添加的方式，【Admin】-&gt;【Federation Upstreams】-&gt;【Add/Update a policy】，创建一个 Federation link ，可以 Web 管理界面中【Admin】-&gt;【Federation Status】-&gt;【Running Links 】查看到相应的链接（或者通过指令 <code>rabbitmqctl eval &#39;rabbit federation_status:status().</code> 查看相应的 Federation link）。</p></li></ul></li></ul><p><strong>如何建立联邦队列</strong>：</p><ul><li><p>首先同样也是定义一个 upstream 。</p></li><li><p>之后定义 Policy 的时候略微有变化，比如使用 rabbitmqctl 工具的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义所有以exchange开头的交换器作为 federated queue</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy --apply-to queues p2 <span class="string">"^queue"</span> <span class="string">'&#123;"federation upstream":"f1"&#125;'</span></span></span><br></pre></td></tr></table></figure></li><li><p>通常情况下，针对每个 upstream 会有一条 Federation link。此Federation link 对应到一个交换器上。例如， 3个交换器与2个upstream分别建立 Federation link 的情况下 ，会有6条连接。</p></li></ul><p>只适用联邦交换器的参数：</p><ul><li>Exchange (exchange）：指定 upstream exchange 的名称，默认情况下和 federated exchange 同名，即图 8-2 中的 exchangeA 。</li><li>Max hops (max-hops）：指定消息被丢弃前在 Federation link 中最大的跳转次数，默认为1。注意即使设置 <code>max-hops</code> 参数为大于1的值，同一条消息也不会在同一个 Broker 中出现2次，但是有可能会在多个节点中被复制。 </li><li>Expires (expires）：指定 Federation link 断开之后，federated queue 所对应的 upstream queue（即图 8-2 中的队列 <code>federation: exchangeA-&gt;broker3</code> ）的超时时间，默认为 none，表示为不删除，单位为 ms 。这个参数相当于设置普通队列的 <code>x-expires</code> 参数。设置这个值可以避免 Federation link 断开之后，生产者一直在向 broker1 中的 exchangeA 发送消息，这些消息又不能被转发到 broker3 中而被消费掉，进而造成 broker1 中有大量的消息堆积。</li><li>Message TTL (message-ttl）：为 federated queue 所对应的 upstream  queue （即 8-2 中的队列 <code>federation: exchangeA-&gt;broker3</code> ）设置，相当于普通队列的 <code>x-message-ttl</code> 参数，默认为 none 。表示消息没有超时时间。 </li><li>HA policy (ha-policy）：为 federated queue 所对应的 upstream queue （即 8-2 中的队列 <code>federation: exchangeA-&gt;broker3</code> ）设置，相当于普通队列的 <code>x-ha-policy</code> 参数，默认为 none，表示队列没有任何 HA。</li></ul><p>只适用联邦队列的参数：</p><ul><li>Queue (queue）：执行 upstream queue 的名称，默认情况下和 federated queue 同名。</li></ul><h2 id="第二节-Shovel"><a href="#第二节-Shovel" class="headerlink" title="第二节 Shovel"></a>第二节 Shovel</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>与 Federation 具备的数据转发功能类似， <strong>Shovel 能够可靠、持续地从一个 Broker 中的队列拉取数据并转发至另一个 Broker 中的交换器</strong>。 </p><p><strong>作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker ，也可以位于不同的 Broker 上</strong>。</p><p>Shovel 可以翻译为“铲子”，是一种比较形象的比喻，这个“铲子”可以将消息从一方“挖到”另一方。 Shovel 的行为就像优秀的客户端应用程序，能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><h4 id="2-1-1-优势"><a href="#2-1-1-优势" class="headerlink" title="2.1.1 优势"></a>2.1.1 优势</h4><p>Shovel 的主要优势在于：</p><ul><li><strong>松耦合</strong>： Shovel 可以移动位于不同管理域中的 Broker（或者集群）上的消息，这些 Broker（或者集群）可以包含不同的用户和 vhost ，也可以使用不同的 RabbitMQ Erlang 版本。 </li><li><strong>支持广域网</strong>：Shovel 插件同样基于 AMQP 协议在 Broker 之间进行通信，被设计成可以容忍时断时续的连通情形，并且能够保证消息的可靠性。</li><li><strong>高度定制</strong>：当 Shovel 成功连接后，可以对其进行配置以执行相关的 AMQP 命令。</li></ul><h3 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h3><p>Shovel 的结构示意图：两个Broker，broker1 中有交换器 exchange1 和队列 queue1 ，且这两者通过路由键 <code>rk1</code> 进行绑定；broker2 中有交换器 exchange2 和队列 queue2 ，且这两者通过路由键 <code>rk2</code> 进行绑定。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010143.png" alt></p><p>在队列 queue1 和交换器 exchange2 之间配置一个 Shovel link，当一条内容为  <code>shovel test payload</code> 的消息从客户端发送至交换器 exchange1 的时候，这条消息会经过图 8-15 中的数据流转最后存储在队列 queue2 中。</p><p>如果在配置 Shovel link 时设置了 <code>add_forward_headers</code> 参数为 true ，则在消费到队列 queue2 中这条消息的时候会有特殊的 headers 属性标记，详细内容可参考图 8-16 ：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010144.png" alt></p><p>通常情况下，使用 Shovel 时配置队列作为源端，交换器作为目的端，但同样可以<strong>将队列配置为目的端</strong>：（虽然看起来像队列queue1直接通过 Shovel link 将消息转发给queue2，但其实还经过了broker2的默认交换器转发）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010145.png" alt></p><p><strong>配置交换器为源端</strong>也可以，虽然看起来像交换器 exchange1 直接通过 Shovel link 将消息转发给 exchange2 ，但其实broker1会创建一个队列并绑定 exchange1 ，消息从 exchange1 过来后先存储在这个队列，然后Shovel再从这个队列中拉取消息并转发到exchange2。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010146.png" alt></p><p>Shovel 可以为源端或者目的端配置多个 Broker 的地址，这样可以使得源端或者目的端的 Broker 失效后能够尝试重连到其他 Broker 之上（随机挑选）。</p><p>可以设置 <code>reconnect_delay</code> 参数以避免由于重连行为导致的网络泛洪， 或者可以在重连失败后直接停止连接。针对源端和目的端的所有配置声明会在重连成功之后被重新发送。</p><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><p>开启Shovel：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel</span></span><br></pre></td></tr></table></figure><p>开启Shovel管理插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel_management</span></span><br></pre></td></tr></table></figure><p>在 RabbitMQ 的管理界面中【Admin】的右侧会多出【Shovel Status 】和【Shovel Management】两个 Tab 页：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010147.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010151.png" alt></p><p>Shovel 既可以部署在源端，也可以部署在目的端。</p><p>有两种方式可以部署 Shovel：</p><ul><li><strong>静态方式</strong>（static）：指在 <code>rabbitmq.config</code> 配置文件中设置。</li><li><strong>动态方式</strong>（dynamic）：指通过 <code>Runtime Parameter</code> 设置。</li></ul><h4 id="2-3-1-静态方式"><a href="#2-3-1-静态方式" class="headerlink" title="2.3.1 静态方式"></a>2.3.1 静态方式</h4><p>在 <code>rabbitmq.config</code> 配置文件中针对 Shovel 插件的配置信息是一种 Erlang 项式，由单条 Shovel 条目构成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;rabbitmq_shovel,</span> <span class="string">[</span> <span class="string">&#123;shovels,</span> <span class="string">[</span> <span class="string">&#123;shovel_name,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;,</span> <span class="string">...</span> <span class="string">]&#125;</span> <span class="string">]&#125;</span></span><br></pre></td></tr></table></figure><p>每一条 Shovel 条目定义了源端与目的端的转发关系，其名称（Shovel name）必须是独一无二的：（其中 sources、destination 和 queue 三项是必需的，其余的都可以默认）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;shovel_name,</span> <span class="string">[</span> <span class="string">&#123;sources,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;destinations,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;queue,</span> <span class="string">queue_name&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;prefetch_count,</span> <span class="string">count&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;ack_mode,</span> <span class="string">a_mode&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;publish_properties,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;publish_fields</span> <span class="string">,</span> <span class="string">[</span> <span class="string">...</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">,</span> <span class="string">&#123;reconnect_delay,</span> <span class="string">reconn_delay&#125;</span></span><br><span class="line">  <span class="string">]&#125;</span></span><br></pre></td></tr></table></figure><p>详细配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[&#123;rabbitmq_shovel,</span> </span><br><span class="line"><span class="string">[&#123;shovels,</span> </span><br><span class="line"><span class="string">[&#123;hidden</span> <span class="string">shovel,</span></span><br><span class="line"><span class="string">[&#123;sources,</span></span><br><span class="line"><span class="comment"># broker项配置的是URI，定义了用于连接Shovel两端的服务器地址、用户名、密码、vhost和端口号等。</span></span><br><span class="line"><span class="string">[&#123;broker,</span> <span class="string">"amqp://root:root123@192.168.0.2:5672 "</span><span class="string">&#125;,</span></span><br><span class="line">         <span class="comment"># declarations这一项是可选的，declaration_list指定了可以使用的AMQP，声明了队列、交换器和绑定关系。</span></span><br><span class="line"> <span class="string">&#123;declarations,</span></span><br><span class="line"> <span class="string">[</span></span><br><span class="line"> <span class="comment"># 声明了队列，&lt;&lt;告诉Erlang是binary类型字符串</span></span><br><span class="line"> <span class="string">&#123;'queue.declare',</span> <span class="string">[&#123;queue,</span> <span class="string">&lt;&lt;"queue1"&gt;&gt;&#125;,</span> <span class="string">durable]&#125;,</span></span><br><span class="line"> <span class="comment"># 声明了交换器，durable需要赋值时才要加上&#123;&#125;</span></span><br><span class="line"> <span class="string">&#123;'exchange.declare',[</span></span><br><span class="line"> <span class="string">&#123;exchange,</span> <span class="string">&lt;&lt;"exchange1"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;type,</span> <span class="string">&lt;&lt;"direct"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">durable</span></span><br><span class="line"> <span class="string">]</span></span><br><span class="line"> <span class="string">&#125;,</span></span><br><span class="line"> <span class="comment"># 声明了绑定关系</span></span><br><span class="line"> <span class="string">&#123;'queue.bind',</span> <span class="string">[</span></span><br><span class="line"> <span class="string">&#123;exchange,</span> <span class="string">&lt;&lt;"exchange1"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;queue,</span> <span class="string">&lt;&lt;"queue1"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;routing_key,</span> <span class="string">&lt;&lt;"rk1"&gt;&gt;&#125;</span></span><br><span class="line"> <span class="string">&#125;]&#125;]&#125;,</span></span><br><span class="line"> <span class="string">&#123;destinations,</span></span><br><span class="line"> <span class="string">[&#123;broker，"amqp://root:root123@192.168.0.2:5672"&#125;,</span></span><br><span class="line"> <span class="string">&#123;declarations,</span></span><br><span class="line"> <span class="string">[</span></span><br><span class="line"> <span class="string">&#123;'queue.declare',</span> <span class="string">[&#123;queue,</span> <span class="string">&lt;&lt;"queue2"&gt;&gt;&#125;,</span> <span class="string">durable]&#125;,</span></span><br><span class="line"> <span class="string">&#123;'exchange.declare',[</span></span><br><span class="line"> <span class="string">&#123;exchange,</span> <span class="string">&lt;&lt;"exchange2"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;type,</span> <span class="string">&lt;&lt;"direct"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">durable</span></span><br><span class="line"> <span class="string">]</span></span><br><span class="line"> <span class="string">&#125;,</span></span><br><span class="line"> <span class="string">&#123;'queue.bind',</span> <span class="string">[</span></span><br><span class="line"> <span class="string">&#123;exchange,</span> <span class="string">&lt;&lt;"exchange2"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;queue,</span> <span class="string">&lt;&lt;"queue2"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;routing_key,</span> <span class="string">&lt;&lt;"rk2"&gt;&gt;&#125;</span></span><br><span class="line"> <span class="string">&#125;]&#125;]&#125;,</span></span><br><span class="line"> <span class="comment"># 表示源端服务器上的队列名称，&lt;&lt;&gt;&gt;则表示匿名队列</span></span><br><span class="line"> <span class="string">&#123;queue,</span> <span class="string">&lt;&lt;"queue1"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="comment"># 表示在完成转发消息时的确认模式</span></span><br><span class="line"> <span class="comment"># no_ack表示无须任何消息确认行为</span></span><br><span class="line"> <span class="comment"># no_publish表示Shovel会把每一条消息发送到目的端之后再向源端发送消息确认</span></span><br><span class="line"> <span class="comment"># no_confirm表示Shovel会使用publisher confirm机制，在收到目的端的消息确认之后再向源端发送消息确认</span></span><br><span class="line"> <span class="string">&#123;ack_mode,</span> <span class="string">no_ack&#125;,</span></span><br><span class="line"> <span class="comment"># 表示Shovel内部缓存的消息条数，Shovel的内部缓存是源端服务器和目的端服务器之间的中间缓存部分</span></span><br><span class="line"> <span class="string">&#123;prefetch_count,</span> <span class="number">64</span><span class="string">&#125;,</span></span><br><span class="line"> <span class="comment"># 指消息发往目的端时需要特别设置的属性列表</span></span><br><span class="line"> <span class="string">&#123;publish_properties,</span> <span class="string">[&#123;delivery_mode,</span> <span class="number">2</span><span class="string">&#125;]&#125;,</span></span><br><span class="line"> <span class="comment"># 设置为true，会在转发的消息内添加x-shovelled的header属性</span></span><br><span class="line"> <span class="string">&#123;add_forward_headers,</span> <span class="literal">true</span><span class="string">&#125;,</span></span><br><span class="line"> <span class="comment"># 定义了消息需要发往目的端服务器上的交换器以及标记在消息上的路由键。如果交换器和路由键没有定义，则Shovel会从原始消息上复制这些被忽略的设置。</span></span><br><span class="line"> <span class="string">&#123;publish_fields,</span> <span class="string">[&#123;exchange,</span> <span class="string">&lt;&lt;"exchange2"&gt;&gt;&#125;,</span></span><br><span class="line"> <span class="string">&#123;routing_key,</span> <span class="string">&lt;&lt;"rk2"&gt;&gt;&#125;]&#125;,</span></span><br><span class="line"> <span class="comment"># 指定在Shovel link失效情况下，重新建立连接前需要等待的时间。如果设置为0，则不会进行重连动作，即Shovel会在首次连接失效时停止工作。默认为5秒。</span></span><br><span class="line"> <span class="string">&#123;reconnect_delay,</span> <span class="number">5</span><span class="string">&#125;</span> <span class="string">J</span></span><br><span class="line"><span class="string">&#125;]</span> </span><br><span class="line"><span class="string">&#125;]</span></span><br><span class="line"><span class="string">&#125;].</span></span><br></pre></td></tr></table></figure><p>如果 sources 或者 destinations 是 RabbitMQ 集群，那么就使用 brokers ，并在其后用多个URI字符串以 <code>[]</code> 的形式包裹起来。</p><h4 id="2-3-2-动态方式"><a href="#2-3-2-动态方式" class="headerlink" title="2.3.2 动态方式"></a>2.3.2 动态方式</h4><p>Federation upstream 类似 Shovel 动态部署方式的配置信息会被保存 RabbitMQ Mnesia 数据库中，包括权限信息、用户信息和队列信息等内容。</p><p>每一个Shovel link都由一个相应的Parameter定义，Parameter设置方式：</p><ul><li><p>第一种，通过 rabbitmqctl 工具的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter shovel hidden_shovel \</span></span><br><span class="line">'&#123;"src-uri":"amqp://root:root123@192.168.0.2:5672",</span><br><span class="line">"src-queue":"queue1",</span><br><span class="line">"dest-uri":"amqp://root:rootl23@192.168.0.3:5672","src- exchange-key":"rk2",</span><br><span class="line">"prefetch-count":64,"reconnect-delay":5,"publish-properties":[],</span><br><span class="line">"add-forward-headers":true,"ack-mode":"on-confirm"&#125;'</span><br></pre></td></tr></table></figure></li><li><p>第二种，通过调用 HTTP API 接口的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XPUT d</span></span><br><span class="line">'&#123;"value":&#123;"src-uri":"amqp://root:root123@192.168.0.2:5672","src-queue":"queue1",</span><br><span class="line">"dest-uri":"amqp://root:rootl23@192.168.0.3:5672","src-exchange-key":"rk2",</span><br><span class="line">"prefetch-count":64, "reconnect-delay":5,"publish-properties":[],</span><br><span class="line">"add-forward-headers":true,"ack_mode":"confirm"&#125;&#125;'</span><br><span class="line">http://192.168.0.2:15672/api/parameters/shovel/%2f/hidden_shovel</span><br></pre></td></tr></table></figure></li><li><p>第三种，通过在Web管理界面中添加的方式，【Admin】-&gt;【Shovel Management】-&gt;【Add a new shovel】。</p><ul><li>在创建了一个 Shovel link 之后，可以在【Admin】-&gt;【Shovel Status】 中查看状态信息。</li><li>也可以通过 <code>rabbitmqctl eval &#39;rabbit shovel_status:status().</code> 查看相应的 Shovel link。</li></ul></li></ul><h3 id="2-4-案例：消息堆积的治理"><a href="#2-4-案例：消息堆积的治理" class="headerlink" title="2.4 案例：消息堆积的治理"></a>2.4 案例：消息堆积的治理</h3><p><strong>消息堆积</strong>是在使用消息中间件过程中遇到的最正常不过的事情。消息堆积是一把双刃剑，适量的堆积可以有削峰、缓存之用 ，但是如果堆积过于严重，就可能影响到其他队列的使用，导致整体服务质量的下降。</p><p>对于一台普通的服务器来说，在一个队列中堆积1万至10万条消息，丝毫不会影响什么。但是如果这个队列中堆积超过1千万乃至一亿条消息时，可能会引起一些严 重的问题，比如引起内存或者磁盘告警而造成所有 Connection 阻塞。</p><p>解决方案：</p><ul><li>消息堆积严重时，可以选择清空队列，或者采用空消费程序丢弃掉部分消息。不过对于重要的数据而言，丢弃消息的方案并无用武之地。</li><li>另一种方案是增加下游消费者的消费能力，这个思路可以通过后期优化代码逻辑或者增加消费者的实例数来实现。但是后期的代码优化在面临紧急情况时总归是“远水解不了近渴”，并且有些业务场景也井非可以简单地通过增加消费实例而得以增强消费能力。</li><li>当某个队列中的消息堆积严重时，比如超过某个设定的阑值，就可以通过 Shovel 将队列中的消息移交给另一个集群。</li></ul><p>几种情形：</p><ul><li>情形1：当检测到当前运行集群 cluster1 中的队列 queue1 中有严重消息堆积，比如通过 <code>/api/queues/vhost/name</code> 接口获取到队列的消息个数（messages）超过2千万或者消息占用大小（messages_bytes）超过 10GB 时，就启用 shovel1 将队列 queue1 中的消息转发至备份集群 cluster2 中的队列 queue2。</li><li>情形2：紧随情形1，当检测到队列 queue1 中的消息个数低于1百万或者消息占用大小低于1GB 时就停止 shovel1，然后让原本队列 queue1 中的消费者慢慢处理剩余的堆积。</li><li>情形3：当检测到队列 queue1 中的消息个数低于 10 万或者消息占用大小低于100MB时， 就开启 shovel2 将队列 queue2 中暂存的消息返还给队列 queue1。</li><li>情形4：紧随情形3，当检测到队列 queue1 中的消息个数超过1百万或者消息占用大小高于 1GB 时就将 shovel2 停掉。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010149.png" alt></p><p>如此，队列 queue1 就拥有了队列 queue2 这个“保镖”为它保驾护航。这里是一备一的情形，如果需要一备多，可以采用镜像队列或者引入 Federation。</p><h2 id="第三节-Federation-Shovel-与集群的区别和联系"><a href="#第三节-Federation-Shovel-与集群的区别和联系" class="headerlink" title="第三节 Federation/Shovel 与集群的区别和联系"></a>第三节 Federation/Shovel 与集群的区别和联系</h2><p>集群、Federation、Shovel这三种部署方式：</p><p>集群是最为通用的一种方式。集群将多个 Broker 节点连接起来组成逻辑上独立的单个 Broker 。集群内部借助 Erlang 进行消息传输，所以集群中的每个节点的 Erlang cookie 务必要保持一致。同时，集群内部的网络必须是可靠的，RabbitMQ Erlang 的版本也必须一致。虚拟主机、交换器、用户、权限等都会自动备份到集群中的各个节点。队列可能部署单个节点或被镜像到多个节点中。连接到任意节点的客户端能够看到集群中所有的队列，即使该队列不在所连接的节点之上。通常使用集群的部署方式来提高可靠性和吞吐量，不过集群只能部署在局域网内。</p><p>Federation，可以翻译为“联邦”。 Federation 可以通过 AMQP 协议（可配置 SSL）让原本发送到某个 Broker （或集群）中的交换器（或队列）上的消息能够转发到另一个 Broker （或集群）中的交换器（或队列）上，两方的交换器（或队列）看起来是以一种“联邦”的形式在运作。当然必须要确保这些“联邦”的交换器或者队列都具备合适的用户和权限。</p><p>联邦交换器（federated exchange）通过单向点对点的连接（Federation link）形式进行通信。默认情况下，消息只会由 Federation 连接转发一次，可以允许有复杂的路由拓扑来提高转发次数。在 Federation 连接上，消息可能不会被转发，如果消息到达了联邦交换器之后路由不到合适的队列，那么它也不会被再次转发到原来的地方（这里指上游交换器，即 upstream exchange）可以通过 Federation 连接广域网中的各个 RabbitMQ 服务器来生产和消费消息。联邦队列（federated queue）也是通过单向点对点连接进行通信的，消息可以根据具体的配置消费者的状态在联邦队列中游离任意次数。</p><p>通过 Shovel 来连接各个 RabbitMQ Broker ，概念上 Federation 的情形类似，不过 Shovel 工作在更低一层。鉴于 Federation 从一个交换器中转发消息到另一个交换器（如果必要可以确认消息是否被转发）， Shovel 只是简单地从某个 Broker 上的队列中消费消息，然后转发消息到 Broker 上的交换器而已。Shovel 也可以在单独的一台服务器上去转发消息，比如将队列中的数据移动到另一个队列中。如果想获得比 Federation 更多的控制，可以在广域网中使用 Shovel 连接各个 RabbitMQ Broker 来生产或消费消息。</p><table><thead><tr><th>Federation/Shovel</th><th>集群</th></tr></thead><tbody><tr><td>各个 Broke 节点之间逻缉分离</td><td>逻辑上是个 Broker 节点</td></tr><tr><td>各个 Broker 节点之间可以运行不同版本的 Erlang 和 RabbitMQ</td><td>各个 Broker 节点之间必须运行相同版本的 Erlang 和 RabbitMQ</td></tr><tr><td>各个 Broker 节点之间可以在广域网中相连，当然必须要授予适当的用户和权限</td><td>各个 Broker 节点之间必须在可信赖的局域网中相连，通过 Erlang 内部节点传递消息，但节点问需要有相同的 Erlang cookie</td></tr><tr><td>各个 Broker 节点之间能以任何拓扑逻辑部署，连接可以是单向的或者是双向的</td><td>所有 Broker 节点都双向连续所有其他节点</td></tr><tr><td>从 CAP 理论中选择可用性和分区耐受性，即 AP</td><td>从 CAP 理论中选择致性和可用性，CA</td></tr><tr><td>一个 Broker 中的交换器可以是 Federation 生成的或者是本地的</td><td>集群中所有 Broker 节点中的交换器都是一样的，要么全有要么全无</td></tr><tr><td>客户端所能看到它所连接的 Broker 节点上的队列</td><td>客户端连接到集群中的任何 Broker 节点都可以看到所有 的队列</td></tr></tbody></table><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第七章《Federation与Shovel》，内容来自于《RabbitMQ实战指南》，内容：RabbitMQ有3种方式实现分布式部署（集群、Federation和Shovel）可以任意组合实现拓扑部署。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（六）运维</title>
    <link href="http://linyishui.top/2020100801.html"/>
    <id>http://linyishui.top/2020100801.html</id>
    <published>2020-10-08T15:34:48.000Z</published>
    <updated>2020-10-10T08:16:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（六）运维"><a href="#RabbitMQ（六）运维" class="headerlink" title="RabbitMQ（六）运维"></a>RabbitMQ（六）运维</h1><h2 id="第一节-集群搭建"><a href="#第一节-集群搭建" class="headerlink" title="第一节 集群搭建"></a>第一节 集群搭建</h2><p>单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键。</p><p>RabbitMQ 集群也不能保证消息的万无一失，即将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式。当集群中一个 RabbitMQ 节点崩溃时，该节点上的所有队列中的消息也会丢失。 RabbitMQ 集群中的所有节点都会备份所有的元数据信息， 包括以下内容：</p><ul><li><strong>队列元数据</strong>：队列的名称及属性； </li><li><strong>交换器</strong>：交换器的名称及属性： </li><li><strong>绑定关系元数据</strong>：交换器与队列或者交换器与交换器之间的绑定关系； </li><li><strong>vhost 元数据</strong>：为 vhost 内的队列、交换器和绑定提供命名空间及安全属性。</li></ul><p>但是不会备份消息（当然通过特殊的配置比如镜像队列可以解决这个问题）。基于存储空间和性能的考虑，在 RabbitMQ 集群中创建队列，<strong>集群只会在单个节点而不是在所有节点上创建队列的进程并包含完整的队列信息</strong>（元数据、状态、内容）。这样只有队列的宿主节点，即所有者节点知道队列的所有信息，所有其他非所有者节点只知道队列的元数据和指向该队列存在的那个节点的指针。因此当集群节点崩溃时，该节点的队列进程和关联的绑定都会消失。附加在那些队列上的消费者也会丢失其所订阅的信息，井且任何匹配该队列绑定信息的新消息也都会消失。</p><p>不同于队列那样拥有自己的进程，交换器其实只是一个名称和绑定列表。当消息发布到交换器时，实际上是由所连接的信道将消息上的路由键同交换器的绑定列表进行比较，然后再路由消息。当创建一个新的交换器时， RabbitMQ 所要做的就是<strong>将绑定列表添加到集群中的所有节点上</strong>。这样，每个节点上的每条信道都可以访问到新的交换器了。</p><p>创建集群的过程可以看作向集群中添加节点的过程。</p><h3 id="1-1-多机多节点配置"><a href="#1-1-多机多节点配置" class="headerlink" title="1.1 多机多节点配置"></a>1.1 多机多节点配置</h3><p>多机多节点主要是指在每台机器中部署一个 RabbitMQ 服务节点，进而由多台机器组成一个 RabbitMQ 集群。</p><p>假设这里一共有三台物理主机，均己正确地安装了 RabbitMQ ，且主机名分别为 node1、node2、node3。RabbitMQ 集群对延迟非常敏感，应当只在本地局域网内使用 。<strong>在广域网中不应该使用集群，而应该使用 Federation 或者 Shovel 来代替</strong>。</p><h4 id="1-1-1-配置流程"><a href="#1-1-1-配置流程" class="headerlink" title="1.1.1 配置流程"></a>1.1.1 配置流程</h4><ul><li><p>第一步，配置各个节点的 hosts 文件，让各个节点都能互相识别对方的存在。</p><ul><li><p>比如在 Linux 系统中可以编辑 <code>/etc/hosts</code> 文件，在其上添加地址与节点名称的映射信息：</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.2</span> <span class="selector-tag">node1</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.3</span> <span class="selector-tag">node2</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.4</span> <span class="selector-tag">node3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>第二步，编辑 RabbitMQ 的 cookie 文件，以确保各个节点的 cookie 文件使用的是同一个值。</p><ul><li><p>可以读取 node1 节点的 cookie 值，然后将其复制到 node2、node3 节点中。</p></li><li><p>cookie 文件默认路径为：<code>/var/lib/rabbitmq/.erlang.cookie</code> 或者 <code>$HOME/.erlang.cookie</code> 。</p></li><li><p>集群中的 RabbitMQ 节点需要通过交换密钥令牌以获得相互认证。</p></li><li><p>如果节点的密钥令牌不一致，那么在配置节点时就会有如下的报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster rabbit@node1</span></span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1</span><br><span class="line">Error: unable to connect to nodes [rabbit@node1]: nodedown </span><br><span class="line"></span><br><span class="line">DIAGNOSTICS </span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">attempted to contact: [rabbit@node1] </span><br><span class="line"></span><br><span class="line">rabbit@node1:</span><br><span class="line">* connected to epmd (port 4369) on node1</span><br><span class="line">* epmd reports node rabbit runn ng on port 25672</span><br><span class="line">* TCP connection succeeded but Erlang distribution failed </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意此处</span></span><br><span class="line">* Authentication failed (rejected by the remote node), please check the Erlang cookie </span><br><span class="line"></span><br><span class="line">current node details:</span><br><span class="line">- node name: 'rabbitmq-cli-53@node2'</span><br><span class="line">- home dir: /root</span><br><span class="line">- cookie hash: kLtTY75JJGZnZpQF7CqnYg==</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第三步，配置集群。</p><ul><li><p>配置集群有三种方式 ：</p><ul><li>通过 rabbitmqctl 工具配置；</li><li>通过 rabbitmq.config 配置文件配置；</li><li>通过 rabbitmq-autocluster 插件配置。</li></ul></li><li><p>示例通过 rabbitmqctl 工具配置：</p><ul><li><p>首先启动 node1、node2、node3 这几个节点的 RabbitMQ 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node2 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node3 ~]# rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li><li><p>开启后这3个节点目前都是以独立节点存在的单个集群，查看各个节点的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl cluster_status </span><br><span class="line">[root@node2 ~]# rabbitmqctl cluster_status </span><br><span class="line">[root@node3 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li><li><p>接下来为了将这3个节点组成一个集群，需要以 node1 节点为基准，将 node2 和 node3 节点加入 node1 节点的集群中。这3个节点是平等的，如果想调换彼此的加入顺序也未尝不可。</p><ol><li><p>首先将 node2 节点加入 node1 节点的集群中：（此时再通过 <code>rabbitmqctl cluster_status</code> 可以看到两个节点的信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabb t@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl join cluster rabbit@node1</span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1</span><br><span class="line">[root@node2 ~]# rabbitmqctl start_ app</span><br><span class="line">Starting node rabbit@node2</span><br></pre></td></tr></table></figure></li><li><p>再将 node3 节点也加入 node1 节点所在的集群中，步骤同上。</p></li></ol></li></ul></li></ul></li></ul><h4 id="1-1-2-节点关闭的几种情况"><a href="#1-1-2-节点关闭的几种情况" class="headerlink" title="1.1.2 节点关闭的几种情况"></a>1.1.2 节点关闭的几种情况</h4><ul><li><p>如果集群中某个节点关闭了，会使集群处于怎样的状态？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭 node2 节点</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 node1 节点查看集群状态时，会发现 running_nodes 已没有 node2</span></span><br><span class="line">[root@node1 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li><li><p>如果关闭了集群中的所有节点，则<strong>需要确保在启动的时候最后关闭的那个节点是第一个启动的</strong>。</p><ul><li>如果第一个启动的不是最后关闭的节点，那么这个节点会等待最后关闭的节点启动。这个等待时间是 30 秒，如果没有等到，那么这个先启动的节点也会失败。</li><li>在最新的版本中会有重试机制，默认重试 10 次 30 秒以等待最后关闭的节点启动。</li></ul></li><li><p>如果最后一个关闭的节点最终由于某些异常而无法启动，则可以通过 <code>rabbitmqctl forget_cluster_node</code> 命令来将此节点剔出当前集群。</p></li><li><p>如果集群中的所有节点由于某些非正常因素，比如断电而关闭，那么集群中的节点都会认为还有其他节点在它后面关闭，此时需要调用 <code>rabbitmqctl force_boot</code> 命令来启动一个节点，之后集群才能正常启动。</p></li></ul><h3 id="1-2-集群节点类型"><a href="#1-2-集群节点类型" class="headerlink" title="1.2 集群节点类型"></a>1.2 集群节点类型</h3><h4 id="1-2-1-两种节点类型"><a href="#1-2-1-两种节点类型" class="headerlink" title="1.2.1 两种节点类型"></a>1.2.1 两种节点类型</h4><p>使用 <code>rabbitmqctl cluster_status</code> 命令来查看集群状态时会有 <code>{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]</code> 这一项信息，其中的 disc 标注了 RabbitMQ 点的类型。</p><p>不论是单一节点还是集群节点，有两种类型：</p><ul><li><strong>内存节点</strong>：将所有的队列、 交换器、绑定关系、用户、权限和 vhost 的元数据定义都存储在内存中；</li><li><strong>磁盘节点</strong>：存放到磁盘中。所以单节点集群只能是磁盘节点，否则重启后会丢失系统的配置信息。</li></ul><h4 id="1-2-2-如何指定或切换节点类型"><a href="#1-2-2-如何指定或切换节点类型" class="headerlink" title="1.2.2 如何指定或切换节点类型"></a>1.2.2 如何指定或切换节点类型</h4><p>将节点指定为内存节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 node2 节点加入 node1 节点的时候可以指定 node2 节点的类型为内存节点</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl join_cluster rabbit@node1 --ram</span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以在集群搭建好以后再通过 rabbitmqctl change_cluster_node_type &#123;disc, ram&#125;命令切换类型</span></span><br><span class="line">[root@node2 ~]# rabbitmqctl stop_app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl change cluster node type disc</span><br><span class="line">Turning rabbit@node2 into a disc node</span><br><span class="line">[root@node2 ~]# rabbitmqctl start app</span><br><span class="line">Starting node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><h4 id="1-2-3-如何选择内存还是磁盘节点"><a href="#1-2-3-如何选择内存还是磁盘节点" class="headerlink" title="1.2.3 如何选择内存还是磁盘节点"></a>1.2.3 如何选择内存还是磁盘节点</h4><p>在集群中创建队列、交换器或者绑定关系的时候，这些操作直到所有集群节点都成功提交元数据变更后才会返回。对内存节点来说，这意味着将变更写入内存；而对于磁盘节点来说，这意味着昂贵的磁盘写入操作。内存节点可以提供出色的性能，磁盘节点能够保证集群配置信息的高可靠性，如何在这两者之间进行抉择呢？</p><ul><li>首先集群中至少有一个磁盘节点；</li><li>新增或删除节点时需要将变更通知到至少一个磁盘节点；</li><li>如果只有一个磁盘节点，而且它刚好崩溃了，集群可以继续发送或者接收消息，但是不能执行创建队列、交换器、绑定关系、用户，以及更改权限、添加或删除集群节点的操作了。<strong>即唯一磁盘节点崩溃时，集群可以继续运行，但不能变更</strong>。</li><li>在内存节点重启后，它们会连接到预先配置的磁盘节点，下载当前集群元数据的副本。当在集群中添加内存节点时，确保告知其所有的磁盘节点（内存节点唯一存储到磁盘的元数据信 息是集群中磁盘节点的地址）。只要内存节点可以找到至少一个磁盘节点，那么它就能在重启后重新加入集群中。</li><li>除了使用RPC功能时，大多数的操作就是生产或者消费消息。为了确保集群信息的可靠性，或者在不确定使用磁盘节点或者内存节点的时候，<strong>建议全部使用磁盘节点</strong>。</li></ul><h3 id="1-3-剔除单个节点"><a href="#1-3-剔除单个节点" class="headerlink" title="1.3 剔除单个节点"></a>1.3 剔除单个节点</h3><h4 id="1-3-1-如何从集群中删除一个节点"><a href="#1-3-1-如何从集群中删除一个节点" class="headerlink" title="1.3.1 如何从集群中删除一个节点"></a>1.3.1 如何从集群中删除一个节点</h4><p>两种方案：</p><ul><li><p>第一种：适合节点不再运行RabbitMQ的情况。</p><ul><li>首先在 node2 节点上执行 <code>rabbitmqctl stop_app</code> 或者 <code>rabbitmqctl stop</code> 命令来关闭 RabbitMQ 服务；</li><li>然后再在 node1 节点或者 node3 节点上执行 <code>rabbitmqctl forget_cluster_node rabbit@node2</code> （可以添加 <code>-offline</code> 即使非运行状态也可以生效）命令将 node2 节点剔除出去。</li></ul></li><li><p>第二种：只是简单的将节点从集群中移出，变成单一节点。</p><ul><li><p>在 node2 上执行 <code>rabbitmqctl reset</code> 命令。此命令将清空节点的状态，并将其恢复到空白状态，也会和集群中的磁盘节点进行通信，告诉它们该节点正在离开集群。</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]# rabbitmqctl stop app</span><br><span class="line">Stopping rabbit application on node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@node2</span><br><span class="line">[root@node2 ~]# rabbitmqctl start app</span><br><span class="line">Starting node rabbit@node2</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-4-集群节点的升级"><a href="#1-4-集群节点的升级" class="headerlink" title="1.4 集群节点的升级"></a>1.4 集群节点的升级</h3><h4 id="1-4-1-独立节点的升级"><a href="#1-4-1-独立节点的升级" class="headerlink" title="1.4.1 独立节点的升级"></a>1.4.1 独立节点的升级</h4><p>只须先关闭原来的服务，然后解压新的版本再运行即可。不过要确保原节点的 Mnesia 中的数据不被变更，且新节点中的 Mnesia 路径的指向要与原节点中的相同。</p><h4 id="1-4-2-集群节点的升级步骤"><a href="#1-4-2-集群节点的升级步骤" class="headerlink" title="1.4.2 集群节点的升级步骤"></a>1.4.2 集群节点的升级步骤</h4><p>单个节点的升级步骤：</p><ol><li>关闭所有节点的服务，注意采用 <code>rabbitmqctl stop</code> 命令关闭。</li><li>保存各个节点的 Mnesia 数据。</li><li>解压新版本的 RabbitMQ 到指定的目录。</li><li>指定新版本的 Mnesia 路径为步骤2中保存的 Mnesia 数据路径。</li><li>启动新版本的服务，注意先重启原版本中最后关闭的那个节点。</li></ol><p>步骤4和步骤5可以一起操作，比如执行 <code>RABBITMQ_MNESIA_BASE=/opt/mnesia rabbitmq-server-detached</code> 命令，其中 <code>/opt/mnesia</code> 为原版本保存 Mnesia 数据的路径。</p><p><strong>在对不同版本升级的过程中，最好先测试两个版本互通的可能性，然后再在线上环境中实地操作。</strong></p><p>如果原集群上的配置和数据都可以舍弃，则可以删除原版本的 RabbitMQ ，然后再重新安装配置即可：如果配置和数据不可丢弃 ，则按照上面所述保存元数据，之后再关闭所有生产者，并等待消费者消费完队列中的所有数据，紧接着关闭所有消费者，然后重新安装 RabbitMQ 重建元数据等。</p><p>也可以利用集群迁移直接转为新的集群。</p><h3 id="1-5-单机多节点配置"><a href="#1-5-单机多节点配置" class="headerlink" title="1.5 单机多节点配置"></a>1.5 单机多节点配置</h3><p>有时候不得不在单台物理机器上去创建一个多 RabbitMQ 服务节点的集群，需要<strong>确保每个节点都有独立的名称、数据存储位置、端口号（包括插件的端口号）等</strong>。</p><p>我们在主机名称为 node1 的机器上创建一个由 rabbit1@node1、rabbit2@node 1 和 rabbit3@node1 这3个节点组成 RabbitMQ 集群。</p><ul><li><p>为每个 RabbitMQ 服务节点设置不同的端口号和节点名称来启动相应的服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5672 RABBITMQ NODENAME=rabbit1</span><br><span class="line">rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5673 RABBITMQ NODENAME=rabbit2</span><br><span class="line">rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5674 RABBITMQ NODENAME=rabbit3</span><br><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li><li><p>在启动 rabbit1@node1 节点的服务之后，继续启动 rabbit2@node1 和 rabbit@node1 服务节点会遇到启动失败的情况。</p><ul><li><p>这种情况大多数是由于配置发生了冲突而造成后面的服务节点启动失 败，需要进一步确认是否开启了某些功能，比如 RabbitMQ Management 插件。</p></li><li><p>如果开启了 RabbitMQ Management 插件，就需要为每个服务节点配置一个对应插件端口号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5672 RABBITMQ NODENAME=rabbit1 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [&#123;port,15672)]" rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5673 RABBITMQ NODENAME=rabbit2 RABBITMQ_SERVER_START_ARGS="- rabbitmq_management listener [&#123;port, 15673&#125;]" rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# RABBITMQ NODE PORT=5674 RABBITMQ NODENAME=rabbit3 RABBITMQ_SERVER_START_ARGS="- rabbitmq_management listener [&#123;port,15674&#125;]" rabbitmq-server -detached</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动各节点服务之后，将 rabbit2@node1 节点加入 rabbit1@node1 集群之中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~] # rabbitmqctl -n rabbit2@node1 stop app</span><br><span class="line">Stopping rabbit application on node rabbit2@node1</span><br><span class="line">[root@node1 ~J # rabbitmqctl -n rabbit2@node1 reset</span><br><span class="line">Resetting node rabbit2@node1</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 join_cluster rabbit1@node1</span><br><span class="line">Clustering node rabbit2@node1 with rabbit1@node1</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 start_app</span><br><span class="line">Starting node rabbit2@node1</span><br></pre></td></tr></table></figure></li><li><p>执行相似的操作将 rabbit3@node1 也加入进来，并通过 <code>rabbitmqctl cluster_status</code> 命令来查看各个服务节点的集群状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit1@node1 cluster_status</span><br><span class="line">Cluster status of de rabbit1@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit3@node1, rabbit2@node1, rabbit1@node1]&#125;,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125;,</span><br><span class="line">&#123;alarms, [&#123;rabbit3@node1, []&#125;, &#123;rabbit2@node1, []&#125;, &#123;rabbit1@node1, []&#125;]&#125;]</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit2@node1 cluster_status</span><br><span class="line">Cluster status of node rabbit2@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit3@node1, rabbit1@node1, rabbit2@node1]&#125;,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125; ,</span><br><span class="line">&#123;alarms, [&#123;rabbit3@node1, []&#125; , &#123;rabbit1@node1, []&#125;, &#123;rabbit2@node1, []&#125;]&#125;]</span><br><span class="line">[root@node1 ~]# rabbitmqctl -n rabbit3@node1 cluster_status</span><br><span class="line">Cluster status of node rabbit3@node1</span><br><span class="line">[&#123;nodes, [&#123;disc, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit1@node1, rabbit2@node1, rabbit3@node1]&#125; ,</span><br><span class="line">&#123;cluster_name, &lt;&lt;"rabbit1@node1"&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions, []&#125; ,</span><br><span class="line">&#123;alarms, [&#123;rabbit1@node1, []&#125;, &#123;rabbit2@node1, []&#125;, &#123;rabbit3@node1, []&#125;]&#125;]</span><br></pre></td></tr></table></figure></li></ul><p>RabbitMQ 单机多节点配置大多用于实验性论证，生产环境还是选用多机多节点的集群。</p><h2 id="第二节-查看服务日志"><a href="#第二节-查看服务日志" class="headerlink" title="第二节 查看服务日志"></a>第二节 查看服务日志</h2><p>RabbitMQ 日志中包含各种类型的事件，比如<strong>连接尝试、服务启动、插件安装及解析请求时的错误等</strong>。</p><p>RabbitMQ 的日志默认存放在 <code>$RABBITMQ_HOME/var/log/rabbitmq</code> 文件夹内。在这个文件夹内 RabbitMQ 会创建两个日志文件：</p><ul><li><code>RABBITMQ_NODENAME-sasl.log</code> ：SASL (System Application Support Libraries，系统应用程序支持库）是库的集合，作为 Erlang-OTP 发行版的一部分。提供了一系列标准，其中之一是日志记录格式。<strong>当 RabbitMQ 记录 Erlang 相关信息时，它会将日志写入文件<code>RABBITMQ_NODENAME-sasl.log</code> </strong>。</li><li><code>RABBITMQ_NODENAME.log</code> ：RabbitMQ 服务日志指的就是这个文件。</li></ul><h3 id="2-1-启动RabbitMQ服务"><a href="#2-1-启动RabbitMQ服务" class="headerlink" title="2.1 启动RabbitMQ服务"></a>2.1 启动RabbitMQ服务</h3><ul><li>使用 <code>rabbitmq-server -detached</code> 命令启动RabbitMQ服务，顺带会启动 Erlang 虚拟机和RabbitMQ应用服务。</li><li>使用 <code>rabbitmqctl start_app</code> 用来启动 RabbitMQ 应用服务（启动成功的前提是 Erlang 虚拟机运转正常）。</li><li>如果使用 <code>rabbitmqctl stop_app</code> 命令关闭的 RabbitMQ 应用服务，那么在使用 <code>rabbitmqctl start_app</code> 命令开启 bbitMQ 应用服务时的启动日志和 <code>rabbitmq-server</code> 的启动日志相同。</li></ul><p>相关服务日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RabbitMQ 版本号、Erlang 的版本号</span></span><br><span class="line"><span class="string">Starting</span> <span class="string">RabbitMQ</span> <span class="number">3.6</span><span class="number">.2</span> <span class="string">on</span> <span class="string">Erlang</span> <span class="number">19.1</span></span><br><span class="line"><span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2007</span><span class="bullet">-2016</span> <span class="string">Pivotal</span> <span class="string">Software,</span> <span class="string">Inc</span> <span class="string">.</span></span><br><span class="line"><span class="string">Licensed</span> <span class="string">under</span> <span class="string">the</span> <span class="string">MPL.</span> <span class="string">See</span> <span class="attr">http://www.rabbitmq.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO REPORT 和 WARNING REPORT 表示日志级别</span></span><br><span class="line"><span class="comment"># RabbitMQ 服务节点名称、cookie 的 hash 值、配置文件地址</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:08</span> <span class="string">===</span></span><br><span class="line"><span class="string">node</span> <span class="string">:</span> <span class="string">rabbit@node1</span></span><br><span class="line"><span class="string">home</span> <span class="string">dir</span> <span class="string">:</span> <span class="string">/root</span></span><br><span class="line"><span class="string">config</span> <span class="string">file(s)</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/etc/rabbitmq/rabbitmq.config</span> <span class="string">(not</span> <span class="string">found)</span></span><br><span class="line"><span class="string">cookie</span> <span class="string">hash</span> <span class="string">:</span> <span class="string">VCwbL3S9/ydrGgVsrLjVkA==</span></span><br><span class="line"><span class="string">log</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/var/log/rabbitmq/rabbit@node1.log</span></span><br><span class="line"><span class="string">sasl</span> <span class="string">log</span> <span class="string">:</span> <span class="string">pt/rabbitmq</span> <span class="string">/var/</span> <span class="string">log/rabbitmq/rabbit@node1-sasl.log</span></span><br><span class="line"><span class="string">database</span> <span class="string">dir</span> <span class="string">:</span> <span class="string">/opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存限制</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span> </span><br><span class="line"><span class="string">Memory</span> <span class="string">limit</span> <span class="string">set</span> <span class="string">to</span> <span class="number">3148</span><span class="string">MB</span> <span class="string">of</span> <span class="number">7872</span><span class="string">MB</span> <span class="string">total.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 磁盘限制</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Disk</span> <span class="string">free</span> <span class="string">limit</span> <span class="string">set</span> <span class="string">to</span> <span class="number">50</span><span class="string">MB</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Limiting</span> <span class="string">to</span> <span class="string">approx</span> <span class="number">924</span> <span class="string">file</span> <span class="string">handles</span> <span class="string">(829</span> <span class="string">sockets)</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">FHC</span> <span class="string">read</span> <span class="attr">buffering:</span> <span class="string">OFF</span></span><br><span class="line"><span class="string">FHC</span> <span class="string">write</span> <span class="attr">buffering:</span> <span class="string">ON</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:09</span> <span class="string">===</span></span><br><span class="line"><span class="string">Database</span> <span class="string">rectory</span> <span class="string">at</span> <span class="string">/opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node1</span> <span class="string">is</span></span><br><span class="line"><span class="string">empty.</span> <span class="string">Initialising</span> <span class="string">from</span> <span class="string">scratch...</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Priority</span> <span class="string">queues</span> <span class="string">enabled,</span> <span class="string">real</span> <span class="string">BQ</span> <span class="string">is</span> <span class="string">rabbit_variable_queue</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Adding</span> <span class="string">vhost</span> <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认账户 guest 的创建及权限配置</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">user</span> <span class="string">'guest'</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Setting</span> <span class="string">user</span> <span class="string">tags</span> <span class="string">for</span> <span class="string">user</span> <span class="string">'guest'</span> <span class="string">to</span> <span class="string">[admistrator]</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Setting</span> <span class="string">permissions</span> <span class="string">for</span> <span class="string">'guest'</span> <span class="string">in</span> <span class="string">to</span> <span class="string">'.*'</span><span class="string">,</span> <span class="string">'.*'</span><span class="string">,</span> <span class="string">'.*'</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="attr">transient:</span> <span class="string">using</span> <span class="string">rabbit_msg_store_ets_index</span> <span class="string">to</span> <span class="string">provide</span> <span class="string">index</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="string">persistent</span> <span class="string">using</span> <span class="string">rabbit_msg_store_ets_index</span> <span class="string">to</span> <span class="string">provide</span> <span class="string">index</span></span><br><span class="line"></span><br><span class="line"><span class="string">=WARNING</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">msg_store</span> <span class="attr">persistent:</span> <span class="string">rebuilding</span> <span class="string">indices</span> <span class="string">from</span> <span class="string">scratch</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:52:10</span> <span class="string">===</span></span><br><span class="line"><span class="string">started</span> <span class="string">TCP</span> <span class="string">Listener</span> <span class="string">on</span> <span class="string">[::]:5672</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="bullet">-Oct-2017</span> <span class="string">::10:52</span> <span class="string">:</span> <span class="number">10</span> <span class="string">===</span></span><br><span class="line"><span class="string">Server</span> <span class="string">startup</span> <span class="string">complete;</span> <span class="number">0</span> <span class="string">plugins</span> <span class="string">started.</span></span><br></pre></td></tr></table></figure><p>日志级别：（通过 <code>rabbitmq.config</code> 配置文件中 <code>log_levels</code> 参数来设置，默认为 <code>[{connection, info}]</code> ）</p><ul><li>none</li><li>error</li><li>warning</li><li>info</li><li>debug</li></ul><h3 id="2-2-关闭RabbitMQ服务"><a href="#2-2-关闭RabbitMQ服务" class="headerlink" title="2.2 关闭RabbitMQ服务"></a>2.2 关闭RabbitMQ服务</h3><p>如果使用 <code>rabbitmqctl stop</code> 命令，会将 Erlang 虚拟机一同关闭，而 <code>rabbitmqctl stop_app</code> 只关闭 RabbitMQ 应用服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Stopping</span> <span class="string">RabbitMQ</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">stopped</span> <span class="string">TCP</span> <span class="string">Listener</span> <span class="string">on</span> <span class="string">[::]:5672</span></span><br><span class="line"></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Stopped</span> <span class="string">RabbitMQ</span> <span class="string">application</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用 rabbitmqctl stop 来进行关闭操作，则会多出下面的日志信息，即关闭 Erlang 虚拟机。</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:10:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Halting</span> <span class="string">Erlang</span> <span class="string">VM</span></span><br></pre></td></tr></table></figure><h3 id="2-3-建立集群"><a href="#2-3-建立集群" class="headerlink" title="2.3 建立集群"></a>2.3 建立集群</h3><p>举例将节点 rabbit@node2 和 rabbit@node1 组成一个集群：</p><ul><li><p>首先在 rabbit@node2 中执行 <code>rabbitmq-server -detached</code> 开启 Erlang 虚拟机和 RabbitMQ 应用服务，之后再执行 <code>rabbitmqctl stop_app</code> 来关闭 RabbitMQ 应用服务，之后需要重置节点 rabbit@node2 中的数据 <code>rabbitmqctl reset</code> ，在 rabbit@node2 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:25:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Resetting</span> <span class="string">Rabbit</span></span><br></pre></td></tr></table></figure></li><li><p>在 rabbit@node2 节点上执行 <code>rabbitmqctl join_clcuster rabbit@node1</code> ，将其加 rabbit@node1 中以组成一个集群，在 rabbit@node2 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:30:46</span> <span class="string">===</span></span><br><span class="line"><span class="string">Clustering</span> <span class="string">with</span> <span class="string">[rabbit@node1]</span> <span class="string">as</span> <span class="string">disc</span> <span class="string">node</span></span><br></pre></td></tr></table></figure></li><li><p>同时在 rabbit@node1 节点输出如下日志：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:30:56</span> <span class="string">===</span></span><br><span class="line"><span class="string">node</span> <span class="string">rabbit@node2</span> <span class="string">up</span></span><br></pre></td></tr></table></figure></li><li><p>如果此时在 rabbit@node2 节点上执行 <code>rabbitmqctl stop_app</code> 的动作，那么在 <code>rabbit@node1</code> 节点中会有如下信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">rabbit</span> <span class="string">on</span> <span class="string">node</span> <span class="string">rabbit@node2</span> <span class="string">down</span></span><br><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">3</span><span class="attr">-Oct-2017:</span> <span class="string">:11:54:01</span> <span class="string">===</span></span><br><span class="line"><span class="string">Keep</span> <span class="string">rabbit@node2</span> <span class="attr">listeners:</span> <span class="string">the</span> <span class="string">node</span> <span class="string">is</span> <span class="string">already</span> <span class="string">back</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h3><p>客户端与 RabbitMQ 建立连接：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=INFO</span> <span class="string">REPORT====</span> <span class="number">14</span><span class="bullet">-0</span><span class="attr">ct-2017:</span> <span class="string">:16:24:55</span> <span class="string">===</span></span><br><span class="line"><span class="string">accepting</span> <span class="string">AMQP</span> <span class="string">connection</span> <span class="string">&lt;0.5865.0&gt;</span> <span class="string">(192.168.0.9:61601</span> <span class="bullet">-&gt;</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span><span class="string">:5672)</span></span><br></pre></td></tr></table></figure><p>客户端强制中断连接时：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">=WARNING</span> <span class="string">REPORT====</span> <span class="number">14</span><span class="attr">-Jul-2017:</span> <span class="string">:16:36:57</span> <span class="string">===</span></span><br><span class="line"><span class="string">closing</span> <span class="string">AMQP</span> <span class="string">connection</span> <span class="string">&lt;0.5909.0&gt;</span> <span class="string">(192.168.0.9:61629</span> <span class="bullet">-&gt;</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span><span class="string">:5672)</span></span><br><span class="line"><span class="string">connection_closed_abruptly</span></span><br></pre></td></tr></table></figure><h3 id="2-5-日常积累各种操作对应日志格式"><a href="#2-5-日常积累各种操作对应日志格式" class="headerlink" title="2.5 日常积累各种操作对应日志格式"></a>2.5 日常积累各种操作对应日志格式</h3><p>可以通过尝试各种的操作以收集相应的服务日志，之后组成一个知识集，这个知识集不单单指一个日志列表，需要通过后期的强化训练掌握其规律，让这个知识集了然于心 。在真正遇到异常故障的时候可以通过查看服务日志来迅速定位问题，之后再采取相应的措施以解决问题。</p><p>比如在执行任何 RabbitMQ 操作之前，都会打开一个新的窗口运 <code>tail -f $RABBITMQ_HOME/var/log/rabbitmq/rabbit@$HOSTNAME.log -n 200</code> 命令来实时查看相应操作所对应的服务日志是什么，久而久之即可在脑海中建立一个相对完备的“知识集”。</p><h3 id="2-6-日志文件管理"><a href="#2-6-日志文件管理" class="headerlink" title="2.6 日志文件管理"></a>2.6 日志文件管理</h3><p>RabbitMQ 中可以通过 <code>rabbitmqctl rotate_logs {suffix}</code> 命令来轮换日志，比如手工切换当前的日志：<code>rabbitmqctl rotate_logs.bak</code> ，之后可以看到在日志目录下会建立新的日志文件，并且将老的日志文件以添加 <code>.bak</code> 后缀的方式进行区分保存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 rabbitmq]# ls - al</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 22646 Jul 23 00:50 rabbit@node1.log.bak</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1-sasl.log</span><br><span class="line">-rw-r--r-- 1 root root     0 Jul 23 00:50 rabbit@node1-sasl.log.bak</span><br></pre></td></tr></table></figure><p>也可以执行一个定时任务，比如使用 <code>Linux crontab</code> ，以当前日期为后缀，每天执行一次切换日志的任务，这样在后面需要查阅日志的时候可以根据日期快速定位到相应的日志文件。</p><p>RabbitMQ 还可以通过程序化的方式来查看相应的日志， 默认会创建一些交换器， 其中 <code>amq.rabbitmq.log</code> 就是用来收集 RabbitMQ 日志的，集群中所有的服务日志都会发往这个交换器中。这个交换器的类型为 topic ，可以收集如前面所说的 debug、info、warning、error 4个级别的日志。</p><p>首先确认是否创建 <code>amq.rabbitmq.log</code> 交换器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl list_exchanges</span><br><span class="line">Listing exchanges for vhost / ...</span><br><span class="line">name    type</span><br><span class="line">exchange_demo   direct</span><br><span class="line">amq.fanout      fanout</span><br><span class="line">amq.rabbitmq.trace      topic</span><br><span class="line">myAe    fanout</span><br><span class="line">amq.headers     headers</span><br><span class="line">amq.topic       topic</span><br><span class="line">amq.direct      direct</span><br><span class="line">normalExchange  direct</span><br><span class="line">        direct</span><br><span class="line">amq.match       headers</span><br></pre></td></tr></table></figure><p>配置文件 <code>vi /etc/rabbitmq/rabbitmq.conf</code> （没有就新建）开启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.exchange = true</span><br></pre></td></tr></table></figure><p>重启下RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmqctl stop</span><br><span class="line">Stopping and halting node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmq-server restart</span><br><span class="line">Configuring logger redirection</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##      RabbitMQ 3.8.8</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Copyright (c) 2007-2020 VMware, Inc. or its affiliates.</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#####  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Licensed under the MPL 2.0. Website: https://rabbitmq.com</span></span></span><br><span class="line"></span><br><span class="line">  Doc guides: https://rabbitmq.com/documentation.html</span><br><span class="line">  Support:    https://rabbitmq.com/contact.html</span><br><span class="line">  Tutorials:  https://rabbitmq.com/getstarted.html</span><br><span class="line">  Monitoring: https://rabbitmq.com/monitoring.html</span><br><span class="line"></span><br><span class="line">  Logs: /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">        /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ_upgrade.log</span><br><span class="line"></span><br><span class="line">  Config file(s): /etc/rabbitmq/rabbitmq.conf</span><br><span class="line"></span><br><span class="line">  Starting broker... completed with 4 plugins.</span><br></pre></td></tr></table></figure><p>可以看到交换器已启动：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010117.png" alt></p><p>分别创建四个日志队列，并采用相应的路由键来绑定 <code>amq.rabbitmq.log</code> 交换器，如果想用一个日志队列收集所有级别日志可以使用 <code>#</code> 这个路由键。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010116.png" alt></p><p>编写代码打印对应级别日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建连接</span></span><br><span class="line">            Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">            &#125;;</span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">            factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">            factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">            Connection connection = factory.newConnection(addresses);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建对应日志级别的信道</span></span><br><span class="line">            Channel channelDebug = connection.createChannel();</span><br><span class="line">            Channel channelInfo = connection.createChannel();</span><br><span class="line">            Channel channelWarn = connection.createChannel();</span><br><span class="line">            Channel channelError = connection.createChannel();</span><br><span class="line">            channelDebug.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelInfo.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelWarn.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelError.basicQos(<span class="number">1</span>);</span><br><span class="line">            channelDebug.basicConsume(<span class="string">"queue.debug"</span>, <span class="keyword">false</span>, <span class="string">"DEBUG"</span>, <span class="keyword">new</span> ConsumerThread(channelDebug));</span><br><span class="line">            channelInfo.basicConsume(<span class="string">"queue.info"</span>, <span class="keyword">false</span>, <span class="string">"INFO "</span>, <span class="keyword">new</span> ConsumerThread(channelInfo)) ;</span><br><span class="line">            channelWarn.basicConsume(<span class="string">"queue.warning"</span>, <span class="keyword">false</span>, <span class="string">"WARNING"</span>, <span class="keyword">new</span> ConsumerThread(channelWarn)) ;</span><br><span class="line">            channelError.basicConsume(<span class="string">"queue.error"</span>, <span class="keyword">false</span>, <span class="string">"ERROR"</span>, <span class="keyword">new</span> ConsumerThread(channelError)) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String log = <span class="keyword">new</span> String(body);</span><br><span class="line">            System.out.println(<span class="string">"="</span> + consumerTag + <span class="string">" REPORT====\n"</span> + log);</span><br><span class="line">            <span class="comment">//对日志进行处理</span></span><br><span class="line">            getChannel().basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">INFO</span>  REPORT====</span><br><span class="line"><span class="number">2020</span>-<span class="number">10</span>-<span class="number">09</span> <span class="symbol">16:00</span><span class="symbol">:19</span>.<span class="number">709</span> [<span class="built_in">info</span>] &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; accepting AMQP connection &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; (<span class="number">115.236</span>.<span class="number">91.15</span><span class="symbol">:64187</span> -&gt; <span class="number">172.17</span>.<span class="number">48.148</span><span class="symbol">:5672</span>)</span><br><span class="line"></span><br><span class="line">=<span class="built_in">INFO</span>  REPORT====</span><br><span class="line"><span class="number">2020</span>-<span class="number">10</span>-<span class="number">09</span> <span class="symbol">16:00</span><span class="symbol">:19</span>.<span class="number">978</span> [<span class="built_in">info</span>] &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; connection &lt;<span class="number">0.1768</span>.<span class="number">0</span>&gt; (<span class="number">115.236</span>.<span class="number">91.15</span><span class="symbol">:64187</span> -&gt; <span class="number">172.17</span>.<span class="number">48.148</span><span class="symbol">:5672</span>)<span class="symbol">:</span> user 'root' authenticated <span class="built_in">and</span> granted access to vhost '/'</span><br></pre></td></tr></table></figure><p>要注意的是各个节点对应级别的日志是交错在一起的。可以通过检索日志的 running_partitioned_network 关键字来及时地探测到<strong>网络分区</strong>的发生，之后可以迅速采取措施以保证集群服务的鲁棒性。当然对于日志的监控处理也可以采用第3方工具实现，如 Logstash 等。</p><h2 id="第三节-单点故障恢复"><a href="#第三节-单点故障恢复" class="headerlink" title="第三节 单点故障恢复"></a>第三节 单点故障恢复</h2><h3 id="3-1-什么是单点故障"><a href="#3-1-什么是单点故障" class="headerlink" title="3.1 什么是单点故障"></a>3.1 什么是单点故障</h3><p>对于集群层面来说，经常遇到的是单点故障。所谓的单点故障是指集群中单个节点发生了故障，有可能会引起集群服务不可用、数据丢失等异常。配置数据节点冗余（镜像队列）可以有效地防止由于单点故障而降低整个集群的可用性、可靠性。</p><h3 id="3-2-四种常见的单点故障"><a href="#3-2-四种常见的单点故障" class="headerlink" title="3.2 四种常见的单点故障"></a>3.2 四种常见的单点故障</h3><p>单节点故障包括：</p><ul><li><strong>机器硬件故障</strong>：包括机器硬盘、内存、主板等故障造成的死机，无法从软件角度来恢复。<ul><li>此时需要在集群中的其他节点中执行 <code>rabbitmqctl forget_cluster_node {nodename}</code> 命令来将故障节点剔除，其中 nodename 表示故障机器节点名称。</li><li>如果之前有客户端连接到此故障节点上，在故障发生时会有异常报出，此时需要将故障节点的IP地址从连接列表里删除，并让客户端重新与集群中的节点建立连接，以恢复整个应用。</li></ul></li><li><strong>机器掉电</strong>：需要等待电源接通之后重启机器。<ul><li>此时这个机器节点上的 RabbitMQ 处于 stop 状态，但是此时不要盲目重启服务，否则可能会引起<strong>网络分区</strong>。</li><li>此时需要在集群中的其他节点中执行 <code>rabbitmqctl forget_cluster_node {nodename}</code> 命令来将故障节点剔除。</li><li>然后删除当前故障机器的 RabbitMQ 中的 Mnesia 数据（相当于重置）。</li><li>然后再重启 RabbitMQ 服务。</li><li>最后再将此节点作为一个新的节点加入到当前集群中。</li></ul></li><li><strong>网络异常</strong>：网线松动或者网卡损坏都会引起网络故障的发生。<ul><li>对于网线松动，无论是彻底断开，还是“藕断丝连”，只要它不降速， RabbitMQ 集群就没有任何影响。但是为了保险起见，建议先关闭故障机器的 RabbitMQ 进程，然后对网线进行更换或者修复操作，之后再考虑是否重新开启 RabbitMQ 进程。</li><li>网卡故障极易引起<strong>网络分区</strong>的发生，如果监控到网卡故障而网络分区尚未发生时，理应第一时间关闭此机器节点上的 RabbitMQ 进程，在网卡修复之前不建议再次开启。 如果己经发生了网络分区，可以参考 10.5 节进行手动恢复网络分区。</li></ul></li><li><strong>服务进程异常</strong>：如 RabbitMQ 进程非预期终止，需要预先思考相关风险是否在可控范围之内。如果风险不可控，可以选择抛弃这个节点。一般情况下，重新启动 RabbitMQ 服务进程即可。</li></ul><h2 id="第四节-集群迁移"><a href="#第四节-集群迁移" class="headerlink" title="第四节 集群迁移"></a>第四节 集群迁移</h2><p>扩容比较简单，一般向集群中加入新的集群节点即可，不过新的机器节点中是没有队列创建的，只有后面新创建的队列才有可能进入这个新的节点中。或者如果集群配置了镜像队列，可以通过系列操作将原先队列“漂移”到这个新的节点中，具体可以参考第 10.5 节。</p><p>迁移同样可以解决扩容的问题，将旧的集群中的数据（包括元数据信息和消息）迁移到新的且容量更大的集群中即可。 RabbitMQ 中的集群迁移更多的是<strong>用来解决集群故障不可短时间内修复而将所有的数据、客户端连接等迁移到新的集群中，以确保服务的可用性</strong>。相比于单点故障而言，集群故障的危害性就大得多，比如 IDC 整体停电、网线被挖断等。这时候就需要通过集群迁移重新建立起一个新的集群。</p><h3 id="4-1-准备阶段-元数据重建"><a href="#4-1-准备阶段-元数据重建" class="headerlink" title="4.1 准备阶段-元数据重建"></a>4.1 准备阶段-元数据重建</h3><p>元数据重建是指在新的集群中创建原集群的队列交换器、绑定关系、 host、用户、权限 Parameter 等数据信息。元数据重建是集群迁移前的准备工作，之后才可将原集群中的消息及客户端连接迁移过来。</p><p>实现方式：</p><ul><li>手工创建：</li><li>客户端创建：</li></ul><p>元数据的整理十分繁琐，需要如Web管理工具的辅助：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010118.png" alt></p><p>可以在原集群上点击 <code>Download broker definitions</code> 按钮下载集群的元数据信息文件，此文件是 JSON 文件，比如叫 metadata.json 。</p><p>之后再在新集群上的 Web 管理界面中点击 <code>Upload broker definitions</code> 按钮上传 metadata.json 文件。</p><p>如果导入成功则会跳转到成功页面，这样就迅速在新集群中创建了元数据信息。如果新集群有数据与 metadata.json 中的数据相冲突，对于交换器、队列及绑定关系这类非可变对象而言会报错，而对于其他可变对象如 Parameter、用户等则会被覆盖，没有发生冲突的则不受影响。如果过程中发生错误，则导入过程终止，导致 metadata.json 中只有部分数据加载成功。</p><p>三个问题：</p><ol><li><p>如果原集群突发故障，又或者开启 RabbitMQ Management 插件的那个节点机器故障不可修复，就无法获取原集群的元数据 metadata.json。</p><ul><li>这个问题很好解决，采取一个通用的备份任务，在元数据有变更或者达到某个存储周期时将最新的 metadata.json 备份至另一处安全的地方。这样在遇 到需要集群迁移时，可以获取到最新的元数据。</li></ul></li><li><p>如果新旧集群的 RabbitMQ 版本不一致时会出现异常情况。一般情况下 RabbitMQ 是能够做到向下兼容的，在高版本的 RabbitMQ 中可以上传低版本的元数据文件。然而如果在低版本中上传高版本的元数据文件就没有那么顺利了。</p><ul><li>比如 3.5.7 版本与 3.6.10 版本的加密算法不一样，就会出现用户登录失败的情况，可以简单地在 Shell 控制台输入变更密码的方式来解决这个问题：<code>rabbitmqctl change_password {username} {new_password}</code> 。</li><li>如果还是不能成功上传元数据，我们要先清楚对于用户、策略、权限这种元数据来说内容相对固定，且内容较少，手工重建的代价较小。集群中元数据最多且最复杂的要数队列、交换器和绑定这三项的内容，如果采用人工重建的方式代价太大，重建元数据的意义其实就在于重建队列、交换器及绑定这三项的相关信息。</li><li>可以将 3.6.10 的元数据从 queues 这一项前面的内容，包括 rabbit_version、users、vhosts、permissions、parameters、global_parameters 和 policies 这几项内容复制后替换 3.5.7 版本中的 queues 这一项前面的所有内容，然后再保存。之后将修改并保存过后的 3.5.7 版本的元数据 JSON 文件上传到新集群 3.6.10 版本的 Web 管理界面中，至此就完成了集群的元数据重建。</li></ul></li><li><p>第三个问题就是如果采用上面的方法将元数据在新集群上重建，则所有的队列都只会落到同一个集群节点上，而其他节点处于空置状态，这样所有的压力将会集中到这单台节点之上。</p><p>两种解决方案，都是通过程序或脚本的形式在新集群上建立元数据：</p><ul><li><p>通过 HTTP API 接口创建相应的数据：</p><ul><li><p>引入gson：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>三个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> Boolean durable;</span><br><span class="line"><span class="keyword">private</span> Boolean auto_delete;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchange</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="keyword">private</span> Boolean durable;</span><br><span class="line"><span class="keyword">private</span> Boolean auto_delete;</span><br><span class="line"><span class="keyword">private</span> Boolean internal;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binding</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String source;</span><br><span class="line"><span class="keyword">private</span> String vhost;</span><br><span class="line"><span class="keyword">private</span> String destination;</span><br><span class="line"><span class="keyword">private</span> String destination_type;</span><br><span class="line"><span class="keyword">private</span> String routing_key;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String , Object&gt; arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析原集群的 metadata.json 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Queue&gt; queueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Exchange&gt; exchangeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Binding&gt; bindingList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseJson</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JsonObject json = (JsonObject) parser.parse(<span class="keyword">new</span></span><br><span class="line">                    FileReader(filename));</span><br><span class="line">            JsonArray jsonQueueArray = json.get(<span class="string">"queues"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonQueueArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonQueueArray.get(i).getAsJsonObject();</span><br><span class="line">                Queue queue = parseQueue(subObject);</span><br><span class="line">                queueList.add(queue);</span><br><span class="line">            &#125;</span><br><span class="line">            JsonArray jsonExchangeArray =</span><br><span class="line">                    json.get(<span class="string">"exchanges"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonExchangeArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonExchangeArray.get(i).getAsJsonObject();</span><br><span class="line">                Exchange exchange = parseExchange(subObject);</span><br><span class="line">                exchangeList.add(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">            JsonArray jsonBindingArray = json.get(<span class="string">"bindings"</span>).getAsJsonArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonBindingArray.size(); i++) &#123;</span><br><span class="line">                JsonObject subObject = jsonBindingArray.get(i).getAsJsonObject();</span><br><span class="line">                Binding binding = parseBinding(subObject);</span><br><span class="line">                bindingList.add(binding);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析队列信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Queue <span class="title">parseQueue</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.setName(subObject.get(<span class="string">"name"</span>).getAsString());</span><br><span class="line">        queue.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        queue.setDurable(subObject.get(<span class="string">"durable"</span>).getAsBoolean());</span><br><span class="line">        queue.setAuto_delete(subObject.get(<span class="string">"auto_delete"</span>).getAsBoolean());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        queue.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析交换器信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Exchange <span class="title">parseExchange</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略，具体参考 parseQueue 方法进行推演</span></span><br><span class="line">        Exchange exchange = <span class="keyword">new</span> Exchange();</span><br><span class="line">        exchange.setName(subObject.get(<span class="string">"name"</span>).getAsString());</span><br><span class="line">        exchange.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        exchange.setType(subObject.get(<span class="string">"type"</span>).getAsString());</span><br><span class="line">        exchange.setDurable(subObject.get(<span class="string">"durable"</span>).getAsBoolean());</span><br><span class="line">        exchange.setInternal(subObject.get(<span class="string">"internal"</span>).getAsBoolean());</span><br><span class="line">        exchange.setAuto_delete(subObject.get(<span class="string">"auto_delete"</span>).getAsBoolean());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        exchange.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析绑定信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Binding <span class="title">parseBinding</span><span class="params">(JsonObject subObject)</span> </span>&#123;</span><br><span class="line">        Binding binding = <span class="keyword">new</span> Binding();</span><br><span class="line">        binding.setSource(subObject.get(<span class="string">"source"</span>).getAsString());</span><br><span class="line">        binding.setVhost(subObject.get(<span class="string">"vhost"</span>).getAsString());</span><br><span class="line">        binding.setDestination(subObject.get(<span class="string">"destination"</span>).getAsString());</span><br><span class="line">        binding.setDestination_type(subObject.get(<span class="string">"destination_type"</span>).getAsString());</span><br><span class="line">        binding.setRouting_key(subObject.get(<span class="string">"routing_key"</span>).getAsString());</span><br><span class="line">        JsonObject argsObject = subObject.get(<span class="string">"arguments"</span>).getAsJsonObject();</span><br><span class="line">        Map&lt;String, Object&gt; map = parseArguments(argsObject);</span><br><span class="line">        binding.setArguments(map);</span><br><span class="line">        <span class="keyword">return</span> binding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析参数 arguments 项内容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">parseArguments</span><span class="params">(JsonObject argsObject)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;Map.Entry&lt;String, JsonElement&gt;&gt; entrySet = argsObject.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, JsonElement&gt; mapEntry : entrySet) &#123;</span><br><span class="line">            map.put(mapEntry.getKey(), mapEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在解析完队列、交换器及绑定关系之后，只需要遍历 queueList、exchangeList、bindingList ，然后调用 HTTP API 创建相应的数据即可。随机挑选一个节点并明确指明了 node 节点这一参数来创建队列，如此便可解决集群内部队列分布不均匀的问题。当然首先需要确定新集群中节点名称的列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ip = <span class="string">"192.168.0.2"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String username = <span class="string">"root "</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String password = <span class="string">"rootl23"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; nodeList =<span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"rabbit@node1"</span>);</span><br><span class="line">    add(<span class="string">"rabbit@node2"</span>);</span><br><span class="line">    add(<span class="string">"rabbit@node3"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createQueues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queueList.size(); i++) &#123;</span><br><span class="line">            Queue queue = queueList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = String.format(<span class="string">"http://%s:l5672/api/queues/%s/%s"</span>, ip,</span><br><span class="line">                    encode(queue.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                    encode(queue.getName(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"auto_delete"</span>, queue.getAuto_delete());</span><br><span class="line">            map.put(<span class="string">"durable"</span>, queue.getDurable());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, queue.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建交换器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createExchanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exchangeList.size(); i++) &#123;</span><br><span class="line">            Exchange exchange = exchangeList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = String.format(<span class="string">"http://%s:l5672/api/exchanges/%s/%s"</span>, ip,</span><br><span class="line">                    encode(exchange.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                    encode(exchange.getName(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"auto_delete"</span>, exchange.getAuto_delete());</span><br><span class="line">            map.put(<span class="string">"durable"</span>, exchange.getDurable());</span><br><span class="line">            map.put(<span class="string">"type"</span>, exchange.getType());</span><br><span class="line">            map.put(<span class="string">"internal"</span>, exchange.getInternal());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, exchange.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//创建绑定关系</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">createBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略, 具体参考 createQueues 方法进行推演, 关键信息如 url</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bindingList.size(); i++) &#123;</span><br><span class="line">            Binding binding = bindingList.get(i);</span><br><span class="line">            <span class="comment">//注意将特殊字符转义, 比如默认的 vhost ,  将其转成 %2F</span></span><br><span class="line">            String url = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//绑定有两种 交换器与队列, 交换器与交换器</span></span><br><span class="line">            <span class="keyword">if</span> (binding.getDestination_type().equals(<span class="string">"queue"</span>) )&#123;</span><br><span class="line">                url = String.format(<span class="string">"http://%s:l5672/api//bindings/%s/e/%s/q/%s"</span>, ip,</span><br><span class="line">                        encode(binding.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getSource(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getDestination(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                url = String.format(<span class="string">"http://%s:l5672/api//bindings/%s/e/%s/e/%s"</span>, ip,</span><br><span class="line">                        encode(binding.getVhost(), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getSource (), <span class="string">"UTF-8"</span>),</span><br><span class="line">                        encode(binding.getDestination(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"destination"</span>, binding.getDestination());</span><br><span class="line">            map.put(<span class="string">"destination_type"</span>, binding.getDestination_type());</span><br><span class="line">            map.put(<span class="string">"routing_key"</span>, binding.getRouting_key());</span><br><span class="line">            map.put(<span class="string">"arguments"</span>, binding.getArguments());</span><br><span class="line">            <span class="comment">//随机挑选一个节点, 并在此节点上创建相应的队列</span></span><br><span class="line">            <span class="comment">// int index = (int) (Math.random() * nodeList.size());</span></span><br><span class="line">            <span class="comment">// map.put("node", nodeList.get(index));</span></span><br><span class="line">            Collections.shuffle(nodeList);</span><br><span class="line">            map.put(<span class="string">"node"</span>, nodeList.get(<span class="number">0</span>));</span><br><span class="line">            String data = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line">            System.out.println(url);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            httpPut(url, data, username, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// http post</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">httpPut</span><span class="params">(String url, String data, String username, String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">            <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">    PutMethod putMethod = <span class="keyword">new</span> PutMethod(url);</span><br><span class="line">    putMethod.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">    putMethod.setRequestEntity(<span class="keyword">new</span> StringRequestEntity(data, <span class="string">"application/json"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">    <span class="keyword">int</span> statusCode = client.executeMethod(putMethod);</span><br><span class="line">    <span class="comment">//System.out.println(statusCode);</span></span><br><span class="line">    <span class="keyword">return</span> statusCode;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">httpPost</span><span class="params">(String url, String data, String username, String password)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//省略, 具体参考 httpPut 方法进行推演</span></span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">            <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">    PostMethod postMethod = <span class="keyword">new</span> PostMethod(url);</span><br><span class="line">    postMethod.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">    postMethod.setRequestEntity(<span class="keyword">new</span> StringRequestEntity(data, <span class="string">"application/json"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">    <span class="keyword">int</span> statusCode = client.executeMethod(postMethod);</span><br><span class="line">    <span class="comment">//System.out.println(statusCode);</span></span><br><span class="line">    <span class="keyword">return</span> statusCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 Gson 解析 metadata.json 文件，进而使用 HttpClient 调用相应的 HTTP API 在随机的节点上创建相应的队列进程，从而达到了集群节点负载均衡的目的。</p></li><li><p>HttpClient需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-httpclient<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过随机连接集群中不同的节点的IP地址，然后再创建队列。与前一种方式需要节点名称的列表不同，这里需要的是节点IP地址列表：</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ipList = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="string">"192.168.0.2"</span>);</span><br><span class="line">    add(<span class="string">"192.168.0.3"</span>);</span><br><span class="line">    add(<span class="string">"192.168.0.4"</span>); </span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>客户端通过连接不同的IP地址来创建不同的 connection 和 channel ，然后将 channel 存入一个缓冲池，之后从 channelList 中获取一个 channel ，再根据 queueList 中的信息创建相应的队列。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010119.png" alt></p></li><li><p>每一个 channel 对应一个 connection，而每一个 connection 又对应一个 IP ，这样串起来就能保证 channelList 中不会遗留任何节点，最终实现与第一种方式相同的功能。对应的队列创建代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createQueuesNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Channel&gt; channelList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Connection&gt; connectionList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ipList.size();i++) &#123;</span><br><span class="line">            String ip = ipList.get(i);</span><br><span class="line">            ConnectionFactory connectionFactory =<span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">            connectionFactory.setUsername(username);</span><br><span class="line">            connectionFactory.setPassword(password);</span><br><span class="line">            connectionFactory.setHost(ip);</span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            Connection connection = connectionFactory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            channelList.add(channel) ;</span><br><span class="line">            connectionList.add(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        createQueueByChannel(channelList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace() ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connection connection : connectionList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createQueueByChannel</span><span class="params">(List&lt;Channel&gt; channelList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queueList.size(); i++) &#123;</span><br><span class="line">        Queue queue = queueList.get(i);</span><br><span class="line">        <span class="comment">//随机获取相应的 channel</span></span><br><span class="line">        Collections.shuffle(channelList);</span><br><span class="line">        Channel channel = channelList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, Object&gt; mapArgs = queue.getArguments();</span><br><span class="line">            <span class="comment">//do something with mapArgs.</span></span><br><span class="line">            channel.queueDeclare(queue.getName(), queue.getDurable(),</span><br><span class="line">                    <span class="keyword">false</span>, queue.getAuto_delete(), mapArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="4-2-数据迁移和客户端连接的切换"><a href="#4-2-数据迁移和客户端连接的切换" class="headerlink" title="4.2 数据迁移和客户端连接的切换"></a>4.2 数据迁移和客户端连接的切换</h3><p>首先需要将生产者的客户端与原 RabbitMQ 集群的连接断开，然后再与新的集群建立新的连接，这样就可以将新的消息流转入到新的集群中。</p><p>之后就需要考虑消费者客户端的事情，一 种是等待原集群中的消息全部消费完之后再将连接断开，然后与新集群建立连接进行消费作业。</p><p>当原集群服务不可用或者出现故障造成服务质量下降而需要迅速将消息流切换到新的集群中时，此时就不能等待消费完原集群中的消息，这里需要及时将消费者客户端的连接切换到新的集群中，那么在原集群中就会残留部分未被消费的消息，此时需要做进一步的处理。如果原集群损坏，可以等待修复之后将数据迁移到新集群中，否则会丢失数据。</p><p><strong>数据迁移的主要原理</strong>是先从原集群中将数据消费出来，然后存入一个缓存区中，另一个线程读取缓存区中的消息再发布到新的集群中，如此便完成了数据迁移的动作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010120.png" alt></p><p>RabbitMQ提供的 Federation 和 Shovel 都可以实现 ForwardMaker 功能。</p><h3 id="4-3-自动化迁移"><a href="#4-3-自动化迁移" class="headerlink" title="4.3 自动化迁移"></a>4.3 自动化迁移</h3><p>要实现集群自动化迁移，需要在使用相关资源时就做好一些准备工作，方便在自动化迁移过程中进行无缝切换。</p><h4 id="4-3-1-使用资源的3个部分"><a href="#4-3-1-使用资源的3个部分" class="headerlink" title="4.3.1 使用资源的3个部分"></a>4.3.1 使用资源的3个部分</h4><p>与生产者和消费者客户端相关的是交换器、队列及集群的信息，如果这种类型的资源发生改变时需要让客户端迅速感知，以便进行相应的处理，则可以通过将相应的资源加载到 ZooKeeper 的相应节点中，然后在客户端为对应的资源节点加入 watcher 来感知变化， 当然这个功能使用 etcd 或者集成到公司层面的资源配置中心中会更加标准、高效。</p><p>如图将整个 RabbitMQ 集群资源的使用分为3个部分：</p><ul><li>客户端、</li><li>集群、</li><li>ZooKeeper 配置管理。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010121.png" alt></p><h4 id="4-3-2-自动化迁移过程"><a href="#4-3-2-自动化迁移过程" class="headerlink" title="4.3.2 自动化迁移过程"></a>4.3.2 自动化迁移过程</h4><p>在集群中<strong>创建元数据资源</strong>时都需要在 ZooKeeper 中生成相应的配置：</p><ul><li><p>比如在 cluster1 集群中创建交换器 exchange1 之后，需要在 /rmqNode/exchanges 路径下创建实节点 exchange1。并赋予节点的数据内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cluster=cluster1</span> <span class="comment"># 表示此交换器所在的集群名称</span></span><br><span class="line"><span class="string">exchangeType=direct</span> <span class="comment"># 表示此交换器的类型</span></span><br><span class="line"><span class="string">vhost=vhost1</span> <span class="comment"># 表示此交换器所在的 vhost</span></span><br><span class="line"><span class="string">username=root</span> <span class="comment"># 表示用户名</span></span><br><span class="line"><span class="string">password=root123</span> <span class="comment"># 表示密码</span></span><br></pre></td></tr></table></figure></li><li><p>在 cluster1 集群中创建队列 queue1 之后，需要在 /rmqNode/queues 路径下创建实节点 queue1 ，并赋予节点的数据内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cluster=cluster1</span></span><br><span class="line"><span class="string">bindings=exchange1</span> <span class="comment"># 表示此队列所绑定的交换器</span></span><br><span class="line"><span class="comment"># 如果有需要，也可以添加一些其他信息，比如路由键等</span></span><br><span class="line"><span class="string">vhost=vhost1</span></span><br><span class="line"><span class="string">username=root</span></span><br><span class="line"><span class="string">password=root123</span></span><br></pre></td></tr></table></figure></li><li><p>对应集群的数据在 /rmqNode/clusters 路径下，比如 cluster 集群，其对应节点的数据内容包含 IP 地址列表信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ipList=192.168.0.2,</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span><span class="string">,</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span> <span class="comment"># 集群中各个节点的 IP 地址信息</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>客户端程序</strong>如果与其上的交换器或者队列进行交互，那么需要在相应的 <strong>ZooKeeper 节点中添加 watcher</strong> ，以便在数据发生变更时进行相应的变更，从而达到自动化迁移的目的。</p><p><strong>生产者客户端</strong>：</p><ul><li>在发送消息之前需要先连接 ZooKeeper，</li><li>然后根据指定的交换器名称如 exchange1 找到相应的路径 /rmqNode/exchanges 中寻找 exchange1 的节点，</li><li>之后再读取节点中的数据，井同时对此节点添加 watcher 。</li><li>在节点的数据第一条 <code>cluster=cluster1</code> 中找到交换器所在的集群名称，</li><li>然后再从路径 /rmqNode/clusters 中寻找 cluster1 节点，</li><li>然后读取其对应 IP 地址列表信息。</li><li>这样整个发送端所需要的连接串数据 (IP地址列表、vhost、usemame、password 等）都己获取，接下就可以与 RabbitMQ 集群 cluster 建立连接然后发送数据了。 </li></ul><p>对于<strong>消费者客户端</strong>而言：</p><ul><li>同样需要连接 ZooKeeper ，</li><li>之后根据指定的队列名称（queue1) 到相应的路径 /rmqNode/queues 中寻找 queue1 节点，</li><li>继而找到相应的连接串，</li><li>然后与 RabbitMQ 集群 cluster1 建立连接进行消费。</li><li>当然对 /rmqNode/queues/queue1 节点的 watcher 必不可少。</li></ul><p>当 cluster1 集群需要迁移到 cluster2 集群时：</p><ul><li>首先需要将 cluster1 集群中的元数据在 cluster2 集群中重建。</li><li>之后通过修改 channel 和 queue 元数据信息：<ul><li>比如原 cluster1 集群中有交换 exchange1、exchange2 和队列 queue1、queue2 ，</li><li>现在通过脚本或者程序将其中的 <code>cluster=cluster1</code> 数据修改为 <code>cluster=cluster2</code> 。</li><li>客户端会立刻感知节点的变化，然后迅速关闭当前连接之后再与新集群 cluster2 建立新的连接后生产和消费消息，在此切换客户端连接的过程中是可以保证数据零丢失的。</li></ul></li><li>迁移之后，生产者和消费者都会与 cluster2 集群进行互通，此时原 cluster 集群中可能还有未被消费完的数据，此时需要使用 RabbitMQ ForwardMaker 工具将 cluster1 集群中未被消费完的数据同步到 cluster2 集群中。</li></ul><p>如果没有准备 RabbitMQ ForwardMaker 工具，也不想使用 Federation 或者 Shovel 插件，那么在变更完交换器相关的 ZooKeeper 中的节点数据之后，需要等待原集群中的所有队列都消费完全之后，再将队列相关的 ZooKeeper 中的节点数据变更，进而使得消费者的连接能够顺利迁移到新的集群之上。可以通过下面的命令来查看是否有队列中的消息未被消费完：</p><p><code>rabbitmqctl list_queues -p / -q | awk &#39;{if($2&gt;0) print $0 }&#39;</code></p><h4 id="4-3-3-空闲备份集群解决方案"><a href="#4-3-3-空闲备份集群解决方案" class="headerlink" title="4.3.3 空闲备份集群解决方案"></a>4.3.3 空闲备份集群解决方案</h4><p>上面的自动化迁移立足于将现有集群迁移到空闲的备份集群，如果由于原集群硬件升级等原因迁移也无可厚非。很多情况下，自动化迁移作为容灾手段中的一种，如果有很多个正在运行的 RabbitMQ 集群，为每个集群都配备一个空闲的备份集群无疑是一种资源的浪费。当然可以采取几个集群共用一个备份集群来减少这种浪费，那么有没有更优的解决方案呢？</p><p>就以4个 RabbitMQ 集群为例，其被分配4个独立的业务使用。如图 7-8 所示， 当 cluster1 集群中的元数据备份到 cluster2 集群中，而 cluster2 集群中的元数据备份到 cluster3 集群中，如此可以两两互备。<strong>比如在 cluster1 集群中创建了一个交换器 exchange1 ，此时需要在 cluster2 集群中同样创建一个交换器 exchange1</strong> 。在正常情况下，使用的是 cluster1 集群中的 exchange1 ，而 exchange1 在 cluster2 集群中只是一份记录，并不消耗 cluster2 集群的任何性能。而当需要将 cluster1 迁移时，只需要将交换器及队列相对应的 ZooKeeper 节点数据项变更即可完成迁移的工作。如此既不用耗费额外的硬件资源，又不用再迁移的时候重新建立元数据信息。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010122.png" alt></p><p>为了更加稳妥起见，也可以准备一个空闲的备份集群以备后用。当 cluster1 集群需要迁移 cluster2 集群中时， cluster2 集群己经发生故障被关闭或者被迁移到 cluster3 集群中了，那么这个空闲的备份集群可以当作 Plan B 来增强整体服务的可靠性。如果既想不浪费多余的硬件资源又想具备更加稳妥的措施，可以参考图 7-9 ，将 cluster1 中的元数据备份到 cluster2、cluster3 中，这样以1备2的方式即可解决这个难题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010123.png" alt></p><p>对于上面介绍的多集群间互备的解决方案需要配套一个完备的实施系统，比如具备资源管理、执行下发、数据校对等功能，并且对于 ZooKeepe 节点中的数据项设计也需要细细斟酌，最好能够根据实际使用情况将这些整合到一个大的平台化系统之中。</p><h2 id="第五节-集群监控"><a href="#第五节-集群监控" class="headerlink" title="第五节 集群监控"></a>第五节 集群监控</h2><p>监控不仅可以提供运行时的数据为应用提供依据参考，还可以迅速定位问题、提供预防及告警等功能，很大程度上增强了整体服务的鲁棒性。</p><p>RabbitMQ Management 插件就能提供一定的监控功能：如发送速度、确认速度、消费速度、消息总数、磁盘读写速度、句柄数、Socket 连接数、 Connection 数、 Channel 数、内存信息等。但是有一个遗憾就是其难以和公司内部系统平台关联，对于业务资源的使用情况、相应的预防及告警的联动无法顺利贯通。如果在人力、物力等条件允许的情况下，自定义一套监控系统非常有必要。</p><h3 id="5-1-通过HTTP-API接口提供监控数据"><a href="#5-1-通过HTTP-API接口提供监控数据" class="headerlink" title="5.1 通过HTTP API接口提供监控数据"></a>5.1 通过HTTP API接口提供监控数据</h3><p>RabbitMQ Management 插件提供了HTTP API接口来提供监控数据。</p><p>假设集群中一共有4个节点：nod1、node2、node3、node4 。有一个交换器 exchange 通过同一个路由键“rk”绑定了3个队列 quue1、queue2 和 queue3。</p><p>首先可以通过 /api/nodes 接口来收集集群节点的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> diskFree;<span class="comment">//磁盘空闲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> diskFreeLimit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fdUsed;<span class="comment">//句柄使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fdTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> socketsUsed;<span class="comment">//Socket 使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> socketsTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> memoryUsed;<span class="comment">//内存使用值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> memoryLimit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> procUsed;<span class="comment">//Erlang 进程使用数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> procTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;disk_free="</span> + diskFree + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"disk_free_limit="</span> + diskFreeLimit + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"fd_used= "</span> + fdUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"fd_total = "</span> + fdTotal + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"sockets_used= "</span> + socketsUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"sockets_total= "</span> + socketsTotal + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"mem_used= "</span> + memoryUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"mem_limit= "</span> + memoryLimit + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"proc_used="</span> + procUsed + <span class="string">", "</span> +</span><br><span class="line">                <span class="string">"proc_total="</span> + procTotal + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装一下HTTP GET，方便后续程序直接调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">httpGet</span><span class="params">(String url, String username, String password)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        client.getState().setCredentials(AuthScope.ANY,</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordCredentials(username, password));</span><br><span class="line">        GetMethod getMethod = <span class="keyword">new</span> GetMethod(url) ;</span><br><span class="line">        <span class="keyword">int</span> ret = client.executeMethod(getMethod);</span><br><span class="line">        String data = getMethod.getResponseBodyAsString();</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 HTTP GET 方法获取 <code>http://xx.xxx.xxx.xxx:15672/api/nodes</code> 的 JSON 数据，然后通过 GSON 进行解析， 之后即可采集到感兴趣的数据项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ClusterNode&gt; <span class="title">getClusterData</span><span class="params">(String ip, <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               String username, String password)</span> </span>&#123;</span><br><span class="line">    List&lt;ClusterNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String url = <span class="string">"http://"</span> + ip + <span class="string">":"</span> + port + <span class="string">"/api/nodes"</span>;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String urlData = HttpUtils.httpGet(url, username, password);</span><br><span class="line">        parseClusters(urlData, list);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseClusters</span><span class="params">(String urlData, List&lt;ClusterNode&gt; list)</span> </span>&#123;</span><br><span class="line">    JsonParser parser= <span class="keyword">new</span> JsonParser();</span><br><span class="line">    JsonArray jsonArray =(JsonArray) parser.parse(urlData);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ;i &lt; jsonArray.size(); i++) &#123;</span><br><span class="line">        JsonObject jsonObjectTemp = jsonArray.get(i).getAsJsonObject();</span><br><span class="line">        ClusterNode cluster = <span class="keyword">new</span> ClusterNode();</span><br><span class="line">        cluster.setDiskFree(jsonObjectTemp.get(<span class="string">"disk_free"</span>).getAsLong());</span><br><span class="line">        cluster.setDiskFreeLimit(jsonObjectTemp.get(<span class="string">" disk_free_limit"</span>).</span><br><span class="line">                getAsLong());</span><br><span class="line">        cluster.setFdUsed(jsonObjectTemp.get(<span class="string">"fd_used"</span>).getAsLong());</span><br><span class="line">        cluster.setFdTotal(jsonObjectTemp.get(<span class="string">"fd_total"</span>).getAsLong() );</span><br><span class="line">        cluster.setSocketsUsed(jsonObjectTemp.get(<span class="string">"sockets_used"</span>).getAsLong());</span><br><span class="line">        cluster.setSocketsTotal(jsonObjectTemp.get(<span class="string">"sockets_total"</span>).getAsLong());</span><br><span class="line">        cluster.setMemoryUsed(jsonObjectTemp.get(<span class="string">"mem_used"</span>).getAsLong() );</span><br><span class="line">        cluster.setMemoryLimit(jsonObjectTemp.get(<span class="string">"mem_limit"</span>).getAsLong() );</span><br><span class="line">        cluster.setProcUsed(jsonObjectTemp.get(<span class="string">"proc_used"</span>).getAsLong());</span><br><span class="line">        cluster.setProcTotal(jsonObjectTemp.get(<span class="string">" proc_total"</span>).getAsLong() );</span><br><span class="line">        list.add(cluster);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据来集完之后并没有结束，图 7-10 中简单囊括了从数据采集到用户使用的过程：</p><ul><li>首先采集程序通过定时调用 HTTP API 接口获取 JSON 数据，</li><li>然后进行 JSON 解析之后再进行持久化处理。</li><li>对于这种基于时间序列的数据非常适合使用 OpenTSDB（基于 Hbase 的分布式的、可伸缩的时间序列数据库。主要用途就是做监控系统，比如收集大规模集群，包括网络设备、操作系统、应用程序的监控数据并进行存储、查询）来进行存储。</li><li>监控管理系统可以根据用户的检索条件来从 OpenTSDB 获取相应的数据并展示到页面之中。</li><li>监控管理系统本身还可以具备报表、权限管理等功能，同时也可以实时读取所采集的数据，对其进行分析处理，对于异常的数据需要及时报告给相应的人员。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010124.png" alt></p><p>对于集群的各节点信息展示可以参考下方，图 7-11 展示了各个节点实时的内存占用情况，图 7-12 展示了各个节点实时的磁盘使用情况。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010125.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010126.png" alt></p><p>对于交换器而言的数据采集可以调用 /api/exchanges/vhost/name 接口，比如需要调用虚拟主机为默认的 <code>/</code> 、交换器名称为 exchange 的数据，只需要使用 HTTP GET 方法获取 <code>http://xxx.xxx.xxx.xxx:15672/api/exchanges/%2F/exchange</code> 的数据即可。注意，这里需要将 <code>/</code> 进行 HTML 转义成 <code>%2F</code> ，否则会出错。对应的数据内容可以参考下方：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message_stats"</span>:&#123;</span><br><span class="line"><span class="attr">"publish_in_details"</span>: &#123;</span><br><span class="line"><span class="attr">"rate"</span>: <span class="number">0.4</span> //数据流入的速率</span><br><span class="line">&#125;,</span><br><span class="line">"publish_in": 9,//数据流入的总量</span><br><span class="line">"publish_out_details": &#123;</span><br><span class="line">"rate": 1.2 //数据流出的速率</span><br><span class="line">&#125;,</span><br><span class="line">"publish_out": 27//数据流出的总量</span><br><span class="line">&#125;,</span><br><span class="line">"outgoing": [],</span><br><span class="line">"incoming": [],</span><br><span class="line">"arguments": &#123;&#125;,</span><br><span class="line">"internal": false,</span><br><span class="line">"auto_delete": false,</span><br><span class="line">"durable": true,</span><br><span class="line">"type": "direct",</span><br><span class="line">"vhost": "/",</span><br><span class="line">"name": "exchange" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于1个交换器绑定3个队列的情况，向交换器发送1条消息，那么流入就是1条，而流出就是3条。在应用的时候根据实际情况挑选数据流入速率或者数据流出速率作为发送数量， 以及挑选数据流入的量还是数据流出的量作为发送量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JQExchange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> publishInRate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> publishIn;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> publishOutRate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> publishOut;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;publish_in_rate="</span> + publishInRate +</span><br><span class="line">                <span class="string">", publish_in"</span> + publishIn +</span><br><span class="line">                <span class="string">", publish_out_rate="</span> + publishOutRate +</span><br><span class="line">                <span class="string">", publish_out="</span> + publishOut + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeMonitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getExchangeData(<span class="string">"192.168.0.2"</span>, <span class="number">15672</span>, <span class="string">"root"</span>, <span class="string">"rootl23"</span>, <span class="string">"/"</span>, <span class="string">"exchange"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JQExchange <span class="title">getExchangeData</span><span class="params">(String ip, <span class="keyword">int</span> port, String username,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String password, String vhost , String exchange)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String url = <span class="string">"http://"</span> + ip + <span class="string">":"</span> + port + <span class="string">"/api/exchanges"</span></span><br><span class="line">                + encode(vhost, <span class="string">"UTF-8"</span>) + <span class="string">"/"</span> + encode(exchange, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        String urlData = HttpUtils.httpGet(url, username, password);</span><br><span class="line">        System.out.println(urlData);</span><br><span class="line">        JQExchange exchangeAns = parseExchange(urlData);</span><br><span class="line">        System.out.println(exchangeAns);</span><br><span class="line">        <span class="keyword">return</span> exchangeAns;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JQExchange <span class="title">parseExchange</span><span class="params">(String urlData)</span> </span>&#123;<span class="comment">//解析程序</span></span><br><span class="line">        JQExchange exchange = <span class="keyword">new</span> JQExchange();</span><br><span class="line">        JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">        JsonObject jsonObject = (JsonObject) parser.parse(urlData);</span><br><span class="line">        JsonObject msgStats =</span><br><span class="line">                jsonObject.get(<span class="string">"message_stats"</span>).getAsJsonObject();</span><br><span class="line">        <span class="keyword">double</span> publish_in_details_rate =</span><br><span class="line">                msgStats.get(<span class="string">"publish_in_details"</span>)</span><br><span class="line">                        .getAsJsonObject().get(<span class="string">"rate"</span>).getAsDouble();</span><br><span class="line">        <span class="keyword">double</span> publish_out_details_rate =</span><br><span class="line">                msgStats.get(<span class="string">"publish_out_details"</span>).</span><br><span class="line">                        getAsJsonObject().get(<span class="string">"rate"</span>).getAsDouble();</span><br><span class="line">        <span class="keyword">long</span> publish_in = msgStats.get(<span class="string">"publish_in"</span>).getAsLong();</span><br><span class="line">        <span class="keyword">long</span> publish_out = msgStats.get(<span class="string">"publish_out"</span>).getAsLong();</span><br><span class="line">        exchange.setPublishInRate(publish_in_details_rate);</span><br><span class="line">        exchange.setPublishOutRate(publish_out_details_rate);</span><br><span class="line">        exchange.setPublishIn(publish_in);</span><br><span class="line">        exchange.setPublishOut(publish_out);</span><br><span class="line">        <span class="keyword">return</span> exchange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于队列而言的数据来集相关的接口为 /api/queues/vhost/name 。</p><h3 id="5-2-通过客户端提供监控数据"><a href="#5-2-通过客户端提供监控数据" class="headerlink" title="5.2 通过客户端提供监控数据"></a>5.2 通过客户端提供监控数据</h3><p>除了 HTTP API 接口可以提供监控数据，Java 版客户端从 3.6.x 版本开始，也在 <code>Channel</code> 接口中提供了两个方法来获取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">messageCount</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">consumerCount</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>messageCount：用来查询队列中的消息个数，可以为监控消息堆积的情况提供数据。</li><li>consumerCount：用来查询队列中的消费者个数，可以为监控消费者的情况提供数据。</li></ul><p>相应监控视图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010127.png" alt></p><p>还可以通过连接的状态进行监控，<code>Connection</code> 接口提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBlockedListener</span><span class="params">(BlockedListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BlockedListener <span class="title">addBlockedListener</span><span class="params">(BlockedCallback var1, UnblockedCallback var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeBlockedListener</span><span class="params">(BlockedListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBlockedListeners</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>addBlockedListener：用来监昕连接阻塞信息。</li><li>addShutdownListener：用来监昕连接关闭信息。</li></ul><p>用户客户端还可以自行定义一些数据进行埋点 ，比如客户端成功发送的消息个数和发送失败的消息个数，进一步可以计算发送消息的成功率等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> successCount = <span class="number">0</span>; <span class="comment">//记录发送成功的次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> failureCount = <span class="number">0</span>; <span class="comment">//记录发送失败的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XXXXXX</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                failureCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>,</span><br><span class="line">                MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                <span class="string">"msg"</span> .getBytes());</span><br><span class="line">        <span class="keyword">if</span> (channel.waitForConfirms() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            successCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            failureCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        failureCount++;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        failureCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里推荐引入 metrics 工具（比如 <code>com.codahale.metrics.*</code>）来进行埋点，这样既方便又高效。同样的方式也可以统计消费者消费成功的条数和消费失败的条数。</p><h3 id="5-3-检测RabbitMQ服务是否健康"><a href="#5-3-检测RabbitMQ服务是否健康" class="headerlink" title="5.3 检测RabbitMQ服务是否健康"></a>5.3 检测RabbitMQ服务是否健康</h3><p>上述两种方式都要基于 RabbitMQ 服务运行正常的情况下，但无法判断 RabbitMQ 是否具备服务外部请求的能力。</p><p>三种检查方式：</p><ul><li>检查RabbitMQ是否运行：<code>ps aux | grep rabbitmq</code> 。</li><li>检查5672端口是否开启：<code>telnet xxx.xxx.xxx.xxx 5672</code> 。</li><li>使用 AMQP 协议来构建一个类似于 TCP 协议中的 Ping 的检测程序。当这个测试程序与 RabbitMQ 服务无法建立 TCP 协议层面的连接，或者无法构建 AMQP 协议层面的连接，再或者构建连接超时时，则可判定 RabbitMQ 服务处于异常状态而无法正常为外部应用提供相应的服务。</li></ul><p>AMQPPing实现代码可以参考《RabbitMQ实战指南 7.5.3》。</p><p>RabbitMQ Management 插件提供了 /api/aliveness-test/vhost 的 HTTP API 形式的接口，通过3个步骤来验证 RabbitMQ 服务的健康性：</p><ul><li>创建1个以 <code>aliveness-test</code> 为名称的队列来接收测试消息。</li><li>用队列名称 <code>aliveness-test</code> 作为消息的路由键，将消息发往默认交换器。 </li><li>到达队列时就消费该消息，否则就报错。</li></ul><p>检测程序 <code>aliveness-test</code> 运行在 Erlang 虚拟机内部， 因此它不会受到网络问题的影响。</p><h3 id="5-4-元数据管理与监控"><a href="#5-4-元数据管理与监控" class="headerlink" title="5.4 元数据管理与监控"></a>5.4 元数据管理与监控</h3><p>确保 RabbitMQ 能够健康运行还不足以让人放松警惕。比如在生产环境误删了一个队列（或者删除交换器、修改绑定信息等），若业务方正在使用这个队列，返回了异常后即使处理还能尽量的减少影响。但如果是深夜执行的定时任务，处理起来就很麻烦了。</p><p>许多应用场景是在业务逻辑代码中创建相应的元数据资源（交换器、队列及绑定关系）并使用对于排他的、自动删除的这类非高可靠性要求的元数据资源可以在一定程度上忽略元数据变更的影响。但是对于两个非常重要的且通过消息中间件交互的业务应用，在使用相应的元数据资源时最好进行相应的管控，如果一方或者其他方肆意变更所使用的元数据，必然对另一方造成不小的损失。管控的介入自然会降低消息中间件的灵活度，但是可以增强系统的可靠性。 比如通过专用的“元数据审核系统”来配置相应的元数据资源，提供给业务方使用的用户只有 可读和可写的权限，这样可以进一步降低风险。</p><p>RabbitMQ 在创建元数据资源的时候是以一种声明的形式完成的：无则创建、有则不变，不过在对应的元数据存在的情况下，对其再次声明时使用不同的属性会报出相应的错误信息。 我们可以利用这一特性来监控元数据的变更，通过定时程序来将记录中的元数据信息重新声明一次，查看是否有异常报出。不过这种方法非常具有局限性，只能增加元数据的信息而不能减少。比如有一个队列没有消费者且以后也不会被使用，我们对其进行了解绑操作，这样就没有更多的消息流入而造成消息堆积，不过这一变更由于某些局限性没有及时将记录变更以通知到那个定时程序，此时又重新将此队列绑定到原交换器中。</p><p>如图 7-15 所示，所有的业务应用都需要通过元数据审核系统来申请创建（当然也可以包含查询、修改及删除）相应的元数据信息。在申请动作完成之后，由专门的人员进行审批，之后在数据库中存储和在 RabbitMQ 集群中创建相应的元数据，这两个步骤可以同时进行，而且也无须为这两个动作添加强一致性的事务逻辑。在数据库和 RabbitMQ 集群之间会有一个元数据一致性校验程序来检测元数据不一致的地方，然后将不一致的数据上送到监控管理系统。监控管理系统中可以显示元数据不一致的记录信息，也可以以告警的形式推送出来，然后相应的管 理人员可以选择手动或者自动地进行元数据修正。这里的不一致有可能是由于数据库的记录未被正确及时地更新，有可能是 RabbitMQ 集群中元数据被异常篡改 元数据修正需慎之又慎，在整个系统修正逻辑完备之前，建议优先采用人工的方式，毕竟不一致的元数据仅占少数，人工修正的工作量并不太大。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010128.png" alt></p><p>主要的元数据是：queues、exchanges、bindings ，可以分别建立三张表。元数据一致性检测程序可以通过 /api/definitions 的 HTTP API 接口获取集群的元数据信息，通过解析之后与数据库中的记录一一比对，查看是否有不一致的地方。</p><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第六章《运维》，内容来自于《RabbitMQ实战指南》，内容：在 RabbitMQ 使用过程中难免会出现各式各样的异常情况，客户端的异常一般是由于应用代码的缺陷造成的，对于服务端的异常，虽然不能完全杜绝，但是可以采取一些有效的手段去监测、管控、修正等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（五）配置</title>
    <link href="http://linyishui.top/2020100601.html"/>
    <id>http://linyishui.top/2020100601.html</id>
    <published>2020-10-06T13:00:41.000Z</published>
    <updated>2020-10-07T15:40:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（五）配置"><a href="#RabbitMQ（五）配置" class="headerlink" title="RabbitMQ（五）配置"></a>RabbitMQ（五）配置</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><p>一般情况下，只需要使用默认的内建配置来运行 RabbitMQ，也可以利用调节系统范围内的参数来达到定制化的需求。</p><p>RabbitMQ 提供了三种方式来定制化服务：</p><ol><li>环境变量（Enviroment Variables）：RabbitMQ 服务端参数可以通过环境变量进行配置，例如：节点名称、 RabbitMQ 配直文件的地址、节点内部通信端口等。</li><li>配置文件（ Configuration File）：可以定义 RabbitMQ 服务和插件设置，例如：TCP 听端口，以及其他网络相关的设直、内存限制、磁盘限制等。</li><li>运行时参数和策略（ Runtime Parameters and Policies）：可以在运行时定义集群层面的服务设置。</li></ol><h2 id="第二节-环境变量"><a href="#第二节-环境变量" class="headerlink" title="第二节 环境变量"></a>第二节 环境变量</h2><h3 id="2-1-配置方式"><a href="#2-1-配置方式" class="headerlink" title="2.1 配置方式"></a>2.1 配置方式</h3><p>RabbitMQ 的环境变量都是以 <code>RABBITMQ_</code> 开头的，可以在 Shell 环境中设置，也可以在 <code>rabbitmq-env.conf</code> 这个 RabbitMQ 环境变量的定义文件中设置。在非 Shell 环境中配置，则需要将 <code>RABBITMQ_</code> 这个前缀去除。</p><p>指令 <code>rabbitmq-server -detached</code> 启动 RabbitMQ 服务的时候，此服务节点默认以 <code>rabbit＠</code> 加上当前的 Shell 环境的 hostname（主机名）来命名，即 <code>rabbit@$HOSTNAME</code> 。可以在 <code>rabbitmq-server</code> 命令前添 <code>RABBITMQ_NODENAME</code> 变量来设定指定的名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> RABBITMQ_NODENAME=rabbit@node2 rabbitmq-server -detached</span></span><br><span class="line">Warning: PIO file not written; -detached was passed.</span><br></pre></td></tr></table></figure><p>优先级顺序：Shell环境 &gt; <code>rabbitmq-env.conf</code> 配置文件 &gt; 默认配置。</p><p>配置 <code>rabbitmq-env.conf</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RabbitMQ 环境变量的定义文件</span></span><br><span class="line"><span class="comment"># 定义节点名称</span></span><br><span class="line"><span class="string">NODENAME=rabbit@node1</span></span><br><span class="line"><span class="comment"># 定义 RabbitMQ 的对外通信端口号</span></span><br><span class="line"><span class="string">NODE_PORT=5672</span></span><br><span class="line"><span class="comment"># 定义 RabbitMQ 配置文件的目录，注意对于 rabbitmq.config</span></span><br><span class="line"><span class="comment"># 文件来说这里不用添加".config后缀"</span></span><br><span class="line"><span class="string">CONFIG_FILE=/opt/rabbitmq/etc/rabbitmq/rabbitmq</span></span><br></pre></td></tr></table></figure><p>默认配置记录在 <code>$RABBITMQ HOME/sbin/rabbitmq-defaults</code> 文件。</p><h3 id="2-2-常见的RabbitMQ变量"><a href="#2-2-常见的RabbitMQ变量" class="headerlink" title="2.2 常见的RabbitMQ变量"></a>2.2 常见的RabbitMQ变量</h3><table><thead><tr><th>变量名称</th><th>描述</th></tr></thead><tbody><tr><td>RABBITMQ_NODE_IP_ADDRESS</td><td>绑定某个特定的网络接口。默认值是空字符串，即绑定到所有网络接口上。如果要绑定两个或者更多的网络接口，可以参考 rabbitmq.config 中的 tcp_listeners 配置</td></tr><tr><td>RABBITMQ_NODE_PORT</td><td>监听客户端连接的端口号，默认为 5672</td></tr><tr><td>RABBITMQ_DIST_PORT</td><td>RabbitMQ 节点内部通信的端口号，默认值为 RABBITMQ_NODE_PORT+20000, 即25672。如果设置了 kernel.inet_dist_listen_min 或者 kemel.inect_dist_listen_max</td></tr><tr><td>RABBITMQ_NODENAME</td><td>RabbitMQ 的节点名称，默认为 rabbit@$HOSTNAME 。在每个 Erlang 节点和机器的组合中，节点名称必须唯一</td></tr><tr><td>RABBITMQ_CONF_ENV_FILE</td><td>RabbitMQ 环境变量的配置文件（rabbitmq-env.conf）的地址，默认值为 $RABBITMQ_HOME/etc/rabbitmq/rabbi tmq-env.conf 注意这里与 RabbitMQ 配置文件 rabbitmq.config 的区别</td></tr><tr><td>RABBITMQ_USE_LONGNAME</td><td>如果当前的 hostname 为 node1.longname ，那么默认情况下创建的节点名称为 rabbit@node1 ，将此参数设置为 true 时，创建的节点名称就为 <a href="mailto:rabbit@node1.longname" target="_blank" rel="noopener">rabbit@node1.longname</a>，即使用了长名称命名，默认值为空</td></tr><tr><td>RABBITMQ_CONFIG_FILE</td><td>RabbitMQ 配置文件（rabbitmq.config）的路径，注意没有“.config”的后缀．默认值为 $RABBITMQ_HOME/etc/rabbitmq/rabbitmq</td></tr><tr><td>RABBITMQ_MNESIA_BASE</td><td>RABBITMQ_MNESIA_DIR 的父目录。除非明确设置了 RABBITMQ_MNESIA _DIR 目录，否则每个节点都应该配置这个环境变量。默认值为 $RABBITMQ_HOME/var/lib/rabbitmq/mnesia  注意对于 RabbitMQ 的操作用户来说，需要有对当前目录可读、可写、可创建文件及子目录的权限</td></tr><tr><td>RABBITMQ_MNESA_DIR</td><td>包含 RabbitMQ 服务节点的数据库、数据存储及集群状态等目录，默认值为 <code>$RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME</code></td></tr><tr><td>RABBITMQ_LOG_BASE</td><td>RabbitMQ 服务日志所在基础目录．默认值为$RABBITMQ_HOME/var/log/rabbitmq</td></tr><tr><td>RABBITMQ_LOGS</td><td>RabbitMQ 服务与 Erlang 相关的日志，默认值为 <code>$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log</code></td></tr><tr><td>RABBITMQ_SASL_LOGS</td><td>RabbitMQ 服务于 Erlang 的 SASL(System Application Support Libraries）相关的日志，默认值为 <code>$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME-sasl.log</code></td></tr><tr><td>RABBITMQ_PLUGINS_DIR</td><td>插件所在路径。默认值为$RABBITMQ_HOME/plugins</td></tr></tbody></table><p>一般不建议修改环境变量，如果生产环境有特殊要求，可以参考：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件的地址</span></span><br><span class="line"><span class="string">CONFIG_FILE=/apps/conf/rabbitmq/rabbitmq</span></span><br><span class="line"><span class="comment"># 环境变量的配置文件的地址</span></span><br><span class="line"><span class="string">CONF_ENV_FILE=/apps/conf/rabbitmq/rabbitmq-env.conf</span></span><br><span class="line"><span class="comment"># 服务日志的地址</span></span><br><span class="line"><span class="string">LOG_BASE=/apps/logs/rabbitmq</span></span><br><span class="line"><span class="comment"># Mnesia 的路径</span></span><br><span class="line"><span class="string">MNESIA_BASE=/apps/dbdat/rabbitmq/mnesia</span></span><br></pre></td></tr></table></figure><h2 id="第三节-配置文件"><a href="#第三节-配置文件" class="headerlink" title="第三节 配置文件"></a>第三节 配置文件</h2><p>在启动 RabbitMQ 服务的时候会打印相关信息，可以检查服务日志来判断配置文件地址。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010112.png" alt></p><p>配置失效的情况：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="keyword">file</span>(s) : <span class="regexp">/opt/</span>rabbitmq<span class="regexp">/sbin/</span>..<span class="regexp">/etc/</span>rabbitmq<span class="regexp">/rabbitmq. config(not found)</span></span><br></pre></td></tr></table></figure><p>检查对应路径下是否有相关配置文件，以及配置文件地址是否设置正确（通过 RABBITMQ_CONFIG_FILE 变量或者 <code>rabbitmq-env.conf</code> 文件设置）。</p><p>还可以通过查看进程信息的方式来检查配直文件的位置。通过 <code>ps aux|grep rabbitmq</code> 命令查看到 RabbitMQ 进程的信息，如果 <code>rabbitmq.config</code> 文件不处于默认的路径中，则会有 <code>-config</code> 选项标记正在使用的路径。</p><h3 id="3-1-配置项"><a href="#3-1-配置项" class="headerlink" title="3.1 配置项"></a>3.1 配置项</h3><p>极简的 <code>rabbitmq.config</code> 文件：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listeners, [<span class="number">5673</span>]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>上面的配置将 RabbitMQ 监听 AMQP 0-9-1 客户端连接的默认端口号从 5672 修改为 5673。</p><p>RabbitMQ 服务相关配置表格暂略。</p><h3 id="3-2-配置加密"><a href="#3-2-配置加密" class="headerlink" title="3.2 配置加密"></a>3.2 配置加密</h3><p>配置文件中有些敏感的配置项可以被加密，在 RabbitMQ 启动时可以对这些项进行解密。在配置文件中将加密之后的值以 <code>{encrypted, 加密的值}</code> 形式包裹。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;default_user,&lt;&lt;<span class="string">"guest"</span>&gt;&gt;&#125;,</span><br><span class="line">&#123;default_pass,</span><br><span class="line">&#123;</span><br><span class="line">&#123;encrypted,&lt;&lt;<span class="string">"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="</span>&gt;&gt;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;loopback_users,[]&#125;,</span><br><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,&lt;&lt;<span class="string">"zzhpassphrase"</span>&gt;&gt;&#125;</span><br><span class="line">]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>config_entry_decoder 项中的 passphrase 配置的就是口令。注意这里将 loopback_users 项配置为 <code>[]</code> ，就可以使用非本地网络访问 RabbitMQ 了，如果开启了 RabbitMQ Management 插件，就可以使用 guest/guest 的用户及密码来访问 Web 管理界面了。</p><p>passphrase 内容可以以单独的文件来赋值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,<span class="string">"/path/to/passphrase/file"</span>&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>加密解密：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode &lt;&lt;<span class="string">"guest"</span>&gt;&gt; zzhpassphrase </span></span><br><span class="line">&#123;encrypted,&lt;&lt;"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="&gt;&gt;&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode --DECODE &lt;&lt;<span class="string">"guest"</span>&gt;&gt; <span class="string">'&#123;encrypted,&lt;&lt;"HuVPYgSUdbogWL+2jGsgDMGZpDfiz+HurDuedpG8dQX/U+DMHcBluA15a5jRnAbs+OviX5EmsJJ+c0XgRRcADA=="&gt;&gt;&#125;'</span> zzhpassphrase</span></span><br></pre></td></tr></table></figure><p>默认情况下，加密机制 PBKDF2 用来从口令中派生出密钥。默认的 Hash 算法是 SHA512，默认的迭代次数是 1000 ，以及默认的加密算法为 AES_256_CBC。可以在配置文件中进行修改：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;config_entry_decoder,[</span><br><span class="line">&#123;passphrase,<span class="string">"zzhpassphrase"</span>&#125;,</span><br><span class="line">&#123;cipher, blowfish_cfb64&#125;,</span><br><span class="line">&#123;hash, sha256&#125;,</span><br><span class="line">&#123;iterations, <span class="number">10000</span>&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>或者通过 rabbitmqctl encode 命令设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl encode --cipher blowfish_cfb64 --<span class="built_in">hash</span> sha256 --iterations 10000 <span class="string">'&lt;&lt;"guest"&gt;&gt;'</span> zzhpassphrase</span></span><br></pre></td></tr></table></figure><h3 id="3-3-优化网络配置"><a href="#3-3-优化网络配置" class="headerlink" title="3.3 优化网络配置"></a>3.3 优化网络配置</h3><p>RabbitMQ 支持的所有协议都是基于 TCP 层面的，除了操作系统内核参数和 DNS，所有的 RabbitMQ 设置都可以通过在 rabbitmq.config 配置文件中配置来实现。</p><h4 id="3-3-1-监听端口"><a href="#3-3-1-监听端口" class="headerlink" title="3.3.1 监听端口"></a>3.3.1 监听端口</h4><p>RabbitMQ 在等待接收客户端连接时需要绑定一个或者多个网络接口（可以理解成IP地址)，井监听特定的端口。网络接口使用 rabbit.tcp_listeners 选项来配置。默认情况下，RabbitMQ 会在所有可用的网络接口上监听 5672 端口。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line"># 在一个指定的地址和端口上进行监听，同时在 <span class="symbol">IPv4</span> 和 <span class="number">1</span><span class="symbol">Pv6</span> 上监听</span><br><span class="line">&#123;tcp_listeners, [&#123;<span class="string">"192.168.0.2"</span>, <span class="number">5672</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"::1"</span>, <span class="number">5672</span>&#125;]&#125;</span><br><span class="line"> </span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><h4 id="3-3-2-提高吞吐量"><a href="#3-3-2-提高吞吐量" class="headerlink" title="3.3.2 提高吞吐量"></a>3.3.2 提高吞吐量</h4><p>优化网络配置的一个重要目标就是提高吞吐量，比如禁用 Nagle 算法、增大 TCP 缓冲区的大小。每个 TCP 连接都分配了缓冲区。一般来说，缓冲区越大，吞吐量也会越高，但是每个连接上耗费的内存也就越多，从而使总体服务的内存增大，这是一个权衡的问题。在 Linux 操作系统中，默认会自动调节 TCP 缓冲区的大小，通常会设置为 80KB 到 120KB 之间。</p><p>要提高吞吐量可以使用 rabbit.tcp_listen_options 来加大配置：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listen_options, [</span><br><span class="line">                 &#123;backlog, <span class="number">128</span>&#125;,</span><br><span class="line">                 &#123;nodelay, true&#125;,</span><br><span class="line">                 &#123;linger, &#123;true,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">                 &#123;exit_on_close, false&#125;,</span><br><span class="line">                 &#123;sndbuf, <span class="number">196608</span>&#125;,</span><br><span class="line">                 &#123;recbuf, <span class="number">196608</span>&#125;]&#125; </span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p>大部分操作系统都限制了同一时间可以打开的文件句柄数。在优化并发连接数的时候，需要确保系统有足够的文件句柄数来支撑客户端和 Broker 的交互。可以用每个节点上连接的数目乘以1.5来粗略的估算限制。例如，要支撑 10 万个 TCP 连接，需要设置文件句柄数为 15 万。当 然，略微增加文件句柄数可以增加闲置机器内存的使用量，但这需要合理权衡。</p><p>如上所述，增大 TCP 缓冲区的大小可以提高吞吐量，如果减小 TCP 缓冲区的大小，这样 就可以减小每个连接上的内存使用量。如果并发量比吞吐量更重要，可以修改此值。</p><p>禁用 Nagle 算法可以提高吞吐量，但是其主要还是用于减少延迟。RabbitMQ 内部节点交互时可以在 kernel.inet_default_connect_options 和 kernel.inet_default_listen_options 配置项中配置 {nodelay, true} 来禁用 Nagle 算法。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">kernel, [</span><br><span class="line">&#123;inet_default_connect_options, [&#123;nodelay, true&#125;]&#125;,</span><br><span class="line">&#123;inet_default_listen_options, [&#123;nodelay, true&#125;]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">rabbit, [</span><br><span class="line">&#123;tcp_listen_options, [</span><br><span class="line">                 &#123;backlog, <span class="number">4096</span>&#125;,</span><br><span class="line">                 &#123;nodelay, true&#125;,</span><br><span class="line">                 &#123;linger, &#123;true,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">                 &#123;exit_on_close, false&#125;]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><h4 id="3-3-3-设置线程池大小"><a href="#3-3-3-设置线程池大小" class="headerlink" title="3.3.3 设置线程池大小"></a>3.3.3 设置线程池大小</h4><p>Erlang 在运行时使用线程池来异步执行 IO 操作。线程池的大小可以通过 RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS 这个环境变量来调节。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</span>=<span class="string">"+A 128"</span></span><br></pre></td></tr></table></figure><p>当机器的内核个数大于等于8时，建议将此值设置为大于等于 96 ，这样可以确保每个内核上可以运行大于等于 12 个 I/O 线程。</p><h4 id="3-3-4-连接量大"><a href="#3-3-4-连接量大" class="headerlink" title="3.3.4 连接量大"></a>3.3.4 连接量大</h4><p>当只有少量的客户端时，新建立的连接分布是非常不均匀的，但是由于数量足够小，所以没有太大的差异。当连接数量到达数万或者更多时，重要的是确保服务器能够接受入站连接。未接受的 TCP 连接将会放在有长度限制的队列中。这个通过 rabbit.tcp_listen_options.backlog 参数来设置，默认值为 128 ，当挂起的连接队列的长度超过此值时，连接将被操作系统拒绝。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010113.png" alt></p><h4 id="3-3-5-一些可配置的内核选项"><a href="#3-3-5-一些可配置的内核选项" class="headerlink" title="3.3.5 一些可配置的内核选项"></a>3.3.5 一些可配置的内核选项</h4><p>与操作系统有关的网络设置也会影响到 RabbitMQ 的运行，注意这一类型的内核参数在 <code>/etc/sysctl.conf</code> 文件（Linux 操作系统）中配置，而不是 rabbitmq.config 这个文件中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010114.png" alt></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010115.png" alt></p><h2 id="第四节-参数及策略"><a href="#第四节-参数及策略" class="headerlink" title="第四节 参数及策略"></a>第四节 参数及策略</h2><p>有些配置不太适合在 rabbitmq.config 中实现，比如某项配置不需要同步到集群中的其他节点中，或者某项配置需要在运行时更改，因为 rabbitmq.config 需要重启 Broker 才能生效。 这种类型的配置在 RabbitMQ 中的另一种称呼为参数（ Paramter），也可以称之为运行时参数（Runtime Parameter）。</p><p>Parameter的设置方式：</p><ul><li>通过 rabbitmqctl 工具；</li><li>通过 RabbitMQ Management 插件提供的 HTTP API 接口来设置。</li></ul><p>RabbitMQ 一共有两种类型的 Parameter:：</p><ul><li>vhost 级别的 Parameter ，由一个组件名称（component name）、名称（name）和值 (value）组成。</li><li>global 级别的 Parameter ，由一个名称和值组成。</li></ul><p>不管什么类型，值都是JSON类型的。例如 Federation upstream 是一个 vhost 级别的 Parameter ，它用来定义 Federation link 的上游信息，其对应的 Parameter 的组件名称为 “federation-upstream” ，名称对应于其自身的名称，而值对应于与上游的相关的连接参数等；对 Shovel 而言也可以通过 Parameter 设置，其对应组件名称为 “shovel”。</p><h3 id="4-1-vhost级别Parameter"><a href="#4-1-vhost级别Parameter" class="headerlink" title="4.1 vhost级别Parameter"></a>4.1 vhost级别Parameter</h3><p>vhost 级别的参数对应的 rabbitmqctl 相关的命令有3种：</p><ul><li><p>set_parameter：用来设置一个参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter [-p vhost] &#123;component_name&#125; &#123;name&#125; &#123;value&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_federation </span></span><br><span class="line">The following plugins have been enabled: </span><br><span class="line">  rabbitmq_federation </span><br><span class="line">Applying plugin configuration to rabbit@node1... started 1 plugin. </span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_parameter federation-upstream f1 <span class="string">'&#123;"uri":"amqp://root:root123@192.168.0.2:5672","ack-mode":"on-confirm"&#125;'</span></span></span><br><span class="line">Setting runtime parameter "f1" for component "federation-upstream" to "&#123;\"uri\":\"amqp://root:root123@192.168.0.2:5672\",\"ack-mode\":\"on-confirm\"&#125;"</span><br></pre></td></tr></table></figure></li><li><p>list_parameters：用来列出指定虚拟主机上所有的Parameter。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters [-p vhost] </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters -p /</span></span><br><span class="line">Listing runtime parameters </span><br><span class="line">federation-upstream f1 &#123;"uri":"amqp://root:root123@192.168.0.2:5672","ack-mode":"on-confirm"&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear_parameter：用来清除指定的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_parameter [-p vhost] &#123;componenet_name&#125; &#123;key&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_parameter -p / federation-upstream f1 </span></span><br><span class="line">Clearing runtime parameter "fl" for component "federation-upstream"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_parameters -p /</span></span><br><span class="line">Listing runtime parameters</span><br></pre></td></tr></table></figure></li></ul><p>HTTP API接口：</p><ul><li>设置一个参数：PUT /api/parameters/{componenet_name}/vhost/name</li><li>清除一个参数：DELETE /api/parameters/{componenet_name}/vhost/name</li><li>列出指定 vhost 中的所有参数：GET /api/parameters</li></ul><h3 id="4-2-global级别Parameter"><a href="#4-2-global级别Parameter" class="headerlink" title="4.2 global级别Parameter"></a>4.2 global级别Parameter</h3><p>global 级别的 Parameter 的操作：</p><table><thead><tr><th>方式</th><th>详细内容</th></tr></thead><tbody><tr><td>rabbitmqctl</td><td>rabbitmqctl set_global_parameter name value<br>rabbitmqctl list_global_parameters<br>rabbitmqctl clear_global_parameter name</td></tr><tr><td>HTTP API接口</td><td>PUT /api/global-parameters/name<br>DELETE /api/global-parameters/name<br>GET /api/global-parameters/</td></tr></tbody></table><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list global parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_global_parameter name1 <span class="string">'&#123;&#125;'</span></span></span><br><span class="line">Setting global runtime parameter "name1" to "&#123;&#125;"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_global_parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br><span class="line">name1        []</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_global_parameter name1</span></span><br><span class="line">Clearing global runtime parameter "name1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_global_parameters</span></span><br><span class="line">Listing global runtime parameters</span><br><span class="line">cluster_name "rabbit@node1"</span><br></pre></td></tr></table></figure><h3 id="4-3-Policy"><a href="#4-3-Policy" class="headerlink" title="4.3 Policy"></a>4.3 Policy</h3><p>除了一些固定参数（ 比如 durable 或者 exclusive），客户端在创建交换器或者队列的时候可以配置一些可选参数来获得一些不同的功能，比如 x-message-ttl 或 x-expires 或 x-max-length 等。通过客户端设定的这些属性参数一旦设置成功就不能再改变（不能修改也不能添加），除非删除原来的交换器或队列之后再重新创建新的。</p><p>Policy 的介入就可以很好的解决这类问题，是一种特殊的Parameter的用法。</p><ul><li>Policy 是 vhost 级别的，一个 Policy 可以匹配多个队列或交换器，便于批量管理。</li><li>Policy 也支持动态的修改一些属性参数，提高了应用的灵活度。</li><li>一般用来配置Federation、镜像、备份交换器、死信等功能。</li></ul><p>rabbitmq_managemet 本身就提供了 Policy 的支持。可以在 【Admin】-&gt;【Policies】-&gt; 【Add / update a policy】中添加一个 Policy 。</p><p>参数： </p><ul><li>Virtual host ：表示当前 Policy 所在的 vhost 是哪个。 </li><li>Name ：表示当前 Policy 的名称。</li><li>Pattern ：一个正则表达式，用来匹配相关的队列或者交换器。 </li><li>Apply to ：用来指定当前 Policy 作用于哪一方。 共有三个选项：<ul><li>Exchanges and queues：表示作用与 Pattern 所匹配的所有队列和交换器；</li><li>Exchanges：表示作用于 Pattern 所匹配的所有交换器；</li><li>Queues：表示作用于与 Pattern 所匹配的所有队列。 </li></ul></li><li>Priority ：定义优先级，如果有多个 Policy 作用于同一个交换器或者队列，那么 Priority 最大的那个 Policy 才会有用 。</li><li>Definition ：定义一组或者多组键值对，为匹配的交换器或者队列附加相应的功能。</li></ul><p>作为一种 Paramter, Policy 也可以通过 rabbitmqctl 工具或者 HTTP API 接口来操 。与前面所讲的 Parameter 对应， rabbitmqctl 工具或者 HTTP API 接口各种都有 set、clear、list 的功能。</p><ul><li><p>用来设置一个 Policy：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy [-p vhost] [--priority priority] [--apply-to apply-to] &#123;name&#125; &#123;pattern&#125; &#123;definition&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例，设置默认的 vhost 中所有以<span class="string">"^amq."</span>开头的交换器为联邦交换器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy --apply-to exchanges --priority 1 p1 <span class="string">"^amq."</span> <span class="string">'&#123;"federation-upstream":"f1"&#125;'</span></span></span><br><span class="line">Setting policy</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root123 -XPUT -d <span class="string">'&#123;"pattern":"^amq\.","definition":&#123;"federation-upstream":"f1"&#125;,"priority":1,"apply-to":"exchanges"&#125;'</span> http://192.168.0.2:15672/api/policies/%2F/p1</span></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:36:20 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type : application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure></li><li><p>列出默认 vhost 所有的 Policy ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_policies [-p vhost] </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_policies </span></span><br><span class="line">Listing policies </span><br><span class="line">/  p1 exchanges ^amq. &#123;"federation-upstream":"f1"&#125;1</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XGET http://192.168.0.2:15672/api/policies/%2F</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:37:30 GMT</span><br><span class="line">content-length: 125</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">[&#123;"vhost":"/","name":"pl","pattern":"^amq\\.","apply-to":"exchanges","definition":&#123;"federation-upstream":"f1"&#125;,"priority":1&#125;]</span><br></pre></td></tr></table></figure></li><li><p>清除指定的 Policy ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_policy [-p vhost] &#123;name&#125; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_policy p1</span></span><br><span class="line">Clearing policy "p1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP API</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:rootl23 -XDELETE http://192.168.0.2:15672/api/policies/%2F/p1</span></span><br><span class="line"></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Mon, 21 Aug 2017 12:38:55 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure><p>如果两个或多个 Policy 都作用到同一个交换器或者队列上，且这些 Policy 的优先级都是一样的，则参数项最多的 Policy 具有决定权。如果参数一样多，则最后添加的 Policy 具有决定权。</p></li></ul><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第五章《配置》，内容来自于《RabbitMQ实战指南》，内容包括：环境变量，配置文件，参数及策略。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（四）管理</title>
    <link href="http://linyishui.top/2020100201.html"/>
    <id>http://linyishui.top/2020100201.html</id>
    <published>2020-10-02T07:08:31.000Z</published>
    <updated>2020-10-06T12:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（四）管理"><a href="#RabbitMQ（四）管理" class="headerlink" title="RabbitMQ（四）管理"></a>RabbitMQ（四）管理</h1><h2 id="第一节-多租户与权限"><a href="#第一节-多租户与权限" class="headerlink" title="第一节 多租户与权限"></a>第一节 多租户与权限</h2><h3 id="1-1-什么是vhost？"><a href="#1-1-什么是vhost？" class="headerlink" title="1.1 什么是vhost？"></a>1.1 什么是vhost？</h3><p>每个 RabbitMQ 服务器都能创建虚拟的消息服务器，我们称之为虚拟主机（virtual host，简称为 vhost)。</p><ul><li>每一个 vhost 本质上是一个独立的小型 RabbitMQ 服务器；</li><li>拥有自己独立的队列、交换器及绑定关系等；</li><li>井且它拥有自己独立的权限。 </li><li>vhost 之间是绝对隔离的，无法将 vhostl 中的交换器与 vhost2 中的队列进行绑定，既保证了安全性，又可以确保可移植性。</li><li>建议用户对业务功能、场景进行归类 区分，并为之分配独立的 vhost。</li><li>vhost 是 AMQP 概念的基础，客户端在连接的时候必须制定一个 vhost。</li><li>默认的 vhost 是 <code>/</code> ，使用默认的用户名 guest 和密码 guest 就可以访问它。</li></ul><h3 id="1-2-常用指令"><a href="#1-2-常用指令" class="headerlink" title="1.2 常用指令"></a>1.2 常用指令</h3><p>创建新 vhost ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_vhost &#123;vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_vhost vhost1</span></span><br></pre></td></tr></table></figure><p>列表当前所有  vhost ：</p><ul><li>name：vhost名称；</li><li>tracing：是否使用trace功能。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts &#123;vhostinfoitem...&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts name tracing</span></span><br><span class="line">Listing vhosts</span><br><span class="line">vhost1 false</span><br><span class="line">/      false</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl trace_on</span></span><br><span class="line">Starting tracing for host "/"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts name tracing</span></span><br><span class="line">Listing vhosts</span><br><span class="line">vhost1 false</span><br><span class="line">/      true</span><br></pre></td></tr></table></figure><p>删除 vhost ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_vhost &#123;vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_vhost vhost1</span></span><br><span class="line">Deleting vhost "vhost1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_vhosts</span></span><br><span class="line">Listing vhosts</span><br></pre></td></tr></table></figure><p>vhost 授予用户权限：</p><ul><li>vhost：授予用户权限的vhost名称；</li><li>user：可以访问vhost的用户名；</li><li>conf：用于匹配用户在哪些资源上拥有可配置权限的正则表达式（指队列和交换器的创建和删除操作）；</li><li>write：用于匹配用户在哪些资源上拥有可写权限的正则表达式（指发布消息）；</li><li>read：用于匹配用户在哪些资源上拥有可读权限的正则表达式（指与消息有关的操作，如读取消息或清空队列）；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions &#123;-p vhost&#125; &#123;user&#125; &#123;conf&#125; &#123;write&#125; &#123;<span class="built_in">read</span>&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授予root：可访问vhost1，所有资源可配置 + 可写 + 可读权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions -p vhost1 root <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span></span><br><span class="line">Setting permissions for user "root" in vhost "vhost1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 授予root：可访问vhost2，<span class="string">"queue"</span>开头资源上可配置，所有资源可写 + 可读权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions -p vhost2 root <span class="string">"^queue.*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span></span><br><span class="line">Setting permissions for user "root" in vhost "vhost2"</span><br></pre></td></tr></table></figure><p>不同AMQP命令的列表和对应权限：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010101.png" alt></p><p>vhost 清除用户权限：禁止用户访问vhost</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_permissions &#123;-p vhost&#125; &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_permissions -p vhost1 root</span></span><br><span class="line">Clearing permissions for user "root" in vhost "vhost1"</span><br></pre></td></tr></table></figure><p>列表查询权限信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显式虚拟主机上的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_permissions &#123;-p vhost&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显式用户的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_user_permissions &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_permissions -p vhost1</span></span><br><span class="line">Listing permissions in vhost "vhost1"</span><br><span class="line">root .* .* .*</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_user_permissions root</span></span><br><span class="line">Listing permissions for user "root"</span><br><span class="line">/      .* .* .*</span><br><span class="line">vhost1 .* .* .*</span><br></pre></td></tr></table></figure><p>rabbitmqctl 工具是用来管理 RabbitMQ 中间件的命令行工具，它通过连接各个 RabbitMQ 节点来执行所有操作。如果有节点没有运行，将显示诊断信息：不能到达或因不匹配的 Erlang cookie 而拒绝连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 标准语法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl [-n node] [-t timeout] [-q] &#123;<span class="built_in">command</span>&#125; [<span class="built_in">command</span> options]</span></span><br></pre></td></tr></table></figure><ul><li><code>[-n node]</code> ：默认节点 <code>rabbit@hostname</code> ，通常 <code>hostname -s</code> 命令输出是 <code>@</code> 标志后的东西。</li><li><code>[-t timeout]</code> ：操作超时时间。</li><li><code>[-q]</code> ：启用quiet模式，可以屏蔽一些消息。</li></ul><h2 id="第二节-用户管理"><a href="#第二节-用户管理" class="headerlink" title="第二节 用户管理"></a>第二节 用户管理</h2><p>在 RabbitMQ 中，用户是访问控制（Access Control) 的基本单元，且单个用户可以跨越多个 vhost 进行授权，同个用户针对多个 vhost 可以被赋予不同级别的访问权限。</p><h3 id="2-1-常用指令"><a href="#2-1-常用指令" class="headerlink" title="2.1 常用指令"></a>2.1 常用指令</h3><p>创建用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_user &#123;username&#125; &#123;password&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_user root root123</span></span><br><span class="line">Creating user "root"</span><br></pre></td></tr></table></figure><p>修改密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_password root root321</span></span><br></pre></td></tr></table></figure><p>清除密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_password &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_password root</span></span><br></pre></td></tr></table></figure><p>密码验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl authenticate_user &#123;username&#125; &#123;password&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl authenticate_user root root321</span></span><br></pre></td></tr></table></figure><p>删除用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_user &#123;username&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_user root</span></span><br></pre></td></tr></table></figure><p>列表查询用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_users</span></span><br></pre></td></tr></table></figure><p>用户包括5种角色类型：</p><ul><li>none：无任何角色，新用户默认为none。</li><li>management：允许访问Web管理界面。</li><li>policymaker：可以管理策略和参数。</li><li>monitoring：可以看到所有连接、信道及节点的相关信息。</li><li>administrator：可以管理用户、虚拟主机、权限、策略、参数等。</li></ul><p>设置用户角色：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_user_tags &#123;username&#125; &#123;tag ...&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_user_tags root monitoring</span></span><br></pre></td></tr></table></figure><h2 id="第三节-Web端管理"><a href="#第三节-Web端管理" class="headerlink" title="第三节 Web端管理"></a>第三节 Web端管理</h2><h3 id="3-1-RabbitMQ-management"><a href="#3-1-RabbitMQ-management" class="headerlink" title="3.1 RabbitMQ management"></a>3.1 RabbitMQ management</h3><p>为了能够运行 rabbitmqctl 工具，当前的用户需要拥有访问 Erlang cookie 的权限，由于服务器可能是 guest 或者 root 用户身份来运行的，因此你需要获得这些文件的访问权限，这样就引申出来一些权限管理的问题。</p><p>RabbitMQ 开发了 RabbitMQ management ，由 Erlang 言编写，并且和 RabbitMQ 服务运行在同一个 Erlang 虚拟机中。提供了 Web 管理界面用来管理如前面所述的虚拟主机、用户等，也可以用来管理队列、交换器、绑定关系、策略、 参数等，还可以用来监控 RabbitMQ 服务的状态及一些数据统计类信息，可谓是功能强大，基本上能够涵盖所有 RabbitMQ 管理的功能。</p><h3 id="3-2-指令开启和关闭"><a href="#3-2-指令开启和关闭" class="headerlink" title="3.2 指令开启和关闭"></a>3.2 指令开启和关闭</h3><p>RabbitMQ插件的默认存放目录：<code>$RABBITMQ_HOME/plugins</code> ，格式为 <code>.ez</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rabbitmq-plugins语法格式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins [-n node] &#123;<span class="built_in">command</span>&#125; [<span class="built_in">command</span> options...]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> [plugin-name]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">disable</span> [plugin-name]</span></span><br></pre></td></tr></table></figure><p>开启 rabbitmq_management 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span></span><br><span class="line">Enabling plugins on node rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">rabbitmq_management</span><br><span class="line">The following plugins have been configured:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">Applying plugin configuration to rabbit@iZ2zeet6kto8eqx1w7sluzZ...</span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line"></span><br><span class="line">started 3 plugins.</span><br></pre></td></tr></table></figure><p>查看当前插件的使用情况：<code>[E*]</code> 表示显示启动，<code>[e*]</code> 表示隐式启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins list</span></span><br><span class="line">Listing plugins with pattern ".*" ...</span><br><span class="line"> Configured: E = explicitly enabled; e = implicitly enabled</span><br><span class="line"> | Status: * = running on rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line"> |/</span><br><span class="line">[  ] rabbitmq_amqp1_0                  3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_cache       3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_http        3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_ldap        3.8.8</span><br><span class="line">[  ] rabbitmq_auth_backend_oauth2      3.8.8</span><br><span class="line">[  ] rabbitmq_auth_mechanism_ssl       3.8.8</span><br><span class="line">[  ] rabbitmq_consistent_hash_exchange 3.8.8</span><br><span class="line">[  ] rabbitmq_event_exchange           3.8.8</span><br><span class="line">[  ] rabbitmq_federation               3.8.8</span><br><span class="line">[  ] rabbitmq_federation_management    3.8.8</span><br><span class="line">[  ] rabbitmq_jms_topic_exchange       3.8.8</span><br><span class="line">[E*] rabbitmq_management               3.8.8</span><br><span class="line">[e*] rabbitmq_management_agent         3.8.8</span><br><span class="line">[  ] rabbitmq_mqtt                     3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_aws       3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_common    3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_consul    3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_etcd      3.8.8</span><br><span class="line">[  ] rabbitmq_peer_discovery_k8s       3.8.8</span><br><span class="line">[  ] rabbitmq_prometheus               3.8.8</span><br><span class="line">[  ] rabbitmq_random_exchange          3.8.8</span><br><span class="line">[  ] rabbitmq_recent_history_exchange  3.8.8</span><br><span class="line">[  ] rabbitmq_sharding                 3.8.8</span><br><span class="line">[  ] rabbitmq_shovel                   3.8.8</span><br><span class="line">[  ] rabbitmq_shovel_management        3.8.8</span><br><span class="line">[  ] rabbitmq_stomp                    3.8.8</span><br><span class="line">[  ] rabbitmq_top                      3.8.8</span><br><span class="line">[  ] rabbitmq_tracing                  3.8.8</span><br><span class="line">[  ] rabbitmq_trust_store              3.8.8</span><br><span class="line">[e*] rabbitmq_web_dispatch             3.8.8</span><br><span class="line">[  ] rabbitmq_web_mqtt                 3.8.8</span><br><span class="line">[  ] rabbitmq_web_mqtt_examples        3.8.8</span><br><span class="line">[  ] rabbitmq_web_stomp                3.8.8</span><br><span class="line">[  ] rabbitmq_web_stomp_examples       3.8.8</span><br></pre></td></tr></table></figure><p>还要再重启 RabbitMQ 服务使之生效。</p><p>关闭 <code>rabbitmq_management</code> 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_management</span></span><br></pre></td></tr></table></figure><h3 id="3-3-简单使用图形化工具"><a href="#3-3-简单使用图形化工具" class="headerlink" title="3.3 简单使用图形化工具"></a>3.3 简单使用图形化工具</h3><p>注意：阿里云服务器要在管理端配置入方向规则，开放15672端口。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010102.png" alt></p><p>尝试使用 guest 账号登录，但被拦截（如下），只允许本地地址访问。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010103.png" alt></p><p>使用 root 登录：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010104.png" alt></p><p>用户管理可以实现上节所有指令的功能：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010105.png" alt></p><p>可以指定用户角色：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010106.png" alt></p><p>新增了用户 <code>user01</code> ：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010107.png" alt></p><p>点击一个用户名，进入详情界面：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010108.png" alt></p><p>新用户没有指定虚拟主机，可以设置一个：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010109.png" alt></p><p>注意：有时Web管理界面可以正常登陆，但进入后显式部分页面，这种情况清空一下浏览器缓存即可。</p><h2 id="第四节-应用与集群管理"><a href="#第四节-应用与集群管理" class="headerlink" title="第四节 应用与集群管理"></a>第四节 应用与集群管理</h2><h3 id="4-1-应用管理"><a href="#4-1-应用管理" class="headerlink" title="4.1 应用管理"></a>4.1 应用管理</h3><p>停止 Erlang 虚拟机和 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop [pid_file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl shutdown</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop /opt/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@nodel.pid</span></span><br></pre></td></tr></table></figure><ul><li><code>stop [pid_file]</code> ：<ul><li>如果指定了 pid_file, 还需要等待指定进程的结束。</li><li>pid_file 是通过调用 <code>rabbitmq-server</code> 命令启动 RabbitMQ 服务时创建的，默认情况下存放于 Mnesia 目录中，可以通过 <code>RABBITMQ_PID_FILE</code> 这个环境变量来改变存放路径。</li><li>使用 <code>rabbitmq-server -detach</code> 这个带有 <code>-detach</code> 后缀的命令来启动 RabbitMQ 服务则不会生成 pid_file 文件。</li></ul></li><li><code>shutdown</code> ：<ul><li>执行这个命令会阻塞直到 Erlang 虚拟机进程退出。</li><li>和stop不同的是，不需要指定pid_file即可阻塞等待指定进程的关闭。</li></ul></li></ul><p>停止 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br></pre></td></tr></table></figure><ul><li>只停止 RabbitMQ 服务应用，Erlang 虚拟机还处于运行状态。</li></ul><p>启动 RabbitMQ 服务应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app</span></span><br></pre></td></tr></table></figure><p>等待 RabbitMQ 应用的启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">wait</span> [pid_file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">wait</span></span></span><br><span class="line">/opt/rabbitmq/var/lib/rabbitmq/mnes a/rabbit\@nodel.pid</span><br></pre></td></tr></table></figure><ul><li>等待 pid_file 的创建，和对应进程启动。</li></ul><p>重置 RabbitMQ 节点（以及强制重置）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl reset</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl force_reset</span></span><br></pre></td></tr></table></figure><ul><li>重置操作将节点还原至最初状态。<ul><li>从所在集群删除此节点</li><li>从管理数据库中删除所有配置数据，如已配置的用户、vhost等</li><li>删除所有持久化消息。</li></ul></li><li>重置前要先停止 RabbitMQ 应用。</li><li>强制重置不同的是不会考虑集群和管理数据库的状态</li></ul><p>指示 RabbitMQ 节点轮换日志文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl rotate_logs &#123;suffix&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span> </span></span><br><span class="line">/opt/rabbitmq/var/log/rabbitmq</span><br><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br><span class="line">-rw-r--r-- 1 root root 1024127 Oct 18 11:56 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 720553 Oct 17 19:16 rabbit@node1-sasl.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原日志文件为 rabbit@node1.log 和 rabbit@node1-sasl.log</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl rotate_logs .1</span></span><br><span class="line">Rotating logs to files with suffix ".1"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 轮换日志之后，原日志文件中的内容就被迫加到 rabbit@nodel.log.1 rabbit@node1-sasl.log.1 日志中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 18 12:05 rabbit@node1.log</span><br><span class="line">-rw-r--r-- 1 root root 1024202 Oct 18 12:05 rabbit@node1.log.1</span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 18 12:05 rabbit@node1-sasl.log</span><br><span class="line">-rw-r--r-- 1 root root 720553 Oct 18 12:05 rabbit@node1-sasl.log.1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后重新建立 rabbit@node1.log 和 rabbit@node1-sasl.log 文件用来接收新的日志。</span></span><br></pre></td></tr></table></figure><ul><li>将原日志文件的内容追加到“原始名称+后缀”的日志文件中；</li><li>将新日志内容记录到新创建的日志中（同名），不存在会创建文件；</li><li>若不指定后缀，只会打开文件而不进行轮换。</li></ul><p>将 RabbitMQ 代码用 HiPE 编译，生成的 <code>.beam</code> 文件保存到指定文件目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl hipe_compile &#123;directory&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl hipe compile</span></span><br><span class="line">/opt/rabbitmq/tmp/rabbit-hipe/ebin</span><br><span class="line">HiPE compiling: |-----------------------------------------------|</span><br><span class="line">                |###############################################|</span><br><span class="line">Compiled 57 modules in 55s</span><br></pre></td></tr></table></figure><ul><li>如果要使用预编译的这些文件，则需要设置 RABBITMQ_SERVER_CODE_PATH 这个环境变量来指定 hipe_compile 调用的路径。</li></ul><h3 id="4-2-集群管理"><a href="#4-2-集群管理" class="headerlink" title="4.2 集群管理"></a>4.2 集群管理</h3><p>将节点加入指定集群中：（在这个命令执行前需要停止 RabbitMQ 应用并重置节点）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster &#123;cluster_node&#125; [--ram]</span></span><br></pre></td></tr></table></figure><p>显式集群的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure><p>修改集群节点的类型：（在这个命令执行前需要停止 RabbitMQ 应用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_cluster_node_type &#123;disc|ram&#125;</span></span><br></pre></td></tr></table></figure><p>将节点从集群中删除，允许离线执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl forget_cluster_node [--offline]</span></span><br></pre></td></tr></table></figure><p>在集群中的节点应用启动前咨询 clusternode 节点的最新信息，并更新相应的集群信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl update_cluster_nodes &#123;clusternode&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>和 join_cluster 不同 ，它不加入集群。</p></li><li><p>使用案例：考虑这样一种情况，节点A和节点B都在集群 中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B但是这样会失败，因为节点B经不在集群中了。 <code>Rabbitmqctl update_cluster_nodes -n A C</code> 可以解决这种场景下出现的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 假设己有 node1 和 node 组成的集群</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1. 初始状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br><span class="line">[</span><br><span class="line"> &#123;nodes, [&#123;disc , [rabbit@node1, rabbit@node2]&#125;]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;running_nodes, [rabbit@node2, rabbit@node1]&#125;,</span><br><span class="line"> &#123;cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions, []&#125;,</span><br><span class="line"> &#123;alarms, [</span><br><span class="line">     &#123;rabbit@node2, []&#125;, </span><br><span class="line">           &#123;rabbit@node1, []&#125; </span><br><span class="line">          ]</span><br><span class="line"> &#125; </span><br><span class="line">]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#2. 关闭 node1 节点的应用</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#3. 之后将 node3 加入到集群中 </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster rabbit@node2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#4. 再将 node2 节点的应用关闭</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#5. 最后启动 node1 节点的应用，此时会报错</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app </span></span><br><span class="line">Starting node rabbit@node1</span><br><span class="line">BOOT FAILED</span><br><span class="line">==========</span><br><span class="line">Timeout contacting cluster nodes : [rabbit@node2] . </span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#6. 如果在启动 node1 节点的应用之前咨询 node3 并更新相关集群信息则可以解决这个问题</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl update_cluster_nodes rabbit@node3</span></span><br><span class="line">Updating cluster nodes for rabbit@node1 from rabbit@node3</span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app </span></span><br><span class="line">Starting node rabbit@node1</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#7. 查看最终集群状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br></pre></td></tr></table></figure></li></ul><p>确保节点可以启动，即使它不是最后一个关闭的节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl force_boot</span></span><br></pre></td></tr></table></figure><ul><li>通常情况下，当关闭整个 RabbitMQ 集群时，重启的第一个节点应该是最后关闭的节点，因为它可以看到其他节点所看不到的事情。</li><li>有时会有一些异常情况出现，比如整个集群都掉电而所有节点都认为它不是最后关闭 的。</li><li>这时可以调用 <code>rabbitmqctl force_boot</code> 命令，告诉节点可以无条件地启动节点 。在此节点关闭后，集群的任何变化，它都会丢失。</li><li>如果最后一个关闭的节点永久 丢失了，那么需要优先使用 <code>rabbitmqctl forget_cluster_node --offline</code> 命令，因 为它可以确保镜像队列的正常运转。</li></ul><p>指示未同步队列 queue 的 slave 镜像可以同步 master 镜像行的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl sync_queue [-p vhost] &#123;queue&#125;</span></span><br></pre></td></tr></table></figure><ul><li>同步期间此队列会被阻塞（所有此队列的生产消费者都会被阻塞），直到同步完成。</li><li>执行成功的前提是队列 queue 配置了镜像。</li><li>未同步队列中的消息被耗尽后，最终也会变成同步，此命令主要用于未耗尽的队列。</li></ul><p>取消队列 queue 同步镜像的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cancel_sync_queue [-p vhost] &#123;queue&#125;</span></span><br></pre></td></tr></table></figure><p>设置集群名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_cluster_name &#123;name&#125;</span></span><br></pre></td></tr></table></figure><ul><li>集群名称在客户端连接时会通报给客户端。</li><li>默认是集群中第一个节点的名称。</li></ul><h2 id="第五节-服务端状态"><a href="#第五节-服务端状态" class="headerlink" title="第五节 服务端状态"></a>第五节 服务端状态</h2><p>服务器状态的查询会返回一个以制表符分隔的列表，此类命令接受一个可选 vhost 参数以显示其结果， 默认值为 <code>/</code> ：</p><ul><li>list_queues </li><li>list_exchanges </li><li>list_bindings </li><li>list_consumers </li></ul><h3 id="5-1-list-queues"><a href="#5-1-list-queues" class="headerlink" title="5.1 list_queues"></a>5.1 list_queues</h3><p>此命令返回队列的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_queues [-p vhost] [queueinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>queueinfoitem</code> 参数用于指示哪些队列的信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>name ：队列名称。</li><li>durable ：队列是否持久化。</li><li>auto_delete ：队列是否自动删除。</li><li>arguments ：队列的参数。</li><li>policy ：应用到队列上的策略名称。</li><li>pid：队列关联的 Erlang 进程的 ID。</li><li>owner_pid ：处理排他队列连接的 Erlang 进程。如果此队列是非排他的，此值将为空。 </li><li>exclusive ：队列是否是排他的。</li><li>exclusive_consumer_pid ：订阅到此排他队列的消费者相关的信道关联的 Erlang 进程。如果此队列是非排他的，此值将为空。</li><li>exclusive_consumer_tag ：订阅到此排他队列的消费者的 consumerTag 如果此队列是非排他的，此值将为空。 </li><li>messages_ready ：准备发送给客户端的消息个数。</li><li>messages_unacknowledged ：发送给客户端但尚未应答的消息个数。messages ：准备发送给客户端和未应答消息的总和。</li><li>messages_ready_ram ：驻留在内存中 messages_ready 的消息个数。</li><li>messages_unacknowledged_ram ：驻留在内存中。messages_unacknowledged 的消息个数。</li><li>messages ram ：驻留在内存中的消息总数。</li><li>messages_persistent ：队列中持久化消息的个数，对于非持久化队列来说总是0。</li><li>messages_bytes ：队列中所有消息的大小总和。不包括消息属性或者任何其他开销。 </li><li>messages_bytes_ready ：准备发送给客户端的消息的大小总和。 </li><li>messages_bytes_unacknowledged ：发送给客户端但尚未应答的消息的大小总和。</li><li>messages_bytes_ram：驻留在内存中的 messages_bytes。</li><li>messages_bytes_persiste ：队列中持久化的 messages_bytes。</li><li>disk_reads ：从队列启动开始，己从磁盘中读取该队列的消息总次数。 </li><li>disk_writes ：从队列启动开始，己向磁盘队列写消息的总次数。 </li><li>consumer ：消费者数目。 </li><li>consumer_utilisation ：队列中的消息能够立刻投递给消费者的比率，介于0或1之间 。这个受网络拥塞或者 Basic.Qos 的影响而小于1。</li><li>memory ：与队列相关的 Erlang 进程所消耗的内存字节数，包括栈、堆及内部结构。</li><li>slave_pids ：如果队列是镜像的，列出所有 slave 镜像的 pid。</li><li>synchronised_slave_pids ：如果队列是镜像的，列出所有己经同步的 slave 镜像 pid。</li><li>state ：队列状态。正常情况下是 running ；如果队列正常同步数据可能会有 <code>{syncing, MsgCount}</code> 的状态；如果队列所在的节点掉线了，则队列显示状态为 down （此时大多数的 queueinfoitems 也将不可用）。</li></ul><p>如果没有指定 queueinfoitems ，那么此命令将显示队列的名称和消息的个数。</p><h3 id="5-2-list-exchanges"><a href="#5-2-list-exchanges" class="headerlink" title="5.2 list_exchanges"></a>5.2 list_exchanges</h3><p>返回交换器的详细细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_exchanges [-p vhost] [exchangeinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>exchangeinfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>name ：交换器的名称。 </li><li>type ：交换器的类型。 </li><li>durable ：设置是否持久化。 durable 设置为 true 表示持久化，反之是非持久化。持久化可以将交换器信息存盘而在服务器重启的时候不会丢失相关信息。 </li><li>auto_delete ：设直是否自动删除。 </li><li>internal ：是否是内置的。 </li><li>arguments ：其他一些结构化参数，比如 alternate-exchange </li><li>policy ：应用到交换器上的策略名称。</li></ul><p><code>exchangeinfoitem</code> 的内容和客户端中的 <code>channel.exchangeDeclare</code> 方法的参数基本一致。</p><h3 id="5-3-list-bindings"><a href="#5-3-list-bindings" class="headerlink" title="5.3 list_bindings"></a>5.3 list_bindings</h3><p>返回绑定关系的细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_bindings [-p vhost] [bindinginfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>bindinginfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>source_name ：绑定中消息来源的名称。 </li><li>source_kind ：绑定中消息来源的类别。 </li><li>destination_name ：绑定中消息目的地的名称。 </li><li>destination_kind ：绑定中消息目的地的种类。 </li><li>routing_key ：绑定的路由键。 </li><li>arguments ：绑定的参数。</li></ul><h3 id="5-4-list-connections"><a href="#5-4-list-connections" class="headerlink" title="5.4 list_connections"></a>5.4 list_connections</h3><p>返回 TCP/IP 连接的统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_connections [connectioninfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>connectioninfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>pid ：与连接相关的 Erlang 进程 ID </li><li>name ：连接的名称。 </li><li>port ：服务器端口。</li><li>host ：返回反向 DNS 获取的服务器主机名称，或者 IP 地址，或者未启用。</li><li>peer_port ：服务器对端端口。当一个客户端与服务器连接时，这个客户端的端口就是 peer_port 。</li><li>peer_host ：返回反向 DNS 获取的对端主机名称，或者 IP 地址， 或者未启用。 </li><li>ssl ：是否启用 SSL 。</li><li>ssl_protocol ：SSL 协议，如 tlsvl 。</li><li>ssl_key_exchange ：SSL 密钥交换算法，如 rsa 。</li><li>ssl_cipher ：SSL 加密算法，如 aes_256_cbc 。</li><li>ssl_hash ：SSL 哈希算法，如 sha 。</li><li>peer_cert_subject ：对端的 SSL 安全证书的主题，基于 RFC4514 的形式。 peer_cert_issuer ：对端 SSL 安全证书的发行者， 基于 RFC4514 的形式。 </li><li>peer_cert_validity ：对端 SSL 安全证书的有效期。 </li><li>state ：连接状态，包括 starting、tuning、opening、running、flow、blocking、blocked、closing、closed 这几种。 </li><li>channels ：该连接中的信道个数。 </li><li>protocol ：使用的 AMQP 协议的版本，当前是｛0,9,1｝或者｛0,8,0｝。注意，如果客户端请求的是 AMQP 0-9 的连接， RabbitMQ 也会将其视为 0-9-1 。</li><li>auth_mechanism ：使用的 SASL 认证机制，如 PLAIN、AMQPLAIN、EXTERNAL、RABBIT-CR-DEMO 等。</li><li>user ：与连接相关的用户名。 </li><li>vhost ：与连接相关的 vhost 的名称。 </li><li>timeout ：连接超时／协商的心跳间隔，单位为秒。 </li><li>frame_max ：最大传输帧的大小，单位为 B 。</li><li>channel_max ：此连接上信道的最大数量。如果值 0，则表示无上限，但客户端一般会将0转变为 65535 。</li><li>client_properties ：在建立连接期间由客户端发送的信息属性。 </li><li>recv_oct ：收到的字节数。 </li><li>recv_cnt ：收到的数据包个数。</li><li>send_oct ：发送的字节数。 </li><li>send_cnt ：发送的数据包个数。 </li><li>send_pend ：发送队列大小。 </li><li>connected_at ：连接建立的时间戳。</li></ul><h3 id="5-5-list-channels"><a href="#5-5-list-channels" class="headerlink" title="5.5 list_channels"></a>5.5 list_channels</h3><p>返回当前所有信道的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_channels [channelinfoitem ...]</span></span><br></pre></td></tr></table></figure><p><code>channelinfoitem</code> 参数用于指示哪些信息项会包含在结果集中，结果集的列顺序将匹配参数的顺序，取值可以是：</p><ul><li>pid ：与连接相关的 Erlang 进程 ID 。</li><li>connection ：信道所属连接的 Erlang 进程 ID 。</li><li>name ：信道的名称。 </li><li>number ：信道的序号。 </li><li>user ：与信道相关的用户名称。 </li><li>vhost ：与信道相关的 vhost 。</li><li>transactional ：信道是否处于事务模式。 </li><li>confirm ：信道是否处于 publiser confirm 模式。 </li><li>consumer_count ：信道中的消费者的个数。 </li><li>messages_unacknowledged ：已投递但是还未被 ack 的消息个数。</li><li>messages_uncommitted ：已接收但是还未提交事务的消息个数。</li><li>acks_uncommitted ：已 ack 收到但是还未提交事务的消息个数。</li><li>messages_unconfirmed ：已发送但是还未确认的消息个数。如果信道不处于 publisher confirm 模式下，则此值为 0 。</li><li>perfetch_count ：新消费者的 Qos 个数限制，0 表示无上限。</li><li>global_prefetch_count ：整个信道的 Qos 个数限制，0 表示无上限。</li></ul><h3 id="5-6-list-consumers"><a href="#5-6-list-consumers" class="headerlink" title="5.6 list_consumers"></a>5.6 list_consumers</h3><p>列举消费者信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_consumers [-p vhost]</span></span><br></pre></td></tr></table></figure><p>每行将显示由制表符分隔的己订阅队列的名称、相关信道的进程标识、 consumerTag、是否需要消费端确认、 prefetch_count 及参数列表这些信息。</p><h3 id="5-7-其它"><a href="#5-7-其它" class="headerlink" title="5.7 其它"></a>5.7 其它</h3><p>显示 Broker 状态，比如当前 Erlang 节点上运行的应用程序、RabbitMQ/Erlang 的版本信息、 OS 的名称、内存及文件描述符等统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl status</span></span><br></pre></td></tr></table></figure><p>对 RabbitMQ 节点进行健康检查，确认应用是否正常运行、list_queues 和 list_channels 是否能够正常返回等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl node_health_check</span></span><br></pre></td></tr></table></figure><p>显示每个运行程序环境中每个变量的名称和值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl environment</span></span><br></pre></td></tr></table></figure><p>为所有服务器状态生成一个服务器状态报告，井将输出重定向到一个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl report</span></span><br></pre></td></tr></table></figure><p>执行任意 Erlang 表达式：（此处暂时不作eval扩展）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl <span class="built_in">eval</span> &#123;expr&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第六节-HTTP-API接口管理"><a href="#第六节-HTTP-API接口管理" class="headerlink" title="第六节 HTTP API接口管理"></a>第六节 HTTP API接口管理</h2><h3 id="6-1-HTTP-API接口功能"><a href="#6-1-HTTP-API接口功能" class="headerlink" title="6.1 HTTP API接口功能"></a>6.1 HTTP API接口功能</h3><p>RabbitMQ Management 插件不仅提供了 Web 管理界面，还提供了 HTTP API 接口来方便调用。比如创建一个队列，就可以通过 PUT 方法调用 <code>/api/queues/vhost/name</code> 接口来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root123 -H <span class="string">"content-type:application/json"</span></span></span><br><span class="line">-XPUT -d '&#123;"auto_delete":false,"durable":true,"node":"rabbit@node2"&#125;' </span><br><span class="line">http://192.168.0.2:15672/api/queues/%2F/queue</span><br><span class="line"></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">server: Cowboy</span><br><span class="line">date: Fri, 25 Aug 2017 06:03:17 GMT</span><br><span class="line">content-length: 0</span><br><span class="line">content-type: application/json</span><br><span class="line">vary: accept, accept-encoding, origin</span><br></pre></td></tr></table></figure><p><code>%2F</code> 即 <code>/</code> 默认的 vhost，特殊字符需要在HTTP URL中进行转义。</p><p>完全基于 RESTful 风格：</p><ul><li>GET 方法一般用来获取如集群、节点、队列、交换器等信息。</li><li>PUT 方法用来创建资源，如交换器、队列之类的。</li><li>DELETE 方法用来删除资源。</li><li>POST 方法也是用来创建资源的，与 PUT 不同的是，POST 创建的是无法用具体名称的资源。比如绑定关系（bindings）和发布消息（publish）无法指定一个具体的名称。</li></ul><h3 id="6-2-接口列表"><a href="#6-2-接口列表" class="headerlink" title="6.2 接口列表"></a>6.2 接口列表</h3><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 10%;}table th:nth-of-type(3){width: 10%;}table th:nth-of-type(4){width: 10%;}table th:nth-of-type(5){width: 60%;}</style><table><thead><tr><th style="text-align:center">GET</th><th style="text-align:center">PUT</th><th style="text-align:center">DELETE</th><th style="text-align:center">POST</th><th>Path &amp; Description</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/overview <br>描述整个系统的各种信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/cluster-name <br>集群的名称</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/nodes <br>集群中节点的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/nodes/name <br>集群中单个节点的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/extensions <br>管理插件的扩展列表</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/definitions <br>GET 方法列出集群中所有的元数据信息，包括交换器、队列、绑定关系、用户、 host 权限及参数。<br>POST 方法用来加载新的元数据信息，不过需要注意如下内容： <br>(1）新的原数据信息会与原本的合并，如果旧的元数据信息中某些项在新加载的 元数据中没有定义， 则不受任何影响<br> (2）对于交换器、队列及绑定关系等不可变的内容，如果新旧元数据有冲突，则会报错 <br>(3）对于其他的可变的内容，如果新旧元数据有冲突，则新的会替换旧的<br> (4）如果在加载过程中发生错误，加载过程会停止，最终只能加载到部分新的元数据信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/definitions/vhost<br>将/api/definitions 接口细化到 vhost 级别，其余内容同上</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/connections<br>所有的连接信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/vhost/connections<br>指定的 vhost 中所有连接信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/connections/name<br>GET 方法列出指定连接的信息<br>DELETE 方法可以 close 指定的连接</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/connections/name/channels<br>指定连接的所有信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/channels<br>所有信道的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/vhost/channels <br>指定的 vhost 中所有信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/channels/channel <br>指定的信道信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/consumers <br>所有的消费者信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/consumers/vhost <br>指定 vhost 中的所有消费者信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges <br>所有交换器信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost <br>指定 vhost 中所有交换器信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/exchanges/vhost/name<br>GET 方法列出一个指定的交换器信息。<br>PUT 方法可以声明一个交换器，对应的内容可以参考如下： <br>{“type”:”direct”,”auto_ delete”:false,”durable”:true ,”internal”:false,”arguments”:{}} <br>其中 type 是必需的，其他都是可选的。 <br>DELETE 方法可以删除指定的交换器，其中可以添加 if-unused=true 参数用来防止有队列与其绑定时能够被删除</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost/name/bindings/source<br>列出指定交换器的所有绑定关系，此交换器需为绑定关系的源端</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/exchanges/vhost/name/bindings/destination<br>列出指定交换器的所有绑定关系，此交换器帘为绑定关系的目的端</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/exchanges/vhost/name/publish<br>向指定的交换器中发送一条消息，对应的内容可以参考： <br>{“properties”:{},”routing_key”,”my key”,”payload:”my body”,”payload_ encoding”:”string”} <br>这里所有的项都是必需的，如果发送成功，会返回 ｛”routed”:true} 。这个接口不适合做稳定、高效的发送之用 ，以采用其他的方式比如通过 AMQP 协议或者其他长连接的协议</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues<br>列出所有的队列信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues/vhost<br>列出指定的 vhost 下所有的队列信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/queues/vhost/name<br>GET 方法列出执行的队列信息<br>PUT 方法可声明一个队列，对应的内容可以参考： <br>{“auto_delete”:false,”durable”:true,”arguments”:{},”node”:”rabbit@smacmullen”} <br>其中所有的项都是可选的。 <br>DELETE 方法用来删除一个队列，当然可以指定 if-empty 或 if-unused 参数</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/queues/vhost/name/bindings<br>列出指定队列的所有绑定关系</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/queues/vhost/name/contents<br>清空（purge）指定的队列</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/queues/vhost/name/actions<br>对指定的队列附加一些动作，对应的内容可以参考：<br>{“action”:”sync”｝ <br>目前仅支持 sync 和 cancel_sync</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/queues/vhost/name/get<br>从指定队列中获取消息，对应的内容可以参考： <br>{“count”:5,”requeue”:true,”encoding”:”auto”,”truncate”:50000}<br>count 表示最大能获取的消息个数，实际可能小于这个值；requeue 表示获取到这些消息时是否从队列中删除，如果 requeue 为 true ，则消息不会被删除，但是消息的 redelivered 标示会被设置；encoding 表示编码格式，两种取值：auto 和 base64，auto 指如果消息符合 UTF-8 格式则返回 string 类型，否则为 base64 类型； truncate表示如果消息的 payload 过指定大小会被截断。除了 truncate 其余项都是必需的。注意这个接口是用来做测试用的，如果要持续的消费队列的消息，需要采用其他的方法</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/bindings<br>列出所有绑定关系的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/bindings/vhost<br>列出指定的 vhost 中所有绑定关系的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/bindings/vhost/e/exchange/q/queue<br>GET 方法列出一个指定的交换器和一个指定的队列中的所有绑定关系的信息。注意一个交换器和一个队列之间可以绑定多次.。<br>POST 用来添加绑定关系，对应的内容可以参考：<br> {“routing_ key”:”my_routing_ key”,”arguments”:{}} 其中所有的项都是可选的</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/bindings/vhost/e/exchange/q/queue/props<br>GET 方法列出一个交换器和一个队列的一个单独的绑定关系的信息 <br>DELETE 方法用来解绑相应的绑定关系，其中 props 表示的是 /api/bindings 返回的绑定关系列表里的 properties_key 的值，具体是指绑定时 routingkey 与 arguments 的哈希值的组合，一般 arguments 为空，此时 properties_key 等于 routingkey</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">X</td><td>/api/bindings/vhost/e/source/e/destination<br>GET 方法用来列出两个交换器的所有绑定关系的信息<br>POST 方法用来添加绑定关系，与接口 /api/bindings/vhost/e/exchange/q/queue 相似</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/bindings/vhost/e/source/e/destination/props<br>与接口/api/bindings/vhost/e/exchange/q/queue/props 相似，只不过是两个交换器之间的关系</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts<br>列出所有 vhost 的信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/vhosts/name <br>GET 方法列出指定 vhost 的信息<br>PUT 方法用来添加 vhost，host 通常只有一个名字，所以不需要任何内容以做请求之用。<br>DELETE 方法用来删除 vhost</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/vhosts/name/permissions<br>列出指定 vhost 的所有权限信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/users<br>列出所有的用户信息</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/users/name<br>GET 方法列出指定的用户信息<br>POST 方法用来添加一个用户，对应的内容参考：<br>{“password”:”secret”,”tags”:”administrator”} <br>或者<br>{“password_hash”:”2lmotb814HODViLaK9Fxi619ds8=”,”tags”:”administrator”} <br>其中 tags 是必需的，用来标识用户角色。对于 password 或者 password_hash，两者可以择其一。 如果 password_hash 为“”，则用户可以无密码登录。<br>DELETE 方法用来删除指定的用户</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/users/user/permissions<br>用来获取指定用户的所有权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/wboami<br>当前的登录用户</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/perrnissions<br>列出所有用户的所有权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/permissions/vhost/user<br>GET 方法列出指定的权限<br>PUT 方法添加指定的权限，对应的内容惨考：<br>{“configure”:”.*“,”write”:”.*“,”read”:”.*“} <br>所有项都是必需的，对应 configure、write、read 的细节可以参考 5.1节 <br>DELETE 方法用来删除指定的权限</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters<br>列出所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters/component<br>列出指定组件（比如 federation-upstream、shovel 等）的所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/parameters/component/vhost<br>列出指定 vhost 和组件的所有 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/parameters/component/vhost/name<br>GET 方法列出一个指定的 vbost 级别的 Parameter<br>PUT 方法用来设置一个 Parameter ，对应的内容参考如下：<br> {“vhost”:”/“,”component”:”federation”,”name”:”local_username”,”value”:”guest”} <br>DELETE 方法用来删除一个指定的 vhost 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/global-parameters<br>列出所有的 global 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/global-parameters/name<br>GET 方法列出一个指定的 global 级别的 Parameter<br>PUT 方法用来设置一个指定的 global 级别的 Parameter，对应的内容参考：<br>{“name”:”user_ vhost_mapping”,”value”:{“guest”:”/“,”rabbit”:”warren”}}<br>DELETE 方法用来删除一个指定的 global 级别的 Parameter</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/policies<br>列出所有的 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/policies/vhost<br>列出指定 vhost 下的所有 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center"></td><td>/api/policies/vhost/name<br>GET 方法列出指定的 Policy<br>PUT 方法用来设置 Policy 对应的内容可以参考：<br>{“pattern”:”^amq.”,”definition”: {“federation-upstream-set”:”all”}, “priority”:0, “apply-to”:”all”} <br>其中 pattern 和 definition 是必需的，其余可选。<br>DELETE 方法用来删除一个指定的 Policy</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>api/aliveness-test/vhost<br>声明一个队列，并基于其上生产和消费一条消息，用来测试系统是否运行完好。这个接口可以方便一些监控工具〈如 Zabbix ）的调用。如果系统运行完好，调用这接口会返回 {“status”:”ok”}，状态码为 200</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/healthchecks/node<br>对当前节点中进行基本的健康检查，包括 RabbitMQ 应用、信道、队列是否正常运行且无告警。如果一切正常则接口返回：<br>{“status”:”ok”} <br>如果有异常则接口返回： <br>{“status”:”failed”,”reason”,”string”} <br>不管正常与否，状态都是 200</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td>/api/healthchecks/node/node<br>对指定节点进行基本的健康检查，其余同 /api/healthchecks/node</td></tr></tbody></table><p>创建、显示和删除队列 queue 可以这样实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin -u root -p rootl23 <span class="built_in">declare</span> queue name=queue1</span></span><br><span class="line">queue declared </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin list queues</span></span><br><span class="line">+--------+----------+</span><br><span class="line">|  name  | messages |</span><br><span class="line">+--------+----------+</span><br><span class="line">| queue1 |  0       |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin -u root -p rootl23 delete queue name=queue1</span></span><br><span class="line">queue deleted</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin list queues</span></span><br><span class="line">No items</span><br></pre></td></tr></table></figure><p>rabbitmqadmin 需要安装，可以通过Web管理界面左下角 【Command Line】进行下载，或者如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://192.168 0.2:15672/cli/rabbitmqadmin</span></span><br><span class="line">--2017-08-25 17:32:50-- http://192.168.0.2:15672/cli/rabbitmqadmin</span><br><span class="line">Connecting to 192.168.0.2:15672 ... connected.</span><br><span class="line">HTTP request sent, awaiting response ... 200 OK</span><br><span class="line">Length: 36192 (35K) [application/octet-stream]</span><br><span class="line">Saving to "rabbitmqadmin"</span><br><span class="line"><span class="meta">100%</span><span class="bash">［＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＞］ 36,192 --.-K/s .<span class="keyword">in</span> 0s</span></span><br><span class="line">2017-08-25 17:32:50 (372 MB/s) - "rabbitmqadmin" saved [36192/36192]</span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x rabbitmqadmin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保已安装python</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python </span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取使用方式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./rabbitmqadmin --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第四章《管理》，内容来自于《RabbitMQ实战指南》，从服务端的角度介绍 RabbitMQ 的一些工具应用，内容包括：rabbitmqctl 工具和 rabbitmq management 插件。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
</feed>
