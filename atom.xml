<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-09-09T13:54:43.310Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Speciosity</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始学习dubbo（二）注册中心和监控中心</title>
    <link href="http://linyishui.top/2020090801.html"/>
    <id>http://linyishui.top/2020090801.html</id>
    <published>2020-09-08T09:50:24.000Z</published>
    <updated>2020-09-09T13:54:43.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo（二）注册中心和监控中心"><a href="#dubbo（二）注册中心和监控中心" class="headerlink" title="dubbo（二）注册中心和监控中心"></a><strong>dubbo（二）注册中心和监控中心</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-dubbo支持的几种注册中心"><a href="#1-1-dubbo支持的几种注册中心" class="headerlink" title="1.1 dubbo支持的几种注册中心"></a><strong>1.1 dubbo支持的几种注册中心</strong></h3><ul><li><strong>Multicast</strong>：不需要启动任何中心节点，只要广播地址一样，就可以互相发现。</li><li><strong>Zookeeper</strong>：Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</li><li><strong>Nacos</strong>：Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 <a href="https://github.com/apache/incubator-dubbo/tree/master/dubbo-registry/dubbo-registry-nacos" target="_blank" rel="noopener"><code>dubbo-registry-nacos</code></a> 则是 Dubbo 融合 Nacos 注册中心的实现。</li><li><strong>Redis</strong>：使用 Redis 的 Key/Map 结构存储数据结构，使用 Redis 的 Publish/Subscribe 事件通知数据变更。</li><li><strong>Simple</strong>：Simple 注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。</li></ul><h3 id="1-2-Zookeeper注册中心"><a href="#1-2-Zookeeper注册中心" class="headerlink" title="1.2 Zookeeper注册中心"></a><strong>1.2 Zookeeper注册中心</strong></h3><p>官方推荐的注册中心，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境。如下图树型结构。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/zookeeper.jpg" alt></p><p>流程说明：</p><ul><li><strong>服务提供者启动时</strong>: 向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li><strong>服务消费者启动时</strong>: 订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li><strong>监控中心启动时</strong>: 订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址。</li></ul><p>支持以下功能：</p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求</li><li>当设置 <code>&lt;dubbo:registry check=&quot;false&quot; /&gt;</code> 时，记录失败注册和订阅请求，后台定时重试</li><li>可通过 <code>&lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt;</code> 设置 zookeeper 登录信息</li><li>可通过 <code>&lt;dubbo:registry group=&quot;dubbo&quot; /&gt;</code> 设置 zookeeper 的根节点，不配置将使用默认的根节点。</li><li>支持 <code>*</code> 号通配符 <code>&lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;</code>，可订阅服务的所有分组和所有版本的提供者</li></ul><hr><h2 id="第二节-使用"><a href="#第二节-使用" class="headerlink" title="第二节 使用"></a><strong>第二节 使用</strong></h2><p>学习环境：LG笔记本 + Win10</p><h3 id="2-1-注册中心"><a href="#2-1-注册中心" class="headerlink" title="2.1 注册中心"></a><strong>2.1 注册中心</strong></h3><p>首先安装Zookeeper注册中心，下载地址：<a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">Zookeeper - download</a></p><p>包结构：</p><ul><li>bin：二进制执行文件，如 <code>zkServer.cmd</code> 可用于Win10执行。</li><li>conf：配置文件 <code>.cfg</code> 。</li><li>contrib：</li><li>dist-maven：</li><li>docs：</li><li>lib：</li><li>recipes：</li><li>src：</li></ul><p>首次启动 <code>zkServer.cmd</code> 会出错。</p><p>找到默认配置文件，创建副本并改名为 <code>zoo.cfg</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 数据存储位置</span><br><span class="line">dataDir=../data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure><p>再次启动 <code>zkServer.cmd</code> 。</p><p>启动 <code>zkCli.cmd</code> 简单使用以下Zookeeper。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取根目录文件</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] get /</span><br><span class="line"></span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看根目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建节点<span class="built_in">test</span></span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /test 123456</span><br><span class="line">Created /test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /</span><br><span class="line">[zookeeper, test]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取<span class="built_in">test</span>节点</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] get /test</span><br><span class="line">123456</span><br><span class="line">cZxid = 0x4</span><br><span class="line">ctime = Tue Sep 08 20:10:35 CST 2020</span><br><span class="line">mZxid = 0x4</span><br><span class="line">mtime = Tue Sep 08 20:10:35 CST 2020</span><br><span class="line">pZxid = 0x4</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x100061cf1510001</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h3 id="2-2-监控中心"><a href="#2-2-监控中心" class="headerlink" title="2.2 监控中心"></a><strong>2.2 监控中心</strong></h3><p>在GitHub找到dubbo项目：<a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">apache/dubbo</a>。往下找到ecosystem，首先下载Dubbo Admin。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010101.png" alt></p><p>查看 <code>application.properties</code> 中Zookeeper地址是否正确。</p><p>在Idea中运行或用Maven打包启动，注意运行端口。</p><p>生产环境配置：</p><ol><li><p>下载代码: <code>git clone https://github.com/apache/dubbo-admin.git</code></p></li><li><p>在 <code>dubbo-admin-server/src/main/resources/application.properties</code>中指定注册中心地址</p></li><li><p>构建</p><blockquote><ul><li><code>mvn clean package</code></li></ul></blockquote></li><li><p>启动</p><ul><li><code>mvn --projects dubbo-admin-server spring-boot:run</code><br>或者</li><li><code>cd dubbo-admin-distribution/target; java -jar dubbo-admin-0.1.jar</code></li></ul></li><li><p>访问 <code>http://localhost:8080</code></p></li></ol><p>开发环境配置：</p><ul><li>运行<code>dubbo admin server</code> <code>dubbo admin server</code>是一个标准的spring boot项目, 可以在任何java IDE中运行它</li><li>运行<code>dubbo admin ui</code> <code>dubbo admin ui</code>由npm管理和构建，在开发环境中，可以单独运行: <code>npm run dev</code></li><li>页面访问 访问 <code>http://localhost:8081</code>, 由于前后端分开部署，前端支持热加载，任何页面的修改都可以实时反馈，不需要重启应用。</li></ul><p>部署完成后，可以访问 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 来查看所有的restful api。</p><p>访问UI对应地址。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010102.png" alt></p><p>默认使用 root/root 登陆。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010103.png" alt></p><p>登录后可以查看Dubbon Admin提供的基础功能。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010104.png" alt></p><h3 id="2-3-实例"><a href="#2-3-实例" class="headerlink" title="2.3 实例"></a><strong>2.3 实例</strong></h3><h4 id="（1）需求"><a href="#（1）需求" class="headerlink" title="（1）需求"></a><strong>（1）需求</strong></h4><p>描述：某电商系统，其订单服务需要调用用户服务获取指定用户的所有地址。</p><p>因此我们需要构建两个服务模块：订单服务Web模块，用户服务Service模块。</p><p>实现：订单服务Web模块部署于服务器A，用户服务Service模块部署于服务器B，A可以远程调用B。</p><h4 id="（2）架构"><a href="#（2）架构" class="headerlink" title="（2）架构"></a><strong>（2）架构</strong></h4><p>根据 dubbo《<a href="http://dubbo.apache.org/zh-cn/docs/user/best-practice.html" target="_blank" rel="noopener">服务化最佳实践</a>》：</p><ol><li><p><strong>分包</strong>：建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：<strong>重用发布等价原则</strong>(REP)，<strong>共同重用原则</strong>(CRP)。</p><p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：/xxx/dubbo-reference.xml。</p></li><li><p><strong>粒度</strong>：服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p><p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p><p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p></li><li><p><strong>版本</strong>：每个接口都应定义版本号，为后续不兼容升级提供可能，如： <code>&lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; version=&quot;1.0&quot; /&gt;</code>。</p><p>建议使用两位版本号，因为第三位版本号通常表示兼容升级，只有不兼容时才需要变更服务版本。</p><p>当不兼容时，先升级一半提供者为新版本，再将消费者全部升为新版本，然后将剩下的一半提供者升为新版本。</p></li><li><p><strong>兼容性</strong>：服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。</p><p>各协议的兼容性不同，参见：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/introduction.html" target="_blank" rel="noopener">服务协议</a> 。</p></li><li><p><strong>枚举值</strong>：</p><ul><li>如果是完备集，可以用 <code>Enum</code>，比如：<code>ENABLE</code>, <code>DISABLE</code>。</li><li>如果是业务种类，以后明显会有类型增加，不建议用 <code>Enum</code>，可以用 <code>String</code> 代替。</li><li>如果是在返回值中用了 <code>Enum</code>，并新增了 <code>Enum</code> 值，建议先升级服务消费方，这样服务提供方不会返回新值。</li><li>如果是在传入参数中用了 <code>Enum</code>，并新增了 <code>Enum</code> 值，建议先升级服务提供方，这样服务消费方不会传入新值。</li></ul></li><li><p><strong>序列号</strong>：</p><ul><li>服务参数及返回值建议使用 POJO 对象，即通过 <code>setter</code>, <code>getter</code> 方法表示属性的对象。</li><li>服务参数及返回值不建议使用接口，因为数据模型抽象的意义不大，并且序列化需要接口实现类的元信息，并不能起到隐藏实现的意图。</li><li>服务参数及返回值都必须是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" target="_blank" rel="noopener">传值调用</a>，而不能是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference" target="_blank" rel="noopener">传引用调用</a>，消费方和提供方的参数或返回值引用并不是同一个，只是值相同，Dubbo 不支持引用远程对象。</li></ul></li><li><p><strong>异常</strong>：</p><ul><li>建议使用异常汇报错误，而不是返回错误码，异常信息能携带更多信息，并且语义更友好。</li><li>如果担心性能问题，在必要时，可以通过 override 掉异常类的 <code>fillInStackTrace()</code> 方法为空方法，使其不拷贝栈信息。</li><li>查询方法不建议抛出 checked 异常，否则调用方在查询时将过多的 <code>try...catch</code>，并且不能进行有效处理。</li><li>服务提供方不应将 DAO 或 SQL 等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常。</li></ul></li><li><p><strong>调用</strong>：</p><ul><li>不要只是因为是 Dubbo 调用，而把调用 <code>try...catch</code> 起来。<code>try...catch</code> 应该加上合适的回滚边界上。</li><li>Provider 端需要对输入参数进行校验。如有性能上的考虑，服务实现者可以考虑在 API 包上加上服务 Stub 类来完成检验。</li></ul></li></ol><p>最终：</p><ul><li>gmall-order-web：订单服务Web模块。</li><li>gmall-user：用户服务Service模块</li><li>gmall-interface：公共接口层。</li></ul><h4 id="（3）编码"><a href="#（3）编码" class="headerlink" title="（3）编码"></a><strong>（3）编码</strong></h4><p>创建Maven项目gmall，并分别创建子项目：</p><ul><li>gmall-order-web：订单服务Web模块。</li><li>gmall-user：用户服务Service模块</li><li>gmall-interface：公共接口层。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010105.png" alt></p><h5 id="1-user-service-provider"><a href="#1-user-service-provider" class="headerlink" title="1.user-service-provider"></a><strong>1.user-service-provider</strong></h5><p>pom.xml，分别引入dubbo和zookeeper。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入dubbo --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>provider.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"user-service-provider"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"127.0.0.1:2181"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20882"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4、暴露服务   ref：指向服务的真正的实现对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"userServiceImpl01"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--统一设置服务提供方的规则  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务的实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl01"</span> <span class="attr">class</span>=<span class="string">"gmall.service.impl.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"userServiceImpl02"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl02"</span> <span class="attr">class</span>=<span class="string">"gmall.service.impl.UserServiceImpl2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 连接监控中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"provider.xml"</span>);</span><br><span class="line">ioc.start();</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserServiceImpl.....old..."</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">"北京市昌平区宏福科技园综合楼3层"</span>, <span class="string">"1"</span>, <span class="string">"李老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"Y"</span>);</span><br><span class="line">UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">"深圳市宝安区西部硅谷大厦B座3层（深圳分校）"</span>, <span class="string">"1"</span>, <span class="string">"王老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"N"</span>);</span><br><span class="line"><span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">Thread.sleep(4000);</span></span><br><span class="line"><span class="comment">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">e.printStackTrace();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserServiceImpl.....new..."</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">"北京市昌平区宏福科技园综合楼3层"</span>, <span class="string">"1"</span>, <span class="string">"李老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"Y"</span>);</span><br><span class="line">UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">"深圳市宝安区西部硅谷大厦B座3层（深圳分校）"</span>, <span class="string">"1"</span>, <span class="string">"王老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"N"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceStub</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceStub</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入的是userService远程的代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserServiceStub</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.userService = userService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"UserServiceStub....."</span>);</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isEmpty(userId)) &#123;</span><br><span class="line"><span class="keyword">return</span> userService.getUserAddressList(userId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-order-service-consumer"><a href="#2-order-service-consumer" class="headerlink" title="2.order-service-consumer"></a><strong>2.order-service-consumer</strong></h5><p>pom.xml，也分别引入dubbo和zookeeper。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>order-service-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入dubbo --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>consumer.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"gmall.service.impl"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"order-service-consumer"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  配置本地存根--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明需要调用的远程服务的接口；生成远程服务代理  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">1）、精确优先 (方法级优先，接口级次之，全局配置再次之)</span></span><br><span class="line"><span class="comment">2）、消费者设置优先(如果级别一样，则消费方优先，提供方次之)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- timeout="0" 默认是1000ms--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- retries="":重试次数，不包含第一次调用，0代表不重试--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 幂等（设置重试次数）【查询、删除、修改】、非幂等（不能设置重试次数）【新增】 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span> <span class="attr">retries</span>=<span class="string">"3"</span> <span class="attr">version</span>=<span class="string">"*"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:method name="getUserAddressList" timeout="1000"&gt;&lt;/dubbo:method&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置当前消费者的统一规则：所有的服务都不检查 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:consumer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:monitor address="127.0.0.1:7070"&gt;&lt;/dubbo:monitor&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</span><br><span class="line"></span><br><span class="line">OrderService orderService = applicationContext.getBean(OrderService.class);</span><br><span class="line"></span><br><span class="line">orderService.initOrder(<span class="string">"1"</span>);</span><br><span class="line">System.out.println(<span class="string">"调用完成...."</span>);</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、将服务提供者注册到注册中心（暴露服务）</span></span><br><span class="line"><span class="comment"> * 1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator)</span></span><br><span class="line"><span class="comment"> * 2）、配置服务提供者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2、让服务消费者去注册中心订阅服务提供者的服务地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"用户id："</span>+userId);</span><br><span class="line"><span class="comment">//1、查询用户的收货地址</span></span><br><span class="line">List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);</span><br><span class="line"><span class="keyword">for</span> (UserAddress userAddress : addressList) &#123;</span><br><span class="line">System.out.println(userAddress.getUserAddress());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addressList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-gmall-interface"><a href="#3-gmall-interface" class="headerlink" title="3.gmall-interface"></a><strong>3.gmall-interface</strong></h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>UserAddress</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userAddress; <span class="comment">//用户地址</span></span><br><span class="line">    <span class="keyword">private</span> String userId; <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> String consignee; <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNum; <span class="comment">//电话号码</span></span><br><span class="line">    <span class="keyword">private</span> String isDefault; <span class="comment">//是否为默认地址    Y-是     N-否</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//constructor and getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化订单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照用户id返回所有的收货地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="http://dubbo.apache.org/zh-cn/docs/user/dependencies.html" target="_blank" rel="noopener">Dubbo官网-文档</a></p></blockquote><blockquote><p>尚硅谷-dubbo</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习Dubbo，第二章《注册中心和监控中心》
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="dubbo" scheme="http://linyishui.top/tags/dubbo/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>文档编辑器（持续更新）</title>
    <link href="http://linyishui.top/2020090601.html"/>
    <id>http://linyishui.top/2020090601.html</id>
    <published>2020-09-06T11:05:38.000Z</published>
    <updated>2020-09-06T11:53:20.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文档编辑器"><a href="#文档编辑器" class="headerlink" title="文档编辑器"></a><strong>文档编辑器</strong></h1><h3 id="MarkDown工具"><a href="#MarkDown工具" class="headerlink" title="MarkDown工具"></a><strong>MarkDown工具</strong></h3><p>记录一下日常使用过的md工具，一般都是用来写博客和日记，办公反而很少用到。</p><h4 id="（1）VSCode"><a href="#（1）VSCode" class="headerlink" title="（1）VSCode"></a><strong>（1）VSCode</strong></h4><p>最开始使用VSCode来编辑MarkDown文档，优点是大部分程序员都已经有了这个工具，不用再下载。</p><p>但早期写博客时，总感觉效率上还有所欠缺，因为VSCode的定位是一个文本编辑器，而不是富文本编辑器，所以不能像一些Markdown编辑器一样，获得所见即所得的体验。</p><p>所以在文档内容比较长时，就很难快速定位到想要修改的内容。</p><h4 id="（2）Typora"><a href="#（2）Typora" class="headerlink" title="（2）Typora"></a><strong>（2）Typora</strong></h4><p>因为我要整理的文档内容越来越长，所以如何提高写作效率成为我需要考虑的一个问题。我换用了正规的Markdown编辑器——Typora，它能让我像写Word一样的直接在效果页面写作，常用的MarkDown格式也很方便生成，并且支持多种格式的导入导出。</p><p>很长一段时间，我都在使用Typora作为写作工具。</p><p>推荐插件：</p><ul><li>Typora：<ul><li>VLOOK</li></ul></li></ul><p>但最近发现Typora经常会有一些莫名其妙的BUG，并且在文档超过2MB左右就会限制无法打开，这逼迫我必须再寻找一个工具来代替Typora。</p><h4 id="（3）MarkText"><a href="#（3）MarkText" class="headerlink" title="（3）MarkText"></a><strong>（3）MarkText</strong></h4><p>虽然没有文件大小限制，但非常卡顿，切换源码格式直接卡崩溃了，弃用。</p><p>无奈，先用VSCode来处理大文件，平时还继续用Typora。</p><h4 id="（4）VSCode插件"><a href="#（4）VSCode插件" class="headerlink" title="（4）VSCode插件"></a><strong>（4）VSCode插件</strong></h4><p>推荐插件：</p><ul><li>VSCode：<ul><li>Markdown All in One</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      简单整理工作和学习时常用的文档编辑器，持续更新中。
    
    </summary>
    
      <category term="实用工具" scheme="http://linyishui.top/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="tools" scheme="http://linyishui.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（四）第一天即开口</title>
    <link href="http://linyishui.top/2020090503.html"/>
    <id>http://linyishui.top/2020090503.html</id>
    <published>2020-09-05T13:28:52.000Z</published>
    <updated>2020-09-07T10:38:16.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一天即开口"><a href="#第一天即开口" class="headerlink" title="第一天即开口"></a><strong>第一天即开口</strong></h1><h3 id="词汇量不够怎么办"><a href="#词汇量不够怎么办" class="headerlink" title="词汇量不够怎么办"></a><strong>词汇量不够怎么办</strong></h3><p>当你作为初学者，要在第一天开口说外语时，你的第一反应是：“我还什么词都不会呢！”最初的一对一交流并不需要你说出几千个单词，可能你只需要掌握能够应对两三个问题的单词，感受一下说出这门语言是什么样子就够了。</p><h3 id="最初几小时"><a href="#最初几小时" class="headerlink" title="最初几小时"></a><strong>最初几小时</strong></h3><p>为第一次交谈做准备：</p><ul><li>选择一个正在使用目标语言的人，或是你觉得作为语言联系的搭档也许不错的人。</li><li>社交软件或邮件约一个具体时间。</li><li>通过线上方式用所学语言进行交流。</li></ul><p>几个小时的准备工作：</p><ul><li>可以看一些旅行常用语一类的书。</li><li>通过免费的资源学习一些常用语：<ul><li>How are you?</li><li>What`s your name?</li><li>My name is …</li><li>I don`t understand.</li><li>Could you repeat that / Again, please.</li><li>Can you speak slower please.</li><li>What does that/… mean?</li></ul></li><li>采用关键词记忆法来记住单词或固定词组：<ul><li>Yes、NO</li><li>Please、Thank you</li><li>Hello</li><li>Good Bye</li></ul></li></ul><h3 id="有不会的词就作个小弊"><a href="#有不会的词就作个小弊" class="headerlink" title="有不会的词就作个小弊"></a><strong>有不会的词就作个小弊</strong></h3><p>虽然你的初次对话可能只持续了10秒或20秒，但你可以回归书本或笔记，回想你想说但不会说的内容，把这些短语做成学习卡，然后学会它们。</p><p>你可以随身带一个小本子，列出你想说的内容以及还未掌握好的偏难词汇。</p><h3 id="改变措辞：让交谈简单直接"><a href="#改变措辞：让交谈简单直接" class="headerlink" title="改变措辞：让交谈简单直接"></a><strong>改变措辞：让交谈简单直接</strong></h3><p>初学者会很快学会一件事：<strong>在脑海中用母语组织好想表达的内容，然后再翻译成目标语言</strong>。但如果你想达到真正流利的水准，<strong>这个多余的步骤会把你的速度拖慢很多。</strong>当然作为初学者，这是可以容忍的。</p><p>比如你聊到未来的计划，你本来打算说:”I will travel to Spain in July for a two-week vacation.”。然而你突然意识到你不会用将来时，忘记了”travel to”（去旅行），甚至想不起”July”和”vacation”对应单词。</p><p>如果你是传统型的语言学习者，你应该会放弃了，接受自己还未“准备好”的事实。但执着于交流而不是表达准确性的人会考虑改换措辞，运用其他词汇来传达同样的意思。</p><p>为了省去动词将来时词形变化的烦恼，很多语言都有一个很便捷的特征：动词不定式跟在情态动词之后。比如”want”、”need”、”would like”、”should”、”may”、”can”这样的词的一般现在时形式与”I”连用，如”I want”、”I can”，后面就可以按词典上列出的不定式形式来使用你想用的重要动词”to travel”。想想”I want to travel”和”I will travel”的区别，虽然很重要，但对于表达意思又没那么重要了。你可能不知道”travel”这个词，但可以用”go”来代替。</p><p>所以上述句子可以转换为”I want to go to Spain this summer to be a tourist for two weeks”。</p><h3 id="最初几天"><a href="#最初几天" class="headerlink" title="最初几天"></a><strong>最初几天</strong></h3><p><strong>反馈至关重要。</strong>重复你在以前的谈话中说过的内容，每次都更加自信的说出来。准备你自己的“演讲稿”，在早期这种可预测的模板是可以接受的，当然以后的阶段就不太适用了。</p><h3 id="运用分类体系来管理学到的内容"><a href="#运用分类体系来管理学到的内容" class="headerlink" title="运用分类体系来管理学到的内容"></a><strong>运用分类体系来管理学到的内容</strong></h3><p>致力于语言交流和应试或顺畅阅读的学习者不同，前者所有的努力都指向同一个目标：在下一次会话中表现的更出色一些。</p><p>偶尔回归传统的语言课程，尤其是和一些聚焦口语的课程相比更能满足你自身学习需求的课程。在解决了“说”这个难题后，就可以尽量遵循课程建议进行学习。如果课程中的内容不适合现在的你学习，请跳过它。比如你可能要学习游客常见口语，但对于正在家中自学的你来说并不是最想学的内容，你可能只想问你的对话搭档今天做了什么。</p><h3 id="我不明白对方的回复"><a href="#我不明白对方的回复" class="headerlink" title="我不明白对方的回复"></a><strong>我不明白对方的回复</strong></h3><p>早期交流中，你听到的大部分内容似乎都是难以理解的。完全的理解整段话语内容在早期阶段并不合适，提取别人讲话中你能听懂的词汇或片段，由此推断对方在说什么。</p><p>不要抱定“我不懂”的想法不放，根据语境去猜测对方的内容，并进行合理的回复。</p><h3 id="作者的两小时波兰语经历"><a href="#作者的两小时波兰语经历" class="headerlink" title="作者的两小时波兰语经历"></a><strong>作者的两小时波兰语经历</strong></h3><p>作者曾因要做演讲而进行过一次两个小时的波兰语Skype学习：</p><ul><li>使用常用语手册学习一些初次会话的基础词汇：<ul><li>“I just started learning Polish”</li><li>“I am going to Poland soon”</li></ul></li><li>用电子词典查好交流要用的词汇。</li><li>在屏幕上打开一个文本文档，在上面记录可能记不住的词，准备几十个这样的词。</li><li>当对方说出一个你不会的词时，请他在聊天窗口打出来，复制下来并抽空学习。</li></ul><p>在这次半个小时的对话中，作者坚持一直使用波兰语，虽然很多次弄不懂对方说什么，自己也说不出一些简单的内容，这种不完美的感觉会一直伴随着学习的过程。</p><p>建议用两周的时间来学习一下世界语，有研究表明学习一年世界语再学一年法语的学生比直接学习两年法语的学生更有优势。</p><p>世界语的设计很简单，可以让你在很短的时间掌握好它，克服了第一门外语的难关后，你再次学习其他外语会简单很多。</p><h3 id="尽早开始全程目标语交流"><a href="#尽早开始全程目标语交流" class="headerlink" title="尽早开始全程目标语交流"></a><strong>尽早开始全程目标语交流</strong></h3><p>传统的学习方法会用你的母语教你这门语言怎么运作，整个学习过程你都在仔细的剖析目标语的语法和词汇。语言作为交流的手段，从一开始就应该是被使用的。</p><p><strong>你需要培养用目标语思考的习惯。</strong></p><p>在会话中使用其他语言只会拖慢你前进的步伐，关键就是要尽早下定决心，只要你能容忍较长的停顿和不断的查找单词，即使从第一天开口对话也是能做到的。</p><h3 id="对方用你的母语回复怎么办"><a href="#对方用你的母语回复怎么办" class="headerlink" title="对方用你的母语回复怎么办"></a><strong>对方用你的母语回复怎么办</strong></h3><p>好的老师或拍档应该只把母语最终手段来使用，请尽可能用一些手段来作为回报，让对方能尽量使用目标语来对话，指出你是为了学习这门语言而在努力，如果无法得到好的结果，就选择和其他人交谈吧。</p><h3 id="杰克-·-斯帕罗法则：避免因迟疑而耗费时间"><a href="#杰克-·-斯帕罗法则：避免因迟疑而耗费时间" class="headerlink" title="杰克 · 斯帕罗法则：避免因迟疑而耗费时间"></a><strong>杰克 · 斯帕罗法则：避免因迟疑而耗费时间</strong></h3><p>初学者要面临的一个问题是，你在刚开始对话时只会“嗯嗯啊啊”而不得不中止交谈，这很尴尬。早期对话中，犹豫和迟疑是不可避免的，但我们可以用一些小技巧让这些时刻变得不那么紧张和尴尬。</p><p>在《加勒比海盗》中，杰克 · 斯帕罗船长的肢体语言十分丰富，即使不说话也依然生动鲜活。这种方法可以用来保持对方的注意力，比如你想说”I want to go to the supermarket”，当你说道”go to”时你发现你忘记了超市怎么说，你需要一些时间来想想。这个时候你可以看着对方的眼睛，吸引他的全部注意，然后举起食指指向远方，并且面带沉思的凝望所指向的方向。这时你可以说你想去机场、沙漠……只要稍微练习，你可以把这些停顿运用的更加自然。</p><h3 id="碰杯法则：抛开害羞的想法"><a href="#碰杯法则：抛开害羞的想法" class="headerlink" title="碰杯法则：抛开害羞的想法"></a><strong>碰杯法则：抛开害羞的想法</strong></h3><p>碰杯法则——抛开我很害羞的想法，只要接近那个人跟他问好就是了。</p><h3 id="参与即理解"><a href="#参与即理解" class="headerlink" title="参与即理解"></a><strong>参与即理解</strong></h3><blockquote><p><strong>不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。学至于行而止矣。</strong></p><p>​                                                                                            ——中国谚语</p></blockquote><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（三）如何记单词</title>
    <link href="http://linyishui.top/2020090502.html"/>
    <id>http://linyishui.top/2020090502.html</id>
    <published>2020-09-05T10:03:08.000Z</published>
    <updated>2020-09-05T13:18:33.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何快速记住上千个单词"><a href="#如何快速记住上千个单词" class="headerlink" title="如何快速记住上千个单词"></a><strong>如何快速记住上千个单词</strong></h1><h3 id="为什么我们在学校学到的记忆方法不起作用"><a href="#为什么我们在学校学到的记忆方法不起作用" class="headerlink" title="为什么我们在学校学到的记忆方法不起作用"></a><strong>为什么我们在学校学到的记忆方法不起作用</strong></h3><p>如今我们有了越来越多的信息来源，很多人不再学习、背诵任何东西，因为随时可以Google到。这种情况很令人遗憾，因为我们没有发挥自己大脑的最大潜力。</p><p><strong>信息的重复出现让我们以为自己已经记住了它。</strong>我们在学校时，为了学会一个单词唯一的方法就是死记硬背。经过几十次甚至几百次的重复，你可能会在短期记住它，但能否运用就看运气了。</p><p><strong>与其简单的读出或识别出单词，不如尝试更有效的学习方法。</strong></p><h3 id="两种优秀的记忆方法"><a href="#两种优秀的记忆方法" class="headerlink" title="两种优秀的记忆方法"></a><strong>两种优秀的记忆方法</strong></h3><h4 id="方法一：关键字联想记忆法"><a href="#方法一：关键字联想记忆法" class="headerlink" title="方法一：关键字联想记忆法"></a><strong>方法一：关键字联想记忆法</strong></h4><p>当你要记忆一个单词或句子时，需要构建一个有趣的、栩栩如生的、令人难忘的画面或小故事。</p><p><strong>请自己从认识这个词语的第一印象开始，根据读音想象一个场景或故事。</strong></p><p>刚开始可能每个单词都要花费一两分钟来构思故事，但几天或一周后，你会变得熟练起来。而在三四次回想起故事后，你就可以牢牢记住这个词，以后就可以直接知道其含义。</p><h4 id="方法二：间隔重复记忆法"><a href="#方法二：间隔重复记忆法" class="headerlink" title="方法二：间隔重复记忆法"></a><strong>方法二：间隔重复记忆法</strong></h4><p><strong>通过单词卡和词组卡重新排列来辅助记忆。</strong>将记不住的单词排到前面，已知的单词排在后面。目前很多主流的APP都支持这种记忆法。</p><h3 id="用音乐来学习词组和整句"><a href="#用音乐来学习词组和整句" class="headerlink" title="用音乐来学习词组和整句"></a><strong>用音乐来学习词组和整句</strong></h3><p><strong>从词组和整句来开始学习语言可能效果会比从单词开始要更好。</strong>多使用如“厕所在哪里”、“这个多少钱”这样的常用句子。</p><p>记住这些句子并不容易，几百年来，人们常常通过唱歌来背诵文章。首先可以把句子和关键字记忆法结合，在短句的开头来启发记忆。其次，我们要相处适合的曲调来启发记忆，曲调要简洁，就像大本钟的钟声一样。记住想象越离奇，越有利于记忆。</p><h3 id="1分钟迷你讲话稿"><a href="#1分钟迷你讲话稿" class="headerlink" title="1分钟迷你讲话稿"></a><strong>1分钟迷你讲话稿</strong></h3><p>我们了解了怎样记住单词和词组，接下来就是更难的内容——记住整段文字。</p><p>请准备好陌生人见面的几个基本问题的答案：</p><ol><li>你是哪位？</li><li>你从哪里来？</li><li>你做什么工作？</li><li>你为什么要学这种语言？</li></ol><p>你可以用母语写好稿子，拜托一位以所学语言为母语的人帮忙准确的翻译它，或者从书上或网上找到地道的表述，请不要背电脑翻译或自己翻译的句子。</p><p>为每个问题都准备一张卡片，并用记忆法记住每个句子开头的单词和音节，再为每个句子找到一个调子或歌曲。</p><h3 id="单词就是你的武器"><a href="#单词就是你的武器" class="headerlink" title="单词就是你的武器"></a><strong>单词就是你的武器</strong></h3><blockquote><p><strong>不求与人相比，只求突破自己。</strong></p><p>​                                                ——嘉纳治五郎，柔道创始人</p></blockquote><p>学习语言的每一天，你的词汇量都在增加，同时你的沟通能力也会得到提升。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（二）计划</title>
    <link href="http://linyishui.top/2020090501.html"/>
    <id>http://linyishui.top/2020090501.html</id>
    <published>2020-09-05T09:02:28.000Z</published>
    <updated>2020-09-05T13:16:28.061Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a><strong>计划</strong></h1><h3 id="设定一个具体化的目标"><a href="#设定一个具体化的目标" class="headerlink" title="设定一个具体化的目标"></a><strong>设定一个具体化的目标</strong></h3><p><strong>如何定义“流利”这个词语？</strong>牛津字典上的定义：流利，形容词，可准确、自如地表达自己的想法。</p><p>请不要错误的把目标定位外语要达到母语的水平。欧洲几个主要的语言测试组织所使用的一套科学、成熟的语言入门标准——《欧洲共同语言参考标准》（Common European Framework of Reference for Languages，CEFRL系统）定义了三个等级：“A”表示初级水平，“B”表示中级，“C”代表高级。每个等级又分“1”（较差）和“2”（较好）两种程度。</p><p>A级水平就是常说的具有基本语言能力的游客水平，可以进行基础的对话交流。C级水平意味着已经掌握了这门语言，能够达到母语使用者的水平。</p><p><strong>我们将B2及以上的水平定位为流利，能够流利地、自然地以该种语言为母语的人经常进行交流，对于双方而言，这种交流都毫无阻碍。</strong></p><h3 id="达到流利需要多长时间"><a href="#达到流利需要多长时间" class="headerlink" title="达到流利需要多长时间"></a><strong>达到流利需要多长时间</strong></h3><p>作者推荐是3个月内先达到基本对话的水平（B1），高强度的语言学习计划需要绝对的集中和专心，即使你是全职工作，也要挤出时间，每天学几小时。<strong>如果你想要迅速的进步，每天至少两个小时的语言学习是必不可少的。</strong>如果你只能每周投入几个小时，那你没有可能在3个月就掌握流利的外语。</p><p>即使你的期限不是3个月、6个月，也请尽量将一年分成更小的、更可控的多个时间段。</p><h3 id="总是朝着更高一级的目标努力"><a href="#总是朝着更高一级的目标努力" class="headerlink" title="总是朝着更高一级的目标努力"></a><strong>总是朝着更高一级的目标努力</strong></h3><p>只要能和其他人交流，你的语言学习就不算失败。但是，<strong>注意不要用“任何一个小进步都是成功”来纵容自己的懒惰。一定要把自己推出“舒适地带”，如果你设定的目标是你百分百能达到的，说明你的目标还是太低了。</strong></p><h3 id="迷你任务：逼自己离开舒适区"><a href="#迷你任务：逼自己离开舒适区" class="headerlink" title="迷你任务：逼自己离开舒适区"></a><strong>迷你任务：逼自己离开舒适区</strong></h3><p>在语言学习的某个特定时期，你会遇到一些具体问题，“迷你任务”可以帮你尽快解决它们。</p><p>在作者刚开始学汉语时，因为语调不对，别人完全不能听懂他的话。所以他只关注语调，不去管词汇和阅读等问题。一周后，人们可以稍微听懂他的一点话了，之后才开始了基本词汇的学习。</p><p>第二周，作者最大的问题是过度依赖词汇书，所以练习自发的说话变成了迷你任务。很快他也能不看书的去说一些词汇了。</p><p>这种迷你任务可以给你一种真实的、辛苦得来的成就感和进步感，使你集中精力应对问题直到解决它们。比如作者学习汉语时没有给自己设定每周的词汇任务，而是每天看60张词汇卡片，卡片上的词汇都是关于怎样点菜的。</p><p>一个月后，作者达到了瓶颈期，可以凭借记忆进行简单的交谈，语调也还可以。但这些交谈只能持续10~15秒，不算是真正的交谈。所以他开始一个新的迷你任务——提升思维速度的“大脑融合”。“大脑融合”强迫你快速思维，根据听到的信息进行推断、搜索词汇的意思，同时根据语境来理解语言的含义。所以他约了汉语母语的朋友来进行一个小时以上的对话。</p><p>迷你任务的目的就是逼迫自己离开舒适区，从而不断升级、挺过艰难的学习阶段。</p><h3 id="倦怠是放弃语言学习的主要原因之一"><a href="#倦怠是放弃语言学习的主要原因之一" class="headerlink" title="倦怠是放弃语言学习的主要原因之一"></a><strong>倦怠是放弃语言学习的主要原因之一</strong></h3><p>如果整个学习过程都充满了“大脑融合”任务，你可能很快会倦怠。适当的休息，在这段时间忘记语言学习，可能会有效的帮助到你。</p><h3 id="制订行动计划"><a href="#制订行动计划" class="headerlink" title="制订行动计划"></a><strong>制订行动计划</strong></h3><p>没有付诸实践，任何好主意都一文不值。请记住以下几点：</p><ul><li>设定稍高的目标。</li><li>设定具体的期限。</li><li>集中学习语言时，使用迷你任务去专注解决眼前的最大问题。</li><li>如果你的全部时间都用来学习，就要保证休息，不要把自己搞得精疲力竭。</li><li>向外界展示你的学习任务，让朋友和家人监督你。</li></ul><h3 id="我的计划"><a href="#我的计划" class="headerlink" title="我的计划"></a><strong>我的计划</strong></h3><p>因为我最近刚好处于择业期，而且技术上有很多短板需要补齐，所以主要学习内容还是专业技术，语言则作为另一项同时进行的学习任务。</p><p><strong>我会把学习周期定为6个月，每天一个小时的语言学习时间。</strong>也就是明年3到4月份验收成果。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>职业规划</title>
    <link href="http://linyishui.top/2020090401.html"/>
    <id>http://linyishui.top/2020090401.html</id>
    <published>2020-09-04T06:28:26.000Z</published>
    <updated>2020-09-04T08:05:56.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a><strong>职业规划</strong></h1><h2 id="岗位选择"><a href="#岗位选择" class="headerlink" title="岗位选择"></a><strong>岗位选择</strong></h2><p>目前情况：Java后端开发，2年工作经验。</p><p>一年后：Java后端 / 大数据开发 ，3年工作经验</p><h2 id="设定目标"><a href="#设定目标" class="headerlink" title="设定目标"></a><strong>设定目标</strong></h2><p>统计岗位薪酬数据：</p><table><thead><tr><th>Java</th><th>北京</th><th>上海</th><th>杭州</th></tr></thead><tbody><tr><td>1-3年年收入-10分位</td><td>79.948</td><td>76.488</td><td>71.014</td></tr><tr><td>1-3年年收入-25分位</td><td>106.167</td><td>100.479</td><td>94.989</td></tr><tr><td>1-3年年收入-50分位</td><td>146.831</td><td>137.871</td><td>130.364</td></tr><tr><td>1-3年年收入-75分位</td><td>208.853</td><td>186.494</td><td>181.281</td></tr><tr><td>1-3年年收入-90分位</td><td>287.424</td><td>251.109</td><td>247.048</td></tr><tr><td>1-3年月平均收入和人数占比</td><td>13.904/19%</td><td>12.900/22%</td><td>12.608/32%</td></tr><tr><td>3-5年月平均收入和人数占比</td><td>18.544/56%</td><td>17.661/56%</td><td>18.103/55%</td></tr><tr><td>5-10年月平均收入和人数占比</td><td>25.207/24%</td><td>24.766/21%</td><td>24.068/12%</td></tr><tr><td>人数样本</td><td>4162601</td><td>2270467</td><td>1604825</td></tr></tbody></table><p><em>数据来源：Boss直聘</em></p><p>设定岗位筛选条件：3-5年经验，20k以上。</p><h2 id="统计要求"><a href="#统计要求" class="headerlink" title="统计要求"></a><strong>统计要求</strong></h2><table><thead><tr><th>要求</th><th>子项</th><th>掌握程度</th><th>次数</th></tr></thead><tbody><tr><td>工龄</td><td>3年</td><td></td><td>12</td></tr><tr><td>学历</td><td>本科</td><td></td><td>7</td></tr><tr><td>Java</td><td>基础</td><td>基础扎实，JDK源码，多态</td><td>11</td></tr><tr><td></td><td>IO</td><td></td><td>5</td></tr><tr><td></td><td>并发/多线程</td><td></td><td>6</td></tr><tr><td></td><td>集合</td><td></td><td>4</td></tr><tr><td></td><td>JVM</td><td>了解原理</td><td>5</td></tr><tr><td></td><td>网络编程</td><td></td><td>2</td></tr><tr><td>Web框架</td><td>Web开发</td><td>深入了解底层实现</td><td>9</td></tr><tr><td></td><td>Spring</td><td></td><td>8</td></tr><tr><td></td><td>SpringMVC</td><td></td><td>2</td></tr><tr><td></td><td>SpringBoot</td><td></td><td>5</td></tr><tr><td>ORM</td><td>Mybatis</td><td>深入了解底层实现</td><td>7</td></tr><tr><td>数据库</td><td>任一</td><td>熟悉数据库优化</td><td>10</td></tr><tr><td></td><td>Mysql</td><td></td><td>8</td></tr><tr><td></td><td>Oracle</td><td></td><td>4</td></tr><tr><td></td><td>db2</td><td></td><td>2</td></tr><tr><td></td><td>sql优化</td><td></td><td>1</td></tr><tr><td>分布式系统</td><td>项目</td><td>熟悉设计和应用</td><td>6</td></tr><tr><td></td><td>监控、部署</td><td></td><td>1</td></tr><tr><td></td><td>负载均衡</td><td></td><td>1</td></tr><tr><td>分布式缓存</td><td>任一</td><td>熟练使用，优化</td><td>9</td></tr><tr><td></td><td>Redis</td><td></td><td>6</td></tr><tr><td></td><td>Memcache</td><td></td><td>2</td></tr><tr><td></td><td>MongoDB</td><td></td><td>2</td></tr><tr><td></td><td>Hbase</td><td></td><td>1</td></tr><tr><td>消息队列</td><td>任一</td><td>熟悉解决方案及应用场景</td><td>9</td></tr><tr><td></td><td>RabbitMQ</td><td></td><td>4</td></tr><tr><td></td><td>ActiveMQ</td><td></td><td>1</td></tr><tr><td></td><td>Kafka</td><td></td><td>2</td></tr><tr><td>Web服务器</td><td>Nginx</td><td>优化配置与使用</td><td>2</td></tr><tr><td></td><td>Tomcat</td><td></td><td>2</td></tr><tr><td></td><td>缓存服务器</td><td></td><td>1</td></tr><tr><td>中间件</td><td>Elasticsearch</td><td>使用和原理</td><td>1</td></tr><tr><td>UML</td><td></td><td>熟悉</td><td>1</td></tr><tr><td>设计模式</td><td></td><td>了解</td><td>1</td></tr><tr><td>微服务</td><td>任一</td><td></td><td>5</td></tr><tr><td></td><td>Dubbo</td><td></td><td>3</td></tr><tr><td></td><td>Spring Cloud</td><td></td><td>2</td></tr><tr><td>工具</td><td>Docker</td><td>熟练掌握</td><td>1</td></tr><tr><td></td><td>K8s</td><td></td><td>1</td></tr><tr><td></td><td>Linux</td><td>熟悉操作，有Linux环境下多线程、并发、网络编程经验，常用命令</td><td>2</td></tr><tr><td>脚本语言</td><td>任一</td><td>熟悉</td><td>2</td></tr><tr><td></td><td>shell</td><td></td><td>2</td></tr><tr><td></td><td>php</td><td></td><td>1</td></tr><tr><td></td><td>python</td><td></td><td>1</td></tr><tr><td>前端</td><td>JS</td><td></td><td>2</td></tr><tr><td></td><td>Jquery</td><td></td><td>2</td></tr><tr><td></td><td>VUE</td><td></td><td>2</td></tr><tr><td>网络</td><td>基础</td><td></td><td>1</td></tr><tr><td></td><td>TCP/IP</td><td>原理</td><td>1</td></tr><tr><td>开源项目</td><td></td><td>有经验</td><td>2</td></tr><tr><td>高并发、高负载、高可用</td><td></td><td>设计和开发，优先</td><td>7</td></tr><tr><td>分布式队列</td><td></td><td>优先</td><td>1</td></tr><tr><td>分布式任务分发框架</td><td></td><td>优先</td><td>1</td></tr><tr><td>全文检索及分词</td><td></td><td>优先</td><td>1</td></tr><tr><td>海量数据存储和处理</td><td></td><td>优先</td><td>4</td></tr><tr><td>分布式存储</td><td></td><td>优先</td><td>1</td></tr><tr><td>Flink、Clickhouse</td><td></td><td>优先</td><td>1</td></tr><tr><td>Java EE、SOA、OSGI、jax-rs</td><td></td><td>熟悉相关技术</td><td>1</td></tr></tbody></table><h2 id="简单规划"><a href="#简单规划" class="headerlink" title="简单规划"></a><strong>简单规划</strong></h2><p>根据岗位要求进行简单规划，先学陌生的技术，再补不足。</p><p>需要学会和精通的技术：</p><ul><li>Java、集合、多线程、并发编程、网络编程、JVM、IO、NIO</li><li>Spring、Spring MVC、Spring Boot</li><li>MyBatis、MySql、Redis、RabbitMQ、ELK</li><li>Dubbo、Zookeeper 、Spring Cloud</li><li>Linux、Docker、k8s、shell</li><li>网络、操作系统、分布式系统、海量数据处理</li></ul><p>将以上内容补充到《<a href="../2018080801.html" title="Title">Java技术栈-学习路线</a>》。</p><p>最后罗列一下学习的优先级：</p><ul><li><p>需要系统学习：Mysql -&gt; RabbitMQ -&gt; Zookeeper + Dubbo -&gt; Spring Cloud -&gt; Redis</p></li><li><p>只要实战学习：MyBatis -&gt; ELK -&gt; Linux + shell -&gt; Docker -&gt; k8s</p></li></ul>]]></content>
    
    <summary type="html">
    
      简单整理一下Java职场信息，为自己设定一个一年后的目标。
    
    </summary>
    
      <category term="笔记杂谈" scheme="http://linyishui.top/categories/%E7%AC%94%E8%AE%B0%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="other" scheme="http://linyishui.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习dubbo（一）简介和搭建</title>
    <link href="http://linyishui.top/2020090301.html"/>
    <id>http://linyishui.top/2020090301.html</id>
    <published>2020-09-03T06:12:39.000Z</published>
    <updated>2020-09-08T09:47:43.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo（一）简介和搭建"><a href="#dubbo（一）简介和搭建" class="headerlink" title="dubbo（一）简介和搭建"></a><strong>dubbo（一）简介和搭建</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a><strong>1.1 背景</strong></h3><p>网站规模的扩大，技术架构经历了从<strong>单一应用架构</strong>到<strong>垂直应用架构</strong>，最后到<strong>分布式服务架构</strong>和<strong>流动计算架构</strong>的发展历程。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-roadmap.jpg" alt></p><ul><li><strong>单一应用架构</strong>：当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<ul><li>适合小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</li><li>缺点：<ul><li>性能扩展比较难</li><li>协同开发问题</li><li>不利于升级维护</li></ul></li></ul></li><li><strong>垂直应用架构</strong>：当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。<ul><li>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</li><li>缺点： 公用模块无法重复利用，开发性的浪费。</li></ul></li><li><strong>分布式服务架构</strong>：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架</strong>(RPC)是关键。</li><li><strong>流动计算架构</strong>：当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong>。</li></ul><p>分布式系统中每个功能模块之间有复杂的联系，需要有一个<strong>治理系统</strong>确保架构有条不紊的演进。</p><h3 id="1-2-RPC和RMI"><a href="#1-2-RPC和RMI" class="headerlink" title="1.2 RPC和RMI"></a><strong>1.2 RPC和RMI</strong></h3><p>RPC是指Remote Procedure Call Protocol，<strong>远程过程调用协议</strong>，是一种进程间通信方式。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>常见的开源框架包括：</p><ul><li><p>单语言：</p><ul><li><p><strong>RMI</strong>：Java RMI （Remote Method Invocation）- 远程方法调用，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化，能够<strong>让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法</strong>。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过<strong>依赖接口</strong>这种更简单自然的方式。</p></li><li><p><strong>Dubbo</strong>：阿里巴巴开发，只支持Java。</p></li><li><strong>Motan</strong>：微博开发，只支持Java。</li><li><strong>Tars</strong>：腾讯开发，只支持C++。</li><li><strong>Spring Cloud</strong>：Pivotal开发，只支持Java。</li></ul></li><li><p>跨语言：</p><ul><li><p><strong>gRPC</strong>：Google开发。</p></li><li><p><strong>Thrift</strong>：Facebook开发，它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的<a href="https://zh.wikipedia.org/wiki/跨平台" target="_blank" rel="noopener">跨平台</a>高效服务。以前是由Facebook开发的，但它现在是<a href="https://zh.wikipedia.org/wiki/Apache软件基金会" target="_blank" rel="noopener">Apache软件基金会</a>的开源项目了。</p></li><li><p><strong>Avro</strong>：一种远程过程调用和数据序列化框架，是在Apache的Hadoop项目之内开发的。它使用JSON来定义数据类型和通讯协议，使用压缩二进制格式来序列化数据。它主要用于Hadoop，它可以为持久化数据提供一种序列化格式，并为Hadoop节点间及从客户端程序到Hadoop服务的通讯提供一种电报格式。</p><p>它类似于Thrift，但当数据库模式改变时，它不要求运行代码生成程序，除非是对静态类型的语言。</p></li></ul></li></ul><h4 id="（1）RMI工作原理"><a href="#（1）RMI工作原理" class="headerlink" title="（1）RMI工作原理"></a><strong>（1）RMI工作原理</strong></h4><ol><li>服务端向 RMI 注册服务绑定自己的地址，</li><li>客户端通过 RMI 注册服务获取目标地址，</li><li>客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致，</li><li>本地存根对象将调用信息打包，通过网络发送到服务端，</li><li>服务端的 Skeleton 对象收到网络请求之后，将调用信息解包，</li><li>然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。</li></ol><p>服务之间的远程调用有两个关键部分：</p><ul><li>服务间通信：客户端与服务端要建立网络连接，并传递数据。所以通信效率决定着RPC框架的性能（如传递二进制流要快于XML或JSON）</li><li>对象序列化与反序列化：参数对象在网络中传递要进行序列化，接收到后要反序列化解析。所以序列化效率也决定着RPC框架的性能。</li></ul><h4 id="（2）RMI基本概念"><a href="#（2）RMI基本概念" class="headerlink" title="（2）RMI基本概念"></a><strong>（2）RMI基本概念</strong></h4><ol><li>通过<strong>接口</strong>进行远程调用：客户端需要依赖接口，而服务端需要提供该接口的实现。</li><li>通过客户端的 <strong>Stub 对象</strong>和服务端的 <strong>Skeleton 对象</strong>的帮助将远程调用伪装成本地调用：在 J2SE 1.5 版本之前需要通过 rmic 预先编译好客户端的 Stub 对象和服务端的 Skeleton 对象。在之后的版本中，不再需要事先生成 Stub 和 Skeleton 对象。</li><li>通过 <strong>RMI 注册服务</strong>完成服务的注册和发现。</li></ol><p>服务端注册方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化服务对象实例</span></span><br><span class="line">Hello obj = <span class="keyword">new</span> HelloImpl(); </span><br><span class="line"><span class="comment">// 生成可以与服务端通讯的 Stub 对象</span></span><br><span class="line">Hello stub = (Hello) UnicastRemoteObject.exportObject(obj, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// 创建一个本地的 RMI 注册服务，监听端口为 1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程</span></span><br><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>); </span><br><span class="line"><span class="comment">// 将 Stub 对象绑定到注册服务上，这样，客户端可以通过 *Hello* 这个名字查找到该远程对象</span></span><br><span class="line">registry.rebind(<span class="string">"Hello"</span>, stub);</span><br></pre></td></tr></table></figure><p>客户端的服务发现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取注册服务实例，在本例中，由于没有传入任何参数，假定要获取的注册服务实例部署在本机，并监听在 1099 端口上</span></span><br><span class="line">Registry registry = LocateRegistry.getRegistry();</span><br><span class="line"><span class="comment">// 从注册服务中查找服务名为 *Hello* 的远程对象</span></span><br><span class="line">Hello stub = (Hello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 通过获取的 Stub 对象发起一次 RMI 调用并获得结果</span></span><br><span class="line">String response = stub.sayHello();</span><br></pre></td></tr></table></figure><h3 id="1-3-为什么需要Dubbo？"><a href="#1-3-为什么需要Dubbo？" class="headerlink" title="1.3 为什么需要Dubbo？"></a><strong>1.3 为什么需要Dubbo？</strong></h3><p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p><p><strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</strong> 此时<strong>需要一个服务注册中心（Eureka、Zookeeper），动态地注册和发现服务，使服务的位置透明</strong>。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p><p><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。</p><p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-service-governance.jpg" alt></p><p>dubbo的核心特性：</p><ul><li><strong>远程方法调用</strong>：面向接口代理的高性能RPC调用，使用时只需调用接口即可。</li><li><strong>智能负载均衡</strong>：同一个服务可能有多台服务器在运行，每台服务器有不同的工作状态，负载均衡会尽量的挑选休闲的服务器。</li><li><strong>服务自动注册和发现</strong>：所有服务都要注册到中心，中心负责管理所有服务的生命周期，服务部署在哪些服务器这些信息可以在中心获取。</li><li><strong>高度可扩展</strong>：遵循微内核和插件的设计原则，核心功能如Protocol、Transport、Serialization都被设计为扩展点，同等对待内置实现和第三方实现。</li><li><strong>运行期流量调度</strong>：内置条件、脚本等路由策略，通过配置不同的路由规则，实现灰度发布、同机房优先等功能。</li><li><strong>可视化的服务治理与运维</strong>：提供丰富的服务治理、运维工具：随时查询服务元数据、服务健康状态以及调用统计，实时下发路由策略、调整配置参数。</li></ul><h3 id="1-4-技术架构"><a href="#1-4-技术架构" class="headerlink" title="1.4 技术架构"></a><strong>1.4 技术架构</strong></h3><p>如下图所示，每个节点角色之间的关系，注意只有消费者调用服务是同步，其他都是异步操作。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt="dubbo-architucture"></p><h5 id="节点角色说明"><a href="#节点角色说明" class="headerlink" title="节点角色说明"></a>节点角色说明</h5><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Provider</code></td><td>暴露服务的<strong>服务提供方</strong></td></tr><tr><td><code>Consumer</code></td><td>调用远程服务的<strong>服务消费方</strong></td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的<strong>注册中心</strong></td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的<strong>监控中心</strong></td></tr><tr><td><code>Container</code></td><td><strong>服务运行容器</strong></td></tr></tbody></table><h5 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h5><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。</p><h5 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h5><ul><li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li><li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li><li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li><li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li><li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li><li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li><li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li><li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li></ul><h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ul><h5 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h5><ul><li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li><li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li></ul><h5 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h5><p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-future.jpg" alt="dubbo-architucture-futures"></p><h5 id="节点角色说明-1"><a href="#节点角色说明-1" class="headerlink" title="节点角色说明"></a>节点角色说明</h5><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Deployer</code></td><td>自动部署服务的本地代理</td></tr><tr><td><code>Repository</code></td><td>仓库用于存储服务应用发布包</td></tr><tr><td><code>Scheduler</code></td><td>调度中心基于访问压力自动增减服务提供者</td></tr><tr><td><code>Admin</code></td><td>统一管理控制台</td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的注册中心</td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的监控中心</td></tr></tbody></table><hr><h2 id="第二节-入门"><a href="#第二节-入门" class="headerlink" title="第二节 入门"></a><strong>第二节 入门</strong></h2><p>项目地址：<a href="https://github.com/apache" target="_blank" rel="noopener">apache</a>/<strong><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">dubbo</a></strong></p><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a><strong>2.1 安装</strong></h3><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/dubbo.git</span><br><span class="line"><span class="built_in">cd</span> dubbo/dubbo-demo/dubbo-demo-xml</span><br><span class="line">运行 dubbo-demo-xml-provider中的org.apache.dubbo.demo.provider.Application</span><br><span class="line">如果使用Intellij Idea 请加上-Djava.net.preferIPv4Stack=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resources/spring/dubbo-provider.xml</span><br><span class="line">修改其中的dubbo:registry，替换成真实的注册中心地址，推荐使用zookeeper，如：</span><br><span class="line">&lt;dubbo:registry address=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span><br></pre></td></tr></table></figure><p>通过Idea打开项目，等待依赖下载完毕后按官网教程启动 <code>dubbo-demo-xml-provider</code> 。</p><p>启动失败，报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\WorkPlace\FromGitHub\dubbo-master\dubbo-config\dubbo-config-api\src\<span class="built_in">test</span>\java\org\apache\dubbo\config\bootstrap\rest\UserService.java</span><br><span class="line">Error:(22, 50) java: 程序包org.apache.dubbo.rpc.protocol.rest.support不存在</span><br><span class="line">Error:(37, 12) java: 找不到符号</span><br><span class="line">  符号: 变量 ContentType</span><br><span class="line">Error:(37, 48) java: 找不到符号</span><br><span class="line">  符号: 变量 ContentType</span><br></pre></td></tr></table></figure><p>找到（dubbo-config-api）<code>pom.xml</code> 并注释掉所有Maven的test作用域。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- FIXME, we shouldn't rely on these modules, even in test scope --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-rpc-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启，OK上述错误不再提示，但有了新的错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error:(26, 52) java: 程序包org.apache.dubbo.common.serialize.nativejava不存在</span><br><span class="line">Error:(99, 43) java: 找不到符号</span><br><span class="line">  符号:   类 NativeJavaSerialization</span><br><span class="line">  位置: 类 org.apache.dubbo.rpc.protocol.hessian.HessianProtocolTest</span><br><span class="line">Warning:(110, 59) java: org.apache.dubbo.common.serialize.ObjectInput中的readObject()已过时</span><br></pre></td></tr></table></figure><p>找到（dubbo-rpc-rest）<code>pom.xml</code> 并注释掉test作用域。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-serialization-jdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次启动，OK顺利运行。</p><h3 id="2-2-简单使用"><a href="#2-2-简单使用" class="headerlink" title="2.2 简单使用"></a><strong>2.2 简单使用</strong></h3><h4 id="（1）服务提供者"><a href="#（1）服务提供者" class="headerlink" title="（1）服务提供者"></a><strong>（1）服务提供者</strong></h4><p>找到 <code>dubbo-demo-interface</code> 子项目，其中有定义接口 <code>DemoService.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(sayHello(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到 <code>dubbo-demo-api</code> 子项目，其中有定义接口实现 <code>DemoServiceImpl.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.rpc.RpcContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Hello "</span> + name + <span class="string">", request from consumer: "</span> + RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">", response from provider: "</span> + RpcContext.getContext().getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过Spring的xml配置来将服务暴露，<code>provider.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.demo.provider.DemoServiceImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后在 <code>dubbo-demo-xml-provider</code> 启动类加载Spring配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/dubbo-provider.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）服务消费者"><a href="#（2）服务消费者" class="headerlink" title="（2）服务消费者"></a><strong>（2）服务消费者</strong></h4><p>首先通过 Spring 配置引用远程服务 dubbo-consumer.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer-of-helloworld-app"</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment">  contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment">  this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment">  The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment">  (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment">  the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"mapping-type"</span> <span class="attr">value</span>=<span class="string">"metadata"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"enable-auto-migration"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    &lt;dubbo:metadata-report address="zookeeper://127.0.0.1:2181"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">provided-by</span>=<span class="string">"demo-provider"</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">provided-by</span>=<span class="string">"demo-provider"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">group</span>=<span class="string">"greeting"</span> <span class="attr">id</span>=<span class="string">"greetingService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.GreetingService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后加载Spring配置，并调用远程服务Consumer.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"META-INF/spring/dubbo-demo-consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = (DemoService)context.getBean(<span class="string">"demoService"</span>); <span class="comment">// 获取远程服务代理</span></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// 执行远程方法</span></span><br><span class="line">        System.out.println( hello ); <span class="comment">// 显示调用结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.GreetingService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before</span></span><br><span class="line"><span class="comment">     * launch the application</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/dubbo-consumer.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = context.getBean(<span class="string">"demoService"</span>, DemoService.class);</span><br><span class="line">        GreetingService greetingService = context.getBean(<span class="string">"greetingService"</span>, GreetingService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String greetings = greetingService.hello();</span><br><span class="line">                System.out.println(greetings + <span class="string">" from separated thread."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            CompletableFuture&lt;String&gt; hello = demoService.sayHelloAsync(<span class="string">"world"</span>);</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + hello.get());</span><br><span class="line"></span><br><span class="line">            String greetings = greetingService.hello();</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + greetings);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li>该接口需单独打包，在服务提供方和消费方共享 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref1" target="_blank" rel="noopener">↩︎</a></li><li>对服务消费方隐藏实现 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref2" target="_blank" rel="noopener">↩︎</a></li><li>也可以使用 IoC 注入 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref3" target="_blank" rel="noopener">↩︎</a></li></ol><hr><p>参考：</p><blockquote><p><a href="http://dubbo.apache.org/zh-cn/docs/user/dependencies.html" target="_blank" rel="noopener">Dubbo官网-文档</a></p></blockquote><blockquote><p><a href="http://jm.taobao.org/2018/06/13/%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">第一个 Dubbo 应用</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习Dubbo，第一章《简介和搭建》
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="dubbo" scheme="http://linyishui.top/tags/dubbo/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（一）启程</title>
    <link href="http://linyishui.top/2020090101.html"/>
    <id>http://linyishui.top/2020090101.html</id>
    <published>2020-09-01T10:14:30.000Z</published>
    <updated>2020-09-05T13:17:13.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="启程"><a href="#启程" class="headerlink" title="启程"></a><strong>启程</strong></h1><h3 id="为什么要学习英语？"><a href="#为什么要学习英语？" class="headerlink" title="为什么要学习英语？"></a><strong>为什么要学习英语？</strong></h3><p>今天，当我终于下定决心要开始学习英语时，我发现最开始想要学习一门外语到现在已经过去了将近5年的时间。大部分人应该和我一样虽然会觉得自己应该至少学习一门外语，但在思考这个问题时，<strong>总是会想在一个更合适的时间开始学习</strong>。</p><p>在逃避学习的这段时间里，我有时忙于玩乐，有时忙于工作，一直在焦虑和麻木的状态中生活。时间来到这个月，我处于人生中的第二个求职阶段，面试的不顺利和内心的不甘心，让我突然发现，<strong>人生中的大部分时间我都是在被迫学习</strong>：少年时因为要考试而去学习；成年后进入大学，又为了奖学金而短暂学习过；工作后为了更好的岗位和薪水而去强迫自己学习。<strong>我还从来没有因为想要学一个东西而去认真的实现这个想法，这让我意识到不管明天会怎样，我都要从今天开始我的学习计划了</strong>。</p><p>我为自己想了几个学习英语的目的：</p><ul><li>为了和英语世界的人交流，认识更多的朋友。</li><li>不局限于中文环境，去见识和了解到更大范围的世界。</li><li>无障碍的看懂美剧而不用盯着字幕，可以听懂英文歌曲。</li><li>将来有更多的工作机会，以及在其他环境生活的机会。</li><li>增强自信心，提高我对自己的自我评价。</li></ul><p>我首先选择了一本在大学时就收藏的书籍《跟各国人都聊得来-三个月外语流利术》，在开启英语学习之路上，先汲取一下在同样事情上成功的人的经验。</p><hr><h3 id="学习语言的错误观点"><a href="#学习语言的错误观点" class="headerlink" title="学习语言的错误观点"></a><strong>学习语言的错误观点</strong></h3><p><strong>我们为学不会一种语言找的借口往往是对自我的错误认知。</strong></p><h4 id="观点1：年纪太大，不利于学习语言"><a href="#观点1：年纪太大，不利于学习语言" class="headerlink" title="观点1：年纪太大，不利于学习语言"></a>观点1：年纪太大，不利于学习语言</h4><p>这种观点从来没有理论或科学研究的支持，实际上无论学习什么东西，成年人都要比小孩子更有优势，因为我们成年人不是从零开始学习第一语音。根据研究，93%的情感交流都不是通过语言完成的，比如笑也是一种信息的传递方式，成年人不用再花大量时间去学习如何与人交流。</p><p><strong>相比于孩子，成年人要学习的内容更少。</strong>成年人有更多的学习经验应用到学习语言上面，成年人比孩子更有分析力。相反，成年人应该学习孩子不害怕犯错误这一点，享受学习的过程，不要害怕尴尬。</p><h4 id="观点2：我没有学习语言的天赋"><a href="#观点2：我没有学习语言的天赋" class="headerlink" title="观点2：我没有学习语言的天赋"></a>观点2：我没有学习语言的天赋</h4><p>事实上，所有人都有学习语言的天赋，在一些多语种的国家，人们都能在很多语言之间自由的切换，比如卢森堡的学生在毕业时能流利的使用法语、德语、卢森堡语。</p><p>我们在学习刚开始就要抛开这种自我怀疑。</p><h4 id="观点3：我没有时间"><a href="#观点3：我没有时间" class="headerlink" title="观点3：我没有时间"></a>观点3：我没有时间</h4><p>大部分人都有工作要做，这是一个很好的接口。但事实上，大部分学习语言很成功的人都有正式的工作，或是操持家务、照顾家人。</p><p>只要真正的抽出时间去学习，你就能取得进步。比如看电视、浏览各种APP、打游戏等等，这些活动占用了我们大量的时间，甚至还有一些是无意义的活动，还有如等电梯、坐公交车、地铁等。即使是几分钟的时间，用来学习几个单词或日常用语也是足够的。</p><p><strong>当你真正想要学习一门语言时，每一分钟都是可以利用的。</strong></p><p>当然，花几个月的时间去做一件事很不错，但如果没有这个条件，请尽量把能用的时间利用起来，虽然周期会长一些，但你总能达到目标的。</p><h4 id="观点4：学语言是有钱人的专利"><a href="#观点4：学语言是有钱人的专利" class="headerlink" title="观点4：学语言是有钱人的专利"></a>观点4：学语言是有钱人的专利</h4><p>昂贵的课程和学习产品并不比网上的免费工具、博客、以及和外国朋友聊天更有帮助。</p><h4 id="观点5：我在等待完美的语言课程"><a href="#观点5：我在等待完美的语言课程" class="headerlink" title="观点5：我在等待完美的语言课程"></a>观点5：我在等待完美的语言课程</h4><p>没有完美的课程，即使是优秀的语言课程能教给你的东西也是有限的，而且它<strong>并不比你努力学习更有效果</strong>。</p><h4 id="观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败"><a href="#观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败" class="headerlink" title="观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败"></a>观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败</h4><p><strong>最重要的事情是你终于开始学习了</strong>，而早期的错误并没有什么关系。遇到挫折，果断的去解决它，振作精神，重新开始，只要再坚持一下就可以了。</p><p><strong>不要把精力投入到研究哪种学习方法更好，而是把精力投入到学习和使用语言上面。</strong></p><h4 id="观点7：只有学到一定程度，我才能开始练习对话"><a href="#观点7：只有学到一定程度，我才能开始练习对话" class="headerlink" title="观点7：只有学到一定程度，我才能开始练习对话"></a>观点7：只有学到一定程度，我才能开始练习对话</h4><p>事实上，<strong>从学习的第一天开始，你就要尝试去说</strong>。这和传统认知并不相符，<strong>因为你永远不会有准备好的那一天</strong>，哪怕你已经掌握了一门语言，你还是能证明自己没有准备好，单词是永远也学不完的，语法也有很多的学习空间，发音也要更多的练习。</p><p><strong>要从现在就开始尽量去使用自己所学的语言，而不是等待很多年。</strong></p><h4 id="观点8：我不能集中精力"><a href="#观点8：我不能集中精力" class="headerlink" title="观点8：我不能集中精力"></a>观点8：我不能集中精力</h4><p><strong>只专注于眼前的任务，不管有多大的诱惑。</strong>一些优秀的人才也只是把各种兴趣爱好安排好，按照次序一一完成，而不是同时去做很多事情。他们也只是有耐心的、有条理的去做。</p><h4 id="观点9：有些语言太难了"><a href="#观点9：有些语言太难了" class="headerlink" title="观点9：有些语言太难了"></a>观点9：有些语言太难了</h4><p>没有人能在这种无意义的比较中获益，事实上即使是公认的难学习的语种也有很多人在使用它来交流。如果你正在学习一门语言，请忘掉其他学过的语言，集中热情在它上面吧！</p><h4 id="观点10：瓶颈期不可避免"><a href="#观点10：瓶颈期不可避免" class="headerlink" title="观点10：瓶颈期不可避免"></a>观点10：瓶颈期不可避免</h4><p>学习中确实难免遇到瓶颈期，初学者不会遇到此问题，直到有所进步后，比如能够交流后就停滞在那里了。这很可能是我们过往的学习方法在此阶段不再适合了，<strong>“愚蠢”的行为就是一直重复用同样的方法做事，却期望得到不同的结果</strong>。</p><p>不要怕，大胆的改变，改变练习的频率，改变对话的对象。</p><h4 id="观点11：完全掌握是不可能的任务"><a href="#观点11：完全掌握是不可能的任务" class="headerlink" title="观点11：完全掌握是不可能的任务"></a>观点11：完全掌握是不可能的任务</h4><p>如果说学一门语言，就是要用它来辩论各种哲学思想，并且不带一丝口音和停顿的话，那么这确实会花费上数十年。</p><p>但请仔细想想，<strong>你对自己的母语有掌握到什么样的程度，再想想为什么要对一门外语有这样的高要求？</strong></p><p>请把目标放在简单对话，再朝着流利的方向努力。</p><h4 id="观点12：学习过程很枯燥"><a href="#观点12：学习过程很枯燥" class="headerlink" title="观点12：学习过程很枯燥"></a>观点12：学习过程很枯燥</h4><p><strong>语言学习并不枯燥，也许只是你的方法枯燥而已。</strong>比如试试听音乐、看动画片、看电影、读杂志、看笑话。找一个互相帮助的伙伴，或者任何能调动你积极性的方式。</p><h4 id="观点13：当地人不会理我"><a href="#观点13：当地人不会理我" class="headerlink" title="观点13：当地人不会理我"></a>观点13：当地人不会理我</h4><p><strong>请记住，你永远也不会准备好，永远都有要学的东西，所以你可以一直给自己找借口。</strong>这种恶性循环导致很多人学了很多年也不敢开口说话。</p><p>现实中，大家往往会鼓励你、帮助你，会很有耐心和包容。比如你是那个本地人，当你遇到一个尝试努力学习你的母语的外人时，你会有怎样的感受？</p><h4 id="观点14：我总是有口音"><a href="#观点14：我总是有口音" class="headerlink" title="观点14：我总是有口音"></a>观点14：我总是有口音</h4><p>实际上有点口音是好事，这并不影响交流。即使是母语也存在很多发音问题，他们也有各种各样的口音。</p><h4 id="观点15：我的家人朋友不支持我"><a href="#观点15：我的家人朋友不支持我" class="headerlink" title="观点15：我的家人朋友不支持我"></a>观点15：我的家人朋友不支持我</h4><p>这个问题没有很好的解决方法，但你可以尽量的阐述自己很喜欢这门语言，表示出你认真的态度，如果对方能理解也许他们会支持你。</p><p>如果你得不到他们的支持，请相信在这个世界上有很多和你一样怀抱相同梦想的人，你会找到支持和理解的。</p><h4 id="观点16：每个人都说英语-汉语"><a href="#观点16：每个人都说英语-汉语" class="headerlink" title="观点16：每个人都说英语/汉语"></a>观点16：每个人都说英语/汉语</h4><p>学会一门新的语言，并不仅仅意味着你收获了这些知识，它会为你带来新的机会和体验。</p><h4 id="观点17：我跟不上比人的脚步"><a href="#观点17：我跟不上比人的脚步" class="headerlink" title="观点17：我跟不上比人的脚步"></a>观点17：我跟不上比人的脚步</h4><p>把自己和别人作比较这种行为本身就很有问题，但这是人的本性。但你要明白，你看到的只是别人展示给你的一面，他们分享经历时，只会说遇到的各种困难，已显示出其高大的形象。</p><p>遇到困难时，请抛弃“成功的人不会面对这样的问题，我还是放弃吧”这样的想法。而应该问自己“成功的人会怎么解决这个困难呢？”。</p><h4 id="观点18：以前失败，现在还会失败"><a href="#观点18：以前失败，现在还会失败" class="headerlink" title="观点18：以前失败，现在还会失败"></a>观点18：以前失败，现在还会失败</h4><p>如果你以前尝试过学习语言，但最终失败了。你可能会觉得自己不擅长学习语言，但请相信这只能说明过去的方法并不适合你。</p><p><strong>没有一种方法是完美适合每一个语言学习者的。</strong>如果你尝试着某种方法，但根本不起作用，请果断的放弃，并试着换另一种方法。</p><p><strong>请明白失败的并不是你这个人，而是你在用的方法。</strong>请在遇到问题时，多和别人交流，书本并不能解决所有的问题。有可能解决方案在你的已知的知识世界以外，而一个学过的人可以帮你轻松的跨过这个难关。</p><h4 id="观点19：一旦忘了某种语言，我就不可能再重新学会它了"><a href="#观点19：一旦忘了某种语言，我就不可能再重新学会它了" class="headerlink" title="观点19：一旦忘了某种语言，我就不可能再重新学会它了"></a>观点19：一旦忘了某种语言，我就不可能再重新学会它了</h4><p>我们小时候学过的语言，后面没有再学，所以总觉得错过了学习它的最佳机会。但其实只要重新开始努力，你会比初次更顺利的学好这门语言。</p><h4 id="观点20：残障人士学语言比正常人更难"><a href="#观点20：残障人士学语言比正常人更难" class="headerlink" title="观点20：残障人士学语言比正常人更难"></a>观点20：残障人士学语言比正常人更难</h4><p>我们会觉得自己有某种缺陷，在学习语言时会和别人不同。但现实中，很多残疾人士都能很好的克服身体上的缺陷，这些问题在你因为它而止步不前时是难以克服的难关，但请相信在你开始不断尝试之后，总会找到出路的。</p><hr><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a><strong>感受</strong></h3><blockquote><p><strong>不管你觉得自己行或不行，你都是对的。</strong></p><p>​                                                                ——亨利 · 福特</p></blockquote><p>语言学习需要面对挑战，需要付出努力，如果我们确信自己不行，那我们也失去了信心和热情，悲观主义情绪已经占了上风，我们也就注定学不好这种语言了。请大胆的承认失败，不要给自己找没有学好的借口。不管你遇到什么困难，别人都可能遇到过，并且克服过这个困难。</p><p>Benny Lewis的观点很能说动现在的我，好像每个问题都是我曾用来逃避的理由，但还好我现在比起以前有了些许的改变，也许迈出第一步之后，就是焕然一新的自己。</p><p>不仅仅是语言学习，这些常识性的问题在大多数学习场景都是雷同的，我们要克服的是自己的懦弱和懒惰。如果你是一个自命不凡的人，或者只是对现在的自己不够满意，就请不要再浪费时间在准备阶段了，尝试的去做吧。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>大数据量表的优化思路</title>
    <link href="http://linyishui.top/2020082201.html"/>
    <id>http://linyishui.top/2020082201.html</id>
    <published>2020-09-01T05:32:46.000Z</published>
    <updated>2020-09-02T07:19:13.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="大数据量表的优化思路"><a href="#大数据量表的优化思路" class="headerlink" title="大数据量表的优化思路"></a><strong>大数据量表的优化思路</strong></h1><h2 id="第一节-问题描述"><a href="#第一节-问题描述" class="headerlink" title="第一节 问题描述"></a><strong>第一节 问题描述</strong></h2><h2 id="1-1-常见问题"><a href="#1-1-常见问题" class="headerlink" title="1.1 常见问题"></a><strong>1.1 常见问题</strong></h2><ol><li>单表数据量达到千万级别后，查询操作耗时过久。</li><li>针对海量的数据表进行修改操作。</li></ol><h2 id="1-2-MySql模拟"><a href="#1-2-MySql模拟" class="headerlink" title="1.2 MySql模拟"></a><strong>1.2 MySql模拟</strong></h2><p>创建千万条模拟数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#创建MyISAM模式表方便批量跑数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`logs1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`logtype`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logurl`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logip`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logdz`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ladduser`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lfadduser`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`laddtime`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`htmlname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM  AUTO_INCREMENT=<span class="number">1811</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'日志表'</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#创建存储过程</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_insert;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> n <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> in_dateTime <span class="keyword">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="string">'2020-01-01 00:00:00'</span>;</span><br><span class="line">        while n &lt;= 10000000 do</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`logs1`</span>(<span class="string">`logtype`</span>,<span class="string">`logurl`</span>,<span class="string">`logip`</span>,<span class="string">`logdz`</span>,<span class="string">`ladduser`</span> ,<span class="string">`lfadduser`</span>,<span class="string">`laddtime`</span>,<span class="string">`htmlname`</span>) <span class="keyword">VALUES</span> (<span class="keyword">FLOOR</span>(<span class="number">1</span> + (<span class="keyword">RAND</span>() * <span class="number">2</span>)), <span class="string">'/index'</span>, <span class="string">'0:0:0:0:0:0:0:1'</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">'null'</span>, in_dateTime, <span class="string">'首页'</span>);</span><br><span class="line">            <span class="keyword">set</span> in_dateTime = in_dateTime + <span class="built_in">interval</span> <span class="number">1</span> MINUTE_SECOND;</span><br><span class="line">            <span class="keyword">SET</span> n = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"> </span><br><span class="line">#执行存储过程</span><br><span class="line"><span class="keyword">CALL</span> my_insert();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#数据插入成功后修改表模式InnoDB 时间稍微久点</span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`logs1`</span> <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查询表中行数，用时2.6s左右</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> logs1;</span><br><span class="line"></span><br><span class="line">#分页查询，id从1811开始，查询第6001条到6010条数据，用时0.025s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">6000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时0.048s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">60000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时0.256s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">600000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时4.372s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">9000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。</strong></p><hr><h2 id="第二节-解决流程"><a href="#第二节-解决流程" class="headerlink" title="第二节 解决流程"></a><strong>第二节 解决流程</strong></h2><h2 id="2-1-索引"><a href="#2-1-索引" class="headerlink" title="2.1 索引"></a><strong>2.1 索引</strong></h2><p>explain得知查询并未走索引，首先增加索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># type=all全表查询，先创建索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> logs1 <span class="keyword">where</span> logtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#增加唯一索引和普通索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_id (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_logtype (logtype)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_laddtime (laddtime)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_logtype</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_laddtime</span><br><span class="line"></span><br><span class="line">#<span class="keyword">type</span>是选择性低的属性，而<span class="keyword">time</span>则不是，所以索引的影响也不同</span><br><span class="line">#全表查询 <span class="number">5.073</span>-&gt;索引 <span class="number">4.226</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> logtype <span class="keyword">from</span> logs1 <span class="keyword">where</span> logtype &gt; <span class="number">1</span>;</span><br><span class="line">#ALL 3.566-&gt;range 0.426</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span>;</span><br></pre></td></tr></table></figure><p>索引并非万能的，如果我们查询的属性列是多个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#index 4.572</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,logtype,laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span>;</span><br><span class="line"></span><br><span class="line">#增加where后判断条件</span><br><span class="line">#0.966-&gt;0.853</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,logtype,laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span> <span class="keyword">and</span> <span class="keyword">id</span> &gt; <span class="string">'9001812'</span> <span class="keyword">and</span> logtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#创建组合索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_union (<span class="keyword">id</span>,logtype,laddtime)</span><br></pre></td></tr></table></figure><h2 id="2-2-优化SQL"><a href="#2-2-优化SQL" class="headerlink" title="2.2 优化SQL"></a><strong>2.2 优化SQL</strong></h2><p>避免select *，将需要查找的字段列出来</p><p>使用连接(join)来代替子查询</p><p>拆分大的delete或insert语句</p><p>通过开启慢查询日志来找出较慢的SQL</p><p>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</p><p>sql语句尽可能简单：一条sql只能在一个cpu运算;大语句拆小语句，减少锁时间;一条大sql可以堵死整个库</p><p>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</p><p>避免%xxx式查询</p><p>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p><p>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</p><p>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</p><h2 id="2-3-分区"><a href="#2-3-分区" class="headerlink" title="2.3 分区"></a><strong>2.3 分区</strong></h2><p>MySql 5.1版本引入，用户需要在建表的时候加上分区参数。分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。</p><p><strong>分区的好处是：</strong></p><ol><li>可以让单表存储更多的数据</li><li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li><li>部分查询能够从查询条件确定只落在少数分区上，速度会很快</li><li>分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备</li><li>可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li><li>可以备份和恢复单个分区</li></ol><p><strong>分区的限制和缺点：</strong></p><ol><li>一个表最多只能有1024个分区</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li>分区表无法使用外键约束</li><li>NULL值会使分区过滤无效</li><li>所有分区必须使用相同的存储引擎</li></ol><p><strong>分区的类型：</strong></p><ol><li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li><li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li><li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li><li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li><li>具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。</li></ol><h2 id="2-4-分表"><a href="#2-4-分表" class="headerlink" title="2.4 分表"></a><strong>2.4 分表</strong></h2><p>分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。</p><p>分表分为垂直拆分和水平拆分，通常以某个字段做拆分项。比如以id字段拆分为100张表： 表名为 tableName_id%100</p><p>但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高!!!而且选择这个方案，都不如选择我提供的第二第三个方案的成本低!故不建议采用。</p><h2 id="2-5-分库"><a href="#2-5-分库" class="headerlink" title="2.5 分库"></a><strong>2.5 分库</strong></h2><p>把一个数据库分成多个，建议做个读写分离就行了，真正的做分库也会带来大量的开发成本，得不偿失!不推荐使用。</p><h2 id="2-5-升级数据库"><a href="#2-5-升级数据库" class="headerlink" title="2.5 升级数据库"></a><strong>2.5 升级数据库</strong></h2><p>选用一款兼容MySql的高性能数据库。</p><h2 id="2-6-换大数据引擎处理数据"><a href="#2-6-换大数据引擎处理数据" class="headerlink" title="2.6 换大数据引擎处理数据"></a><strong>2.6 换大数据引擎处理数据</strong></h2><p>当数据量过亿，可能实现无法支撑，只能更换Hadoop等大数据引擎来代替传统数据库。</p><p>或者购买专业的大数据云解决方案，比较便宜省人力。</p><hr><p><em>参考内容：</em></p><blockquote><p><a href="https://database.51cto.com/art/201902/592522.htm" target="_blank" rel="noopener">记录一次MySQL两千万数据的大表优化解决过程，提供三种解决方案</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentSkipListMap</title>
    <link href="http://linyishui.top/2020070801.html"/>
    <id>http://linyishui.top/2020070801.html</id>
    <published>2020-07-08T08:56:37.000Z</published>
    <updated>2020-08-25T05:23:27.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a><strong>ConcurrentSkipListMap</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是ConcurrentSkipListMap"><a href="#1-1-什么是ConcurrentSkipListMap" class="headerlink" title="1.1 什么是ConcurrentSkipListMap"></a><strong>1.1 什么是ConcurrentSkipListMap</strong></h3><p>ConcurrentSkipListMap是由并发包提供的一种线程安全的并发容器，（优点）使我们能够<strong>以无锁方式实现线程安全</strong>，<strong>底层是通过跳表来实现</strong>的能够保证<strong>元素有序</strong>。</p><p>跳表是一个链表，但是通过使用<strong>“跳跃式”</strong>查找的方式使得插入、读取数据时复杂度变成了 <strong>O(logn)</strong> 。注意：<code>size()</code> 由于多个线程可以同时对映射进行操作，所以需要遍历整个映射才能返回元素个数，这是个 <strong>O(logn)</strong> 的操作。</p><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a><strong>1.2 简单使用</strong></h3><p>一个简单的实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ConcurrentSkipListMap&lt;Integer, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(</span><br><span class="line">            Comparator.comparingInt(v -&gt; v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过put添加</span></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(-<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">600</span>);</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//遍历线程集合，构建每个线程，每个线程都分别调用线程安全和不安全的计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="comment">//分别调用安全和不安全的计数器</span></span><br><span class="line">                    map.put(i, i + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历执行所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待所有线程执行完成</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印最终结果</span></span><br><span class="line">    map.forEach((k,v) -&gt; &#123;System.out.println(<span class="string">"k: "</span> + k + <span class="string">" v: "</span> + v);&#125;);</span><br><span class="line">    System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">98</span> <span class="string">v:</span> <span class="number">98</span></span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">82</span></span><br></pre></td></tr></table></figure><p>把 ConcurrentSkipListMap 替换为 TreeMap 。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line"><span class="string">k:</span> <span class="number">3</span> <span class="string">v:</span> <span class="number">3</span></span><br><span class="line"><span class="string">k:</span> <span class="number">4</span> <span class="string">v:</span> <span class="number">4</span></span><br><span class="line"><span class="string">k:</span> <span class="number">5</span> <span class="string">v:</span> <span class="number">5</span></span><br><span class="line"><span class="string">k:</span> <span class="number">6</span> <span class="string">v:</span> <span class="number">6</span></span><br><span class="line"><span class="string">k:</span> <span class="number">7</span> <span class="string">v:</span> <span class="number">7</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line"><span class="string">k:</span> <span class="number">8</span> <span class="string">v:</span> <span class="number">8</span></span><br><span class="line"><span class="string">k:</span> <span class="number">9</span> <span class="string">v:</span> <span class="number">9</span></span><br><span class="line"><span class="string">k:</span> <span class="number">10</span> <span class="string">v:</span> <span class="number">10</span></span><br><span class="line"><span class="string">k:</span> <span class="number">11</span> <span class="string">v:</span> <span class="number">11</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">50</span> <span class="string">v:</span> <span class="number">50</span></span><br><span class="line"><span class="string">k:</span> <span class="number">51</span> <span class="string">v:</span> <span class="number">51</span></span><br><span class="line"><span class="string">k:</span> <span class="number">52</span> <span class="string">v:</span> <span class="number">52</span></span><br><span class="line"><span class="string">k:</span> <span class="number">53</span> <span class="string">v:</span> <span class="number">53</span></span><br><span class="line"><span class="string">k:</span> <span class="number">54</span> <span class="string">v:</span> <span class="number">54</span></span><br><span class="line"><span class="string">k:</span> <span class="number">55</span> <span class="string">v:</span> <span class="number">55</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">56</span> <span class="string">v:</span> <span class="number">56</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">58</span> <span class="string">v:</span> <span class="number">58</span></span><br><span class="line"><span class="string">k:</span> <span class="number">59</span> <span class="string">v:</span> <span class="number">59</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">46</span></span><br></pre></td></tr></table></figure><p>可以得到一个初印象：TreeMap 多线程环境下非线程安全，但单线程的有序映射有较好的性能，而 ConcurrentSkipListMap 则可以在相同需求的多线程场景作为替代品。  </p><hr><h2 id="第二节-跳表"><a href="#第二节-跳表" class="headerlink" title="第二节 跳表"></a><strong>第二节 跳表</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h3><p> 跳表（SkipList）：是一种优秀的数据结构，<strong>使得包含n个元素的有序序列的查找和插入操作的平均时间复杂度都是 O(logn) ，要优于数组的 O(n) </strong>。</p><p>快速的查询效果是<strong>通过维护一个多层次的链表实现的</strong>，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少（见下图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择或确定性选择，其中前者更为常见。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010118.png" alt></p><p><em>一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。</em></p><h3 id="2-2-算法"><a href="#2-2-算法" class="headerlink" title="2.2 算法"></a><strong>2.2 算法</strong></h3><p>跳跃列表是按层建造的。<strong>底层是一个普通的有序链表</strong>。每个更高层都充当下面列表的<strong>“快速通道”</strong>，这里在第 i 层中的元素按某个固定的概率 p（通常为 1/2 或 1/4 ）出现在第 i+1 层中。每个元素平均出现在 1 / 1-p 个列表中，而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）在 log~1/p~n 个列表中出现。</p><p>在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾。如果该元素等于目标元素，则表明该元素已被找到；如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。每层链表中预期的查找步数最多为 1/p ，而层数为 log~1/p~n ，所以查找的总体步数为 -log~p~n / p，由于 p 是常数，查找操作总体的时间复杂度为 O(log n) 。而通过选择不同 p 值，就可以在查找代价和存储代价之间获取平衡。</p><p>跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。跳跃列表在并行计算中也很有用：插入可以在跳跃列表不同的部分并行地进行，而不用对数据结构进行全局的重新平衡。</p><h3 id="2-3-实现细节"><a href="#2-3-实现细节" class="headerlink" title="2.3 实现细节"></a><strong>2.3 实现细节</strong></h3><p>因为跳跃列表中的元素可以在多个列表中，所以每个元素可以有多于一个指针。</p><p>跳跃列表的插入和删除的实现与普通的链表操作类似，但高层元素必须在进行多个链表中进行插入或删除。</p><p>跳跃列表的最坏时间性能具有一定随机性，但是可以通过时间复杂度为 O(n) 的遍历操作（例如在打印列表全部内容时）以无随机的算法重整列表的结构，从而使跳跃列表的实际查找时间复杂度尽量符合理论平均值 O(log n) 。</p><h4 id="（1）插入操作"><a href="#（1）插入操作" class="headerlink" title="（1）插入操作"></a><strong>（1）插入操作</strong></h4><p>往跳跃列表中插入一个元素，如图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/Skip_list_add_element-en.gif" alt></p><ol><li>新节点和各层索引节点逐一比较，确定原链表的插入位置，O(log n)。</li><li>把索引插入到原链表，O(1)。</li><li>利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止，O(log n)。</li></ol><p>总体上，跳跃表插入操作的时间复杂度是 O(log n) ，而这种数据结构所占空间是2N，既空间复杂度是 O(n) 。</p><h4 id="（2）删除操作"><a href="#（2）删除操作" class="headerlink" title="（2）删除操作"></a><strong>（2）删除操作</strong></h4><p>在索引层找到要删除的节点，依次删除每层相同节点即可。若某层索引在删除后只剩下一个节点，可以删除此层。</p><ol><li>自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点，O(log n) 。</li><li>删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外），O(log n) 。</li></ol><p>总体上，跳跃表删除操作的时间复杂度是 O(log n) 。</p><h3 id="2-4-跳跃表和二叉树的区别"><a href="#2-4-跳跃表和二叉树的区别" class="headerlink" title="2.4 跳跃表和二叉树的区别"></a><strong>2.4 跳跃表和二叉树的区别</strong></h3><ul><li>跳表维持结构平衡的成本较低，完全依靠随机；二叉树则在多次插入删除后，通过再平衡操作来重新调整结构平衡。</li><li>跳表非树结构，分索引节点和底层链表节点，索引节点只有右边和下边两条索引，链表节点则只有下个节点索引，而二叉树节点则有左右子结点。</li></ul><p>补充：Redis通过跳跃表的优化实现Sorted-set维护有序集合，而关系型数据库则采用B+树。</p><hr><h2 id="第三节-源码解析"><a href="#第三节-源码解析" class="headerlink" title="第三节 源码解析"></a><strong>第三节 源码解析</strong></h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a><strong>1.1 基本结构</strong></h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank" rel="noopener">ConcurrentSkipListMap</a> 中包括 Node 和 Index 两种节点，其中 Node 即普通链表节点，而 Index 则是索引节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳表的最高头索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护映射内元素顺序的比较器，可以为空表示自然顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 延迟初始化的键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; keySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的条目集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet&lt;K,V&gt; entrySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的值集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Values&lt;V&gt; values;</span><br><span class="line">    <span class="comment">/** 延迟初始化的降序键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ConcurrentNavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> Object value;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个新的标记节点. 标记的区别在于其值字段指向自身。标记节点也具有空键，这一事实在一些地方得到了利用，但这并不能将标记与也具有空键的基本级别标头节点（head.node）区分开。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置value字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置next字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//重新检查链接，然后在每个调用中仅执行一个help-out阶段，这样可以最大程度地减少帮助线程之间的CAS干扰</span></span><br><span class="line">            <span class="comment">//如果f是此节点的下个节点，b是此节点的前个节点</span></span><br><span class="line">            <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">                <span class="comment">//如果f为空或f的value字段不等于f，则尝试CAS将新Node节点插入f前</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">                    casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">                <span class="comment">//否则，用f的下个节点覆盖f</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; node;<span class="comment">//对应链表节点，即value</span></span><br><span class="line">        <span class="keyword">final</span> Index&lt;K,V&gt; down;<span class="comment">//下层索引节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Index&lt;K,V&gt; right;<span class="comment">//右边索引节点</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置right字段，CAS set right value</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casRight</span><span class="params">(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, rightOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否已删除此索引的节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">indexesDeletedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS索引节点newSucc作为当前节点的新右边节点（插入），并将原右边节点succ右移一位</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; n = node;</span><br><span class="line">            newSucc.right = succ;</span><br><span class="line">            <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS覆盖当前节点的右边节点succ。如果已知已删除此节点，则失败(强制调用者进行遍历) </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> rightOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = Index.class;</span><br><span class="line">                rightOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"right"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-get"><a href="#1-2-get" class="headerlink" title="1.2 get"></a><strong>1.2 get</strong></h3><p>通过 <code>get()</code> 获取键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//键不允许为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">//outer配合break，外层循环</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，找到所给键的前驱节点b，并找到键对应节点n</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="comment">//找到节点已为null，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">//若此时数据已发生改变，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//n节点的值已为null，说明已被删除，调用helpDelete删掉此节点，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//b已被删除，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若命中，则返回value</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所给键小于找到的n节点键，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">//否则右移，继续循环判断</span></span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-put"><a href="#1-3-put" class="headerlink" title="1.3 put"></a><strong>1.3 put</strong></h3><p>通过 <code>put()</code> 放置键值对，前面和 <code>get()</code> 流程类似，当新增节点时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非只覆盖value，新增了节点，通过随机数维持平衡</span></span><br><span class="line">    <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">        <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            ++level;</span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">            level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                h = head;</span><br><span class="line">                <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                    newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                    h = newh;</span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find insertion points and splice in</span></span><br><span class="line">        splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = h.level;</span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> splice;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                    <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        findNode(key);</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-remove"><a href="#1-4-remove" class="headerlink" title="1.4 remove"></a><strong>1.4 remove</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-findPredecessor"><a href="#1-5-findPredecessor" class="headerlink" title="1.5 findPredecessor"></a><strong>1.5 findPredecessor</strong></h3><p>通过 <code>findPredecessor()</code> 查找给定键和比较器的前驱节点（小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个其键严格小于给定键的base-level节点，如果没有这样的节点，则返回base-level header。</span></span><br><span class="line"><span class="comment"> * 通过不断右移和下移索引，找到对应链表节点，过程中会unlink发现到的已删除节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    <span class="comment">//外层循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，从头索引开始</span></span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            <span class="comment">//右边还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                K k = n.key;</span><br><span class="line">                <span class="comment">//右边索引对应Node所存值为空，则删掉它，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r)) <span class="comment">//删掉右边索引节点</span></span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    r = q.right;         <span class="comment">// 更新右边索引节点（原右边节点的右边节点）</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若所给键大于右边节点的键，则指针右移，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前索引节点没有下层索引，直接返回其Node节点</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">            <span class="comment">//否则指针q下移到下层索引，同时更新d</span></span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-findNode"><a href="#1-6-findNode" class="headerlink" title="1.6 findNode"></a><strong>1.6 findNode</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns node holding key or null if no such, clearing out any</span></span><br><span class="line"><span class="comment"> * deleted nodes seen along the way.  Repeatedly traverses at</span></span><br><span class="line"><span class="comment"> * base-level looking for key starting at predecessor returned</span></span><br><span class="line"><span class="comment"> * from findPredecessor, processing base-level deletions as</span></span><br><span class="line"><span class="comment"> * encountered. Some callers rely on this side-effect of clearing</span></span><br><span class="line"><span class="comment"> * deleted nodes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Restarts occur, at traversal step centered on node n, if:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (1) After reading n's next field, n is no longer assumed</span></span><br><span class="line"><span class="comment"> *       predecessor b's current successor, which means that</span></span><br><span class="line"><span class="comment"> *       we don't have a consistent 3-node snapshot and so cannot</span></span><br><span class="line"><span class="comment"> *       unlink any subsequent deleted nodes encountered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (2) n's value field is null, indicating n is deleted, in</span></span><br><span class="line"><span class="comment"> *       which case we help out an ongoing structural deletion</span></span><br><span class="line"><span class="comment"> *       before retrying.  Even though there are cases where such</span></span><br><span class="line"><span class="comment"> *       unlinking doesn't require restart, they aren't sorted out</span></span><br><span class="line"><span class="comment"> *       here because doing so would not usually outweigh cost of</span></span><br><span class="line"><span class="comment"> *       restarting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (3) n is a marker or n's predecessor's value field is null,</span></span><br><span class="line"><span class="comment"> *       indicating (among other possibilities) that</span></span><br><span class="line"><span class="comment"> *       findPredecessor returned a deleted node. We can't unlink</span></span><br><span class="line"><span class="comment"> *       the node because we don't know its predecessor, so rely</span></span><br><span class="line"><span class="comment"> *       on another call to findPredecessor to notice and return</span></span><br><span class="line"><span class="comment"> *       some earlier predecessor, which it will do. This check is</span></span><br><span class="line"><span class="comment"> *       only strictly needed at beginning of loop, (and the</span></span><br><span class="line"><span class="comment"> *       b.value check isn't strictly needed at all) but is done</span></span><br><span class="line"><span class="comment"> *       each iteration to help avoid contention with other</span></span><br><span class="line"><span class="comment"> *       threads by callers that will fail to be able to change</span></span><br><span class="line"><span class="comment"> *       links, and so will retry anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The traversal loops in doPut, doRemove, and findNear all</span></span><br><span class="line"><span class="comment"> * include the same three kinds of checks. And specialized</span></span><br><span class="line"><span class="comment"> * versions appear in findFirst, and findLast and their</span></span><br><span class="line"><span class="comment"> * variants. They can't easily share code because each uses the</span></span><br><span class="line"><span class="comment"> * reads of fields held in locals occurring in the orders they</span></span><br><span class="line"><span class="comment"> * were performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node holding key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findNode</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">跳跃列表</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/java-concurrent-skip-list-map" target="_blank" rel="noopener">Guide to the ConcurrentSkipListMap</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了下Java中ConcurrentSkipListMap的实现原理，包括：概述，跳表，源码解析等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>算法复习 (二) 查找-散列表</title>
    <link href="http://linyishui.top/2020070501.html"/>
    <id>http://linyishui.top/2020070501.html</id>
    <published>2020-07-05T09:35:09.000Z</published>
    <updated>2020-08-06T16:34:57.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><strong>散列表</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是散列表"><a href="#1-1-什么是散列表" class="headerlink" title="1.1 什么是散列表"></a><strong>1.1 什么是散列表</strong></h3><p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<strong>键</strong>（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><p>通过散列表我们可以在一般应用中拥有（均摊后）<strong>常数级别</strong>的查找和插入操作。</p><p>散列表的查找分为两步：</p><ol><li>通过<strong>散列函数</strong>将被查找的键转化为数组的一个索引。</li><li>处理<strong>碰撞冲突</strong>的情况。</li></ol><h3 id="1-2-散列函数"><a href="#1-2-散列函数" class="headerlink" title="1.2 散列函数"></a><strong>1.2 散列函数</strong></h3><p>散列函数的计算过程将键转化为数组的索引：如果我们有一个能保持M个键值对的数组，就需要一个能够将任意键转化为该数组范围内的索引（[0,M-1]）的<strong>散列函数</strong>。</p><p>严格来说，<strong>对于每种类型的键都需要一个与之对应的散列函数</strong>。</p><ul><li>正整数：常用<strong>除留余数法</strong>，数组大小为素数M，任意整数k除以M获得余数。选用素数的原因是避免无法均匀的散列。</li><li>浮点数：0到1间的实数，可以乘以M并四舍五入得到一个0至M-1间的索引值。但这种方法使键的高位占更大作用，低位则没什么影响，Java中采用的修正方法是<strong>将键表示为二进制再使用除留余数法</strong>。</li><li>字符串：也可以使用<strong>除留余数法</strong>，Java中有 <code>charAt()</code> 函数能返回一个char值，即一个非负16位整数。把字符串当作一个N位的R进制值，除以M并取余。Java默认使用类似 <code>Horner</code> 方法的算法，用N次乘法、加法和取余计算一个字符串的散列值。</li><li>组合键：键类型包含多种类型，如多个整型变量组合，比如Date类型，可以通过 <code>int hash = (((day * R + month) % M ) * R + year) % M</code> 来计算散列值。只要R足够小，就可以得到一个0至M-1间的散列值。</li></ul><p>Java为很多常用的数据类型重写了 <code>hashcode()</code> 方法（如String、Integer、Double、File和URL）。</p><h3 id="1-3-哈希碰撞"><a href="#1-3-哈希碰撞" class="headerlink" title="1.3 哈希碰撞"></a><strong>1.3 哈希碰撞</strong></h3><p>对不同的关键字可能得到同一散列地址，即 k~1~ != k~2~ ，而 f(k~1~) == f(k~2~) ，这种现象称为<strong>冲突</strong>（英语：Collision），也叫哈希冲突/碰撞。</p><p>两种处理哈希碰撞的方法：</p><ul><li><strong>开放地址法</strong>：当遇到哈希冲突时，依照增量规则向后取地址直到有未被占用地址为止。实例公式：<code>Hash(key) = (Hash(key) + di) mod TableSize</code> ，di表示增量序列，di不同的增长可分为：<ul><li><strong>线性探测法</strong>：di = i++ [1,2,3……，TableSize-1] ，即依次按地址后取，当一个键散列值被占用时，直接检查散列表的下一个位置（索引值加1），弊端是元素积聚，没有均匀的分布元素，导致性能降低，多查询了越来越多的无关项。</li><li><strong>二次探测法</strong>：di = (i++)^2^ * (di  / |di|) [1,-1,4,-4,9,-9……] ，弊端是当剩余空间较少时，在还有空间的情况下会极有可能插入失败。</li><li><strong>双散列探测法</strong>：di = (i++) * Hash2(key) [1H,2H,3H……] ，<code>Hash2(key) = p – (key mod p)</code> ，<code>Hash2(key) = (key % 97) + 1</code> ，其中p为小于表长的任意素数。通过另外一个散列函数来减少积聚问题，第二个函数需要排出散列值为0的情况，计算的散列值要和表长互素。</li></ul></li><li><strong>链地址法/拉链法</strong>：即将散列表每一个地址都对应一个链表，似乎链表会占用更多的空间，但实际使用中，因为装填因子的存在所以链地址法可能会更节省空间。通常情况下哈希表都非常高效，插入或查询都是O(1)，最差情况是集中映射到少量地址上，就会退化为链表查询，若被人通过Hash攻击的方式产生大量的碰撞，会导致本来高效的服务处理变得异常缓慢，可以通过限制表单提交长度等方法来防止此类攻击。</li></ul><hr><h2 id="第二节-实现"><a href="#第二节-实现" class="headerlink" title="第二节 实现"></a><strong>第二节 实现</strong></h2><h3 id="2-1-基于拉链法的散列表"><a href="#2-1-基于拉链法的散列表" class="headerlink" title="2.1 基于拉链法的散列表"></a><strong>2.1 基于拉链法的散列表</strong></h3><p>下面这个简单的符号表维护了一条链表数组，通过散列函数来为每个键选择链表。创建 <code>st[]</code> 时需要进行类型转换，因为 Java 不允许泛型的数组。默认构造器会使用997条链表，此段简单的代码已经可以在已知符号表大小时得到不错的性能，当然还可以添加<strong>动态调整链表数组的大小</strong>（rehash-再散列）的功能，从而能在任意大小都能保证链表的短小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表大小</span></span><br><span class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st;<span class="comment">//存放链表对象的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建M条链表</span></span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">            st[i] = <span class="keyword">new</span> SequentialSearchST();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value) st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-基于线性探测法的散列表"><a href="#2-2-基于线性探测法的散列表" class="headerlink" title="2.2 基于线性探测法的散列表"></a><strong>2.2 基于线性探测法的散列表</strong></h3><p>线性探测表<strong>通过空（null）来表示一簇键的结束</strong>，对于删除操作来说，直接将对应元素值设置为 <code>null</code> 是不行的，会导致此位置之后的元素无法被查找。正确的做法是将右侧所有键重新插入散列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">16</span>;<span class="comment">//线性探测表大小</span></span><br><span class="line">    <span class="keyword">private</span> key[] keys;<span class="comment">//键数组</span></span><br><span class="line">    <span class="keyword">private</span> value[] vals;<span class="comment">//值数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = (key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        vals = (value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;<span class="comment">//散列函数</span></span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;<span class="comment">//再散列</span></span><br><span class="line">        <span class="comment">//实例化新的线性探测表</span></span><br><span class="line">        LinearProbingHashST&lt;Key, Value&gt; t;</span><br><span class="line">        t = <span class="keyword">new</span> LinearProbingHashST&lt;Key, Value&gt;(cap);</span><br><span class="line">        <span class="comment">//循环遍历拷贝旧表元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">        <span class="keyword">if</span>(keys[i] != <span class="keyword">null</span>)</span><br><span class="line">                t.put(keys[i], vals[i]);</span><br><span class="line">        <span class="comment">//更新当前引用，t为局部变量</span></span><br><span class="line">        keys = t.keys;</span><br><span class="line">        vals = t.vals;</span><br><span class="line">        M = t.M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N &gt;= M/<span class="number">2</span>) resize(M*<span class="number">2</span>); <span class="comment">//M加倍扩容散列表</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//i散列得到索引，若键相等则替换值，否则检查下一个位置，直到对应key为空</span></span><br><span class="line">        <span class="keyword">for</span>(i = hash(key);keys[i] != <span class="keyword">null</span>;i = (i + <span class="number">1</span>) % M)</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))&#123;</span><br><span class="line">                vals[i] = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//将键值放入当前i</span></span><br><span class="line">        keys[i] = key;</span><br><span class="line">        vals[i] = val;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key);keys[i] != <span class="keyword">null</span>;i = (i + <span class="number">1</span>) % M)</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))</span><br><span class="line">                <span class="keyword">return</span> vals[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = hash(key);</span><br><span class="line">        <span class="comment">//遍历键簇直到找到对应key</span></span><br><span class="line">        <span class="keyword">while</span>(!key.equals(key[i]))</span><br><span class="line">            i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先将对应索引置空</span></span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        vals[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新i到下一个位置</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环将后面元素重新加入散列表，直到遍历到下一个空</span></span><br><span class="line">        <span class="keyword">while</span>(keys[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Key keyToRedo = keys[i];</span><br><span class="line">            Value valueToRedo = vals[i];</span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        vals[i] = <span class="keyword">null</span>;</span><br><span class="line">            N--;</span><br><span class="line">            put(keyToRedo, valueToRedo);</span><br><span class="line">            i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">//若此时键值对总数达到1/8表大小，则再散列缩小</span></span><br><span class="line">        <span class="keyword">if</span>(N &gt; <span class="number">0</span> &amp;&amp; N == M/<span class="number">8</span>) </span><br><span class="line">            resize(M/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-查找总结"><a href="#第三节-查找总结" class="headerlink" title="第三节 查找总结"></a><strong>第三节 查找总结</strong></h2><h3 id="3-1-各种符号表渐进性能的总结"><a href="#3-1-各种符号表渐进性能的总结" class="headerlink" title="3.1 各种符号表渐进性能的总结"></a><strong>3.1 各种符号表渐进性能的总结</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010117.jpg" alt></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了散列表的相关内容，内容包括：概述（什么是散列表、散列函数、哈希碰撞），实现（基于拉链法的散列表、基于线性探测法的散列表），查找总结。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="hash" scheme="http://linyishui.top/tags/hash/"/>
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>B树和B+树</title>
    <link href="http://linyishui.top/2020070201.html"/>
    <id>http://linyishui.top/2020070201.html</id>
    <published>2020-07-02T08:40:04.000Z</published>
    <updated>2020-08-05T16:11:59.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><strong>B树和B+树</strong></h1><h2 id="第一节-B树"><a href="#第一节-B树" class="headerlink" title="第一节 B树"></a><strong>第一节 B树</strong></h2><h3 id="1-1-什么是B树"><a href="#1-1-什么是B树" class="headerlink" title="1.1 什么是B树"></a><strong>1.1 什么是B树</strong></h3><p>B树是一种<strong>自平衡</strong>的树，能够保持数据<strong>有序</strong>。保证查找数据、顺序访问、插入数据、删除等操作都能在<strong>对数时间</strong>内完成。</p><p>B树也属于二叉查找树，<strong>一个节点允许拥有两个以上的子节点</strong>。与平衡二叉树不同的是，B树适用于读写相对较大的数据块的存储系统，如磁盘。</p><p>B树减少定位记录时所经历的中间过程，从而加快存取速度。</p><p><strong>2-3树、红黑树都是常见的B树</strong>。</p><h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a><strong>1.2 应用场景</strong></h3><p>B树这种数据结构可以用来描述外部存储。常被应用在<strong>数据库</strong>和<strong>文件系统</strong>的实现上。</p><h3 id="1-3-描述"><a href="#1-3-描述" class="headerlink" title="1.3 描述"></a><strong>1.3 描述</strong></h3><p>几个定义：</p><ul><li><strong>内部节点</strong>：内部节点是除叶子节点和根节点之外的所有节点。它们通常被表示为一组有序的元素和指向子节点的指针。</li><li><strong>根节点</strong>：根节点拥有的子节点数量的上限和内部节点相同，但是没有下限。</li><li><strong>叶子节点</strong>：叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。</li></ul><p>B树的内部结点（非叶子）可以拥有可变数量的子结点。因为子结点可变数量这一特性，B树不需要像其他平衡二叉树那样频繁的进行重新保持平衡的操作，但相应的也造成了空间浪费（以空间换时间）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/400px-B-tree.svg.png" alt></p><p>子节点数量的上界和下界依特定的实现而设置。例如，在一个2-3 B树（通常简称<a href="https://zh.wikipedia.org/wiki/2-3树" target="_blank" rel="noopener">2-3树</a>），每一个内部节点只能有2或3个子节点。</p><h3 id="1-4-操作"><a href="#1-4-操作" class="headerlink" title="1.4 操作"></a><strong>1.4 操作</strong></h3><h4 id="（1）搜索"><a href="#（1）搜索" class="headerlink" title="（1）搜索"></a><strong>（1）搜索</strong></h4><p>B树的搜索和二叉搜索树类似：从根节点开始，从上到下<strong>递归的遍历树</strong>。在每一层上，搜索的范围被减小到包含了搜索值的子树中（左小右大）。子树值的范围被它的父节点的键确定。</p><h4 id="（2）插入"><a href="#（2）插入" class="headerlink" title="（2）插入"></a><strong>（2）插入</strong></h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/B_tree_insertion_example.png" alt></p><p>所有的插入都从根节点开始。要插入一个新的元素，首先搜索这棵树找到新元素应该被添加到的对应节点。将新元素插入到这一节点中的步骤如下：</p><ol><li>如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序。</li><li>否则的话这一节点已经满了，将它平均地分裂成两个节点：<ol><li>从该节点的原有元素和新的元素中选择出中位数。</li><li>小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值。</li><li>分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）。</li></ol></li></ol><h4 id="（3）删除叶子节点中的元素"><a href="#（3）删除叶子节点中的元素" class="headerlink" title="（3）删除叶子节点中的元素"></a><strong>（3）删除叶子节点中的元素</strong></h4><ol><li>搜索要删除的元素。</li><li>如果它在叶子节点，将它从中删除。</li><li>如果发生了下溢出，按照后面<strong>删除后重新平衡</strong>部分的描述重新调整树。</li></ol><h4 id="（4）删除内部节点中的元素"><a href="#（4）删除内部节点中的元素" class="headerlink" title="（4）删除内部节点中的元素"></a><strong>（4）删除内部节点中的元素</strong></h4><p>内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：</p><ol><li>选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。</li><li>前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。</li></ol><h4 id="（5）删除后的重新平衡"><a href="#（5）删除后的重新平衡" class="headerlink" title="（5）删除后的重新平衡"></a><strong>（5）删除后的重新平衡</strong></h4><p>重新平衡从叶子节点开始向根节点进行，直到树重新平衡（自底向上）。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点<strong>合并</strong>。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：</p><ul><li>如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转：<ol><li>将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）。</li><li>将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）。</li><li>树又重新平衡。</li></ol></li><li>否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转：<ol><li>将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）。</li><li>将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）。</li><li>树又重新平衡。</li></ol></li><li>否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并：<ol><li>将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）。</li><li>将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）。</li><li>将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）。<ul><li>如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）。</li><li>否则，如果父节点的元素数量小于最小值，重新平衡父节点。</li></ul></li></ol></li></ul><h3 id="1-5-变体"><a href="#1-5-变体" class="headerlink" title="1.5 变体"></a><strong>1.5 变体</strong></h3><p>B树在内部结点上存储键值，但不需要在叶子结点上存储这些键值的记录。</p><ul><li><strong>B+树</strong>：<ul><li>这些键值的拷贝被存储在内部结点；</li><li>键值和记录存储在叶子结点；</li><li>一个叶子结点可以包含一个指针，指向另一个叶子结点以加速顺序存取。</li></ul></li><li><strong>B*树</strong>：分支出更多的内部邻居节点以保持内部节点更密集地填充。此变体要求非根节点至少2/3填充，而不是1/2。为了维持这样的结构，当一个节点填满之后将不会再立即分割节点，而是将它的键值与下一个节点共享。当两个节点都填满之后，分割成3个节点。</li><li>计数B树存储，每一树都带有一个指针和其指向子树的节点数目。这就允许了以键值为序快速查找第N笔记录，或是统计2笔记录之间的记录数目，还有其他很多相关的操作。</li></ul><h3 id="1-6-B树与平衡二叉树的区别"><a href="#1-6-B树与平衡二叉树的区别" class="headerlink" title="1.6 B树与平衡二叉树的区别"></a><strong>1.6 B树与平衡二叉树的区别</strong></h3><p>平衡二叉树通常是指查找路径只有两种（即只有二叉），而B树则不仅仅二叉，所以也叫<strong>平衡多路查找树</strong>。</p><p>B树相比平衡二叉树在每个结点所包含的内容更多，在应用到数据库中的时候，充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把结点大小限制和充分使用在磁盘块大小范围。所以树的结点能包含更多的内容后，树的层级比原来的二叉树少了，就可以减少数据查找的次数和复杂度。</p><hr><h2 id="第二节-B-树"><a href="#第二节-B-树" class="headerlink" title="第二节 B+树"></a><strong>第二节 B+树</strong></h2><h3 id="2-1-什么是B-树"><a href="#2-1-什么是B-树" class="headerlink" title="2.1 什么是B+树"></a><strong>2.1 什么是B+树</strong></h3><p><strong>B+ 树</strong>是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是<strong>能够保持数据稳定有序</strong>，其<strong>插入与修改拥有较稳定的对数时间复杂度</strong>。B+ 树元素<strong>自底向上插入</strong>，这与二叉树恰好相反。</p><p>B+ 树在节点访问时间远远超过节点内部访问时间的时候，比其他可作为替代的实现有着实在的优势。这通常在多数节点在次级存储比如硬盘中的时候出现。<strong>通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了</strong>。通常需要每个节点在次级存储中占据完整的磁盘块或近似的大小。</p><p>B+ 背后的设计思想是<strong>内部节点可以有在预定范围内的可变量目的子节点</strong>。因此，B+ 树不需要像其他自平衡二叉查找树那样经常的重新平衡。对于特定的实现在子节点数目上的低和高边界是固定的。</p><p>B+ 树的创造者 <code>Rudolf Bayer</code> 没有解释 <code>B</code> 代表什么。最常见的观点是 <code>B</code> 代表<strong>平衡</strong>(balanced)，因为所有的叶子节点在树中都在相同的级别上。<code>B</code> 也可能代表 <code>Bayer</code>，或者是<a href="https://zh.wikipedia.org/wiki/波音" target="_blank" rel="noopener">波音</a>（Boeing），因为他曾经工作于<em>波音科学研究实验室</em>。</p><p>如下图，把键 <code>1-7</code> 连接到值 <code>d1-d7</code> 的B+树。链表（红色）用于快速顺序遍历叶子节点。树的分叉因子 <code>b=4</code> 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/400px-Bplustree.png" alt></p><h3 id="2-2-节点结构"><a href="#2-2-节点结构" class="headerlink" title="2.2 节点结构"></a><strong>2.2 节点结构</strong></h3><p>在B+树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的阶数是 <code>m</code> ，则除了根之外的每个节点都包含最少 <code>m/2</code> 个元素最多 <code>m-1</code> 个元素，对于任意的结点有最多 <code>m</code> 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。</p><p>如下图所示，非叶子结点的关键字不保存数据，只用来索引，所有数据都保存在叶子节点。所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010115.png" alt></p><h3 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a><strong>2.3 算法</strong></h3><h4 id="2-3-1-查找"><a href="#2-3-1-查找" class="headerlink" title="2.3.1 查找"></a><strong>2.3.1 查找</strong></h4><p>查找以典型的方式进行，类似于<a href="https://zh.wikipedia.org/wiki/二叉查找树" target="_blank" rel="noopener">二叉查找树</a>。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是<a href="https://zh.wikipedia.org/wiki/二分查找" target="_blank" rel="noopener">二分查找</a>来确定这个位置。</p><h4 id="2-3-2-插入"><a href="#2-3-2-插入" class="headerlink" title="2.3.2 插入"></a><strong>2.3.2 插入</strong></h4><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。</p><ol><li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li></ol><h4 id="2-3-3-删除"><a href="#2-3-3-删除" class="headerlink" title="2.3.3 删除"></a><strong>2.3.3 删除</strong></h4><ol><li>首先，查找要删除的值。接着从包含它的节点中删除这个值。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果节点处于违规状态则有两种可能情况：<ol><li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。</li><li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li></ol></li></ol><h3 id="2-4-实例说明"><a href="#2-4-实例说明" class="headerlink" title="2.4 实例说明"></a><strong>2.4 实例说明</strong></h3><p>假设B+树结点最多容纳存放3个键和4个指针， <code>m = 3</code> 为奇数，<code>d = 1</code> ，叶子结点至少2个条目（d + 1），非叶子结点至少2个指针（d + 1），1个条目。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010101.png" alt></p><p>首先插入1：判断根结点为空直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010102.png" alt></p><p>接着连续插入3、5：根结点未满，连续放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010103.png" alt></p><p>接着插入7：此时根结点达到max，判断需要分裂：<strong>当节点元素数量大于m-1的时候，从中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，当然本身中间元素还是分裂右边这一部分的，保证左小右大的规则</strong>。所以分裂成两个子结点，1和3下沉到左边，5和7下沉到右边，内部结点只保存索引，最底层叶子结点连成有序链表。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010104.png" alt></p><p>接着插入9：找到位置，还有空间，直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010105.png" alt></p><p>接着插入2：如上放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010106.png" alt></p><p>接着插入4：此时对应叶子结点已放满，需要再度分裂成两个结点，1和2保留在左结点，3和4则移到新结点，并将新结点首个元素指向父结点（此时父结点仍有空间）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010107.png" alt></p><p>接着插入6：对应叶子结点同样已满，继续相同分裂操作，并将新结点首个元素指向父结点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010108.png" alt></p><p>接着插入8：仍有空间，直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010109.png" alt></p><p>接着插入10：此时对应叶子结点已满，所以先分裂开，7和8保留，9和10生成新叶子结点，将新叶子结点首个元素指向父结点，此时父结点超过上限（已是根结点，递归向上分裂，直到根结点分裂，增加高度），所以根结点分裂，中间元素7成为新的根结点，左小右大，新的结构仍是稳定的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010110.png" alt></p><p>接下来我们看B+树的删除操作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010111.png" alt></p><p>首先删除9：查找9所在结点，把它删除，然后判断此时树状态，发现叶子结点违规：叶子结点至少2个条目（d + 1），非叶子结点至少2个指针（d + 1），1个条目。合并兄弟结点，10、11和12合并，此时父结点因为少了一个子结点违规，所以需要继续处理。（此处为何为9还未搞懂）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010112.png" alt></p><p>接着删除7：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010113.png" alt></p><p>接着删除8：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010114.png" alt></p><h3 id="2-5-B-树的特点"><a href="#2-5-B-树的特点" class="headerlink" title="2.5 B+树的特点"></a><strong>2.5 B+树的特点</strong></h3><ol><li>B+树的非叶子结点不保存关键字记录的指针，只进行数据索引，这样可以使B+树每个非叶子结点所能保存的关键字数大大增加。</li><li>B+树叶子结点保存了父结点的所有关键字记录的指针，所有数据地址必须到叶子结点才能获取到，所以每次数据查询的次数都相同。</li><li>B+树叶子结点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li><strong>非叶子节点的子节点数</strong> = <strong>关键字数</strong>，或者<strong>非叶节点的关键字数</strong> = <strong>子节点数</strong> - 1，虽然他们数据排列结构不一样，但其原理还是一样的，Mysql 的B+树是用第一种方式实现。</li></ol><h3 id="2-6-B-树与B树的区别"><a href="#2-6-B-树与B树的区别" class="headerlink" title="2.6 B+树与B树的区别"></a><strong>2.6 B+树与B树的区别</strong></h3><ol><li>B+树的<strong>层级更少</strong>：相较于B树，B+树的每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li><li>B+树<strong>查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li><li>B+树<strong>天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li></ol><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><table><thead><tr><th style="text-align:center">S.NO</th><th style="text-align:center">B TREE</th><th style="text-align:center">B+ TREE</th></tr></thead><tbody><tr><td style="text-align:center">1.</td><td style="text-align:center">所有的内部和叶子结点都有数据指针</td><td style="text-align:center">只有叶子结点有数据指针</td></tr><tr><td style="text-align:center">2.</td><td style="text-align:center">由于叶子结点上的所有键都不可用，所以搜索通常更费时</td><td style="text-align:center">所有键都在叶节点上，因此搜索更快，更准确</td></tr><tr><td style="text-align:center">3.</td><td style="text-align:center">树中没有重复的键</td><td style="text-align:center">允许重复的键，并且所有结点都存在于叶子上</td></tr><tr><td style="text-align:center">4.</td><td style="text-align:center">插入会花费更多时间，有时无法预测</td><td style="text-align:center">插入更容易，结果始终相同</td></tr><tr><td style="text-align:center">5.</td><td style="text-align:center">内部结点的删除非常复杂，并且树必须进行大量转换</td><td style="text-align:center">删除任何节点都很容易，因为所有结点都可以在叶子上找到</td></tr><tr><td style="text-align:center">6.</td><td style="text-align:center">叶子结点不存储为结构链表</td><td style="text-align:center">叶子结点存储为结构链表</td></tr><tr><td style="text-align:center">7.</td><td style="text-align:center">没有多余的搜索键</td><td style="text-align:center">可能存在多余的搜索键</td></tr></tbody></table><h3 id="2-7-B-树与B-树的区别"><a href="#2-7-B-树与B-树的区别" class="headerlink" title="2.7 B+树与B*树的区别"></a><strong>2.7 B+树与B*树的区别</strong></h3><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ol><li><p>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是 <code>cei(m/2)</code> ，<code>b*</code> 树的初始化个数为<code>cei(2/3*m)</code> 。</p></li><li><p>B+树节点满时就会分裂，而B<em>树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</em></p></li><li>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</li></ol><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/B树" target="_blank" rel="noopener">B树-维基百科</a></p></blockquote><blockquote><p><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B+树-维基百科</a></p></blockquote><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了B树和B+树的相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="http://linyishui.top/2020070101.html"/>
    <id>http://linyishui.top/2020070101.html</id>
    <published>2020-07-01T09:28:50.000Z</published>
    <updated>2020-08-06T09:30:27.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a><strong>Redis底层数据结构</strong></h1><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80bc35b4da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="第一节-动态字符串-SDS"><a href="#第一节-动态字符串-SDS" class="headerlink" title="第一节 动态字符串-SDS"></a><strong>第一节 动态字符串-SDS</strong></h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a><strong>1.1 概述</strong></h3><p>Redis 是由 <strong>C 语言</strong>作为底层编程语言实现的，而 <strong>C 语言中的字符串是一个以空字符结尾的字符数组</strong>，这种结构对于 Redis 而言过于简单了，主要缺点如下：</p><ol><li><strong>C 字符串不记录自身长度信息，为了获取字符串长度必须遍历整个字符串，时间复杂度为 O(n)</strong>。</li><li>由于 C 字符串不记录自身长度，<strong>稍有不小心就会造成缓冲区溢出</strong>。</li><li>对于 Redis 这种缓存类型数据库，对于缓存的 Value 是有可能经常的更改的。但是 <strong>C 字符串每次的增长或是缩小都需要一次内存的重分配操作</strong>。</li><li>Redis 数据库中缓存的内容不是特定的，有可能会是图片、音频等等文件的二进制数据，但是 <strong>C 字符串中的字符必须符合某种编码，且字符串中不能包含空格</strong>，这些限制也导致了 Redis 不能使用 C 字符串来作为自身字符串的实现。</li></ol><p>于是 Redis 实现了 SDS 这种简单动态字符串结构，它其实和 Java 中 ArrayList 的实现是很类似的。</p><p>Redis 源代码中 <code>sds.h</code> 文件下，有五种 <code>sdshdr</code> ，它们分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，sdshdr5 的注释表明，<strong>sdshdr5  is never used</strong>。sdshdr5 这种数据结构一般用于存储长度小于 32 个字符的字符串，但现在也已经不再使用这种结构了，再小长度的字符串也建议使用 sdshdr8 进行存储，因为 sdshdr5 少了两个关键字段，因此不具备动态扩容操作，一旦预分配的内存空间使用完，就需要重新分配内存并完成数据的复制迁移，在实际的生产环境中对于性能的影响还是很大的，所以进行了一个抛弃，但其实有些比较小的键依然会采用这种结构存储。</p><p>关于 sdshdr5 我们不再多说，我们看其他四种结构的各个字段，len 字段表示当前字符串总长度，也即当前字符串已使用内存大小，alloc 表示为当前字符串分配的总内存大小（不包括len以及flags字段本身分配的内存），因为每一个结构在预分配的时候都会多分配一段内存空间，主要是为了方便以后的扩容。flags 的低三位表示当前 sds 的类型，高五位无用。低三位取值如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure><p>实际上，redis 对 sdshdr 内存分配是禁用内存对齐的，也就是说每个字段分配的内存地址是紧紧排列在一起的， 所以 redis 中字符串参数的传递直接使用 <strong>char*</strong> 指针。</p><p>可能有人会疑问，仅仅通过一个 <strong>char</strong> 指针如何确定当前字符串的类型，其实由于 sdshdr 内存分配禁止内存对齐，所以 sds[-1] 其实指向的就是 flags 字段的内存地址，通过 flags 字段又可以得到当前 sds 属于哪种类型，进而可以读取头部字段确定 sds 的相关属性。</p><p>接下来我们讲讲 sdshdr 相对于传统的 C 语言字符串，性能的提升在哪，以及具有哪些便捷的点。</p><p><strong>首先</strong>，对于传统的 C 字符串，我想要获取字符串的长度，至少需要 O(n) 遍历一遍数组才行，而我们 sds 只需要 O(1) 的取 len 字段的值即可。</p><p><strong>其次</strong>，也是非常重要的一个设计，如果我们初始分配了一个字符串对象，那么如果我要在这个字符串后面追加内容的话，限制于数组的长度一经初始化是不能修改的，我们至少需要分配一个足够大的数组，然后将原先的字符串进行一个拷贝。</p><p><strong>sdshdr 每次为一个 sds 分配内存的时候都会额外分配一部分暂不使用的内存空间，一般额外的内存会等同于当前字符串占用的内存大小，如果超过 1MB，那么额外空间的内存大小就是 1MB</strong>。每当执行 sdscat 这种方法的时候，程序会用 alloc-len 比较下剩下的空余内存是否足够分配追加的内容，如果不够自然触发内存重分配，而如果剩余未使用内存空间足够放下，那么将直接进行分配，无需内存重分配。</p><p><strong>通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次</strong>。</p><p><strong>最后</strong>，对于常规的 C 语言字符串，它通过判断当前字符是否是空字符来决定字符串的结尾，所以就要求你的字符串中不能包含甚至一个空字符，否则空字符后面的字符都不能作为有效字符被读取。而对于某些具有特殊格式要求的，需要使用空字符进行分隔作用的，那么传统的 C 字符串就无法存储了，而我们的 <strong>sds 不是通过空字符判断字符串结尾，而是通过 len 字段的值判断字符串的结尾</strong>，所以说，sds 还具备<strong>二进制安全</strong>这个特性，即它可以安全的存储具备特殊格式要求的二进制数据。</p><p>关于 sds 我们就简单说到这，它是一种改良版的 C 字符串，兼容 C 语言中既有的函数 API，也通过一些手段提升了某些操作的性能，值得大家借鉴。</p><hr><h2 id="第二节-链表"><a href="#第二节-链表" class="headerlink" title="第二节 链表"></a><strong>第二节 链表</strong></h2><p>链表这种数据结构相信大家也不陌生，有很多类型，比如单向链表，双向链表，循环链表等，链表相对于数组来说，<strong>一是不需要连续的内存块地址，二是删除和插入的时间复杂度是 O(1) 级别的</strong>，非常的高效，但<strong>比不上数组的随机访问查询方式</strong>。</p><p>一样的那句话，没有最好的数据结构，只有恰到好处的数据结构，比如我们后面要介绍的更高层次的数据结构，字典，它的底层其实就依赖的链表规避哈希冲突，具体的我们后面再说。</p><p>redis 中借助 C 语言实现了一个双向链表结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>pre 指针指向前一个节点，next 指针指向后一个节点，value 指向当前节点对应的数据对象。盗一张图描述整个串联起来的链表结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80c4f8982b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>虽然通过链表的第一个头节点就可以遍历整个链表，但在 <strong>redis 向上封装了一层结构，专门用于表示一个链表结构</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><ul><li>head 指向链表的头节点</li><li>tail 指向链表的尾节点</li><li>dup 函数用于链表转移复制时对节点 value 拷贝的一个实现，一般来说用等于号足以，但某些特殊情况下可能会用到节点转移函数，默认可以给这个函数赋值 NULL 即表示使用等于号进行节点转移。</li><li>free 函数用于释放一个节点所占用的内存空间，默认赋值 NULL 的话，即使用 redis 自带的 zfree 函数进行内存空间释放，我们也可以来看一下这个 zfree 函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会涉及到一个<strong>内存对齐</strong>的概念，就比如一个 64 位的操作系统，一次内存 IO 会固定取出 8 个字节的内存数据出来，如果某个变量横跨了两个八字节段，那么 CPU 需要进行两次的 IO 才能完整取出该变量的数据，引入内存对齐，是为了保证任意变量的内存分配不会出现上述的横跨情况，具体的操作手法就是填充无用的内存位，当然这必然会造成内存碎片，不过这也是一种以空间换时间的策略，你也可以禁用它。</p><p>函数的上半部分是做一些判断，如果确定了该指针指向的数据结构占用的总内存，则直接调用 free 函数进行内存的释放，否则需要进行一个计算。redis 中的 zmalloc 在每一次内存数据分配的时候都会追加一个 PREFIX_SIZE 的头部数据块，它的值等于当前系统的最大寻址空间，比如 64 CPU的话，PREFIX_SIZE 就会占用到 8 个字节，并且这 8 个字节内部存储的是当前数据实际占用内存大小。</p><p>所以这里的话，ptr 指针向低位移动就是指向头部 PREFIX_SIZE 字段首地址，然后取出里面保存的值，也就是当前数据结构实际占用的内存大小，最后加上它自身传入 update_zmalloc_stat_free 函数中修改 used_memory 内存记录指针的值，并在最后调用 free 函数释放内存，包括头部的部分。</p><p>其实我们扯远了，继续看数据结构，这里如果还不是很明白的话，没关系，后面我们还会继续讲的。</p><p>match 函数依然是一个多态的实现，只给出了定义，具体实现由你来决定，你也可以选择不实现，它用于比较两个链表节点的 value 值是否相等。返回 0 表示不相等，返回 1 表示相等。</p><p>最后一个 len 字段描述的是，整个链表中所包含的节点数量。以上就是 redis 中链表的一个基本的定义，加上 list，最终链表结构在 redis 中呈现的抽象图大概是这样的，依然盗的图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80bc798df0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>综上，我们介绍了 redis 中链表的一个基本实现情况，总结一下，它是一个双端链表，也就是查找某个节点的前后节点的时间复杂度都在 O(1)，也是一个无环并具有首尾节点指针的链表，初次之外，还具有三个多态函数，用于节点间的复制、比较以及内存释放，需要使用者自行实现。</p><hr><h2 id="第三节-字典"><a href="#第三节-字典" class="headerlink" title="第三节 字典"></a><strong>第三节 字典</strong></h2><p>字典相对于数组，链表来说，是一种较高层次的数据结构，像我们的汉语字典一样，可以通过拼音或偏旁唯一确定一个汉字，在程序里我们管<strong>每一个映射关系叫做一个键值对</strong>，<strong>很多个键值对放在一起就构成了我们的字典结构</strong>。</p><p>有很多高级的字典结构实现，例如我们 <strong>Java 中的 HashMap 底层实现，根据键的 Hash 值均匀的将键值对分散到数组中，并在遇到哈希冲突时，冲突的键值对通过单向链表串联，并在链表结构超过八个节点裂变成红黑树</strong>。</p><p>那么 redis 中是怎么实现的呢？我们一起来看一看。</p><h3 id="一、字典结构定义"><a href="#一、字典结构定义" class="headerlink" title="一、字典结构定义"></a>一、字典结构定义</h3><p>Redis 中的字典相关结构都定义在 dict.h 文件中，dict 表示一个字典结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><ul><li>type 字段指向 dictType 结构，这个结构中定义几个多态方法。</li><li>privdata 指针存储了字典结构一些附属额外信息。</li><li>ht 是一个 dictht 结构的数组，dictht 就是一个哈希表结构。</li><li>rehashidx 字段用于 rehash 过程中记录正在转移的键。</li><li>iterators 字段记录了当前字典正在进行中的迭代器。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010116.png" alt></p><p>dictType 具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><ul><li>hashFunction 哈希函数指针，当我们通过 set 命令往字典中存储数据时，会先用键值对的键作为参数传入哈希函数，得到一个较为散列均匀的值，然后才会实际的进行数据的存储。这里就会用到哈希函数，如果你需要为你的字典结构提供不同的散列方式，在初始化字典的时候为 dictType 中哈希函数进行一个实现就好。</li><li>keyDup 是一个键的复制函数。</li><li>valDup是一个键值对的值的复制函数。</li><li>keyCompare 是一个键的比较大小的函数。</li><li>keyDestructor 销毁一个键。</li><li>valDestructor 销毁一个键值对的值。都是一个多态的呈现，具体实现需要使用者自行提供。</li></ul><p>接着看 dict 结构，具体的再看。</p><p>dictht 就是我们的哈希表结构，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table 是一个指向 dictEntry 的二维数组，每个 dictEntry 其实就表述一个键值对，为什么是一个二维的结构呢？</p><p>其实正常情况下，我们的字典是这样保存数据的：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800ede0c3b2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>每个 dictEntry 内部会保存一个 key/value 的键值对，然后我们通过 table 指针可以遍历所有的键值对，但是如果某个键值对的键进行哈希之后并计算得到应该存储的位置被别的节点捷足先登了，也就是我们常说的哈希冲突了，怎么办？</p><p>redis 中的做法，甚至于大部分字典结构实现都是选择将冲突的节点串联成链表，于是字典结构就变成这样了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800ecf48bcfe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p><strong>同一条链表上的节点键的哈希值必定是相同的，也正是因为相同才会被串在一起</strong>，从逻辑上看，字典结构如上图所展示的那样，但抽象到我们的代码层，就是一个二维数组的结构，第一维放的就是节点指针的指针，第二维指向的就是指向我们键值对结构的指针，每一个 dictEntry 结构都会有一个 next 指针，在遇到哈希冲突的时候可以串联所有冲突节点。</p><p>除此之外，dictht 中的 size 属性用于描述整个哈希字典表最大可寻址大小，也就是二维数组中第一维度的最大长度，sizemask 属性始终等于 size-1 表述的是一种大小掩码的概念，用于确定节点最初在数组中的位置，used 记录了整张哈希表中已经存储的键值对节点数量。</p><p>其中，dict 字典结构中 ht 是一个只有两个元素的数组，<strong>正常情况下我们使用 ht[0] 字典表，ht[1] 用在我们渐进 rehash 过程中转移 ht[0] 中所有节点中</strong>。</p><p>最后，我们再来看这个 dictEntry 键值对结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>key 是一个指向任意结构的指针，代表我们的 key 可以使用我们 redis 中任意对象类型，v 是一个 union 类型，它可以是一个指针，也可以是 uint64_t 或 int64_t 类型，也可以是一个 double 类型。根据实际使用中，value 的不同值，使用不同的字段属性。</p><p>next 指针指向另一个 dictEntry 结构，用于发生哈希冲突时，链接下一个键值对节点。</p><p>以上就是 redis 中字典结构主要结构类型，从里至外封装了三层，dict 描述一个字典，其中的 dictht 描述哈希表，其中的 dictEntry 描述键值对结构。迭代器回头我们单独说说。</p><h3 id="二、渐进式-rehash-迁移数据"><a href="#二、渐进式-rehash-迁移数据" class="headerlink" title="二、渐进式 rehash 迁移数据"></a>二、渐进式 rehash 迁移数据</h3><p>redis 的 rehash 和 Java 以及其他哈希的实现稍微可能有点不同，由于 redis 是单线程的，不需要写大量的并发语句来保证数据一致性，但是单线程处理也会导致一次 rehash 过程会非常缓慢，客户端阻塞太久。那么 redis 具体是怎么做的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rehashidx 的值默认为 -1，表示当前字典未处于 rehash 阶段，其他场合该字段的值等于当前正在转移桶的索引。</p><p>新版本的 dictRehash 需要多传一个参数 n，这个参数用于控制单次最多转移空桶数量。什么意思呢，具体我们看一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800edea0e859?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>有这么一个字典结构，其中索引值为 2 和 3 的两个桶是空的，即里面没有放我们的键值对节点。正常情况下，一次 rehash 只会转移一个桶，但如果上一次转移了索引为 1 的那个桶，下一次来会遍历后面一个桶，如果继续为空就继续向后遍历，直到找到一个存储了我们节点的非空桶，极端情况下，如果字典表中只有最后一个桶有节点，那么一次的 rehash 就要遍历所有的桶，时间复杂度 O(n)，这会导致客户端等待过长时间，所以新版本中额外传一个参数 n 用于控制最多遍历的空桶数。</p><p>相关代码段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    d-&gt;rehashidx++;</span><br><span class="line">    <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的尾部会进行一个校验，如果当前桶转移结束后，当前字典的 rehash 过程完全结束，那么修改 ht[0] 指针引用，让他指向新的字典表 ht[1]，并设置 rehashidx 为 -1，标记整个字典 rehash 结束。</p><p>以上就是 redis 中 rehash 的全过程，还是比较简单的，那为什么说它是渐进式的呢，我们看一下添加和查询键值对的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们调用 set 命令，底层为我们添加键值对的方法，函数的最开头逻辑就是调用 dictIsRehashing 方法判断当前的字典表是否处于 rehash 状态，也即判断 rehashidx 是否不等于 -1 了。_dictRehashStep 方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，一次 rehash 过程，redis 允许最多 10 空桶的访问就要返回，不得逗留。<strong>值得注意的是，方法的后续逻辑会判断当前字典如果正在进行 rehash，那么新的键值对将不再向 ht[0] 中添加，而直接转而添加到 ht[1] 中</strong>。</p><p>我们再看看查询键值对的 get 命令底层 API 调用，底层会调用 dictFind 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，同样也是有 dictIsRehashing 方法的判断，如果字典处于 rehash 状态，即需要去完成一个桶的转移，然后才能返回。<strong>值得注意的是，方法的中间逻辑是嵌套在一个 for 循环中的，供两次循环，第一次从 ht[0] 中搜索我们给定 key 的键值对，如果没有找到，第二次循环将从 ht[1] 中搜索我们要查询的键值对。</strong></p><p>之所以说 redis 的 rehash 是渐进式的，就是因为即便它处于 rehash 状态下，所有节点的插入、查询甚至于删除都是不受影响的，直至整个 rehash 结束，redis 释放原先 ht[0] 占用无用内存。</p><p><em>ps：redis 中的字典实现相对于 Java 中的实现要简单不少，主要还是因为 redis 是单线程调用的，不需要使用额外的并发语句控制。</em></p><h3 id="三、字典迭代器"><a href="#三、字典迭代器" class="headerlink" title="三、字典迭代器"></a>三、字典迭代器</h3><p>迭代器是用于迭代遍历字典中所有的节点的一个工具，有两种，一种是安全迭代器，一种是不安全迭代器。安全迭代器就是指，你在迭代的过程中，允许你对字典结构进行修改，也即允许你添加、删除、修改字典中的键值对节点。不安全迭代器即不允许对字典中任何节点进行修改。</p><p>dictIterator 结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure><p>字段 d 指向一个即将被迭代的字典结构，index 记录了当前迭代到字典中的桶索引，table 取值为 0 或 1，表示当前迭代的是字典中哪个哈希表，safe 标记当前迭代器是安全的或是不安全的。 entry 记录的是当前迭代的节点，nextEntry 的值等于 entry 的 next 指针，用于防止当前节点接受删除操作后续节点丢失情况。fingerprint 保存了 dictFingerprint 函数根据当前字典的基本信息计算的一个指纹信息，稍有一丁点变动，指纹信息就会发生变化，用于不安全迭代器检验。</p><p>安全迭代器获取方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不安全迭代器获取方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看看迭代器的核心方法，dictNext 用于获取字典中下一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果迭代器初次工作，entry 必定为 null</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到迭代器 d 字段保存的字典</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    <span class="comment">//给字典的 iterators 字段自增，禁止 rehash操作</span></span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//计算并保存指纹信息</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//迭代器开始工作，指向 0 号桶</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">//如果 index 大于等于 size，即最后一个桶迭代结束</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//当前字典结构正在 rehash 且 ht[0] 已经遍历结束</span></span><br><span class="line">                    <span class="comment">//继续遍历 ht[1]</span></span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则表示迭代工作确实全部结束</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据 index 取出节点</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果 entry 不等于 null，尝试遍历它的后续节点</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里，迭代器已经拿到下一个节点了</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">//记录 nextEntry 节点的值</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分逻辑都已经注释上了，整个方法是一个死循环，如果 entry 等于 null，要么是迭代器初次工作，要么是迭代到一个桶的最后节点处了。如果是后者，会进入 if 逻辑中，判断是否整个字典全部迭代结束，如果不是取下一个桶。</p><p>如果字典未处于 rehash 状态，自增 iterators 属性的操作会禁止后续节点操作触发 rehash，如果已经处于 rehash 过程了，也不慌，当前 ht[0] 迭代结束后，再去迭代早于迭代器工作前已经被转移到 ht[1] 的那些节点。因为如果你是安全迭代器的话，iterators 一自增之后，后续节点就不会触发 rehash 迁移节点，所以不会重复迭代数据。</p><p>迭代器迭代结束之后需要释放关闭释放迭代器，redis 中对应方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">            iter-&gt;d-&gt;iterators--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d));</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是安全的迭代器，自减 iterators，不安全迭代器会重新计算指纹并与迭代器最开始工作时计算的指纹比较，并通过 assert 断言判断指纹是否一致，如果不一致则说明你在不安全的迭代器中执行了修改字典结构的方法，程序报错并退出。</p><p>以上就是 redis 字典中基础的两个安全与非安全迭代器用法及其原理，终究是不允许边 rehash 边遍历的，其实 redis 中还有一种高级遍历方式，大家叫它 scan 遍历，它允许边 rehash 边迭代，比较高级，我们后续会分析它的源码，敬请期待！</p><hr><h2 id="第四节-跳跃表"><a href="#第四节-跳跃表" class="headerlink" title="第四节 跳跃表"></a><strong>第四节 跳跃表</strong></h2><p>我们都知道单链表有一个致命的弱点，查找任一节点都至少 O(n) 的时间复杂度，它需要遍历一遍整个链表，那么有没有办法提升链表的搜索效率？</p><p>跳跃表（SkipList）这种数据结构使用空间换时间的策略，通过给链表建立多层索引来加快搜索效率，我们先介绍跳跃表的基本理论，再来看看 redis 中的实现情况。</p><h3 id="一、跳跃表（SkipList）"><a href="#一、跳跃表（SkipList）" class="headerlink" title="一、跳跃表（SkipList）"></a>一、跳跃表（SkipList）</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbffe59b8e16ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>这是一条带哨兵的双端链表，大部分场景下的链表都是这种结构，它的好处是，无论是头插法还是尾插法，插入操作都是常量级别的时间复杂度，删除也是一样。但缺点就是，如果想要查询某个节点，则需要 O(n)。</p><p>那如果我们给链表加一层索引呢？当然前提是最底层的链表是有序的，不然索引也没有意义了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbffe5a1111a7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>让 HEAD 头指针指向最高索引，我抽出来一层索引，这样即便你查找节点 2222 三次比较。</p><p>第一次：与 2019 节点比较，发现大于 2019，往后继续</p><p>第二次：与 2100 节点比较，发现依然大于，往后继续</p><p>第三次：本层索引到头了，指向低层索引的下一个节点，继续比较，找到节点</p><p>而无索引的链表需要四次，效率看起来不是很明显，但是随着链表节点数量增多，索引层级增多，效率差距会很明显。图就不自己画了，取自极客时间王争老师的一张图。</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;&quot; version=&quot;1.1&quot; width=&quot;1142&quot; height=&quot;636&quot;&gt;&lt;/svg" alt="image"></p><p>你看，原本需要 62 次比较操作，通过五层索引，只需要 4 次比较，跳跃表的效率可见一瞥。</p><p>想要知道具体跳跃表与链表差距多少，我们接下来进行它们各个操作的时间复杂度分析对比。</p><p><strong>1、插入节点操作</strong></p><p>双端链表（以下我们简称链表）的原本插入操作是 O(1) 的时间复杂度，但是这里我们讨论的是有序链表，所以插入一个节点至少还要找到它该插入的位置，然后才能执行插入操作，所以链表的插入效率是 O(n)。</p><p>跳跃表（以下我们简称跳表）也依然是需要两个步骤才能完成插入操作，先找到该插入的位置，再进行插入操作。我们设定一个具有 N 个节点的链表，它建有 K 层索引并假设每两个节点间隔就向上分裂一层索引。</p><p>k 层两个节点，k-1 层 4 个节点，k-2 层 8 个节点 … 第一层 n 个节点，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：n</span><br><span class="line"><span class="number">2</span>：<span class="number">1</span>/<span class="number">2</span> * n</span><br><span class="line"><span class="number">3</span>：<span class="number">1</span>/<span class="number">2</span>^<span class="number">2</span> * n</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">k：<span class="number">1</span>/<span class="number">2</span>^(k<span class="number">-1</span>) * n</span><br></pre></td></tr></table></figure><p>1/2^(k-1) <em> n 表示第 k 层节点数，1/2^(k-1) </em> n=2 可以得到，k 等于 logn，也就是说 ，N 个节点构建跳表将需要 logn 层索引，包括自身那层链表层。</p><p>而当我们要搜索某个节点时，需要从最高层索引开始，按照我们的构建方式，某个节点必然位于两个索引节点之间，所以每一层都最多访问三个节点。这一点你可能需要理解理解，因为每一层索引的搜索都是基于上一层索引的，从上一层索引下来，要么是大于（小于）当前的索引节点，但不会大于（小于）其往后两个位置的节点，也就是当前索引节点的上一层后一索引节点，所以它最多访问三个节点。</p><p>有了这一结论，我们向跳表中插入一个元素的时间复杂度就为：O(logn)。这个时间复杂度等于二分查找的时间复杂度，所有有时我们又称跳表是实现了二分查找的链表。</p><p>很明显，插入操作，跳表完胜链表。</p><p><strong>2、修改删除查询</strong></p><p>这三个节点操作其实没什么可比性，修改删除操作，链表等效于跳表。而查询，我们上面也说了，链表至少 O(n)，跳表在 O(logn)。</p><p>除此之外，我们都知道红黑树在每次插入节点后会自旋来进行树的平衡，那么跳表其实也会有这么一个问题，就是不断的插入，会导致底层链表节点疯狂增长，而索引层依然那么多，极端情况所有节点都新增到最后一级索引节点的右边，进而使跳表退化成链表。</p><p>简单一句话来说，就是大量的节点插入之后，而不更新索引的话，跳表将无法一如既往的保证效率。解决办法也很简单，就是每一次节点的插入，触发索引节点的更新，我们具体来看一下更新策略。</p><p>一般跳表会使用一个随机函数，这个随机函数会在跳表新增了一个节点后，根据跳表的目前结构生成一个随机数，这个数值当然要小于最大的索引层值，假定这个值等于 m，那么跳表会生成从 1 到 m 层的索引。所以这个随机函数的选择或者说实现就显得很重要了，关于它我们这里不做讨论，大家可以看看各种跳表的实现中是如何实现这个随机函数的，典型的就是 Java 中 ConcurrentSkipListMap 内部实现的 SkipList 结构，当然还有我们马上要介绍的 redis 中的实现。</p><p>以上就是跳表这种数据结构的基本理论内容，接下来我们看 redis 中的实现情况。</p><h3 id="二、Redis-中的跳跃表"><a href="#二、Redis-中的跳跃表" class="headerlink" title="二、Redis 中的跳跃表"></a>二、Redis 中的跳跃表</h3><p>说在前面的是，redis 自己实现了跳表，但目的是为它的有序集合等高层抽象数据结构提供服务，所以等下我们分析源代码的时候其中必然会涉及到一些看似无用的结构和代码逻辑，但那些也是非常重要的，我们也会提及有序集合相关的内容，但不会拆分细致，重点还是看跳表的实现。</p><p>跳表的数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳表中的每个节点用数据结构 zskiplistNode 表示，head 和 tail 分别指向最底层链表的头尾节点。length 表示当前跳表最底层链表有多少个节点，level 记录当前跳表最高索引层数。</p><p>zskiplistNode 结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>我这里摘取的 redis 源码是 4.0 版本的，以前版本 ele 属性是一个 RedisObject 类型，现在是一个字符串类型，也即表示跳表现在只用于存储字符串数据。</p><p>score 记录当前节点的一个分值，最底层的链表就是按照分值大小有序的串联的，并且我们查询一个节点，一般也会传入该节点的 score 值，毕竟数值类型比较起来方便。</p><p>backward 指针指向前一个节点，为什么是倒着往前，我们待会会说。</p><p>level 是比较关键的一个点，这里面是一个 level 数组，而每个元素又都是一个 zskiplistLevel 类型的结构，zskiplistLevel 类型包括一个 forward 前向指针，一个 span 跨度值，具体是什么意思，我们一点点说。</p><p>跳表理论上在最底层是一条双端链表，然后基于此建立了多层索引节点以实现的，但在实际的代码实现上，这种结构是不好表述的，所以你要打破既有的惯性思维，然后才能好理解 redis 中的实现。实际上正如我们上述介绍的 zskiplistNode 结构一样，<strong>每个节点除了存储节点自身的数据外，还通过 level 数组保存了该节点在整个跳表各个索引层的节点引用</strong>，具体结构就是这样的：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;216&quot; height=&quot;367&quot;&gt;&lt;/svg" alt="image"></p><p>而整张跳表基本就是这样的结构：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;554&quot;&gt;&lt;/svg" alt="image"></p><p>每一个节点的 backward 指针指向自己前面的一个节点，而每个节点中的 level 数组记录的就是当前节点在跳表的哪些索引层出现，并通过其 forward 指针顺序串联这一层索引的各个节点，0 表示第一层，1 表示第二层，等等以此类推。span 表示的是当前节点与后面一个节点的跨度，我们等下还会在代码里说到，暂时不理解也没关系。</p><p>基本上跳表就是这样一个结构，上面那张图还是很重要的，包括我们等下介绍源码实现，也对你理解有很大帮助的。（毕竟我画了半天。。）</p><p>这里多插一句，与跳表相关结构定义在一起的还有一个有序集合结构，很多人会说 redis 中的有序集合是跳表实现的，这句话不错，但有失偏驳。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    <span class="keyword">dict </span>*<span class="keyword">dict;</span></span><br><span class="line"><span class="keyword"> </span>   zskiplist *zsl<span class="comment">;</span></span><br><span class="line">&#125; zset<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>准确来说，redis 中的有序集合是由我们之前介绍过的字典加上跳表实现的，字典中保存的数据和分数 score 的映射关系，每次插入数据会从字典中查询，如果已经存在了，就不再插入，有序集合中是不允许重复数据。</p><p>下面我们看看 redis 中跳表的相关代码的实现情况。</p><p><strong>1、跳表初始化</strong></p><p>redis 中初始化一个跳表的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    <span class="comment">//分配内存空间</span></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">//默认只有一层索引</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//0 个节点</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1、创建一个 node 节点，这是个哨兵节点</span></span><br><span class="line">    <span class="comment">//2、为 level 数组分配 ZSKIPLIST_MAXLEVEL=32 内存大小</span></span><br><span class="line">    <span class="comment">//3、也即 redis 中支持索引最大 32 层</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//为哨兵节点的 level 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zslCreate 用于初始化一个跳表，比较简单，我也给出了基本的注释，这里不再赘述了，强调一点的是，redis 中实现的跳表最高允许 32 层索引，这么做也是一种性能与内存之间的衡量，过多的索引层必然占用更多的内存空间，32 是一个比较合适值。</p><p><strong>2、插入一个节点</strong></p><p>插入一个节点的代码比较多，也稍微有点复杂，希望你也有耐心和我一起来分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//update数组将用于记录新节点在每一层索引的目标插入位置</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">//rank数组记录目标节点每一层的排名</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">//指向哨兵节点</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//这一段就是遍历每一层索引，找到最后一个小于当前给定score值的节点</span></span><br><span class="line">    <span class="comment">//从高层索引向底层索引遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//rank记录的是节点的排名，正常情况下给它初始值等于上一层目标节点的排名</span></span><br><span class="line">        <span class="comment">//如果当前正在遍历最高层索引，那么这个初始值暂时给0</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//我们说过level结构中，span表示的是与后面一个节点的跨度</span></span><br><span class="line">            <span class="comment">//rank[i]最终会得到我们要找的目标节点的排名，也就是它前面有多少个节点</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            <span class="comment">//挪动指针</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此，update数组中已经记录好，每一层最后一个小于给定score值的节点</span></span><br><span class="line">    <span class="comment">//我们的新节点只需要插在他们后即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//random算法获取一个平衡跳表的level值，标志着我们的新节点将要在哪些索引出现</span></span><br><span class="line">    <span class="comment">//具体算法这里不做分析，你也可以私下找我讨论</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">//如果产生值大于当前跳表最高索引</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="comment">//为高出来的索引层赋初始值，update[i]指向哨兵节点</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据score和ele创建节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="comment">//每一索引层得进行新节点插入，建议对照我之前给出的跳表示意图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">//断开指针，插入新节点</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rank[0]等于新节点再最底层链表的排名，就是它前面有多少个节点</span></span><br><span class="line">        <span class="comment">//update[i]-&gt;level[i].span记录的是目标节点与后一个索引节点之间的跨度，即跨越了多少个节点</span></span><br><span class="line">        <span class="comment">//得到新插入节点与后一个索引节点之间的跨度</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        <span class="comment">//修改目标节点的span值</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果上面产生的平衡level大于跳表最高使用索引，我们上面说会为高出部分做初始化</span></span><br><span class="line">    <span class="comment">//这里是自增他们的span值，因为新插入了一个节点，跨度自然要增加</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改 backward 指针与 tail 指针</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个方法我都已经给出了注释，具体的不再细说，欢迎你与我交流讨论，整体的逻辑分为三个步骤。</p><ol><li>从最高索引层开始遍历，根据 score 找到它的前驱节点，用 update 数组进行保存</li><li>每一层得进行节点的插入，并计算更新 span 值</li><li>修改 backward 指针与 tail 指针</li></ol><p>删除节点也是类似的，首先需要根据 score 值找到目标节点，然后断开前后节点的连接，完成节点删除。</p><p><strong>3、特殊的查询操作</strong></p><p>因为 redis 的跳表实现中，增设了 span 这个跨度字段，它记录了与当前节点与后一个节点之间的跨度，所以就具有以下一些查询方法。</p><p><strong>a、zslGetRank</strong></p><p>返回包含给定成员和分值的节点在跳跃表中的排位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，这个方法的核心代码其实就是我们插入节点方法的一个部分，通过累计 span 得到目标节点的一个排名值。</p><p><strong>b、zslGetElementByRank</strong></p><p>通过给定排名查询元素。这个方法就更简单了。</p><p><strong>c、zslIsInRange</strong></p><p>给定一个分值范围（range）， 比如 0 到 10， 如果给定的分值范围包含在跳跃表的分值范围之内， 那么返回 1 ，否则返回 0 。</p><p><strong>d、zslFirstInRange</strong></p><p>给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点。</p><p><strong>e、zslDeleteRangeByScore</strong></p><p>给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点。</p><p><strong>f、zslDeleteRangeByRank</strong></p><p>给定一个排名范围， 删除跳跃表中所有在这个范围之内的节点。</p><p>其实，后面列出来的那些根据排名，甚至一个范围查询删除节点的方法，都仰仗的是 span 这个字段，这也是为什么 insert 方法中需要通过那么复杂的计算逻辑对 span 字段进行计算的一个原因。</p><p>总结一下，跳表是为有序集合服务的，通过多层索引把链表的搜索效率提升到 O(logn)级别，但修改删除依然是 O(1)，是一个较为优秀的数据结构，而 redis 中的实现把每个节点实现成类似楼房一样的结构，也即我们的索引层，非常的巧妙。</p><hr><h2 id="第五节-整数集合"><a href="#第五节-整数集合" class="headerlink" title="第五节 整数集合"></a><strong>第五节 整数集合</strong></h2><p>当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它的一个优点就是可以节省很多内存，虽然字典结构的效率很高，但是它的实现结构相对复杂并且会分配较多的内存空间。</p><p>而我们的整数集合（intset）可以做到使用较少的内存空间却达到和字典一样效率的实现，但也是前提的，集合中只能包含整型数据并且数量不能太多。整数集合最多能存多少个元素在 redis 中也是有体现的。</p><blockquote><p>OBJ_SET_MAX_INTSET_ENTRIES 512</p></blockquote><p>也就是超过 512 个元素，或者向集合中添加了字符串或其他数据结构，redis 会将整数集合向字典结构进行转换。</p><h3 id="一、基本的数据结构"><a href="#一、基本的数据结构" class="headerlink" title="一、基本的数据结构"></a>一、基本的数据结构</h3><p>intset 的结构定义很简单，有以下成员构成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents [];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>encoding 记录当前 intset 使用编码，有三个取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure><p>length 记录整数集合中目前存储了多少个元素，contents 记录我们实际的数据集合，虽然我们看到结构体中给数组元素的类型定死成 int8_t，但实际上这个 int8_t 定义的毫无意义，因为这里的处理方式非常规的数组操作，content 字段虽然被定义成指向一个 int8_t 类型数据的指针，但实际上 redis 无论是读取数组元素还是新增元素进去都依赖 encoding 和 length 两个字段直接操作的内存。</p><p>基本数据结构还是非常的简单的，下面我们来看看它的一些核心方法。</p><h3 id="二、核心-API-实现"><a href="#二、核心-API-实现" class="headerlink" title="二、核心 API 实现"></a>二、核心 API 实现</h3><p><strong>1、初始化一个 intset</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，默认的 inset 配置是使用 INTSET_ENC_INT16 作为数据存储大小，并且不会为 content 数组初始化。常规的数组需要先预先确定数组长度，然后分配内存，继而通过 contents[x] 可以访问数组中任一元素。</p><p>但是，inset 这里是非常规式操作数组，encoding 字段定义了数组中每个元素实际类型，lenth 字段定义了数组中实际的元素个数，那么 contents[x] 是失效的，这种方式只会按照 int8_t 进行内存偏移，这种方式是拿不到正确的数据的，所以 redis 中通过 memcpy 按照 encoding 字段的值暴力直接偏移地址操作内存读取数据。</p><p>所以，这也是为什么 intset 初始化时不初始化 content 数组的原因所在，因为没有必要。而每当新增一个元素的时候都会去动态扩容原数组的长度以盛放下新插入进来的元素，扩容不会扩容很多，刚好一个新元素所占用的内存即可。具体的细节，我们接着看。</p><p><strong>2、添加新元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算得到新插入的元素的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果大于 intset 目前存储元素的编码大小</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">//触发 intset 升级</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//二分搜索当前元素，如果元素已经存在会直接返回</span></span><br><span class="line">        <span class="comment">//如果没找到元素，pos 的值就是该元素的位置索引</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//resize 集合，扩容一个元素的内存空间</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//移动 pos 后面的元素，以插入我们的新元素</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此，我们应该知道为什么 intset 内的数据是有序且无重复的了，二分查找 O(logN)，但是 intset 插入一个元素却不是 O(logN)，因为有些情况会触发升级操作，或者极端情况下，会移动所有元素，时间复杂度达到 O(N)。</p><p><strong>3、升级</strong></p><p>我们先看示意图的变化，然后再分析源码，假设原 intset 使用 16 位的编码存储数据，先来了一个 32 位的数据，触发了我们的编码升级。</p><p>原 intset 结构如下：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;472&quot; height=&quot;187&quot;&gt;&lt;/svg" alt="image"></p><p>新 intset 结构会扩容成这样：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;537&quot; height=&quot;173&quot;&gt;&lt;/svg" alt="image"></p><p>虽然数据占用的内存已经分配好了，但是还需要做的是迁移每个元素占用的比特位。 做法是这样的，假设我们的新元素是 int_32 类型的数值 65536，那么首先我们会将这个 65536 放到[128-159]比特位区间，然后将 78 放到[96-127]比特位区间，并向前以此类推，最后我们会得到升级完成之后 intset。</p><p>下面我们看 redis 中代码的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//intset目前的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="comment">//intset即将扩展到的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据新的元素内存大小重新分配 intset 内存大小</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这个地方我先标记一下 @1，下面详细分析</span></span><br><span class="line">    <span class="comment">//总体上你可以理解，就是我们上图画的那样，从原集合的最后一个元素</span></span><br><span class="line">    <span class="comment">//开始扩大它占用的比特位</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新元素放进 intset 中</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别的不再解释，我重点解释一下我做标记的 @1，这个循环其实是这个方法的核心点，它完成了将旧元素扩充比特位这么一个操作。</p><p>首先明确的一点是，升级操作只有两种情况会触发，一种是新插入一个较大的数值，另一种是新插入一个负很大的值，这两种情况都会导致类型不够存储，需要扩大数据位。</p><p>_intsetGetEncoded 这个方法可以根据给定了 length，也就是元素在数组中的下标取出旧数组中对应的元素，很显然，这里是从后往前倒着来的。</p><p>因为我们的 intsetResize 方法已经完成了扩容内存的操作，也就是说新元素的内存已经分配完毕，那么 _intsetSet 方法就会将 _intsetGetEncoded 取出的元素重新的向数组中赋值。循环结束时，就是所有元素重新归位的时候，最后再将新元素赋值进入数组最后的位置。</p><p>但其实细心的同学会发现，_intsetSet 方法在传下标索引的时候实际传的是 length+prepend，这其实就是我们说，如果 value 是小于零的，length+prepend 最终会导致所有的旧元素往后挪了一个偏移量，然后新的元素会被赋值的索引为零的位置。也就是说，如果新插入的数值是负数，它会被头插进数组的第一个位置。</p><p>核心的几个 API 我们都已经介绍了，其他的一些 API 你可以自行参阅源码，相信对你不难。</p><p>总结一下，整数集合(intset)使用了非常简洁的数据结构，可以更少的占用内存存储一些整数，但终究是基于数组的，也就避免不了不能存储大量数据的缺点。总体来说，插入一个元素，最好情况 O(logN)，最坏的情况是 O(N)，摊还时间复杂度为 O(N)，查找一个元素，根据索引下标时间复杂度在 O(1)。当 intset 中的元素超过 512 个，或者向其中添加了字符串，redis 会将 intset 转换成字典。</p><hr><h2 id="第六节-压缩列表"><a href="#第六节-压缩列表" class="headerlink" title="第六节 压缩列表"></a><strong>第六节 压缩列表</strong></h2><p>上一篇我们介绍了 redis 中的整数集合这种数据结构的实现，也谈到了，引入这种数据结构的一个很大的原因就是，在某些仅有少量整数元素的集合场景，通过整数集合既可以达到字典的效率，也能使用远少于字典的内存达到同样的效果。</p><p>我们本篇介绍的压缩列表，相信你从他的名字里应该也能看出来，又是一个为了节约内存而设计的数据结构，它的数据结构相对于整数集合来说会复杂了很多，但是整数集合只能允许存储少量的整型数据，而我们的压缩列表可以允许存储少量的整型数据或字符串。</p><p>这是他们之间的一个区别，下面我们来看看这种数据结构。</p><h3 id="一、基本的结构定义"><a href="#一、基本的结构定义" class="headerlink" title="一、基本的结构定义"></a>一、基本的结构定义</h3><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a764ad1fcd3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><ul><li>ZIPLIST_BYTES：四个字节，记录了整个压缩列表总共占用了多少字节数</li><li>ZIPLIST_TAIL_OFFSET：四个字节，记录了整个压缩列表第一个节点到最后一个节点跨越了多少个字节，通故这个字段可以迅速定位到列表最后一个节点位置</li><li>ZIPLIST_LENGTH：两个字节，记录了整个压缩列表中总共包含几个 zlentry 节点</li><li>zlentry：非固定字节，记录的是单个节点，这是一个复合结构，我们等下再说</li><li>0xFF：一个字节，十进制的值为 255，标志压缩列表的结尾</li></ul><p>其中，zlentry 在 redis 中确实有着这样的结构体定义，但实际上这个结构定义了一堆类似于 length 这样的字段，记录前一个节点和自身节点占用的字节数等等信息，用处不多，而我们更倾向于使用这样的逻辑结构来描述 zlentry 节点。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a764b42d99f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>这种结构在 redis 中是没有具体结构体定义的，请知悉，网上的很多博客文章都直接描述 zlentry 节点是这样的一种结构，其实是不准确的。</p><p>简单解释一下这三个字段的含义：</p><ul><li>previous_entry_length：每个节点会使用一个或者五个字节来描述前一个节点占用的总字节数，如果前一个节点占用的总字节数小于 254，那么就用一个字节存储，反之如果前一个节点占用的总字节数超过了 254，那么一个字节就不够存储了，这里会用五个字节存储并将第一个字节的值存储为固定值 254 用于区分。</li><li>encoding：压缩列表可以存储 16位、32位、64位的整数以及字符串，encoding 就是用来区分后面的 content 字段中存储于的到底是哪种内容，分别占多少字节，这个我们等下细说。</li><li>content：没什么特别的，存储的就是具体的二进制内容，整数或者字符串。</li></ul><p>下面我们细说一个 encoding 具体是怎么存储的。</p><p>主要分为两种，一种是字符串的存储格式：</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content类型</th></tr></thead><tbody><tr><td>00xxxxxx</td><td>一个字节</td><td>长度小于 63 的字符串</td></tr><tr><td>01xxxxxx xxxxxxxx</td><td>两个字节</td><td>长度小于 16383 的字符串</td></tr><tr><td>10xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</td><td>五个字节</td><td>长度小于 4294967295 的字符串</td></tr></tbody></table><p>content 的具体长度，由编码除去高两位剩余的二进制位表示。</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content类型</th></tr></thead><tbody><tr><td>11000000</td><td>一个字节</td><td>int16_t 类型的整数</td></tr><tr><td>11010000</td><td>一个字节</td><td>int32_t 类型的整数</td></tr><tr><td>11100000</td><td>一个字节</td><td>int64_t 类型的整数</td></tr><tr><td>11110000</td><td>一个字节</td><td>24 位有符号整数</td></tr><tr><td>11111110</td><td>一个字节</td><td>8 位有符号整数</td></tr></tbody></table><p>注意，整型数据的编码是固定 11 开头的八位二进制，而字符串类型的编码都是非固定的，因为它还需要通过后面的二进制位得到字符串的长度，稍有区别。</p><p>这就是压缩列表的基本的结构定义情况，下面我们通过节点的增删改查方法源码实现来看看 redis 中具体的实现情况。</p><h3 id="二、redis-的具体源码实现"><a href="#二、redis-的具体源码实现" class="headerlink" title="二、redis 的具体源码实现"></a>二、redis 的具体源码实现</h3><p><strong>1、ziplistNew</strong></p><p>我们先来看看压缩列表初始化的方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//bytes=2*4+2</span></span><br><span class="line">    <span class="comment">//分配压缩列表结构所需要的字节数</span></span><br><span class="line">    <span class="comment">//ZIPLIST_BYTES + ZIPLIST_TAIL_OFFSET + ZIPLIST_LENGTH</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_BYTES 字段</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_TAIL_OFFSET</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_LENGTH 字段</span></span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为压缩列表最后一个字节赋值 255</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、ziplistPush</strong></p><p>接着我们看新增节点的源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s</span></span></span><br><span class="line"><span class="function"><span class="params">        ,<span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">//找到待插入的位置，头部或者尾部</span></span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下 ziplistPush 的几个入参的含义。</p><p>zl 指向一个压缩列表的首地址，s 指向一个字符串首地址），slen 指向字符串的长度（如果节点存储的值是整型，存储的就是整型值），where 指明新节点的插入方式，头插亦或尾插。</p><p>ziplistPush 方法的核心是 __ziplistInsert：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; </span><br><span class="line">    zlentry tail;</span><br><span class="line">    <span class="comment">//prevlensize 存储前一个节点长度，本节点使用了几个字节 1 or 5</span></span><br><span class="line">    <span class="comment">//prelen  存储前一个节点实际占用了几个字节</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">//s 指针指向一个整数，尝试进行一个转换并得到存储这个整数占用了几个字节</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//s 指针指向一个字符串（字符数组），slen 就是他占用的字节数</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前节点存储数据占用 reqlen 个字节，加上存储前一个节点长度占用的字节数</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">//encoding 字段存储实际占用字节数</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line">    <span class="comment">//至此，reqlen 保存了存储当前节点数据占用字节数和 encoding 编码占用的字节数总和</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前节点占用的总字节减去存储前一个节点字段占用的字节</span></span><br><span class="line">    <span class="comment">//记录的是这一个节点的插入会引起下一个节点占用字节的变化量</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容有可能导致 zl 的起始位置偏移，故记录 p 与 zl 首地址的相对偏差数，事后还原 p 指针指向</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line">        <span class="comment">//把当前节点占用的字节数存储到下一个节点的头部字段</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新 tail_offset 字段，让他保存从头节点到尾节点之间的距离</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否触发连锁更新</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将节点写入指定位置</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体细节我不再赘述，总结一下整个插入节点的步骤。</p><ol><li>计算并得到前一个节点的总长度，并判断得到当前待插入节点保存前一个节点长度的 previous_entry_length 占用字节数</li><li>根据传入的 s 和 slen，计算并保存 encoding 字段内容</li><li>构建节点并将数据写入节点添加到压缩列表中</li></ol><p><em>ps：重点要去理解压缩列表节点的数据结构定义，previous_entry_length、encoding、content 字段，这样才能比较容易理解节点新增操作的实现。</em></p><h3 id="三、连锁更新"><a href="#三、连锁更新" class="headerlink" title="三、连锁更新"></a>三、连锁更新</h3><p>谈到 redis 的压缩列表，就必然会谈到他的连锁更新，我们先引一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a76497a20d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>假设原本 entry1 节点占用字节数为 211（小于 254），那么 entry2 的 previous_entry_length 会使用一个字节存储 211，现在我们新插入一个节点 NEWEntry，这个节点比较大，占用了 512 个字节。</p><p>那么，我们知道，NEWEntry 节点插入后，entry2 的 previous_entry_length 存储不了 512，那么 redis 就会重分配内存，增加 entry2 的内存分配，并分配给 previous_entry_length 五个字节存储 NEWEntry 节点长度。</p><p>看似没什么问题，但是如果极端情况下，entry2 扩容四个字节后，导致自身占用字节数超过 254，就会又触发后一个节点的内存占用空间扩大，非常极端情况下，会导致所有的节点都扩容，这就是连锁更新，一次更新导致大量甚至全部节点都更新内存的分配。</p><p>如果连锁更新发生的概率很高的话，压缩列表无疑就会是一个低效的数据结构，但实际上连锁更新发生的条件是非常苛刻的，其一是需要大量节点长度小于 254 连续串联连接，其二是我们更新的节点位置恰好也导致后一个节点内存扩充更新。</p><p>基于这两点，且少量的连锁更新对性能是影响不大的，所以这里的连锁更新对压缩列表的性能是没有多大的影响的，可以忽略，但需要知晓。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><blockquote><p><a href="https://juejin.im/post/5d7dac02518825297023fb35" target="_blank" rel="noopener">Redis 的底层数据结构（SDS和链表）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5d872b41f265da03ec2ea091" target="_blank" rel="noopener">Redis 的底层数据结构（字典）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5da1ca58e51d4577fc7b1c5a" target="_blank" rel="noopener">Redis 的底层数据结构（跳跃表）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5dac52a96fb9a04e2d36c9ec" target="_blank" rel="noopener">Redis 的底层数据结构（整数集合）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5dcbf185f265da3072427647" target="_blank" rel="noopener">Redis 的底层数据结构（压缩列表）</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理Redis中的几种常见的底层数据结构，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度</title>
    <link href="http://linyishui.top/2020061801.html"/>
    <id>http://linyishui.top/2020061801.html</id>
    <published>2020-06-18T11:03:47.000Z</published>
    <updated>2020-08-04T06:33:02.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p><strong>时间复杂度</strong>是一个函数，用于描述算法的运行时间。常用大O符号表示，如 <code>O(n)</code> 。时间复杂度可以被称为是<strong>渐进的</strong>，即考察输入值趋近于无穷时的情况，如一个算法对于任意数量n的输入，需要 5n^3^ + 3n 的时间运行完毕，则其渐进时间复杂度为 O(n^3^) 。</p><p>即使相同数目大小的不同输入值仍可能导致算法的运行时间不同，所以<strong>通常使用算法的最坏情况复杂度</strong>，即 <code>T(n)</code> 。</p><h3 id="1-1-常见时间复杂度"><a href="#1-1-常见时间复杂度" class="headerlink" title="1.1 常见时间复杂度"></a><strong>1.1 常见时间复杂度</strong></h3><ul><li>O(n^3^)：矩阵乘法的基础实现。</li><li>O(n^2^)：冒泡排序、插入排序。</li><li>O(loglogn)：有界优先队列的单个操作。</li><li>O(nlogn)：最快的比较排序。</li><li>O(logn)：二分搜索。</li><li>O(n)：无序数组的搜索。</li><li>O(1)：奇偶判断。</li></ul><p>对于时间复杂度中的对数表达式，一般默认底数为2（计算机偏爱2?），所以 logn 即 log~2~n。</p><h2 id="第二节-计算时间复杂度"><a href="#第二节-计算时间复杂度" class="headerlink" title="第二节 计算时间复杂度"></a><strong>第二节 计算时间复杂度</strong></h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a><strong>2.1 步骤</strong></h3><ol><li>找出算法中的基本语句。<ul><li>基本语句即执行次数最多的语句，通常指最内层循环。</li></ul></li><li>计算基本语句的执行次数的数量级。<ul><li>可忽略所有的低次幂和高次幂的系数。</li></ul></li><li>用大O记号表示算法的时间性能。</li></ol><h3 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2 实例"></a><strong>2.2 实例</strong></h3><h4 id="（1）单层和双层循环"><a href="#（1）单层和双层循环" class="headerlink" title="（1）单层和双层循环"></a><strong>（1）单层和双层循环</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">       x++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">       x++;</span><br></pre></td></tr></table></figure><p>两种基本语句都是最内层循环 <code>x++;</code> 。</p><p>单层循环执行了 n 次，双层循环执行了 n^2^ 次。</p><p>所以二者的时间复杂度分别为 O(n) 和 O(N^2^) 。</p><h4 id="（2）循环乘2"><a href="#（2）循环乘2" class="headerlink" title="（2）循环乘2"></a><strong>（2）循环乘2</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">       i = i * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>基本语句 <code>i = i * 2;</code> ，设y为其执行次数，则 2^y^ &lt;= n ，即 y &lt;= log~2~n 。</p><p>所以 T(n) = O(log~2~n) 。</p><h4 id="（3）冒泡排序"><a href="#（3）冒泡排序" class="headerlink" title="（3）冒泡排序"></a><strong>（3）冒泡排序</strong></h4><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="comment">// 比较两个元素大小，若前大于后则交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句即比较操作 <code>arr[j] &gt; arr[j + 1]</code> ，其运行次数为 (n - 1) + (n - 2) + … + 2 + 1  = n (n - 1) / 2 = n^2^ / 2 。所以时间复杂度为 O(n^2^) 。</p><h4 id="（4）选择排序"><a href="#（4）选择排序" class="headerlink" title="（4）选择排序"></a><strong>（4）选择排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;<span class="comment">//将数组a按升序排序</span></span><br><span class="line">    <span class="keyword">int</span> N = a.length;<span class="comment">//记录数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;<span class="comment">//将a[i]与a[i+1...N]最小元素交换</span></span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//循环遍历找到当前最小元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; N;j++)</span><br><span class="line">            <span class="keyword">if</span>(less(a[j],a[min])) min = j;</span><br><span class="line">        <span class="comment">//将第i小元素交换至位置i</span></span><br><span class="line">        exch(a,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>min = j;</code> ，其运行次数为 (n - 1) + (n - 2) + … + 2 + 1 = n (n - 1) / 2 = n^2^ / 2 。</p><p>所以时间复杂度为 O(n^2^) 。</p><h4 id="（5）插入排序"><a href="#（5）插入排序" class="headerlink" title="（5）插入排序"></a><strong>（5）插入排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)&#123;</span><br><span class="line">    <span class="comment">// 第二层游标j从游标i开始，逆向遍历，不断和比其小的元素交换位置，直到移动到0位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span> &amp;&amp; less(a[j],a[j-<span class="number">1</span>]);j--)</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>less(a[j],a[j-1])</code> ，其运行次数为 1 + 2 + … + (n - 2) +  (n - 1) = n (n - 1) / 2 = n^2^ / 2 。</p><p>所以时间复杂度为 O(n^2^) 。</p><h4 id="（6）希尔排序"><a href="#（6）希尔排序" class="headerlink" title="（6）希尔排序"></a><strong>（6）希尔排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> H = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 根据元素数目初始化H：1、4、13、40、121...</span></span><br><span class="line">    <span class="keyword">while</span> (H &lt; N/<span class="number">3</span>)</span><br><span class="line">        H = <span class="number">3</span>*H + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//同插入排序，但游标不是相邻移动，而是间隔H，将a[i]插入到a[i-H],a[i-2H]...之中</span></span><br><span class="line">    <span class="keyword">while</span> (H &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 游标i从H开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = H;i &lt; N;i++)&#123;</span><br><span class="line">        <span class="comment">// 游标j仍从游标i开始，逆向隔H遍历，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;=H &amp;&amp; less(a[j],a[j-H]);j-=H)<span class="comment">//</span></span><br><span class="line">                exch(a,j,j-H);</span><br><span class="line">        &#125;</span><br><span class="line">        H = H/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>less(a[j],a[j-H])</code> ，希尔排序的性能论证十分复杂，目前的结论是其运行时间达不到平方级别，运行次数本人目前浅陋的数学水平无法归纳，根据书本和互联网获得的答案是<strong>平均时间复杂度为 O(nlogn) </strong>，<strong>最坏情况大概与 N^(3/2)^ 成正比</strong>，相比插入排序一点微小的改变就突破了平方的屏障，这正是算法设计的目标。</p><p>所以时间复杂度为 O(nlogn) 。</p><h4 id="（7）归并排序"><a href="#（7）归并排序" class="headerlink" title="（7）归并排序"></a><strong>（7）归并排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> <span class="keyword">extends</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] a = RandomUtil.getRandomIndex(<span class="number">10000</span>);</span><br><span class="line">        Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(stopwatch.elapseTime());</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原地归并的抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将a[lo,mid]与a[mid+1,hi]归并，两个数组是有序的</span></span><br><span class="line">        <span class="keyword">int</span> i = lo,j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先将所有元素复制到aux[]中，再归并到a[]中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo;k &lt;= hi;k++)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        <span class="comment">//用i,j指针分别游离于两数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]; <span class="comment">//左边下标已结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];<span class="comment">//右边下标已结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j],aux[i])) a[k] = aux[j++];<span class="comment">//两数组的指针比较当前大小，前者较小</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自顶向下的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">//归并所需的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];<span class="comment">//一次性分配空间</span></span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组a排序，递归排序，sort的作用为以正确的顺序调用merge方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);      <span class="comment">// 将左半边排序</span></span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);    <span class="comment">// 将右半边排序</span></span><br><span class="line">        merge(a,lo,mid,hi);  <span class="comment">// 归并结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBottomUp</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 进行lgN次两两归并</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N ;sz = sz + sz) <span class="comment">//sz-子数组大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz;lo+=sz+sz) <span class="comment">//子数组索引</span></span><br><span class="line">                merge(a,lo,lo+sz-<span class="number">1</span>,Math.min(lo+sz+sz-<span class="number">1</span>,N-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于长度为N的任意数组，自顶向下的归并排序需要 <code>1/2NlgN</code> 至 <code>NlgN</code> 次比较，并且最多需要访问数组 <code>6NlgN</code> 次</strong>。</p><p><strong>归并排序所需时间与 <code>NlgN</code> 成正比</strong>，这相比前几个排序要快很多（指数级），只需要比遍历整个数组多个对数因子的时间就可以将一个庞大的数组排序。</p><p><strong>对于长度为N的任意数组，自底向上的归并排序需要 <code>1/2NlgN</code> 至 <code>NlgN</code> 次比较，最多访问数组 <code>6NlgN</code> 次</strong>。</p><p>所以时间复杂度为 O(nlogn) 。</p><h4 id="（8）快速排序"><a href="#（8）快速排序" class="headerlink" title="（8）快速排序"></a><strong>（8）快速排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//消除对输入的依赖，需要在这里把元素随机分布一下</span></span><br><span class="line">        StdRandom.shuffle(a);</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当左右游标相等，表示已对最小数组排序，结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//将左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切分数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo,j = hi + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        Comparable v = a[lo];  </span><br><span class="line">        <span class="comment">//扫描左右，检查扫描是否结束并交换元素，遍历结束后数组被切分为两部分，一边小于切分元素，一边大于切分元素</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//循环遍历直到找到大于v元素或游标到底</span></span><br><span class="line">            <span class="keyword">while</span>(less(a[++i],v))</span><br><span class="line">                <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//循环遍历直到找到小于v元素或游标到头</span></span><br><span class="line">            <span class="keyword">while</span>(less(v,a[--j]))</span><br><span class="line">                <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若游标交叉则表示以遍历所有元素，结束</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换两边元素</span></span><br><span class="line">            exch(a,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将v=a[j]放入正确位置</span></span><br><span class="line">        exch(a,lo,j); </span><br><span class="line">        <span class="comment">//a[lo...j-1] &lt;= a[j] &lt;= a[j+1...hi] 达成</span></span><br><span class="line">        <span class="keyword">return</span> j;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以时间复杂度为 O(nlogn) 。</p><p>T(n) = O(n^2^)</p><blockquote><p>命题：<strong>将长度为N的无重复元素数组排序，快速排序平均需要 ~ <code>2NlnN</code> 次比较，以及 <code>1/6</code> 的交换</strong>。</p><p>证明：<code>CN</code> 为将N个不同元素排序平均所需的比较次数。很明显 <code>C0</code> = <code>C1</code> = 0，对于 <code>N &gt; 1</code> ，由递归程序可以得到以下归纳关系：</p><p> CN = N + 1 + (C0 + C1 + … + C(N-2) + C(N-1)) / N + (C(N-1) + C(N-2) + … + C0) / N</p><p>第一项是切分的成本（总是N+1），第二项是将左子数组排序的平均成本，第三项是将右子数组（长度和左子数组相同）排序的平均成本。将等式左右两边乘以N并整理各项得到：</p><p> NCN = N (N + 1) + 2(C0 + C1 + … + C(N-2) + C(N-1))</p><p>将该等式减去 <code>N - 1</code> 时的相同等式可得：</p><p> NCN - (N - 1)C(N - 1) = 2N + 2C(N - 1)</p><p>整理等式并将两边除以 <code>N(N + 1)</code> 可得：</p><p> CN / (N + 1) = C(N - 1) / N + 2 / (N + 1)</p><p>归纳法推导可得：</p><p> CN ~ 2(N + 1)(1/3 + 1/4 + … + 1 / (N + 1))</p><p>括号内的量是曲线 <code>2 / x</code> 下从3到N的离散近似面积加一，积分得到 <code>CN ~ 2NlnN</code> 。注意 <code>2NlnN</code> ≈ <code>1.39NlgN</code> ，也就是说平均比较次数只比最好情况多39%。</p></blockquote><blockquote><p>命题：<strong>快速排序最多需要 <code>N^2/2</code> 次比较，但随机打乱数组能够预防这种情况。</strong></p><p>证明：在每次切分后两个子数组之一总是空的情况下，比较次数为：</p><p> N + (N - 1) + … + (N - 2) + 2 + 1 = (N + 1) N / 2</p><p>这说明了算法所需时间为平方级别，所需空间是线性的，而这对于大数组来说是不可接受的。比较次数的标准差为0.65N，因此随着N的增大，运行时间会趋于平均数，且不可能与平均数偏差太大。</p></blockquote><h4 id="（9）堆排序"><a href="#（9）堆排序" class="headerlink" title="（9）堆排序"></a><strong>（9）堆排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Set</span> <span class="keyword">extends</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparable[] sort(Comparable[] c)&#123;</span><br><span class="line">        Comparable[] a = <span class="keyword">new</span> Comparable[c.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> N = c.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">            a[i+<span class="number">1</span>] = c[i];</span><br><span class="line">        <span class="comment">// for循环构造堆，sink方法将a从1到N排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(a,k,N);</span><br><span class="line">        show(a);</span><br><span class="line">        <span class="comment">// while循环将最大元素a[1]和a[N]交换，并修复堆</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            exch(a,<span class="number">1</span>,N--);</span><br><span class="line">            sink(a,<span class="number">1</span>,N);</span><br><span class="line">            show(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;<span class="comment">//循环判断条件，k&gt;1,父结点的值比当前小</span></span><br><span class="line">            <span class="comment">//交换当前结点和父结点的值，以及当前游标所指下标</span></span><br><span class="line">            exch(a,k/<span class="number">2</span>,k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;<span class="comment">//循环判断条件，当前游标所指有子结点存在</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">//当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; N &amp;&amp; less(a[j],a[j+<span class="number">1</span>]))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//如果当前结点比子结点大就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(!less(a[k],a[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换，更新游标</span></span><br><span class="line">            exch(a,k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Integer[] a = RandomUtil.getRandomIndex(10000);</span></span><br><span class="line">        Comparable[] a = &#123;<span class="string">'S'</span>,<span class="string">'O'</span>,<span class="string">'R'</span>,<span class="string">'T'</span>,<span class="string">'E'</span>,<span class="string">'X'</span>,<span class="string">'A'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>,<span class="string">'L'</span>,<span class="string">'E'</span>&#125;;</span><br><span class="line">        Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        a = sort(a);</span><br><span class="line">        System.out.println(stopwatch.elapseTime());</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将N个元素排序，堆排序只需要少于 <code>2NlgN + 2N</code> 次比较，以及一半次数的交换</strong>。</p><p>所以时间复杂度为 O(nlogn) 。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">时间复杂度- 维基百科</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/21387264" target="_blank" rel="noopener">如何理解算法时间复杂度的表示法，例如 O(n²)、O(n)、O(1)、O(nlogn) 等</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BlockingQueue（未完成）</title>
    <link href="http://linyishui.top/2020061401.html"/>
    <id>http://linyishui.top/2020061401.html</id>
    <published>2020-06-14T13:41:26.000Z</published>
    <updated>2020-07-26T14:53:33.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><strong>BlockingQueue</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>并发包 <code>java.util.concurrent</code> 提供了阻塞队列系列，顶层接口 <code>BlockingQueue</code> ，相关实现类：</p><ul><li>ArrayBlockingQueue：基于数组的有界阻塞队列。</li><li>LinkedBlockingQueue：基于链表的阻塞队列。</li><li>DelayQueue：延迟队列。</li><li>SynchronousQueue：同步队列。</li><li>PriorityBlockingQueue：优先阻塞队列。</li></ul>]]></content>
    
    <summary type="html">
    
      简单整理Java并发包中阻塞队列BlockingQueue相关内容，包括：概述，API，ArrayBlockingQueue，LinkedBlockingQueue等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList的实现原理</title>
    <link href="http://linyishui.top/2020060501.html"/>
    <id>http://linyishui.top/2020060501.html</id>
    <published>2020-06-05T14:27:02.000Z</published>
    <updated>2020-07-23T09:09:32.847Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><strong>CopyOnWriteArrayList</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-为什么需要CopyOnWriteArrayList？"><a href="#1-1-为什么需要CopyOnWriteArrayList？" class="headerlink" title="1.1 为什么需要CopyOnWriteArrayList？"></a><strong>1.1 为什么需要CopyOnWriteArrayList？</strong></h3><p><strong>多读场景需要高效的并发数组</strong>。</p><p>常用的 <code>ArrayList</code> 不是一个线程安全的集合，基于快速失败机制，多线程操作会抛出 <code>ConcurrentModificationException</code> ，而线程安全的  <code>Vector</code> 又因为低效的设计而被弃用，又或者 <code>Collections.synchronizedList()</code> 来获取一个包装的线程安全类，与前者一样使用 <code>synchronized</code> 来保证的线程安全。</p><p> <code>synchronized</code> 这种独占锁在同一时刻只能有一个线程拥有对象监视器，对于大部分<strong>读多写少的业务场景</strong>并不适用。针对这种场景而设计的读写锁 <code>ReentrantReadWriteLock</code> 是一个合适的选择。</p><p>如果只是在 <code>List</code> 上封装一层读写锁，读数据仍会被其他操作阻塞，所以需要并发包提供的 <code>CopyOnWriteArrayList</code> 。</p><h3 id="1-2-什么是CopyOnWrite？"><a href="#1-2-什么是CopyOnWrite？" class="headerlink" title="1.2 什么是CopyOnWrite？"></a><strong>1.2 什么是CopyOnWrite？</strong></h3><p><code>CopyOnWrite</code>（COW）即<strong>写时复制</strong>，通过延迟更新的策略来实现数据一致性，并且能保证线程间不阻塞。</p><p>通俗的讲就是在向容器添加元素时，并非直接向容器内添加，而是先将当前容器进行Copy，复制出一个新容器，然后向新容器添加元素，完成后再将指向旧容器的引用指向新容器。</p><p>这一过程的优势就是在进行并发的读操作时不用加锁，因为旧容器并不改变，所以<strong>写时复制也是一种读写分离的思想</strong>，通过放弃数据的实时性来达到数据一致性，获得的是提高并发性。</p><h3 id="1-3-写时复制和读写锁的区别？"><a href="#1-3-写时复制和读写锁的区别？" class="headerlink" title="1.3 写时复制和读写锁的区别？"></a><strong>1.3 写时复制和读写锁的区别？</strong></h3><ul><li><p>相同点：两者都是通过读写分离思想实现，都实现了读线程间互不阻塞。</p></li><li><p>不同点：使用读写锁依然会存在线程阻塞等待的情况，而COW则牺牲了数据实时性，保证读线程不会存在等待。</p></li></ul><p>读写锁中，读线程为了实现数据实时性，在写锁被获取时，读线程会等待。而写时复制中虽然写线程最终的修改结果可以被读线程感知，但有一定延迟。</p><h2 id="第二节-实现原理"><a href="#第二节-实现原理" class="headerlink" title="第二节 实现原理"></a><strong>第二节 实现原理</strong></h2><h3 id="2-1-基本结构"><a href="#2-1-基本结构" class="headerlink" title="2.1 基本结构"></a><strong>2.1 基本结构</strong></h3><p>根据其接口实现 <code>RandomAccess</code> 就可得知，其底层为数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过可重入锁 <code>ReentrantLock</code> 来保证线程安全，通过 <code>volatile</code> 修饰底层数组来保证可见性。 </p><h3 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get"></a><strong>2.2 get</strong></h3><p><code>get()</code> 方法源码如下，读操作不需要考虑并发安全，直接通过数组索引获取元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Positional Access Operations</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-add"><a href="#2-3-add" class="headerlink" title="2.3 add"></a><strong>2.3 add</strong></h3><p><code>add()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.首先获取Lock，保证写操作线程安全</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.获取旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 3.通过Arrays.copyOf进行数组浅复制扩容，底层是通过调用System.arraycopy()进行数组的浅拷贝</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 4.将新元素添加到新数组的末尾</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 5.指向新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现核心主要是：</p><ol><li>通过 <code>ReentrantLock</code> 保证同一时刻只有一个写线程在进行数组的复制，否则会导致内存中存在多份复制数组。</li><li><code>volatile</code> 修饰的底层数组，根据 <code>happens-before</code> 规则，写线程对数组引用的修改对读线程是可见的。</li></ol><p><code>add()</code> 还有重载方法，指定位置添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 末尾添加，直接拷贝生成新数组</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非末尾，先构建新数组，再通过System.arraycopy错位复制</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 第一次复制源数组下标0-index的元素</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 第二次复制源数组index-end的元素，错位复制到新数组，此步完成后index元素重复一次</span></span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新元素</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        <span class="comment">// 更新引用</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心就是通过 <code>System.arraycopy()</code> 进行错位复制。</p><h3 id="2-4-set"><a href="#2-4-set" class="headerlink" title="2.4 set"></a><strong>2.4 set</strong></h3><p><code>set()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 先获取旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="comment">// 仍通过浅复制进行替换</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 旧值等价于新值，不需要替换，此处只更新一下引用</span></span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-remove"><a href="#2-5-remove" class="headerlink" title="2.5 remove"></a><strong>2.5 remove</strong></h3><p><code>remove()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).  Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If this list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &#123;<span class="doctag">@code</span> true&#125; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">int</span> index = indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A version of remove(Object) using the strong hint that given</span></span><br><span class="line"><span class="comment"> * recent snapshot contains o at the given index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o, Object[] snapshot, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123;</span><br><span class="line">            <span class="keyword">int</span> prefix = Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span> findIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (current[index] == o)</span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">            index = indexOf(o, current, index, len);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>,</span><br><span class="line">                         newElements, index,</span><br><span class="line">                         len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes from this list all of the elements whose index is between</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="doctag">@code</span> toIndex&#125;, exclusive.</span></span><br><span class="line"><span class="comment"> * Shifts any succeeding elements to the left (reduces their index).</span></span><br><span class="line"><span class="comment"> * This call shortens the list by &#123;<span class="doctag">@code</span> (toIndex - fromIndex)&#125; elements.</span></span><br><span class="line"><span class="comment"> * (If &#123;<span class="doctag">@code</span> toIndex==fromIndex&#125;, this operation has no effect.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex index of first element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex index after last element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if fromIndex or toIndex out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> fromIndex &lt; 0 || toIndex &gt; size() || toIndex &lt; fromIndex&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || toIndex &lt; fromIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">int</span> newlen = len - (toIndex - fromIndex);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - toIndex;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, newlen));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[newlen];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, fromIndex);</span><br><span class="line">            System.arraycopy(elements, toIndex, newElements,</span><br><span class="line">                             fromIndex, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>set()</code> 、<code>add()</code> 等方法一样，<code>remove()</code> 仍通过数组浅复制进行删除操作，主要是错位复制。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><blockquote><p><a href="https://juejin.im/post/5aeeb55f5188256715478c21#heading-4" target="_blank" rel="noopener">并发容器之CopyOnWriteArrayList</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了一下CopyOnWriteArrayList的相关内容，主要内容包括：概述（为什么需要CopyOnWriteArrayList、什么是CopyOnWrite、写时复制和读写锁的区别），实现原理（基本结构、get、add、set、remove）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="list" scheme="http://linyishui.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>迭代器</title>
    <link href="http://linyishui.top/2020060301.html"/>
    <id>http://linyishui.top/2020060301.html</id>
    <published>2020-06-03T14:21:21.000Z</published>
    <updated>2020-07-17T17:25:01.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-迭代器是什么？"><a href="#1-1-迭代器是什么？" class="headerlink" title="1.1 迭代器是什么？"></a><strong>1.1 迭代器是什么？</strong></h3><p><strong>迭代器</strong>（iterator），是确使用户可在容器对象（container，例如<a href="https://zh.wikipedia.org/wiki/鏈表" target="_blank" rel="noopener">链表</a>或<a href="https://zh.wikipedia.org/wiki/陣列" target="_blank" rel="noopener">数组</a>）上遍访的<a href="https://zh.wikipedia.org/wiki/对象_(计算机科学" target="_blank" rel="noopener">对象</a>)，设计人员使用此接口无需关心容器对象的内存分配的实现细节。</p><h3 id="1-2-Java迭代器"><a href="#1-2-Java迭代器" class="headerlink" title="1.2 Java迭代器"></a><strong>1.2 Java迭代器</strong></h3><p><a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a> JDK 1.2 版开始支持迭代器。每一个迭代器提供 <code>next()</code>以及 <code>hasNext()</code>方法，同时也支持 <code>remove()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iter = list.iterator();</span><br><span class="line"><span class="comment">//Iterator&lt;MyType&gt; iter = list.iterator();    in J2SE 5.0</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext())</span><br><span class="line">    System.out.println(iter.next());</span><br></pre></td></tr></table></figure><p>迭代器主要用来帮助集合遍历，使集合类型的遍历行为与被遍历的集合对象分离。</p><p>Java语法糖中的 <code>foreach</code> 就是由迭代器来实现的。</p><h3 id="1-3-快速失败与安全失败"><a href="#1-3-快速失败与安全失败" class="headerlink" title="1.3 快速失败与安全失败"></a><strong>1.3 快速失败与安全失败</strong></h3><p>快速失败（fail-fast）是指迭代器遍历集合对象时发现内容被同时修改，且修改导致了计数器与期待值不同，导致抛出异常 <code>ConcurrentModificationException</code>（迭代器内部有计数器ModCount，每次移动指针前会检查当前值是否是expected，若修改不会使modCount不匹配就不会抛出异常）。</p><p>安全失败（fail-safe）则是指相应集合并不直接在内部访问，而是先拷贝副本，在副本上进行遍历，所以遍历过程中的修改不会影响到读取。</p><p>Java迭代器采用的是快速失败的模式，在一个线程工作时不允许其他线程修改相关内容。</p><hr><h2 id="第二节-源码"><a href="#第二节-源码" class="headerlink" title="第二节 源码"></a><strong>第二节 源码</strong></h2><p><em>本部分代码来自于JDK 1.8。</em></p><h3 id="2-1-Iterable"><a href="#2-1-Iterable" class="headerlink" title="2.1 Iterable"></a><strong>2.1 Iterable</strong></h3><p>Iterable接口定义了 <code>iterator()</code> 返回一个迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口Iterable表示<strong>对象是否可迭代</strong>，集合顶层接口Collection继承了此接口，所以所有集合对象都是可迭代的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Iterator"><a href="#2-2-Iterator" class="headerlink" title="2.2 Iterator"></a><strong>2.2 Iterator</strong></h3><p>迭代器接口Iterator源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 删除最后一个元素，默认实现抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意 <code>remove()</code> 使用时有一些陷阱，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List list = ...;  </span><br><span class="line"><span class="keyword">for</span>(Iterator iter = list.iterator();iter.hasNext();) &#123;  </span><br><span class="line">    Object obj = iter.next();  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">if</span>(XXX) &#123;  </span><br><span class="line">        list.remove(obj);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代器遍历集合时，调用 <code>remove()</code> 后，继续执行 <code>next()</code> 时，程序会抛出异常 <code>UnsupportedOperationException</code> 或 <code>ConcurrentModificationException</code> 。</p><p>前者是因为接口或抽象类默认实现即抛出此异常。后者则因为删除方法修改了modCount计数值，导致与期待值不等所以抛出此异常。</p><h3 id="2-3-Itr"><a href="#2-3-Itr" class="headerlink" title="2.3 Itr"></a><strong>2.3 Itr</strong></h3><p>AbstractList中通过子类Itr实现了迭代器接口Iterator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 计数器记录操作次数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 抽象类默认仍是抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查modCount是否修改</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                E next = get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查modCount是否修改</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList中也通过子类Itr实现了迭代器接口Iterator。</p><p>在ArrayList中如 <code>remove()</code> 或 <code>sort()</code> 等方法会 <code>modCount++</code> 所以并发修改会导致计数器值和期待值不符，导致抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《维基百科》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Java集合中迭代器简单整理。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记</title>
    <link href="http://linyishui.top/2020060101.html"/>
    <id>http://linyishui.top/2020060101.html</id>
    <published>2020-06-01T09:06:15.000Z</published>
    <updated>2020-06-30T08:39:08.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a><strong>算法笔记</strong></h1><h2 id="第一节-递归"><a href="#第一节-递归" class="headerlink" title="第一节 递归"></a><strong>第一节 递归</strong></h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a><strong>1.1 概述</strong></h3><p>什么是递归？简单的说，一个方法自己调用自己即递归。递归实质上是把一个大问题分解为一个个小问题，然后通过一个个解决小问题最终解决大问题。</p><h3 id="1-2-斐波那契数列"><a href="#1-2-斐波那契数列" class="headerlink" title="1.2 斐波那契数列"></a><strong>1.2 斐波那契数列</strong></h3><h4 id="1-2-1-问题"><a href="#1-2-1-问题" class="headerlink" title="1.2.1 问题"></a><strong>1.2.1 问题</strong></h4><p>斐波那契数列是典型的递归案例：</p><ul><li>F(0) = 0（初始值）</li><li>F(1) = 1（初始值）</li><li>对于所有大于1的整数n：f(n) = f(n-1) + f(n-2)（递归定义）</li></ul><p>除了开头0和1，每个数字都刚好等于前两个数字之和：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……</p><h4 id="1-2-2-实现"><a href="#1-2-2-实现" class="headerlink" title="1.2.2 实现"></a><strong>1.2.2 实现</strong></h4><p>用代码来表示斐波那契数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-运行轨迹"><a href="#1-2-3-运行轨迹" class="headerlink" title="1.2.3 运行轨迹"></a><strong>1.2.3 运行轨迹</strong></h4><p>但递归的时间开销实在是太高了，如下图所示，求F(n)要沿树走下去并依次执行返回上来，即4-3-2-1-2-0-3-1-4-2-1-2-0-2-4。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt></p><h4 id="1-2-4-时间复杂度"><a href="#1-2-4-时间复杂度" class="headerlink" title="1.2.4 时间复杂度"></a><strong>1.2.4 时间复杂度</strong></h4><p>递归过程即遍历二叉树的流程，所以所有节点耗时相加即总耗时。每个节点只做了求和操作即 <code>O(1)</code> ，所以总时间为 <code>2^n</code> 。</p><h4 id="1-2-5-额外内存空间"><a href="#1-2-5-额外内存空间" class="headerlink" title="1.2.5 额外内存空间"></a><strong>1.2.5 额外内存空间</strong></h4><p>空间复杂度是指算法运行期间所需占用的所有内存空间，而我们分析算法时更常用的是额外内存空间，两者区别：长度为 <code>n</code> 的数组排序， <code>O(n)</code> 的空间不会算在额外内存空间，因为这个空间是必要的，不是取决于你的算法的。</p><p>对于递归算法来说，每个节点所需空间为 <code>O(1)</code> ，总共需要 <code>O(n)</code> 的空间。</p><h4 id="1-2-6-优化"><a href="#1-2-6-优化" class="headerlink" title="1.2.6 优化"></a><strong>1.2.6 优化</strong></h4><p>可以明显的看出递归算法的低效主要是因为进行了大量的<strong>重复操作</strong>，只要减少不必要的重复操作就可以提高算法效率。</p><p>首先我们可以想到用一个数据结构来记录已经进行过的操作，每次操作前判断一下是否进行过来避免重复。</p><p>选用一个数组来存放对应下标的值，通过游标遍历到n求得对应值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] notes = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    notes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    notes[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        notes[i] = notes[i-<span class="number">1</span>] + notes[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> notes[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时时间复杂度降低到了 <code>O(n)</code> 。</p><p>接着还可以继续优化空间，求第n个数的值最终并不需要我们记录之前的每个元素，所以可以继续优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样时间复杂度仍为 <code>O(n)</code> ，而空间也降到了 <code>O(1)</code> 。</p><p>这种解法其实就是<strong>动态规划</strong>。</p>]]></content>
    
    <summary type="html">
    
      暂时记录一些基础内容，持续更新。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>HTTP会话（未完成）</title>
    <link href="http://linyishui.top/2020050701.html"/>
    <id>http://linyishui.top/2020050701.html</id>
    <published>2020-05-07T11:21:21.000Z</published>
    <updated>2020-07-01T14:21:03.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP会话"><a href="#HTTP会话" class="headerlink" title="HTTP会话"></a><strong>HTTP会话</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-为什么需要会话？"><a href="#1-1-为什么需要会话？" class="headerlink" title="1.1 为什么需要会话？"></a><strong>1.1 为什么需要会话？</strong></h3><p>服务器接收请求时需要<strong>标识用户身份</strong>，当然首先可以想到<strong>IP地址</strong>可以作为<strong>唯一标识符</strong>，即某个时间段内来自同一IP地址的所有请求一定属于相同客户端。但是<strong>网络地址转换（NAT）并不可靠</strong>，比如大学校园或大型企业，可能有数千人使用相同的IP地址，其真实IP则隐藏在NAT路由之后。我们<strong>需要一个维护用户状态的机制</strong>，而HTTP协议本身是无状态的，所以所有的HTTP服务器都普遍采用了HTTP会话的概念。</p><h3 id="1-2-什么是会话？"><a href="#1-2-什么是会话？" class="headerlink" title="1.2 什么是会话？"></a><strong>1.2 什么是会话？</strong></h3><p>在网络领域，会话（session）是一种持久网络协议，在用户端（或用户代理）和服务器端间创建关联，从而起到交换数据包的作用机制。<strong>在不包含会话层（UDP）或无法长时间驻留会话层（HTTP）的传输协议中，会话的维持需要依靠在传输数据中的高级版程序</strong>。例如HTTP中使用Cookie存放一些如 <code>Session ID</code> 、参数和权限信息等。</p><p>会话是由服务器或Web应用程序管理的某些文件、内存片段、对象或容器，它包含了应用分配给它的各种数据。容器和用户浏览器直接通过某种方式连接起来，通常是赋予一个随机生成的字符串 <code>Session ID</code> 也叫会话ID。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010139.jpg" alt></p><h3 id="1-3-会话的作用"><a href="#1-3-会话的作用" class="headerlink" title="1.3 会话的作用"></a><strong>1.3 会话的作用</strong></h3><h4 id="1-3-1-维持状态"><a href="#1-3-1-维持状态" class="headerlink" title="1.3.1 维持状态"></a><strong>1.3.1 维持状态</strong></h4><p><strong>会话用于维持请求和请求之间的状态，HTTP请求自身是完全无状态的</strong>。在无状态的方式下，大部分应用程序无法正常工作，比如购物网站，所有的行为和功能都要基于用户身份，如购物车、收藏夹、支付等，可以想象没有状态的话所有的功能都必须一次成功走完，会话是维持请求状态的引擎。</p><h4 id="1-3-2-记住用户"><a href="#1-3-2-记住用户" class="headerlink" title="1.3.2 记住用户"></a><strong>1.3.2 记住用户</strong></h4><p><strong>会话的机制让系统能够记住用户</strong>：如论坛等网站，用户都要有用户名或“匿名”，用户登录后可以添加主题、回复主题、参与此人讨论等，所有流程中用户只须登录一次，系统需要记住此用户。</p><h4 id="1-3-3-启动应用程序工作流"><a href="#1-3-3-启动应用程序工作流" class="headerlink" title="1.3.3 启动应用程序工作流"></a><strong>1.3.3 启动应用程序工作流</strong></h4><p>通常用户在使用一些高级功能时，需要使用某种形式的<strong>工作流</strong>，比如新闻网站中发布新闻时，首先要进入编写标题、标语和正文的页面，然后下个页面选择相关图片，最后还可能要选择一些类似文章或关键字。以上三个步骤完成后，新闻被发布出去，这样的<strong>工作流通常包含多个步骤，每个步骤是单个任务，共同构成了整个工作流</strong>，所以请求之间需要维持一个状态。</p><hr><h2 id="第二节-简单使用"><a href="#第二节-简单使用" class="headerlink" title="第二节 简单使用"></a><strong>第二节 简单使用</strong></h2><h3 id="2-1-Cookie、Session、Token"><a href="#2-1-Cookie、Session、Token" class="headerlink" title="2.1 Cookie、Session、Token"></a><strong>2.1 Cookie、Session、Token</strong></h3><p>相关内容：<a href="../2019052101.html" title="Title">Cookie，Session，Token</a>。</p><h3 id="2-2-传输会话ID"><a href="#2-2-传输会话ID" class="headerlink" title="2.2 传输会话ID"></a><strong>2.2 传输会话ID</strong></h3><p>有两种流行的方式来传输会话ID：</p><ul><li>通过Set-Cookie头将JSESSIONID发送给浏览器。</li><li>通过URL直接拼接JSESSIONID。</li></ul><p>第二种方式可以避免使用Cookie，但所有请求URL都会嵌入会话ID。</p><h3 id="2-3-会话常见漏洞"><a href="#2-3-会话常见漏洞" class="headerlink" title="2.3 会话常见漏洞"></a><strong>2.3 会话常见漏洞</strong></h3><p>可以通过一些漏洞检测工具或如Open Web Application Security Project(OWASP)网站来进行检查。</p><h4 id="2-3-1-复制并粘贴错误"><a href="#2-3-1-复制并粘贴错误" class="headerlink" title="2.3.1 复制并粘贴错误"></a><strong>2.3.1 复制并粘贴错误</strong></h4><p>使用URL拼接的方式传输SessionID会面临一个问题：用户可能会不小心把URL复制到互联网上，如果一些人在会话结束前访问此URL，那么自然也会变当作此用户。</p><p>解决此问题的方法就是<strong>不要使用URL拼接这种方式</strong>，这并不奇怪，大部分网站都采用Cookie来作为通用的解决方案。</p><h4 id="2-3-2-会话固定"><a href="#2-3-2-会话固定" class="headerlink" title="2.3.2 会话固定"></a><strong>2.3.2 会话固定</strong></h4><p>会话固定攻击类似于复制粘贴错误，攻击者首先获得一个拼接SessionID的URL，然后将此URL传播出去，不知情的用户通过此URL在会话期间登录网站，那么攻击者也能够登录成功并访问被攻击用户的账户。</p><p>解决方法有：</p><ul><li>禁止在URL中嵌入会话ID，同时也需要在应用程序中禁止接受通过URL传递的会话ID。</li><li>在登录后采用会话迁移。即用户登录后，修改会话ID并将之前会话ID无效。</li></ul><h4 id="2-3-3-跨站脚本和会话劫持"><a href="#2-3-3-跨站脚本和会话劫持" class="headerlink" title="2.3.3 跨站脚本和会话劫持"></a><strong>2.3.3 跨站脚本和会话劫持</strong></h4><p><strong>跨站脚本攻击</strong>（CSRF）：攻击者会通过将JS注入某个页面，通过DOM属性 <code>document.cookie</code> 读取会话Cookie的内容，攻击者获得会话ID后，可以通过创建Cookie/或URL嵌入来模拟会话，直接使用被攻击用户的身份。</p><p>大致的触发流程是：</p><ol><li>用户登录了站点A，并且在Cookie中留下了A站点的认证信息</li><li>用户进入了站点B，而站点B用一些方式（比如一个提交行为是到A站点某关键接口的表单）引诱用户去点击。当用户点击时，会发出到A站点的请求。而浏览器会给这个请求附带上A站点的认证信息，从而让这个请求能够执行。这种行为可能是，但不限于，给某个A站点的某个其他用户提权/转账/发文辱骂等等。</li></ol><p>解决方法：</p><ol><li>编码和过滤，将HTML字符转换为 <code>HTML Entities</code> 编码，对js代码进行转义。</li><li>避免使用 <code>Cookie</code> ，而使用 <code>Local Storage</code> ，但会使XSS攻击更容易。</li><li>使用 <code>CSRF Token</code> 作表单验证。</li><li>给所有接口都添加一个请求 <code>secret</code> ，来标记其来自于合法的客户端。</li><li>用 <code>Same-Site Cookie</code> 限制站点必须同域名才能携带cookie。</li><li>总是用 <code>json</code> 格式提交，禁止允许跨域的 <code>application/x-www-form-urlencoded</code> 格式，而使用<code>application/json</code> 。</li><li>双认证，认证信息同时存放在 <code>HttpOnly Cookie</code> 和 <code>Authorization Header</code> ，并在服务器对比。</li><li>使用HTTPS，将Cookie设置为Secure，浏览器就可以只在访问https网址时才会携带Cookie。</li></ol><h4 id="2-3-4-不安全的Cookie"><a href="#2-3-4-不安全的Cookie" class="headerlink" title="2.3.4 不安全的Cookie"></a><strong>2.3.4 不安全的Cookie</strong></h4><p><strong>中间人攻击</strong>（MitM）：是一种典型的数据截获攻击，攻击者通过观察客户端和服务端交互的请求或响应，从中获取信息。</p><p>这种类型的攻击促进了<strong>安全套接字层</strong>和<strong>传输层安全</strong>（SSL/TLS）的发展，是HTTPS协议的基础。</p><p>解决方案是<strong>使用HTTPS协议</strong>，但仍存在的问题是<strong>应用可能同时支持HTTP和HTTPS</strong>，那么在HTTP请求重定向到HTTPS时攻击可能已经发生了（在用户浏览器通过未加密的方式发送会话ID cookie时，观察者已经窃取到此ID）。这种情况需要使用Cookie的 <code>Secure</code> 特性，此标志告诉浏览器只能通过HTTPS传输Cookie，即<strong>一直使用HTTPS</strong>。</p><h4 id="2-3-5-安全的会话"><a href="#2-3-5-安全的会话" class="headerlink" title="2.3.5 安全的会话"></a><strong>2.3.5 安全的会话</strong></h4><p><code>SSL/TLS 会话 ID</code> 通过去除必须在每次请求中都执行SSL握手的需求，改善了SSL协议的效率。<code>SSL/TLS 会话 ID</code> 在SSL握手期间建立，然后使用在后续请求中，将请求绑定在一起，决定加密和界面所使用的密钥。它与 <code>HTTP 会话 ID</code> 的区别在于其并不通过URL或Cookie来传输或存储，而是需要认证授权才能获取。</p><p>使用 <code>SSL/TLS 会话 ID</code> 需要一直使用HTTPS协议，并且SSL通信必须由Web容器完成，如果使用了Web服务器或负载均衡器管理SSL通信，Web容器将无法获得通信中的 <code>SSL/TLS 会话 ID</code> 值。在集群环境中，用户的请求必须要一直发生到同一服务器（多机不会备份会话信息）。服务端存储 <code>SSL/TLS 会话 ID</code> 对应的信息不太容易控制失效时间，太短起不到作用，太长又占用服务端大量资源。</p><hr><h2 id="第三节-在会话中存储数据"><a href="#第三节-在会话中存储数据" class="headerlink" title="第三节 在会话中存储数据"></a><strong>第三节 在会话中存储数据</strong></h2><hr><h2 id="第四节-使用会话"><a href="#第四节-使用会话" class="headerlink" title="第四节 使用会话"></a><strong>第四节 使用会话</strong></h2><hr><h2 id="第五节-将使用会话的应用集群化"><a href="#第五节-将使用会话的应用集群化" class="headerlink" title="第五节 将使用会话的应用集群化"></a><strong>第五节 将使用会话的应用集群化</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《JavaWeb高级编程——涵盖WebSockets、Spring Framework、JPA Hibernate和Spring Security》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="session" scheme="http://linyishui.top/tags/session/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="web" scheme="http://linyishui.top/tags/web/"/>
    
      <category term="java web" scheme="http://linyishui.top/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Redis</title>
    <link href="http://linyishui.top/2020050501.html"/>
    <id>http://linyishui.top/2020050501.html</id>
    <published>2020-05-05T03:44:21.000Z</published>
    <updated>2020-08-29T14:49:29.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h1><h2 id="第一节-综合"><a href="#第一节-综合" class="headerlink" title="第一节 综合"></a><strong>第一节 综合</strong></h2><h3 id="问：简单描述下-Redis？支持哪些数据结构？优点？"><a href="#问：简单描述下-Redis？支持哪些数据结构？优点？" class="headerlink" title="问：简单描述下 Redis？支持哪些数据结构？优点？"></a><strong>问：简单描述下 Redis？支持哪些数据结构？优点？</strong></h3><p>由<strong>C语言</strong>开发的一个<strong>基于高性能键值对</strong>的<strong>开源</strong>的<strong>内存数据库</strong>，是一个<strong>非关系型数据库</strong>（NoSQL）。</p><p>支持八种数据结构：字符串String，哈希Hash，数组List，集合Set，有序集合ZSet，位图BitMaps，基数统计HyperLogLig，地理信息定位GEO。</p><p>Redis的优势有：</p><ul><li>支持多种数据结构和算法，所以<strong>应用面广</strong>。</li><li>将数据存放在内存，所以有<strong>高效的读写性能</strong>。</li><li>内存中的数据通过快照和日志的方式保存在硬盘，所以<strong>不易丢失</strong>。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/118561398" target="_blank" rel="noopener">我和面试官的博弈：Redis 篇</a></p><h3 id="问：redis-最适合的场景？"><a href="#问：redis-最适合的场景？" class="headerlink" title="问：redis 最适合的场景？"></a><strong>问：redis 最适合的场景？</strong></h3><ol><li><strong>缓存模块</strong>：常用于大型网站来加速数据访问和缓解后端数据库压力。Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。会话缓存 session cache。</li><li><strong>排行榜</strong>：几乎所有网站都需要各种规则的排行榜，或是依据热度排行，或是发布时间，或是结合各种复杂维度计算。Redis提供了列表和有序集合数据结构，合理的使用这些结构可以很方便的构建各种排行榜系统。</li><li><strong>计数器</strong>：如一些视频网站的播放数，电商网站的浏览数，对于数据的实时性有较高的要求，如果并发量很大时，传统关系型数据库很难做好这一工作。Redis天然支持计数功能，且性能优越。</li><li><strong>社交网络</strong>：比如赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等常见功能，由于社交网站访问量通常较大，且传统关系型数据库不太适合存储这种类型的数据，而Redis提供的数据结构比较容易实现这些功能。</li><li><strong>消息队列</strong>：大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列功能，虽然相比专业的消息队列还有所欠缺，但可以满足大部分基础需求。</li></ol><h3 id="问：redis单线程为什么执行速度这么快？"><a href="#问：redis单线程为什么执行速度这么快？" class="headerlink" title="问：redis单线程为什么执行速度这么快？"></a><strong>问：redis单线程为什么执行速度这么快？</strong></h3><ol><li>纯内存操作，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快</li><li>单线程操作，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>采用了非阻塞I/O多路复用机制，减少了线程切换时上下文切换和竞争。</li></ol><h3 id="问：Redis高并发快的原因？"><a href="#问：Redis高并发快的原因？" class="headerlink" title="问：Redis高并发快的原因？"></a><strong>问：Redis高并发快的原因？</strong></h3><ol><li>内存数据库，读写速度快。</li><li>采用了非阻塞I/O多路复用机制。</li><li>单线程模型，保证了操作原子性，也避免了不必要的上下文切换和竞争条件。</li><li>数据结构有做底层优化，如Hash、压缩表、压缩存储、跳跃表等。</li><li>Redis实现了高效率的事件分离器，内部采用非阻塞的执行方式，吞吐能力很高。</li></ol><h3 id="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；"><a href="#问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；" class="headerlink" title="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；"></a><strong>问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；</strong></h3><h3 id="问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a><strong>问：1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></h3><p>使用keys指令可以扫出指定模式的key列表。 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了 ，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="问：Redis如何压缩内存？"><a href="#问：Redis如何压缩内存？" class="headerlink" title="问：Redis如何压缩内存？"></a><strong>问：Redis如何压缩内存？</strong></h3><h3 id="问：讲一下平时使用Redis遇到过哪些问题？如何解决的？"><a href="#问：讲一下平时使用Redis遇到过哪些问题？如何解决的？" class="headerlink" title="问：讲一下平时使用Redis遇到过哪些问题？如何解决的？"></a><strong>问：讲一下平时使用Redis遇到过哪些问题？如何解决的？</strong></h3><hr><h2 id="第二节-底层数据结构"><a href="#第二节-底层数据结构" class="headerlink" title="第二节 底层数据结构"></a><strong>第二节 底层数据结构</strong></h2><h3 id="问：redis支持哪些数据结构？"><a href="#问：redis支持哪些数据结构？" class="headerlink" title="问：redis支持哪些数据结构？"></a><strong>问：redis支持哪些数据结构？</strong></h3><p>string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog（做基数统计）、GEO（地理信息定位）等多种数据结构和算法</p><h3 id="问：Redis各种数据结构的使用场景、内部编码及底层实现？"><a href="#问：Redis各种数据结构的使用场景、内部编码及底层实现？" class="headerlink" title="问：Redis各种数据结构的使用场景、内部编码及底层实现？"></a><strong>问：Redis各种数据结构的使用场景、内部编码及底层实现？</strong></h3><p><strong>String</strong>：</p><ul><li><p>【应用场景】： </p><ul><li><strong>缓存</strong></li><li><strong>计数</strong></li><li><strong>共享Session</strong></li><li><strong>限速</strong></li></ul></li><li><p>【内部编码】：</p><ul><li><strong>int</strong>：8个字节的长整型。</li><li><strong>embstr</strong>：小于等于39个字节的字符串。</li><li><strong>raw</strong>：大于39个字节的字符串。</li></ul></li><li><p>【底层实现】：<code>Simple dynamic string</code>（SDS）的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">  <span class="comment">//等于SDS保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len；</span><br><span class="line">  <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>；</span><br><span class="line">  <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[]；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>优点（都是C字符串的缺点弥补）：</p><ul><li>不会出现字符串变更造成的内存溢出问题。</li><li>获取字符串长度时间复杂度为1，C字符串没有长度信息（以 <code>\0</code> 来明确表示结尾），必须遍历字符串，时间复杂度为O(n)。</li><li>空间预分配， 惰性空间释放free字段，会默认留够一定的空间防止多次重分配内存。</li></ul></li></ul><p><strong>Hash</strong>：</p><ul><li>【应用场景】： <ul><li><strong>保存结构体信息</strong>，可部分获取不用序列化所有字段。如保存用户类，原生字符串每个属性都要对应一个键，序列化字符串需要序列与反序列的开销，而哈希类型只须一个键即可存放一个用户信息。</li></ul></li><li>【内部编码】：<ul><li><strong>ziplist</strong>（压缩列表）：当哈希类型元素个数小于 <code>hash-max-ziplist-entries</code> 配置（默认为512个），同时所有值都小于 <code>hash-max-ziplist-value</code> 配置（默认为6字节）时，Redis使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以相比hashtable会更节省空间。</li><li><strong>hashtable</strong>（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，这种情况ziplist的读写效率会下降，而hashtable读写时间复杂度为 <code>O(1)</code> 。</li></ul></li><li>【底层实现】：在数组+链表的基础上，进行了一些rehash优化。<ul><li>Reids的Hash采用<strong>链地址法</strong>来处理冲突，然后它<strong>没有使用红黑树优化</strong>。</li><li>哈希表节点采用<strong>单链表结构</strong>。</li><li><strong>rehash优化</strong> （采用分而治之的思想，将庞大的迁移工作量划分到每一次CURD中，避免了服务繁忙）</li></ul></li></ul><p><strong>List</strong>：</p><ul><li><p>【应用场景】： </p><ul><li><p><strong>消息队列</strong>：<code>lpush</code> + <code>brpop</code> 命令组合即可实现<strong>阻塞队列</strong></p></li><li><p><strong>文章列表</strong>：比如twitter的关注列表，粉丝列表等</p></li><li><p>经典口诀：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush + <span class="attr">lpop</span> = Stack（栈）</span><br><span class="line">lpush + <span class="attr">rpop</span> = Queue（队列）</span><br><span class="line">lpush + <span class="attr">ltrim</span> = Capped Collection（有限集合）</span><br><span class="line">lpush + <span class="attr">brpop</span> = Message Queue（消息队列）</span><br></pre></td></tr></table></figure></li></ul></li><li><p>【内部编码】：</p><ul><li><strong>ziplist</strong>：当列表的元素个数小于 <code>list-max-ziplist-entries</code> 配置（默认512个），同时列表中每个元素的值都小于 <code>list-max-ziplist-value</code> 配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li><li><strong>linkedlist</strong>（链表）：当列表类型无法满足ziplist的条件时，Redis会使用链表实现。</li></ul></li><li><p>【底层实现】：list的实现为一个<strong>双向链表</strong>，即可以支持反向查找和遍历。</p></li></ul><p><strong>Set</strong>：</p><ul><li>【应用场景】： <ul><li><strong>去重的场景</strong></li><li><strong>求交集</strong>（sinter）、<strong>并集</strong>（sunion）、<strong>差集</strong>（sdiff）</li><li><strong>标签</strong>：实现如共同关注、共同喜好、二度好友等功能。</li></ul></li><li>【内部编码】：<ul><li><strong>intset</strong>（整数集合）：当集合中的元素都是整数且元素个数小于 <code>set-max-intset-entries</code> 配置（默认512个）时，Redis会选用intset来作为集合内部实现，从而减少内存的使用。</li><li><strong>hashtable</strong>（哈希表）：集合无法满足intset的条件时，选用hashtable作为集合内部实现。</li></ul></li><li>【底层实现】：是一个<strong>value为null的HashMap</strong>，实际就是<strong>通过计算hash的方式来快速排重</strong>的，这也是set能提供判断一个成员是否在集合内的原因。 </li></ul><p><strong>ZSet</strong>：</p><ul><li>【应用场景】：<ul><li><strong>排行榜</strong></li><li><strong>实现延时队列</strong></li></ul></li><li>【内部编码】：<ul><li><strong>ziplist</strong>（压缩列表）：当有序集合的元素个数小于 <code>zset-max-ziplist-entries</code> 配置（默认128个），同时列表中每个元素的值都小于 <code>zset-max-ziplist-value</code> 配置（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li><li><strong>skiplist</strong>（跳跃表）：当无法满足ziplist的条件时，Redis选用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li></ul></li><li>【底层实现】：内部使用<strong>HashMap</strong>和<strong>跳跃表</strong>（SkipList）来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 <ul><li>跳表：每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</li></ul></li></ul><h3 id="问：redis中的字符串类型是怎么实现的？"><a href="#问：redis中的字符串类型是怎么实现的？" class="headerlink" title="问：redis中的字符串类型是怎么实现的？"></a><strong>问：redis中的字符串类型是怎么实现的？</strong></h3><p>通过一个抽象数据结构SDS来实现，包含三个重要属性：已使用字节数量，未使用字节数量，字节数组。存储时保留了C语言以 <code>\0</code> 为结尾的习惯以便能兼容C语言的函数。分配空间时，当长度小于1MB，会根据已使用空间分配相等大小的未使用空间以备扩展，大于1MB时只会分配1MB。</p><h3 id="问：redis-如何存储一个-String-的？"><a href="#问：redis-如何存储一个-String-的？" class="headerlink" title="问：redis 如何存储一个 String 的？"></a><strong>问：redis 如何存储一个 String 的？</strong></h3><p>假设要存储一个字符串 <code>hello</code> ，SDS会记录已使用字节长度为5，并分配相同大小的未使用字节空间（长度小于1MB时）所以也为5，并保留 <code>\0</code> 作为字符串结尾但不计入空间占用，所以此时SDS分配空间为11。</p><h3 id="问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？"><a href="#问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？" class="headerlink" title="问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？"></a><strong>问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？</strong></h3><p>首先原生C字符串获取字符串长度需要遍历整个字符串，复杂度为O(n)，而SDS则为O(1)。</p><p>因为有预分配的空间以及惰性释放空间，所以可以避免重复内存分配。</p><p>因为有了长度控制，所以避免了C字符串常见的内存溢出问题。</p><p>C字符串对于字符编码有要求，对于一些如图片、音频等格式的二进制编码未必能支持，而SDS虽然保留了空字符结尾但并不以它来判断字符串结尾，所以可以安全的存储一些特殊格式要求的二进制数据。</p><h3 id="问：hash底层如何实现？rehash做了哪些优化？"><a href="#问：hash底层如何实现？rehash做了哪些优化？" class="headerlink" title="问：hash底层如何实现？rehash做了哪些优化？"></a><strong>问：hash底层如何实现？rehash做了哪些优化？</strong></h3><p>Redis 的 hash 数据有两种底层编码实现：ziplist和hashtable。</p><p>字典由 <code>dict.h</code> 文件定义，其中ht是哈希表结构，0是正常使用的表，1则是渐进rehash时用来转移0的节点。</p><p>rehashidx用来在rehash过程记录正在转移的键，平时为-1。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010116.png" alt></p><p>dictht即哈希表结构，内部包含一个 <code>dictEntry **table</code> table即dictEntry二维数组，为了哈希冲突时能够串联所有冲突的节点。size即哈希表最大可寻址大小，即一维数组最大长度。dictEntry则是一个键值对结构。</p><p>在数组+链表的基础上，进行了一些rehash优化。TODO</p><ul><li>Reids的Hash采用<strong>链地址法</strong>来处理冲突，然后它<strong>没有使用红黑树优化</strong>。</li><li>哈希表节点采用<strong>单链表结构</strong>。</li><li><strong>rehash优化</strong> （采用分而治之的思想，将庞大的迁移工作量划分到每一次CURD中，避免了服务繁忙）</li></ul><h3 id="问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？"><a href="#问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？" class="headerlink" title="问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？"></a><strong>问：zset底层怎么实现的？zset为什么使用跳跃链表而不用红黑树实现？</strong></h3><ol><li>skiplist的复杂度和红黑树一样，而且实现起来更简单。</li><li>在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。</li></ol><h3 id="问：redis如何实现延时队列？"><a href="#问：redis如何实现延时队列？" class="headerlink" title="问：redis如何实现延时队列？"></a><strong>问：redis如何实现延时队列？</strong></h3><p>使用sortedset，想要执行时间的时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p><h3 id="问：关于redis对象系统的一个问题？"><a href="#问：关于redis对象系统的一个问题？" class="headerlink" title="问：关于redis对象系统的一个问题？"></a><strong>问：关于redis对象系统的一个问题？</strong></h3><p>（我说忘记了，记得redis设计与实现有写，面试小哥：忘记了那就不问了）</p><h3 id="问：如何利用Redis处理热点数据？"><a href="#问：如何利用Redis处理热点数据？" class="headerlink" title="问：如何利用Redis处理热点数据？"></a><strong>问：如何利用Redis处理热点数据？</strong></h3><h3 id="问：redis-的过期策略？"><a href="#问：redis-的过期策略？" class="headerlink" title="问：redis 的过期策略？"></a><strong>问：redis 的过期策略？</strong></h3><h3 id="问：redis-的内存淘汰策略？"><a href="#问：redis-的内存淘汰策略？" class="headerlink" title="问：redis 的内存淘汰策略？"></a><strong>问：redis 的内存淘汰策略？</strong></h3><hr><h2 id="第三节-事务"><a href="#第三节-事务" class="headerlink" title="第三节 事务"></a><strong>第三节 事务</strong></h2><h3 id="问：redis事务？"><a href="#问：redis事务？" class="headerlink" title="问：redis事务？"></a><strong>问：redis事务？</strong></h3><ol><li>Multi开启事务</li><li>Exec执行事务块内命令</li><li>Discard 取消事务</li><li>Watch 监视一个或多个key，如果事务执行前key被改动，事务将打断</li></ol><h3 id="问：redis事务的实现特征？"><a href="#问：redis事务的实现特征？" class="headerlink" title="问：redis事务的实现特征？"></a><strong>问：redis事务的实现特征？</strong></h3><ol><li>所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行</li><li>Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</li><li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行</li><li>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。</li></ol><p>然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</p><p>Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了</p><hr><h2 id="第四节-同步阻塞"><a href="#第四节-同步阻塞" class="headerlink" title="第四节 同步阻塞"></a><strong>第四节 同步阻塞</strong></h2><h3 id="问：Redis的同步机制？"><a href="#问：Redis的同步机制？" class="headerlink" title="问：Redis的同步机制？"></a><strong>问：Redis的同步机制？</strong></h3><blockquote><ul><li>全量拷贝：</li><li><ol><li>slave第一次启动时，连接Master，发送PSYNC命令，</li><li>master会执行bgsave命令来生成rdb文件，期间的所有写命令将被写入缓冲区。</li><li>master bgsave执行完毕，向slave发送rdb文件</li><li>slave收到rdb文件，丢弃所有旧数据，开始载入rdb文件</li><li>rdb文件同步结束之后，slave执行从master缓冲区发送过来的所以写命令。此后 master 每执行一个写命令，就向slave发送相同的写命令。</li></ol></li><li>增量拷贝：</li><li><ul><li>如果出现网络闪断或者命令丢失等异常情况，从节点之前保存了自身已复制的偏移量和主节点的运行ID<ul><li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li></ul></li></ul></li></ul></blockquote><h3 id="问：redis阻塞原因？"><a href="#问：redis阻塞原因？" class="headerlink" title="问：redis阻塞原因？"></a><strong>问：redis阻塞原因？</strong></h3><ol><li>数据结构使用不合理bigkey</li><li>CPU饱和</li><li>持久化阻塞，rdb fork子线程，aof每秒刷盘等</li></ol><h3 id="问：讲一下分布式锁？"><a href="#问：讲一下分布式锁？" class="headerlink" title="问：讲一下分布式锁？"></a><strong>问：讲一下分布式锁？</strong></h3><h3 id="问：说说怎么用redis实现分布式锁？"><a href="#问：说说怎么用redis实现分布式锁？" class="headerlink" title="问：说说怎么用redis实现分布式锁？"></a><strong>问：说说怎么用redis实现分布式锁？</strong></h3><h3 id="问：Redis分布式锁？"><a href="#问：Redis分布式锁？" class="headerlink" title="问：Redis分布式锁？"></a><strong>问：Redis分布式锁？</strong></h3><p>2.6版本以后lua脚本保证setnx跟setex进行原子性（setnx之后，未setex，服务挂了，锁不释放） a获取锁，超过过期时间，自动释放锁，b获取到锁执行，a代码执行完remove锁，a和b是一样的key，导致a释放了b的锁。 解决办法：remove之前判断value（高并发下value可能被修改，应该用lua来保证原子性）</p><h3 id="问：redis锁续租问题？"><a href="#问：redis锁续租问题？" class="headerlink" title="问：redis锁续租问题？"></a><strong>问：redis锁续租问题？</strong></h3><ol><li><p>基于redis的redission分布式可重入锁RLock，以及配合java集合中lock；</p></li><li><p>Redission 内部提供了一个监控锁的看门狗，不断延长锁的有效期，默认检查锁的超时时间是30秒</p></li><li><p>此方案的问题：如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master ，slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。</p></li></ol><p>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。 此时就会导致多个客户端对一个分布式锁完成了加锁 解决办法：只需要将新的redis实例，在一个TTL时间内，对客户端不可用即可，在这个时间内，所有客户端锁将被失效或者自动释放.</p><h3 id="问：如何使用Redis做异步队列？"><a href="#问：如何使用Redis做异步队列？" class="headerlink" title="问：如何使用Redis做异步队列？"></a><strong>问：如何使用Redis做异步队列？</strong></h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><h3 id="问：可不可以不用sleep呢？"><a href="#问：可不可以不用sleep呢？" class="headerlink" title="问：可不可以不用sleep呢？"></a><strong>问：可不可以不用sleep呢？</strong></h3><p>list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。</p><h3 id="问：如何解决-Redis-的并发竞争-Key-问题？"><a href="#问：如何解决-Redis-的并发竞争-Key-问题？" class="headerlink" title="问：如何解决 Redis 的并发竞争 Key 问题？"></a><strong>问：如何解决 Redis 的并发竞争 Key 问题？</strong></h3><hr><h2 id="第x节-发布订阅"><a href="#第x节-发布订阅" class="headerlink" title="第x节 发布订阅"></a><strong>第x节 发布订阅</strong></h2><h3 id="问：能不能生产一次消费多次呢？"><a href="#问：能不能生产一次消费多次呢？" class="headerlink" title="问：能不能生产一次消费多次呢？"></a><strong>问：能不能生产一次消费多次呢？</strong></h3><p>使用pub/sub主题订阅者模式，可以实现1：N的消息队列。</p><h3 id="问：pub-sub有什么缺点？"><a href="#问：pub-sub有什么缺点？" class="headerlink" title="问：pub/sub有什么缺点？"></a><strong>问：pub/sub有什么缺点？</strong></h3><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p><h3 id="问：讲一下项目中Redis消息队列如何做的？"><a href="#问：讲一下项目中Redis消息队列如何做的？" class="headerlink" title="问：讲一下项目中Redis消息队列如何做的？"></a><strong>问：讲一下项目中Redis消息队列如何做的？</strong></h3><p>使用pub/sub主题订阅者模式，可以实现1：N的消息队列。</p><hr><h2 id="第x节-持久化"><a href="#第x节-持久化" class="headerlink" title="第x节 持久化"></a><strong>第x节 持久化</strong></h2><h3 id="问：Redis-持久化策略？Redis如何做持久化？"><a href="#问：Redis-持久化策略？Redis如何做持久化？" class="headerlink" title="问：Redis 持久化策略？Redis如何做持久化？"></a><strong>问：Redis 持久化策略？Redis如何做持久化？</strong></h3><p>Redis持久化分两种：RDB和AOF，RDB是全量持久化，aof则是增量持久化。因为全量持久化是重操作，无法进行实时的持久化，所以通过AOF解决。</p><p>RDB是将进程数据的快照保存到硬盘，通过fork子进程来异步生成RDB文件。</p><p>AOF则将命令写入缓冲区，通过三种策略同步到硬盘（每次都同步，每秒同步，不同步），随着文件增大还会进行文件重写，服务器重启时通过AOF文件恢复。</p><p>在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><h3 id="问：如果突然机器断电会怎样？"><a href="#问：如果突然机器断电会怎样？" class="headerlink" title="问：如果突然机器断电会怎样？"></a><strong>问：如果突然机器断电会怎样？</strong></h3><p>一般会选择everysec模式，即每秒执行一次fsync同步文件，所以只会丢失1s的数据（同步时主线程会判断最近2s是否有进行同步，有则直接返回，否则阻塞等同步线程执行完毕，所以最多可能丢失2s的数据）。</p><h3 id="问：bgsave的原理是什么？"><a href="#问：bgsave的原理是什么？" class="headerlink" title="问：bgsave的原理是什么？"></a><strong>问：bgsave的原理是什么？</strong></h3><p>bgsave相比于已废弃的save，后者阻塞服务器直到RDB过程结束，前者则通过fork创建子进程，持久化过程由子进程来完成，减少了主进程的阻塞时间。通过copy-on-write机制，父子进程共享内存，父进程继续提供读写服务，子进程根据父进程内存生成快照文件，并替换到RDB文件。</p><h3 id="问：RDB与AOF区别？"><a href="#问：RDB与AOF区别？" class="headerlink" title="问：RDB与AOF区别？"></a><strong>问：RDB与AOF区别？</strong></h3><ol><li><p>RDB压缩文件格式紧凑，适合备份和全量复制，数据恢复快。但没法实时持久化，且有不同版本多个格式问题。</p></li><li><p>AOF则不断的追加命令到文件（文本协议RESP），因此文件会不断变大，需要重写机制来压缩体积。重写时通过重写缓冲区保存此期间主进程响应的命令。</p></li></ol><hr><h2 id="第x节-哨兵、复制、集群"><a href="#第x节-哨兵、复制、集群" class="headerlink" title="第x节 哨兵、复制、集群"></a><strong>第x节 哨兵、复制、集群</strong></h2><h3 id="问：redis主从机制了解么？怎么实现的？"><a href="#问：redis主从机制了解么？怎么实现的？" class="headerlink" title="问：redis主从机制了解么？怎么实现的？"></a><strong>问：redis主从机制了解么？怎么实现的？</strong></h3><h3 id="问：redis-的部署方式，主从，集群？"><a href="#问：redis-的部署方式，主从，集群？" class="headerlink" title="问：redis 的部署方式，主从，集群？"></a><strong>问：redis 的部署方式，主从，集群？</strong></h3><h3 id="问：谈谈Redis哨兵、复制、集群？"><a href="#问：谈谈Redis哨兵、复制、集群？" class="headerlink" title="问：谈谈Redis哨兵、复制、集群？"></a><strong>问：谈谈Redis哨兵、复制、集群？</strong></h3><h3 id="问：redis-的哨兵模式，一个-key-值如何在-redis-集群中找到存储在哪？"><a href="#问：redis-的哨兵模式，一个-key-值如何在-redis-集群中找到存储在哪？" class="headerlink" title="问：redis 的哨兵模式，一个 key 值如何在 redis 集群中找到存储在哪？"></a><strong>问：redis 的哨兵模式，一个 key 值如何在 redis 集群中找到存储在哪？</strong></h3><h3 id="问：redis集群模式性能优化？"><a href="#问：redis集群模式性能优化？" class="headerlink" title="问：redis集群模式性能优化？"></a><strong>问：redis集群模式性能优化？</strong></h3><ol><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li><li>尽量避免在压力很大的主库上增加从库</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master - Slave1 - Slave2 - Slave3…</code> 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</li></ol><h3 id="问：Redis集群方案？"><a href="#问：Redis集群方案？" class="headerlink" title="问：Redis集群方案？"></a><strong>问：Redis集群方案？</strong></h3><ol><li>官方cluster方案</li><li>twemproxy：代理方案twemproxy是一个单点，很容易对其造成很大的压力，所以通常会结合keepalived来实twemproy的高可用</li><li>codis 基于客户端来进行分片</li></ol><h3 id="问：集群不可用场景？"><a href="#问：集群不可用场景？" class="headerlink" title="问：集群不可用场景？"></a><strong>问：集群不可用场景？</strong></h3><ol><li>master挂掉，且当前master没有slave</li><li>集群超过半数以上master挂掉，无论是否有slave集群进入fail状态</li></ol><h3 id="问：hot-key出现造成集群访问量倾斜解决办法？"><a href="#问：hot-key出现造成集群访问量倾斜解决办法？" class="headerlink" title="问：hot key出现造成集群访问量倾斜解决办法？"></a><strong>问：hot key出现造成集群访问量倾斜解决办法？</strong></h3><ol><li>使用本地缓存</li><li>利用分片算法的特性，对key进行打散处理（给hot key加上前缀或者后缀，把一个hotkey 的数量变成 redis 实例个数N的倍数M，从而由访问一个 redis key 变成访问 N * M 个redis key）</li></ol><h3 id="问：缓存淘汰策略？"><a href="#问：缓存淘汰策略？" class="headerlink" title="问：缓存淘汰策略？"></a><strong>问：缓存淘汰策略？</strong></h3><ol><li><p>先进先出算法（FIFO）</p></li><li><p>最近使用最少Least Frequently Used（LFU）</p></li><li><p>最长时间未被使用的Least Recently Used（LRU）</p></li></ol><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重</p><h3 id="问：redis过期key删除策略？"><a href="#问：redis过期key删除策略？" class="headerlink" title="问：redis过期key删除策略？"></a><strong>问：redis过期key删除策略？</strong></h3><ol><li><p>惰性删除，cpu友好，但是浪费cpu资源</p></li><li><p>定时删除（不常用）</p></li><li><p>定期删除，cpu友好，节省空间</p></li></ol><h3 id="问：缓存雪崩以及处理办法？"><a href="#问：缓存雪崩以及处理办法？" class="headerlink" title="问：缓存雪崩以及处理办法？"></a><strong>问：缓存雪崩以及处理办法？</strong></h3><p>同一时刻大量缓存失效；</p><blockquote><p>处理方法：</p><ol><li>缓存数据增加过期标记</li><li>设置不同的缓存失效时间</li><li>双层缓存策略C1为短期，C2为长期</li><li>定时更新策略</li></ol></blockquote><h3 id="问：缓存击穿原因以及处理办法？"><a href="#问：缓存击穿原因以及处理办法？" class="headerlink" title="问：缓存击穿原因以及处理办法？"></a><strong>问：缓存击穿原因以及处理办法？</strong></h3><p>频繁请求查询系统中不存在的数据导致；</p><blockquote><p>处理方法：</p><ol><li>cache null策略，查询反馈结果为null仍然缓存这个null结果，设置不超过5分钟过期时间</li><li>布隆过滤器，所有可能存在的数据映射到足够大的bitmap中 google布隆过滤器：基于内存，重启失效不支持大数据量，无法在分布式场景 redis布隆过滤器：可扩展性，不存在重启失效问题，需要网络io，性能低于google</li></ol></blockquote><h3 id="问：你们怎么解决缓存击穿问题的？"><a href="#问：你们怎么解决缓存击穿问题的？" class="headerlink" title="问：你们怎么解决缓存击穿问题的？"></a><strong>问：你们怎么解决缓存击穿问题的？</strong></h3><p>注:估计答了Hystrix</p><h3 id="问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？"><a href="#问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？" class="headerlink" title="问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？"></a><strong>问：缓存穿透、缓存击穿、缓存雪崩问题及解决方法？</strong></h3><h3 id="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"><a href="#问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？" class="headerlink" title="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"></a><strong>问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？</strong></h3><p>注:估计答了Hystrix</p><h3 id="问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？"><a href="#问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？"></a><strong>问：缓存和数据库一致性问题？如何保证缓存与数据库双写时的数据一致性？</strong></h3><hr><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p></blockquote><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Redis相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
</feed>
