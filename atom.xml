<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-01-14T09:29:18.848Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程安全和锁优化</title>
    <link href="http://linyishui.top/2019122801.html"/>
    <id>http://linyishui.top/2019122801.html</id>
    <published>2019-12-28T08:30:18.000Z</published>
    <updated>2020-01-14T09:29:18.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程安全和锁优化"><a href="#线程安全和锁优化" class="headerlink" title="线程安全和锁优化"></a><strong>线程安全和锁优化</strong></h1><p>&emsp;&emsp;并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。</p><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;在软件业发展的初期，程序编写都是以算法为核心的，程序员会把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维方式直接站在计算机的角度去抽象问题和解决问题，称为面向过程的编程思想。与此相对的是，面向对象的编程思想是站在现实世界的角度去抽象和解决问题，它把数据和行为都看做是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。</p><p>&emsp;&emsp;面向过程的编程思想极大地提升了现代软件开发的生产效率和软件可以达到的规模，但是现实世界与计算机世界之间不可避免地存在一些差异。例如，人们很难想象现实中的对象在一项工作进行期间，会被不停地中断和切换，对象的属性（数据）可能会在中断期间被修改和变“脏”，而这些事件在计算机世界中则是很正常的事情。有时候，良好的设计原则不得不向现实做出一些让步，我们必须让程序在计算机中正确无误地运行，然后再考虑如何将代码组织得更好，让程序运行得更快。对于这部分的主题“高效并发”来讲，首先需要保证并发的正确性，然后在此基础上实现高效。本章先从如何保证并发的正确性和如何实现线程安全讲起。</p><hr><h2 id="第二节-线程安全"><a href="#第二节-线程安全" class="headerlink" title="第二节 线程安全"></a><strong>第二节 线程安全</strong></h2><p>&emsp;&emsp;“线程安全”这个名称，相信稍有经验的程序员都会听说过，甚至在代码编写和走查的时候可能还会经常挂在嘴边，但是如何找到一个不太拗口的概念来定义线程安全却不是一件容易的事情，笔者尝试在Google中搜索它的概念，找到的是类似于“如果一个对象可以安全地被多个线程同时使用，那它就是线程安全的”这样的定义——并不能说它不正确，但是人们无法从中获取到任何有用的信息。</p><p>&emsp;&emsp;笔者认为《Java Concurrency In Practice》的作者Brian Goetz对“线程安全”有一个比较恰当的定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。</p><p>&emsp;&emsp;这个定义比较严谨，它要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。这点听起来简单，但其实并不容易做到，在大多数场景中，我们都会将这个定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”，这个定义的其他描述也能够成立的话，我们就可以称它是线程安全了，为什么要弱化这个定义，现在暂且放下，稍后再详细探讨。</p><h3 id="2-1-Java语言中的线程安全"><a href="#2-1-Java语言中的线程安全" class="headerlink" title="2.1 Java语言中的线程安全"></a><strong>2.1 Java语言中的线程安全</strong></h3><p>&emsp;&emsp;我们已经有了线程安全的一个抽象定义，那接下来就讨论一下在Java语言中，线程安全具体是如何体现的？有哪些操作是线程安全的？我们这里讨论的线程安全，就限定于多个线程之间存在共享数据访问这个前提，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的。</p><p>&emsp;&emsp;为了更加深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元排他选项来看待，按照线程安全的“安全程度”由强至弱来排序，我们[1]可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h3 id="2-1-1-不可变"><a href="#2-1-1-不可变" class="headerlink" title="2.1.1 不可变"></a><strong>2.1.1 不可变</strong></h3><p>&emsp;&emsp;在Java语言中（特指JDK 1.5以后，即Java内存模型被修正之后的Java语言），不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，在第12章我们谈到final关键字带来的可见性时曾经提到过这一点，只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最简单和最纯粹的。</p><p>&emsp;&emsp;Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，如果读者还没想明白这句话，不妨想一想java.lang.String类的对象，它是一个典型的不可变对象，我们调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。</p><p>&emsp;&emsp;保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的，例如代码清单13-1中java.lang.Integer构造函数所示的，它通过将内部状态变量value定义为final来保障状态不变。</p><p>&emsp;&emsp;代码清单13-1 JDK中Integer类的构造函数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value of the&lt;code&gt;Integer&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> * @serial</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> final <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a newly allocated&lt;code&gt;Integer&lt;/code&gt;object that</span></span><br><span class="line"><span class="comment"> * represents the specified&lt;code&gt;int&lt;/code&gt;value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param value the value to be represented by the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Integer&lt;/code&gt;object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Java API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类型，以及java.lang.Number的部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型；但同为Number的子类型的原子类AtomicInteger和AtomicLong则并非不可变的，读者不妨看看这两个原子类的源码，想一想为什么。</p><h3 id="2-1-2-绝对线程安全"><a href="#2-1-2-绝对线程安全" class="headerlink" title="2.1.2 绝对线程安全"></a><strong>2.1.2 绝对线程安全</strong></h3><p>&emsp;&emsp;绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。我们可以通过Java API中一个不是“绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思。</p><p>&emsp;&emsp;如果说java.util.Vector是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，因为它的add()、get()和size()这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远都不再需要同步手段了，请看一下代码清单13-2中的测试代码。</p><p>&emsp;&emsp;代码清单13-2 对Vector线程安全的测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt;<span class="built_in">vector</span> = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">vector</span>.size();i++)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">vector</span>.size();i++)&#123;</span><br><span class="line">                    System.out.println((<span class="built_in">vector</span>.get(i)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        removeThread.start();</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread<span class="string">"Thread-132"</span>java<span class="selector-class">.lang</span><span class="selector-class">.ArrayIndexOutOfBoundsException</span>：</span><br><span class="line">Array index out of range：<span class="number">17</span></span><br><span class="line">at java<span class="selector-class">.util</span><span class="selector-class">.Vector</span><span class="selector-class">.remove</span>(Vector.java：<span class="number">777</span>)</span><br><span class="line">at org<span class="selector-class">.fenixsoft</span><span class="selector-class">.mulithread</span><span class="selector-class">.VectorTest</span>$<span class="number">1</span>.run(VectorTest.java：<span class="number">21</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.java：<span class="number">662</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很明显，尽管这里使用到的Vector的get()、remove()和size()方法都是同步的，但是在多线程的环境中，如果不在方法调用端做额外的同步措施的话，使用这段代码仍然是不安全的，因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i已经不再可用的话，再用i访问数组就会抛出一个ArrayIndexOutOfBoundsException。如果要保证这段代码能正确执行下去，我们不得不把removeThread和printThread的定义改成如代码清单13-3所示的样子。</p><p>&emsp;&emsp;代码清单13-3 必须加入同步以保证Vector访问的线程安全性</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Thread removeThread = new Thread(<span class="name">new</span> Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        synchronized(<span class="name">vector</span>)&#123;</span><br><span class="line">            for(<span class="name">int</span> i = <span class="number">0</span><span class="comment">;i&lt;vector.size();i++)&#123;</span></span><br><span class="line">                vector.remove(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Thread printThread = new Thread(<span class="name">new</span> Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        synchronized(<span class="name">vector</span>)&#123;</span><br><span class="line">            for(<span class="name">int</span> i = <span class="number">0</span><span class="comment">;i&lt;vector.size();i++)&#123;</span></span><br><span class="line">                System.out.println((<span class="name">vector</span>.get(<span class="name">i</span>)))<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-1-3-相对线程安全"><a href="#2-1-3-相对线程安全" class="headerlink" title="2.1.3 相对线程安全"></a><strong>2.1.3 相对线程安全</strong></h3><p>&emsp;&emsp;相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。上面代码清单13-2和代码清单13-3就是相对线程安全的明显的案例。</p><p>&emsp;&emsp;在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。</p><h3 id="2-1-4-线程兼容"><a href="#2-1-4-线程兼容" class="headerlink" title="2.1.4 线程兼容"></a><strong>2.1.4 线程兼容</strong></h3><p>&emsp;&emsp;线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</p><h3 id="2-1-5-线程对立"><a href="#2-1-5-线程对立" class="headerlink" title="2.1.5 线程对立"></a><strong>2.1.5 线程对立</strong></h3><p>&emsp;&emsp;线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p><p>&emsp;&emsp;一个线程对立的例子是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend()和resume()方法已经被JDK声明废弃（@Deprecated）了。常见的线程对立的操作还有System.setIn()、Sytem.setOut()和System.runFinalizersOnExit()等。</p><p>[1]这种划分方法也是Brian Goetz在IBM developWorkers上发表的一篇论文中提出的，这里写“我们”纯粹是笔者下笔行文中的语言用法。</p><h3 id="2-2-线程安全的实现方法"><a href="#2-2-线程安全的实现方法" class="headerlink" title="2.2 线程安全的实现方法"></a><strong>2.2 线程安全的实现方法</strong></h3><p>&emsp;&emsp;了解了什么是线程安全之后，紧接着的一个问题就是我们应该如何实现线程安全，这听起来似乎是一件由代码如何编写来决定的事情，确实，如何实现线程安全与代码编写有很大的关系，但虚拟机提供的同步和锁机制也起到了非常重要的作用。本节中，代码编写如何实现线程安全和虚拟机如何实现同步与锁这两者都会有所涉及，相对而言更偏重后者一些，只要读者了解了虚拟机线程安全手段的运作过程，自己去思考代码如何编写并不是一件困难的事情。</p><h3 id="2-2-1-互斥同步"><a href="#2-2-1-互斥同步" class="headerlink" title="2.2.1 互斥同步"></a><strong>2.2.1 互斥同步</strong></h3><p>&emsp;&emsp;互斥同步（Mutual Exclusion＆Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p><p>&emsp;&emsp;在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。</p><p>&emsp;&emsp;根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p><p>&emsp;&emsp;在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。第12章讲过，Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中一个重量级（Heavyweight）的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。</p><p>&emsp;&emsp;除了synchronized之外，我们还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁（ReentrantLock）来实现同步，在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。不过，相比synchronized,ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p><p>&emsp;&emsp;等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</p><p>&emsp;&emsp;公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p><p>&emsp;&emsp;锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。</p><p>&emsp;&emsp;如果需要使用上述功能，选用ReentrantLock是一个很好的选择，那如果是基于性能考虑呢？关于synchronized和ReentrantLock的性能问题，Brian Goetz对这两种锁在JDK 1.5与单核处理器，以及JDK 1.5与双Xeon处理器环境下做了一组吞吐量对比的实验[1]，实验结果如图13-1和图13-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010233.png" alt="JDK 1.5、单核处理器下两种锁的吞吐量对比"></p><p>&emsp;&emsp;从图13-1和图13-2可以看出，多线程环境下synchronized的吞吐量下降得非常严重，而ReentrantLock则能基本保持在同一个比较稳定的水平上。与其说ReentrantLock性能好，还不如说synchronized还有非常大的优化余地。后续的技术发展也证明了这一点，JDK 1.6中加入了很多针对锁的优化措施（13.3节我们就会讲解这些优化措施），JDK 1.6发布之后，人们就发现synchronized与ReentrantLock的性能基本上是完全持平了。因此，如果读者的程序是使用JDK 1.6或以上部署的话，性能因素就不再是选择ReentrantLock的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010234.png" alt="JDK 1.5、双Xeon处理器下两种锁的吞吐量对比"></p><h3 id="2-2-2-非阻塞同步"><a href="#2-2-2-非阻塞同步" class="headerlink" title="2.2.2 非阻塞同步"></a><strong>2.2.2 非阻塞同步</strong></h3><p>&emsp;&emsp;互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><p>&emsp;&emsp;为什么笔者说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：</p><blockquote><ul><li>测试并设置（Test-and-Set）。</li><li>获取并增加（Fetch-and-Increment）。</li><li>交换（Swap）。</li><li>比较并交换（Compare-and-Swap，下文称CAS）。</li><li>加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）。</li></ul></blockquote><p>&emsp;&emsp;其中，前面的3条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能是类似的。在IA64、x86指令集中有cmpxchg指令完成CAS功能，在sparc-TSO也有casa指令实现，而在ARM和PowerPC架构下，则需要使用一对ldrex/strex指令来完成LL/SC的功能。</p><p>&emsp;&emsp;CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。</p><p>&emsp;&emsp;在JDK 1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了[2]。</p><p>&emsp;&emsp;由于Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的Class才能访问它），因此，如果不采用反射手段，我们只能通过其他的Java API来间接使用它，如J.U.C包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作。</p><p>&emsp;&emsp;我们不妨拿一段在第12章中没有解决的问题代码来看看如何使用CAS操作来避免阻塞同步，代码如代码清单12-1所示。我们曾经通过这段20个线程自增10000次的代码来证明volatile变量不具备原子性，那么如何才能让它具备原子性呢？把“race++”操作或increase()方法用同步块包裹起来当然是一个办法，但是如果改成如代码清单13-4所示的代码，那效率将会提高许多。</p><p>&emsp;&emsp;代码清单13-4 Atomic的原子自增运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomic变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger race = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        race.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread[]threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; THREADS_COUNT;i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用AtomicInteger代替int后，程序输出了正确的结果，一切都要归功于incrementAndGet()方法的原子性。它的实现其实非常简单，如代码清单13-5所示。</p><p>&emsp;&emsp;代码清单13-5 incrementAndGet()方法的JDK源码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *Atomically increment by one the current value.</span></span><br><span class="line"><span class="comment"> *@return the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> incrementAndGet()&#123;</span><br><span class="line">    <span class="keyword">for</span>(;)&#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">next</span> = current+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current,<span class="keyword">next</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;incrementAndGet()方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋给自己。如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止。</p><p>&emsp;&emsp;尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><h3 id="2-2-3-无同步方案"><a href="#2-2-3-无同步方案" class="headerlink" title="2.2.3 无同步方案"></a><strong>2.2.3 无同步方案</strong></h3><p>&emsp;&emsp;要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。</p><p>&emsp;&emsp;可重入代码（Reentrant Code）：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p><p>&emsp;&emsp;可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p><p>&emsp;&emsp;线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>&emsp;&emsp;符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>&emsp;&emsp;Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec（thread）[3]这样的关键字，不过还是可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</p><p>[1]本例中的数据及图片来源于Brian Goetz为IBM developerWorks撰写的论文：《Java theory and practice：More flexible,scalable locking in JDK 5.0》，原文地址是：<a href="http://www.ibm.com/developerworks/java/library/j-jtp10264/?S_TACT=105AGX52＆S_CMP=cna-j。" target="_blank" rel="noopener">http://www.ibm.com/developerworks/java/library/j-jtp10264/?S_TACT=105AGX52＆S_CMP=cna-j。</a><br>[2]这种被虚拟机特殊处理的方法称为固有函数（Intrinsics），类似的固有函数还有Math.sin()等。<br>[3]在Visual C++中是“<strong>declspec（thread）”关键字，而在GCC中是“</strong>thread”。</p><hr><h2 id="第三节-锁优化"><a href="#第三节-锁优化" class="headerlink" title="第三节 锁优化"></a><strong>第三节 锁优化</strong></h2><p>&emsp;&emsp;高效并发是从JDK 1.5到JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><h3 id="3-1-自旋锁与自适应自旋"><a href="#3-1-自旋锁与自适应自旋" class="headerlink" title="3.1 自旋锁与自适应自旋"></a><strong>3.1 自旋锁与自适应自旋</strong></h3><p>&emsp;&emsp;前面我们讨论互斥同步的时候，提到了互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>&emsp;&emsp;自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX：+UseSpinning参数来开启，在JDK 1.6中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX：PreBlockSpin来更改。</p><p>&emsp;&emsp;在JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。</p><h3 id="3-2-锁消除"><a href="#3-2-锁消除" class="headerlink" title="3.2 锁消除"></a><strong>3.2 锁消除</strong></h3><p>&emsp;&emsp;锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p><p>&emsp;&emsp;也许读者会有疑问，变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢？答案是有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。我们来看看代码清单13-6中的例子，这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p><p>&emsp;&emsp;代码清单13-6 一段看起来没有同步的代码</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> <span class="keyword">String </span>concatString(<span class="keyword">String </span><span class="built_in">s1</span>, <span class="keyword">String </span><span class="built_in">s2</span>, <span class="keyword">String </span><span class="built_in">s3</span>)&#123;</span><br><span class="line">    return <span class="built_in">s1</span>+<span class="built_in">s2</span>+<span class="built_in">s3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们也知道，由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编译器会对String连接做自动优化。在JDK 1.5之前，会转化为StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuilder对象的连续append()操作，即代码清单13-6中的代码可能会变成代码清单13-7的样子[1]。</p><p>&emsp;&emsp;代码清单13-7 Javac转化后的字符串连接操作</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> <span class="keyword">String </span>concatString(<span class="keyword">String </span><span class="built_in">s1</span>, <span class="keyword">String </span><span class="built_in">s2</span>, <span class="keyword">String </span><span class="built_in">s3</span>)&#123;</span><br><span class="line">    <span class="keyword">StringBuffer </span><span class="built_in">sb</span> = new <span class="keyword">StringBuffer();</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">sb</span>.append(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">sb</span>.append(<span class="built_in">s2</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">sb</span>.append(<span class="built_in">s3</span>)<span class="comment">;</span></span><br><span class="line">    return <span class="built_in">sb</span>.toString()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在大家还认为这段代码没有涉及同步吗？每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，很快就会发现它的动态作用域被限制在concatString()方法内部。也就是说，sb的所有引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p><p>[1]客观地说，既然谈到锁消除与逃逸分析，那虚拟机就不可能是JDK 1.5之前的版本，实际上会转化为非线程安全的StringBuilder来完成字符串拼接，并不会加锁，但这也不影响笔者用这个例子证明Java对象中同步的普遍性。</p><h3 id="3-3-锁粗化"><a href="#3-3-锁粗化" class="headerlink" title="3.3 锁粗化"></a><strong>3.3 锁粗化</strong></h3><p>&emsp;&emsp;原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p><p>&emsp;&emsp;大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p>&emsp;&emsp;代码清单13-7中连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以代码清单13-7为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。</p><h3 id="3-4-轻量级锁"><a href="#3-4-轻量级锁" class="headerlink" title="3.4 轻量级锁"></a><strong>3.4 轻量级锁</strong></h3><p>&emsp;&emsp;轻量级锁是JDK 1.6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>&emsp;&emsp;要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。</p><p>&emsp;&emsp;对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32bit空间中的25bit用于存储对象哈希码（HashCode），4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表13-1。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010235.png" alt="HotSpot虚拟机对象头Mark Word"></p><p>&emsp;&emsp;简单地介绍了对象的内存布局后，我们把话题返回到轻量级锁的执行过程上。在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3所示。</p><p>&emsp;&emsp;然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图13-4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010236.png" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010237.png" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p><p>&emsp;&emsp;如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p><p>&emsp;&emsp;上面描述的是轻量级锁的加锁过程，它的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p><p>&emsp;&emsp;轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><p>[1]图13-3和图13-4来源于HotSpot虚拟机的一位Senior Staff Engineer——Paul Hohensee所写的PPT“The Hotspot Java Virtual Machine”。</p><h3 id="3-5-偏向锁"><a href="#3-5-偏向锁" class="headerlink" title="3.5 偏向锁"></a><strong>3.5 偏向锁</strong></h3><p>&emsp;&emsp;偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p><p>&emsp;&emsp;偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>&emsp;&emsp;如果读者读懂了前面轻量级锁中关于对象头Mark Word与线程之间的操作过程，那偏向锁的原理理解起来就会很简单。假设当前虚拟机启用了偏向锁（启用参数-XX：+UseBiasedLocking，这是JDK 1.6的默认值），那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking、Unlocking及对Mark Word的Update等）。</p><p>&emsp;&emsp;当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图13-5所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010237.png" alt="偏向锁、轻量级锁的状态转化及对象Mark Word的关系"></p><p>&emsp;&emsp;偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p><hr><h2 id="第四节-总结"><a href="#第四节-总结" class="headerlink" title="第四节 总结"></a><strong>第四节 总结</strong></h2><p>&emsp;&emsp;本章介绍了线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运作原理，并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。</p><p>&emsp;&emsp;许多资深的程序员都说过，能够写出高伸缩性的并发程序是一门艺术，而了解并发在系统底层是如何实现的，则是掌握这门艺术的前提条件，也是成长为高级程序员的必备知识之一。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的线程安全和锁优化，包括：概述，线程安全（Java语言中的线程安全、线程安全的实现方法），锁优化（自旋锁与自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型和线程</title>
    <link href="http://linyishui.top/2019122701.html"/>
    <id>http://linyishui.top/2019122701.html</id>
    <published>2019-12-27T07:31:02.000Z</published>
    <updated>2020-01-14T08:29:41.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java内存模型和线程"><a href="#Java内存模型和线程" class="headerlink" title="Java内存模型和线程"></a><strong>Java内存模型和线程</strong></h1><p>&emsp;&emsp;并发处理的广泛应用是使得Amdahl定律代替摩尔定律[1]成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。</p><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的浪费，而让计算机同时处理几项任务则是最容易想到、也被证明是非常有效的“压榨”手段。</p><p>&emsp;&emsp;除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second,TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。</p><p>&emsp;&emsp;服务端是Java语言最擅长的领域之一，这个领域的应用占了Java应用中最大的一块份额[2]，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持。幸好Java语言和虚拟机提供了许多工具，把并发编程的门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员处理尽可能多的线程并发细节，使得程序员在编码时能更关注业务逻辑，而不是花费大部分时间去关注此服务会同时被多少人调用、如何协调硬件资源。无论语言、中间件和框架如何先进，开发人员都不能期望它们能独立完成所有并发处理的事情，了解并发的内幕也是成为一个高级程序员不可缺少的课程。</p><p>&emsp;&emsp;“高效并发”是本书讲解Java虚拟机的最后一部分，将会向读者介绍虚拟机如何实现多线程、多线程之间由于共享和竞争数据而导致的一系列问题及解决方案。</p><p>[1]Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力，摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系。这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程。</p><p>[2]必须以代码的总体规模来衡量，服务端应用不能与JavaCard、移动终端这些领域去比绝对数量。</p><hr><h2 id="第二节-硬件的效率与一致性"><a href="#第二节-硬件的效率与一致性" class="headerlink" title="第二节 硬件的效率与一致性"></a><strong>第二节 硬件的效率与一致性</strong></h2><p>&emsp;&emsp;在正式讲解Java虚拟机并发相关的知识之前，我们先花费一点时间去了解一下物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p><p>&emsp;&emsp;“让计算机并发执行若干个运算任务”与“更充分地利用计算机处理器的效能”之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p>&emsp;&emsp;基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如图12-1所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。在本章中将会多次提到的“内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010226.png" alt="处理器、高速缓存、主内存间的交互关系"></p><p>&emsp;&emsp;除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。</p><hr><h2 id="第三节-Java内存模型"><a href="#第三节-Java内存模型" class="headerlink" title="第三节 Java内存模型"></a><strong>第三节 Java内存模型</strong></h2><p>&emsp;&emsp;Java虚拟机规范中试图定义一种Java内存模型[1]（Java Memory Model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。</p><p>&emsp;&emsp;定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在JDK 1.5（实现了JSR-133[2]）发布后，Java内存模型已经成熟和完善起来了。</p><h3 id="3-1-主内存与工作内存"><a href="#3-1-主内存与工作内存" class="headerlink" title="3.1 主内存与工作内存"></a><strong>3.1 主内存与工作内存</strong></h3><p>&emsp;&emsp;Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的[3]，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p><p>&emsp;&emsp;Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝[4]，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量[5]。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图12-2所示。</p><p>&emsp;&emsp;这里所讲的主内存、工作内存与本书第2章所讲的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分[6]，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010227.png" alt="线程、主内存、工作内存三者的交互关系（请与图12-1对比）"></p><p>[1]本书中的Java内存模型都特指目前正在使用的，即在JDK 1.2之后建立起来并在JDK 1.5中完备过的内存模型。<br>[2]JSR-133：Java Memory Model and Thread Specification Revision（Java内存模型和线程规范修订）。<br>[3]此处请读者注意区分概念：如果局部变量是一个reference类型，它引用的对象在Java堆中可被各个线程共享，但是reference本身在Java栈的局部变量表中，它是线程私有的。<br>[4]有不少读者会对这段描述中的“拷贝副本”提出疑问，如“假设线程中访问一个10MB的对象，也会把这10MB的内存复制一份拷贝出来吗？”，事实上并不会如此，这个对象的引用、对象中某个在线程访问到的字段是有可能存在拷贝的，但不会有虚拟机实现成把整个对象拷贝A一次。<br>[5]根据Java虚拟机规范的规定，volatile变量依然有工作内存的拷贝，但是由于它特殊的操作顺序性规定（后文会讲到），所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于volatile也并不存在例外。<br>[6]除了实例数据，Java堆还保存了对象的其他信息，对于HotSpot虚拟机来讲，有Mark Word（存储对象哈希码、GC标志、GC年龄、同步锁等信息）、Klass Point（指向存储类型元数据的指针）及一些用于字节对齐补白的填充数据（如果实例数据刚好满足8字节对齐的话，则可以不存在补白）。</p><h3 id="3-2-内存间交互操作"><a href="#3-2-内存间交互操作" class="headerlink" title="3.2 内存间交互操作"></a><strong>3.2 内存间交互操作</strong></h3><p>&emsp;&emsp;关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，这个问题在12.3.4节再讲）[1]。</p><blockquote><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul></blockquote><p>&emsp;&emsp;如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><blockquote><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li></ul></blockquote><p>&emsp;&emsp;这8种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以在12.3.6节中笔者将介绍这种定义的一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。</p><h3 id="3-3-对于volatile型变量的特殊规则"><a href="#3-3-对于volatile型变量的特殊规则" class="headerlink" title="3.3 对于volatile型变量的特殊规则"></a><strong>3.3 对于volatile型变量的特殊规则</strong></h3><p>&emsp;&emsp;关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在本节中我们将多花费一些时间去弄清楚volatile的语义到底是什么。</p><p>&emsp;&emsp;Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。</p><p>&emsp;&emsp;当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</p><p>&emsp;&emsp;关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因，请看代码清单12-1中演示的例子。</p><p>&emsp;&emsp;代码清单12-1 volatile的运算</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolatileTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[]args</span>)</span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; THREADS_COUNT;i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.<span class="keyword">out</span>.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？</p><p>&emsp;&emsp;问题就出现在自增运算“race++”之中，我们用Javap反编译这段代码后会得到代码清单12-2，发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成的（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。</p><p>&emsp;&emsp;代码清单12-2 VolatileTest的字节码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> increase();</span><br><span class="line">    Code: </span><br><span class="line">        Stack=<span class="number">2</span>，Locals=<span class="number">0</span>，Args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: getstatic#<span class="number">13</span>;<span class="comment">//Field race: I</span></span><br><span class="line">        <span class="number">3</span>: iconst_1</span><br><span class="line">        <span class="number">4</span>: iadd</span><br><span class="line">        <span class="number">5</span>: putstatic#<span class="number">13</span>;<span class="comment">//Field race: I</span></span><br><span class="line">        <span class="number">8</span>: <span class="built_in">return</span></span><br><span class="line">    LineNumberTable: </span><br><span class="line">        <span class="built_in">line</span> <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        <span class="built_in">line</span> <span class="number">15</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客观地说，笔者在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令，此处使用-XX：+PrintAssembly参数输出反汇编来分析会更加严谨一些，但考虑到读者阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析。</p><p>&emsp;&emsp;由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p><p>&emsp;&emsp;运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p><p>&emsp;&emsp;变量不需要与其他的状态变量共同参与不变约束。</p><p>&emsp;&emsp;而在像如下的代码清单12-3所示的这类场景就很适合使用volatile变量来控制并发，当shutdown()方法被调用时，能保证所有线程中执行的doWork()方法都立即停下来。</p><p>&emsp;&emsp;代码清单12-3 volatile的使用场景</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">    shutdownRequested=<span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>（!shutdownRequested）&#123;</span><br><span class="line">        <span class="comment">//do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。</p><p>&emsp;&emsp;上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码清单12-4所示。</p><p>&emsp;&emsp;代码清单12-4 指令重排序</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> configOptions;</span><br><span class="line">char[]configText;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此变量必须定义为volatile</span></span><br><span class="line">volatile boolean initialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">//模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="function"><span class="keyword">new</span> <span class="title">HashMap</span>();</span></span><br><span class="line"><span class="function"><span class="title">configText</span> = <span class="title">readConfigFile</span>(fileName);</span></span><br><span class="line"><span class="function"><span class="title">processConfigOptions</span>(configText,configOptions);</span></span><br><span class="line"><span class="function"><span class="title">initialized</span> = <span class="title">true</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//假设以下代码在线程B中执行</span></span></span><br><span class="line"><span class="function"><span class="comment">//等待initialized为true，代表线程A已经把配置信息初始化完成</span></span></span><br><span class="line"><span class="function"><span class="title">while</span>(!initialized)&#123;</span></span><br><span class="line"><span class="function">    <span class="title">sleep</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//使用线程A中初始化好的配置信息</span></span></span><br><span class="line"><span class="function"><span class="title">doSomethingWithConfig</span>();</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单12-4中的程序是一段伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码“initialized=true”被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生[1]。</p><p>&emsp;&emsp;指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，笔者再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。代码清单12-5是一段标准的DCL单例代码，可以观察加入volatile和未加入volatile关键字时所生成汇编代码的差别（如何获得JIT的汇编代码，请参考4.2.7节）。</p><p>&emsp;&emsp;代码清单12-5 DCL单例模式</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                   <span class="built_in"> instance </span>= new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译后，这段代码对instance变量赋值部分如代码清单12-6所示。</p><p>&emsp;&emsp;代码清单12-6</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01a3de0f</span>：mov$<span class="number">0x3375cdb0</span>, %esi;......beb0cd75 <span class="number">33</span>;&#123;oop(<span class="string">'Singleton'</span>)&#125;</span><br><span class="line"><span class="number">0x01a3de14</span>：mov%eax, <span class="number">0x150</span>(%esi);......<span class="number">89865001</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0x01a3de1a</span>：shr$<span class="number">0x9</span>, %esi;......c1ee09</span><br><span class="line"><span class="number">0x01a3de1d</span>：movb$<span class="number">0x0</span>, <span class="number">0x1104800</span>(%esi);......c6860048 <span class="number">100100</span></span><br><span class="line"><span class="number">0x01a3de24</span>：lock addl$<span class="number">0x0</span>, (%esp);......f0830424 <span class="number">00</span>;*putstatic <span class="keyword">instance</span>;-Singleton：getInstance@<span class="number">24</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过对比就会发现，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150（%esi）这句便是赋值操作）多执行了一个“lock addl ＄0x0，（%esp）”操作，这个操作相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。这句指令中的“addl ＄0x0，（%esp）”（把ESP寄存器的值加0）显然是一个空操作（采用这个空操作而不是空操作指令nop是因为IA32手册规定lock前缀不允许配合nop指令使用），关键在于lock前缀，查询IA32手册，它的作用是使得本CPU的Cache写入了内存，该写入动作也会引起别的CPU或者别的内核无效化（Invalidate）其Cache，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作[2]。所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。</p><p>&emsp;&emsp;那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——（A+10）<em>2与A</em>2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可。所以在本内CPU中，重排序看起来依然是有序的。因此，lock addl＄0x0，（%esp）指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。</p><p>&emsp;&emsp;解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。</p><p>&emsp;&emsp;在本节的最后，我们回头看一下Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：</p><p>&emsp;&emsp;只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值）。</p><p>&emsp;&emsp;只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改）。</p><p>&emsp;&emsp;假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）。</p><p>[1]volatile屏蔽指令重排序的语义在JDK 1.5中才被完全修复，此前的JDK中即使将变量声明为volatile也仍然不能完全避免重排序所导致的问题（主要是volatile变量前后的代码仍然存在重排序问题），这点也是在JDK 1.5之前的Java中无法安全地使用DCL（双锁检测）来实现单例模式的原因。</p><p>[2]Doug Lea列出了各种处理器架构下的内存屏障指令：<a href="http://g.oswego.edu/dl/jmm/cookbook.html。" target="_blank" rel="noopener">http://g.oswego.edu/dl/jmm/cookbook.html。</a></p><h3 id="3-4-对于long和double型变量的特殊规则"><a href="#3-4-对于long和double型变量的特殊规则" class="headerlink" title="3.4 对于long和double型变量的特殊规则"></a><strong>3.4 对于long和double型变量的特殊规则</strong></h3><p>&emsp;&emsp;Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定（Nonatomic Treatment ofdouble and long Variables）。</p><p>&emsp;&emsp;如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。</p><p>&emsp;&emsp;不过这种读取到“半个变量”的情况非常罕见（在目前商用Java虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。</p><h3 id="3-5-原子性、可见性与有序性"><a href="#3-5-原子性、可见性与有序性" class="headerlink" title="3.5 原子性、可见性与有序性"></a><strong>3.5 原子性、可见性与有序性</strong></h3><p>&emsp;&emsp;介绍完Java内存模型的相关操作和规则，我们再整体回顾一下这个模型的特征。Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，我们逐个来看一下哪些操作实现了这3个特性。</p><blockquote><ul><li>原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。<br>&emsp;&emsp;&emsp;&emsp;如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</li><li>可见性（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。上文在讲解volatile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。<br>&emsp;&emsp;&emsp;&emsp;除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。如代码清单12-7所示，变量i与j都具备可见性，它们无须同步就能被其他线程正确访问。</li></ul></blockquote><p>&emsp;&emsp;代码清单12-7 final与可见性</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//也可以选择在构造函数中初始化</span></span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>有序性（Ordering）：Java内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li></ul></blockquote><p>&emsp;&emsp;Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p><p>&emsp;&emsp;介绍完并发中3种重要的特性后，读者有没有发现synchronized关键字在需要这3种特性的时候都可以作为其中一种的解决方案？看起来很“万能”吧。的确，大部分的并发控制操作都能使用synchronized来完成。synchronized的“万能”也间接造就了它被程序员滥用的局面，越“万能”的并发控制，通常会伴随着越大的性能影响，这点我们将在第13章讲解虚拟机锁优化时再介绍。</p><h3 id="3-6-先行发生原则"><a href="#3-6-先行发生原则" class="headerlink" title="3.6 先行发生原则"></a><strong>3.6 先行发生原则</strong></h3><p>&emsp;&emsp;如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><p>&emsp;&emsp;现在就来看看“先行发生”原则指的是什么。先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。这句话不难理解，但它意味着什么呢？我们可以举个例子来说明一下，如代码清单12-8中所示的这3句伪代码。</p><p>&emsp;&emsp;代码清单12-8 先行发生原则示例1</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//以下操作在线程A中执行</span><br><span class="line"><span class="attribute">i</span>=<span class="number">1</span><span class="comment">;</span></span><br><span class="line">//以下操作在线程B中执行</span><br><span class="line"><span class="attribute">j</span>=i<span class="comment">;</span></span><br><span class="line">//以下操作在线程C中执行</span><br><span class="line"><span class="attribute">i</span>=<span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设线程A中的操作“i=1”先行发生于线程B的操作“j=i”，那么可以确定在线程B的操作执行后，变量j的值一定等于1，得出这个结论的依据有两个：一是根据先行发生原则，“i=1”的结果可以被观察到；二是线程C还没“登场”，线程A操作结束之后没有其他线程会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和线程B之间的先行发生关系，而线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少呢？答案是不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备多线程安全性。</p><p>&emsp;&emsp;下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p><blockquote><ul><li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li><li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li><li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li><li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li><li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul></blockquote><p>&emsp;&emsp;Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些了，笔者演示一下如何使用这些规则去判定操作间是否具备顺序性，对于读写共享变量的操作来说，就是线程是否安全，读者还可以从下面这个例子中感受一下“时间上的先后顺序”与“先行发生”之间有什么不同。演示例子如代码清单12-9所示。</p><p>&emsp;&emsp;代码清单12-9 先行发生原则示例2</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span>=<span class="number">0</span>；</span><br><span class="line">pubilc <span class="keyword">void</span> setValue（<span class="keyword">int</span> <span class="keyword">value</span>）&#123;</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">value</span>=<span class="keyword">value</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单12-9中显示的是一组再普通不过的getter/setter方法，假设存在线程A和B，线程A先（时间上的先后）调用了“setValue（1）”，然后线程B调用了同一个对象的“getValue()”，那么线程B收到的返回值是什么？</p><p>&emsp;&emsp;我们依次分析一下先行发生原则中的各项规则，由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定尽管线程A在操作时间上先于线程B，但是无法确定线程B中“getValue()”方法的返回结果，换句话说，这里面的操作不是线程安全的。</p><p>&emsp;&emsp;那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系。</p><p>&emsp;&emsp;通过上面的例子，我们可以得出结论：一个操作“时间上的先发生”不代表这个操作会是“先行发生”，那如果一个操作“先行发生”是否就能推导出这个操作必定是“时间上的先发生”呢？很遗憾，这个推论也是不成立的，一个典型的例子就是多次提到的“指令重排序”，演示例子如代码清单12-10所示。</p><p>&emsp;&emsp;代码清单12-10 先行发生原则示例3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下操作在同一个线程中执行</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">2</span>；</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单12-10的两条赋值语句在同一个线程之中，根据程序次序规则，“int i=1”的操作先行发生于“int j=2”，但是“int j=2”的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这点。</p><p>&emsp;&emsp;上面两个例子综合起来证明了一个结论：时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p><hr><h2 id="第四节-Java与线程"><a href="#第四节-Java与线程" class="headerlink" title="第四节 Java与线程"></a><strong>第四节 Java与线程</strong></h2><p>&emsp;&emsp;并发不一定要依赖多线程（如PHP中很常见的多进程并发），但是在Java里面谈论并发，大多数都与线程脱不开关系。既然我们这本书探讨的话题是Java虚拟机的特性，那讲到Java线程，我们就从Java线程在虚拟机中的实现开始讲起。</p><h3 id="4-1-线程的实现"><a href="#4-1-线程的实现" class="headerlink" title="4.1 线程的实现"></a><strong>4.1 线程的实现</strong></h3><p>&emsp;&emsp;我们知道，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。</p><p>&emsp;&emsp;主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start()且还未结束的java.lang.Thread类的实例就代表了一个线程。我们注意到Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。在Java API中，一个Native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用Native方法，不过，通常最高效率的手段也就是平台相关的手段）。正因为如此，作者把本节的标题定为“线程的实现”而不是“Java线程的实现”。</p><p>&emsp;&emsp;实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p><h4 id="4-1-1-使用内核线程实现"><a href="#4-1-1-使用内核线程实现" class="headerlink" title="4.1.1 使用内核线程实现"></a><strong>4.1.1 使用内核线程实现</strong></h4><p>&emsp;&emsp;内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（MultiThreads Kernel）。</p><p>&emsp;&emsp;程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型，如图12-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010228.png" alt="轻量级进程与内核线程之间1:1的关系"></p><p>&emsp;&emsp;由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</p><h4 id="4-1-2-使用用户线程实现"><a href="#4-1-2-使用用户线程实现" class="headerlink" title="4.1.2 使用用户线程实现"></a><strong>4.1.2 使用用户线程实现</strong></h4><p>&emsp;&emsp;从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程（User Thread,UT），因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。</p><p>&emsp;&emsp;而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型，如图12-4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010229.png" alt="进程与用户线程之间1：N的关系"></p><p>&emsp;&emsp;使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。因而使用用户线程实现的程序一般都比较复杂[1]，除了以前在不支持多线程的操作系统中（如DOS）的多线程程序与少数有特殊需求的程序外，现在使用用户线程的程序越来越少了，Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它。</p><h4 id="4-1-3-使用用户线程加轻量级进程混合实现"><a href="#4-1-3-使用用户线程加轻量级进程混合实现" class="headerlink" title="4.1.3 使用用户线程加轻量级进程混合实现"></a><strong>4.1.3 使用用户线程加轻量级进程混合实现</strong></h4><p>&emsp;&emsp;线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系，如图12-5所示，这种就是多对多的线程模型。</p><p>&emsp;&emsp;许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了N：M的线程模型实现</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010230.png" alt="用户线程与轻量级进程之间N：M的关系"></p><h4 id="4-1-4-Java线程的实现"><a href="#4-1-4-Java线程的实现" class="headerlink" title="4.1.4 Java线程的实现"></a><strong>4.1.4 Java线程的实现</strong></h4><p>&emsp;&emsp;Java线程在JDK 1.2之前，是基于称为“绿色线程”（Green Threads）的用户线程实现的，而在JDK 1.2中，线程模型替换为基于操作系统原生线程模型来实现。因此，在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是透明的。</p><p>&emsp;&emsp;对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的[2]。</p><p>&emsp;&emsp;而在Solaris平台中，由于操作系统的线程特性可以同时支持一对一（通过Bound Threads或Alternate Libthread实现）及多对多（通过LWP/Thread Based Synchronization实现）的线程模型，因此在Solaris版的JDK中也对应提供了两个平台专有的虚拟机参数：-XX：+UseLWPSynchronization（默认值）和-XX：+UseBoundThreads来明确指定虚拟机使用哪种线程模型。</p><p>[1]此处所讲的“复杂”与“程序自己完成线程操作”，并不限制程序中必须编写了复杂的实现用户线程的代码，使用用户线程的程序，很多都依赖特定的线程库来完成基本的线程操作，这些复杂性都封装在线程库之中。</p><p>[2]Windows下有纤程包（Fiber Package），Linux下也有NGPT（在2.4内核的年代）来实现N：M模型，但是它们都没有成为主流。</p><h3 id="4-2-Java线程调度"><a href="#4-2-Java线程调度" class="headerlink" title="4.2 Java线程调度"></a><strong>4.2 Java线程调度</strong></h3><p>&emsp;&emsp;线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive ThreadsScheduling）。</p><p>&emsp;&emsp;如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。Lua语言中的“协同例程”就是这类实现。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。很久以前的Windows 3.x系统就是使用协同式来实现多进程多任务的，相当不稳定，一个进程坚持不让出CPU执行时间就可能会导致整个系统崩溃。</p><p>&emsp;&emsp;如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度[1]。与前面所说的Windows 3.x的例子相对，在Windows 9x/NT内核中就是使用抢占式来实现多进程的，当一个进程出了问题，我们还可以使用任务管理器把这个进程“杀掉”，而不至于导致系统崩溃。</p><p>&emsp;&emsp;虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p><p>&emsp;&emsp;不过，线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应，如Solaris中有2147483648（232）种优先级，但Windows中就只有7种，比Java线程优先级多的系统还好说，中间留下一点空位就可以了，但比Java线程优先级少的系统，就不得不出现几个优先级相同的情况了，表12-1显示了Java线程优先级与Windows线程优先级之间的对应关系，Windows平台的JDK中使用了除THREAD_PRIORITY_IDLE之外的其余6种线程优先级。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010231.png" alt="Java线程优先级与Windows线程优先级之间的对应关系"></p><p>&emsp;&emsp;上文说到“线程优先级并不是太靠谱”，不仅仅是说在一些平台上不同的优先级实际会变得相同这一点，还有其他情况让我们不能太依赖优先级：优先级可能会被系统自行改变。例如，在Windows系统中存在一个称为“优先级推进器”（Priority Boosting，当然它可以被关闭掉）的功能，它的大致作用就是当系统发现一个线程执行得特别“勤奋努力”的话，可能会越过线程优先级去为它分配执行时间。因此，我们不能在程序中通过优先级来完全准确地判断一组状态都为Ready的线程将会先执行哪一个。</p><h3 id="4-3-状态转换"><a href="#4-3-状态转换" class="headerlink" title="4.3 状态转换"></a><strong>4.3 状态转换</strong></h3><p>&emsp;&emsp;Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下。</p><blockquote><ul><li>新建（New）：创建后尚未启动的线程处于这种状态。</li><li>运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</li><li>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：<br>&emsp;&emsp;&emsp;&emsp;● 没有设置Timeout参数的Object.wait()方法。<br>&emsp;&emsp;&emsp;&emsp;● 没有设置Timeout参数的Thread.join()方法。<br>&emsp;&emsp;&emsp;&emsp;● LockSupport.park()方法。</li><li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<br>&emsp;&emsp;&emsp;&emsp;● Thread.sleep()方法。<br>&emsp;&emsp;&emsp;&emsp;● 设置了Timeout参数的Object.wait()方法。<br>&emsp;&emsp;&emsp;&emsp;● 设置了Timeout参数的Thread.join()方法。<br>&emsp;&emsp;&emsp;&emsp;● LockSupport.parkNanos()方法。<br>&emsp;&emsp;&emsp;&emsp;● LockSupport.parkUntil()方法。</li><li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul></blockquote><p>&emsp;&emsp;上述5种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如图12-6所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010232.png" alt="线程状态转换关系"></p><hr><h2 id="第五节-总结"><a href="#第五节-总结" class="headerlink" title="第五节 总结"></a><strong>第五节 总结</strong></h2><p>&emsp;&emsp;本章中，我们首先了解了虚拟机Java内存模型的结构及操作，然后讲解了原子性、可见性、有序性在Java内存模型中的体现，最后介绍了先行发生原则的规则及使用。另外，我们还了解了线程在Java语言之中是如何实现的。</p><p>&emsp;&emsp;关于“高效并发”这个话题，在本章中主要介绍了虚拟机如何实现“并发”，在第13章中，我们的主要关注点将是虚拟机如何实现“高效”，以及虚拟机对我们编写的并发代码提供了什么样的优化手段。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的Java内存模型和线程，包括：概述，硬件的效率与一致性，Java内存模型（主内存与工作内存、内存间交互操作、对于volatile型变量的特殊规则、对于long和double型变量的特殊规则、原子性、可见性与有序性、先行发生原则），Java与线程（线程的实现、Java线程调度、状态转换），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>运行期优化</title>
    <link href="http://linyishui.top/2019122501.html"/>
    <id>http://linyishui.top/2019122501.html</id>
    <published>2019-12-25T10:34:48.000Z</published>
    <updated>2020-01-14T07:42:51.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a><strong>运行期优化</strong></h1><p>&emsp;&emsp;从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。</p><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;在部分的商用虚拟机（Sun HotSpot、IBM J9）中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文中简称JIT编译器）。</p><p>&emsp;&emsp;即时编译器并不是虚拟机必需的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器存在，更没有限定或指导即时编译器应该如何去实现。但是，即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。在本章中，我们将走进虚拟机的内部，探索即时编译器的运作过程。</p><p>&emsp;&emsp;由于Java虚拟机规范没有具体的约束规则去限制即时编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现（Implementation Specific）相关的内容，如无特殊说明，本章提及的编译器、即时编译器都是指HotSpot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机。不过，本章的大部分内容是描述即时编译器的行为，涉及编译器实现层面的内容较少，而主流虚拟机中即时编译器的行为又有很多相似和相通之处，因此，对其他虚拟机来说也具有较高的参考意义。</p><hr><h2 id="第二节-HotSpot虚拟机内的即时编译器"><a href="#第二节-HotSpot虚拟机内的即时编译器" class="headerlink" title="第二节 HotSpot虚拟机内的即时编译器"></a><strong>第二节 HotSpot虚拟机内的即时编译器</strong></h2><p>&emsp;&emsp;在本节中，我们将要了解HotSpot虚拟机内的即时编译器的运作过程，同时，还要解决以下几个问题：</p><blockquote><ul><li>为何HotSpot虚拟机要使用解释器与编译器并存的架构？</li><li>为何HotSpot虚拟机要实现两个不同的即时编译器？</li><li>程序何时使用解释器执行？何时使用编译器执行？</li><li>哪些程序代码会被编译为本地代码？如何编译为本地代码？</li><li>如何从外部观察即时编译器的编译过程和编译结果？</li></ul></blockquote><h3 id="2-1-解释器与编译器"><a href="#2-1-解释器与编译器" class="headerlink" title="2.1 解释器与编译器"></a><strong>2.1 解释器与编译器</strong></h3><p>&emsp;&emsp;尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机，如HotSpot、J9等，都同时包含解释器与编译器[1]。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行（部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器[2]担任“逃生门”的角色），因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作，如图11-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010214.png" alt="解释器与编译器的交互"></p><p>&emsp;&emsp;HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器（也叫Opto编译器）。目前主流的HotSpot虚拟机（Sun系列JDK 1.7及之前版本的虚拟机）中，默认采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在Client模式或Server模式。</p><p>&emsp;&emsp;无论采用的编译器是Client Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”（Mixed Mode），用户可以使用参数“-Xint”强制虚拟机运行于“解释模式”（Interpreted Mode），这时编译器完全不介入工作，全部代码都使用解释方式执行。另外，也可以使用参数“-Xcomp”强制虚拟机运行于“编译模式”（Compiled Mode）[3]， 这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程，可以通过虚拟机的“-version”命令的输出结果显示出这3种模式，如代码清单11-1所示，请注意黑体字部分。</p><p>&emsp;&emsp;代码清单11-1　虚拟机执行模式</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;java-version java version<span class="string">"1.6.0_22"</span> </span><br><span class="line">Java(TM)SE Runtime Environment(build 1.6.0_22-b04) </span><br><span class="line">Dynamic Code Evolution 64-Bit </span><br><span class="line">Server VM(build 0.2-b02-internal, 19.0-b04-internal,mixed mode) </span><br><span class="line"></span><br><span class="line">C:\&gt;java-Xint-version java version<span class="string">"1.6.0_22"</span> </span><br><span class="line">Java(TM)SE Runtime Environment(build 1.6.0_22-b04) </span><br><span class="line">Dynamic Code Evolution 64-Bit </span><br><span class="line">Server VM(build 0.2-b02-internal, 19.0-b04-internal,interpreted mode) </span><br><span class="line"></span><br><span class="line">C:\&gt;java-Xcomp-version java version<span class="string">"1.6.0_22"</span> </span><br><span class="line">Java(TM)SE Runtime Environment(build 1.6.0_22-b04) </span><br><span class="line">Dynamic Code Evolution 64-Bit </span><br><span class="line">Server VM(build 0.2-b02-internal, 19.0-b04-internal,compiled mode)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长;而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译（Tiered Compilation）[4]的策略，分层编译的概念在JDK 1.6时期出现，后来一直处于改进阶段，最终在JDK 1.7的Server模式虚拟机中作为默认编译策略被开启。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p><blockquote><ul><li>第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。</li><li>第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。</li><li>第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul></blockquote><p>&emsp;&emsp;实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。</p><h3 id="2-2-编译对象与触发条件"><a href="#2-2-编译对象与触发条件" class="headerlink" title="2.2 编译对象与触发条件"></a><strong>2.2 编译对象与触发条件</strong></h3><p>&emsp;&emsp;上文中提到过，在运行过程中会被即时编译器编译的“热点代码”有两类，即：</p><blockquote><ul><li>被多次调用的方法。</li><li>被多次执行的循环体。</li></ul></blockquote><p>&emsp;&emsp;前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为“热点代码”是理所当然的。而后者则是为了解决一个方法只被调用过一次或少量的几次，但是方法体内部存在循环次数较多的循环体的问题，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”。</p><p>&emsp;&emsp;对于第一种情况，由于是由方法调用触发的编译，因此编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的JIT编译方式。而对于后一种情况，尽管编译动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）作为编译对象。这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为栈上替换（On Stack Replacement，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了）。</p><p>&emsp;&emsp;读者可能还会有疑问，在上面的文字描述中，无论是“多次执行的方法”，还是“多次执行的代码块”，所谓“多次”都不是一个具体、严谨的用语，那到底多少次才算“多次”呢？还有一个问题，就是虚拟机如何统计一个方法或一段代码被执行过多少次呢？解决了这两个问题，也就回答了即时编译被触发的条件。</p><p>&emsp;&emsp;判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测（Hot Spot Detection），其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主要的热点探测判定方式有两种[1]，分别如下。</p><p>&emsp;&emsp;基于采样的热点探测（Sample Based Hot Spot Detection）：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</p><p>&emsp;&emsp;基于计数器的热点探测（Counter Based Hot Spot Detection）：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对来说更加精确和严谨。</p><p>&emsp;&emsp;在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p><p>&emsp;&emsp;在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p><p>&emsp;&emsp;我们首先来看看方法调用计数器。顾名思义，这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次，这个阈值可以通过虚拟机参数-XX:CompileThreshold来人为设定。当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p>&emsp;&emsp;如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。整个JIT编译的交互过程如图11-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010215.png" alt="方法调用计数器触发即时编译"></p><p>&emsp;&emsp;如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><p>&emsp;&emsp;现在我们再来看看另外一个计数器——回边计数器，它的作用是统计一个方法中循环体代码执行的次数[2]，在字节码中遇到控制流向后跳转的指令称为“回边”（BackEdge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p>&emsp;&emsp;关于回边计数器的阈值，虽然HotSpot虚拟机也提供了一个类似于方法调用计数器阈值XX:CompileThreshold的参数-XX:BackEdgeThreshold供用户设置，但是当前的虚拟机实际上并未使用此参数，因此我们需要设置另外一个参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值，其计算公式如下。</p><p>&emsp;&emsp;虚拟机运行在Client模式下，回边计数器阈值计算公式为：</p><blockquote><ul><li>方法调用计数器阈值(CompileThreshold) × OSR比率(OnStackReplacePercentage) / 100 </li><li>其中OnStackReplacePercentage默认值为933，如果都取默认值，那Client模式虚拟机的回边计数器的阈值为13995。 </li></ul></blockquote><p>&emsp;&emsp;虚拟机运行在Server模式下，回边计数器阈值的计算公式为：</p><blockquote><ul><li>方法调用计数器阈值(CompileThreshold) × (OSR比率 (OnStackReplacePercentage) - 解释器监控比率(InterpreterProfilePercentage) / 100 </li><li>其中OnStackReplacePercentage默认值为140，InterpreterProfilePercentage默认值为33，如果都取默认值，那Server模式虚拟机回边计数器的阈值为10700。 </li></ul></blockquote><p>&emsp;&emsp;当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有，它将会优先执行已编译的代码，否则就把回边计数器的值加1，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果，整个执行过程如图11-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010216.png" alt="回边计数器触发即时编译"></p><p>&emsp;&emsp;与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p><p>&emsp;&emsp;最后需要提醒一点，图11-2和图11-3都仅仅描述了Client VM的即时编译方式，对于Server VM来说，执行情况会比上面的描述更复杂一些。从理论上了解过编译对象和编译触发条件后，我们再从HotSpot虚拟机的源码中观察一下，在MethodOop.hpp（一个methodOop对象代表了一个Java方法）中，定义了Java方法在虚拟机中的内存布局，如下所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010217.png" alt="MethodOop.hpp"></p><p>&emsp;&emsp;在这个内存布局中，一行长度为32bit，从中可以清楚地看到方法调用计数器和回边计数器所在的位置和长度。还有from_compiled_entry和from_interpreted_entry这两个方法的入口。</p><h3 id="2-3-编译过程"><a href="#2-3-编译过程" class="headerlink" title="2.3 编译过程"></a><strong>2.3 编译过程</strong></h3><p>&emsp;&emsp;在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。用户可以通过参数-XX:-BackgroundCompilation来禁止后台编译，在禁止后台编译后，一旦达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。</p><p>&emsp;&emsp;那么在后台执行编译的过程中，编译器做了什么事情呢？Server Compiler和Client Compiler两个编译器的编译过程是不一样的。对于Client Compiler来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p><p>&emsp;&emsp;在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（HighLevel Intermediate Representaion,HIR）。HIR使用静态单分配（Static Single Assignment,SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</p><p>&emsp;&emsp;在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation,LIR），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</p><p>&emsp;&emsp;最后阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。Client Compiler的大致执行过程如图11-4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010218.png" alt="Client Compiler架构"></p><p>&emsp;&emsp;而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，如无用代码消除（Dead Code Elimination）、循环展开（Loop Unrolling）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、常量传播（Constant Propagation）、基本块重排序（Basic Block Reordering）等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除（Range Check Elimination）、空值检查消除（Null Check Elimination，不过并非所有的空值检查消除都是依赖编译器优化的，有一些是在代码运行过程中自动优化了）等。另外，还可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化，如守护内联（Guarded Inlining）、分支频率预测（Branch Frequency Prediction）等。本章的下半部分将会挑选上述的一部分优化手段进行分析和讲解。</p><p>&emsp;&emsp;Server Compiler的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构（如RISC）上的大寄存器集合。以即时编译的标准来看，Server Compiler无疑是比较缓慢的，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。</p><p>&emsp;&emsp;在本节中，涉及了许多编译原理和代码优化中的概念名词，没有这方面基础的读者，阅读起来会感觉到抽象和理论化。有这种感觉并不奇怪，JIT编译过程本来就是一个虚拟机中最体现技术水平也是最复杂的部分，不可能以较短的篇幅就介绍得很详细，另外，这个过程对Java开发来说是透明的，程序员平时无法感知它的存在，还好HotSpot虚拟机提供了两个可视化的工具，让我们可以“看见”JIT编译器的优化过程，在稍后作者将演示这个过程。</p><h3 id="2-4-查看及分析即时编译结果"><a href="#2-4-查看及分析即时编译结果" class="headerlink" title="2.4 查看及分析即时编译结果"></a><strong>2.4 查看及分析即时编译结果</strong></h3><p>&emsp;&emsp;一般来说，虚拟机的即时编译过程对用户程序是完全透明的，虚拟机通过解释执行代码还是编译执行代码，对于用户来说并没有什么影响（执行结果没有影响，速度上会有很大差别），在大多数情况下用户也没有必要知道。但是虚拟机也提供了一些参数用来输出即时编译和某些优化手段（如方法内联）的执行状况，本节将介绍如何从外部观察虚拟机的即时编译行为。</p><p>&emsp;&emsp;本节中提到的运行参数有一部分需要Debug或FastDebug版虚拟机的支持，Product版的虚拟机无法使用这部分参数。如果读者使用的是根据本书第1章的内容自己编译的JDK，注意将SKIP_DEBUG_BUILD或SKIP_FASTDEBUG_BUILD参数设置为false，也可以在OpenJDK网站上直接下载FastDebug版的JDK（从JDK 6u25之后Oracle官网就不再提供FastDebug的JDK下载了）。注意，本节中所有的测试都基于代码清单11-2所示的Java代码。</p><p>&emsp;&emsp;代码清单11-2　测试代码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">15000</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">    <span class="comment">//这个空循环用于后面演示JIT代码优化过程 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">100000</span>;j++); </span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">long</span> <span class="title">calcSum</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">        sum += doubleValue(i); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NUM;i++)&#123; </span><br><span class="line">        calcSum(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先运行这段代码，并且确认这段代码是否触发了即时编译，要知道某个方法是否被编译过，可以使用参数-XX:+PrintCompilation要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来，如代码清单11-3所示（其中带有“%”的输出说明是由回边计数器触发的OSR编译）。</p><p>&emsp;&emsp;代码清单11-3　被即时编译的代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VM option<span class="string">'+PrintCompilation'</span> </span><br><span class="line"><span class="number">310</span> <span class="number">1</span> java<span class="selector-class">.lang</span><span class="selector-class">.String</span>:charAt(<span class="number">33</span> bytes)</span><br><span class="line"><span class="number">329</span> <span class="number">2</span> org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:calcSum(<span class="number">26</span> bytes) </span><br><span class="line"><span class="number">329</span> <span class="number">3</span> org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:doubleValue(<span class="number">4</span> bytes) </span><br><span class="line"><span class="number">332</span> <span class="number">1%</span>org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:main@<span class="number">5</span>(<span class="number">20</span> bytes)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从代码清单11-3输出的确认信息中可以确认main()、calcSum()和doubleValue()方法已经被编译，我们还可以加上参数-XX:+PrintInlining要求虚拟机输出方法内联信息，如代码清单11-4所示。</p><p>&emsp;&emsp;代码清单11-4　内联信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VM option<span class="string">'+PrintCompilation'</span> </span><br><span class="line">VM option<span class="string">'+PrintInlining'</span> </span><br><span class="line"><span class="number">273</span> <span class="number">1</span> java<span class="selector-class">.lang</span><span class="selector-class">.String</span>:charAt(<span class="number">33</span> bytes) </span><br><span class="line"><span class="number">291</span> <span class="number">2</span> org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:calcSum(<span class="number">26</span> bytes) </span><br><span class="line">@<span class="number">9</span> org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:doubleValue inline(hot) </span><br><span class="line"><span class="number">294</span> <span class="number">3</span> org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:doubleValue(<span class="number">4</span> bytes) </span><br><span class="line"><span class="number">295</span> <span class="number">1%</span>org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:main@<span class="number">5</span>(<span class="number">20</span> bytes) </span><br><span class="line">@<span class="number">5</span> org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:calcSum inline(hot) </span><br><span class="line">@<span class="number">9</span> org<span class="selector-class">.fenixsoft</span><span class="selector-class">.jit</span><span class="selector-class">.Test</span>:doubleValue inline(hot)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从代码清单11-4的输出中可以看到方法doubleValue()被内联编译到calcSum()中，而calcSum()又被内联编译到方法main()中，所以虚拟机再次执行main()方法的时候（举例而已，main()方法并不会运行两次），calcSum()和doubleValue()方法都不会再被调用，它们的代码逻辑都被直接内联到main()方法中了。</p><p>&emsp;&emsp;除了查看哪些方法被编译之外，还可以进一步查看即时编译器生成的机器码内容，不过如果虚拟机输出一串0和1，对于我们的阅读来说是没有意义的，机器码必须反汇编成基本的汇编语言才可能被阅读。虚拟机提供了一组通用的反汇编接口[1]，可以接入各种平台下的反汇编适配器来使用，如使用32位80x86平台则选用hsdis-i386适配器，其余平台的适配器还有hsdis-amd64、hsdis-sparc和hsdis-sparcv9等，可以下载或自己编译出反汇编适配器[2]，然后将其放置在JRE/bin/client或/server目录下，只要与jvm.dll的路径相同即可被虚拟机调用。在为虚拟机安装了反汇编适配器之后，就可以使用-XX:+PrintAssembly参数要求虚拟机打印编译方法的汇编代码了，具体的操作可以参考本书4.2.7节。</p><p>&emsp;&emsp;如果没有HSDIS插件支持，也可以使用-XX:+PrintOptoAssembly（用于Server VM）或XX:+PrintLIR（用于Client VM）来输出比较接近最终结果的中间代码表示，代码清单11-2被编译后部分反汇编（使用-XX:+PrintOptoAssembly）的输出结果如代码清单11-5所示。从阅读角度来说，使用-XX:+PrintOptoAssembly参数输出的伪汇编结果包含了更多的信息（主要是注释），利于阅读并理解虚拟机JIT编译器的优化结果。</p><p>&emsp;&emsp;代码清单11-5　本地机器码反汇编信息（部分）</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="number">000</span> B1:#N1&lt;-BLOCK HEAD IS JUNK Freq:<span class="number">1</span> </span><br><span class="line"><span class="number">000</span> pushq rbp subq rsp, #<span class="number">16</span>#Create frame nop#nop for patch_verified_entry </span><br><span class="line"><span class="number">006</span> movl RAX,RDX#spill </span><br><span class="line"><span class="number">008</span> sall RAX, #<span class="number">1</span> </span><br><span class="line"><span class="number">00</span>a addq rsp, <span class="number">16</span>#Destroy frame popq rbp testl rax, [rip+#offset_to_poll_page]#Safepoint:poll for GC</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面提到的使用-XX:+PrintAssembly参数输出反汇编信息需要Debug或者FastDebug版的虚拟机才能直接支持，如果使用Product版的虚拟机，则需要加入参数-XX: +UnlockDiagnosticVMOptions打开虚拟机诊断模式后才能使用。</p><p>&emsp;&emsp;如果除了本地代码的生成结果外，还想再进一步跟踪本地代码生成的具体过程，那还可以使用参数-XX:+PrintCFGToFile（使用Client Compiler）或-XX:PrintIdealGraphFile（使用Server Compiler）令虚拟机将编译过程中各个阶段的数据（例如，对C1编译器来说，包括字节码、HIR生成、LIR生成、寄存器分配过程、本地代码生成等数据）输出到文件中。然后使用Java HotSpot Client Compiler Visualizer[3]（用于分析Client Compiler）或Ideal Graph Visualizer[4]（用于分析Server Compiler）打开这些数据文件进行分析。以Server Compiler为例，作者分析一下JIT编译器的代码生成过程。</p><p>&emsp;&emsp;Server Compiler的中间代码表示是一种名为Ideal的SSA形式程序依赖图（Program Dependence Graph），在运行Java程序的JVM参数中加入“-XX:PrintIdealGraphLevel = 2 -XX:PrintIdealGraphFile = ideal.xml”，编译后将产生一个名为ideal.xml的文件，它包含了Server Compiler编译代码的过程信息，可以使用Ideal Graph Visualizer对这些信息进行分析。</p><p>&emsp;&emsp;Ideal Graph Visualizer加载ideal.xml文件后，在Outline面板上将显示程序运行过程中编译过的方法列表，如图11-5所示。这里列出的方法是代码清单11-2中的测试代码，其中doubleValue()方法出现了两次，这是由于该方法的编译结果存在标准编译和OSR编译两个版本。在代码清单11-2中，作者特别为doubleValue()方法增加了一个空循环，这个循环对方法的运算结果不会产生影响，但如果没有任何优化，执行空循环会占用CPU时间，到今天还有许多程序设计的入门教程把空循环当做程序延时的手段来介绍，在Java中这样的做法真的能起到延时的作用吗？</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010219.png" alt="编译过的方法列表"></p><p>&emsp;&emsp;展开方法根节点，可以看到下面罗列了方法优化过程的各个阶段（根据优化措施的不同，每个方法所经过的阶段也会有所差别）的Ideal图，我们先打开“After Parsing”这个阶段。上文提到，JIT编译器在编译一个Java方法时，首先要把字节码解析成某种中间表示形式，然后才可以继续做分析和优化，最终生成代码。“After Parsing”就是Server Compiler刚完成解析，还没有做任何优化时的Ideal图表示。在打开这个图后，读者会看到其中有很多有颜色的方块，如图11-6所示。每一个方块就代表了一个程序的基本块（Basic Block），基本块的特点是只有唯一的一个入口和唯一的一个出口，只要基本块中第一条指令执行了，那么基本块内所有执行都会按照顺序仅执行一次。</p><p>&emsp;&emsp;代码清单11-2的doubleValue()方法虽然只有简单的两行字，但是按基本块划分后，形成的图形结构要比想象中复杂得多，这一方面是要满足Java语言所定义的安全需要（如类型安全、空指针检查）和Java虚拟机的运作需要（如Safepoint轮询），另一方面是由于有些程序代码中一行语句就可能形成好几个基本块（例如循环）。对于例子中的doubleValue()方法，如果忽略语言安全检查的基本块，可以简单理解为按顺序执行了以下几件事情：</p><blockquote><ol><li>程序入口，建立栈帧。 </li><li>设置j = 0，进行Safepoint轮询，跳转到（4）的条件检查。 </li><li>执行j++。</li><li>条件检查，如果j &lt; 100000，跳转到（3）。 </li><li>设置i = i * 2，进行Safepoint轮询，函数返回。</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010220.png" alt="基本块图示（1）"></p><p>&emsp;&emsp;以上几个步骤，反映到Ideal Graph Visualizer的图上，就是如图11-7所示的内容。这样我们要看空循环是否优化，或者何时优化，只要观察代表循环的基本块是否消除，或者何时消除就可以了。</p><p>&emsp;&emsp;要观察到这一点，可以在Outline面板上右键点击“Difference to current graph”，让软件自动分析指定阶段与当前打开的Ideal图之间的差异，如果基本块被消除了，将会以红色显示。对“After Parsing”和“PhaseIdealLoop 1”阶段的Ideal图进行差异分析，发现在“PhaseIdealLoop 1”阶段循环操作被消除了，如图11-8所示，这也就说明空循环实际上是不会被执行的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010221.png" alt="基本块图示（2）"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010222.png" alt="基本块图示（3）"></p><p>&emsp;&emsp;从“After Parsing”阶段开始，一直到最后的“Final Code”阶段，可以看到doubleValue()方法的Ideal图从繁到简的变迁过程，这也是Java虚拟机在尽力优化代码的过程。到了最后的“Final Code”阶段，不仅空循环的开销消除了，许多语言安全和Safepoint轮询的操作也一起消除了，因为编译器判断即使不做这些安全保障，虚拟机也不会受到威胁。</p><p>&emsp;&emsp;最后提醒一下读者，要输出CFG或IdealGraph文件，需要一个Debug版或FastDebug版的虚拟机支持，Product版的虚拟机无法输出这些文件。</p><hr><h2 id="第三节-编译优化技术"><a href="#第三节-编译优化技术" class="headerlink" title="第三节 编译优化技术"></a><strong>第三节 编译优化技术</strong></h2><p>&emsp;&emsp;Java程序员有一个共识，以编译方式执行本地代码比解释方式更快，之所以有这样的共识，除去虚拟机解释执行字节码时额外消耗时间的原因外，还有一个很重要的原因就是虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中（在JDK 1.3之后，Javac就去除了-O选项，不会生成任何字节码级别的优化代码了），因此一般来说，即时编译器产生的本地代码会比Javac产生的字节码更加优秀[1]。下面，作者将介绍一些HotSpot虚拟机的即时编译器在生成代码时采用的代码优化技术。</p><h3 id="3-1-优化技术概览"><a href="#3-1-优化技术概览" class="headerlink" title="3.1 优化技术概览"></a><strong>3.1 优化技术概览</strong></h3><p>&emsp;&emsp;在Sun官方的Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、在即时编译器中采用的优化技术列表[2]（见表11-1），其中有不少经典编译器的优化手段，也有许多针对Java语言（准确地说是针对运行在Java虚拟机上的所有语言）本身进行的优化技术，本节将对这些技术进行概括性的介绍，在后面几节中，再挑选若干重要且典型的优化，与读者一起看看优化前后的代码产生了怎样的变化。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010223.png" alt="即时编译器优化技术一览"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010224.png" alt="即时编译器优化技术一览"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010225.png" alt="即时编译器优化技术一览"></p><p>&emsp;&emsp;上述的优化技术看起来很多，而且从名字看都显得有点“高深莫测”，虽然实现这些优化也许确实有些难度，但大部分技术理解起来都并不困难。为了消除读者对这些优化技术的陌生感，作者举一个简单的例子，即通过大家熟悉的Java代码变化来展示其中几种优化技术是如何发挥作用的（仅使用Java代码来表示而已）。首先从原始代码开始，如代码清单11-6所示[3]。</p><p>&emsp;&emsp;代码清单11-6　优化前的原始代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">B</span>&#123; </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">value</span>; </span><br><span class="line">    <span class="function">final <span class="keyword">int</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    y=b.<span class="keyword">get</span>(); </span><br><span class="line">    <span class="comment">//……do stuff…… </span></span><br><span class="line">    z=b.<span class="keyword">get</span>(); </span><br><span class="line">    sum=y+z; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先需要明确的是，这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝不是建立在Java源码之上的，为了展示方便，作者使用了Java语言的语法来表示这些优化技术所发挥的作用。</p><p>&emsp;&emsp;代码清单11-6的代码已经非常简单了，但是仍有许多优化的余地。第一步进行方法内联（Method Inlining），方法内联的重要性要高于其他优化措施，它的主要目的有两个，一是去除方法调用的成本（如建立栈帧等），二是为其他优化建立良好的基础，方法内联膨胀之后可以便于在更大范围上采取后续的优化手段，从而获取更好的优化效果。因此，各种编译器一般都会把内联优化放在优化序列的最靠前位置。内联后的代码如代码清单11-7所示。</p><p>&emsp;&emsp;代码清单11-7　内联后的代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    y=b.<span class="keyword">value</span>; </span><br><span class="line">    <span class="comment">//……do stuff…… </span></span><br><span class="line">    z=b.<span class="keyword">value</span>; </span><br><span class="line">    sum=y+z; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二步进行冗余访问消除（Redundant Loads Elimination），假设代码中间注释掉的“dostuff……”所代表的操作不会改变b.value的值，那就可以把“z=b.value”替换为“z=y”，因为上一句“y=b.value”已经保证了变量y与b.value是一致的，这样就可以不再去访问对象b的局部变量了。如果把b.value看做是一个表达式，那也可以把这项优化看成是公共子表达式消除（Common Subexpression Elimination），优化后的代码如代码清单11-8所示。</p><p>&emsp;&emsp;代码清单11-8　冗余存储消除的代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    y=b.<span class="keyword">value</span>; </span><br><span class="line">    <span class="comment">//……do stuff…… </span></span><br><span class="line">    z=y; </span><br><span class="line">    sum=y+z; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第三步我们进行复写传播（Copy Propagation），因为在这段程序的逻辑中并没有必要使用一个额外的变量“z”，它与变量“y”是完全相等的，因此可以使用“y”来代替“z”。复写传播之后程序如代码清单11-9所示。</p><p>&emsp;&emsp;代码清单11-9　复写传播的代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    y=b.<span class="keyword">value</span>; </span><br><span class="line">    <span class="comment">//……do stuff…… </span></span><br><span class="line">    y=y; </span><br><span class="line">    sum=y+y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第四步我们进行无用代码消除（Dead Code Elimination）。无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码，因此，它又形象地称为“Dead Code”，在代码清单11-9中，“y=y”是没有意义的，把它消除后的程序如代码清单11-10所示。</p><p>&emsp;&emsp;代码清单11-10　进行无用代码消除的代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    y=b.<span class="keyword">value</span>; </span><br><span class="line">    <span class="comment">//……do stuff…… </span></span><br><span class="line">    sum=y+y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过四次优化之后，代码清单11-10与代码清单11-6所达到的效果是一致的，但是前者比后者省略了许多语句（体现在字节码和机器码指令上的差距会更大），执行效率也会更高。编译器的这些优化技术实现起来也许比较复杂，但是要理解它们的行为对于一个普通的程序员来说是没有困难的，接下来，我们将继续查看如下的几项最有代表性的优化技术是如何运作的，它们分别是：</p><blockquote><ul><li>语言无关的经典优化技术之一：公共子表达式消除。</li><li>语言相关的经典优化技术之一：数组范围检查消除。 </li><li>最重要的优化技术之一：方法内联。 </li><li>最前沿的优化技术之一：逃逸分析。 </li></ul></blockquote><h3 id="3-2-公共子表达式消除"><a href="#3-2-公共子表达式消除" class="headerlink" title="3.2 公共子表达式消除"></a><strong>3.2 公共子表达式消除</strong></h3><p>&emsp;&emsp;公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，它的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。举个简单的例子来说明它的优化过程，假设存在如下代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int d = (<span class="name">c</span> * b) * <span class="number">12</span> + a + (<span class="name">a</span> + b * c);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果这段代码交给Javac编译器则不会进行任何优化，那生成的代码将如代码清单11-11所示，是完全遵照Java源码的写法直译而成的。</p><p>&emsp;&emsp;代码清单11-11　未做任何优化的字节码</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iload_2<span class="comment">//b </span></span><br><span class="line">imul<span class="comment">//计算b * c </span></span><br><span class="line">bipush <span class="number">12</span><span class="comment">//推入12 </span></span><br><span class="line">imul<span class="comment">//计算(c * b) * 12 </span></span><br><span class="line">iload_1<span class="comment">//a </span></span><br><span class="line">iadd<span class="comment">//计算(c * b) * 12 + a </span></span><br><span class="line">iload_1<span class="comment">//a </span></span><br><span class="line">iload_2<span class="comment">//b </span></span><br><span class="line">iload_3<span class="comment">//c </span></span><br><span class="line">imul<span class="comment">//计算b * c </span></span><br><span class="line">iadd<span class="comment">//计算a+b * c </span></span><br><span class="line">iadd<span class="comment">//计算(c * b) * 12 + a + (a + b * c) </span></span><br><span class="line">istore <span class="number">4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当这段代码进入到虚拟机即时编译器后，它将进行如下优化：编译器检测到“c <em> b”与“b </em> c”是一样的表达式，而且在计算期间b与c的值是不变的。因此，这条表达式就可能被视为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int d</span> = E * 12 + a + (a + E);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化：代数化简（Algebraic Simplification），把表达式变为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int d</span> = E * 13 + a * 2;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;表达式进行变换之后，再计算起来就可以节省一些时间了。如果读者还对其他的经典编译优化技术感兴趣，可以参考《编译原理》（俗称“龙书”，推荐使用Java的程序员阅读2006年版的“紫龙书”）中的相关章节。</p><h3 id="3-3-数组边界检查消除"><a href="#3-3-数组边界检查消除" class="headerlink" title="3.3 数组边界检查消除"></a><strong>3.3 数组边界检查消除</strong></h3><p>&emsp;&emsp;数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。我们知道Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样在本质上是裸指针操作。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即检查i必须满足i &gt;= 0 &amp;&amp; i &lt; foo.length这个条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。这对软件开发者来说是一件很好的事情，即使程序员没有专门编写防御代码，也可以避免大部分的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑也是一种性能负担。</p><p>&emsp;&emsp;无论如何，为了安全，数组边界检查肯定是必须做的，但数组边界检查是不是必须在运行期间一次不漏地检查则是可以“商量”的事情。例如下面这个简单的情况：数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下标“3”没有越界，执行的时候就无须判断了。更加常见的情况是数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length）之内，那在整个循环中就可以把数组的上下界检查消除，这可以节省很多次的条件判断操作。</p><p>&emsp;&emsp;将这个数组边界检查的例子放在更高的角度来看，大量的安全检查令编写Java程序比编写C/C++程序容易很多，如数组越界会得到ArrayIndexOutOfBoundsException异常，空指针访问会得到NullPointException，除数为零会得到ArithmeticException等，在C/C++程序中出现类似的问题，一不小心就会出现Segment Fault信号或者Window编程中常见的“xxx内存不能为Read/Write”之类的提示，处理不好程序就直接崩溃退出了。但这些安全检查也导致了相同的程序，Java要比C/C++做更多的事情（各种检查判断），这些事情就成为一种隐式开销，如果处理不好它们，就很可能成为一个Java语言比C/C++更慢的因素。要消除这些隐式开销，除了如数组边界检查优化这种尽可能把运行期检查提到编译期完成的思路之外，另外还有一种避免思路——隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这种思路。举个例子，例如程序中访问一个对象（假设对象叫foo）的某个属性（假设属性叫value），那以Java伪代码来表示虚拟机访问foo.value的过程如下。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo != <span class="literal">null</span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> foo.<span class="keyword">value</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointException(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在使用隐式异常优化之后，虚拟机会把上面伪代码所表示的访问过程变为如下伪代码。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> foo.<span class="keyword">value</span>; </span><br><span class="line">&#125; <span class="keyword">catch</span> (segment<span class="number">_f</span>ault)&#123; </span><br><span class="line">    uncommon<span class="number">_</span>trap(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虚拟机会注册一个Segment Fault信号的异常处理器（伪代码中的uncommon_trap()），这样当foo不为空的时候，对value的访问是不会额外消耗一次对foo判空的开销的。代价就是当foo真的为空时，必须转入到异常处理器中恢复并抛出NullPointException异常，这个过程必须从用户态转到内核态中处理，结束后再回到用户态，速度远比一次判空检查慢。当foo极少为空的时候，隐式异常优化是值得的，但假如foo经常为空的话，这样的优化反而会让程序更慢，还好HotSpot虚拟机足够“聪明”，它会根据运行期收集到的Profile信息自动选择最优方案。</p><p>&emsp;&emsp;与语言相关的其他消除操作还有不少，如自动装箱消除（Autobox Elimination）、安全点消除（Safepoint Elimination）、消除反射（Dereflection）等，作者就不再一一介绍了。</p><h3 id="3-4-方法内联"><a href="#3-4-方法内联" class="headerlink" title="3.4 方法内联"></a><strong>3.4 方法内联</strong></h3><p>&emsp;&emsp;在前面的讲解之中我们提到过方法内联，它是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础，如代码清单1112所示的简单例子就揭示了内联对其他优化手段的意义：事实上testInline()方法的内部全部都是无用的代码，如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何“Dead Code”，因为如果分开来看，foo()和testInline()两个方法里面的操作都可能是有意义的。</p><p>&emsp;&emsp;代码清单11-12　未做任何优化的字节码</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> foo(<span class="keyword">Object</span> obj)&#123; </span><br><span class="line">    <span class="keyword">if</span>(obj != <span class="keyword">null</span>)&#123; </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"do something"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testInline(<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">    <span class="keyword">Object</span> obj = <span class="keyword">null</span>; </span><br><span class="line">    foo(obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;方法内联的优化行为看起来很简单，不过是把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用而已。但实际上Java虚拟机中的内联过程远远没有那么简单，因为如果不是即时编译器做了一些特别的努力，按照经典编译原理的优化理论，大多数的Java方法都无法进行内联。</p><p>&emsp;&emsp;无法内联的原因其实在第8章中讲解Java方法解析和分派调用的时候就已经介绍过。只有使用invokespecial指令调用的私有方法、实例构造器、父类方法以及使用invokestatic指令进行调用的静态方法才是在编译期进行解析的，除了上述4种方法之外，其他的Java方法调用都需要在运行时进行方法接收者的多态选择，并且都有可能存在多于一个版本的方法接收者（最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法，Java语言规范中明确说明了这点），简而言之，Java语言中默认的实例方法是虚方法。</p><p>&emsp;&emsp;对于一个虚方法，编译期做内联的时候根本无法确定应该使用哪个方法版本，如果以代码清单11-7中把“b.get()”内联为“b.value”为例的话，就是不依赖上下文就无法确定b的实际类型是什么。假如有ParentB和SubB两个具有继承关系的类，并且子类重写了父类的get()方法，那么，是要执行父类的get()方法还是子类的get()方法，需要在运行期才能确定，编译期无法得出结论。</p><p>&emsp;&emsp;由于Java语言提倡使用面向对象的编程方式进行编程，而Java对象的方法默认就是虚方法，因此Java间接鼓励了程序员使用大量的虚方法来完成程序逻辑。根据上面的分析，如果内联与虚方法之间产生“矛盾”，那该怎么办呢？是不是为了提高执行性能，就要到处使用final关键字去修饰方法呢？</p><p>&emsp;&emsp;为了解决虚方法的内联问题，Java虚拟机设计团队想了很多办法，首先是引入了一种名为“类型继承关系分析”（Class Hierarchy Analysis,CHA）的技术，这是一种基于整个应用程序的类型分析技术，它用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某个类是否存在子类、子类是否为抽象类等信息。</p><p>&emsp;&emsp;编译器在进行内联时，如果是非虚方法，那么直接进行内联就可以了，这时候的内联是有稳定前提保障的。如果遇到虚方法，则会向CHA查询此方法在当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那也可以进行内联，不过这种内联就属于激进优化，需要预留一个“逃生门”（Guard条件不成立时的Slow Path），称为守护内联（Guarded Inlining）。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新进行编译。</p><p>&emsp;&emsp;如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会进行最后一次努力，使用内联缓存（Inline Cache）来完成方法内联，这是一个建立在目标方法正常入口之前的缓存，它的工作原理大致是：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。</p><p>&emsp;&emsp;所以说，在许多情况下虚拟机进行的内联都是一种激进优化，激进优化的手段在高性能的商用虚拟机中很常见，除了内联之外，对于出现概率很小（通过经验数据或解释器收集到的性能监控信息确定概率大小）的隐式异常、使用概率很小的分支等都可以被激进优化“移除”，如果真的出现了小概率事件，这时才会从“逃生门”回到解释状态重新执行。</p><h3 id="3-5-逃逸分析"><a href="#3-5-逃逸分析" class="headerlink" title="3.5 逃逸分析"></a><strong>3.5 逃逸分析</strong></h3><p>&emsp;&emsp;逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。</p><p>&emsp;&emsp;逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><p>&emsp;&emsp;如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化，如下所示。</p><blockquote><ul><li>栈上分配（Stack Allocation）：Java虚拟机中，在Java堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象，还是回收和整理内存都需要耗费时间。如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。</li><li>同步消除（Synchronization Elimination）：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就 不会有竞争，对这个变量实施的同步措施也就可以消除掉。</li><li>标量替换（Scalar Replacement）：标量（Scalar）是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解，那它就称作聚合量（Aggregate），Java中的对象就是最典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。</li></ul></blockquote><p>&emsp;&emsp;关于逃逸分析的论文在1999年就已经发表，但直到Sun JDK 1.6才实现了逃逸分析，而且直到现在这项优化尚未足够成熟，仍有很大的改进余地。不成熟的原因主要是不能保证逃逸分析的性能收益必定高于它的消耗。如果要完全准确地判断一个对象是否会逃逸，需要进行数据流敏感的一系列复杂分析，从而确定程序各个分支执行时对此对象的影响。这是一个相对高耗时的过程，如果分析完后发现没有几个不逃逸的对象，那这些运行期耗用的时间就白白浪费了，所以目前虚拟机只能采用不那么准确，但时间压力相对较小的算法来完成逃逸分析。还有一点是，基于逃逸分析的一些优化手段，如上面提到的“栈上分配”，由于HotSpot虚拟机目前的实现方式导致栈上分配实现起来比较复杂，因此在HotSpot中暂时还没有做这项优化。</p><p>&emsp;&emsp;在测试结果中，实施逃逸分析后的程序在MicroBenchmarks中往往能运行出不错的成绩，但是在实际的应用程序，尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定的情况，或因分析过程耗时但却无法有效判别出非逃逸对象而导致性能（即时编译的收益）有所下降，所以在很长的一段时间里，即使是Server Compiler，也默认不开启逃逸分析[1]，甚至在某些版本（如JDK 1.6 Update18）中还曾经短暂地完全禁止了这项优化。</p><p>&emsp;&emsp;如果有需要，并且确认对程序运行有益，用户可以使用参数-XX:+DoEscapeAnalysis来手动开启逃逸分析，开启之后可以通过参数-XX:+PrintEscapeAnalysis来查看分析结果。有了逃逸分析支持之后，用户可以使用参数-XX:+EliminateAllocations来开启标量替换，使用+XX:+EliminateLocks来开启同步消除，使用参数-XX:+PrintEliminateAllocations查看标量的替换情况。</p><p>&emsp;&emsp;尽管目前逃逸分析的技术仍不是十分成熟，但是它却是即时编译器优化技术的一个重要的发展方向，在今后的虚拟机中，逃逸分析技术肯定会支撑起一系列实用有效的优化技术。</p><hr><h2 id="第四节-Java与C-C-的编译器对比"><a href="#第四节-Java与C-C-的编译器对比" class="headerlink" title="第四节 Java与C/C++的编译器对比"></a><strong>第四节 Java与C/C++的编译器对比</strong></h2><p>&emsp;&emsp;大多数程序员都认为C/C++会比Java语言快，甚至觉得从Java语言诞生以来“执行速度缓慢”的帽子就应当扣在它的头顶，这种观点的出现是由于Java刚出现的时候即时编译技术还不成熟，主要靠解释器执行的Java语言性能确实比较低下。但目前即时编译技术已经十分成熟，Java语言有可能在速度上与C/C++一争高下吗？要想知道这个问题的答案，让我们从两者的编译器谈起[1]。</p><p>&emsp;&emsp;Java与C/C++的编译器对比实际上代表了最经典的即时编译器与静态编译器的对比，很大程度上也决定了Java与C/C++的性能对比的结果，因为无论是C/C++还是Java代码，最终编译之后被机器执行的都是本地机器码，哪种语言的性能更高，除了它们自身的API库实现得好坏以外，其余的比较就成了一场“拼编译器”和“拼输出代码质量”的游戏。当然，这种比较也是剔除了开发效率的片面对比，语言间孰优孰劣、谁快谁慢的问题都是很难有结果的争论，下面我们就回到正题，看看这两种语言的编译器各有何种优势。</p><p>&emsp;&emsp;Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些劣势（下面列举的也包括一些虚拟机执行子系统的性能劣势）：</p><blockquote><ul><li>第一，因为即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。如果编译速度不能达到要求，那用户将在启动程序或程序的某部分察觉到重大延迟，这点使得即时编译器不敢随便引入大规模的优化技术，而编译的时间成本在静态优化编译器中并不是主要的关注点。</li><li>第二，Java语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存。从实现层面上看，这就意味着虚拟机必须频繁地进行动态检查，如实例方法访问时检查空指针、数组元素访问时检查上下界范围、类型转换时检查继承关系等。对于这类程序代码没有明确写出的检查行为，尽管编译器会努力进行优化，但是总体上仍然要消耗不少的运行时间。</li><li>第三，Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言，这意味着运行时对方法接收者进行多态选择的频率要远远大于C/C++语言，也意味着即时编译器在进行一些优化（如前面提到的方法内联）时的难度要远大于C/C++的静态优化编译器。</li><li>第四，Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行，因为编译器无法看见程序的全貌，许多全局的优化措施都只能以激进优化的方式来完成，编译器不得不时刻注意并随着类型的变化而在运行时撤销或重新进行一些优化。</li><li>第五，Java语言中对象的内存分配都是堆上进行的，只有方法中的局部变量才能在栈上分配[2]。而C/C++的对象则有多种内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力。另外，C/C++中主要由用户程序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上（仅指运行效率，排除了开发效率）也比垃圾收集机制要高。</li></ul></blockquote><p>&emsp;&emsp;上面说了一大堆Java语言相对C/C++的劣势，不是说Java就真的不如C/C++了，相信读者也注意到了，Java语言的这些性能上的劣势都是为了换取开发效率上的优势而付出的代价，动态安全、动态扩展、垃圾回收这些“拖后腿”的特性都为Java语言的开发效率做出了很大贡献。</p><p>&emsp;&emsp;何况，还有许多优化是Java的即时编译器能做而C/C++的静态优化编译器不能做或者不好做的。例如，在C/C++中，别名分析（Alias Analysis）的难度就要远高于Java。Java的类型安全保证了在类似如下代码中，只要ClassA和ClassB没有继承关系，那对象objA和objB就绝不可能是同一个对象，即不会是同一块内存两个不同别名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(ClassA objA, ClassB objB)</span></span>&#123; </span><br><span class="line">    objA.x=<span class="number">123</span>; </span><br><span class="line">    objB.y=<span class="number">456</span>; <span class="comment">//只要objB.y不是objA.x的别名，下面就可以保证输出为123 </span></span><br><span class="line">    print(objA.x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;确定了objA和objB并非对方的别名后，许多与数据依赖相关的优化才可以进行（重排序、变量代换）。具体到这个例子中，就是无须担心objB.y其实与objA.x指向同一块内存，这样就可以安全地确定打印语句中的objA.x为123。</p><p>&emsp;&emsp;Java编译器另外一个红利是由它的动态性所带来的，由于C/C++编译器所有优化都在编译期完成，以运行期性能监控为基础的优化措施它都无法进行，如调用频率预测（Call Frequency Prediction）、分支频率预测（Branch Frequency Prediction）、裁剪未被选择的分支（Untaken Branch Pruning）等，这些都会成为Java语言独有的性能优势。</p><hr><h2 id="第五节-总结"><a href="#第五节-总结" class="headerlink" title="第五节 总结"></a><strong>第五节 总结</strong></h2><p>&emsp;&emsp;第10～11两章分别介绍了Java程序从源码编译成字节码和从字节码编译成本地机器码的过程，Javac字节码编译器与虚拟机内的JIT编译器的执行过程合并起来其实就等同于一个传统编译器所执行的编译过程。</p><p>&emsp;&emsp;本章中，我们着重了解了虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果，还选择了几种常见的编译期优化技术进行讲解。对Java编译器的深入了解，有助于在工作中分辨哪些代码是编译器可以帮我们处理的，哪些代码需要自己调节以便更适合编译器的优化。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的运行期优化，包括：概述，HotSpot虚拟机内的即时编译器（解释器与编译器、编译对象与触发条件、编译过程、查看及分析即时编译结果），编译优化技术（优化技术概览、公共子表达式消除、数组边界检查消除、方法内联、逃逸分析），Java与C/C++的编译器对比，总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>编译期优化-Java语法糖</title>
    <link href="http://linyishui.top/2019122101.html"/>
    <id>http://linyishui.top/2019122101.html</id>
    <published>2019-12-21T10:27:47.000Z</published>
    <updated>2020-01-14T07:24:10.343Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编译期优化-Java语法糖"><a href="#编译期优化-Java语法糖" class="headerlink" title="编译期优化-Java语法糖"></a><strong>编译期优化-Java语法糖</strong></h1><h2 id="第三节-Java语法糖的味道"><a href="#第三节-Java语法糖的味道" class="headerlink" title="第三节 Java语法糖的味道"></a><strong>第三节 Java语法糖的味道</strong></h2><p>&emsp;&emsp;几乎各种语言或多或少都提供过一些语法糖来方便程序员的代码开发，这些语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。不过也有一种观点认为语法糖并不一定都是有益的，大量添加和使用“含糖”的语法，容易让程序员产生依赖，无法看清语法糖的糖衣背后，程序代码的真实面目。</p><p>&emsp;&emsp;总而言之，语法糖可以看做是编译器实现的一些“小把戏”，这些“小把戏”可能会使得效率“大提升”，但我们也应该去了解这些“小把戏”背后的真实世界，那样才能利用好它们，而不是被它们所迷惑。</p><h3 id="3-1-泛型与类型擦除"><a href="#3-1-泛型与类型擦除" class="headerlink" title="3.1 泛型与类型擦除"></a><strong>3.1 泛型与类型擦除</strong></h3><p>&emsp;&emsp;泛型是JDK 1.5的一项新增特性，它的本质是参数化类型（Parametersized Type）的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p><p>&emsp;&emsp;泛型思想早在C++语言的模板（Template）中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。例如，在哈希表的存取中，JDK 1.5之前使用HashMap的get()方法，返回值就是一个Object对象，由于Java语言里面所有的类型都继承于java.lang.Object，所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期之中。</p><p>&emsp;&emsp;泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List＜int＞与List＜String＞就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。</p><p>&emsp;&emsp;Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。</p><p>&emsp;&emsp;代码清单10-2是一段简单的Java泛型的例子，我们可以看一下它编译后的结果是怎样的。</p><p>&emsp;&emsp;代码清单10-2　泛型擦除前的例子</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">    Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;<span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;(); </span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"hello"</span>, <span class="string">"你好"</span>); </span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"how are you?"</span>, <span class="string">"吃了没?"</span>); </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"hello"</span>)); </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"how are you?"</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型，如代码清单10-3所示。</p><p>&emsp;&emsp;代码清单10-3　泛型擦除后的例子</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">    Map <span class="built_in">map</span> = <span class="keyword">new</span> HashMap(); </span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"hello"</span>, <span class="string">"你好"</span>); </span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"how are you?"</span>, <span class="string">"吃了没?"</span>); </span><br><span class="line">    System.out.<span class="built_in">println</span>((<span class="keyword">String</span>) <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"hello"</span>)); </span><br><span class="line">    System.out.<span class="built_in">println</span>((<span class="keyword">String</span>) <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"how are you?"</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当初JDK设计团队为什么选择类型擦除的方式来实现Java语言的泛型支持呢？是因为实现简单、兼容性考虑还是别的原因？我们已不得而知，但确实有不少人对Java语言提供的伪泛型颇有微词，当时甚至连《Thinking in Java》一书的作者Bruce Eckel也发表了一篇文章《这不是泛型！》[1]来批评JDK 1.5中的泛型实现。</p><p>&emsp;&emsp;在当时众多的批评之中，有一些是比较表面的，还有一些从性能上说泛型会由于强制转型操作和运行期缺少针对类型的优化等从而导致比C#的泛型慢一些，则是完全偏离了方向，姑且不论Java泛型是不是真的会比C#泛型慢，选择从性能的角度上评价用于提升语义准确性的泛型思想就不太恰当。但作者也并非在为Java的泛型辩护，它在某些场景下确实存在不足，作者认为通过擦除法来实现泛型丧失了一些泛型思想应有的优雅，例如代码清单10-4的例子。</p><p>&emsp;&emsp;代码清单10-4　当泛型遇见重载1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span>&#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; <span class="built_in">list</span>)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; <span class="built_in">list</span>)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;请想一想，上面这段代码是否正确，能否编译执行？也许你已经有了答案，这段代码是不能被编译的，因为参数List＜Integer＞和List＜String＞编译之后都被擦除了，变成了一样的原生类型List＜E＞，擦除动作导致这两种方法的特征签名变得一模一样。初步看来，无法重载的原因已经找到了，但真的就是如此吗？只能说，泛型擦除成相同的原生类型只是无法重载的其中一部分原因，请再接着看一看代码清单10-5中的内容。</p><p>&emsp;&emsp;代码清单10-5　当泛型遇见重载2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span>&#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List&lt;String&gt; <span class="built_in">list</span>)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; <span class="built_in">list</span>)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        method(<span class="keyword">new</span> ArrayList&lt;String&gt;()); </span><br><span class="line">        method(<span class="keyword">new</span> ArrayList&lt;Integer&gt;()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke <span class="function"><span class="keyword">method</span><span class="params">(List&lt;String&gt; list)</span> </span></span><br><span class="line"><span class="function"><span class="title">invoke</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单10-5与代码清单10-4的差别是两个method方法添加了不同的返回值，由于这两个返回值的加入，方法重载居然成功了，即这段代码可以被编译和执行[2]了。这是对Java语言中返回值不参与重载选择的基本认知的挑战吗？</p><p>&emsp;&emsp;代码清单10-5中的重载当然不是根据返回值来确定的，之所以这次能编译和执行成功，是因为两个method()方法加入了不同的返回值后才能共存在一个Class文件之中。第6章介绍Class文件方法表（method_info）的数据结构时曾经提到过，方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名之中，所以返回值不参与重载选择，但是在Class文件格式之中，只要描述符不是完全一致的两个方法就可以共存。也就是说，两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个Class文件中的。</p><p>&emsp;&emsp;由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。因此，JCP组织对虚拟机规范做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[3]，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范[4]要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</p><p>&emsp;&emsp;从上面的例子可以看到擦除法对实际编码带来的影响，由于List＜String＞和List＜Integer＞擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成重载，这是一种毫无优雅和美感可言的解决方案，并且存在一定语意上的混乱，譬如上面脚注中提到的，必须用Sun JDK 1.6的Javac才能编译成功，其他版本或者ECJ编译器都可能拒绝编译。</p><p>&emsp;&emsp;另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p><h3 id="3-2-自动装箱、拆箱与遍历循环"><a href="#3-2-自动装箱、拆箱与遍历循环" class="headerlink" title="3.2 自动装箱、拆箱与遍历循环"></a><strong>3.2 自动装箱、拆箱与遍历循环</strong></h3><p>&emsp;&emsp;从纯技术的角度来讲，自动装箱、自动拆箱与遍历循环（Foreach循环）这些语法糖，无论是实现上还是思想上都不能和上文介绍的泛型相比，两者的难度和深度都有很大差距。专门拿出一节来讲解它们只有一个理由：毫无疑问，它们是Java语言里使用得最多的语法糖。我们通过代码清单10-6和代码清单10-7中所示的代码来看看这些语法糖在编译后会发生什么样的变化。</p><p>&emsp;&emsp;代码清单10-6　自动装箱、拆箱与遍历循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">    List&lt;Integer&gt; <span class="built_in">list</span> = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="comment">//如果在JDK 1.7中, 还有另外一颗语法糖[1] </span></span><br><span class="line">    <span class="comment">//能让上面这句代码进一步简写成List&lt;Integer&gt; list = [1, 2, 3, 4]; </span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="built_in">list</span>)&#123; </span><br><span class="line">        sum += i; </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(sum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单10-7　自动装箱、拆箱与遍历循环编译之后</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static void main(String[] args)&#123; </span><br><span class="line">    List list = Arrays.asList(new <span class="keyword">Integer</span>[]&#123; </span><br><span class="line">        <span class="keyword">Integer</span>.valueOf(<span class="number">1</span>),  </span><br><span class="line">        <span class="keyword">Integer</span>.valueOf(<span class="number">2</span>),  </span><br><span class="line">        <span class="keyword">Integer</span>.valueOf(<span class="number">3</span>),  </span><br><span class="line">        <span class="keyword">Integer</span>.valueOf(<span class="number">4</span>)&#125;); </span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>; </span><br><span class="line">    for(Iterator localIterator = list.iterator();localIterator.hasNext();)&#123; </span><br><span class="line">        <span class="built_in">int</span> i = ((<span class="keyword">Integer</span>) localIterator.next()).intValue(); </span><br><span class="line">        <span class="built_in">sum</span>+ = i; </span><br><span class="line">    &#125; </span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="built_in">sum</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单10-6中一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖，代码清单10-7则展示了它们在编译后的变化。泛型就不必说了，自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法，如本例中的Integer.valueOf()与Integer.intValue()方法，而遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因。最后再看看变长参数，它在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员就是使用数组来完成类似功能的。</p><p>&emsp;&emsp;这些语法糖虽然看起来很简单，但也不见得就没有任何值得我们注意的地方，代码清单10-8演示了自动装箱的一些错误用法。</p><p>&emsp;&emsp;代码清单10-8　自动装箱的陷阱</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123; </span><br><span class="line">    Integer a = <span class="number">1</span><span class="comment">; </span></span><br><span class="line">    Integer <span class="keyword">b </span>= <span class="number">2</span><span class="comment">; </span></span><br><span class="line">    Integer c = <span class="number">3</span><span class="comment">; </span></span><br><span class="line">    Integer d = <span class="number">3</span><span class="comment">; </span></span><br><span class="line">    Integer e = <span class="number">321</span><span class="comment">; </span></span><br><span class="line">    Integer f = <span class="number">321</span><span class="comment">; </span></span><br><span class="line">    Long g = <span class="number">3</span>L<span class="comment">; </span></span><br><span class="line">    System.out.println(c == d)<span class="comment">; </span></span><br><span class="line">    System.out.println(e == f)<span class="comment">; </span></span><br><span class="line">    System.out.println(c == (a + <span class="keyword">b)); </span></span><br><span class="line">    System.out.println(c.equals(a + <span class="keyword">b)); </span></span><br><span class="line">    System.out.println(g == (a + <span class="keyword">b)); </span></span><br><span class="line">    System.out.println(g.equals(a + <span class="keyword">b)); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;阅读完代码清单10-8，读者不妨思考两个问题：一是这6句打印语句的输出是什么？二是这6句打印语句中，解除语法糖后参数会是什么样子？这两个问题的答案可以很容易试验出来，作者就暂且略去答案，希望读者自己上机实践一下。无论读者的回答是否正确，鉴于包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们equals()方法不处理数据转型的关系，作者建议在实际编码中尽量避免这样使用自动装箱与拆箱。</p><h3 id="3-3-条件编译"><a href="#3-3-条件编译" class="headerlink" title="3.3 条件编译"></a><strong>3.3 条件编译</strong></h3><p>&emsp;&emsp;许多程序设计语言都提供了条件编译的途径，如C、C++中使用预处理器指示符（#ifdef）来完成条件编译。C、C++的预处理器最初的任务是解决编译时的代码依赖关系（如非常常用的#include预处理命令），而在Java语言之中并没有使用预处理器，因为Java语言天然的编译方式（编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）无须使用预处理器。那Java语言是否有办法实现条件编译呢？</p><p>&emsp;&emsp;Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。如代码清单109所示，此代码中的if语句不同于其他Java代码，它在编译阶段就会被“运行”，生成的字节码之中只包括“System.out.println(“block1”);”一条语句，并不会包含if语句及另外一个分子中的“System.out.println(“block 2”);”</p><p>&emsp;&emsp;代码清单10-9　Java语言的条件编译</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"block 1"</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"block 2"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码编译后Class文件的反编译结果：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"block 1"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能力的语句搭配，则可能在控制流分析中提示错误，被拒绝编译，如代码清单10-10所示的代码就会被编译器拒绝编译。</p><p>&emsp;&emsp;代码清单10-10　不能使用其他条件语句来完成条件编译</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </span><br><span class="line">    <span class="comment">//编译器将会提示“Unreachable code” </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">false</span>)&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">""</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段（com.sun.tools.javac.comp.Lower类中）完成。由于这种条件编译的实现方式使用了if语句，所以它必须遵循最基本的Java语法，只能写在方法体内部，因此它只能实现语句基本块（Block）级别的条件编译，而没有办法实现根据条件调整整个Java类的结构。</p><p>&emsp;&emsp;除了本节中介绍的泛型、自动装箱、自动拆箱、遍历循环、变长参数和条件编译之外，Java语言还有不少其他的语法糖，如内部类、枚举类、断言语句、对枚举和字符串（在JDK 1.7中支持）的switch支持、try语句中定义和关闭资源（在JDK 1.7中支持）等，读者可以通过跟踪Javac源码、反编译Class文件等方式了解它们的本质实现，囿于篇幅，作者就不再一一介绍了。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的编译期优化-Java语法糖，包括：泛型与类型擦除，自动装箱、拆箱与遍历循环，条件编译等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>编译期优化-实战</title>
    <link href="http://linyishui.top/2019122201.html"/>
    <id>http://linyishui.top/2019122201.html</id>
    <published>2019-12-20T10:27:54.000Z</published>
    <updated>2020-01-14T07:24:17.986Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编译期优化-实战"><a href="#编译期优化-实战" class="headerlink" title="编译期优化-实战"></a><strong>编译期优化-实战</strong></h1><h2 id="第四节-实战：插入式注解处理器"><a href="#第四节-实战：插入式注解处理器" class="headerlink" title="第四节 实战：插入式注解处理器"></a><strong>第四节 实战：插入式注解处理器</strong></h2><p>&emsp;&emsp;JDK编译优化部分在本书中并没有设置独立的实战章节，因为我们开发程序，考虑的主要是程序会如何运行，很少会有针对程序编译的需求。也因为这个原因，在JDK的编译子系统里面，提供给用户直接控制的功能相对较少，除了第11章会介绍的虚拟机JIT编译的几个相关参数以外，我们就只有使用JSR-296中定义的插入式注解处理器API来对JDK编译子系统的行为产生一些影响。</p><p>&emsp;&emsp;但是作者并不认为相对于前两部分介绍的内存管理子系统和字节码执行子系统，JDK的编译子系统就不那么重要。一套编程语言中编译子系统的优劣，很大程度上决定了程序运行性能的好坏和编码效率的高低，尤其在Java语言中，运行期即时编译与虚拟机执行子系统非常紧密地互相依赖、配合运作（第11章将主要讲解这方面的内容）。了解JDK如何编译和优化代码，有助于我们写出适合JDK自优化的程序。下面我们回到本章的实战中，看看插入式注解处理器API能实现什么功能。</p><h3 id="4-1-实战目标"><a href="#4-1-实战目标" class="headerlink" title="4.1 实战目标"></a><strong>4.1 实战目标</strong></h3><p>&emsp;&emsp;通过阅读Javac编译器的源码，我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成，在本节的实战中，我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。</p><p>&emsp;&emsp;当然，由于我们的实战都是为了学习和演示技术原理，而不是为了做出一款能媲美CheckStyle等工具的产品来，所以NameCheckProcessor的目标也仅定为对Java程序命名进行检查，根据《Java语言规范（第3版）》中第6.8节的要求，Java程序命名应当符合下列格式的书写规范。</p><blockquote><ul><li>类（或接口）：符合驼式命名法，首字母大写。</li></ul></blockquote><blockquote><ul><li>方法：符合驼式命名法，首字母小写。</li></ul></blockquote><blockquote><ul><li>字段：</li></ul><p>&emsp;&emsp;&emsp;&emsp;类或实例变量：符合驼式命名法，首字母小写。</p><p>&emsp;&emsp;&emsp;&emsp;常量：要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。</p></blockquote><p>&emsp;&emsp;上文提到的驼式命名法（Camel Case Name），正如它的名称所表示的那样，是指混合使用大小写字母来分割构成变量或函数的名字，犹如驼峰一般，这是当前Java语言中主流的命名规范，我们的实战目标就是为Javac编译器添加一个额外的功能，在编译程序时检查程序名是否符合上述对类（或接口）、方法、字段的命名要求[1]。 </p><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a><strong>4.2 代码实现</strong></h3><p>&emsp;&emsp;要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process()”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process()方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init()方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。</p><p>&emsp;&emsp;注解处理器除了process()方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。</p><p>&emsp;&emsp;每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process()方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process()方法的返回值都是false。关于注解处理器的API，作者就简单介绍这些，对这个领域有兴趣的读者可以阅读相关的帮助文档。下面来看看注解处理器NameCheckProcessor的具体代码，如代码清单10-11所示。</p><p>&emsp;&emsp;代码清单10-11　注解处理器NameCheckProcessor</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用"*"表示支持所有Annotations @SupportedAnnotationTypes("*") </span></span><br><span class="line"><span class="comment">//只支持JDK 1.6的Java代码 @SupportedSourceVersion(SourceVersion.RELEASE_6) </span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">NameChecker</span> nameChecker; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *初始化名称检查插件 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    public void init(<span class="type">ProcessingEnvironment</span> processingEnv)&#123; </span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv); </span><br><span class="line">        nameChecker = <span class="keyword">new</span> <span class="type">NameChecker</span>(processingEnv); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 对输入的语法树的各个节点进行名称检查 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    public boolean process(<span class="type">Set</span>&lt;? <span class="keyword">extends</span> <span class="type">TypeElement</span>&gt; annotations, <span class="type">RoundEnvironment</span> roundEnv)&#123; </span><br><span class="line">        <span class="keyword">if</span>(!roundEnv.processingOver())&#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">Element</span> element : roundEnv.getRootElements()) </span><br><span class="line">                nameChecker.checkNames(element); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面代码可以看出，NameCheckProcessor能处理基于JDK 1.6的源码，它不限于特定的注解，对任何代码都“感兴趣”，而在process()方法中是把当前Round中的每一个RootElement传递到一个名为NameChecker的检查器中执行名称检查逻辑，NameChecker的代码如代码清单10-12所示。</p><p>&emsp;&emsp;代码清单10-12　命名检查器NameChecker</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 程序名称规范的编译器插件：&lt;br&gt; </span></span><br><span class="line"><span class="comment"> * 如果程序命名不合规范, 将会输出一个编译器的WARNING信息 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NameChecker&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager; </span><br><span class="line">    NameCheckScanner nameCheckScanner = <span class="keyword">new</span> NameCheckScanner(); </span><br><span class="line"></span><br><span class="line">    NameChecker(ProcessingEnvironment processsingEnv)&#123; </span><br><span class="line">        <span class="keyword">this</span>.messager = processsingEnv.getMessager(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *对Java程序命名进行检查, 根据《Java语言规范(第3版)》第6.8节的要求, Java程序命名应当符合下列格式： </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * &lt;ul&gt; </span></span><br><span class="line"><span class="comment">     *     &lt;li&gt;类或接口：符合驼式命名法, 首字母大写。 </span></span><br><span class="line"><span class="comment">     *     &lt;li&gt;方法：符合驼式命名法, 首字母小写。 </span></span><br><span class="line"><span class="comment">     * &lt;li&gt;字段： </span></span><br><span class="line"><span class="comment">     * &lt;ul&gt; </span></span><br><span class="line"><span class="comment">     *     &lt;li&gt;类、实例变量：符合驼式命名法, 首字母小写。 </span></span><br><span class="line"><span class="comment">     *     &lt;li&gt;常量：要求全部大写。 </span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt; </span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt; </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> checkNames(Element element)&#123; </span><br><span class="line">        nameCheckScanner.scan(element); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 名称检查器实现类, 继承了JDK 1.6中新提供的ElementScanner6&lt;br&gt; </span></span><br><span class="line"><span class="comment">     * 将会以Visitor模式访问抽象语法树中的元素 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> NameCheckScanner <span class="keyword">extends</span> ElementScanner6&lt;<span class="keyword">Void</span>, <span class="keyword">Void</span>&gt;&#123; </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 此方法用于检查Java类 </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        @Override </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Void</span> visitType(TypeElement e, <span class="keyword">Void</span> p)&#123; </span><br><span class="line">            scan(e.getTypeParameters(), p); </span><br><span class="line">            checkCamelCase(e, <span class="keyword">true</span>); </span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 检查方法命名是否合法 </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        @Override </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Void</span> visitExecutable(ExecutableElement e, <span class="keyword">Void</span> p)&#123; </span><br><span class="line">            <span class="keyword">if</span>(e.getKind() == METHOD)&#123; </span><br><span class="line">                Name name=e.getSimpleName(); </span><br><span class="line">                <span class="keyword">if</span> (name.contentEquals(e.getEnclosingElement().getSimpleName())) </span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"一个普通方法"</span> + name + <span class="string">"不应当与类名重复, 避免与构造函数产生混淆"</span>, e); </span><br><span class="line">                </span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 检查变量命名是否合法 </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        @Override </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Void</span> visitVariable(VariableElement e, <span class="keyword">Void</span> p)&#123; </span><br><span class="line">            <span class="comment">//如果这个Variable是枚举或常量, 则按大写命名检查, 否则按照驼式命名法规则检查 </span></span><br><span class="line">            <span class="keyword">if</span>(e.getKind() == ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> || heuristicallyConstant(e)) </span><br><span class="line">                checkAllCaps(e); </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                checkCamelCase(e,<span class="keyword">false</span>); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 判断一个变量是否是常量 </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> heuristicallyConstant(VariableElement e)&#123; </span><br><span class="line">            <span class="keyword">if</span>(e.getEnclosingElement().getKind() == <span class="keyword">INTERFACE</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e.getKind() == FIELD&amp;&amp;e.getModifiers().containsAll(EnumSet.of(<span class="keyword">PUBLIC</span>,<span class="keyword">STATIC</span>,<span class="keyword">FINAL</span>))) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">            <span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 检查传入的Element是否符合驼式命名法, 如果不符合, 则输出警告信息 </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> checkCamelCase(Element e, <span class="keyword">boolean</span> initialCaps)&#123; </span><br><span class="line">            String name = e.getSimpleName().toString(); </span><br><span class="line">            <span class="keyword">boolean</span> previousUpper = <span class="keyword">false</span>; </span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>; </span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>); </span><br><span class="line">            <span class="keyword">if</span>(Character.isUpperCase(firstCodePoint))&#123; </span><br><span class="line">                previousUpper = <span class="keyword">true</span>; </span><br><span class="line">                <span class="keyword">if</span>(!initialCaps)&#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称"</span><span class="string">"+name+"</span><span class="string">"应当以小写字母开头"</span>, e); </span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Character.isLowerCase(firstCodePoint))&#123; </span><br><span class="line">                <span class="keyword">if</span>(initialCaps)&#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称"</span><span class="string">"+name+"</span><span class="string">"应当以大写字母开头"</span>, e); </span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> </span><br><span class="line">                conventional = <span class="keyword">false</span>; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(conventional)&#123; </span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = Character.charCount(cp);i&lt;name.length();i += Character.charCount(cp))&#123; </span><br><span class="line">                    cp = name.codePointAt(i); </span><br><span class="line">                    <span class="keyword">if</span>(Character.isUpperCase(cp))&#123; </span><br><span class="line">                        <span class="keyword">if</span>(previousUpper)&#123; </span><br><span class="line">                            conventional = <span class="keyword">false</span>; </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; </span><br><span class="line">                        previousUpper = <span class="keyword">true</span>; </span><br><span class="line">                    &#125;<span class="keyword">else</span> </span><br><span class="line">                        previousUpper = <span class="keyword">false</span>; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!conventional) </span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"名称"</span><span class="string">"+name+"</span><span class="string">"应当符合驼式命名法(Camel Case Names)"</span>, e); </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         *大写命名检查, 要求第一个字母必须是大写的英文字母, 其余部分可以是下划线或大写字母 </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> checkAllCaps(Element e)&#123; </span><br><span class="line">            String name = e.getSimpleName().toString(); </span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>; </span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>); </span><br><span class="line">            <span class="keyword">if</span>(!Character.isUpperCase(firstCodePoint)) </span><br><span class="line">                conventional = <span class="keyword">false</span>; </span><br><span class="line">            <span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="keyword">boolean</span> previousUnderscore = <span class="keyword">false</span>; </span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = Character.charCount(cp);i&lt;name.length();i+ = Character.charCount(cp))&#123; </span><br><span class="line">                    cp = name.codePointAt(i); </span><br><span class="line">                    <span class="keyword">if</span>(cp == (<span class="keyword">int</span>) <span class="string">'_'</span>)&#123; </span><br><span class="line">                        <span class="keyword">if</span>(previousUnderscore)&#123; </span><br><span class="line">                            conventional = <span class="keyword">false</span>; </span><br><span class="line">                            <span class="keyword">break</span>; </span><br><span class="line">                        &#125; </span><br><span class="line">                        previousUnderscore = <span class="keyword">true</span>; </span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                        previousUnderscore = <span class="keyword">false</span>; </span><br><span class="line">                        <span class="keyword">if</span>(!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>; </span><br><span class="line">                            <span class="keyword">break</span>; </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!conventional) </span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"常量"</span> + name + <span class="string">"应当全部以大写字母或下划线命名, 并且以字母开头"</span>, e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;NameChecker的代码看起来有点长，但实际上注释占了很大一部分，其实即使算上注释也不到190行。它通过一个继承于javax.lang.model.util.ElementScanner6的NameCheckScanner类，以Visitor模式来完成对语法树的遍历，分别执行visitType()、visitVariable()和visitExecutable()方法来访问类、字段和方法，这3个visit方法对各自的命名规则做相应的检查，checkCamelCase()与checkAllCaps()方法则用于实现驼式命名法和全大写命名规则的检查。</p><p>&emsp;&emsp;整个注解处理器只需NameCheckProcessor和NameChecker两个类就可以全部完成，为了验证我们的实战成果，代码清单10-13中提供了一段命名规范的“反面教材”代码，其中的每一个类、方法及字段的命名都存在问题，但是使用普通的Javac编译这段代码时不会提示任何一个Warning信息。</p><p>&emsp;&emsp;代码清单10-13　包含了多处不规范命名的代码样例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span></span>&#123; </span><br><span class="line">    <span class="keyword">enum</span> colors&#123; red,blue,green; &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> int_FORTY_TWO = <span class="number">42</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT = _FORTY_TWO; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BADLY_NAMED_CODE</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NOTcamelCASEmethodNAME</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-运行与测试"><a href="#4-3-运行与测试" class="headerlink" title="4.3 运行与测试"></a><strong>4.3 运行与测试</strong></h3><p>&emsp;&emsp;我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，本次实战中的NameCheckProcessor的编译及执行过程如代码清单10-14所示。</p><p>&emsp;&emsp;代码清单10-14　注解处理器的运行过程</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">D:</span>\src&gt;javac org<span class="regexp">/fenixsoft/</span>compile/NameChecker.java </span><br><span class="line"><span class="string">D:</span>\src&gt;javac org<span class="regexp">/fenixsoft/</span>compile/NameCheckProcessor.java </span><br><span class="line"><span class="string">D:</span>\src&gt;javac-processor org.fenixsoft.compile.NameCheckProcessor org<span class="regexp">/fenixsoft/</span>compile/BADLY_NAMED_CODE.java </span><br><span class="line"></span><br><span class="line">org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">3</span>:警告:名称<span class="string">"BADLY_NAMED_CODE"</span>应当符合驼式命名法(Camel Case Names) </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span>&#123;</span> </span><br><span class="line">    ^ </span><br><span class="line">    org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">5</span>:警告:名称<span class="string">"colors"</span>应当以大写字母开头 </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">colors</span>&#123;</span> </span><br><span class="line">        ^ org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">6</span>:警告:常量<span class="string">"red"</span>应当全部以大写字母或下划线命名, 并且以字母开头 </span><br><span class="line">        red,blue,green; </span><br><span class="line">        ^ org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">6</span>:警告:常量<span class="string">"blue"</span>应当全部以大写字母或下划线命名, 并且以字母开头 </span><br><span class="line">        red,blue,green; </span><br><span class="line">        ^ org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">6</span>:警告:常量<span class="string">"green"</span>应当全部以大写字母或下划线命名, 并且以字母开头 </span><br><span class="line">        red,blue,green; </span><br><span class="line">        ^ org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">9</span>:警告:常量<span class="string">"_FORTY_TWO"</span>应当全部以大写字母或下划线命名, 并且以字母开头 </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> int_FORTY_TWO=<span class="number">42</span>; </span><br><span class="line">        ^ org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">11</span>:警告:名称<span class="string">"NOT_A_CONSTANT"</span>应当以小写字母开头 </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT=_FORTY_TWO; </span><br><span class="line">        ^ org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">13</span>:警告:名称<span class="string">"Test"</span>应当以小写字母开头 </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> Test()&#123; </span><br><span class="line">            ^ org\fenixsoft\compile\BADLY_NAMED_CODE.<span class="string">java:</span><span class="number">17</span>:警告:名称<span class="string">"NOTcamelCASEmethodNAME"</span>应当以小写字母开头</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> NOTcamelCASEmethodNAME()&#123;</span><br></pre></td></tr></table></figure><h3 id="4-4-其他应用案例"><a href="#4-4-其他应用案例" class="headerlink" title="4.4 其他应用案例"></a><strong>4.4 其他应用案例</strong></h3><p>&emsp;&emsp;NameCheckProcessor的实战例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processor[1]（本质上与NameCheckProcessor所做的事情差不多）、自动为字段生成getter和setter方法的Project Lombok[2]（根据已有元素生成新的语法树元素）等，读者有兴趣的话可以参考它们官方站点的相关内容。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的编译期优化，包括：实战目标，代码实现，运行与测试，其他应用案例等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>编译期优化-Javac编译器</title>
    <link href="http://linyishui.top/2019122002.html"/>
    <id>http://linyishui.top/2019122002.html</id>
    <published>2019-12-20T10:27:38.000Z</published>
    <updated>2020-01-14T03:23:09.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编译期优化-Javac编译器"><a href="#编译期优化-Javac编译器" class="headerlink" title="编译期优化-Javac编译器"></a><strong>编译期优化-Javac编译器</strong></h1><h2 id="第二节-Javac编译器"><a href="#第二节-Javac编译器" class="headerlink" title="第二节 Javac编译器"></a><strong>第二节 Javac编译器</strong></h2><p>&emsp;&emsp;分析源码是了解一项技术的实现内幕最有效的手段，Javac编译器不像HotSpot虚拟机那样使用C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序，这为纯Java的程序员了解它的编译过程带来了很大的便利。</p><h3 id="2-1-Javac的源码与调试"><a href="#2-1-Javac的源码与调试" class="headerlink" title="2.1 Javac的源码与调试"></a><strong>2.1 Javac的源码与调试</strong></h3><p>&emsp;&emsp;Javac的源码存放在JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac中[1]，除了JDK自身的API外，就只引用了JDK_SRC_HOME/langtools/src/share/classes/com/sun/*里面的代码，调试环境建立起来简单方便，因为基本上不需要处理依赖关系。</p><p>&emsp;&emsp;以Eclipse IDE环境为例，先建立一个名为“Compiler_javac”的Java工程，然后把JDK_SRC_HOME/langtools/src/share/classes/com/sun/*目录下的源文件全部复制到工程的源码目录中，如图10-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010207.png" alt="Eclipse中的Javac工程"></p><p>&emsp;&emsp;导入代码期间，源码文件“AnnotationProxyMaker.java”可能会提示“Access Restriction”，被Eclipse拒绝编译，如图10-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010208.png" alt="AnnotationProxyMaker被拒绝编译"></p><p>&emsp;&emsp;这是由于Eclipse的JRE System Library中默认包含了一系列的代码访问规则（Access Rules），如果代码中引用了这些访问规则所禁止引用的类，就会提示这个错误。可以通过添加一条允许访问JAR包中所有类的访问规则来解决这个问题，如图10-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010209.png" alt="设置访问规则"></p><p>&emsp;&emsp;导入了Javac的源码后，就可以运行com.sun.tools.javac.Main的main()方法来执行编译了，与命令行中使用Javac的命令没有什么区别，编译的文件与参数在Eclipse的“Debug Configurations”面板中的“Arguments”页签中指定。</p><p>&emsp;&emsp;虚拟机规范严格定义了Class文件的格式，但是《Java虚拟机规范（第2版）》中，虽然有专门的一章“Compiling for the Java Virtual Machine”，但都是以举例的形式描述，并没有对如何把Java源码文件转变为Class文件的编译过程进行十分严格的定义，这导致Class文件编译 在某种程度上是与具体JDK实现相关的，在一些极端情况，可能出现一段代码Javac编译器可以编译，但是ECJ编译器就不可以编译的问题（10.3.1节中将会给出这样的例子）。从Sun Javac的代码来看，编译过程大致可以分为3个过程，分别是：</p><blockquote><ul><li>解析与填充符号表过程。</li><li>插入式注解处理器的注解处理过程。</li><li>分析与字节码生成过程。</li></ul></blockquote><p>&emsp;&emsp;这3个步骤之间的关系与交互顺序如图10-4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010210.png" alt="Javac的编译过程"></p><p>&emsp;&emsp;Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，其中主体代码如图10-5所示，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010211.png" alt="Javac编译过程的主体代码"></p><h3 id="2-2-解析与填充符号表"><a href="#2-2-解析与填充符号表" class="headerlink" title="2.2 解析与填充符号表"></a><strong>2.2 解析与填充符号表</strong></h3><p>&emsp;&emsp;解析步骤由图10-5中的parseFiles()方法（图10-5中的过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。</p><h4 id="2-2-1-词法、语法分析"><a href="#2-2-1-词法、语法分析" class="headerlink" title="2.2.1 词法、语法分析"></a><strong>2.2.1 词法、语法分析</strong></h4><p>&emsp;&emsp;词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a = b + 2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p><p>&emsp;&emsp;语法分析是根据Token序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p><p>&emsp;&emsp;图10-6是根据Eclipse AST View插件分析出来的某段代码的抽象语法树视图，读者可以通过这张图对抽象语法树有一个直观的认识。在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010212.png" alt="抽象语法树结构视图"></p><h4 id="2-2-2-填充符号表"><a href="#2-2-2-填充符号表" class="headerlink" title="2.2.2 填充符号表"></a><strong>2.2.2 填充符号表</strong></h4><p>&emsp;&emsp;完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是图10-5中enterTrees()方法（图10-5中的过程1.2）所做的事情。符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，读者可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</p><p>&emsp;&emsp;在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p><h3 id="2-3-注解处理器"><a href="#2-3-注解处理器" class="headerlink" title="2.3 注解处理器"></a><strong>2.3 注解处理器</strong></h3><p>&emsp;&emsp;在JDK1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范[1]，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是图10-4中的回环过程。</p><p>&emsp;&emsp;有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情，本章最后会给出一个使用插入式注解处理器的简单实战。</p><p>&emsp;&emsp;在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成的，这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing()方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。</p><h3 id="2-4-语义分析与字节码生成"><a href="#2-4-语义分析与字节码生成" class="headerlink" title="2.4 语义分析与字节码生成"></a><strong>2.4 语义分析与字节码生成</strong></h3><p>&emsp;&emsp;语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。举个例子，假设有如下的3个变量定义语句：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int a</span>=1; </span><br><span class="line"><span class="attribute">boolean b</span> = false; </span><br><span class="line"><span class="attribute">char c</span>=2;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;后续可能出现的赋值运算：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int d</span> = a + c; </span><br><span class="line"><span class="attribute">int d</span> = b + c; </span><br><span class="line"><span class="attribute">char d</span> = a + c;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;后续代码中如果出现了如上3种赋值运算的话，那它们都能构成结构正确的语法树，但是只有第1种的写法在语义上是没有问题的，能够通过编译，其余两种在Java语言中是不合逻辑的，无法编译（是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有意义。如在C语言中，a、b、c的上下文定义不变，第2、3种写法都是可以正确编译）。</p><h4 id="2-4-1-标注检查"><a href="#2-4-1-标注检查" class="headerlink" title="2.4.1 标注检查"></a><strong>2.4.1 标注检查</strong></h4><p>&emsp;&emsp;Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由图10-5中所示的attribute()和flow()方法（分别对应图10-5中的过程3.1和过程3.2）完成。</p><p>&emsp;&emsp;标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int a</span> = 1 + 2;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，如图10-7所示，这个插入式表达式（Infix Expression）的值已经在语法树上标注出来了（ConstantExpressionValue：3）。由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010213.png" alt="常量折叠"></p><p>&emsp;&emsp;标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类。</p><h4 id="2-4-2-数据及控制流分析"><a href="#2-4-2-数据及控制流分析" class="headerlink" title="2.4.2 数据及控制流分析"></a><strong>2.4.2 数据及控制流分析</strong></h4><p>&emsp;&emsp;数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。下面举一个关于final修饰符的数据及控制流分析的例子，见代码清单10-1。</p><p>&emsp;&emsp;代码清单10-1　final语义校验</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一带有final修饰 </span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arg)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> var=<span class="number">0</span>; </span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二没有final修饰 </span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> var=<span class="number">0</span>; </span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这两个foo()方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，通过第6章的讲解我们已经知道，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。在Javac的源码中，数据及控制流分析的入口是图10-5中的flow()方法（对应图10-5中的过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p><h4 id="2-4-3-解语法糖"><a href="#2-4-3-解语法糖" class="headerlink" title="2.4.3 解语法糖"></a><strong>2.4.3 解语法糖</strong></h4><p>&emsp;&emsp;语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J.Landin）发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p><p>&emsp;&emsp;Java在现代编程语言之中属于“低糖语言”（相对于C#及许多其他JVM语言来说），尤其是JDK 1.5之前的版本，“低糖”语法也是Java语言被怀疑已经“落后”的一个表面理由。Java中最常用的语法糖主要是前面提到过的泛型（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。Java的这些语法糖被解除后是什么样子，将在10.3节中详细讲述。</p><p>&emsp;&emsp;在Javac的源码中，解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。</p><h4 id="2-4-4-字节码生成"><a href="#2-4-4-字节码生成" class="headerlink" title="2.4.4 字节码生成"></a><strong>2.4.4 字节码生成</strong></h4><p>&emsp;&emsp;字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p><p>&emsp;&emsp;例如，前面章节中多次提到的实例构造器＜init＞()方法和类构造器＜clinit＞()方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器，＜clinit＞()方法中无须调用父类的＜clinit＞()方法，虚拟机会自动保证父类构造器的执行，但在＜clinit＞()方法中经常会生成调用java.lang.Object的＜init＞()方法的代码）等操作收敛到＜init＞()和＜clinit＞()方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs()方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK1.5）的append()操作等。</p><p>&emsp;&emsp;完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass()方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的编译期优化-Javac编译器，包括：Javac的源码与调试，解析与填充符号表（词法、语法分析、填充符号表），注解处理器，语义分析与字节码生成（标注检查、数据及控制流分析、解语法糖、字节码生成）等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>编译期优化</title>
    <link href="http://linyishui.top/2019122001.html"/>
    <id>http://linyishui.top/2019122001.html</id>
    <published>2019-12-20T10:03:08.000Z</published>
    <updated>2020-01-14T07:24:19.881Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a><strong>虚拟机字节码执行引擎</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛 车。</p><p>&emsp;&emsp;Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把<em>.java文件转变成</em>.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程；还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码的过程。下面列举了这3类编译过程中一些比较有代表性的编译器。</p><blockquote><ul><li>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）[1]。</li><li>JIT编译器：HotSpot VM的C1、C2编译器。</li><li>AOT编译器：GNU Compiler for the Java（GCJ）[2]、Excelsior JET[3]。</li></ul></blockquote><p>&emsp;&emsp;这3类过程中最符合大家对Java程序编译认知的应该是第一类，在本章的后续文字里，作者提到的“编译期”和“编译器”都仅限于第一类编译过程，把第二类编译过程留到下一章中讨论。限制了编译范围后，我们对于“优化”二字的定义就需要宽松一些，因为Javac这类编译器对代码的运行效率几乎没有任何优化措施（在JDK 1.3之后，Javac的-O优化参数就不再有意义）。虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由Javac产生的Class文件（如JRuby、Groovy等语言的Class文件）也同样能享受到编译器优化所带来的好处。但是Javac做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖虚拟机的底层改进来支持，可以说，Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。</p><hr><h2 id="第二节-Javac编译器"><a href="#第二节-Javac编译器" class="headerlink" title="第二节 Javac编译器"></a><strong>第二节 Javac编译器</strong></h2><p>&emsp;&emsp;<a href="../2019122002.html" title="Title">编译期优化-Javac编译器</a></p><hr><h2 id="第三节-Java语法糖的味道"><a href="#第三节-Java语法糖的味道" class="headerlink" title="第三节 Java语法糖的味道"></a><strong>第三节 Java语法糖的味道</strong></h2><p>&emsp;&emsp;<a href="../2019122101.html" title="Title">编译期优化-Java语法糖</a></p><hr><h2 id="第四节-实战：插入式注解处理器"><a href="#第四节-实战：插入式注解处理器" class="headerlink" title="第四节 实战：插入式注解处理器"></a><strong>第四节 实战：插入式注解处理器</strong></h2><p>&emsp;&emsp;<a href="../2019122201.html" title="Title">编译期优化-实战</a></p><hr><h2 id="第五节-总结"><a href="#第五节-总结" class="headerlink" title="第五节 总结"></a><strong>第五节 总结</strong></h2><p>&emsp;&emsp;在本章中，我们从编译器源码实现的层次上了解了Java源代码编译为字节码的过程，分析了Java语言中泛型、主动装箱/拆箱、条件编译等多种语法糖的前因后果，并实战练习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。如本章概述中所说的那样，在前端编译器中，“优化”手段主要用于提升程序的编码效率，之所以把Javac这类将Java代码转变为字节码的编译器称做“前端编译器”，是因为它只完成了从程序到抽象语法树或中间字节码的生成，而在此之后，还有一组内置于虚拟机内部的“后端编译器”完成了从字节码生成本地机器码的过程，即前面多次提到的即时编译器或JIT编译器，这个编译器的编译速度及编译结果的优劣，是衡量虚拟机性能一个很重要的指标。在第11章中，我们将会介绍即时编译器的运作和优化过程。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的编译期优化，包括：概述，Javac编译器，Java语法糖的味道，实战：插入式注解处理器，总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载集执行子系统的案例与实战-实战</title>
    <link href="http://linyishui.top/2019121901.html"/>
    <id>http://linyishui.top/2019121901.html</id>
    <published>2019-12-19T09:58:55.000Z</published>
    <updated>2020-01-14T07:23:53.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类加载集执行子系统的案例与实战-实战"><a href="#类加载集执行子系统的案例与实战-实战" class="headerlink" title="类加载集执行子系统的案例与实战-实战"></a><strong>类加载集执行子系统的案例与实战-实战</strong></h1><h2 id="第三节-实战：自己动手实现远程执行功能"><a href="#第三节-实战：自己动手实现远程执行功能" class="headerlink" title="第三节 实战：自己动手实现远程执行功能"></a><strong>第三节 实战：自己动手实现远程执行功能</strong></h2><p>&emsp;&emsp;不知道读者在做程序维护的时候是否遇到过这类情形：排查问题的过程中，想查看内存中的一些参数值，却又没有方法把这些值输出到界面或日志中，又或者定位到某个缓存数据有问题，但缺少缓存的统一管理界面，不得不重启服务才能清理这个缓存。类似的需求有一个共同的特点，那就是只要在服务中执行一段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行临时代码的途径，这时候就会希望Java服务器中也有提供类似Groovy Console的功能。</p><p>&emsp;&emsp;JDK 1.6之后提供了Compiler API，可以动态地编译Java程序，虽然这样达不到动态语言的灵活度，但让服务器执行临时代码的需求就可以得到解决了。在JDK 1.6之前，也可以通过其他方式来做到，譬如写一个JSP文件上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个BeanShell Script、JavaScript等的执行引擎（如Mozilla Rhino[1]）去执行动态脚本。在本章的实战部分，我们将使用前面学到的关于类加载及虚拟机执行子系统的知识去实现在服务端执行临时代码的功能。</p><h3 id="3-1-目标"><a href="#3-1-目标" class="headerlink" title="3.1 目标"></a><strong>3.1 目标</strong></h3><p>&emsp;&emsp;首先，在实现“在服务端执行临时代码”这个需求之前，先来明确一下本次实战的具体目标，我们希望最终的产品是这样的：</p><blockquote><ul><li>不依赖JDK版本，能在目前还普遍使用的JDK中部署，也就是使用JDK 1.4～JDK 1.7都可以运行。</li><li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li><li>不侵入原有程序，即无须改动原程序的任何代码，也不会对原有程序的运行带来任何影响。</li><li>考到BeanShellScript或JavaScript等脚本编写起来不太方便，“临时代码”需要直接支持Java语言。</li><li>“临时代码”应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。这里写的是“不需要”而不是“不可以”，当“临时代码”需要引用其他类库时也没有限制，只要服务端程序能使用的，临时代码应当都能直接引用。</li><li>“临时代码”的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li></ul></blockquote><p>&emsp;&emsp;看完上面列出的目标，你觉得完成这个需求需要做多少工作呢？也许答案比大多数人所想的都要简单一些：5个类，250行代码（含注释），大约一个半小时左右的开发时间就可以了，现在就开始编写程序吧！</p><h3 id="3-2-思路"><a href="#3-2-思路" class="headerlink" title="3.2 思路"></a><strong>3.2 思路</strong></h3><p>&emsp;&emsp;在程序实现的过程中，我们需要解决以下3个问题：</p><blockquote><ul><li>如何编译提交到服务器的Java代码？</li><li>如何执行编译之后的Java代码？</li><li>如何收集Java代码的执行结果？</li></ul></blockquote><p>&emsp;&emsp;对于第一个问题，我们有两种思路可以选择，一种是使用tools.jar包（在Sun JDK/lib目录下）中的com.sun.tools.javac.Main类来编译Java文件，这其实和使用Javac命令编译是一样的。这种思路的缺点是引入了额外的JAR包，而且把程序“绑死”在Sun的JDK上了，要部署到其他公司的JDK中还得把tools.jar带上（虽然JRockit和J9虚拟机也有这个JAR包，但它总不是标准所规定必须存在的）。另外一种思路是直接在客户端编译好，把字节码而不是Java代码传到服务端，这听起来好像有点投机取巧，一般来说确实不应该假定客户端一定具有编译代码的能力，但是既然程序员会写Java代码去给服务端排查问题，那么很难想象他的机器上会连编译Java程序的环境都没有。</p><p>&emsp;&emsp;对于第二个问题，简单地一想：要执行编译后的Java代码，让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法就可以了（因为不实现任何接口，我们可以借用一下Java中人人皆知的“main()”方法）。但我们还应该考虑得更周全些：一段程序往往不是编写、运行一次就能达到效果，同一个类可能要反复地修改、提交、执行。另外，提交上去的类要能访问服务端的其他类库才行。还有，既然提交的是临时代码，那提交的Java类在执行完后就应当能卸载和回收。</p><p>&emsp;&emsp;最后的一个问题，我们想把程序往标准输出（System.out）和标准错误输出（System.err）中打印的信息收集起来，但标准输出设备是整个虚拟机进程全局共享的资源，如果使用System.setOut()/System.setErr()方法把输出流重定向到自己定义的PrintStream对象上固然可以收集输出信息，但也会对原有程序产生影响：会把其他线程向标准输出中打印的信息也收集了。虽然这些并不是不能解决的问题，不过为了达到完全不影响原程序的目的，我们可以采用另外一种办法，即直接在执行的类中把对System.out的符号引用替换为我们准备的PrintStream的符号引用，依赖前面学习的知识，做到这一点并不困难。</p><h3 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a><strong>3.3 实现</strong></h3><p>&emsp;&emsp;在程序实现部分，我们主要看一下代码及其注释。首先看看实现过程中需要用到的4个支持类。第一个类用于实现“同一个类的代码可以被多次加载”这个需求，即用于解决9.3.1节中列举的第2个问题的HotSwapClassLoader，具体程序如代码清单9-3所示。</p><p>&emsp;&emsp;代码清单9-3　HotSwapClassLoader的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *为了多次载入执行类而加入的加载器&lt;br&gt; </span></span><br><span class="line"><span class="comment"> *把defineClass方法开放出来, 只有外部显式调用的时候才会使用到loadByte方法 </span></span><br><span class="line"><span class="comment"> *由虚拟机调用时, 仍然按照原有的双亲委派规则使用loadClass方法进行类加载 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HotSwapClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123; </span><br><span class="line">    public <span class="type">HotSwapClassLoader</span>()&#123; </span><br><span class="line">        <span class="keyword">super</span>(<span class="type">HotSwapClassLoader</span>.<span class="keyword">class</span>.getClassLoader()); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public <span class="type">Class</span> loadByte(byte[]classByte)&#123; </span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="literal">null</span>,classByte, <span class="number">0</span>, classByte.length); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;HotSwapClassLoader所做的事情仅仅是公开父类（即java.lang.ClassLoader）中的protected方法defineClass()，我们将会使用这个方法把提交执行的Java类的byte[]数组转变为Class对象。HotSwapClassLoader中并没有重写loadClass()或findClass()方法，因此如果不算外部手工调用loadByte()方法的话，这个类加载器的类查找范围与它的父类加载器是完全一致的，在被虚拟机调用时，它会按照双亲委派模型交给父类加载。构造函数中指定为加载HotSwapClassLoader类的类加载器作为父类加载器，这一步是实现提交的执行代码可以访问服务端引用类库的关键，下面我们来看看代码清单9-3。</p><p>&emsp;&emsp;第二个类是实现将java.lang.System替换为我们自己定义的HackSystem类的过程，它直接修改符合Class文件格式的byte[]数组中的常量池部分，将常量池中指定内容的CONSTANT_Utf8_info常量替换为新的字符串，具体代码如代码清单9-4所示。ClassModifier中涉及对byte[]数组操作的部分，主要是将byte[]与int和String互相转换，以及把对byte[]数据的替换操作封装在代码清单9-5所示的ByteUtils中。</p><p>&emsp;&emsp;代码清单9-4　ClassModifier的实现</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *修改Class文件, 暂时只提供修改常量池常量的功能 </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class ClassModifier&#123; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CONSTANT_Utf8_info = <span class="number">1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *常量池中11种常量所占的长度, CONSTANT_Utf8_info型常量除外, 因为它不是定长的 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span>[] CONSTANT_ITEM_LENGTH = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> u1 = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> u2 = <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">byte</span>[] classByte; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ClassModifier(<span class="built_in">byte</span>[] classByte)&#123; </span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容 </span></span><br><span class="line"><span class="comment">     * @param oldStr修改前的字符串 </span></span><br><span class="line"><span class="comment">     * @param newStr修改后的字符串 </span></span><br><span class="line"><span class="comment">     * @return修改结果 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] modifyUTF8Constant(<span class="keyword">String</span> oldStr,<span class="keyword">String</span> newStr)&#123; </span><br><span class="line">        <span class="built_in">int</span> cpc = getConstantPoolCount(); </span><br><span class="line">        <span class="built_in">int</span> offset = CONSTANT_POOL_COUNT_INDEX+u2; </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; cpc;i++)&#123; </span><br><span class="line">            <span class="built_in">int</span> tag = ByteUtils.bytes2Int(classByte,offset,u1); </span><br><span class="line">            <span class="keyword">if</span>(tag =  = CONSTANT_Utf8_info)&#123; </span><br><span class="line">                <span class="built_in">int</span> len = ByteUtils.bytes2Int(classByte,offset+u1, u2); </span><br><span class="line">                offset += (u1+u2); </span><br><span class="line">                <span class="keyword">String</span> <span class="built_in">str</span> = ByteUtils.bytes2String(classByte,offset,len); </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">str</span>.equalsIgnoreCase(oldStr))&#123; </span><br><span class="line">                    <span class="built_in">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="built_in">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2); </span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte,offset-u2, u2, strLen); </span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte,offset,len,strBytes); </span><br><span class="line">                    <span class="keyword">return</span> classByte; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    offset += len; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                offset+ = CONSTANT_ITEM_LENGTH[tag]; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> classByte; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量 </span></span><br><span class="line"><span class="comment">     * @return常量池数量 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> getConstantPoolCount()&#123; </span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte,CONSTANT_POOL_COUNT_INDEX,u2); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单9-5　ByteUtils的实现</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Bytes数组处理工具 </span></span><br><span class="line"><span class="comment"> * @author </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ByteUtils</span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span>(<span class="params"><span class="keyword">byte</span>[] b,<span class="keyword">int</span> start,<span class="keyword">int</span> len</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> end = start+len; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)&#123; </span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>)b[i])&amp;<span class="number">0xff</span>; n&lt;&lt; = (--len)*<span class="number">8</span>; sum = n+sum; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">int2Bytes</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span>,<span class="keyword">int</span> len</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len]; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123; </span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((<span class="keyword">value</span> &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span>(<span class="params"><span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b,start,len); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">string2Bytes</span>(<span class="params">String str</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> str.getBytes(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">bytesReplace</span>(<span class="params"><span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)]; </span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset); </span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes,offset,replaceBytes.length); </span><br><span class="line">        System.arraycopy(originalBytes, offset+len, newBytes, offset+replaceBytes.length, originalBytes.length - offset - len); </span><br><span class="line">        <span class="keyword">return</span> newBytes; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过ClassModifier处理后的byte[]数组才会传给HotSwapClassLoader.loadByte()方法进行类加载，byte[]数组在这里替换符号引用之后，与客户端直接在Java代码中引用HackSystem类再编译生成的Class是完全一样的。这样的实现既避免了客户端编写临时执行代码时要依赖特定的类（不然无法引入HackSystem），又避免了服务端修改标准输出后影响到其他程序的输出。下面我们来看看代码清单9-4和代码清单9-5。</p><p>&emsp;&emsp;最后一个类就是前面提到过的用来代替java.lang.System的HackSystem，这个类中的方法看起来不少，但其实除了把out和err两个静态变量改成使用ByteArrayOutputStream作为打印目标的同一个PrintStream对象，以及增加了读取、清理ByteArrayOutputStream中内容的getBufferString()和clearBuffer()方法外，就再没有其他新鲜的内容了。其余的方法全部都来自于System类的public方法，方法名字、参数、返回值都完全一样，并且实现也是直接转调了System类的对应方法而已。保留这些方法的目的，是为了在Sytem被替换成HackSystem之后，执行代码中调用的System的其余方法仍然可以继续使用，HackSystem的实现如代码清单9-6所示。</p><p>&emsp;&emsp;代码清单9-6　HackSystem的实现</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 为JavaClass劫持java.lang.System提供支持 </span></span><br><span class="line"><span class="comment"> * 除了out和err外, 其余的都直接转发给System处理 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackSystem</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = System.in;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream(); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">new</span> PrintStream(buffer); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = out; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">String <span class="title">getBufferString</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">return</span> buffer.<span class="title">toString</span><span class="params">()</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">()</span></span>&#123; </span><br><span class="line">        buffer.reset(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(<span class="keyword">final</span> SecurityManager s)</span></span>&#123; </span><br><span class="line">        System.setSecurityManager(s); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">return</span> System.<span class="title">getSecurityManager</span><span class="params">()</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">return</span> System.<span class="title">currentTimeMillis</span><span class="params">()</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>&#123; </span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">identityHashCode</span><span class="params">(Object x)</span></span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">return</span> System.<span class="title">identityHashCode</span><span class="params">(x)</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//下面所有的方法都与java.lang.System的名称一样 </span></span><br><span class="line">    <span class="comment">//实现都是字节转调System的对应方法 </span></span><br><span class="line">    <span class="comment">//因版面原因, 省略了其他方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，4个支持类已经讲解完毕，我们来看看最后一个类JavaClassExecuter，它是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。JavaClassExecuter只有一个execute()方法，用输入的符合Class文件格式的byte[]数组替换java.lang.System的符号引用后，使用HotSwapClassLoader加载生成一个Class对象，由于每次执行execute()方法都会生成一个新的类加载器实例，因此同一个类可以实现重复加载。然后，反射调用这个Class对象的main()方法，如果期间出现任何异常，将异常信息打印到HackSystem.out中，最后把缓冲区中的信息作为方法的结果返回。JavaClassExecuter的实现代码如代码清单9-7所示。</p><p>&emsp;&emsp;代码清单9-7　JavaClassExecuter的实现</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * JavaClass执行工具 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaClassExecuter</span></span>&#123; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的byte数组&lt;br&gt; </span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类 </span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法, 输出结果为该类向System.out/err输出的信息 </span></span><br><span class="line"><span class="comment">     * @param classByte代表一个Java类的byte数组 </span></span><br><span class="line"><span class="comment">     * @return执行结果 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> execute(byte[] classByte)&#123; </span><br><span class="line">        HackSystem.clearBuffer(); </span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> <span class="type">ClassModifier</span>(classByte); </span><br><span class="line">        byte[]modiBytes = cm.modifyUTF8Constant(<span class="string">"java/lang/System"</span>, <span class="string">"org/fenixsoft/classloading/execute/HackSystem"</span>); </span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> <span class="type">HotSwapClassLoader</span>(); </span><br><span class="line">        Class clazz = loader.loadByte(modiBytes); </span><br><span class="line">        <span class="keyword">try</span>&#123; </span><br><span class="line">            Method method = clazz.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> <span class="type">Class</span>[]&#123;<span class="keyword">String</span>[].class&#125;); </span><br><span class="line">            method.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="type">String</span>[]&#123;<span class="literal">null</span>&#125;); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e)&#123; </span><br><span class="line">            e.printStackTrace(HackSystem.out); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-验证"><a href="#3-4-验证" class="headerlink" title="3.4 验证"></a><strong>3.4 验证</strong></h3><p>&emsp;&emsp;远程执行功能的编码到此就完成了，接下来就要检验一下我们的劳动成果了。如果只是测试的话，那么可以任意写一个Java类，内容无所谓，只要向System.out输出信息即可，取名为TestClass，同时放到服务器C盘的根目录中。然后，建立一个JSP文件并加入如代码清单98所示的内容，就可以在浏览器中看到这个类的运行结果了。</p><p>&emsp;&emsp;代码清单9-8　测试JSP</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="keyword">@page</span> <span class="keyword">import</span> = <span class="string">"java.lang.*"</span>%&gt; </span><br><span class="line">&lt;%<span class="keyword">@page</span> <span class="keyword">import</span> = <span class="string">"java.io.*"</span>%&gt; </span><br><span class="line">&lt;%<span class="keyword">@page</span> <span class="keyword">import</span> = <span class="string">"org.fenixsoft.classloading.execute.*"</span>%&gt; </span><br><span class="line">    &lt;% InputStream <span class="keyword">is</span> = <span class="keyword">new</span> FileInputStream(<span class="string">"c:/TestClass.class"</span>); </span><br><span class="line">       <span class="keyword">byte</span>[]b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">is</span>.available()]; </span><br><span class="line">       <span class="keyword">is</span>.read(b); </span><br><span class="line">       <span class="keyword">is</span>.close(); </span><br><span class="line">       <span class="keyword">out</span>.println(<span class="string">"&lt;textarea style = 'width:1000;height = 800'&gt;"</span>); </span><br><span class="line">       <span class="keyword">out</span>.println(JavaClassExecuter.execute(b)); </span><br><span class="line">       <span class="keyword">out</span>.println(<span class="string">"&lt;/textarea&gt;"</span>); </span><br><span class="line">    %&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，上面的做法只是用于测试和演示，实际使用这个JavaExecuter执行器的时候，如果还要手工复制一个Class文件到服务器上就没有什么意义了。作者给这个执行器写了一个“外壳”，是一个Eclipse插件，可以把Java文件编译后传输到服务器中，然后把执行器的返回结果输出到Eclipse的Console窗口里，这样就可以在有灵感的时候随时写几行调试代码，放到测试环境的服务器上立即运行了。虽然实现简单，但效果很不错，对调试问题也非常有用，如图9-4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010206.png" alt="JavaClassExecuter的使用"></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的类加载集执行子系统的案例与实战-实战，包括：目标，思路，实现，验证等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载集执行子系统的案例与实战</title>
    <link href="http://linyishui.top/2019121801.html"/>
    <id>http://linyishui.top/2019121801.html</id>
    <published>2019-12-18T09:39:37.000Z</published>
    <updated>2020-01-14T07:23:46.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a><strong>虚拟机字节码执行引擎</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p><p>&emsp;&emsp;在Class文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不太多，Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路，这些思路后来成为了许多常用功能和程序实现的基础。在本章中，我们将看一下前面所学的知识在实际开发之中是如何应用的。</p><hr><h2 id="第二节-案例分析"><a href="#第二节-案例分析" class="headerlink" title="第二节 案例分析"></a><strong>第二节 案例分析</strong></h2><p>&emsp;&emsp;在案例分析部分，作者准备了4个例子，关于类加载器和字节码的案例各有两个。并且这两个领域的案例中各有一个案例是大多数Java开发人员都使用过的工具或技术，另外一个案例虽然不一定每个人都使用过，但却特别精彩地演绎出这个领域中的技术特性。希望这些案例能引起读者的思考，并给读者的日常工作带来灵感。</p><h3 id="2-1-Tomcat：正统的类加载器架构"><a href="#2-1-Tomcat：正统的类加载器架构" class="headerlink" title="2.1 Tomcat：正统的类加载器架构"></a><strong>2.1 Tomcat：正统的类加载器架构</strong></h3><p>&emsp;&emsp;主流的Java Web服务器，如Tomcat、Jetty、WebLogic、WebSphere或其他作者没有列举的服务器，都实现了自己定义的类加载器（一般都不止一个）。因为一个功能健全的Web服务器，要解决如下几个问题：</p><p>&emsp;&emsp;部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离。这是最基本的需求，两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一个类库在一个服务器中只有一份，服务器应当保证两个应用程序的类库可以互相独立使用。</p><p>&emsp;&emsp;部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。这个需求也很常见，例如，用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费——这主要倒不是浪费磁盘空间的问题，而是指类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方法区就会很容易出现过度膨胀的风险。</p><p>&emsp;&emsp;服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。目前，有许多主流的Java Web服务器自身也是使用Java语言来实现的。因此，服务器本身也有类库依赖的问题，一般来说，基于安全考虑，服务器所使用的类库应该与应用程序的类库互相独立。</p><p>&emsp;&emsp;支持JSP应用的Web服务器，大多数都需要支持HotSwap功能。我们知道，JSP文件最终要编译成Java Class才能由虚拟机执行，但JSP文件由于其纯文本存储的特性，运行时修改的概率远远大于第三方类库或程序自身的Class文件。而且ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的“优势”来看待，因此“主流”的Web服务器都会支持JSP生成类的热替换，当然也有“非主流”的，如运行在生产模式（Production Mode）下的WebLogic服务器默认就不会处理JSP文件的变化。</p><p>&emsp;&emsp;由于存在上述问题，在部署Web应用时，单独的一个ClassPath就无法满足需求了，所以各种Web服务器都“不约而同”地提供了好几个ClassPath路径供用户存放第三方类库，这些路径一般都以“lib”或“classes”命名。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常，每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。现在，作者就以Tomcat服务器[1]为例，看一看Tomcat具体是如何规划用户类库结构和类加载器的。</p><p>&emsp;&emsp;在Tomcat目录结构中，有3组目录（“/common/<em>”、“/server/</em>”和“/shared/<em>”）可以存放Java类库，另外还可以加上Web应用程序自身的目录“/WEB-INF/</em>”，一共4组，把Java类库放置在这些目录中的含义分别如下。</p><blockquote><ul><li>放置在/common目录中：类库可被Tomcat和所有的Web应用程序共同使用。</li><li>放置在/server目录中：类库可被Tomcat使用，对所有的Web应用程序都不可见。</li><li>放置在/shared目录中：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可<br>见。</li><li>放置在/WebApp/WEB-INF目录中：类库仅仅可以被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li></ul></blockquote><p>&emsp;&emsp;为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现，其关系如图9-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010203.png" alt="Tomcat服务器的类加载架构"></p><p>&emsp;&emsp;灰色背景的3个类加载器是JDK默认提供的类加载器，这3个加载器的作用在第7章中已经介绍过了。而CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载/common/<em>、/server/</em>、/shared/<em>和/WebApp/WEB-INF/</em>中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。</p><p>&emsp;&emsp;从图9-1的委派关系中可以看出，CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class，它出现的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。</p><p>&emsp;&emsp;对于Tomcat的6.x版本，只有指定了tomcat/conf/catalina.properties配置文件的server.loader和share.loader项后才会真正建立CatalinaClassLoader和SharedClassLoader的实例，否则会用到这两个类加载器的地方都会用CommonClassLoader的实例代替，而默认的配置文件中没有设置这两个loader项，所以Tomcat6.x顺理成章地把/common、/server和/shared三个目录默认合并到一起变成一个/lib目录，这个目录里的类库相当于以前/common目录中类库的作用。这是Tomcat设计团队为了简化大多数的部署场景所做的一项改进，如果默认设置不能满足需要，用户可以通过修改配置文件指定server.loader和share.loader的方式重新启用Tomcat5.x的加载器架构。</p><p>&emsp;&emsp;Tomcat加载器的实现清晰易懂，并且采用了官方推荐的“正统”的使用类加载器的方式。如果读者阅读完上面的案例后，能完全理解Tomcat设计团队这样布置加载器架构的用意，那说明已经大致掌握了类加载器“主流”的使用方式，那么作者不妨再提一个问题让读者思考一下：前面曾经提到过一个场景，如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring放到Common或Shared目录下让这些程序共享。Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中的，那么被CommonClassLoader或SharedClassLoader加载的Spring如何访问并不在其加载范围内的用户程序呢？如果读过本书第7章的相关内容，相信读者可以很容易地回答这个问题。</p><h3 id="2-2-OSGi：灵活的类加载器架构"><a href="#2-2-OSGi：灵活的类加载器架构" class="headerlink" title="2.2 OSGi：灵活的类加载器架构"></a><strong>2.2 OSGi：灵活的类加载器架构</strong></h3><p>&emsp;&emsp;Java程序社区中流传着这么一个观点：“学习JEE规范，去看JBoss源码;学习类加载器，就去看OSGi源码”。尽管“JEE规范”和“类加载器的知识”并不是一个对等的概念，不过，既然这个观点能在程序员中流传开来，也从侧面说明了OSGi对类加载器的运用确实有其独到之处。</p><p>&emsp;&emsp;OSGi[1]（Open Service Gateway Initiative）是OSGi联盟（OSGi Alliance）制定的一个基于Java语言的动态模块化规范，这个规范最初由Sun、IBM、爱立信等公司联合发起，目的是使服务提供商通过住宅网关为各种家用智能设备提供各种服务，后来这个规范在Java的其他技术领域也有相当不错的发展，现在已经成为Java世界中“事实上”的模块化标准，并且已经有了Equinox、Felix等成熟的实现。OSGi在Java程序员中最著名的应用案例就是Eclipse IDE，另外还有许多大型的软件平台和中间件服务器都基于或声明将会基于OSGi规范来实现，如IBM Jazz平台、GlassFish服务器、jBoss OSGi等。</p><p>&emsp;&emsp;OSGi中的每个模块（称为Bundle）与普通的Java类库区别并不太大，两者一般都以JAR格式进行封装，并且内部存储的都是Java Package和Class。但是一个Bundle可以声明它所依赖的Java Package（通过Import-Package描述），也可以声明它允许导出发布的Java Package（通过Export-Package描述）。在OSGi里面，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖（至少外观上如此），而且类库的可见性能得到非常精确的控制，一个模块里只有被Export过的Package才可能由外界访问，其他的Package和Class将会隐藏起来。除了更精确的模块划分和可见性控制外，引入OSGi的另外一个重要理由是，基于OSGi的程序很可能（只是很可能，并不是一定会）可以实现模块级的热插拔功能，当程序升级更新或调试除错时，可以只停用、重新安装然后启用程序的其中一部分，这对企业级程序开发来说是一个非常有诱惑力的特性。</p><p>&emsp;&emsp;OSGi之所以能有上述“诱人”的特点，要归功于它灵活的类加载器架构。OSGi的Bundle类加载器之间只有规则，没有固定的委派关系。例如，某个Bundle声明了一个它依赖的Package，如果有其他Bundle声明发布了这个Package，那么所有对这个Package的类加载动作都会委派给发布它的Bundle类加载器去完成。不涉及某个具体的Package时，各个Bundle加载器都是平级关系，只有具体使用某个Package和Class的时候，才会根据Package导入导出定义来构造Bundle间的委派和依赖。</p><p>&emsp;&emsp;另外，一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控制访问范围。如果一个类存在于Bundle的类库中但是没有被Export，那么这个Bundle的类加载器能找到这个类，但不会提供给其他Bundle使用，而且OSGi平台也不会把其他Bundle的类加载请求分配给这个Bundle来处理。</p><p>&emsp;&emsp;我们可以举一个更具体一些的简单例子，假设存在Bundle A、Bundle B、Bundle C三个模块，并且这三个Bundle定义的依赖关系如下。</p><blockquote><ul><li>Bundle A：声明发布了packageA，依赖了java.*的包。</li><li>Bundle B：声明依赖了packageA和packageC，同时也依赖了java.*的包。</li><li>Bundle C：声明发布了packageC，依赖了packageA。</li></ul></blockquote><p>&emsp;&emsp;那么，这三个Bundle之间的类加载器及父类加载器之间的关系如图9-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010204.png" alt="OSGi的类加载器架构"></p><p>&emsp;&emsp;由于没有牵扯到具体的OSGi实现，所以图9-2中的类加载器都没有指明具体的加载器实现，只是一个体现了加载器之间关系的概念模型，并且只是体现了OSGi中最简单的加载器委派关系。一般来说，在OSGi中，加载一个类可能发生的查找行为和委派关系会比图9-2中显示的复杂得多，类加载时可能进行的查找规则如下：</p><blockquote><ul><li>以java.*开头的类，委派给父类加载器加载。 </li><li>否则，委派列表名单内的类，委派给父类加载器加载。</li><li>否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li><li>否则，查找当前Bundle的Classpath，使用自己的类加载器加载。</li><li>否则，查找是否在自己的Fragment Bundle中，如果是，则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li><li>否则，类查找失败。</li></ul></blockquote><p>&emsp;&emsp;从图9-2中还可以看出，在OSGi里面，加载器之间的关系不再是双亲委派模型的树形结构，而是已经进一步发展成了一种更为复杂的、运行时才能确定的网状结构。这种网状的类加载器架构在带来更好的灵活性的同时，也可能会产生许多新的隐患。作者曾经参与过将一个非OSGi的大型系统向Equinox OSGi平台迁移的项目，由于历史原因，代码模块之间的依赖关系错综复杂，勉强分离出各个模块的Bundle后，发现在高并发环境下经常出现死锁。我们 很容易就找到了死锁的原因：如果出现了Bundle A依赖Bundle B的Package B，而Bundle B又依赖了Bundle A的Package A，这两个Bundle进行类加载时就很容易发生死锁。具体情况是当Bundle A加载Package B的类时，首先需要锁定当前类加载器的实例对象 （java.lang.ClassLoader.loadClass()是一个synchronized方法），然后把请求委派给Bundle B的加载器处理，但如果这时候Bundle B也正好想加载Package A的类，它也先锁定自己的加载器再去请求Bundle A的加载器处理，这样，两个加载器都在等待对方处理自己的请求，而对方处理完之前自己又一直处于同步锁定的状态，因此它们就互相死锁，永远无法完成加载请求了。Equinox的Bug List中有关于这类问题的Bug[2]，也提供了一个以牺牲性能为代价的解决方案——用户可以启用osgi.classloader.singleThreadLoads参数来按单线程串行化的方式强制进行类加载动作。在JDK 1.7中，为非树状继承关系下的类加载器架构进行了一次专门的升级[3]，目的是从底层避免这类死锁出现的可能。</p><p>&emsp;&emsp;总体来说，OSGi描绘了一个很美好的模块化开发的目标，而且定义了实现这个目标所需要的各种服务，同时也有成熟框架对其提供实现支持。对于单个虚拟机下的应用，从开发初期就建立在OSGi上是一个很不错的选择，这样便于约束依赖。但并非所有的应用都适合采用OSGi作为基础架构，OSGi在提供强大功能的同时，也引入了额外的复杂度，带来了线程死锁和内存泄漏的风险。</p><h3 id="2-3-字节码生成技术与动态代理的实现"><a href="#2-3-字节码生成技术与动态代理的实现" class="headerlink" title="2.3 字节码生成技术与动态代理的实现"></a><strong>2.3 字节码生成技术与动态代理的实现</strong></h3><p>&emsp;&emsp;“字节码生成”并不是什么高深的技术，读者在看到“字节码生成”这个标题时也先不必去想诸如Javassist、CGLib、ASM之类的字节码类库，因为JDK里面的javac命令就是字节码生成技术的“老祖宗”，并且javac也是一个由Java语言写成的程序，它的代码存放在OpenJDK的langtools/src/share/classes/com/sun/tools/javac目录中[1]。要深入了解字节码生成，阅读javac的源码是个很好的途径，不过javac对于我们这个例子来说太过庞大了。在Java里面除了javac和字节码类库外，使用字节码生成的例子还有很多，如Web服务器中的JSP编译器，编译时植入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度。我们选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的。</p><p>&emsp;&emsp;相信许多Java开发人员都使用过动态代理，即使没有直接使用过java.lang.reflect.Proxy或实现过java.lang.reflect.InvocationHandler接口，应该也用过Spring来做过Bean的组织管理。如果使用过Spring，那大多数情况都会用过动态代理，因为如果Bean是面向接口编程，那么在Spring内部都是通过动态代理的方式来对Bean进行增强的。动态代理中所谓的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的，它的优势不在于省去了编写代理类那一点工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。</p><p>&emsp;&emsp;代码清单9-1演示了一个最简单的动态代理的用法，原始的逻辑是打印一句“helloworld”，代理类的逻辑是在原始类方法执行前打印一句“welcome”。我们先看一下代码，然后再分析JDK是如何做到的。</p><p>&emsp;&emsp;代码清单9-1　动态代理的简单示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span></span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span></span>&#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123; </span><br><span class="line">            System.out.println(<span class="string">"hello world"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123; </span><br><span class="line">        Object originalObj; </span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span></span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj; </span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[]args)</span><span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">            System.out.println(<span class="string">"welcome"</span>); </span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj,args); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello()); </span><br><span class="line">        hello.sayHello(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">welcome</span> </span><br><span class="line"><span class="attribute">hello world</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码里，唯一的“黑匣子”就是Proxy.newProxyInstance()方法，除此之外再没有任何特殊之处。这个方法返回一个实现了IHello的接口，并且代理了new Hello()实例行为的对象。跟踪这个方法的源码，可以看到程序进行了验证、优化、缓存、同步、生成字节码、显式类加载等操作，前面的步骤并不是我们关注的重点，而最后它调用了sun.misc.ProxyGenerator.generateProxyClass()方法来完成生成字节码的动作，这个方法可以在运行时产生一个描述代理类的字节码byte[]数组。如果想看一看这个在运行时产生的代理类中写了些什么，可以在main()方法中加入下面这句：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">System</span><span class="selector-class">.getProperties</span>()<span class="selector-class">.put</span>("<span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.ProxyGenerator</span><span class="selector-class">.saveGeneratedFiles</span>", "<span class="selector-tag">true</span>");</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加入这句代码后再次运行程序，磁盘中将会产生一个名为“$Proxy0.class”的代理类Class文件，反编译后可以看见如代码清单9-2所示的内容。</p><p>&emsp;&emsp;代码清单9-2　反编译的动态代理类的代码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.bytecode; </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler; </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method; </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy; </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> $Proxy0 <span class="keyword">extends</span> Proxy <span class="keyword">implements</span> DynamicProxyTest.IHello &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler) <span class="keyword">throws</span> &#123; </span><br><span class="line">        <span class="keyword">super</span>(paramInvocationHandler); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> sayHello() <span class="keyword">throws</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>,m3, <span class="keyword">null</span>); </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; <span class="keyword">catch</span>(RuntimeException localRuntimeException) &#123; </span><br><span class="line">            <span class="keyword">throw</span> localRuntimeException; </span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable localThrowable) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处由于版面原因, 省略equals()、hashCode()、toString()三个方法的代码 </span></span><br><span class="line">    <span class="comment">//这3个方法的内容与sayHello()非常相似。 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            m3=<span class="keyword">Class</span>.forName(<span class="string">"org.fenixsoft.bytecode.DynamicProxyTest $IHello"</span>).getMethod(<span class="string">"sayHello"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]); </span><br><span class="line">            m1=<span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[]&#123;</span><br><span class="line">                <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>)&#125;); </span><br><span class="line">                m0 = <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]); </span><br><span class="line">                m2 = <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]); </span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125; <span class="keyword">catch</span>(NoSuchMethodException localNoSuchMethodException) &#123; </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage()); </span><br><span class="line">            &#125; <span class="keyword">catch</span>(ClassNotFoundException localClassNotFoundException) &#123; </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage()); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个代理类的实现代码也很简单，它为传入接口中的每一个方法，以及从java.lang.Object中继承来的equals()、hashCode()、toString()方法都生成了对应的实现，并且统一调用了InvocationHandler对象的invoke()方法（代码中的“this.h”就是父类Proxy中保存的InvocationHandler实例变量）来实现这些方法的内容，各个方法的区别不过是传入的参数和Method对象有所不同而已，所以无论调用动态代理的哪一个方法，实际上都是在执行InvocationHandler.invoke()中的代理逻辑。</p><p>&emsp;&emsp;这个例子中并没有讲到generateProxyClass()方法具体是如何产生代理类“$Proxy0.class”的字节码的，大致的生成过程其实就是根据Class文件的格式规范去拼装字节码，但在实际开发中，以byte为单位直接拼装出字节码的应用场合很少见，这种生成方式也只能产生一些高度模板化的代码。对于用户的程序代码来说，如果有要大量操作字节码的需求，还是使用封装好的字节码类库比较合适。如果读者对动态代理的字节码拼装过程很感兴趣，可以在OpenJDK的jdk/src/share/classes/sun/misc目录下找到sun.misc.ProxyGenerator的源码。</p><h3 id="2-4-Retrotranslator：跨越JDK版本"><a href="#2-4-Retrotranslator：跨越JDK版本" class="headerlink" title="2.4 Retrotranslator：跨越JDK版本"></a><strong>2.4 Retrotranslator：跨越JDK版本</strong></h3><p>&emsp;&emsp;一般来说，以“做项目”为主的软件公司比较容易更新技术，在下一个项目中换一个技术框架、升级到最新的JDK版本，甚至把Java换成C#、C++来开发程序都是有可能的。但当公司发展壮大，技术有所积累，逐渐成为以“做产品”为主的软件公司后，自主选择技术的权利就会丧失掉，因为之前所积累的代码和技术都是用真金白银换来的，一个稳健的团队也不会随意地改变底层的技术。然而在飞速发展的程序设计领域，新技术总是日新月异、层出不穷，偏偏这些新技术又如鲜花之于蜜蜂一样，对程序员散发着天然的吸引力。</p><p>&emsp;&emsp;在Java世界里，每一次JDK大版本的发布，都伴随着一场大规模的技术革新，而对Java程序编写习惯改变最大的，无疑是JDK 1.5的发布。自动装箱、泛型、动态注解、枚举、变长参数、遍历循环（foreach循环）……事实上，在没有这些语法特性的年代，Java程序也照样能写，但是现在看来，上述每一种语法的改进几乎都是“必不可少”的。就如同习惯了24寸液晶显示器的程序员，很难习惯在15寸纯平显示器上编写代码。但假如“不幸”因为要保护现有投资、维持程序结构稳定等，必须使用1.5以前版本的JDK呢？我们没有办法把15寸显示器变成24寸的，但却可以跨越JDK版本之间的沟壑，把JDK 1.5中编写的代码放到JDK 1.4或1.3的环境中去部署使用。为了解决这个问题，一种名为“Java逆向移植”的工具（Java Backporting Tools）应运而生，Retrotranslator[1]是这类工具中较出色的一个。</p><p>&emsp;&emsp;Retrotranslator的作用是将JDK 1.5编译出来的Class文件转变为可以在JDK 1.4或1.3上部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK 1.5中新增的集合改进、并发包以及对泛型、注解等的反射操作。了解了Retrotranslator这种逆向移植工具可以做什么以后，现在关心的是它是怎样做到的？</p><p>&emsp;&emsp;要想知道Retrotranslator如何在旧版本JDK中模拟新版本JDK的功能，首先要弄清楚JDK升级中会提供哪些新的功能。JDK每次升级新增的功能大致可以分为以下4类：</p><blockquote><ul><li>在编译器层面做的改进。如自动装箱拆箱，实际上就是编译器在程序中使用到包装对象的地方自动插入了很多Integer.valueOf()、Float.valueOf()之类的代码;变长参数在编译之后就自动转化成了一个数组来完成参数传递;泛型的信息则在编译阶段就已经擦除掉了（但是在元数据中还保留着），相应的地方被编译器自动插入了类型转换代码[2]。</li><li>对Java API的代码增强。譬如JDK 1.2时代引入的java.util.Collections等一系列集合类，在JDK 1.5时代引入的java.util.concurrent并发包等。 </li><li>需要在字节码中进行支持的改动。如JDK 1.7里面新加入的语法特性：动态语言支持，就需要在虚拟机中新增一条invokedynamic字节码指令来实现相关的调用功能。不过字节码指令集一直处于相对比较稳定的状态，这种需要在字节码层面直接进行的改动是比较少见的。</li><li>虚拟机内部的改进。如JDK 1.5中实现的JSR-133[3]规范重新定义的Java内存模型（Java Memory Model,JMM）、CMS收集器之类的改动，这类改动对于程序员编写代码基本是透明的，但会对程序运行时产生影响。</li></ul></blockquote><p>&emsp;&emsp;上述4类新功能中，Retrotranslator只能模拟前两类，对于后面两类直接在虚拟机内部实现的改进，一般所有的逆向移植工具都是无能为力的，至少不能完整地或者在可接受的效率上完成全部模拟，否则虚拟机设计团队也没有必要舍近求远地改动处于JDK底层的虚拟机。在可以模拟的两类功能中，第二类模拟相对更容易实现一些，如JDK 1.5引入的java.util.concurrent包，实际是由多线程大师Doug Lea开发的一套并发包，在JDK 1.5出现之前就已经存在（那时候名字叫做dl.util.concurrent，引入JDK时由作者和JDK开发团队共同做了一些改进），所以要在旧的JDK中支持这部分功能，以独立类库的方式便可实现。Retrotranslator中附带了一个名叫“backport-util-concurrent.jar”的类库（由另一个名为“Backport ot JSR 166”的项目所提供）来代替JDK 1.5的并发包。</p><p>&emsp;&emsp;至于JDK在编译阶段进行处理的那些改进，Retrotranslator则是使用ASM框架直接对字节码进行处理。由于组成Class文件的字节码指令数量并没有改变，所以无论是JDK 1.3、JDK 1.4还是JDK 1.5，能用字节码表达的语义范围应该是一致的。当然，肯定不可能简单地把Class的文件版本号从49.0改回48.0就能解决问题了，虽然字节码指令的数量没有变化，但是元数据信息和一些语法支持的内容还是要做相应的修改。以枚举为例，在JDK 1.5中增加了enum关键字，但是Class文件常量池的CONSTANT_Class_info类型常量并没有发生任何语义变化，仍然是代表一个类或接口的符号引用，没有加入枚举，也没有增加过“CONSTANT_Enum_info”之类的“枚举符号引用”常量。所以使用enum关键字定义常量，虽然从Java语法上看起来与使用class关键字定义类、使用interface关键字定义接口是同一层次的，但实际上这是由Javac编译器做出来的假象，从字节码的角度来看，枚举仅仅是一个继承于java.lang.Enum、自动生成了values()和valueOf()方法的普通Java类而已。</p><p>&emsp;&emsp;Retrotranslator对枚举所做的主要处理就是把枚举类的父类从“java.lang.Enum”替换为它运行时类库中包含的“net.sf.retrotranslator.runtime.java.lang.Enum_”，然后再在类和字段的访问标志中抹去ACC_ENUM标志位。当然，这只是处理的总体思路，具体的实现要比上面说的复杂得多。可以想象既然两个父类实现都不一样，values()和valueOf()的方法自然需要重写，常量池需要引入大量新的来自父类的符号引用，这些都是实现细节。图9-3是一个使用JDK 1.5编译的枚举类与被Retrotranslator转换处理后的字节码的对比图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010205.png" alt="Retrotranslator处理前后的枚举类字节码对比"></p><hr><h2 id="第三节-实战：自己动手实现远程执行功能"><a href="#第三节-实战：自己动手实现远程执行功能" class="headerlink" title="第三节 实战：自己动手实现远程执行功能"></a><strong>第三节 实战：自己动手实现远程执行功能</strong></h2><p>&emsp;&emsp;<a href="../2019121901.html" title="Title">类加载集执行子系统的案例与实战-实战</a></p><hr><h2 id="第四节-总结"><a href="#第四节-总结" class="headerlink" title="第四节 总结"></a><strong>第四节 总结</strong></h2><p>&emsp;&emsp;本书第6～9章介绍了Class文件格式、类加载及虚拟机执行引擎几部分内容，这些内容是虚拟机中必不可少的组成部分，只有了解了虚拟机如何执行程序，才能更好地理解怎样写出优秀的代码。</p><p>&emsp;&emsp;关于虚拟机执行子系统的介绍到此就结束了，通过这4章的讲解，我们描绘了一个虚拟机应该怎样运行Class文件的概念模型。对于具体到某个虚拟机的实现，为了使实现简单、清晰，或者为了更快的运行速度，在虚拟机内部的运作跟概念模型可能会有非常大的差异，但从最终的执行结果来看应该是一致的。从第10章开始，我们将探索虚拟机在语法和运行性能上是如何对程序编写做出各种优化的。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的类加载集执行子系统的案例与实战，包括：概述，案例分析（Tomcat：正统的类加载器架构、OSGi：灵活的类加载器架构、字节码生成技术与动态代理的实现、Retrotranslator：跨越JDK版本），实战：自己动手实现远程执行功能，总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>应用程序服务器和Web容器</title>
    <link href="http://linyishui.top/2019121701.html"/>
    <id>http://linyishui.top/2019121701.html</id>
    <published>2019-12-17T08:27:07.000Z</published>
    <updated>2020-01-10T09:31:42.509Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用程序服务器和Web容器"><a href="#应用程序服务器和Web容器" class="headerlink" title="应用程序服务器和Web容器"></a><strong>应用程序服务器和Web容器</strong></h1><h2 id="第一节-选择Web容器"><a href="#第一节-选择Web容器" class="headerlink" title="第一节 选择Web容器"></a><strong>第一节 选择Web容器</strong></h2><p>&emsp;&emsp;Java EE Web应用程序运行在Java EE应用服务器和Web容器(也称为Servlet容器)中。 尽管Java EE规范由许多更小的子规范组成，但大多数Web容器都只实现了Servlet、JSP和JSTL规范。这不同于实现了完整Java EE规范的成熟Java EE应用服务器。每个应用服务器都包含了一个Web容器，用于管理Servlet的生命周期、将请求URL映射到对应的Servlet代码、接受和响应HTTP请求以及管理过滤器链(在适用的时候)。不过，独立运行的Web容器通常是轻量级的，并且易于使用(如果不需要使用Java EE的所有特性的话)。</p><p>&emsp;&emsp;选择Web容器(或应用服务器)要求对项目的需求进行认真的研究和考虑。在选择Web容器时有多种选项，每种容器都有自己的优点和不足。也可以同时使用多种不同的Web容器。例如，可以选择在个人计算机上使用Apache Tomcat用于本地测试，在生产环境中使用GlassFish。</p><h3 id="1-1-Apache-Tomcat"><a href="#1-1-Apache-Tomcat" class="headerlink" title="1.1 Apache Tomcat"></a><strong>1.1 Apache Tomcat</strong></h3><p>&emsp;&emsp;Apache Tomcat是目前最常见和最流行的Web容器。Sun公司的软件工程师最初创建了该Web容器，称为Sun Java Web Server，它也是Java EE Servlet规范最初的参考实现。之后在1999年，Sun将它捐献给了Apache Software Foundation，就在此时它变成了Jakarta Tomcat，并最终变成了Apache Tomcat。另外很有意思的是Apache对Tomcat的改进引起了Apache Ant构建工具的发展，该构建工具在今天已经被数以千计的商业和开源项目所使用。 </p><p>&emsp;&emsp;Tomcat的主要优点是占用内存小、配置简单以及长期的社区参与。通常，开发者可以在5到10分钟内安装并运行Tomcat安装包成功，包括下载时间。Tomcat 只需要很少的额外配置即可在开发计算机上成功运行，经过调优之后，也可以在高负载、高可用性的生产环境中使用。你可以创建出庞大的Tomcat群集，以可靠的方式处理大量通信。因为Tomcat简单并且使用的是轻量级架构，所以它经常被用于商业生产环境中。不过与许多竞争者相比，它在配置服务器时缺少复杂的Web管理界面。相反，Tomcat只提供了处理基本任务的简单界面，包括部署和卸载应用程序。对于更详细的配置，管理员必须操作一组XML和Java属性文件。另外，因为它不是一个完整的应用服务器，所以缺少了许多Java EE组件，例如Java Persistence API、Bean Validation API和Java Message Service。</p><p>&emsp;&emsp;可以想象的是，Tomcat可以完美地完成许多任务，但不能轻松地部署复杂的企业级应用程序，有时甚至是不可能的。如果你喜欢Tomcat但需要一个完整的Java EE应用服务器，那么可以考虑使用Apache TomEE，该服务器基于Tomcat构建，但提供了对于Java EE组件的完整实现。由于它是基于Tomcat构建的，因此它有着Tomcat社区的完全支持，以及超过10年的测试。Apache还提供了另一个开源的完整Java EE应用服务器：Geronimo。</p><p>&emsp;&emsp;Tomcat提供了Servlet、Java Server Pages(JSP)、Java Unified Expression Language(EL)和WebSocket规范。表2-1列出了几个Tomcat版本和它们所实现的规范。目前只有Tomcat 6、7、8仍然能得到支持。版本3.3、4.1和5.5已经在多年前停止了开发。在<a href="http://tomcat.apache.org/" title="Title" target="_blank" rel="noopener">Tomcat网站</a>上可以获得更多关于Apache Tomcat的详细信息。 </p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010201.png" alt="Tomcat版本和它们的规范"></p><h3 id="1-2-GlassFish"><a href="#1-2-GlassFish" class="headerlink" title="1.2 GlassFish"></a><strong>1.2 GlassFish</strong></h3><p>&emsp;&emsp;GlassFish服务器是一个开源的、也是商业的完整Java EE应用服务器实现。它提供了Java EE规范的所有特性，包括Web容器，而且它目前还是Java EE规范的参考实现。它的Web容器实际源自于Apache Tomcat；不过自从使用Tomcat核心创建了GlassFish之后，它已经做出了重大的改变，初始的代码已经很难识别出来了。</p><p>&emsp;&emsp;GlassFish的开源版本由社区提供支持，而Oracle的商业GlassFish服务器版本由Oracle公司提供收费的商业支持。Oracle将只为Java EE 7之前的版本提供商业支持。从Java EE 8开始，GlassFish将不再包含商业支持选项。</p><p>&emsp;&emsp;GlassFish的一个优势是它的管理界面，可以通过图形Web用户界面、命令行界面和配置文件等方式对服务器进行设置。服务器管理员甚至可以使用管理界面在GlassFish群集中部署新的GlassFish实例。作为参考实现，无论何时规范被更新，它都将是第一个实现新版本规范的服务器。GlassFish的第一个版本在2006年5月发布，它实现了Java EE 5规范。在2007年9月发布的版本2.0添加了对完整群集能力的支持。版本3.0作为Java EE 6的参考实现，在2009年12月发布——包含几个企业级特性的改进。该版本代表着GlassFish流行度的转折点，它变得非常易于管理企业级群集GlassFish环境。在2011年7月，版本3.1.1改进了几个企业级特性并添加了对Java SE 7的支持，尽管所需的最小版本仍然是Java SE 6。在2013年6月发布的GlassFish 4.0作为Java EE 7的参考实现，所需的最小版本是 Java SE 7。</p><h3 id="1-3-JBoss和WildFly"><a href="#1-3-JBoss和WildFly" class="headerlink" title="1.3 JBoss和WildFly"></a><strong>1.3 JBoss和WildFly</strong></h3><p>&emsp;&emsp;截至2013年初，Red Hat的JavaBeans Open Source Software Application Server (JBoss AS)是仅次于Tomcat、第二流行的Java EE服务器。从历史上看，JBoss AS已经是一个支持Enterprise JavaBeans(EJB)和一些Java EE特性的Web容器。最终它通过了Web Profile的认证，并在2012年通过了完整Java EE应用服务器的认证。随着时间的流逝，JBoss变成了提供几种产品的开发社区(例如Apache)和商业JBoss企业级应用平台的代名词。该应用服务器一直使用JBoss AS作为名字直到版本7.1.x，到了2012年，社区觉得由于其他JBoss项目的存在，该名字会引起许多混乱，因此在2014年初发布的应用服务器被重命名为WildFly。</p><p>&emsp;&emsp;类似于GlassFish，WildFly由JBoss社区提供免费支持，由Red Hat提供收费的商业支持。它有一套完整的管理工具，并如同Tomcat和GlassFish一样提供了群集和高可用性。JBoss AS从版本4.0.x到4.2.x都是基于Tomcat 5.5构建的，并且支持Java EE 1.4的特性。版本5.0引入了对Java EE 5的支持以及一个全新的Web容器，而版本5.1则包含了一些Java EE 6特性的早期实现(尽管它仍然是 Java EE 5应用服务器)。JBoss AS 6.0实现了Java EE Web Profile，但它并未追求通过Java EE 6应用服务器的认证。JBoss AS 7.0代表着对产品完整的重写，极大地减少了内存占用并提高了性能，另外它只支持Java EE 6 Web Profile。直到JBoss AS 7.1，它才再次成为完整的应用服务器，在Java EE 6发布两年之后通过了Java EE 6认证。WildFly 8.0是一个完整的Java EE 7应用服务器，它要求使用的Java SE最小版本为Java SE 7(实际上，所有Java EE 7应用服务器和Web容器都要求Java SE的最小版本为 Java SE 7)。</p><h3 id="1-4-其他容器和应用服务器"><a href="#1-4-其他容器和应用服务器" class="headerlink" title="1.4 其他容器和应用服务器"></a><strong>1.4 其他容器和应用服务器</strong></h3><p>&emsp;&emsp;现在有多种Web容器(例如Jetty和Tiny)和开源的完整Java EE应用服务器(例如JOnAS、Resin、 Caucho和Enhydra)可供选择。另外还有大量的商业完整应用服务器，其中Oracle WebLogic和IBM WebSphere是最流行的。表2-2显示出了其中的一些服务器和它们不同版本所支持的Java EE规范。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010202.png" alt="容器和应用服务器版本"></p><p>&emsp;&emsp;每种Web容器或应用服务器都有自己的优点和不足，你必须理解自己的组织项目的需求，然后选择符合需求的正确Web容器或应用服务器。因为商业应用服务器的许可通常价格很高，所以必须考虑运营预算。所有的这些因素都将影响你的决定。</p><hr><h2 id="第二节-应用服务器的使用"><a href="#第二节-应用服务器的使用" class="headerlink" title="第二节 应用服务器的使用"></a><strong>第二节 应用服务器的使用</strong></h2><p>&emsp;&emsp;Tomcat等应用服务器的安装、配置和使用在互联网上有很多文档资料，此处无需再复制粘贴。</p><p>&emsp;&emsp;配合IDE工具，通过DEMO项目了解应用服务器的功能。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《JavaWeb高级编程——涵盖WebSockets、Spring Framework、JPA Hibernate和Spring Security》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      应用程序服务器和Web容器，内容包括：选择Web容器（Apache Tomcat、GlassFish、JBoss和WildFly、其他容器和应用服务器），应用服务器的使用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="java web" scheme="http://linyishui.top/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>Java EE简介</title>
    <link href="http://linyishui.top/2019121501.html"/>
    <id>http://linyishui.top/2019121501.html</id>
    <published>2019-12-15T03:10:15.000Z</published>
    <updated>2020-01-10T09:07:56.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java-EE简介"><a href="#Java-EE简介" class="headerlink" title="Java EE简介"></a><strong>Java EE简介</strong></h1><h2 id="第一节-背景"><a href="#第一节-背景" class="headerlink" title="第一节 背景"></a><strong>第一节 背景</strong></h2><p>&emsp;&emsp;从1997年的1.1版本开始，Java平台被称为JDK，但到了版本1.2，很明显JDK和平台不再是同一样技术。从1998 年底的1.2版本开始，Java技术栈被分割为以下关键部分：</p><blockquote><ul><li>Java是一门包含了严格和强类型语法的语言，你现在已经熟悉它了。 </li><li>Java2平台标准版本，也被称为<strong>J2SE</strong>，指的是平台以及java.lang和java.io包中包含的类。它是构建Java应用程序的基础。</li><li>Java虚拟机或JVM是一个可以运行编译后Java代码的软件虚拟机。因为被编译过的Java代码只是字节码，JVM将在运行代码之前，把字节码编译成机器码(通常被称作即时编译器或JIT编译器)。JVM还负责管理内存，从而实现了应用程序代码的简化。</li><li>Java开发工具包或JDK曾经并且现在也仍然是Java开发者创建应用程序所需的软件。它包含了Java语言编译器、文档生成器、与本地代码协作的工具和用于调试平台类的Java源代码。 </li><li>Java运行时环境或JRE曾经并且现在也仍然是终端用户用于运行编译后Java应用程序的软件。它包含了JVM但不含任何JDK中的开发工具。不过JDK中确实也包含了一个JRE。 </li></ul></blockquote><p>&emsp;&emsp;这5个组件曾经都只是规范，而不是实现，任何公司都可以创建自己的Java技术栈实现。尽管Sun提供了Java、J2SE、JVM、JDK和JRE的标准实现，但IBM、Oracle和Apple仍然创建了包含不同特性的实现。随着多年的发展，许多语言都可以被编译为Java字节码(在某些情况下可以被编译为机器码)，并运行在JVM上。其中最引人注目的有Clojure(Lisp方言)、Groovy、JRuby(基于Java的Ruby实现)、Jython(基于Java的Python实现)、Rhino和Scala。</p><p>&emsp;&emsp;随着Internet的发展和Web应用程序的流行，Sun公司已经意识到应用程序开发对高级开发工具的需求。1998年，就在J2SE 1.2发布之前，Sun宣布它正在开发一个称为Java专业版本或JPE的产品。同时它还研发了一门称为Servlet的技术，这是一个能够处理HTTP请求的小型应用程序。在1997年，Java Servlets 1.0与Java Web Server一起发布，因为该服务器缺少许多Java社区需要的特性，所以它并未流行起来。 </p><p>&emsp;&emsp;Servlet和JPE在经历过几次内部迭代过程之后，Sun于1999年12月12日发布了Java 2平台的企业版(或<strong>J2EE</strong>)，版本为1.2。版本号对应着当时的Java和J2SE版本，该规范包括： </p><blockquote><ul><li>Servlets 2.2 </li><li>JDBC Extension API 2.0 </li><li>Java Naming and Directory Interface (JNDI) 1.0 </li><li>JavaServer Pages (JSP) 1.2 </li><li>Enterprise JavaBeans (EJB) 1.1 </li><li>Java Message Service (JMS) 1.0 </li><li>Java Transaction API (JTA) 1.0 </li><li>JavaMail API 1.1 </li><li>JavaBeans Activation Framework (JAF) 1.0. </li></ul></blockquote><p>&emsp;&emsp;J2EE 1.3在2001年9月发布，Java和J2SE 1.3的发布稍晚一点，但在Java/J2SE 1.4发布之前。它的大多数组件都进行了小的升级，并且也添加了一些新的特性。下面的技术也加入了J2EE规范，并且它们的实现也得到了扩展和升级： </p><blockquote><ul><li>Java API for XML Processing (JAXP) 1.1 </li><li>JavaServer Pages Standard Tag Library (JSTL) 1.0 </li><li>J2EE Connector Architecture 1.0 </li><li>Java Authentication and Authorization Service (JAAS) 1.0 </li></ul></blockquote><p>&emsp;&emsp;J2EE 1.4代表着Java平台企业版的一次极大飞跃。在2003年11月发布时(大约在Java/J2SE 5.0 发布一年之前，Java/J2SE 1.4发布两年之后)，它包含了Servlets 2.4和JSP 2.0。在该版本中，JDBC Extension API、JNDI和JAAS规范被移除了，因为它们被认为是Java的必需部分，被移入Java/J2SE 1.4。该版本还代表着J2EE组件被分割成了几个更高级别的分类： </p><blockquote><ul><li>Web服务技术：包括JAXP 1.2和J2EE 1.1中的新Web服务、Java API for XML-based RPC (JAX-RPC) 1.1、Java API for XML Registries (JAXR) 1.0 </li><li>Web应用程序技术: 包括Servlet、JSP和JSTL 1.1组件，还有新的Java Server Faces (JSF) 1.1 </li><li>企业级应用程序技术：包括EJB 2.1、Connector Architecture 1.5、JMS 1.1、JTA、JavaMail 1.3和JAF </li><li>管理和安全技术：包括Java Authorization Service Provider Contract for Containers (JACC) 1.0、Java Management Extensions (JMX) 1.2、Enterprise Edition Management API 1.0和Enterprise Edition Deployment API 1.1 </li></ul></blockquote><p>&emsp;&emsp;2004年，Sun公司决定使用Java平台标准版取代Java 2平台标准版，使用全新的缩写名字Java SE。2006年发布的Java SE 6开始正式使用该名称，直到今天名字和版本的命名方式都未再改变。Java SE 6实际对应着1.6，Java SE 7实际对应着1.7，Java SE 8实际对应着1.8。J2EE也采用了新的命名和版本约定，现在使用的名字为Java SE。</p><p>&emsp;&emsp;2006年5月发布的Java EE 5再次发生了变化，它包含了众多修改和改进，直到今天它仍然是应用程序最广泛的一 个Java EE版本。它包括以下修改和补充： </p><blockquote><ul><li>JAXP和JMX被移到了J2SE 5.0 中，不再包含在Java EE 5中。 </li><li>Java API for XML-based Web Services (JAX-WS) 2.0、 Java Architecture for XML Binding (JAXB) 2.0、Web Service Metadata for the Java Platform 2.0、SOAP with Attachments API for Java (SAAJ) 1.2以及Streaming API for XML (StAX) 1.0被添加到了Web服务技术中。 </li><li>Java Persistence API (JPA) 1.0和Common Annotations API 1.0被添加到了企业级应用程序技术中。</li></ul></blockquote><p>&emsp;&emsp;2006年12月Java SE 6的发布标志着Java SE持续了大概5年的发展停滞期。在这段时期内，许多Java社区都感到沮丧甚至是生气。Sun公司继续承诺在Java SE 7中添加新的语言特性和API，但计划推迟了一年又一年。与此同时其他技术，例如C#语言和.NET平台，赶上并超越了Java语言的特性和平台API，许多人都猜测Java是否已经到了生命的终结。更糟的是，Java EE也进入了发展停滞期直到2009年，距离Java EE 5发布已经过去了三年多的时间。不过，这并不是终结。Java EE 6的开发在2009年初重新开始，并在2009年12月发布，距离Java EE 5的发布已经过去了3年零7个月，距离Java SE 6的发布几乎接近3年。 </p><p>&emsp;&emsp;此时，Java企业版已经变得极其庞大： </p><blockquote><ul><li>SAAJ、StAX和JAF被移到了Java SE 6中。 </li><li>Java API for RESTful Web Services (JAX-RS) 1.1和Java APIs for XML Messaging (JAXM) 1.3规范被添加到 Web服务技术中。 </li><li>Java Unified Expression Language (JUEL或称为EL) 2.0被添加到Web应用程序技术中。 </li><li>Management and Security Technologies中添加了Java Authentication Service Provider Interface for Containers (JASPIC) 1.0。 </li><li>企业级应用程序技术增加了大量的新特性，包括Contexts and Dependency Injection for Java (CDI) 1.0、Dependency Injection for Java 1.0、Bean Validation 1.0、Managed Beans 1.0和 Interceptors 1.1，还对它所有其他的组件做了更新。  </li></ul></blockquote><p>&emsp;&emsp;Java EE 6 还代表着 Java EE架构在两个技术上的重大转折点： </p><blockquote><ul><li>该版本引入了基于注解的配置和编程式应用程序配置，是对已经使用超过10年的传统XML配置的补充。 </li><li>该版本标志着Java EE Web Profile的引入。 </li></ul></blockquote><p>&emsp;&emsp;由于Java EE已经变得如此庞大(维护和更新公认的实现变得相当困难)，Web Profile验证程序为认证只包含完整Java EE平台一个子集的Java EE实现提供了机会。该子集包含了对于大量应用程序都十分关键的特性，排除了一些只被少数应用程序使用的规范。对于Java EE 6来说： </p><blockquote><ul><li>所有的Web服务或者管理和安全组件都不是Java EE Web Profile的一部分。 </li><li>该Web Profile包含了Web应用程序技术和企业级应用程序技术的所有内容，除了Java EE Connector Architecture、JMS和JavaMail。 </li></ul></blockquote><p>&emsp;&emsp;就在这5年的发展停滞期中，Oracle公司于2010年1月收购了Sun公司。除了Java SE发展的停滞，该事件为Java社区带来了新的担忧。Oracle并不愿意或积极与开源项目合作，许多人担心购买了Sun的Oracle会关闭Java。不过，事实并不是这样的。在初期，Oracle开始重组Java团队，创建与开源社区的沟通渠道，并发布了未来Java SE和EE版本的规划蓝图，这比Sun的承诺要更加实际。首先完成的是Java SE 7，Oracle在2011年6月按时发布，距离Java SE 6的发布几乎已经过去了5年。第二个Java EE发展停滞期在2013年6月结束，此时发布了Java EE 7，距离Java EE 6的发布已经过去了3年零7个月。Oracle现在表示Java的发展已经步入正轨，以后每两年将会同时发布两个平台的新版本(轮流发布)，让我们拭目以待。 </p><h3 id="1-1-Java-SE-7的新特性"><a href="#1-1-Java-SE-7的新特性" class="headerlink" title="1.1 Java SE 7的新特性"></a><strong>1.1 Java SE 7的新特性</strong></h3><p>&emsp;&emsp;Java SE 7增加了对<strong>动态语言</strong>和<strong>64位压缩指针</strong>(用于改善64位JVM的性能)的支持。它还添加了几种新的语言特性，可以使开发Java应用程序更容易。可能<strong>菱形操作符</strong>(&lt;&gt;)就是其中最有用的改进之一——泛型实例化的简写。</p><p>&emsp;&emsp;在Java 7之前，泛型类型的变量声明和变量赋值都必须包含泛型参数。例如，下面是一个非常复杂的 java.util.Map变量的声明和赋值： </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Integer</span>, <span class="built_in">List</span>&lt;MyBean&gt;&gt;&gt;&gt; <span class="built_in">map</span> = newHashtable&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Integer</span>, <span class="built_in">List</span>&lt;MyBean&gt;&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，该声明语句中包含了大量的冗余信息。将任何不是Map&lt;String, Map&lt;String, Map&lt;Integer, List<mybean>&gt;&gt;&gt;类型的对象赋给该变量都是非法的，那么为什么还需要再次指定所有的类型参数呢？使用了Java 7菱形操作符之后，上述声明和赋值语句将变得非常简单。编译器将会为实例化生成的java.util.Hashtable推断出它的类型参数。</mybean></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Integer</span>, <span class="built_in">List</span>&lt;MyBean&gt;&gt;&gt;&gt; <span class="built_in">map</span> = <span class="literal">new</span> Hashtable&lt;&gt;();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Java 7之前Java中的另一个常见问题是：使用try-catch-finally块管理可关闭的资源。尤其是下面这样有点讨厌的JDBC代码： </p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = <span class="literal">null</span>; </span><br><span class="line">PreparedStatement statement = <span class="literal">null</span>; </span><br><span class="line">ResultSetresultSet = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    connection = dataSource.getConnection(); </span><br><span class="line">    statement = connection.prepareStatement(...); </span><br><span class="line">    //<span class="keyword">set</span> up statement </span><br><span class="line">    resultSet = statement.executeQuery(); </span><br><span class="line">    // do something <span class="keyword">with</span> result <span class="keyword">set</span>  </span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123; </span><br><span class="line">    // do something <span class="keyword">with</span> exception </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(resultSet != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            resultSet.close(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException ignore) &#123; </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(statement != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            statement.close(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException ignore) &#123; </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed()) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            connection.close(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException ignore) &#123; </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 7的try-with-resource极大地简化了这个任务。任何实现了java.lang.AutoCloseable的类都可用于try-with-resources结构中。JDBC Connection、PreparedStatement和ResultSet接口都继承了这个接口。下面的例子使用了try-with-resources结构，在try关键字后面的圆括号中声明的资源，将会在隐式的finally块中自动关闭。任何在这段清理过程中抛出的异常将被添加到现有异常的抑制异常中，或者如果之前未有任何异常发生，那么该异常将在所有的资源都关闭后抛出。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try</span>(Connection connection = dataSource.getConnection(); </span><br><span class="line">    PreparedStatement statement = connection.prepareStatement(...)) &#123; </span><br><span class="line">    //<span class="built_in">set</span> up statement </span><br><span class="line">    <span class="built_in">try</span>(ResultSetresultSet = statement.executeQuery()) &#123; </span><br><span class="line">        //<span class="built_in">do</span> something <span class="built_in">with</span> resul <span class="built_in">set</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125; catch(SQLException e) &#123; </span><br><span class="line">    //<span class="built_in">do</span> something <span class="built_in">with</span> exception </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于try-catch-finally的另一处改进是添加了multi-catch(捕捉多个异常)。在Java 7中可以在单个catch块中同时捕捉多个异常，使用单个竖线隔开异常类型即可。 </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(MyException | YourException e) &#123; </span><br><span class="line">    <span class="comment">//handle these exceptions the same way </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，不能同时捕捉多个相互之间有继承关系的异常。例如，下面的代码是不可行的，因为FileNotFoundException继承了IOException： </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException | FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">//handle these exceptions the same way </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，这可以被认为是一个常识性的问题。在这种情况下，只需要捕捉IOException即可，这样两种异常类型都可以被捕捉到。 </p><p>&emsp;&emsp;Java 7的一些其他语言特性包括字节码/整数的<strong>二进制字面量</strong>(可以将字面量1928写作0b11110001000)以及在<strong>数字字面量中使用下划线</strong>(如果愿意的话，可将相同的字面量1928写作1_928和ob111_1000_1000)。另外，终于可以<strong>将字符串用作switch的参数</strong>了。 </p><h3 id="1-3-Java-EE-7的新特性"><a href="#1-3-Java-EE-7的新特性" class="headerlink" title="1.3 Java EE 7的新特性"></a><strong>1.3 Java EE 7的新特性</strong></h3><p>&emsp;&emsp;Java EE 7在2013年6月12日发布，它包含许多变动和新特性。Java EE 7中的变动有： </p><blockquote><ul><li>JAXB被添加到了Java SE 7 中，并且不再包含在Java EE中。 </li><li>Batch Applications for the Java Platform 1.0和Concurrency Utilities for Java EE 1.0被添加到了企业级应用程序技术中。</li><li>Web应用程序技术中添加了Java API for WebSockets 1.0和Java API for JSON Processing 1.0。</li><li>Java Unified Expression Language得到了极大的扩展，其中包括lambda表达式和对Java SE 8 Collections Stream API的模拟。 </li><li>Web Profile得到了少许扩展，其中添加了在通用Web应用程序中使用较多的一些规范：JAX-RS、Java API for WebSockets和 Java API for JSON Processing。 </li></ul></blockquote><h3 id="1-2-Java-SE-8的新特性"><a href="#1-2-Java-SE-8的新特性" class="headerlink" title="1.2 Java SE 8的新特性"></a><strong>1.2 Java SE 8的新特性</strong></h3><p>&emsp;&emsp;<a href="../2019091901.html" title="Title">Java8的新特性</a></p><hr><h2 id="第二节-基本的Web应用程序结构"><a href="#第二节-基本的Web应用程序结构" class="headerlink" title="第二节 基本的Web应用程序结构"></a><strong>第二节 基本的Web应用程序结构</strong></h2><h3 id="2-1-Servlet、过滤器、监听器和JSP"><a href="#2-1-Servlet、过滤器、监听器和JSP" class="headerlink" title="2.1 Servlet、过滤器、监听器和JSP"></a><strong>2.1 Servlet、过滤器、监听器和JSP</strong></h3><p>&emsp;&emsp;Servlet是用于接受和响应HTTP请求的Java类。几乎发送到应用程序中的所有请求都将经过某种类型Servlet的处理，除了错误的或被其他组件拦截的请求。</p><p>&emsp;&emsp;过滤器就是这样一种组件，可以拦截发送给Servlet的请求。通过使用过滤器可以满足各种需求，包括数据格式化、对返回的数据进行压缩、认证和授权。</p><p>&emsp;&emsp;Java EE Web应用程序支持各种不同类型的监听器。这些监听器可以通知代码多种事件，例如应用程序启动、应用程序关闭、HTTP会话创建和会话销毁。</p><p>&emsp;&emsp;Java EE工具中最强大的一个就是JavaServer Pages技术或JSP。通过使用JSP可以为Web应用程序创建动态的、基于HTML的图形用户界面，不需要手动向OutputStream或PrintWriter中输入HTML的字符串。JSP技术包含了许多不同的内容，包括JavaServer Pages Standard Tag Library、Java Unified Expression Language、自定义标签、国际化和本地化。</p><blockquote><p>为什么不建议深入学习JSP？</p><ul><li>前后端职能分离，各司其职，界面不应再由后端工程师去协助实现</li><li>JSP作为一个后端渲染技术，会使动静资源耦合，无法做到有效的动静分离</li><li>JSP依赖于支持Java的Web服务器</li><li>JSP效率很低，在前端的发展潮流中已被淘汰</li></ul><p>&emsp;&emsp;虽然JSP已经不再流行，但其技术原理还是需要我们学习掌握的，当然其重要性就没那么高了，可以往自己的学习队列末尾移动。</p></blockquote><h3 id="2-2-目录结构和WAR文件"><a href="#2-2-目录结构和WAR文件" class="headerlink" title="2.2 目录结构和WAR文件"></a><strong>2.2 目录结构和WAR文件</strong></h3><p>&emsp;&emsp;标准Java EE Web应用程序将作为<strong>WAR文件</strong>或<strong>未归档的Web应用程序目录</strong>进行部署。JAR文件只是一个简单的ZIP格式归档文件，其中包含了可被JVM识别的标准目录结构。没有专门的JAR文件格式，任何ZIP归档应用程序都可以创建和读取JAR文件。Web应用程序归档或WAR是Java EE Web应用程序对应的归档文件。 </p><p>&emsp;&emsp;无论是归档文件还是未归档文件，它们的目录结构约定都是相同的。如同JAR文件一样，该结构包含了类和其他应用程序资源，但这些类并未像JAR文件一样存储在应用程序根目录的相对路径上。相反，<strong>类文件都存储在/WEB-INF/classes中</strong>。<strong>WEB-INF目录存储了一些包含了信息和指令的文件</strong>，Java EE Web应用程序服务器使用它们决定如何部署和运行应用程序。它的classes目录被用作包的根目录。所有编译后的应用程序类文件和其他资源都被存储在该目录中。 </p><p>&emsp;&emsp;不同于标准的JAR文件，<strong>WAR文件可以包含应用程序所依赖的JAR文件</strong>，它们被存储在/WEB-INF/lib中。JAR文件中所有在该目录中的类对于在应用程序类路径上的应用程序都是可用的。目录/WEB-INF/tags和/WEB-INF/tld分别用于存储 JSP标签文件和标签库描述符。</p><h3 id="2-3-部署描述符"><a href="#2-3-部署描述符" class="headerlink" title="2.3 部署描述符"></a><strong>2.3 部署描述符</strong></h3><p>&emsp;&emsp;部署描述符是<strong>用于描述Web应用程序的元数据</strong>，并为Java EE Web应用程序服务器部署和运行Web应用程序提供指令。从传统上来说，所有元数据都来自于部署描述符文件/WEB-INF/web.xml。该文件通常包含Servlet、监听器和过滤器的定义，以及HTTP会话、JSP和应用程序的配置选项。</p><h3 id="2-4-类加载器架构"><a href="#2-4-类加载器架构" class="headerlink" title="2.4 类加载器架构"></a><strong>2.4 类加载器架构</strong></h3><p>&emsp;&emsp;在使用Java EE Web应用程序时，有必要理解类加载器(ClassLoader)架构，因为它不同于你所熟悉的标准Java SE应用程序。在典型的应用程序中，Java SE平台中的java.*类将被加载到特定的<strong>根类加载器</strong>中，并且不能被覆盖。这是一种安全的方式，它阻止了恶意代码的执行，例如恶意代码可能会替换String类，或者重定义Boolean.TRUE和Boolean.FALSE。 </p><p>&emsp;&emsp;在根类加载器之后是<strong>扩展类加载器</strong>，它将加载JRE安装目录中的扩展JAR。最后，应用程序Class Loader将加载应用程序中的所有其他类。这组成了类加载器的层次，根类加载器是所有类加载器最早的祖先。当低级别类加载器申请加载一个类时，它总是首先将该任务委托给它的父类加载器。继续向上委托直至根类加载器确认成功。<strong>如果它的父类加载器未能找到该类，那么当前的类加载器将尝试从自己的JAR文件和目录中加载该类</strong>。 </p><p>&emsp;&emsp;这种类加载的方法被称为<strong>双亲优先类加载委托模式</strong>，尽管这种方法适用于许多类型的应用程序，但它并不完全适用于Java EE Web应用程序。运行Java EE Web应用程序的服务器通常相当复杂，许多供应商都可以提供其实现。服务器可能使用了与个人应用程序使用的相同的第三方库，但它们的版本可能相互冲突。另外，不同的Web应用程序也可能使用了同一第三方库的冲突版本，导致更多的问题为了解决这些问题，就需要使用<strong>子女优先类加载委托模式</strong>。 </p><p>&emsp;&emsp;在Java EE Web应用程序服务器中，每个Web应用程序都被分配了一个自由的相互隔离的类加载器，它们都继承自公共的服务器类加载器。通过隔离不同的应用程序，它们不能访问相互的类。这不仅消除了类冲突的风险，还是一种阻止Web应用程序被其他Web应用程序干扰或伤害的安全方式。另外，Web应用程序类加载器通常会在自己无法加载某个类的时候，请求它的父类加载器帮助加载。通过这种方式，<strong>类加载的任务会在最后而不是首先委托给它的父类</strong>，Web应用程序中的类和库会被优先使用，而不是服务器提供的版本优先使用。为了维持绑定的Java SE类的安全状态，Web应用程序类加载器仍然会在尝试加载任何类之前与根类加载器确认。尽管几乎在所有的情况下，这种委托模式都更适用于Web应用程序，但仍然有它不适用的情况。出于这个原因，兼容Java EE的服务器通常会提供修改委托模式的方法，从父类最后改为父类首先。 </p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《JavaWeb高级编程——涵盖WebSockets、Spring Framework、JPA Hibernate和Spring Security》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Java EE简介，内容包括：背景（Java SE 7的新特性、Java EE 7的新特性、Java SE 8的新特性），基本的Web应用程序结构（Servlet、过滤器、监听器和JSP、目录结构和WAR文件、部署描述符、类加载器架构）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="java web" scheme="http://linyishui.top/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行引擎-方法调用</title>
    <link href="http://linyishui.top/2019121201.html"/>
    <id>http://linyishui.top/2019121201.html</id>
    <published>2019-12-12T10:28:27.000Z</published>
    <updated>2020-01-10T03:11:17.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字节码执行引擎-方法调用"><a href="#字节码执行引擎-方法调用" class="headerlink" title="字节码执行引擎-方法调用"></a><strong>字节码执行引擎-方法调用</strong></h1><h2 id="第三节-方法调用"><a href="#第三节-方法调用" class="headerlink" title="第三节 方法调用"></a><strong>第三节 方法调用</strong></h2><p>&emsp;&emsp;方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p><h3 id="3-1-解析"><a href="#3-1-解析" class="headerlink" title="3.1 解析"></a><strong>3.1 解析</strong></h3><p>　<br>&emsp;&emsp;继续前面关于方法调用的话题，所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是:方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。</p><p>&emsp;&emsp;在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p><p>&emsp;&emsp;与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。</p><blockquote><ul><li>invokestatic: 调用静态方法。</li><li>invokespecial: 调用实例构造器＜init＞方法、私有方法和父类方法。invokevirtual:调用所有的虚方法。</li><li>invokeinterface: 调用接口方法，会在运行时再确定一个实现此接口的对象。</li><li>invokedynamic: 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而&gt;* invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul></blockquote><p>&emsp;&emsp;只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（除去final方法，后文会提到）。代码清单8-5演示了一个最常见的解析调用的例子，此样例中，静态方法sayHello()只可能属于类型StaticResolution，没有任何手段可以覆盖或隐藏这个方法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">8</span><span class="number">-5</span>　方法静态解析演示</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *方法静态解析演示 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StaticResolution</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello world"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123; </span><br><span class="line">        StaticResolution.sayHello(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用javap命令查看这段程序的字节码，会发现的确是通过invokestatic命令来调用sayHello()方法的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\Develop\&gt;javap-verbose StaticResolution </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(java.lang.<span class="keyword">String</span>[]); </span><br><span class="line">    Code: </span><br><span class="line">        Stack  =  <span class="number">0</span>，Locals  =  <span class="number">1</span>，Args_size  =  <span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>:    invokestatic#<span class="number">31</span>;    <span class="comment">//Method sayHello:()V </span></span><br><span class="line">        <span class="number">3</span>:    <span class="built_in">return</span> </span><br><span class="line">    </span><br><span class="line">    LineNumberTable: </span><br><span class="line">        <span class="built_in">line</span> <span class="number">15</span>:<span class="number">0</span> </span><br><span class="line">        <span class="built_in">line</span> <span class="number">16</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java中的非虚方法除了使用invokestatic、invokespecial调用的方法之外还有一种，就是被final修饰的方法。虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了final方法是一种非虚方法。</p><p>&emsp;&emsp;解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派（Dispatch）调用则可能是静态的也可能是动态的，根据分派依据的宗量数[1]可分为单分派和多分派。这两类分派方式的两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况，下面我们再看看虚拟机中的方法分派是如何进行的。</p><h3 id="3-2-分派"><a href="#3-2-分派" class="headerlink" title="3.2 分派"></a><strong>3.2 分派</strong></h3><p>&emsp;&emsp;众所周知，Java是一门面向对象的程序语言，因为Java具备面向对象的3个基本特征:继承、封装和多态。本节讲解的分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟机之中是如何实现的，这里的实现当然不是语法上该如何写，我们关心的依然是虚拟机如何确定正确的目标方法。</p><h4 id="3-2-1-静态分派"><a href="#3-2-1-静态分派" class="headerlink" title="3.2.1 静态分派"></a><strong>3.2.1 静态分派</strong></h4><p>&emsp;&emsp;在开始讲解静态分派[1]前，作者准备了一段经常出现在面试题中的程序代码，读者不妨先看一遍，想一下程序的输出结果是什么。后面我们的话题将围绕这个类的方法来重载（Overload）代码，以分析虚拟机和编译器确定方法版本的过程。方法静态分派如代码清单8-6所示。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-6　方法静态分派演示</span></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *方法静态分派演示 </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span></span>&#123; </span><br><span class="line">    static <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public void sayHello(<span class="type">Human</span> guy)&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"hello,guy!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public void sayHello(<span class="type">Man</span> guy)&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"hello,gentleman!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public void sayHello(<span class="type">Woman</span> guy)&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"hello,lady!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123; </span><br><span class="line">        <span class="type">Human</span> man = <span class="keyword">new</span> <span class="type">Man</span>(); </span><br><span class="line">        <span class="type">Human</span> woman = <span class="keyword">new</span> <span class="type">Woman</span>(); </span><br><span class="line">        <span class="type">StaticDispatch</span> sr = <span class="keyword">new</span> <span class="type">StaticDispatch</span>(); </span><br><span class="line">        sr.sayHello(man); </span><br><span class="line">        sr.sayHello(woman); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hello,</span>guy!</span><br><span class="line"><span class="built_in">hello,</span>guy!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单8-6中的代码实际上是在考验阅读者对重载的理解程度，相信对Java编程稍有经验的程序员看完程序后都能得出正确的运行结果，但为什么会选择执行参数类型为Human的重载呢？在解决这个问题之前，我们先按如下代码定义两个重要的概念。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Human man</span> = new Man();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们把上面代码中的“Human”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。例如下面的代码:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//实际类型变化 </span><br><span class="line">Human <span class="keyword">man</span> = new <span class="keyword">Man</span>(); </span><br><span class="line"><span class="keyword">man</span> = new <span class="keyword">Woman</span>(); </span><br><span class="line">//静态类型变化 </span><br><span class="line">sr.sayHello((<span class="keyword">Man</span>) <span class="keyword">man</span>) </span><br><span class="line">sr.sayHello((<span class="keyword">Woman</span>) <span class="keyword">man</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释了这两个概念，再回到代码清单8-6的样例代码中。main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。代码中刻意地定义了两个静态类型相同但实际类型不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</p><p>&emsp;&emsp;所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是比较“稀罕”的事情，产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。代码清单87演示了何为“更加合适的”版本。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-7　重载方法匹配优先级</span></span><br><span class="line">package org.fenixsoft.polymorphic; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Overload</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Object arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Object"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">int</span> arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello int"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">long</span> arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello long"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Character arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Character"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">char</span> arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello char"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">char</span>... arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello char ..."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Serializable arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Serializable"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </span><br><span class="line">        sayHello(<span class="string">'a'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码运行后会输出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="keyword">char</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这很好理解，’a’是一个char类型的数据，自然会寻找参数类型为char的重载方法，如果注释掉sayHello（char arg）方法，那输出会变为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时发生了一次自动类型转换，’a’除了可以代表一个字符串，还可以代表数字97（字符’a’的Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的。我们继续注释掉sayHello(int arg)方法，那输出会变为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="keyword">long</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时发生了两次自动类型转换，’a’转型为整数97之后，进一步转型为长整数97L，匹配了参数类型为long的重载。作者在代码中没有写其他的类型如float、double等的重载，不过实际上自动转型还能继续发生多次，按照char-&gt;int-&gt;long-&gt;float-&gt;double的顺序转型进行匹配。但不会匹配到byte和short类型的重载，因为char到byte或short的转型是不安全的。我们继续注释掉sayHello(long arg)方法，那输出会变为:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello Character</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时发生了一次自动装箱，’a’被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为Character的重载，继续注释掉sayHello(Character arg)方法，那输出会变为:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello Serializable</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个输出可能会让人感觉摸不着头脑，一个字符或数字与序列化有什么关系？出现helloSerializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生一次自动转型。char可以转型成int，但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现了另外一个接口java.lang.Comparable＜Character＞，如果同时出现两个参数分别为Serializable和Comparable＜Character＞的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如:sayHello（（Comparable＜Character＞）’a’），才能编译通过。下面继续注释掉sayHello（Serializable arg）方法，输出会变为:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。我们把sayHello（Object arg）也注释掉，输出将会变为:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hello</span></span> char ...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;7个重载方法已经被注释得只剩一个了，可见变长参数的重载优先级是最低的，这时候字符’a’被当做了一个数组元素。作者使用的是char类型的变长参数，读者在验证时还可以选择int类型、Character类型、Object类型等的变长参数重载来把上面的过程重新演示一遍。但要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的[2]。</p><p>&emsp;&emsp;代码清单8-7演示了编译期间选择静态分派目标的过程，这个过程也是Java语言实现方法重载的本质。演示所用的这段程序属于很极端的例子，除了用做面试题为难求职者以外，在实际工作中几乎不可能有实际用途。作者拿来做演示仅仅是用于讲解重载时目标方法选择的<br>过程，大部分情况下进行这样极端的重载都可算是真正的“关于茴香豆的茴有几种写法的研究”。无论对重载的认识有多么深刻，一个合格的程序员都不应该在实际应用中写出如此极端的重载代码。</p><p>&emsp;&emsp;另外还有一点读者可能比较容易混淆:作者讲述的解析与分派这两者之间的关系并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程。例如，前面说过，静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。</p><h4 id="3-2-2-动态分派"><a href="#3-2-2-动态分派" class="headerlink" title="3.2.2 动态分派"></a><strong>3.2.2 动态分派</strong></h4><p>&emsp;&emsp;了解了静态分派，我们接下来看一下动态分派的过程，它和多态性的另外一个重要体现[3]——重写（Override）有着很密切的关联。我们还是用前面的Man和Woman一起sayHello的例子来讲解动态分派，请看代码清单8-8中所示的代码。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-8　方法动态分派演示</span></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *方法动态分派演示 </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span></span>&#123; </span><br><span class="line">    static <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123; </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> void sayHello(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">protected</span> void sayHello()&#123; </span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"man say hello"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">protected</span> void sayHello()&#123; </span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"woman say hello"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123; </span><br><span class="line">        <span class="type">Human</span> man = <span class="keyword">new</span> <span class="type">Man</span>(); </span><br><span class="line">        <span class="type">Human</span> woman = <span class="keyword">new</span> <span class="type">Woman</span>(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line">        woman.sayHello(); </span><br><span class="line">        man = <span class="keyword">new</span> <span class="type">Woman</span>(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span> <span class="keyword">say</span> hello </span><br><span class="line"><span class="keyword">woman</span> <span class="keyword">say</span> hello </span><br><span class="line"><span class="keyword">woman</span> <span class="keyword">say</span> hello</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个运行结果相信不会出乎任何人的意料，对于习惯了面向对象思维的Java程序员会觉得这是完全理所当然的。现在的问题还是和前面的一样，虚拟机是如何知道要调用哪个方法的？</p><p>&emsp;&emsp;显然这里不可能再根据静态类型来决定，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？我们使用javap命令输出这段代码的字节码，尝试从中寻找答案，输出结果如代码清单8-9所示。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-9　main()方法的字节码</span></span><br><span class="line">public static void main(java<span class="selector-class">.lang</span><span class="selector-class">.String</span><span class="selector-attr">[]</span>); </span><br><span class="line">    <span class="selector-tag">Code</span>: </span><br><span class="line">        Stack = <span class="number">2</span>，Locals = <span class="number">3</span>，Args_size = <span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>:    new    <span class="number">#16</span>;              <span class="comment">//class org/fenixsoft/polymorphic/DynamicDispatch $Man </span></span><br><span class="line">        3:    dup </span><br><span class="line">        <span class="number">4</span>:    invokespecial    <span class="number">#18</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/DynamicDispatch $Man."＜init＞":()V </span></span><br><span class="line">        7:    astore_1 </span><br><span class="line">        <span class="number">8</span>:    new<span class="number">#19</span>;                  <span class="comment">//class org/fenixsoft/polymorphic/DynamicDispatch $Woman </span></span><br><span class="line">        11:   dup </span><br><span class="line">        <span class="number">12</span>:   invokespecial    <span class="number">#21</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/DynamicDispa tch $Woman."＜init＞":()V </span></span><br><span class="line">        15:   astore_2 </span><br><span class="line">        <span class="number">16</span>:   aload_1 </span><br><span class="line">        <span class="number">17</span>:   invokevirtual    <span class="number">#22</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/DynamicDispatch $Human.sayHello:()V </span></span><br><span class="line">        20:   aload_2 </span><br><span class="line">        <span class="number">21</span>:   invokevirtual    <span class="number">#22</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/DynamicDispatch $Human.sayHello:()V </span></span><br><span class="line">        24:   new<span class="number">#19</span>;                  <span class="comment">//class org/fenixsoft/polymorphic/DynamicDispatch $Woman </span></span><br><span class="line">        27:   dup </span><br><span class="line">        <span class="number">28</span>:   invokespecial    <span class="number">#21</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/Dynam icDispatch $Woman."＜init＞":()V </span></span><br><span class="line">        31:   astore_1 </span><br><span class="line">        <span class="number">32</span>:   aload_1 </span><br><span class="line">        <span class="number">33</span>:   invokevirtual    <span class="number">#22</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/ DynamicDispatch $Human.sayHello:()V </span></span><br><span class="line">        36:   return</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;0～15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表Slot之中，这个动作也就对应了代码中的这两句:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Human man</span> = new Man(); </span><br><span class="line"><span class="attribute">Human woman</span> = new Woman();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来的16～21句是关键部分，16、20两句分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为接收者（Receiver）；17和21句是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）完全一样的，但是这两句指令最终执行的目标方法并不相同。原因就需要从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤:</p><blockquote><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol></blockquote><p>&emsp;&emsp;由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h4 id="3-2-3-单分派与多分派"><a href="#3-2-3-单分派与多分派" class="headerlink" title="3.2.3 单分派与多分派"></a><strong>3.2.3 单分派与多分派</strong></h4><p>&emsp;&emsp;方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于《Java与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p><p>&emsp;&emsp;单分派和多分派的定义读起来拗口，从字面上看也比较抽象，不过对照着实例看就不难理解了。代码清单8-10中列举了一个Father和Son一起来做出“一个艰难的决定”的例子。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-10　单分派和多分派</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *单分派、多分派演示 </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dispatch</span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">QQ</span>&#123;&#125; </span><br><span class="line">    <span class="keyword">static</span> class_360&#123;&#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Father</span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span>(<span class="params">QQ arg</span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"father choose qq"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span>(<span class="params">_360 arg</span>)</span>&#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"father choose 360"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span>(<span class="params">QQ arg</span>)</span>&#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"son choose qq"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span>(<span class="params">_360 arg</span>)</span>&#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"son choose 360"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </span><br><span class="line">        Father father = <span class="keyword">new</span> Father(); </span><br><span class="line">        Father son = <span class="keyword">new</span> Son(); </span><br><span class="line">        father.hardChoice(new_360()); </span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father <span class="built_in">choose</span> <span class="number">360</span> </span><br><span class="line">son <span class="built_in">choose</span> qq</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在main函数中调用了两次hardChoice()方法，这两次hardChoice()方法的选择结果在程序输出中已经显示得很清楚了。</p><p>&emsp;&emsp;我们来看看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点:一是静态类型是Father还是Son，二是方法参数是QQ还是360。这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向Father.hardChoice(360)及Father.hardChoice(QQ)方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p><p>&emsp;&emsp;再看看运行阶段虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoice(new QQ())”这句代码时，更准确地说，是在执行这句代码所对应的invokevirtual指令时，由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Son。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p><p>&emsp;&emsp;根据上述论证的结果，我们可以总结一句:今天（直至还未发布的Java 1.8）的Java语言是一门静态多分派、动态单分派的语言。强调“今天的Java语言”是因为这个结论未必会恒久不变，C#在3.0及之前的版本与Java一样是动态单分派语言，但在C#4.0中引入了dynamic类型后，就可以很方便地实现动态多分派。</p><p>&emsp;&emsp;按照目前Java语言的发展趋势，它并没有直接变为动态语言的迹象，而是通过内置动态语言（如JavaScript）执行引擎的方式来满足动态性的需求。但是Java虚拟机层面上则不是如此，在JDK 1.7中实现的JSR-292[4]里面就已经开始提供对动态语言的支持了，JDK1.7中新增的invokedynamic指令也成为了最复杂的一条方法调用的字节码指令，稍后作者将专门讲解这个JDK1.7的新特性。</p><h4 id="3-2-4-虚拟机动态分派的实现"><a href="#3-2-4-虚拟机动态分派的实现" class="headerlink" title="3.2.4 虚拟机动态分派的实现"></a><strong>3.2.4 虚拟机动态分派的实现</strong></h4><p>&emsp;&emsp;前面介绍的分派过程，作为对虚拟机概念模型的解析基本上已经足够了，它已经解决了虚拟机在分派中“会做什么”这个问题。但是虚拟机“具体是如何做到的”，可能各种虚拟机的实现都会有些差别。</p><p>&emsp;&emsp;由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。面对这种情况，最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表（Vritual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Inteface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。我们先看看代码清单8-10所对应的虚方法表结构示例，如图8-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010163.png" alt="方法表结构"></p><p>&emsp;&emsp;虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。图8-3中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。</p><p>&emsp;&emsp;为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p>&emsp;&emsp;方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p><p>&emsp;&emsp;上文中作者说方法表是分派调用的“稳定优化”手段，虚拟机除了使用方法表之外，在条件允许的情况下，还会使用内联缓存（Inline Cache）和基于“类型继承关系分析”（Class Hierarchy Analysis,CHA）技术的守护内联（Guarded Inlining）两种非稳定的“激进优化”手段来获得更高的性能，关于这两种优化技术的原理和运作过程，读者可以参考本书第11章中的相关内容。</p><h3 id="3-3-动态类型语言支持"><a href="#3-3-动态类型语言支持" class="headerlink" title="3.3 动态类型语言支持"></a><strong>3.3 动态类型语言支持</strong></h3><p>&emsp;&emsp;Java虚拟机的字节码指令集的数量从Sun公司的第一款Java虚拟机问世至JDK7来临之前的十余年时间里，一直没有发生任何变化。随着JDK7的发布，字节码指令集终于迎来了第一位新成员——invokedynamic指令。这条新增加的指令是JDK7实现“动态类型语言”（Dynamically Typed Language）支持而进行的改进之一，也是为JDK 8可以顺利实现Lambda表达式做技术准备。在本节中，我们将详细讲解JDK7这项新特性出现的前因后果和它的深远意义。</p><h4 id="3-3-1-动态类型语言"><a href="#3-3-1-动态类型语言" class="headerlink" title="3.3.1 动态类型语言"></a><strong>3.3.1 动态类型语言</strong></h4><p>&emsp;&emsp;在介绍Java虚拟机的动态类型语言支持之前，我们要先弄明白动态类型语言是什么？它与Java语言、Java虚拟机有什么关系？了解JDK 1.7提供动态类型语言支持的技术背景，对理解这个语言特性是很有必要的。</p><p>&emsp;&emsp;什么是动态类型语言[1]？动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期，满足这个特征的语言有很多，常用的包括:APL、Clojure、Erlang、Groovy、JavaScript、Jython、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk和Tcl等。相对的，在编译期就进行类型检查过程的语言（如C++和Java等）就是最常用的静态类型语言。</p><p>&emsp;&emsp;觉得上面定义过于概念化？那我们不妨通过两个例子以最浅显的方式来说明什么是“在编译期/运行期进行”和什么是“类型检查”。首先看下面这段简单的Java代码，它是否能正常编译和运行？</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="keyword"> static</span> void main(String[] args)&#123; </span><br><span class="line">    int[][][]<span class="built_in"> array </span>=<span class="built_in"> new </span>int[1][0][-1]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码能够正常编译，但运行的时候会报NegativeArraySizeException异常。在Java虚拟机规范中明确规定了NegativeArraySizeException是一个运行时异常，通俗一点来说，运行时异常就是只要代码不运行到这一行就不会有问题。与运行时异常相对应的是连接时异常，例如很常见的NoClassDefFoundError便属于连接时异常，即使会导致连接时异常的代码放在一条无法执行到的分支路径上，类加载时（Java的连接过程不在编译阶段，而在类加载阶段）也照样会抛出异常。</p><p>&emsp;&emsp;不过，在C语言中，含义相同的代码会在编译期报错:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123; </span><br><span class="line">   <span class="built_in"> int </span>i[1][0][-1];//GCC拒绝编译，报“size of<span class="built_in"> array </span>is negative” </span><br><span class="line">   <span class="built_in"> return </span>0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此看来，一门语言的哪一种检查行为要在运行期进行，哪一种检查要在编译期进行并没有必然的因果逻辑关系，关键是语言规范中人为规定的。再举一个例子来解释“类型检查”，例如下面这一句非常简单的代码:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.println(<span class="string">"hello world"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽然每个人都能看懂这行代码要做什么，但对于计算机来说，这一行代码“没头没尾”是无法执行的，它需要一个具体的上下文才有讨论的意义。</p><p>&emsp;&emsp;现在假设这行代码是在Java语言中，并且变量obj的静态类型为java.io.PrintStream，那变量obj的实际类型就必须是PrintStream的子类（实现了PrintStream接口的类）才是合法的。否则，哪怕obj属于一个确实有用println(String)方法，但与PrintStream接口没有继承关系，代码依然不可能运行——因为类型检查不合法。</p><p>&emsp;&emsp;但是相同的代码在ECMAScript（JavaScript）中情况则不一样，无论obj具体是何种类型，只要这种类型的定义中确实包含有println(String)方法，那方法调用便可成功。</p><p>&emsp;&emsp;这种差别产生的原因是Java语言在编译期间已将println(String)方法完整的符号引用（本例中为一个CONSTANT_InterfaceMethodref_info常量）生成出来，作为方法调用指令的参数存储到Class文件中，例如下面这段代码:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual    <span class="meta">#4;    <span class="comment">//Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，虚拟机可以翻译出这个方法的直接引用。而在ECMAScript等动态类型语言中，变量obj本身是没有类型的，变量obj的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个重要特征。</p><p>&emsp;&emsp;了解了动态和静态类型语言的区别后，也许读者的下一个问题就是动态、静态类型语言两者谁更好，或者谁更加先进？这种比较不会有确切答案，因为它们都有自己的优点，选择哪种语言是需要经过权衡的。静态类型语言在编译期确定类型，最显著的好处是编译器可以提供严谨的类型检查，这样与类型相关的问题能在编码的时候就及时发现，利于稳定性及代码达到更大规模。而动态类型语言在运行期确定类型，这可以为开发人员提供更大的灵活性，某些在静态类型语言中需用大量“臃肿”代码来实现的功能，由动态类型语言来实现可能会更加清晰和简洁，清晰和简洁通常也就意味着开发效率的提升。</p><h4 id="3-3-2-JDK-1-7与动态类型"><a href="#3-3-2-JDK-1-7与动态类型" class="headerlink" title="3.3.2 JDK 1.7与动态类型"></a><strong>3.3.2 JDK 1.7与动态类型</strong></h4><p>&emsp;&emsp;回到本节的主题，来看看Java语言、虚拟机与动态类型语言之间有什么关系。Java虚拟机毫无疑问是Java语言的运行平台，但它的使命并不仅限于此，早在1997年出版的《Java虚拟机规范》中就规划了这样一个愿景:“在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上”。而目前确实已经有许多动态类型语言运行于Java虚拟机之上了，如Clojure、Groovy、Jython和JRuby等，能够在同一个虚拟机上可以达到静态类型语言的严谨性与动态类型语言的灵活性，这是一件很美妙的事情。</p><p>&emsp;&emsp;但遗憾的是，Java虚拟机层面对动态类型语言的支持一直都有所欠缺，主要表现在方法调用方面:JDK 1.7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是被调用的方法的符号引用（CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量），前面已经提到过，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定接收者类型。这样，在Java虚拟机上实现的动态类型语言就不得不使用其他方式（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现，这样势必让动态类型语言实现的复杂度增加，也可能带来额外的性能或者内存开销。尽管可以利用一些办法（如Call Site Caching）让这些开销尽量变小，但这种底层问题终归是应当在虚拟机层次上去解决才最合适，因此在Java虚拟机层面上提供动态类型的直接支持就成为了Java平台的发展趋势之一，这就是JDK 1.7（JSR-292）中invokedynamic指令以及java.lang.invoke包出现的技术背景。</p><h4 id="3-3-3-java-lang-invoke包"><a href="#3-3-3-java-lang-invoke包" class="headerlink" title="3.3.3 java.lang.invoke包"></a><strong>3.3.3 java.lang.invoke包</strong></h4><p>&emsp;&emsp;JDK1.7实现了JSR-292，新加入的java.lang.invoke包[2]就是JSR-292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称为MethodHandle。这种表达方式也许不太好懂？那不妨把MethodHandle与C/C++中的Function Pointer，或者C#里面的Delegate类比一下。举个例子，如果我们要实现一个带谓词的排序函数，在C/C++中常用的做法是把谓词定义为函数，用函数指针把谓词传递到排序方法，如下:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">sort</span>(<span class="built_in">int</span> list[], <span class="keyword">const</span> <span class="built_in">int</span> <span class="built_in">size</span>, <span class="built_in">int</span>(*compare)(<span class="built_in">int</span>, <span class="built_in">int</span>))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但Java语言做不到这一点，即没有办法单独地把一个函数作为参数进行传递。普遍的做法是设计一个带有compare()方法的Comparator接口，以实现了这个接口的对象作为参数，例如Collections.sort()就是这样定义的:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> sort(<span class="built_in">List</span> <span class="built_in">list</span>, Comparator c)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不过，在拥有Method Handle之后，Java语言也可以拥有类似于函数指针或者委托的方法别名的工具了。代码清单8-11演示了MethodHandle的基本用途，无论obj是何种类型（临时定义的ClassA抑或是实现PrintStream接口的实现类System.out），都可以正确地调用到println()方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-11　MethodHandle演示</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *JSR-292 Method Handle基础用法演示 </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span>&#123;</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>&#123;</span> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> println(String s)&#123; </span><br><span class="line">            System.out.println(s); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)<span class="keyword">throws</span> Throwable&#123; </span><br><span class="line">        Object obj = System.currentTimeMillis()%<span class="number">2</span> == <span class="number">0</span> ? System.out:<span class="keyword">new</span> ClassA(); </span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法 </span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"icyfenix"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MethodHandle getPrintlnMH(Object reveiver) <span class="keyword">throws</span> Throwable&#123; </span><br><span class="line">        <span class="comment">/*MethodType:代表“方法类型”，包含了方法的返回值(methodType()的第一个参数)和具体参数(methodType()第二个及以后的参数)*/</span> </span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span>.<span class="keyword">class</span>, String.<span class="keyword">class</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄*/</span> </span><br><span class="line">        <span class="comment">/*因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即是this指向的对象，这个参数以前是放在参数列表中进行传递的，而现在提供了bindTo()方法来完成这件事情*/</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上，方法getPrintlnMH()中模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个具体方法来实现。而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。以此为基础，有了MethodHandle就可以写出类似于下面这样的函数声明:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">sort</span>(<span class="keyword">List</span> <span class="keyword">list</span>, MethodHandle <span class="keyword">compare</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的例子可以看出，使用MethodHandle并没有什么困难，不过看完它的用法之后，读者大概就会产生疑问，相同的事情，用反射不是早就可以实现了吗？</p><p>&emsp;&emsp;确实，仅站在Java语言的角度来看，MethodHandle的使用方法和效果与Reflection有众多相似之处，不过，它们还是有以下这些区别:</p><p>&emsp;&emsp;从本质上讲，Reflection和MethodHandle机制都是在模拟方法调用，但Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。在MethodHandles.lookup中的3个方法——findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual＆invokeinterface和invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。</p><p>&emsp;&emsp;Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息多。前者是方法在Java一端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅仅包含与执行该方法相关的信息。用通俗的话来讲，Reflection是重量级，而MethodHandle是轻量级。</p><p>&emsp;&emsp;由于MethodHandle是对字节码的方法指令调用的模拟，所以理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还不完善）。而通过反射去调用方法则不行。</p><p>&emsp;&emsp;MethodHandle与Reflection除了上面列举的区别外，最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度来看”:ReflectionAPI的设计目标是只为Java语言服务的，而MethodHandle则设计成可服务于所有Java虚拟机之上的语言，其中也包括Java语言。</p><h4 id="3-3-4-invokedynamic指令"><a href="#3-3-4-invokedynamic指令" class="headerlink" title="3.3.4 invokedynamic指令"></a><strong>3.3.4 invokedynamic指令</strong></h4><p>&emsp;&emsp;本节一开始就提到了JDK1.7为了更好地支持动态类型语言，引入了第5条方法调用的字节码指令invokedynamic，之后一直没有再提到它，甚至把代码清单8-11中使用MethodHandle的示例代码反编译后也不会看见invokedynamic的身影，它的应用之处在哪里呢？</p><p>&emsp;&emsp;在某种程度上，invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke*”指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（包含其他语言的设计者）有更高的自由度。而且，它们两者的思路也是可类比的，可以把它们想象成为了达成同一个目的，一个采用上层Java代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。因此，如果理解了前面的MethodHandle例子，那么理解invokedynamic指令也并不困难。</p><p>&emsp;&emsp;每一处含有invokedynamic指令的位置都称做“动态调用点”（Dynamic Call Site），这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK 1.7新加入的CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息:引导方法（BootstrapMethod，此方法存放在新增的BootstrapMethods属性中）、方法类型（MethodType）和名称。引导方法是有固定的参数，并且返回值是java.lang.invoke.CallSite对象，这个代表真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用要执行的目标方法。我们还是举一个实际的例子来解释这个过程，如代码清单8-12所示。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-12　invokedynamic指令演示</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.CallSite; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.ConstantCallSite; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeDynamicTest</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">        INDY_BootstrapMethod().invokeExact(<span class="string">"icyfenix"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(String s)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello String:"</span>+s); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">CallSite <span class="title">BootstrapMethod</span><span class="params">(MethodHandles.Lookup lookup, String name, MethodType mt)</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(lookup.findStatic(InvokeDynamicTest.class,name,mt)); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">MethodType <span class="title">MT_BootstrapMethod</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> MethodType </span><br><span class="line">                .fromMethodDescriptorString(</span><br><span class="line">                    <span class="string">"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"</span>,  <span class="keyword">null</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">MethodHandle <span class="title">MH_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> lookup().findStatic(InvokeDynamicTest.class, <span class="string">"BootstrapMethod"</span>, MT_BootstrapMethod()); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">MethodHandle <span class="title">INDY_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">        CallSite cs = (CallSite)MH_BootstrapMethod().invokeWithArguments(lookup(), <span class="string">"testMethod"</span>, MethodType.fromMethodDescriptorString(<span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">null</span>)); </span><br><span class="line">        <span class="function"><span class="keyword">return</span> cs.<span class="title">dynamicInvoker</span><span class="params">()</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码与前面MethodHandleTest的作用基本上是一样的，虽然作者没有加以注释，但是阅读起来应当不困难。本书前面提到过，由于invokedynamic指令所面向的使用者并非Java语言，而是其他Java虚拟机之上的动态语言，因此仅依靠Java语言的编译器Javac没有办法生成带有invokedynamic指令的字节码（曾经有一个java.dyn.InvokeDynamic的语法糖可以实现，但后来被取消了），所以要使用Java语言来演示invokedynamic指令只能用一些变通的办法。John Rose（DaVinci Machine Project的Leader）编写了一个把程序的字节码转换为使用invokedynamic的简单工具INDY[3]来完成这件事情，我们要使用这个工具来产生最终要的字节码，因此这个示例代码中的方法名称不能随意改动，更不能把几个方法合并到一起写，因为它们是要被INDY工具读取的。</p><p>&emsp;&emsp;把上面代码编译、再使用INDY转换后重新生成的字节码如代码清单8-13所示（结果使用javap输出，因版面原因，精简了许多无关的内容）。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-13　invokedynamic指令演示(2)</span></span><br><span class="line">Constant pool: </span><br><span class="line">    <span class="meta">#121 = NameAndType      #33:#30    <span class="comment">//testMethod:(Ljava/lang/String;)V </span></span></span><br><span class="line">    <span class="meta">#123 = InvokeDynamic    #0:#121    <span class="comment">//#0:testMethod:(Ljava/lang/String;)V </span></span></span><br><span class="line"></span><br><span class="line">public static void main(java.lang.<span class="keyword">String</span>[]) throws java.lang.Throwable; </span><br><span class="line">    <span class="built_in">Code</span>: </span><br><span class="line">        stack = <span class="number">2</span>，locals = <span class="number">1</span>，args_size = <span class="number">1</span> </span><br><span class="line">            <span class="number">0</span>: ldc            <span class="meta">#23        <span class="comment">//String abc </span></span></span><br><span class="line">            <span class="number">2</span>: invokedynamic  <span class="meta">#123, 0    <span class="comment">//InvokeDynamic#0:testMethod:(Ljava/lang/String;)V </span></span></span><br><span class="line">            <span class="number">7</span>: nop </span><br><span class="line">            <span class="number">8</span>: <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">public static java.lang.invoke.CallSite BootstrapMethod(java.lang.invoke.MethodHandles $Lookup,java.lang.<span class="keyword">String</span>,java.lang.invoke.MethodType) throws java.lang.Throwable; </span><br><span class="line">    <span class="built_in">Code</span>: </span><br><span class="line">        stack = <span class="number">6</span>，locals = <span class="number">3</span>，args_size = <span class="number">3</span> </span><br><span class="line">            <span class="number">0</span>: <span class="keyword">new</span>            <span class="meta">#63        <span class="comment">//class java/lang/invoke/ConstantCallSite </span></span></span><br><span class="line">            <span class="number">3</span>: dup </span><br><span class="line">            <span class="number">4</span>: aload_0 </span><br><span class="line">            <span class="number">5</span>: ldc            <span class="meta">#1         <span class="comment">//class org/fenixsoft/InvokeDynamicTest </span></span></span><br><span class="line">            <span class="number">7</span>: aload_1 </span><br><span class="line">            <span class="number">8</span>: aload_2 </span><br><span class="line">            <span class="number">9</span>: invokevirtual  <span class="meta">#65        <span class="comment">//Method java/lang/invoke/MethodHandles$Lookup.findStatic:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle; </span></span></span><br><span class="line">            <span class="number">12</span>: invokespecial <span class="meta">#71        <span class="comment">//Method java/lang/invoke/ConstantCallSite."＜init＞":(Ljava/lang/invoke/MethodHandle;)V </span></span></span><br><span class="line">            <span class="number">15</span>: areturn</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从main()方法的字节码可见，原本的方法调用指令已经替换为invokedynamic，它的参数为第123项常量（第二个值为0的参数在HotSpot中用不到，与invokeinterface指令那个值为0的参数一样都是占位的）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2</span>: invokedynamic  <span class="number">#123</span>, <span class="number">0</span>    <span class="comment">// InvokeDynamic #0:testMethod:(Ljava/lang/String;)V</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从常量池中可见，第123项常量显示“#123 = InvokeDynamic#0:#121”说明它是一项CONSTANT_InvokeDynamic_info类型常量，常量值中前面的“#0”代表引导方法取BootstrapMethods属性表的第0项（javap没有列出属性表的具体内容，不过示例中仅有一个引导方法，即BootstrapMethod()），而后面的“#121”代表引用第121项类型为CONSTANT_NameAndType_info的常量，从这个常量中可以获取方法名称和描述符，即后面输出的“testMethod:（Ljava/lang/String；）V”。</p><p>&emsp;&emsp;再看一下BootstrapMethod()，这个方法Java源码中没有，是INDY产生的，但是它的字节码很容易读懂，所有逻辑就是调用MethodHandles $Lookup的findStatic()方法，产生testMethod()方法的MethodHandle，然后用它创建一个ConstantCallSite对象。最后，这个对象返回给invokedynamic指令实现对testMethod()方法的调用，invokedynamic指令的调用过程到此就宣告完成了。</p><h4 id="3-3-5-掌控方法分派规则"><a href="#3-3-5-掌控方法分派规则" class="headerlink" title="3.3.5 掌控方法分派规则"></a><strong>3.3.5 掌控方法分派规则</strong></h4><p>&emsp;&emsp;invokedynamic指令与前面4条“invoke*”指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。在介绍Java虚拟机动态语言支持的最后一个小结中，作者通过一个简单例子（如代码清单8-14所示），帮助读者理解程序员在可以掌控方法分派规则之后，能做什么以前无法做到的事情。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-14　方法调用问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span></span>&#123; </span><br><span class="line">    void thinking()&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"i am grandfather"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span></span>&#123; </span><br><span class="line">    void thinking()&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"i am father"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123; </span><br><span class="line">    void thinking()&#123; </span><br><span class="line">        <span class="comment">//请读者在这里填入适当的代码(不能修改其他地方的代码) </span></span><br><span class="line">        <span class="comment">//实现调用祖父类的thinking()方法，打印"i am grandfather" </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Java程序中，可以通过“super”关键字很方便地调用到父类中的方法，但如果要访问祖类的方法呢？读者在阅读本书下面提供的解决方案之前，不妨自己思考一下，在JDK 1.7之前有没有办法解决这个问题。</p><p>&emsp;&emsp;在JDK 1.7之前，使用纯粹的Java语言很难处理这个问题（直接生成字节码就很简单，如使用ASM等字节码工具），原因是在Son类的thinking()方法中无法获取一个实际类型是GrandFather的对象引用，而invokevirtual指令的分派逻辑就是按照方法接收者的实际类型进行分派，这个逻辑是固化在虚拟机中的，程序员无法改变。在JDK1.7中，可以使用代码清单815中的程序来解决这个问题。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-15　使用MethodHandle来解决相关问题</span></span><br><span class="line"><span class="keyword">import</span> static java.lang.invoke.<span class="type">MethodHandles</span>.lookup; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.<span class="type">MethodHandle</span>; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.<span class="type">MethodType</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span></span>&#123; </span><br><span class="line">        void thinking()&#123; </span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"i am grandfather"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span></span>&#123;</span><br><span class="line">        void thinking()&#123; </span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"i am father"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123; </span><br><span class="line">        void thinking()&#123; </span><br><span class="line">            <span class="keyword">try</span>&#123; </span><br><span class="line">                <span class="type">MethodType</span> mt = <span class="type">MethodType</span>.methodType(void.<span class="keyword">class</span>); </span><br><span class="line">                <span class="type">MethodHandle</span> mh = lookup().findSpecial(<span class="type">GrandFather</span>.<span class="keyword">class</span>, <span class="string">"thinking"</span>, mt,getClass()); </span><br><span class="line">                mh.invoke(<span class="keyword">this</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">Throwable</span> e)&#123; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123; </span><br><span class="line">        (<span class="keyword">new</span> <span class="type">Test</span>().<span class="keyword">new</span> <span class="type">Son</span>()).thinking(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> am grandfather</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等:</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的字节码执行引擎-方法调用，包括：解析，分派（静态分派、动态分派、单分派与多分派、虚拟机动态分派的实现），动态类型语言支持（动态类型语言、JDK 1.7与动态类型、java.lang.invoke包、invokedynamic指令、掌控方法分派规则、）等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行引擎-运行时栈帧结构</title>
    <link href="http://linyishui.top/2019121101.html"/>
    <id>http://linyishui.top/2019121101.html</id>
    <published>2019-12-11T10:28:22.000Z</published>
    <updated>2020-01-10T03:11:48.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字节码执行引擎-运行时栈帧结构"><a href="#字节码执行引擎-运行时栈帧结构" class="headerlink" title="字节码执行引擎-运行时栈帧结构"></a><strong>字节码执行引擎-运行时栈帧结构</strong></h1><h2 id="第二节-运行时栈帧结构"><a href="#第二节-运行时栈帧结构" class="headerlink" title="第二节 运行时栈帧结构"></a><strong>第二节 运行时栈帧结构</strong></h2><p>&emsp;&emsp;栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）[1]的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p>&emsp;&emsp;每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中[2]，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p>&emsp;&emsp;一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图8-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010161.png" alt="栈帧的概念结构"></p><p>&emsp;&emsp;接下来详细讲解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的作用和数据结构。</p><h3 id="2-1-局部变量表"><a href="#2-1-局部变量表" class="headerlink" title="2.1 局部变量表"></a><strong>2.1 局部变量表</strong></h3><p>&emsp;&emsp;局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><p>&emsp;&emsp;局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，但这种描述与明确指出“每个Slot占用32位长度的内存空间”是有一些差别的，它允许Slot的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。</p><p>&emsp;&emsp;既然前面提到了Java虚拟机的数据类型，在此再简单介绍一下它们。一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference[3]和returnAddress8种类型。前面6种不需要多加解释，读者可以按照Java语言中对应数据类型的概念去理解它们（仅是这样理解而已，Java语言与Java虚拟机中的基本数据类型是存在本质差别的），而第7种reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但一般来说，虚拟机实现至少都应当能通过这个引用做到两点，一是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束约束[4]。第8种即returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替。</p><p>&emsp;&emsp;对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。Java语言中明确的（reference类型则可能是32位也可能是64位）64位的数据类型只有long和double两种。值得一提的是，这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把一次long和double数据类型读写分割为两次32位读写的做法有些类似，读者阅读到Java内存模型时可以互相对比一下。不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题[5]。</p><p>&emsp;&emsp;虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。</p><p>&emsp;&emsp;在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参<br>数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。</p><p>&emsp;&emsp;为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接影响到系统的垃圾收集行为，请看代码清单8-1～代码清单8-3的3个演示。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-1　局部变量表Slot复用对垃圾收集的影响之一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">    <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    System.gc(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单8-1中的代码很简单，即向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上“-verbose：gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收这64MB的内存，下面是运行的结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="number">66846</span>K-&gt;<span class="number">65824</span>K(<span class="number">125632</span>K)，<span class="number">0.0032678</span> secs] [Full GC <span class="number">65824</span>K-&gt;<span class="number">65746</span>K(<span class="number">125632</span>K)，<span class="number">0.0064131</span> secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;没有回收placeholder所占的内存能说得过去，因为在执行System.gc()时，变量placeholder还处于作用域之内，虚拟机自然不敢回收placeholder的内存。那我们把代码修改一下，变成代码清单8-2中的样子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-2　局部变量表Slot复用对垃圾收集的影响之二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) () &#123; </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">byte</span>[]placeholder=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    System.gc(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加入了花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，在执行System.gc()的时候，placeholder已经不可能再被访问了，但执行一下这段程序，会发现运行结果如下，还是有64MB的内存没有被回收，这又是为什么呢？</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="number">66846</span>K-&gt;<span class="number">65888</span>K(<span class="number">125632</span>K)，<span class="number">0.0009397</span> secs] </span><br><span class="line">[Full GC <span class="number">65888</span>K-&gt;<span class="number">65746</span>K(<span class="number">125632</span>K)，<span class="number">0.0051574</span> secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在解释为什么之前，我们先对这段代码进行第二次修改，在调用System.gc()之前加入一行“int a=0；”，变成代码清单8-3的样子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-3　局部变量表Slot复用对垃圾收集的影响之三</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) () &#123; </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>; </span><br><span class="line">    System.gc(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个修改看起来很莫名其妙，但运行一下程序，却发现这次内存真的被正确回收了。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="number">66401</span>K-&gt;<span class="number">65778</span>K(<span class="number">125632</span>K)，<span class="number">0.0035471</span> secs] </span><br><span class="line">[Full GC <span class="number">65778</span>K-&gt;<span class="number">218</span>K(<span class="number">125632</span>K)，<span class="number">0.0140596</span> secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码清单8-1～代码清单8-3中，placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GCRoots一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句int a = 0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。Java语言的一本非常著名的书籍《Practical Java》中把“不使用的对象应手动赋值为null”作为一条推荐的编码规则，但是并没有解释具体的原因，很长时间之内都有读者对这条规则感到疑惑。</p><p>&emsp;&emsp;虽然代码清单8-1～代码清单8-3的代码示例说明了赋null值的操作在某些情况下确实是有用的，但作者的观点是不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普遍的编码规则来推广。原因有两点，从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法，如代码清单8-3那样的场景并不多见。更关键的是，从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，在第6章介绍完字节码后，作者专门增加了一个6.5节“公有设计、私有实现”来强调概念模型与实际执行过程是外部看起来等效，内部看上去则可以完全不同。在虚拟机使用解释器执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。字节码被编译为本地代码后，对GCRoots的枚举也与解释执行时期有巨大差别，以前面例子来看，代码清单8-2在经过JIT编译后，System.gc()执行时就可以正确地回收掉内存，无须写成代码清单8-3的样子。</p><p>&emsp;&emsp;关于局部变量表，还有一点可能会对实际开发产生影响，就是局部变量不像前面介绍的类变量那样存在“准备阶段”。通过第7章的讲解，我们已经知道类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样，如果一个局部变量定义了但没有赋初始值是不能使用的，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值。如代码清单8-4所示，这段代码其实并不能运行，还好编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虚拟机发现而导致类加载失败。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-4　未赋值的局部变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    System.out.<span class="built_in">println</span>(a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-操作数栈"><a href="#2-2-操作数栈" class="headerlink" title="2.2 操作数栈"></a><strong>2.2 操作数栈</strong></h3><p>&emsp;&emsp;操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p><p>&emsp;&emsp;当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p><p>&emsp;&emsp;举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。</p><p>&emsp;&emsp;操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。再以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况。</p><p>&emsp;&emsp;另外，在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递，重叠的过程如图8-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010162.png" alt="两个栈帧之间的数据共享"></p><p>&emsp;&emsp;Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。本章稍后会对基于栈的代码过程进行更详细的讲解。</p><h3 id="2-3-动态连接"><a href="#2-3-动态连接" class="headerlink" title="2.3 动态连接"></a><strong>2.3 动态连接</strong></h3><p>&emsp;&emsp;每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。通过第6章的讲解，我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。关于这两个转化过程的详细信息，将在8.3节中详细讲解。</p><p>&emsp;&emsp;运行时常量池可参考第2章。</p><h3 id="2-4-方法返回地址"><a href="#2-4-方法返回地址" class="headerlink" title="2.4 方法返回地址"></a><strong>2.4 方法返回地址</strong></h3><p>&emsp;&emsp;当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</p><p>&emsp;&emsp;另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p><p>&emsp;&emsp;无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><p>&emsp;&emsp;方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><h3 id="2-5-附加信息"><a href="#2-5-附加信息" class="headerlink" title="2.5 附加信息"></a><strong>2.5 附加信息</strong></h3><p>&emsp;&emsp;虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的字节码执行引擎-运行时栈帧结构，包括：局部变量表，操作数栈，动态连接，方法返回地址，附加信息等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行引擎</title>
    <link href="http://linyishui.top/2019121001.html"/>
    <id>http://linyishui.top/2019121001.html</id>
    <published>2019-12-10T10:28:14.000Z</published>
    <updated>2020-01-10T09:41:48.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a><strong>虚拟机字节码执行引擎</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p><p>&emsp;&emsp;执行引擎是Java虚拟机最核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p><p>&emsp;&emsp;在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择[1]，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果，本章将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。</p><hr><h2 id="第二节-运行时栈帧结构"><a href="#第二节-运行时栈帧结构" class="headerlink" title="第二节 运行时栈帧结构"></a><strong>第二节 运行时栈帧结构</strong></h2><p>&emsp;&emsp;<a href="../2019121101.html" title="Title">字节码执行引擎-运行时栈帧结构</a></p><hr><h2 id="第三节-方法调用"><a href="#第三节-方法调用" class="headerlink" title="第三节 方法调用"></a><strong>第三节 方法调用</strong></h2><p>&emsp;&emsp;<a href="../2019121201.html" title="Title">字节码执行引擎-方法调用</a></p><hr><h2 id="第四节-基于栈的字节码解释执行引擎"><a href="#第四节-基于栈的字节码解释执行引擎" class="headerlink" title="第四节 基于栈的字节码解释执行引擎"></a><strong>第四节 基于栈的字节码解释执行引擎</strong></h2><p>&emsp;&emsp;虚拟机是如何调用方法的内容已经讲解完毕，从本节开始，我们来探讨虚拟机是如何执行方法中的字节码指令的。上文中提到过，许多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，在本章中，我们先来探讨一下在解释执行时，虚拟机执行引擎是如何工作的。</p><h3 id="4-1-解释执行"><a href="#4-1-解释执行" class="headerlink" title="4.1 解释执行"></a><strong>4.1 解释执行</strong></h3><p>&emsp;&emsp;Java语言经常被人们定位为“解释执行”的语言，在Java初生的JDK 1.0时代，这种定义还算是比较准确的，但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。再后来，Java也发展出了可以直接生成本地代码的编译器[如GCJ[1]（GNU Compiler for the Java）]，而C/C++语言也出现了通过解释器执行的版本（如CINT[2]），这时候再笼统地说“解释执行”，对于整个Java语言来说就成了几乎是没有意义的概念，只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。</p><p>&emsp;&emsp;不论是解释还是编译，也不论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅读、理解，然后就获得了执行能力。大部分的程序代码到物理机的目标代码或虚拟机能执行的指令集之前，都需要经过图8-4中的各个步骤。如果读者对编译原理的相关课程还有印象的话，很容易就会发现图8-4中下面那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程，而中间的那条分支，自然就是解释执行的过程。</p><p>&emsp;&emsp;如今，基于物理机、Java虚拟机，或者非Java的其他高级语言虚拟机（HLLVM）的语言，大多都会遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树（Abstract Syntax Tree,AST）。对于一门具体语言的实现来说，词法分析、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的JavaScript执行器。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010164.png" alt="编译过程"></p><p>&emsp;&emsp;Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p><h3 id="4-2-基于栈的指令集与基于寄存器的指令集"><a href="#4-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="4.2 基于栈的指令集与基于寄存器的指令集"></a><strong>4.2 基于栈的指令集与基于寄存器的指令集</strong></h3><p>&emsp;&emsp;Java编译器输出的指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set Architecture,ISA），指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，说得通俗一些，就是现在我们主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作。那么，基于栈的指令集与基于寄存器的指令集这两者之间有什么不同呢？</p><p>&emsp;&emsp;举个最简单的例子，分别使用这两种指令集计算“1+1”的结果，基于栈的指令集会是这样子的：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ico<span class="symbol">nst_1</span> </span><br><span class="line">ico<span class="symbol">nst_1</span> </span><br><span class="line">iadd </span><br><span class="line">istore_<span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中。</p><p>&emsp;&emsp;如果基于寄存器，那程序可能会是这个样子：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span> </span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>，<span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。</p><p>&emsp;&emsp;了解了基于栈的指令集与基于寄存器的指令集的区别后，读者可能会有进一步的疑问，这两套指令集谁更好一些呢？</p><p>&emsp;&emsp;应该这么说，既然两套指令集会同时并存和发展，那肯定是各有优势的，如果有一套指令集全面优于另外一套的话，就不会存在选择的问题了。</p><p>&emsp;&emsp;基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供[2]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。例如，现在32位80x86体系的处理器中提供了8个32位的寄存器，而ARM体系的CPU（在当前的手机、PDA中相当流行的一种处理器）则提供了16个32位的通用寄存器。如果使用栈架构的指令集，用户程序不会直接使用这些寄存器，就可以由虚拟机实现来自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存等）放到寄存器中以获取尽量好的性能，这样实现起来也更加简单一些。栈架构的指令集还有一些其他的优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）等。</p><p>&emsp;&emsp;栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。</p><p>&emsp;&emsp;虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接内存访问，但这也只能是优化措施而不是解决本质问题的方法。由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢。</p><h3 id="4-3-基于栈的解释器执行过程"><a href="#4-3-基于栈的解释器执行过程" class="headerlink" title="4.3 基于栈的解释器执行过程"></a><strong>4.3 基于栈的解释器执行过程</strong></h3><p>&emsp;&emsp;初步的理论知识已经讲解过了，本节准备了一段Java代码，看看在虚拟机中实际是如何执行的。前面曾经举过一个计算“1+1”的例子，这样的算术题目显然太过简单了，作者准备了四则运算的例子，请看代码清单8-16。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-16　一段简单的算术代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>; </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>; </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>; </span><br><span class="line">    <span class="keyword">return</span> (a + b) * c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从Java语言的角度来看，这段代码没有任何解释的必要，可以直接使用javap命令看看它的字节码指令，如代码清单8-17所示。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-17　一段简单的算术代码的字节码表示</span></span><br><span class="line">public int calc(); </span><br><span class="line">    Code： </span><br><span class="line">        Stack = <span class="number">2</span>，Locals = <span class="number">4</span>，Args_size = <span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>：bipush <span class="number">100</span> </span><br><span class="line">        <span class="number">2</span>：istore_1 </span><br><span class="line">        <span class="number">3</span>：sipush <span class="number">200</span> </span><br><span class="line">        <span class="number">6</span>：istore_2 </span><br><span class="line">        <span class="number">7</span>：sipush <span class="number">300</span> </span><br><span class="line">        <span class="number">10</span>：istore_3 </span><br><span class="line">        <span class="number">11</span>：iload_1 </span><br><span class="line">        <span class="number">12</span>：iload_2 </span><br><span class="line">        <span class="number">13</span>：iadd </span><br><span class="line">        <span class="number">14</span>：iload_3 </span><br><span class="line">        <span class="number">15</span>：imul </span><br><span class="line">        <span class="number">16</span>：ireturn </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;javap提示这段代码需要深度为2的操作数栈和4个Slot的局部变量空间，作者根据这些信息画了图8-5～图8-11共7张图，用它们来描述代码清单8-17执行过程中的代码、操作数栈和局部变量表的变化情况。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010165.png" alt="执行偏移地址为0的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010166.png" alt="执行偏移地址为1的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010167.png" alt="执行偏移地址为11的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010168.png" alt="执行偏移地址为12的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010169.png" alt="执行偏移地址为13的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010170.png" alt="执行偏移地址为14的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010171.png" alt="执行偏移地址为16的指令的情况"></p><p>&emsp;&emsp;上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述……更准确地说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化，例如，在HotSpot虚拟机中，有很多以“fast_”开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，而即时编译器的优化手段更加花样繁多[1]。</p><p>&emsp;&emsp;不过，我们从这段程序的执行中也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径，符合我们在前面分析的特点。</p><hr><h2 id="第五节-总结"><a href="#第五节-总结" class="headerlink" title="第五节 总结"></a><strong>第五节 总结</strong></h2><p>&emsp;&emsp;本章中，我们分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码，以及执行代码时涉及的内存结构。在第6、7、8三章中，我们针对Java程序是如何存储的、如何载入（创建）的，以及如何执行的问题把相关知识进行了讲解，第9章我们将一起看看这些理论知识在具体开发之中的经典应用。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的字节码执行引擎，包括：概述，运行时栈帧结构，方法调用，基于栈的字节码解释执行引擎（解释执行、基于栈的指令集与基于寄存器的指令集、基于栈的解释器执行过程），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制-类加载过程</title>
    <link href="http://linyishui.top/2019120801.html"/>
    <id>http://linyishui.top/2019120801.html</id>
    <published>2019-12-08T10:06:32.000Z</published>
    <updated>2020-01-10T03:11:38.330Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机类加载机制-类加载过程"><a href="#虚拟机类加载机制-类加载过程" class="headerlink" title="虚拟机类加载机制-类加载过程"></a><strong>虚拟机类加载机制-类加载过程</strong></h1><h2 id="第三节-类加载的过程"><a href="#第三节-类加载的过程" class="headerlink" title="第三节 类加载的过程"></a><strong>第三节 类加载的过程</strong></h2><p>&emsp;&emsp;接下来我们详细讲解一下Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。 </p><h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a><strong>3.1 加载</strong></h3><p>&emsp;&emsp;<strong>加载</strong>是<strong>类加载</strong>（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，虚拟机需要完成以下3件事情： </p><blockquote><ol><li>通过一个类的全限定名来<strong>获取</strong>定义此类的<strong>二进制字节流</strong>。 </li><li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong>。</li><li>在内存中<strong>生成</strong>一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。 </li></ol></blockquote><p>&emsp;&emsp;虚拟机规范的这3点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条，它没有指明二进制字节流要从一个Class文件中获取，准确地说是根本没有指明要从哪里获取、怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开放的、广阔的“舞台”，Java发展历程中，充满创造力的开发人员则在这个“舞台”上玩出了各种花样，许多举足轻重的Java技术都建立在这一基础之上，例如：</p><blockquote><ul><li><strong>从ZIP包中读取</strong>，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li><li><strong>从网络中获取</strong>，这种场景最典型的应用就是Applet。 </li><li><strong>运行时计算生成</strong>，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。 </li><li><strong>由其他文件生成</strong>，典型场景是JSP应用，即由JSP文件生成对应的Class类。 </li><li><strong>从数据库中读取</strong>，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li><li>……</li></ul></blockquote><p>&emsp;&emsp;相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中<strong>获取类的二进制字节流的动作</strong>）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。 </p><p>&emsp;&emsp;对于数组类而言，情况就有所不同，<strong>数组类本身不通过类加载器创建</strong>，它是<strong>由Java虚拟机直接创建</strong>的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为C）创建过程就遵循以下规则：</p><blockquote><ul><li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，在第四节会介绍到，<strong>一个类必须与类加载器一起确定唯一性</strong>）。 </li><li>如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。 </li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。 </li></ul></blockquote><p>&emsp;&emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，<strong>Class对象比较特殊，它虽然是对象，但是存放在方法区里面</strong>），这个对象将<strong>作为程序访问方法区中的这些类型数据的外部接口</strong>。 </p><p>&emsp;&emsp;加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a><strong>3.2 验证</strong></h3><p>&emsp;&emsp;验证是连接阶段的第一步，这一阶段的目的是为了<strong>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</strong>。 </p><p>&emsp;&emsp;Java语言本身是相对安全的语言（依然是相对于C/C++来说），使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但前面已经说过，Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生Class文件。在字节码语言层面上，上述Java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。 </p><p>&emsp;&emsp;验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分。《Java虚拟机规范（第2版）》对这个阶段的限制、指导还是比较笼统的，规范中列举了一些Class文件格式中的静态和结构化约束，如果验证到输入的字节流不符合Class文件格式的约束，虚拟机就应抛出一个java.lang.VerifyError异常或其子类异常，但具体应当检查哪些方面，如何检查，何时检查，都没有足够具体的要求和明确的说明。直到2011年发布的《Java虚拟机规范（Java SE 7版）》，大幅增加了描述验证过程的篇幅（从不到10页增加到130页），这时约束和验证规则才变得具体起来。受篇幅所限无法逐条规则去讲解，但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 </p><h4 id="3-2-1-文件格式验证"><a href="#3-2-1-文件格式验证" class="headerlink" title="3.2.1 文件格式验证"></a><strong>3.2.1 文件格式验证</strong></h4><p>&emsp;&emsp;第一阶段要<strong>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</strong>。这一阶段可能包括下面这些验证点： </p><blockquote><ul><li>是否以魔数0xCAFEBABE开头。 </li><li>主、次版本号是否在当前虚拟机处理范围之内。 </li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 </li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 </li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。 </li><li>……</li></ul></blockquote><p>&emsp;&emsp;实际上，第一阶段的验证点还远不止这些，上面这些只是从HotSpot虚拟机源码中摘抄的一小部分内容，该验证阶段的主要目的是<strong>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</strong>。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以<strong>后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流</strong>。</p><h4 id="3-2-2-元数据验证"><a href="#3-2-2-元数据验证" class="headerlink" title="3.2.2 元数据验证"></a><strong>3.2.2 元数据验证</strong></h4><p>&emsp;&emsp;第二阶段是<strong>对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求</strong>，这个阶段可能包括的验证点如下：</p><blockquote><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 </li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 </li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 </li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 </li><li>……</li></ul></blockquote><p>&emsp;&emsp;第二阶段的主要目的是<strong>对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息</strong>。 </p><h4 id="3-2-3-字节码验证"><a href="#3-2-3-字节码验证" class="headerlink" title="3.2.3 字节码验证"></a><strong>3.2.3 字节码验证</strong></h4><p>&emsp;&emsp;第三阶段是整个验证过程中最复杂的一个阶段，主要目的是<strong>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</strong>。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如： </p><blockquote><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。 </li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。 </li><li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。 </li><li>……</li></ul></blockquote><p>&emsp;&emsp;如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。这里涉及了离散数学中一个很著名的问题“Halting Problem”：通俗一点的说法就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p><p>&emsp;&emsp;由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在JDK 1.6之后的Javac编译器和Java虚拟机中进行了一项优化，给方法体的Code属性的属性表中增加了一项名为“StackMapTable”的属性，这项属性描述了方法体中所有的基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。这样<strong>将字节码验证的类型推导转变为类型检查从而节省一些时间</strong>。 </p><p>&emsp;&emsp;理论上StackMapTable属性也存在错误或被篡改的可能，所以是否有可能在恶意篡改了Code属性的同时，也生成相应的StackMapTable属性来骗过虚拟机的类型校验则是虚拟机设计者值得思考的问题。 </p><p>&emsp;&emsp;在JDK 1.6的HotSpot虚拟机中提供了-XX:-UseSplitVerifier选项来关闭这项优化，或者使用参数-XX:+FailOverToOldVerifier要求在类型校验失败的时候退回到旧的类型推导方式进行校验。而在JDK 1.7之后，对于主版本号大于50的Class文件，<strong>使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到类型推导的校验方式</strong>。 </p><h4 id="3-2-4-符号引用验证"><a href="#3-2-4-符号引用验证" class="headerlink" title="3.2.4 符号引用验证"></a><strong>3.2.4 符号引用验证</strong></h4><p>&emsp;&emsp;最后一个阶段的校验发生<strong>在虚拟机将符号引用转化为直接引用的时候</strong>，这个转化动作将在连接的第三阶段——<strong>解析阶段</strong>中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： </p><blockquote><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。 </li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 </li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 </li><li>……</li></ul></blockquote><p>&emsp;&emsp;符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。 </p><p>&emsp;&emsp;对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但<strong>不是一定必要</strong>（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么<strong>在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</strong>。</p><h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a><strong>3.3 准备</strong></h3><p>&emsp;&emsp;准备阶段是<strong>正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些<strong>变量所使用的内存都将在方法区中进行分配</strong>。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的<strong>仅包括类变量</strong>（被static修饰的变量），而不包括实例变量，<strong>实例变量将会在对象实例化时随着对象一起分配在Java堆中</strong>。其次，这里所说的初始值“通常情况”下是<strong>数据类型的零值</strong>，假设一个类变量的定义为：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。表7-1列出了Java中所有基本数据类型的零值。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/1111111111.png" alt="基本数据类型的零值"></p><p>&emsp;&emsp;上面提到，在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a><strong>3.4 解析</strong></h3><p>&emsp;&emsp;解析阶段是虚拟机<strong>将常量池内的符号引用替换为直接引用的过程</strong>，符号引用在前一章讲解Class文件格式的时候已经出现过多次，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？ </p><p>&emsp;&emsp;符号引用（Symbolic References）：<strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</strong>。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 </p><p>&emsp;&emsp;直接引用（Direct References）：<strong>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</strong>。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。 </p><p>&emsp;&emsp;虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、 invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这16个<strong>用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析</strong>。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。 </p><p>&emsp;&emsp;对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机<strong>需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功</strong>；同样的，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常。 </p><p>&emsp;&emsp;对于<strong>invokedynamic指令</strong>，上面规则则不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。因为invokedynamic指令的目的本来就是用于动态语言支持（目前仅使用Java语言不会生成这条字节码指令），它所对应的引用称为“动态调用点限定符”（Dynamic Call Site Specifier），这里“动态”的含义就是<strong>必须等到程序实际运行到这条指令的时候，解析动作才能进行</strong>。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。 </p><p>&emsp;&emsp;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型。下面将讲解前面4种引用的解析过程，对于后面3种，与JDK 1.7新增的动态语言支持息息相关，由于Java语言是一门静态类型语言，因此在没有介绍invokedynamic指令的语义之前，没有办法将它们和现在的Java语言对应上，作者将在<a href="../2019121001.html" title="Title">字节码执行引擎</a>介绍动态语言调用时一起分析讲解。 </p><h4 id="3-4-1-类或接口的解析"><a href="#3-4-1-类或接口的解析" class="headerlink" title="3.4.1 类或接口的解析"></a><strong>3.4.1 类或接口的解析</strong></h4><p>&emsp;&emsp;假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤： </p><blockquote><ol><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关 类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。 </li><li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。 </li><li>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。 </li></ol></blockquote><h4 id="3-4-2-字段解析"><a href="#3-4-2-字段解析" class="headerlink" title="3.4.2 字段解析"></a><strong>3.4.2 字段解析</strong></h4><p>&emsp;&emsp;要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。 </p><blockquote><ol><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 </li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的 父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 </li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 </li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li></ol></blockquote><p>&emsp;&emsp;如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。 </p><p>&emsp;&emsp;在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。在代码清单7-4中，如果注释了Sub类中的“public static int A = 4;”，接口与父类同时存在字段A，那编译器将提示“The field Sub.A is ambiguous”，并且拒绝编译这段代码。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-4　字段解析</span></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldResolution</span> </span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Interface0</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> <span class="keyword">extends</span> <span class="title">Interface0</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">3</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Interface2</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">4</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123; </span><br><span class="line">        System.out.println(Sub.A); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-3-类方法解析"><a href="#3-4-3-类方法解析" class="headerlink" title="3.4.3 类方法解析"></a><strong>3.4.3 类方法解析</strong></h4><p>&emsp;&emsp;类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。 </p><blockquote><ol><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。 </li><li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 </li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 </li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。 </li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。 </li></ol></blockquote><p>&emsp;&emsp;最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。 </p><h4 id="3-4-4-接口方法解析"><a href="#3-4-4-接口方法解析" class="headerlink" title="3.4.4 接口方法解析"></a><strong>3.4.4 接口方法解析</strong></h4><p>&emsp;&emsp;接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p><blockquote><ol><li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。 </li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 </li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 </li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ol></blockquote><p>&emsp;&emsp;由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。 </p><h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a><strong>3.5 初始化</strong></h3><p>&emsp;&emsp;类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。<strong>到了初始化阶段，才真正开始执行类中定义的Java程序代码</strong>（或者说是字节码）。 </p><p>&emsp;&emsp;在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞()方法的过程。我们在下文会讲解＜clinit＞()方法是怎么生成的，在这里，我们先看一下＜clinit＞()方法执行过程中一些可能会影响程序运行行为的特点和细节，这部分相对更贴近于普通的程序开发人员。 </p><p>&emsp;&emsp;＜clinit＞()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，<strong>编译器收集的顺序是由语句在源文件中出现的顺序所决定的</strong>，<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>，如代码清单7-5中的例子所示。 </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-5　非法向前引用变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">//给变量赋值可以正常编译通过 </span></span><br><span class="line">        System.<span class="keyword">out</span>.print（i）; <span class="comment">//这句编译器会提示"非法向前引用" </span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。因此在<strong>虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object</strong>。 </p><p>&emsp;&emsp;由于父类的＜clinit＞()方法先执行，也就意味着<strong>父类中定义的静态语句块要优先于子类的变量赋值操作</strong>，如在代码清单7-6中，字段B的值将会是2而不是1。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-6＜clinit＞()方法执行顺序</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123; </span><br><span class="line">        A = <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    System.out.println(Sub.B); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。 </p><p>&emsp;&emsp;接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞()方法。但接口与类不同的是，执行接口的＜clinit＞()方法不需要先执行父接口的＜clinit＞()方法。<strong>只有当父接口中定义的变量使用时，父接口才会初始化</strong>。另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞()方法。</p><p>&emsp;&emsp;虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞ ()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。代码清单7-7演示了这种场景。 </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-7　字段解析</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DeadLoopClass</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        <span class="comment">/*如果不加上这个if语句，编译器将提示"Initializer does not complete normally"并拒绝编译 */</span> </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread() + <span class="string">"init DeadLoopClass"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123; </span><br><span class="line">    Runnable script=<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread() + <span class="string">"start"</span>)；</span><br><span class="line">            DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread() + <span class="string">"run over"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下，即一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-0, 5, main]<span class="keyword">start</span> </span><br><span class="line"><span class="keyword">Thread</span>[<span class="keyword">Thread</span><span class="number">-1</span>, <span class="number">5</span>, <span class="keyword">main</span>]<span class="keyword">start</span> </span><br><span class="line"><span class="keyword">Thread</span>[<span class="keyword">Thread</span><span class="number">-0</span>, <span class="number">5</span>, <span class="keyword">main</span>]init DeadLoopClass</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的虚拟机类加载机制-类加载过程，包括：加载，验证（文件格式验证、元数据验证、字节码验证、符号引用验证），准备，解析（类或接口的解析、字段解析、类方法解析、接口方法解析），初始化等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://linyishui.top/2019120701.html"/>
    <id>http://linyishui.top/2019120701.html</id>
    <published>2019-12-07T10:04:08.000Z</published>
    <updated>2020-01-10T03:11:53.993Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a><strong>类文件结构</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p><p>&emsp;&emsp;<a href="../2019120301.html" title="Title">类文件结构</a>我们了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？这些都是本章将要讲解的内容。 </p><p>&emsp;&emsp;<strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制</strong>。 </p><p>&emsp;&emsp;与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。从最基础的Applet、JSP到相对复杂的OSGi技术，都使用了<strong>Java语言运行期类加载的特性</strong>。 </p><p>&emsp;&emsp;为了避免语言表达中可能产生的偏差，在本章正式开始之前，作者先设立两个语言上的约定：第一，在实际情况中，每个Class文件都有可能代表着Java语言中的一个类或接口，后文中直接对“类”的描述都包括了类和接口的可能性，而对于类和接口需要分开描述的场景会特别指明；第二，与前面介绍Class文件格式时的约定一致，作者本章所提到的“Class文件”并非特指某个存在于具体磁盘中的文件，这里所说的“Class文件”应当是一串二进制的字节流，无论以何种形式存在都可以。</p><hr><h2 id="第二节-类加载的时机"><a href="#第二节-类加载的时机" class="headerlink" title="第二节 类加载的时机"></a><strong>第二节 类加载的时机</strong></h2><p>&emsp;&emsp;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载</strong>（Loading）、<strong>验证</strong>（Verification）、<strong>准备</strong>（Preparation）、<strong>解析</strong>（Resolution）、<strong>初始化</strong>（Initialization）、<strong>使用</strong>（Using）和<strong>卸载</strong>（Unloading）7个阶段。其中验证、准备、解析3个 部分统称为<strong>连接</strong>（Linking），这7个阶段的发生顺序如图7-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010160.png" alt="类的生命周期"></p><p>&emsp;&emsp;图7-1中，<strong>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的</strong>，<strong>类的加载过程必须按照这种顺序按部就班地开始</strong>，而<strong>解析阶段则不一定</strong>：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的<strong>运行时绑定</strong>（也称为动态绑定或晚期绑定）。注意，这里作者写的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。 </p><p>&emsp;&emsp;什么情况下需要开始类加载过程的第一个阶段：加载？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）： </p><blockquote><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 </li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 </li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 </li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 </li><li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 </li></ol></blockquote><p>&emsp;&emsp;对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。下面举3个例子来说明何为被动引用，分别见代码清单7-1～代码清单7-3。 </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-1　被动引用的例子之一</span></span><br><span class="line">package org.fenixsoft.classloading; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示一： </span></span><br><span class="line"><span class="comment"> *    通过子类引用父类的静态字段，不会导致子类初始化 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SuperClass</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"SuperClass init!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">123</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubClass</span> <span class="title">extends</span> <span class="title">SuperClass</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"SubClass init!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NotInitialization</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(SubClass.<span class="keyword">value</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码运行之后，只会输出“SuperClass init!”，而不会输出“SubClass init!”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于Sun HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数观察到此操作会导致子类的加载。 </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-2　被动引用的例子之二</span></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *被动使用类字段演示二： </span></span><br><span class="line"><span class="comment"> *   通过数组定义来引用类，不会触发此类的初始化 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main (<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> <span class="type">SuperClass</span>[<span class="number">10</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了节省版面，这段代码复用了代码清单7-1中的SuperClass，运行之后发现没有输出“SuperClass init!”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了另外一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。 </p><p>&emsp;&emsp;这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法（准确的说越界检查不是封装在数组元素访问的类中，而是封装在数组访问的xaload、xastore字节码指令中），而C/C++直接翻译为对数组指针的移动。在Java语言中，当检查到发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-3　被动引用的例子之三</span></span><br><span class="line">package org.fenixsoft.classloading; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示三： </span></span><br><span class="line"><span class="comment"> *    常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstClass</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"ConstClass init!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final String HELLOWORLD = <span class="string">"hello world"</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NotInitialization</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(ConstClass.HELLOWORLD); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码运行之后，也没有输出“ConstClass init!”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。</p><p>&emsp;&emsp;接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：<strong>接口也有初始化过程</strong>，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“＜clinit＞()”类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：<strong>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化</strong>。 </p><hr><h2 id="第三节-类加载的过程"><a href="#第三节-类加载的过程" class="headerlink" title="第三节 类加载的过程"></a><strong>第三节 类加载的过程</strong></h2><p>&emsp;&emsp;<a href="../2019120801.html" title="Title">类加载机制-类加载过程</a></p><hr><h2 id="第四节-类加载器"><a href="#第四节-类加载器" class="headerlink" title="第四节 类加载器"></a><strong>第四节 类加载器</strong></h2><p>&emsp;&emsp;虚拟机设计团队把类加载阶段中的<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><p>&emsp;&emsp;类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，它最初是为了满足Java Applet的需求而开发出来的。虽然目前Java Applet技术基本上已经“死掉”，但类加载器却在<strong>类层次划分</strong>、<strong>OSGi</strong>（Open Service Gateway Initiative，开放服务网关协议技术是Java动态化模块化系统的一系列规范）、<strong>热部署</strong>、<strong>代码加密</strong>等领域大放异彩，成为了Java技术体系中一块重要的基石，可谓是失之桑榆，收之东隅。</p><h3 id="4-1-类与类加载器"><a href="#4-1-类与类加载器" class="headerlink" title="4.1 类与类加载器"></a><strong>4.1 类与类加载器</strong></h3><p>&emsp;&emsp;类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>&emsp;&emsp;这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果，代码清单7-8中演示了不同的类加载器对instanceof关键字运算的结果的影响。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">7</span><span class="number">-8</span>　不同的类加载器对<span class="keyword">instanceof</span>关键字运算的结果的影响</span><br><span class="line"><span class="comment">/** *类加载器与instanceof关键字演示 * *@author zzm */</span> <span class="keyword">public</span> class ClassLoaderTest&#123; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（<span class="keyword">String</span>[]args）<span class="keyword">throws</span> Exception&#123; ClassLoader myLoader=<span class="keyword">new</span> ClassLoader（）&#123; @Override <span class="keyword">public</span> Class＜?＞loadClass（<span class="keyword">String</span> name）<span class="keyword">throws</span> ClassNotFoundException&#123; <span class="keyword">try</span>&#123; <span class="keyword">String</span> fileName=name.substring（name.lastIndexOf（<span class="string">"."</span>）+<span class="number">1</span>）+<span class="string">".class"</span>； InputStream is=getClass（）.getResourceAsStream（fileName）； <span class="keyword">if</span>（is==<span class="keyword">null</span>）&#123; <span class="keyword">return</span> <span class="keyword">super</span>.loadClass（name）； &#125; <span class="built_in">byte</span>[]b=<span class="keyword">new</span> <span class="built_in">byte</span>[is.available（）]； is.read（b）； <span class="keyword">return</span> defineClass（name,b，<span class="number">0</span>，b.length）； &#125;<span class="keyword">catch</span>（IOException e）&#123; <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException（name）； &#125; &#125; &#125;； <span class="keyword">Object</span> obj=myLoader.loadClass（<span class="string">"org.fenixsoft.classloading.ClassLoaderTest"</span>）.newInstance（）； System.out.<span class="built_in">println</span>（obj.getClass（））； System.out.<span class="built_in">println</span>（obj <span class="keyword">instanceof</span> org.fenixsoft.classloading.ClassLoaderTest）； &#125; &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class org<span class="selector-class">.fenixsoft</span><span class="selector-class">.classloading</span><span class="selector-class">.ClassLoaderTest</span> false</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单7-8中构造了一个简单的类加载器，尽管很简单，但是对于这个演示来说还是够用了。它可以加载与自己在同一路径下的Class文件。我们使用这个类加载器去加载了一个名为“org.fenixsoft.classloading.ClassLoaderTest”的类，并实例化了这个类的对象。两行输出结果中，从第一句可以看出，这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化出来的对象，但从第二句可以发现，这个对象与类org.fenixsoft.classloading.ClassLoaderTest做所属类型检查的时候却返回了false，这是因为虚拟机中存在了两个ClassLoaderTest类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然为false。</p><h3 id="4-2-双亲委派模型"><a href="#4-2-双亲委派模型" class="headerlink" title="4.2 双亲委派模型"></a><strong>4.2 双亲委派模型</strong></h3><p>&emsp;&emsp;从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现[1]，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p><p>&emsp;&emsp;从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。</p><p>&emsp;&emsp;启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如代码清单7-9所示为java.lang.ClassLoader.getClassLoader（）方法的代码片段。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">7</span>-<span class="number">9</span>　ClassLoader.getClassLoader（）方法的代码片段</span><br><span class="line">/** Returns the class loader <span class="keyword">for</span> the class.Some implementations may use null <span class="keyword">to</span> represent the bootstrap class loader.This method will <span class="keyword">return</span> null in such implementations <span class="keyword">if</span> this class was loaded by the bootstrap class loader. */ public ClassLoader getClassLoader（）&#123; ClassLoader <span class="keyword">cl</span>=getClassLoader0（）； <span class="keyword">if</span>（<span class="keyword">cl</span>==null） <span class="keyword">return</span> null； SecurityManager <span class="keyword">sm</span>=System.getSecurityManager（）； <span class="keyword">if</span>（<span class="keyword">sm</span>！=null）&#123; ClassLoader <span class="keyword">ccl</span>=ClassLoader.getCallerClassLoader（）； <span class="keyword">if</span>（<span class="keyword">ccl</span>！=null＆＆<span class="keyword">ccl</span>！=<span class="keyword">cl</span>＆＆！<span class="keyword">cl</span>.isAncestor（<span class="keyword">ccl</span>））&#123; <span class="keyword">sm</span>.checkPermission（SecurityConstants.GET_CLASSLOADER_PERMISSION）； &#125; &#125; <span class="keyword">return</span> <span class="keyword">cl</span>； &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher $ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p><p>&emsp;&emsp;应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>&emsp;&emsp;我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图7-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/1111111111.png" alt="类加载器双亲委派模型 "></p><p>&emsp;&emsp;图7-2中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p><p>&emsp;&emsp;类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p><p>&emsp;&emsp;双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p>&emsp;&emsp;使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果读者有兴趣的话，可以尝试去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行[2]。</p><p>&emsp;&emsp;双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass（）方法之中，如代码清单7-10所示，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass（）方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">7</span>-<span class="number">10</span>　双亲委派模型的实现</span><br><span class="line"><span class="keyword">protected</span> synchronized <span class="keyword">Class</span>＜?＞loadClass（String <span class="keyword">name</span>,boolean resolve）throws ClassNotFoundException &#123; //首先，检查请求的类是否已经被加载过了 <span class="keyword">Class</span> c=findLoadedClass（<span class="keyword">name</span>）； <span class="keyword">if</span>（c==null）&#123; try&#123; <span class="keyword">if</span>（parent！=null）&#123; c=parent.loadClass（<span class="keyword">name</span>,false）； &#125;<span class="keyword">else</span>&#123; c=findBootstrapClassOrNull（<span class="keyword">name</span>）； &#125; &#125;catch（ClassNotFoundException e）&#123; //如果父类加载器抛出ClassNotFoundException //说明父类加载器无法完成加载请求 &#125; <span class="keyword">if</span>（c==null）&#123; //在父类加载器无法加载的时候 //再调用本身的findClass方法来进行类加载 c=findClass（<span class="keyword">name</span>）； &#125; &#125; <span class="keyword">if</span>（resolve）&#123; resolveClass（c）； &#125; <span class="keyword">return</span> c； &#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-破坏双亲委派模型"><a href="#4-3-破坏双亲委派模型" class="headerlink" title="4.3 破坏双亲委派模型"></a><strong>4.3 破坏双亲委派模型</strong></h3><p>&emsp;&emsp;上文提到过双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。在Java的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过3较大规模的“被破坏”情况。</p><p>&emsp;&emsp;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2发布之前。由于双亲委派模型在JDK1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass（），在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass（）方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal（），而这个方法的唯一逻辑就是去调用自己的loadClass（）。</p><p>&emsp;&emsp;上一节我们已经看过loadClass（）方法的代码，双亲委派的具体逻辑就实现在这个方法之中，JDK1.2之后已不提倡用户再去覆盖loadClass（）方法，而应当把自己的类加载逻辑写到findClass（）方法中，在loadClass（）方法的逻辑里如果父类加载失败，则会调用自己的findClass（）方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p><p>&emsp;&emsp;双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？</p><p>&emsp;&emsp;这并非是不可能的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI,Service Provider Interface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？</p><p>&emsp;&emsp;为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoaser（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>&emsp;&emsp;有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p><p>&emsp;&emsp;双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U盘，<br>不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人计算机来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。</p><p>&emsp;&emsp;Sun公司所提出的JSR-294[1]、JSR-277[2]规范在与JCP组织的模块化规范之争中落败给JSR291（即OSGi R4.2），虽然Sun不甘失去Java模块化的主导权，独立在发展Jigsaw项目，但目前OSGi已经成为了业界“事实上”的Java模块化标准[3]，而OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p><p>&emsp;&emsp;在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><blockquote><ol><li>将以java.*开头的类委派给父类加载器加载。</li><li>否则，将委派列表名单内的类委派给父类加载器加载。</li><li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li><li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li><li>否则，类查找失败。</li></ol></blockquote><p>&emsp;&emsp;上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p><p>&emsp;&emsp;作者虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可认为是一种创新。正如OSGi中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在Java程序员中基本有一个共识：OSGi中对类加载器的使用是很值得学习的，弄懂了OSGi的实现，就可以算是掌握了类加载器的精髓。</p><hr><h2 id="第五节-总结"><a href="#第五节-总结" class="headerlink" title="第五节 总结"></a><strong>第五节 总结</strong></h2><p>&emsp;&emsp;本章介绍了类加载过程的“加载”、“验证”、“准备”、“解析”和“初始化”5个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。</p><p>&emsp;&emsp;经过第6和第7两章的讲解，相信读者已经对如何在Class文件中定义类，如何将类加载到虚拟机中这两个问题有了比较系统的了解，第8章我们将一起来看看虚拟机如何执行定义在Class文件里的字节码。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的虚拟机类加载机制，包括：概述，类加载的时机，类加载的过程，类加载器（类与类加载器、双亲委派模型、破坏双亲委派模型），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构-字节码指令简介</title>
    <link href="http://linyishui.top/2019120501.html"/>
    <id>http://linyishui.top/2019120501.html</id>
    <published>2019-12-05T09:59:50.000Z</published>
    <updated>2020-01-10T03:12:04.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类文件结构-字节码指令简介"><a href="#类文件结构-字节码指令简介" class="headerlink" title="类文件结构-字节码指令简介"></a><strong>类文件结构-字节码指令简介</strong></h1><h2 id="第四节-字节码指令简介"><a href="#第四节-字节码指令简介" class="headerlink" title="第四节 字节码指令简介"></a><strong>第四节 字节码指令简介</strong></h2><p>&emsp;&emsp;Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为<strong>操作码</strong>，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为<strong>操作数</strong>，Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构（这两种架构的区别和影响将在<a href="../2019121001.html" title="Title">字节码执行引擎</a>中探讨），所以<strong>大多数的指令都不包含操作数，只有一个操作码</strong>。 </p><p>&emsp;&emsp;字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机<strong>操作码的长度为一个字节</strong>（即0～255），这意味着指令集的操作码总数不可能超过256条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个16位长度的无符号整数使用两个无符号字节存储起来（将它们命名为byte1和byte2），那它们的值应该是这样的：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( byte1 &lt;&lt; <span class="number">8</span> ) <span class="string">| byte2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种操作在某种程度上会导致解释执行字节码时损失一些性能。但这样做的优势也非常明显，放弃了操作数长度对齐，就意味着可以省略很多填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效率的设计是由Java语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至今。 </p><p>&emsp;&emsp;如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效地工作：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>;</span><br><span class="line">    根据PC寄存器的指示位置, 从字节码流中取出操作码; </span><br><span class="line">    <span class="keyword">if</span><span class="comment">(字节码存在操作数)</span> 从字节码流中取出操作数; </span><br><span class="line">    执行操作码所定义的操作; </span><br><span class="line">&#125; <span class="keyword">while</span> <span class="comment">(字节码流长度 &gt; 0)</span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-字节码与数据类型"><a href="#4-1-字节码与数据类型" class="headerlink" title="4.1 字节码与数据类型"></a><strong>4.1 字节码与数据类型</strong></h3><p>&emsp;&emsp;在Java虚拟机的指令集中，<strong>大多数的指令都包含了其操作所对应的数据类型信息</strong>。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p><p>&emsp;&emsp;对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。</p><p>&emsp;&emsp;由于Java虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那指令的数量恐怕就会超出一个字节所能表示的数量范围了。因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会故意被设计成非完全独立的（Java虚拟机规范中把这种特性称为“Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。 </p><p>&emsp;&emsp;表6-31列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。例如，load指令有操作int类型的iload，但是没有操作byte类型的同类指令。 </p><p>&emsp;&emsp;注意，从表6-31中可以看出，大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。<strong>编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据</strong>，<strong>将boolean和char类型数据零位扩展（ZeroExtend）为相应的int类型数据</strong>。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，<strong>大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型</strong>（Computational Type）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010157.png" alt="Java虚拟机指令集所支持的数据类型"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010158.png" alt="Java虚拟机指令集所支持的数据类型"></p><p>&emsp;&emsp;在本章中，受篇幅所限，无法对字节码指令集中每条指令进行逐一讲解，但阅读字节码作为了解Java虚拟机的基础技能，是一项应当熟练掌握的能力。作者将字节码操作按用途大致分为9类，按照分类来为读者概略介绍一下这些指令的用法。</p><h3 id="4-2-加载和存储指令"><a href="#4-2-加载和存储指令" class="headerlink" title="4.2 加载和存储指令"></a><strong>4.2 加载和存储指令</strong></h3><p>&emsp;&emsp;加载和存储指令用于<strong>将数据在栈帧中的局部变量表和操作数栈之间来回传输</strong>，这类指令包括如下内容。 </p><blockquote><ul><li>将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_ ＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。 </li><li>将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、 fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。 </li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、 iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。 </li><li>扩充局部变量表的访问索引的指令：wide。 </li></ul></blockquote><p>&emsp;&emsp;存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。 </p><p>&emsp;&emsp;上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_＜n＞），这些指令助记符实际上是代表了一组指令（例如iload_＜n＞，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这若干组特殊指令来说，它们省略掉了显式的操作数，不需要进行取操作数的动作，实际上操作数就隐含在指令中。除了这点之外，它们的语义与原生的通用指令完全一致（例如iload_0的语义与操作数为0时的iload指令语义完全一致）。这种指令表示方法在本书以及《Java虚拟机规范》中都是通用的。</p><h3 id="4-3-运算指令"><a href="#4-3-运算指令" class="headerlink" title="4.3 运算指令"></a><strong>4.3 运算指令</strong></h3><p>&emsp;&emsp;运算或算术指令用于<strong>对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</strong>。大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、short、char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现，所有的算术指令如下。 </p><blockquote><ul><li>加法指令：iadd、ladd、fadd、dadd。 </li><li>减法指令：isub、lsub、fsub、dsub。 </li><li>乘法指令：imul、lmul、fmul、dmul。 </li><li>除法指令：idiv、ldiv、fdiv、ddiv。 </li><li>求余指令：irem、lrem、frem、drem。 </li><li>取反指令：ineg、lneg、fneg、dneg。 </li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr。</li><li>按位或指令：ior、lor。 </li><li>按位与指令：iand、land。 </li><li>按位异或指令：ixor、lxor。 </li><li>局部变量自增指令：iinc。 </li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。 </li></ul></blockquote><p>&emsp;&emsp;Java虚拟机的指令集直接支持了在《Java语言规范》中描述的各种对整数及浮点数操作（参见《Java语言规范（第3版）》中的4.2.2节和4.2.4节）的语义。数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象，对于程序员来说是很容易理解的，但其实Java虚拟机规范没有明确定义过整型数据溢出的具体运算结果，仅规定了在处理整型数据时，只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，其余任何整型数运算场景都不应该抛出运行时异常。 </p><p>&emsp;&emsp;Java虚拟机规范要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754规范中所规定的行为和限制。也就是说，Java虚拟机必须完全支持IEEE 754中定义的非正规浮点数值（Denormalized Floating-Point Numbers）和逐级下溢（Gradual Underflow）的运算规则。这些特征将会使某些数值算法处理起来变得相对容易一些。</p><p>&emsp;&emsp;Java虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式也是IEEE 754规范中的默认舍入模式，称为<strong>向最接近数舍入模式</strong>。</p><p>&emsp;&emsp;在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的<strong>向零舍入模式</strong>，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。</p><p>&emsp;&emsp;另外，Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一种运算信号），当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</p><p>&emsp;&emsp;在对long类型数值进行比较时，虚拟机采用带符号的比较方式，而对浮点数值进行比较时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（Nonsignaling Comparisons）方式。</p><h3 id="4-4-类型转换指令"><a href="#4-4-类型转换指令" class="headerlink" title="4.4 类型转换指令"></a><strong>4.4 类型转换指令</strong></h3><p>&emsp;&emsp;类型转换指令可以<strong>将两种不同的数值类型进行相互转换</strong>，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>&emsp;&emsp;Java虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的<strong>宽化类型转换</strong>（Widening Numeric Conversions，即小范围类型向大范围类型的安全转换）： </p><blockquote><ul><li>int类型到long、float或者double类型。 </li><li>long类型到float、double类型。 </li><li>float类型到double类型。</li></ul></blockquote><p>&emsp;&emsp;相对的，处理<strong>窄化类型转换</strong>（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。 </p><p>&emsp;&emsp;在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单地丢弃除最低位N个字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N个字节的首位了。 </p><p>&emsp;&emsp;在将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下转换规则： </p><blockquote><ul><li>如果浮点值是NaN，那转换结果就是int或long类型的0。 </li><li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long）的表示范围之内，那转换结果就是v。 </li><li>否则，将根据v的符号，转换为T所能表示的最大或者最小正数。 </li></ul></blockquote><p>&emsp;&emsp;从double类型到float类型的窄化转换过程与IEEE 754中定义的一致，通过IEEE 754向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。如果转换结果的绝对值太小而无法使用float来表示的话，将返回float类型的正负零。如果转换结果的绝对值太大而无法使用float来表示的话，将返回float类型的正负无穷大，对于double类型的NaN值将按规定转换为float类型的NaN值。 </p><p>&emsp;&emsp;尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p><h3 id="4-5-对象创建与访问指令"><a href="#4-5-对象创建与访问指令" class="headerlink" title="4.5 对象创建与访问指令"></a><strong>4.5 对象创建与访问指令</strong></h3><p>&emsp;&emsp;虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在第7章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下。 </p><blockquote><ul><li>创建类实例的指令：new。</li><li>创建数组的指令：newarray、anewarray、multianewarray。 </li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic。 </li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、 faload、daload、aaload。 </li><li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、 fastore、dastore、aastore。 </li><li>取数组长度的指令：arraylength。</li><li>检查类实例类型的指令：instanceof、checkcast。</li></ul></blockquote><h3 id="4-6-操作数栈管理指令"><a href="#4-6-操作数栈管理指令" class="headerlink" title="4.6 操作数栈管理指令"></a><strong>4.6 操作数栈管理指令</strong></h3><p>&emsp;&emsp;如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括： </p><blockquote><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2。</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、 dup_x1、dup2_x1、dup_x2、dup2_x2。</li><li>将栈最顶端的两个数值互换：swap。</li></ul></blockquote><h3 id="4-7-控制转移指令"><a href="#4-7-控制转移指令" class="headerlink" title="4.7 控制转移指令"></a><strong>4.7 控制转移指令</strong></h3><p>&emsp;&emsp;控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下。 </p><blockquote><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、 if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。 </li><li>复合条件分支：tableswitch、lookupswitch。 </li><li>无条件分支：goto、goto_w、jsr、jsr_w、ret。</li></ul></blockquote><p>&emsp;&emsp;在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个实体值是否null，也有专门的指令用来检测null值。 </p><p>&emsp;&emsp;与前面算术运算时的规则一致，对于boolean类型、byte类型、char类型和short类型的条件分支比较操作，都是使用int类型的比较指令来完成，而对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，见4.3节），运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。由于各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便完善就显得尤为重要，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p><h3 id="4-8-方法调用和返回指令"><a href="#4-8-方法调用和返回指令" class="headerlink" title="4.8 方法调用和返回指令"></a><strong>4.8 方法调用和返回指令</strong></h3><p>&emsp;&emsp;方法调用（分派、执行过程）将在<a href="../2019121001.html" title="Title">字节码执行引擎</a>具体讲解，这里仅列举以下5条用于方法调用的指令。 </p><blockquote><ul><li>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。 </li><li>invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。 </li><li>invokestatic指令用于调用类方法（static方法）。 </li><li>invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul></blockquote><p>&emsp;&emsp;方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p><h3 id="4-9-异常处理指令"><a href="#4-9-异常处理指令" class="headerlink" title="4.9 异常处理指令"></a><strong>4.9 异常处理指令</strong></h3><p>&emsp;&emsp;在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在前面介绍的整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。 </p><p>&emsp;&emsp;而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成的。</p><h3 id="4-10-同步指令"><a href="#4-10-同步指令" class="headerlink" title="4.10 同步指令"></a><strong>4.10 同步指令</strong></h3><p>&emsp;&emsp;Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用<strong>管程</strong>（Monitor）来支持的。 </p><p>&emsp;&emsp;<strong>方法级的同步是隐式的</strong>，即<strong>无须通过字节码指令来控制</strong>，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。 </p><p>&emsp;&emsp;同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，譬如代码清单6-6中所示的代码。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单6-6　代码同步演示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onlyMe</span> <span class="params">(Foo f)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">        doSomething(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译后，这段代码生成的字节码序列如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Method void onlyMe (Foo) </span><br><span class="line"><span class="number">0</span> aload_1                            <span class="comment">//将对象f入栈 </span></span><br><span class="line"><span class="number">1</span> dup                                <span class="comment">//复制栈顶元素（即f的引用） </span></span><br><span class="line"><span class="number">2</span> astore_2                           <span class="comment">//将栈顶元素存储到局部变量表Slot 2中 </span></span><br><span class="line"><span class="number">3</span> monitorenter                       <span class="comment">//以栈顶元素（即f）作为锁，开始同步 </span></span><br><span class="line"><span class="number">4</span> aload_0                            <span class="comment">//将局部变量Slot 0（即this指针）的元素入栈 </span></span><br><span class="line"><span class="number">5</span> invokevirtual <span class="meta">#5                   <span class="comment">//调用doSomething（）方法 </span></span></span><br><span class="line"><span class="number">8</span> aload_2                            <span class="comment">//将局部变量Slow 2的元素（即f）入栈 </span></span><br><span class="line"><span class="number">9</span> monitorexit                        <span class="comment">//退出同步 </span></span><br><span class="line"><span class="number">10</span> <span class="keyword">goto</span> <span class="number">18</span>                           <span class="comment">//方法正常结束，跳转到18返回 </span></span><br><span class="line"><span class="number">13</span> astore_3                          <span class="comment">//从这步开始是异常路径，见下面异常表的Taget 13 </span></span><br><span class="line"><span class="number">14</span> aload_2                           <span class="comment">//将局部变量Slow 2的元素（即f）入栈 </span></span><br><span class="line"><span class="number">15</span> monitorexit                       <span class="comment">//退出同步 </span></span><br><span class="line"><span class="number">16</span> aload_3                           <span class="comment">//将局部变量Slow 3的元素（即异常对象）入栈 </span></span><br><span class="line"><span class="number">17</span> athrow                            <span class="comment">//把异常对象重新抛出给onlyMe（）方法的调用者 </span></span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span>                            <span class="comment">//方法正常返回 </span></span><br><span class="line"></span><br><span class="line">Exception table: </span><br><span class="line">FromTo Target <span class="built_in">Type</span> </span><br><span class="line"><span class="number">4</span>      <span class="number">10</span>     <span class="number">13</span> any </span><br><span class="line"><span class="number">13</span>     <span class="number">16</span>     <span class="number">13</span> any</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p><p>&emsp;&emsp;从代码清单6-6的字节码序列中可以看到，为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的类文件结构-字节码指令简介，包括：字节码与数据类型，加载和存储指令，运算指令，类型转换指令，对象创建与访问指令，操作数栈管理指令，控制转移指令，方法调用和返回指令，异常处理指令，同步指令等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构-Class类文件的结构</title>
    <link href="http://linyishui.top/2019120401.html"/>
    <id>http://linyishui.top/2019120401.html</id>
    <published>2019-12-04T09:59:44.000Z</published>
    <updated>2020-01-10T03:12:08.802Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类文件结构-Class类文件的结构"><a href="#类文件结构-Class类文件的结构" class="headerlink" title="类文件结构-Class类文件的结构"></a><strong>类文件结构-Class类文件的结构</strong></h1><h2 id="第三节-Class类文件的结构"><a href="#第三节-Class类文件的结构" class="headerlink" title="第三节 Class类文件的结构"></a><strong>第三节 Class类文件的结构</strong></h2><p>&emsp;&emsp;解析Class文件的数据结构是本章的最主要内容。Class文件是一组以<strong>8位字节</strong>为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间<strong>没有添加任何分隔符</strong>，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>&emsp;&emsp;根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>，后面的解析都要以这两种数据类型为基础，所以这里要先讲明白这两个概念。</p><p>&emsp;&emsp;无符号数属于基本的数据类型，以<strong>u1、u2、u4、u8</strong>来分别代表1个字节、2个字节、 4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值，或者按照UTF-8编码构成字符串值。</p><p>&emsp;&emsp;表是<strong>由多个无符号数或其他表作为数据项构成</strong>的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由表6-1所示的数据项构成。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010115.png" alt="Class文件格式"></p><p>&emsp;&emsp;无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的<strong>容量计数器</strong>加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为<strong>某一类型的集合</strong>。</p><p>&emsp;&emsp;Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在表6-1中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。接下来我们将一起看看这个表中各个数据项的具体含义。</p><h3 id="3-1-魔数与Class文件的版本"><a href="#3-1-魔数与Class文件的版本" class="headerlink" title="3.1 魔数与Class文件的版本"></a><strong>3.1 魔数与Class文件的版本</strong></h3><p>&emsp;&emsp;每个Class文件的头4个字节称为<strong>魔数</strong>（Magic Number），它的唯一作用是<strong>用于确定这个文件是否为一个能被虚拟机接受的Class文件</strong>。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以很随意地被改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆即可。Class文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？），这个魔数值在Java还被称做“Oak”语言的时候（大约是1991年前后）就已经确定下来了。它还有一段很有趣的历史，据Java开发小组最初的关键成员Patrick Naughton所说：“我们一直在寻找一些好玩的、容易记忆的东西，选择0xCAFEBABE是因为它象征着著名咖啡品牌Peet’s Coffee中深受欢迎的Baristas咖啡”，这个魔数似乎也预示着日后“Java”这个名称的出现。</p><p>&emsp;&emsp;紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是<strong>次版本号</strong>（Minor Version），第7个和第8个字节是<strong>主版本号</strong>（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生变化。JDK1.1能支持版本号为45.0～45.65535的Class，无法执行版本号为46.0以上的 Class，而JDK 1.2则能支持45.0～46.65535的Class文件。现在，最新的JDK版本为1.7，可生成的Class文件主版本号的最大值为51.0。</p><p>&emsp;&emsp;为了讲解方便，作者准备了一段最简单的Java代码（如代码清单6-1所示）本章后面的讲解都将以这段小程序使用JDK 1.6编译输出的Class文件为基础来讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.clazz; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;图6-2显示的是使用十六进制编辑器WinHex打开这个Class文件的结果，可以清楚地看见开头4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为0x0000，而主版本号的值为0x0032，也即是十进制的50，该版本号说明这个文件是可以被JDK 1.6或以上版本虚拟机执行的Class文件。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010116.png" alt="Java Class文件的结构"></p><p>&emsp;&emsp;表6-2列出了从JDK 1.1到JDK 1.7，主流JDK版本编译器输出的默认和可支持的Class文件版本号。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010117.png" alt="Class文件版本号"></p><h3 id="3-2-常量池"><a href="#3-2-常量池" class="headerlink" title="3.2 常量池"></a><strong>3.2 常量池</strong></h3><p>&emsp;&emsp;紧接着主次版本号之后的是<strong>常量池入口</strong>，常量池可以理解为<strong>Class文件之中的资源仓库</strong>，它是<strong>Class文件结构中与其他项目关联最多的数据类型</strong>，也是<strong>占用Class文件空间最大的数据项目之一</strong>，同时它还是在<strong>Class文件中第一个出现的表类型数据项目</strong>。</p><p>&emsp;&emsp;由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表<strong>常量池容量计数值</strong>（constant_pool_count）。与Java中语言习惯不一样的是，<strong>这个容量计数是从1而不是0开始的</strong>，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。在Class文件格式规范制定之时，<strong>设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示</strong>。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010118.png" alt="常量池结构"></p><p>&emsp;&emsp;常量池中主要存放两大类常量：<strong>字面量</strong>（Literal）和<strong>符号引用</strong>（Symbolic References）。字面量比较<strong>接近于Java语言层面的常量概念</strong>，如文本字符串、声明为final的常量值等。而符号引用则<strong>属于编译原理方面的概念</strong>，包括了下面三类常量： </p><blockquote><ul><li>类和接口的全限定名（Fully Qualified Name） </li><li>字段的名称和描述符（Descriptor） </li><li>方法的名称和描述符</li></ul></blockquote><p>&emsp;&emsp;Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，<strong>在Class文件中不会保存各个方法、字段的最终内存布局信息</strong>，因此<strong>这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用</strong>。<strong>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</strong>。关于类的创建和动态连接的内容，在下一章介绍虚拟机类加载过程时再进行详细讲解。 </p><p>&emsp;&emsp;常量池中每一项常量都是一个表，在JDK 1.7之前共有11种结构各不相同的表结构数据，在JDK 1.7中为了更好地支持动态语言调用，又额外增加了3种（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info和CONSTANT_InvokeDynamic_info，本章不会涉及这3种新增的类型，在<a href="../2019121001.html" title="Title">字节码执行引擎</a>介绍字节码执行和方法调用时，将会详细讲解）。 </p><p>&emsp;&emsp;这14种表都有一个共同的特点，就是<strong>表开始的第一位是一个u1类型的标志位</strong>（tag，取值见表6-3中标志列），<strong>代表当前这个常量属于哪种常量类型</strong>。这14种常量类型所代表的具体含义见表6-3。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010119.png" alt="常量池的项目类型"></p><p>&emsp;&emsp;之所以说常量池是最烦琐的数据，是因为这14种常量类型各自均有自己的结构。回头看看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表6-3的标志列发现这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的符号引用。CONSTANT_Class_info的结构比较简单，见表6-4。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010120.png" alt="CONSTANT_Class_info的结构"></p><p>&emsp;&emsp;tag是标志位，上面已经讲过了，它用于区分常量类型；<strong>name_index是一个索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名</strong>，这里name_index值（偏移地址：0x0000000B）为0x0002，也即是指向了常量池中的第二项常量。继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。CONSTANT_Utf8_info类型的结构见表6-5。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010121.png" alt="CONSTANT_Utf8_info型常量的结构"></p><p>&emsp;&emsp;length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是：<strong>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示</strong>。 </p><p>&emsp;&emsp;顺便提一下，<strong>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度</strong>。而这里的<strong>最大长度就是length的最大值，既u2类型能表达的最大值65535</strong>。<strong>所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译</strong>。 </p><p>&emsp;&emsp;本例中这个字符串的length值（偏移地址：0x0000000E）为0x001D，也就是长29字节，往后29字节正好都在1～127的ASCII码范围以内，内容为“org/fenixsoft/clazz/TestClass”，有兴趣的读者可以自己逐个字节换算一下，换算结果如图6-4选中的部分所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010122.png" alt="常量池UTF-8字符串结构"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--以上分析过程</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  A  B  C  D  E  F</span><br><span class="line">CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span> <span class="number">00</span> <span class="number">16</span> <span class="number">07</span> <span class="number">00</span> <span class="number">02</span> <span class="number">01</span> <span class="number">00</span> <span class="number">1</span>D</span><br><span class="line"><span class="number">6</span>F <span class="number">72</span> <span class="number">67</span> <span class="number">2</span>F <span class="number">66</span> <span class="number">65</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">78</span> <span class="number">73</span> <span class="number">6</span>F <span class="number">66</span> <span class="number">74</span> <span class="number">2</span>F <span class="number">63</span> <span class="number">6</span>C</span><br><span class="line"><span class="number">61</span> <span class="number">7</span>A <span class="number">7</span>A <span class="number">2</span>F <span class="number">54</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">07</span> <span class="number">00</span> <span class="number">04</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">cp_info</span><br><span class="line"><span class="number">07</span> tag=CONSTANT_Class_info</span><br><span class="line"><span class="number">00</span> <span class="number">02</span> name_index=<span class="number">0x0000000D</span>指向了常量池中的第二项常量<span class="number">01</span></span><br><span class="line"><span class="number">01</span> tag=CONSTANT_Utf8_info</span><br><span class="line"><span class="number">00</span> <span class="number">1</span>D length=<span class="number">29</span></span><br><span class="line"><span class="number">6</span>F <span class="number">72</span> <span class="number">67</span> <span class="number">2</span>F <span class="number">66</span> <span class="number">65</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">78</span> <span class="number">73</span> <span class="number">6</span>F <span class="number">66</span> <span class="number">74</span> <span class="number">2</span>F <span class="number">63</span> <span class="number">6</span>C</span><br><span class="line"><span class="number">61</span> <span class="number">7</span>A <span class="number">7</span>A <span class="number">2</span>F <span class="number">54</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> bytes=org/fenixsoft/clazz/TestClass</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到此为止，我们分析了TestClass.class常量池中21个常量中的两个，其余的19个常量都可以通过类似的方法计算出来。为了避免计算过程占用过多的版面，后续的19个常量的计算过程可以借助计算机来帮我们完成。在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：<strong>javap</strong>，代码清单6-2中列出了使用javap工具的-verbose参数输出的TestClass.class文件字节码内容（此清单中省略了常量池以外的信息）。前面我们曾经提到过，Class文件中还有很多数据项都要引用常量池中的常量，所以代码清单6-2中的内容在后续的讲解过程中还要经常使用到。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">6</span>-<span class="number">2</span>　使用Javap命令输出常量表</span><br><span class="line">C：<span class="string">\&gt;javap-verbose</span> TestClass </span><br><span class="line">Compiled <span class="keyword">from</span><span class="string">"TestClass.java"</span> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">clazz</span>.<span class="title">TestClass</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> </span></span><br><span class="line">        SourceFile:<span class="string">"TestClass.java"</span> </span><br><span class="line">        minor version:<span class="number">0</span></span><br><span class="line">        major version:<span class="number">50</span> </span><br><span class="line">        Constant pool: </span><br><span class="line">    <span class="keyword">const</span><span class="comment">#1 = class           #2;           //org/fenixsoft/clazz/TestClass </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#2 = Asciz           org/fenixsoft/clazz/TestClass; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#3 = class           #4;           //java/lang/Object </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#4 = Asciz           java/lang/Object; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#5 = Asciz           m; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#6 = Asciz           I; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#7 = Asciz           &lt;init&gt;; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#8 = Asciz           ()V; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#9 = Asciz           Code; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#10 = Method         #3.#11;       //java/lang/Object."&lt;init&gt;":()V </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#11 = NameAndType    #7:#8;       //"&lt;init&gt;":()V </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#12 = Asciz          LineNumberTable; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#13 = Asciz          LocalVariableTable; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#14 = Asciz          this; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#15 = Asciz          Lorg/fenixsoft/clazz/TestClass; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#16 = Asciz          inc; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#17 = Asciz          ()I; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#18 = Field          #1.#19;       //org/fenixsoft/clazz/TestClass.m:I </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#19 = NameAndType    #5:#6;       //m:I </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#20 = Asciz          SourceFile; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#21 = Asciz          TestClass.java;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从代码清单6-2中可以看出，计算机已经帮我们把整个常量池的21项常量都计算了出来，并且第1、2项常量的计算结果与我们手工计算的结果一致。仔细看一下会发现，其中有一些常量似乎从来没有在代码中出现过，如“I”、“V”、“＜init＞”、“LineNumberTable”、 “LocalVariableTable”等，这些看起来在代码任何一处都没有出现过的常量是哪里来的呢？ </p><p>&emsp;&emsp;这部分自动生成的常量的确没有在Java代码里面直接出现过，但它们会被后面即将讲到的<strong>字段表</strong>（field_info）、<strong>方法表</strong>（method_info）、<strong>属性表</strong>（attribute_info）引用到，它们会用来描述一些不方便使用“固定字节”进行表达的内容。譬如描述方法的返回值是什么？有几个参数？每个参数的类型是什么？因为Java中的“类”是无穷无尽的，无法通过简单的无符号字节来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达。这部分内容将在后面进一步阐述。最后，作者将这14种常量项的结构定义总结为表6-6以供读者参考。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010123.png" alt="常量池中的11种数据类型的结构总表"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010124.png" alt="常量池中的11种数据类型的结构总表-续"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010159.png" alt="常量池中的11种数据类型的结构总表-续"></p><h3 id="3-3-访问标志"><a href="#3-3-访问标志" class="headerlink" title="3.3 访问标志"></a><strong>3.3 访问标志</strong></h3><p>&emsp;&emsp;在常量池结束之后，紧接着的2个字节代表<strong>访问标志</strong>（access_flags），这个标志<strong>用于识别一些类或接口层次的访问信息</strong>，包括：</p><blockquote><ul><li>这个Class是类还是接口；</li><li>是否定义为public类型；</li><li>是否定义为abstract类型；</li><li>如果是类的话，是否被声明为final，等等。</li></ul></blockquote><p>&emsp;&emsp;具体的标志位及标志的含义见表6-7。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010125.png" alt="访问标志"></p><p>&emsp;&emsp;access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求一律为0。以代码清单6-1中的代码为例，TestClass是一个普通Java类，不是接口、枚举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM这6个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。从图6-5中可以看出，access_flags标志（偏移地址：0x000000EF）的确为0x0021。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010126.png" alt="access_flags标志"></p><h3 id="3-4-类索引、父类索引与接口索引集合"><a href="#3-4-类索引、父类索引与接口索引集合" class="headerlink" title="3.4 类索引、父类索引与接口索引集合"></a><strong>3.4 类索引、父类索引与接口索引集合</strong></h3><p>&emsp;&emsp;<strong>类索引</strong>（this_class）和<strong>父类索引</strong>（super_class）都是一个u2类型的数据，而<strong>接口索引集合</strong>（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来<strong>确定这个类的继承关系</strong>。<strong>类索引用于确定这个类的全限定名</strong>，<strong>父类索引用于确定这个类的父类的全限定名</strong>。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。<strong>接口索引集合就用来描述这个类实现了哪些接口</strong>，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。 </p><p>&emsp;&emsp;类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。图6-6演示了代码清单6-1的代码的类索引查找过程。 </p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010127.png" alt="类索引查找全限定名的过程"></p><p>&emsp;&emsp;对于接口索引集合，入口的第一项——u2类型的数据为<strong>接口计数器</strong>（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。代码清单6-1中的代码的类索引、父类索引与接口表索引的内容如图6-7所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010128.png" alt="类索引、父类索引、接口索引集合"></p><p>&emsp;&emsp;从偏移地址0x000000F1开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是类索引为1，父类索引为3，接口索引集合大小为0，查询前面代码清单6-2中javap命令计算出来的常量池，找出对应的类和父类的常量，结果如代码清单6-3所示。 </p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">6</span>-<span class="number">3</span>　部分常量池内容</span><br><span class="line"><span class="keyword">const</span> <span class="string">#1</span> = <span class="keyword">class</span>      <span class="string">#2</span>；        <span class="comment">//org/fenixsoft/clazz/TestClass </span></span><br><span class="line"><span class="keyword">const</span> <span class="string">#2</span> = Asciz      org/fenixsoft/clazz/TestClass； </span><br><span class="line"><span class="keyword">const</span> <span class="string">#3</span> = <span class="keyword">class</span>      <span class="string">#4</span>；        <span class="comment">//java/lang/Object </span></span><br><span class="line"><span class="keyword">const</span> <span class="string">#4</span> = Asciz      java/lang/<span class="keyword">Object</span>；</span><br></pre></td></tr></table></figure><h3 id="3-5-字段表集合"><a href="#3-5-字段表集合" class="headerlink" title="3.5 字段表集合"></a><strong>3.5 字段表集合</strong></h3><p>&emsp;&emsp;字段表（field_info）用于<strong>描述接口或者类中声明的变量</strong>。字段（field）包括<strong>类级变量</strong>以及<strong>实例级变量</strong>，但<strong>不包括在方法内部声明的局部变量</strong>。我们可以想一想在Java中描述一个字段可以包含什么信息？可以包括的信息有：</p><blockquote><ul><li><strong>字段的作用域</strong>（public、private、protected修饰符）</li><li><strong>是实例变量还是类变量</strong>（static修饰符）</li><li><strong>可变性</strong>（final）</li><li><strong>并发可见性</strong>（volatile修饰符，是否强制从主内存读写）</li><li><strong>可否被序列化</strong>（transient修饰符）</li><li><strong>字段数据类型</strong>（基本类型、对象、数组）</li><li><strong>字段名称</strong></li></ul></blockquote><p>&emsp;&emsp;上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。表6-8中列出了字段表的最终格式。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010129.png" alt="字段表结构"></p><p>&emsp;&emsp;字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如表6-9所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010130.png" alt="字段访问标志"></p><p>&emsp;&emsp;很明显，在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所决定的。 </p><p>&emsp;&emsp;跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。现在需要解释一下“简单名称”、“描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念。 </p><p>&emsp;&emsp;<strong>全限定名</strong>和<strong>简单名称</strong>很好理解，以代码清单6-1中的代码为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。简单名称是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”。 </p><p>&emsp;&emsp;相对于全限定名和简单名称来说，方法和字段的描述符就要复杂一些。<strong>描述符</strong>的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见表6-10。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010131.png" alt="描述符标识字符含义"></p><p>&emsp;&emsp;对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String;”，一个整型数组“int[]”将被记录为“[I”。 </p><p>&emsp;&emsp;用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String;”，方法int indexOf(char[]source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex）的描述符为“([CII[CIII）I”。 </p><p>&emsp;&emsp;对于代码清单6-1中的TestClass.class文件来说，字段表集合从地址0x000000F8开始，第一个u2类型的数据为容量计数器fields_count，如图6-8所示，其值为0x0001，说明这个类只有一个字段表数据。接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private修饰符的ACC_PRIVATE标志位为真（ACC_PRIVATE标志的值为0x0002），其他修饰符为假。代表字段名称的name_index的值为0x0005，从代码清单6-2列出的常量表中可查得第5项常量是一个CONSTANT_Utf8_info类型的字符串，其值为“m”，代表字段描述符的descriptor_index的值为0x0006，指向常量池的字符串“I”，根据这些信息，我们可以推断出原代码定义的字段为：“private int m;”。</p><p>&emsp;&emsp;字段表都包含的固定数据项目到descriptor_index为止就结束了，不过在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信息，但是，如果将字段m的声明改为“final static int m=123;”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。关于attribute_info的其他内容，将在6.3.7节介绍属性表的数据项目时再进一步讲解。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010132.png" alt="字段表结构实例"></p><p>&emsp;&emsp;字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。 </p><h3 id="3-6-方法表集合"><a href="#3-6-方法表集合" class="headerlink" title="3.6 方法表集合"></a><strong>3.6 方法表集合</strong></h3><p>&emsp;&emsp;如果理解了上一节关于字段表的内容，那本节关于方法表的内容将会变得很简单。Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项，见表6-11。这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010133.png" alt="方法表结构"></p><p>&emsp;&emsp;因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见表6-12。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010134.png" alt="方法访问标志"></p><p>&emsp;&emsp;行文至此，也许有的读者会产生疑问，方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里面的代码去哪里了？方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，将在3.7节中详细讲解。</p><p>&emsp;&emsp;我们继续以代码清单6-1中的Class文件为例对方法表集合进行分析，如图6-9所示，方法表集合的入口地址为：0x00000101，第一个u2类型的数据（即是计数器容量）的值为0x0002，代表集合中有两个方法（这两个方法为编译器添加的实例构造器＜init＞和源码中 的方法inc()）。第一个方法的访问标志值为0x001，也就是只有ACC_PUBLIC标志为真， 名称索引值为0x0007，查代码清单6-2的常量池得方法名为“＜init＞”，描述符索引值为 0x0008，对应常量为“()V”，属性表计数器attributes_count的值为0x0001就表示此方法的属 性表集合有一项属性，属性名称索引为0x0009，对应常量为“Code”，说明此属性是方法的字 节码描述。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010135.png" alt="方法表结构实例"></p><p>&emsp;&emsp;与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”方法。 </p><p>&emsp;&emsp;在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的<strong>特征签名</strong>（Java代码的方法特征签名只包括了方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表），特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。 </p><h3 id="3-6-属性表集合"><a href="#3-6-属性表集合" class="headerlink" title="3.6 属性表集合"></a><strong>3.6 属性表集合</strong></h3><p>&emsp;&emsp;属性表（attribute_info）在前面的讲解之中已经出现过数次，在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。 </p><p>&emsp;&emsp;与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件，《Java虚拟机规范（第2版）》中预定义了9项虚拟机实现应当能识别的属性，而在最新的《Java虚拟机规范（Java SE 7）》版中，预定义属性已经增加到21项，具体内容见表6-13。下文中将对其中一些属性中的关键常用的部分进行讲解。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010136.png" alt="虚拟机规范预定义额属性"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010137.png" alt="虚拟机规范预定义额属性"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010138.png" alt="虚拟机规范预定义额属性"></p><p>&emsp;&emsp;对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足表6-14中所定义的结构。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010139.png" alt="属性表结构"></p><h4 id="3-6-1-Code属性"><a href="#3-6-1-Code属性" class="headerlink" title="3.6.1 Code属性"></a><strong>3.6.1 Code属性</strong></h4><p>&emsp;&emsp;Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010140.png" alt="Code属性表结构"></p><p>&emsp;&emsp;attribute_name_index是一项<strong>指向CONSTANT_Utf8_info型常量的索引</strong>，常量值固定为“Code”，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。 </p><p>&emsp;&emsp;max_stack代表了<strong>操作数栈（Operand Stacks）深度的最大值</strong>。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。 </p><p>&emsp;&emsp;max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。</p><p>&emsp;&emsp;方法参数（包括实例方法中的隐藏参 数“this”）、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch 块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。 </p><p>&emsp;&emsp;code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令，目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令含义，编码与指令之间的对应关系可查阅本书的附录B“虚拟机字节码指令表”。 </p><p>&emsp;&emsp;关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到(2^32)-1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器也会拒绝编译。一般来讲，编写Java代码时只要不是刻意去编写一个超长的方法来为难编译器，是不太可能超过这个最大值的限制。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就可能因为方法生成字节码超长的原因而导致编译失败。 </p><p>&emsp;&emsp;Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。了解Code属性是学习后面关于字节码执行引擎内容的必要基础，能直接阅读字节码也是工作中分析Java代码语义问题的必要工具和基本技能，因此作者准备了一个比较详细的实例来讲解虚拟机是如何使用这个属性的。 </p><p>&emsp;&emsp;继续以代码清单6-1的TestClass.class文件为例，如图6-10所示，这是上一节分析过的实例构造器“＜init＞”方法的Code属性。它的操作数栈的最大深度和本地变量表的容量都为0x0001，字节码区域所占空间的长度为0x0005。虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并根据字节码指令表翻译出所对应的字节码指令。翻译“2A B7 00 0A B1”的过程为： </p><blockquote><ol><li>读入2A，查表得0x2A对应的指令为aload_0，这个指令的含义是将第0个Slot中为reference类型的本地变量推送到操作数栈顶。 </li><li>读入B7，查表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的方法符号引用。</li><li>读入00 0A，这是invokespecial的参数，查常量池得0x000A对应的常量为实例构造器“＜init＞”方法的符号引用。 </li><li>读入B1，查表得0xB1对应的指令为return，含义是返回此方法，并且返回值为void。这条指令执行后，当前方法结束。</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010141.png" alt="Code属性结构实例"></p><p>&emsp;&emsp;这段字节码虽然很短，但是至少可以看出它的执行过程中的数据交换、方法调用等操作都是基于栈（操作栈）的。我们可以初步猜测：<strong>Java虚拟机执行字节码是基于栈的体系结构</strong>。但是与一般基于堆栈的零字节指令又不太一样，某些指令（如invokespecial）后面还会带有参数，关于虚拟机字节码执行的讲解是后面两章的重点，我们不妨把这里的疑问放到<a href="../2019121001.html" title="Title">字节码执行引擎</a>去解决。 </p><p>&emsp;&emsp;我们再次使用javap命令把此Class文件中的另外一个方法的字节码指令也计算出来，结果如代码清单6-4所示。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">6</span><span class="number">-4</span>　用javap命令计算字节码指令</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始Java代码 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>&#123;</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">C: \&gt; javap-verbose TestClass </span><br><span class="line"><span class="comment">//常量表部分的输出见代码清单6-1, 因版面原因这里省略掉 </span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.clazz.TestClass();  </span><br><span class="line">    Code:  </span><br><span class="line">        Stack=<span class="number">1</span>, Locals=<span class="number">1</span>, Args_size=<span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>: aload_0 </span><br><span class="line">        <span class="number">1</span>: invokespecial  #<span class="number">10</span>;   <span class="comment">//Method java/lang/Object."&lt;init&gt;": ()V </span></span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span> </span><br><span class="line">    LineNumberTable:  </span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    LocalVariableTable:  </span><br><span class="line">        Start Length Slot Name Signature </span><br><span class="line">        <span class="number">0</span>     <span class="number">5</span>      <span class="number">0</span>    <span class="keyword">this</span> Lorg/fenixsoft/clazz/TestClass;  </span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>;  </span><br><span class="line">    Code:  </span><br><span class="line">        Stack=<span class="number">2</span>, Locals=<span class="number">1</span>, Args_size=<span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>: aload_0 </span><br><span class="line">        <span class="number">1</span>: getfield#<span class="number">18</span>; <span class="comment">//Field m: I </span></span><br><span class="line">        <span class="number">4</span>: iconst_1 </span><br><span class="line">        <span class="number">5</span>: iadd </span><br><span class="line">        <span class="number">6</span>: ireturn </span><br><span class="line">    </span><br><span class="line">    LineNumberTable:  </span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    LocalVariableTable:  </span><br><span class="line">        Start Length Slot Name Signature </span><br><span class="line">        <span class="number">0</span>     <span class="number">7</span>      <span class="number">0</span>    <span class="keyword">this</span> Lorg/fenixsoft/clazz/TestClass; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果大家注意到javap中输出的“Args_size”的值，可能会有疑问：这个类有两个方法——实例构造器＜init＞()和inc()，这两个方法很明显都是没有参数的，为什么Args_size会为1？而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么会等于1？如果有这样的疑问，大家可能是忽略了一点：在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现却非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此<strong>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量</strong>，<strong>局部变量表中也会预留出第一个Slot位来存放对象实例的引用</strong>，方法参数值从1开始计算。这个处理只对实例方法有效，如果代码清单6-1中的inc()方法声明为static，那Args_size就不会等于1而是等于0了。 </p><p>&emsp;&emsp;在字节码指令之后的是这个方法的显式异常处理表（下文简称异常表）集合，异常表对于Code属性来说并不是必须存在的，如代码清单6-4中就没有异常表生成。 </p><p>&emsp;&emsp;异常表的格式如表6-16所示，它包含4个字段，这些字段的含义为：如果当字节码在第start_pc行（行并非指Java源码的行号，而是字节码相对于方法体开始的偏移量）到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010142.png" alt="属性表结构"></p><p>&emsp;&emsp;异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制（JDK 1.4.2之前Javac编译器采用jsr和ret指令实现finally语句，但之后已经改为编译器自动在每段可能的分支路径之后都将finally语句块内容冗余生成一遍，在JDK 1.7中已完全禁止了Class文件中出现jsr和ret语句，会在类加载的字节码校验阶段抛出异常）。 </p><p>&emsp;&emsp;代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了在字节码层面中try-catch-finally是如何实现的。在阅读字节码之前，大家不妨先看看下面的Java源码，想一下这段代码的返回值在出现异常和不出现异常的情况下分别应该是多少？ </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">6</span><span class="number">-5</span>　异常表运作演示</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java源码 </span></span><br><span class="line">public int inc()&#123; </span><br><span class="line">    int x;  </span><br><span class="line">    try&#123; </span><br><span class="line">        x = <span class="number">1</span>;  </span><br><span class="line">        return x;  </span><br><span class="line">    &#125; catch(Exception e) &#123; </span><br><span class="line">        x = <span class="number">2</span>;  </span><br><span class="line">        return x;  </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        x = <span class="number">3</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后的ByteCode字节码及异常表 </span></span><br><span class="line">public int inc();  </span><br><span class="line">    Code： </span><br><span class="line">        Stack=<span class="number">1</span>，Locals=<span class="number">5</span>，Args_size=<span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>：iconst_1 <span class="comment">//try块中的x=1 </span></span><br><span class="line">        <span class="number">1</span>：istore_1 </span><br><span class="line">        <span class="number">2</span>：iload_1 <span class="comment">//保存x到returnValue中，此时x=1 </span></span><br><span class="line">        <span class="number">3</span>：istore <span class="number">4</span> </span><br><span class="line">        <span class="number">5</span>：iconst_3 <span class="comment">//finaly块中的x=3 </span></span><br><span class="line">        <span class="number">6</span>：istore_1 </span><br><span class="line">        <span class="number">7</span>：iload <span class="number">4</span> <span class="comment">//将returnValue中的值放到栈顶，准备给ireturn返回 </span></span><br><span class="line">        <span class="number">9</span>：ireturn <span class="number">10</span>：astore_2<span class="comment">//给catch中定义的Exception e赋值，存储在Slot 2中 </span></span><br><span class="line">        <span class="number">11</span>：iconst_2 <span class="comment">//catch块中的x=2 </span></span><br><span class="line">        <span class="number">12</span>：istore_1 </span><br><span class="line">        <span class="number">13</span>：iload_1 <span class="comment">//保存x到returnValue中，此时x=2 </span></span><br><span class="line">        <span class="number">14</span>：istore <span class="number">4</span> </span><br><span class="line">        <span class="number">16</span>：iconst_3 <span class="comment">//finaly块中的x=3 </span></span><br><span class="line">        <span class="number">17</span>：istore_1 </span><br><span class="line">        <span class="number">18</span>：iload <span class="number">4</span> <span class="comment">//将returnValue中的值放到栈顶，准备给ireturn返回 </span></span><br><span class="line">        <span class="number">20</span>：ireturn </span><br><span class="line">        <span class="number">21</span>：astore_3 <span class="comment">//如果出现了不属于java.lang.Exception及其子类的异常才会走到这里 </span></span><br><span class="line">        <span class="number">22</span>：iconst_3 <span class="comment">//finaly块中的x=3 </span></span><br><span class="line">        <span class="number">23</span>：istore_1 </span><br><span class="line">        <span class="number">24</span>：aload_3 <span class="comment">//将异常放置到栈顶，并抛出 </span></span><br><span class="line">        <span class="number">25</span>：athrow </span><br><span class="line">    Exception table： </span><br><span class="line">        from to target type </span><br><span class="line">        <span class="number">0</span>    <span class="number">5</span>  <span class="number">10</span>     Class java/lang/Exception </span><br><span class="line">        <span class="number">0</span>    <span class="number">5</span>  <span class="number">21</span>     any </span><br><span class="line">        <span class="number">10</span>   <span class="number">16</span> <span class="number">21</span>     any</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译器为这段Java源码生成了3条异常表记录，对应3条可能出现的代码执行路径。从Java代码的语义上讲，这3条执行路径分别为： </p><blockquote><ul><li>如果try语句块中出现属于Exception或其子类的异常，则转到catch语句块处理。 </li><li>如果try语句块中出现不属于Exception或其子类的异常，则转到finally语句块处理。 </li><li>如果catch语句块中出现任何异常，则转到finally语句块处理。 </li></ul></blockquote><p>&emsp;&emsp;返回到我们上面提出的问题，这段代码的返回值应该是多少？对Java语言熟悉的读者应该很容易说出答案：如果没有出现异常，返回值是1；如果出现了Exception异常，返回值是2；如果出现了Exception以外的异常，方法非正常退出，没有返回值。我们一起来分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。 </p><p>&emsp;&emsp;字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副本到最后一个本地变量表的Slot中（这个Slot里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为方法返回值使用。为了讲解方便，作者给这个Slot起了个名字：returnValue）。 </p><p>&emsp;&emsp;如果这时没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后将之前保存在returnValue中的整数1读入到操作栈顶，最后ireturn指令会以int形式返回操作栈顶中的值，方法结束。如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是将2赋值给变量x，然后将变量x此时的值赋给returnValue，最后再将变量x的值改为3。方法返回前同样将returnValue中保留的整数2读到了操作栈顶。从第21行开始的代码，作用是变量x的值赋为3，并将栈顶的异常抛出，方法结束。 </p><p>&emsp;&emsp;尽管大家都知道这段代码出现异常的概率非常小，但并不影响它为我们演示异常表的作用。如果大家到这里仍然对字节码的运作过程比较模糊，其实也不要紧，关于虚拟机执行字节码的过程，<a href="../2019121001.html" title="Title">字节码执行引擎</a>中将会有更详细的讲解。 </p><h4 id="3-6-2-Exceptions属性"><a href="#3-6-2-Exceptions属性" class="headerlink" title="3.6.2 Exceptions属性"></a><strong>3.6.2 Exceptions属性</strong></h4><p>&emsp;&emsp;这里的Exceptions属性是在方法表中与Code属性平级的一项属性，读者不要与前面刚刚讲解完的异常表产生混淆。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。它的结构见表6-17。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010143.png" alt="属性表结构"></p><p>&emsp;&emsp;Exceptions属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示，exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p><h4 id="3-6-3-LineNumberTable属性"><a href="#3-6-3-LineNumberTable属性" class="headerlink" title="3.6.3 LineNumberTable属性"></a><strong>3.6.3 LineNumberTable属性</strong></h4><p>&emsp;&emsp;LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g：none或-g：lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。LineNumberTable属性的结构见表618。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010144.png" alt="LineNumberTable属性结构"></p><p>&emsp;&emsp;line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。 </p><h4 id="3-6-4-LocalVariableTable属性"><a href="#3-6-4-LocalVariableTable属性" class="headerlink" title="3.6.4 LocalVariableTable属性"></a><strong>3.6.4 LocalVariableTable属性</strong></h4><p>&emsp;&emsp;LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g：none或-g：vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。LocalVariableTable属性的结构见表6-19。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010145.png" alt="LocalVariableTable属性结构"></p><p>&emsp;&emsp;其中，local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构见表6-20。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010146.png" alt="local_variable_info项目结构"></p><p>&emsp;&emsp;start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。 </p><p>&emsp;&emsp;name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。 </p><p>&emsp;&emsp;index是这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为index和index+1两个。 </p><p>&emsp;&emsp;顺便提一下，在JDK 1.5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”：LocalVariableTypeTable，这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature），对于非泛型类型来说，描述符和特征签名能描述的信息是基本一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[3]，描述符就不能准确地描述泛型类型了，因此出现了 LocalVariableTypeTable。 </p><h4 id="3-6-5-SourceFile属性"><a href="#3-6-5-SourceFile属性" class="headerlink" title="3.6.5 SourceFile属性"></a><strong>3.6.5 SourceFile属性</strong></h4><p>&emsp;&emsp;SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以分别使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性，其结构见表6-21。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010147.png" alt="SourceFile属性结构"></p><p>&emsp;&emsp;sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。</p><h4 id="3-6-6-ConstantValue属性"><a href="#3-6-6-ConstantValue属性" class="headerlink" title="3.6.6 ConstantValue属性"></a><strong>3.6.6 ConstantValue属性</strong></h4><p>&emsp;&emsp;ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的 变量（类变量）才可以使用这项属性。类似“int x=123”和“static int x=123”这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非static类型的变量（也就是实例变量）的赋值是在实例构造器＜init＞方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器＜clinit＞方法中或者使用ConstantValue属性。目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在＜clinit＞方法中进行初始化。 </p><p>&emsp;&emsp;虽然有final关键字才更符合“ConstantValue”的语义，但虚拟机规范中并没有强制要求字段必须设置了ACC_FINAL标志，只要求了有ConstantValue属性的字段必须设置ACC_STATIC标志而已，对final关键字的要求是Javac编译器自己加入的限制。而对ConstantValue的属性值只能限于基本类型和String，不过作者不认为这是什么限制，因为此属性的属性值只是一个常量池的索引号，由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以就算ConstantValue属性想支持别的类型也无能为力。ConstantValue属性的结构见表6-22。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010148.png" alt="ConstantValue属性结构"></p><p>&emsp;&emsp;从数据结构中可以看出，ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、 CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info常量中的一种。 </p><h4 id="3-6-7-InnerClasses属性"><a href="#3-6-7-InnerClasses属性" class="headerlink" title="3.6.7 InnerClasses属性"></a><strong>3.6.7 InnerClasses属性</strong></h4><p>&emsp;&emsp;InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。该属性的结构见表6-23。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010149.png" alt="InnerClasses属性结构"></p><p>&emsp;&emsp;数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个inner_classes_info表进行描述。inner_classes_info表的结构见表6-24。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010150.png" alt="inner_classes_info表结构"></p><p>&emsp;&emsp;inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</p><p>&emsp;&emsp;inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，那么这项值为0。 </p><p>&emsp;&emsp;inner_class_access_flags是内部类的访问标志，类似于类的access_flags，它的取值范围见表6-25。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010151.png" alt="inner_class_access_flags标志"></p><h4 id="3-6-8-Deprecated及Synthetic属性"><a href="#3-6-8-Deprecated及Synthetic属性" class="headerlink" title="3.6.8 Deprecated及Synthetic属性"></a><strong>3.6.8 Deprecated及Synthetic属性</strong></h4><p>&emsp;&emsp;Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。 </p><p>&emsp;&emsp;Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用@deprecated注释进行设置。 </p><p>&emsp;&emsp;Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 1.5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位，其中最典型的例子就是Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置Synthetic属性和ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器“＜init＞”方法和类构造器“＜clinit＞”方法。 </p><p>&emsp;&emsp;Deprecated和Synthetic属性的结构非常简单，见表6-26。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010152.png" alt="Deprecated及Synthetic属性结构"></p><p>&emsp;&emsp;其中attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置。 </p><h4 id="3-6-9-StackMapTable属性"><a href="#3-6-9-StackMapTable属性" class="headerlink" title="3.6.9 StackMapTable属性"></a><strong>3.6.9 StackMapTable属性</strong></h4><p>&emsp;&emsp;StackMapTable属性在JDK 1.6发布后增加到了Class文件规范中，它是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用（见3.2节），目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 </p><p>&emsp;&emsp;这个类型检查验证器最初来源于Sheng Liang（听名字似乎是虚拟机团队中的华裔成员）为Java ME CLDC实现的字节码验证器。新的验证器在同样能保证Class文件合法性的前提下，省略了在运行期通过数据流分析去确认字节码的行为逻辑合法性的步骤，而是在编译阶段将一系列的验证类型（Verification Types）直接记录在Class文件之中，通过检查这些验证 类型代替了类型推导过程，从而大幅提升了字节码验证的性能。这个验证器在JDK 1.6中首次提供，并在JDK 1.7中强制代替原本基于类型推断的字节码验证器。关于这个验证器的工作原理，《Java虚拟机规范（Java SE 7版）》花费了整整120页的篇幅来讲解描述，并且分析证明新验证方法的严谨性，作者在此不再赘述。 </p><p>&emsp;&emsp;StackMapTable属性中包含零至多个栈映射帧（Stack Map Frames），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。StackMapTable属性的结构见表6-27。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010153.png" alt="StackMapTable属性结构"></p><p>&emsp;&emsp;《Java虚拟机规范（Java SE 7版）》明确规定：在版本号大于或等于50.0的Class文件中，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性。这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</p><h4 id="3-6-10-Signature属性"><a href="#3-6-10-Signature属性" class="headerlink" title="3.6.10 Signature属性"></a><strong>3.6.10 Signature属性</strong></h4><p>&emsp;&emsp;Signature属性在JDK 1.5发布后增加到了Class文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。在JDK 1.5中大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，在字节码（Code属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得到泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性。关于Java泛型、Signature属性和类型擦除，在第10章介绍编译器优化的时候会通过一个具体的例子来讲解。Signature属性的结构见表6-28。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010154.png" alt="Signature属性结构"></p><p>&emsp;&emsp;其中signature_index项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名、方法类型签名或字段类型签名。如果当前的Signature属性是类文件的属性，则这个结构表示类签名，如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。 </p><h4 id="3-6-11-BootstrapMethods属性"><a href="#3-6-11-BootstrapMethods属性" class="headerlink" title="3.6.11 BootstrapMethods属性"></a><strong>3.6.11 BootstrapMethods属性</strong></h4><p>&emsp;&emsp;BootstrapMethods属性在JDK 1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。《Java虚拟机规范（Java SE 7版）》规定，如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性，另外，即使CONSTANT_InvokeDynamic_info类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性。BootstrapMethods属性与JSR-292中的InvokeDynamic指令和java.lang.Invoke包关系非常密切，要介绍这个属性的作用，必须先弄清楚InovkeDynamic指令的运作原理，作者将在<a href="../2019121001.html" title="Title">字节码执行引擎</a>专门用1节篇幅去介绍它们，在此先暂时略过。 </p><p>&emsp;&emsp;目前的Javac暂时无法生成InvokeDynamic指令和BootstrapMethods属性，必须通过一些非常规的手段才能使用到它们，也许在不久的将来，等JSR-292更加成熟一些，这种状况就会改变。BootstrapMethods属性的结构见表6-29。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010155.png" alt="BootstrapMethods属性结构"></p><p>&emsp;&emsp;其中引用到的bootstrap_method结构见表6-30。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010156.png" alt="bootstrap_method属性结构"></p><p>&emsp;&emsp;BootstrapMethods属性中，num_bootstrap_methods项的值给出了bootstrap_methods[]数组中的引导方法限定符的数量。而bootstrap_methods[]数组的每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值，它代表了一个引导方法，还包含了这个引导方法静态参数的序列（可能为空）。</p><blockquote><p>bootstrap_methods[]数组中的每个成员必须包含以下3项内容。 </p><ul><li>bootstrap_method_ref：bootstrap_method_ref项的值必须是一个对常量池的有效索引。常 量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。</li><li>num_bootstrap_arguments：num_bootstrap_arguments项的值给出了bootstrap_arguments[]数 组成员的数量。 </li><li>bootstrap_arguments[]：bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效 索引。常量池在该索引处必须是下列结构之一：CONSTANT_String_info、 CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、 CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info或 CONSTANT_MethodType_info。 </li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的类文件结构-Class类文件的结构，包括：魔数与Class文件的版本，常量池，访问标志，类索引、父类索引与接口索引集合，字段表集合，方法表集合，属性表集合（Code属性、Exceptions属性、LineNumberTable属性、LocalVariableTable属性、SourceFile属性、ConstantValue属性、InnerClasses属性、Deprecated及Synthetic属性、StackMapTable属性、Signature属性、BootstrapMethods属性）等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://linyishui.top/2019120301.html"/>
    <id>http://linyishui.top/2019120301.html</id>
    <published>2019-12-03T02:17:54.000Z</published>
    <updated>2020-01-14T07:23:19.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a><strong>类文件结构</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;记得在第一节计算机程序课上老师就讲过：“计算机只认识0和1，所以我们写的程序需要被编译器翻译成由0和1构成的二进制格式才能被计算机执行”。10多年的时间过去了，今天的计算机仍然只能识别0和1，但由于最近10年内虚拟机及建立在虚拟机之上的大量程序语言如雨后春笋般出现并蓬勃发展，将我们编写的<strong>程序编译成二进制本地机器码（Native Code）已不再是唯一的选择</strong>，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p><hr><h2 id="第二节-无关性的基石"><a href="#第二节-无关性的基石" class="headerlink" title="第二节 无关性的基石"></a><strong>第二节 无关性的基石</strong></h2><p>&emsp;&emsp;如果计算机的CPU指令集就只有x86一种，操作系统就只有Windows一种，那也许就不会有Java语言的出现。Java在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处运行（Write Once, Run Anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴求。在无时无刻不充满竞争的IT领域，不可能只有Wintel存在，我们也不希望只有Wintel存在，各种不同的硬件体系结构和不同的操作系统定将会长期并存发展。“与平台无关”的理想最终实现在操作系统的应用层上：<strong>Sun公司及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码</strong>，从而实现程序的“一次编写，到处运行”。</p><p>&emsp;&emsp;各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—<strong>字节码</strong>（ByteCode）是构成平台无关性的基石，但本节标题中刻意省略了“平台”二字，那是因为作者注意到虚拟机的另外一种中立的特性—如今语言无关性越来越被开发者所重视。到今天为止，或许大部分程序员都还认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。但在Java发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，他们在发布规范文档的时候，也刻意把Java的规范拆分成了Java语言规范《The Java Language Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。并且在1997年发布的第一版Java虚拟机规范中就曾经承诺过：“In the future,we will consider bounded extensions to the Java virtual machine to provide better support for other languages”（在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于JVM之上），<strong>当Java虚拟机发展到JDK 1.7~1.8的时候，JVM设计者通过JSR-292基本兑现了这个承诺</strong>。</p><p>&emsp;&emsp;时至今日，商业机构和开源机构已经在Java语言之外发展出一大批在Java虚拟机之上运行的语言，如Clojure、Groovy、JRuby、Jython、Scala，等等。使用过这些语言的开发者可能还不是非常多，但是听说过的人肯定已经不少，随着时间的推移，谁能保证日后Java虚拟机在语言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？</p><p>&emsp;&emsp;<strong>实现语言无关性的基础仍然是虚拟机和字节码存储格式</strong>，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是什么语言，只要它符合Class文件应有的结构就可以在Java虚拟机中运行，如图6-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010114.png" alt="Java虚拟机提供的语言无关性"></p><p>&emsp;&emsp;<strong>Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的</strong>，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更强大。因此，有一些Java语言本身无法有效支持的语言特性并不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。</p><hr><h2 id="第三节-Class类文件的结构"><a href="#第三节-Class类文件的结构" class="headerlink" title="第三节 Class类文件的结构"></a><strong>第三节 Class类文件的结构</strong></h2><p>&emsp;&emsp;<a href="../2019120401.html" title="Title">类文件结构-Class类文件的结构</a></p><hr><h2 id="第四节-字节码指令简介"><a href="#第四节-字节码指令简介" class="headerlink" title="第四节 字节码指令简介"></a><strong>第四节 字节码指令简介</strong></h2><p>&emsp;&emsp;<a href="../2019120501.html" title="Title">类文件结构-字节码指令简介</a></p><hr><h2 id="第五节-公有设计和私有实现"><a href="#第五节-公有设计和私有实现" class="headerlink" title="第五节 公有设计和私有实现"></a><strong>第五节 公有设计和私有实现</strong></h2><p>&emsp;&emsp;Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：<strong>Class文件格式</strong>以及<strong>字节码指令集</strong>。这些内容与硬件、操作系统及具体的Java虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看做是程序在各种Java平台实现之间互相安全地交互的手段。</p><p>&emsp;&emsp;理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取 Class文件并精确实现包含在其中的Java虚拟机代码的语义。拿着Java虚拟机规范一成不变地 逐字实现其中要求的内容当然是一种可行的途径，但一个优秀的虚拟机实现，在满足虚拟机 规范的约束下对具体实现做出修改和优化也是完全可行的，并且虚拟机规范中明确鼓励实现 者这样做。只要优化后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的 保持，那实现者就可以选择任何方式去实现这些语义，虚拟机后台如何处理Class文件完全是 实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可[1]。 </p><p>&emsp;&emsp;虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或 者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么。虚拟机实 现的方式主要有以下两种： </p><blockquote><ul><li>将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。 </li><li>将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生 成技术）。 </li></ul></blockquote><p>&emsp;&emsp;精确定义的虚拟机和目标文件格式不应当对虚拟机实现者的创造性产生太多的限制，Java虚拟机应被设计成可以允许有众多不同的实现，并且各种实现可以在保持兼容性的 同时提供不同的、新的、有趣的解决方案。 </p><hr><h2 id="第六节-Class文件结构的发展"><a href="#第六节-Class文件结构的发展" class="headerlink" title="第六节 Class文件结构的发展"></a><strong>第六节 Class文件结构的发展</strong></h2><p>&emsp;&emsp;Class文件结构自Java虚拟机规范第1版订立以来，已经有十多年的历史。这十多年 间，Java技术体系有了翻天覆地的改变，JDK的版本号已经从1.0提升到了1.7。相对于语言、 API以及Java技术体系中其他方面的变化，Class文件结构一直处于比较稳定的状态，Class文 件的主体结构、字节码指令的语义和数量几乎没有出现过变动[1]，所有对Class文件格式的改 进，都集中在向访问标志、属性表这些在设计上就可扩展的数据结构中添加内容。 </p><p>&emsp;&emsp;如果以《Java虚拟机规范（第2版）》为基准进行比较的话，那么在后续Class文件格式 的发展过程中，访问标志里新加入了ACC_SYNTHETIC、ACC_ANNOTATION、 ACC_ENUM、ACC_BRIDGE、ACC_VARARGS共5个标志。而属性表集合中，在JDK 1.5到 JDK 1.7版本之间一共增加了12项新的属性，这些属性大部分用于支持Java中许多新出现的语 言特性，如枚举、变长参数、泛型、动态注解等。还有一些是为了支持性能改进和调试信 息，譬如JDK 1.6的新类型校验器的StackMapTable属性和对非Java代码调试中用到的 SourceDebugExtension属性。</p><p>&emsp;&emsp;Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩 展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。 </p><hr><h2 id="第七节-总结"><a href="#第七节-总结" class="headerlink" title="第七节 总结"></a><strong>第七节 总结</strong></h2><p>&emsp;&emsp;Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础构成之一。了解 Class文件的结构对后面进一步了解虚拟机执行引擎有很重要的意义。 </p><p>&emsp;&emsp;本章详细讲解了Class文件结构中的各个组成部分，以及每个部分的定义、数据结构和使 用方法。通过代码清单6-1的Java代码与它的Class文件样例，以实战的方式演示了Class的数 据是如何存储和访问的。从第7章开始，我们将以动态的、运行时的角度去看看字节码流在 虚拟机执行引擎中是怎样被解释执行的。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的类文件结构，包括：概述，无关性的基石，Class类文件的结构，字节码指令简介，公有设计和私有实现，Class文件结构的发展，总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机调优案例分析与实战</title>
    <link href="http://linyishui.top/2019120101.html"/>
    <id>http://linyishui.top/2019120101.html</id>
    <published>2019-12-01T12:53:58.000Z</published>
    <updated>2020-01-10T03:12:26.494Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机调优案例分析与实战"><a href="#虚拟机调优案例分析与实战" class="headerlink" title="虚拟机调优案例分析与实战"></a><strong>虚拟机调优案例分析与实战</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;<a href="../2019112501.html" title="Title">虚拟机性能监控和故障处理工具</a>介绍了处理Java虚拟机内存问题的知识与工具，在处理实际项目的问题时，除了知识与工具外，经验也是一个很重要的因素。因此本章将分享几个比较有代表性的实际案例。考虑到虚拟机故障处理和调优主要面向各类服务端应用，而大部分Java程序员较少有机会直接接触生产环境的服务器，因此本章还准备了一个所有开发人员都能够进行“亲身实战”的练习，希望通过实践使读者获得故障处理和调优的经验。</p><hr><h2 id="第二节-案例分析"><a href="#第二节-案例分析" class="headerlink" title="第二节 案例分析"></a><strong>第二节 案例分析</strong></h2><p>&emsp;&emsp;本章中的案例大部分来源于作者处理过的一些问题，还有一小部分来源于网上有特色和代表性的案例总结。出于对客户商业信息保护的目的，在不影响前后逻辑的前提下，作者对实际环境和用户业务做了一些屏蔽和精简。</p><h3 id="2-1-高性能硬件上的程序部署策略"><a href="#2-1-高性能硬件上的程序部署策略" class="headerlink" title="2.1 高性能硬件上的程序部署策略"></a><strong>2.1 高性能硬件上的程序部署策略</strong></h3><p>&emsp;&emsp;例如一个15万PV/天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个CPU、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给访问量并不算太大的网站使用。管理员为了尽量利用硬件资源选用了64位的JDK 1.5，并通过-Xmx和-Xms参数将Java堆固定在12GB。使用一段时间后发现使用效果并不理想，网站经常不定期出现长时间没有响应的现象。</p><p>&emsp;&emsp;监控服务器运行状况后发现网站没有响应是由GC停顿导致的，虚拟机运行在Server模式，默认使用吞吐量优先收集器，回收12GB的堆，一次Full GC的停顿时间高达14秒。并且由于程序设计的关系，访问文档时要把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有在Minor GC中清理掉。这种情况下即使有12GB的堆，内存也很快会被消耗殆尽，由此导致每隔十几分钟出现十几秒的停顿，令网站开发人员和管理员感到很沮丧。</p><p>&emsp;&emsp;这里先不延伸讨论程序代码问题，程序部署上的主要问题显然是<strong>过大的堆内存进行回收时带来的长时间的停顿</strong>。硬件升级前使用32位系统1.5GB的堆，用户只感到访问网站比较缓慢，但不会发生十分明显的停顿，因此才考虑升级硬件提升程序效能，如果重新缩小给Java堆分配的内存，那么硬件上的投资就浪费了。</p><blockquote><p>在高性能硬件上部署程序，目前主要有两种方式：</p><ul><li>通过64位JDK来使用大内存。</li><li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源。</li></ul></blockquote><p>&emsp;&emsp;此案例中的管理员采用了第一种部署方式。对于用户交互性强、对停顿时间敏感的系统，可以给Java虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，至少要低到不会影响用户使用，譬如十几个小时乃至一天才出现一次Full GC，这样可以<strong>通过在深夜执行定时任务的方式触发Full GC甚至自动重启应用服务器来将内存可用空间保持在一个稳定的水平</strong>。</p><p>&emsp;&emsp;控制Full GC频率的关键是看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能产生成批量的、长生存时间的大对象，这样才能保障老年代空间的稳定。</p><p>&emsp;&emsp;在大多数网站形式的应用里，主要对象的生存周期都应该是请求级或页面级的，会话级和全局级的长生命对象相对很少。只要代码写得合理，应当都能实现在超大堆中正常使用而没有Full GC，这样的话，使用超大堆内存时，网站响应的速度才比较有保证。除此之外，如果读者计划使用64位JDK来管理大内存，还需要考虑下面可能面临的问题：</p><blockquote><ul><li>内存回收导致的长时间停顿。</li><li>现阶段，64位JDK的性能测试结果普遍低于32位JDK。</li><li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照 （因为要产生十几GB乃至更大的dump文件），哪怕产生了快照也几乎无法进行分 析。</li><li>相同的程序在64位JDK中消耗的内存一般比32位JDK大，这是由指针膨胀及数据类型对齐补白等因素导致的。</li></ul></blockquote><p>&emsp;&emsp;上面的问题听起来有点吓人，所以现阶段不少管理员还是选择第二种方式：使用若干个32位虚拟机建立逻辑集群来利用硬件资源。具体做法是<strong>在一台物理机器上启动多个应用服务器进程，给每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求</strong>。读者不需要太在意均衡器转发所消耗的性能，即使使用64位JDK，许多应用也不止有一台服务器，因此在许多应用中前端的均衡器总是要存在的。</p><p>&emsp;&emsp;考虑到在一台物理机器上建立逻辑集群的目的仅仅是尽可能地利用硬件资源，并不需要关心状态保留、热转移之类的高可用性需求，也不需要保证每个虚拟机进程有绝对准确的均衡负载，因此使用无Session复制的亲合式集群是一个相当不错的选择。我们仅仅需要保障集群具备亲和性，也就是均衡器按一定的规则算法（一般根 据SessionID分配）将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可，这样程序开发阶段就基本不用为集群环境做什么特别的考虑。</p><p>&emsp;&emsp;当然，很少有没有缺点的方案，如果读者计划使用逻辑集群的方式来部署程序，可能会遇到下面一些问题：</p><blockquote><ul><li>尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致IO异常。</li><li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI，但这有一定的复杂性并且可能带来额外的性能代价。</li><li>各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些 Linux, Unix系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB（2^32）内存的限制。</li><li>大量使用本地缓存（如大量使用HashMap作为K/V缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时可以考虑把本地缓存改为集中式缓存。</li></ul></blockquote><p>&emsp;&emsp;介绍完这两种部署方式，再重新回到这个案例之中，最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了10GB的内存。另外建立一个Apache服务作为前端均衡代理访问门户。考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问上，CPU资源敏感度较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较大提升。</p><h3 id="2-2-集群间同步导致的内存溢出"><a href="#2-2-集群间同步导致的内存溢出" class="headerlink" title="2.2 集群间同步导致的内存溢出"></a><strong>2.2 集群间同步导致的内存溢出</strong></h3><p>&emsp;&emsp;一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机，服务器是WebLogic 9.2，每台机器启动了3个WebLogic实例，构成一个6个节点的亲合式集群。由于是亲合式集群，节点之间没有进行Session同步，但是有一些需求要实现部分数据在各个节点间共享。开始这些数据存放在数据库中，但由于读写频繁竞争很激烈，对性能的影响较大，后面使用JBossCache构建了一个全局缓存。全局缓存启用后，服务正常使用了较长的一段时间。但最近不定期地多次出现内存溢出问题。</p><p>&emsp;&emsp;在不出现内存溢出异常的时候，服务内存回收状况一直正常，每次内存回收后都能恢复到一个稳定的可用空间，开始怀疑是程序的某些不常用的代码路径中存在内存泄漏，但管理员反映最近程序并未更新或升级过，也没有进行什么特别的操作。只好让服务带着-XX：+HeapDumpOnOutOfMemoryError参数运行了一段时间。在最近一次溢出之后，管理员发回了heapdump文件，发现里面存在着大量的org.jgroups.protocols.pbcast.NAKACK对象。</p><p>&emsp;&emsp;JBossCache是基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性的自由组合，数据包接收和发送时要经过每层协议栈的up()和down()方法，其中的NAKACK栈用于保障各个包的有效顺序及重发。JBossCache协议栈如图5-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010101.png" alt="JBossCache协议栈"></p><p>&emsp;&emsp;由于信息有传输失败需要重发的可能性，在确认所有注册在GMS（Group Membership Service）的节点都收到正确的信息前，发送的信息必须在内存中保 留。而此MIS的服务端中有一个负责安全校验的全局Filter，每当接收到请求时，均会更新一次最后的操作时间，并且将这个时间同步到所有的节点中，使得一个用户在一段时间内不能在多台机器上登录。在服务使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间的网络交互非常频繁。当网络情况不能满足传输要求时，重发数据在内存中不断地堆积，很快就产生了内存溢出。</p><p>&emsp;&emsp;这个案例中的问题，既有JBossCache的缺陷，也有MIS系统实现方式上的缺陷。JBossCache官方的maillist中讨论过很多次类似的内存溢出异常问题，据说后续版本有了改进。而更重要的缺陷是这一类被集群共享的数据如果要使用类似JBossCache这种集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动作不会耗费多少资源，但不应当有过于频繁的写操作，这会带来很大的网络同步的开销。</p><h3 id="2-3-堆外内存导致的溢出错误"><a href="#2-3-堆外内存导致的溢出错误" class="headerlink" title="2.3 堆外内存导致的溢出错误"></a><strong>2.3 堆外内存导致的溢出错误</strong></h3><p>&emsp;&emsp;这是一个学校的小型项目：基于B/S的电子考试系统，为了实现客户端能实时地从服务端接收考试数据，系统使用了逆向AJAX技术（也称为Comet或Server Side Push），选用CometD 1.1.1作为服务端推送框架，服务器是Jetty 7.1.4，硬件为一台普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统。</p><p>&emsp;&emsp;测试期间发现服务端不定时抛出内存溢出异常，服务器不一定每次都会出现异常，但假如正式考试时崩溃一次，那估计整场电子考试都会乱套，网站管理员尝试过把堆开到最大，32位系统最多到1.6GB基本无法再加大了，而且开大了也基本没效果，抛出内存溢出异常好像更加频繁了。加入-XX: +HeapDumpOnOutOfMemoryError，居然也没有任何反应，抛出内存溢出异常时什么文件都没有产生。无奈之下只好挂着jstat使劲盯屏幕，发现GC并不频繁，Eden 区、Survivor区、老年代及永久代内存全部都表示“情绪稳定，压力不大”，但照样不停地抛出内存溢出异常，管理员压力很大。最后，在内存溢出后从系统日志中找到异常堆栈，如代码清单5-1所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">1</span> 异常堆栈<span class="number">1</span></span><br><span class="line">[org<span class="selector-class">.eclipse</span><span class="selector-class">.jetty</span><span class="selector-class">.util</span><span class="selector-class">.log</span>]handle failed java<span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>：null</span><br><span class="line">at sun<span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.allocateMemory</span>(Native Method)</span><br><span class="line">at java<span class="selector-class">.nio</span><span class="selector-class">.DirectByteBuffer</span>.&lt;init&gt;(DirectByteBuffer.java：<span class="number">99</span>)</span><br><span class="line">at java<span class="selector-class">.nio</span><span class="selector-class">.ByteBuffer</span><span class="selector-class">.allocateDirect</span>(ByteBuffer.java：<span class="number">288</span>)</span><br><span class="line">at org<span class="selector-class">.eclipse</span><span class="selector-class">.jetty</span><span class="selector-class">.io</span><span class="selector-class">.nio</span><span class="selector-class">.DirectNIOBuffer</span>.&lt;init&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果认真阅读过本书的第2章，看到异常堆栈就应该清楚这个内存溢出异常是怎么回事了。大家知道操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位Windows平台的限制是2GB，其中给了Java堆1.6GB，而Direct Memory并不算在1.6GB的堆之内，因此它只能在剩余的0.4GB空间中分出一部分。在此应用中导致溢出的关键是：垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能像新生代和老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。否则，它只能等到抛出内存溢出异常时，先catch掉，再在catch块里面“大喊”一声：“System.gc()！”。要是虚拟机还是不听（譬如打开了-XX:+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。而本案例中使用的CometD 1.1.1框架，正好有大量的NIO操作需要用到Direct Memory。</p><p>&emsp;&emsp;从实践经验的角度出发，除了Java堆和永久代之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和会受到操作系统进程最大内存的限制：</p><blockquote><ul><li>Direct Memory：可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或OutOfMemoryError：Direct buffer memory。</li><li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或OutOfMemoryError：unable to create new native thread（横向无法分配，即无法建立新的线程）。</li><li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB的内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException：Too many open files异常。</li><li>JNI代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</li><li>虚拟机和GC：虚拟机和GC的代码执行也要消耗一定的内存。</li></ul></blockquote><h3 id="2-4-外部命令导致系统缓慢"><a href="#2-4-外部命令导致系统缓慢" class="headerlink" title="2.4 外部命令导致系统缓慢"></a><strong>2.4 外部命令导致系统缓慢</strong></h3><p>&emsp;&emsp;这是一个来自网络的案例：一个数字校园应用系统，运行在一台4个CPU的Solaris 10操作系统上，中间件为GlassFish服务器。系统在进行大并发压力测试的时候，发现请求响应时间比较慢，通过操作系统的mpstat工具发现CPU使用率很高，并且占用绝大多数CPU资源的程序并不是应用系统本身。这是个不正常的现象，通常情况下用户应用的CPU占用率应该占主要地位，才能说明系统是正常工作的。</p><p>&emsp;&emsp;通过Solaris 10的Dtrace脚本可以查看当前情况下哪些系统调用花费了最多的CPU资源，Dtrace运行后发现最消耗CPU资源的竟然是“fork”系统调用。众所周知，“fork”系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码最多只有线程的概念，不应当有进程的产生。</p><p>&emsp;&emsp;这是个非常异常的现象。通过本系统的开发人员最终找到了答案：每个用户请求的处理都需要执行一个外部shell脚本来获得系统的一些信息。执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式可以达到目的，但是它在Java虚拟机中非常消耗资源，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。Java虚拟机执行这个命令的过程是：首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU，内存的负担也很重。</p><p>&emsp;&emsp;用户根据建议去掉这个shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快就恢复了正常。</p><h3 id="2-5-服务器JVM进程崩溃"><a href="#2-5-服务器JVM进程崩溃" class="headerlink" title="2.5 服务器JVM进程崩溃"></a><strong>2.5 服务器JVM进程崩溃</strong></h3><p>&emsp;&emsp;一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP系统，服务器是 WebLogic 9.2（就是第二个案例中的那套系统）。正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid###.log文件后，进程就消失了，两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日志中注意到，每个节点的虚拟机进程在崩溃前不久，都发生过大量相同的异常，见代码清单5-2。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">2</span> 异常堆栈<span class="number">2</span></span><br><span class="line">java<span class="selector-class">.net</span><span class="selector-class">.SocketException</span>：Connection reset</span><br><span class="line">at java<span class="selector-class">.net</span><span class="selector-class">.SocketInputStream</span><span class="selector-class">.read</span>(SocketInputStream.java：<span class="number">168</span>)</span><br><span class="line">at java<span class="selector-class">.io</span><span class="selector-class">.BufferedInputStream</span><span class="selector-class">.fill</span>(BufferedInputStream.java： <span class="number">218</span>)</span><br><span class="line">at java<span class="selector-class">.io</span><span class="selector-class">.BufferedInputStream</span><span class="selector-class">.read</span>(BufferedInputStream.java：<span class="number">235</span>)</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.axis</span><span class="selector-class">.transport</span><span class="selector-class">.http</span><span class="selector-class">.HTTPSender</span><span class="selector-class">.readHeadersFromSocket</span>(HTTPSe <span class="number">583</span>)</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.axis</span><span class="selector-class">.transport</span><span class="selector-class">.http</span><span class="selector-class">.HTTPSender</span><span class="selector-class">.invoke</span>(HTTPSender.java： <span class="number">143</span>)</span><br><span class="line">……<span class="number">99</span> more</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是一个远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的待办事项变化时，要通过Web服务通知OA门户系统，把待办事项的变化同步到OA门户之中。通过SoapUI测试了一下同步待办事项的几个Web服务，发现调用后竟然需要长达3分钟才能返回，并且返回的结果都是连接中断。</p><p>&emsp;&emsp;由于MIS系统的用户多，待办事项变化很快，为了不被OA系统的速度拖累，使用了异步的方式调用Web服务，但由于两边服务的速度完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后使得虚拟机进程崩溃。通知OA门户方修复无法使用的集成接口，并将异步调用改为生产者/消费者模式的消息队列实现后，系统恢复正常。</p><h3 id="2-6-不恰当数据结构导致内存占用过大"><a href="#2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="2.6 不恰当数据结构导致内存占用过大"></a><strong>2.6 不恰当数据结构导致内存占用过大</strong></h3><p>&emsp;&emsp;例如，有一个后台RPC服务器，使用64位虚拟机，内存配置为-Xms4g -Xmx8g -Xmnlg，使用ParNew+CMS的收集器组合。平时对外服务的Minor GC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap&lt;Long, Long&gt;Entry，在这段时间里面Minor GC就会造成超过500毫秒的停顿，这个时间就有些接受不了了，具体情况如下面GC日志所示。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">95</span>(full <span class="number">4</span>):</span><br><span class="line">    par new generation total 903168K,used 803142K[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    eden space 802816K，<span class="number">100</span>%used[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaadf770000</span>)</span><br><span class="line">    from space 100352K，<span class="number">0</span>%used[<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae59c1910</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    to space 100352K，<span class="number">0</span>%used[<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaae5970000</span>)</span><br><span class="line">    concurrent mark-sweep generation total 5845540K,used 3898978K[<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aac507f9000</span>，<span class="number">0x00002aacae770000</span>)</span><br><span class="line">    concurrent-mark-sweep perm gen total 65536K,used 40333K[<span class="number">0x00002aacae770000</span>，<span class="number">0x00002aacb2770000</span>，<span class="number">0x00002aacb2770000</span>)</span><br><span class="line">    <span class="number">2011</span>-<span class="number">10</span>-<span class="number">28</span> T <span class="number">11</span>:<span class="number">40</span>:<span class="number">45.162</span>+<span class="number">0800</span>: <span class="number">226.504</span>:[GC <span class="number">226.504</span>: [ParNew:803142K-&gt;100352K(903168K)，<span class="number">0.5995670</span> secs] 4702120K-&gt; 4056332K(6748708K)，<span class="number">0.5997560</span> secs][<span class="built_in">Times</span>:user=<span class="number">1.46</span> sys=<span class="number">0.04</span>，real=<span class="number">0.60</span> secs]</span><br><span class="line">    Heap after GC invocations=<span class="number">96</span>(full <span class="number">4</span>):</span><br><span class="line">    par new generation total 903168K,used 100352K[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    eden space 802816K，<span class="number">0</span>%used[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaadf770000</span>)</span><br><span class="line">    from space 100352K，<span class="number">100</span>%used[<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae5970000</span>)</span><br><span class="line">    to space 100352K，<span class="number">0x00002aaaebb70000</span>)<span class="number">0</span>%used[<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae5970000</span>，</span><br><span class="line">    concurrent mark-sweep generation total 5845540K,used 3955980K[<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aac507f9000</span>，<span class="number">0x00002aacae770000</span>)</span><br><span class="line">    concurrent-mark-sweep perm gen total 65536K,used 40333K[<span class="number">0x00002aacae770000</span>，<span class="number">0x00002aacb2770000</span>，<span class="number">0x00002aacb2770000</span>)</span><br><span class="line">&#125;</span><br><span class="line">Total time for which application threads were stopped:<span class="number">0.6070570</span> seconds</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;观察这个案例，发现平时的Minor GC时间很短，原因是新生代的绝大部分对象都是可清除的，在Minor GC之后Eden和Survivor基本上处于完全空闲的状态。而在分析数据文件期间，800MB的Eden空间很快被填满从而引发GC，但Minor GC之后，新生代中绝大部分对象依然是存活的。我们知道ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确就成为一个沉重的负担，因此导致GC暂停时间明显变长。</p><p>&emsp;&emsp;如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑将Survivor空间去掉（加入参数-XX:SurvivorRatio=65536、-XX:MaxTenuringThreshold=0或者-XX:+AlwaysTenure），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再清理它们。这种措施可以治标，但也有很大副作用，治本的方案需要修改程序，因为这里的问题产生的根本原因是用HashMap&lt;Long, Long&gt;结构来存储数据文件空间效率太低。</p><p>&emsp;&emsp;下面具体分析一下空间效率。在HashMap&lt;Long, Long&gt;结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16B（2×8B）。这两个长整型数据包装成java.lang.Long对象之后，就分别具有8B的MarkWord、8B的Klass指针，在加8B存储数据的long值。在这两个Long对象组成Map.Entry之后，又多了16B的对象头，然后一个8B的next字段和4B的int型的hash字段，为了对齐，还必须添加4B的空白填充，最后还有HashMap中对这个Entry的8B的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24B)×2) + Entry(32B) + HashMap Ref (8B) = 88B，空间效率为16B/88B=18%，实在太低了。</p><h3 id="2-7-由Windows虚拟内存导致的长时间停顿"><a href="#2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="2.7 由Windows虚拟内存导致的长时间停顿"></a><strong>2.7 由Windows虚拟内存导致的长时间停顿</strong></h3><p>&emsp;&emsp;例如，有一个带心跳检测功能的GUI桌面程序，每15秒会发送一次心跳检测信号，如果对方30秒以内都没有信号返回，那就认为和对方程序的连接已经断开。程序上线后发现心跳检测有误报的概率，查询日志发现误报的原因是程序会偶尔出现间隔约一分钟左右的时间完全无日志输出，处于停顿状态。</p><p>&emsp;&emsp;因为是桌面程序，所需的内存并不大（-Xmx256m），所以开始并没有想到是GC导致的程序停顿，但是加入参数-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps Xloggc:gclog.log后，从GC日志文件中确认了停顿确实是由GC导致的，大部分GC时间都控制在100毫秒以内，但偶尔就会出现一次接近1分钟的GC。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0112389</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0001335</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0003246</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">41.4731411</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0489481</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.1110761</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0007286</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0001268</span> seconds</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从GC日志中找到长时间停顿的具体日志信息（添加了-XX:+PrintReferenceGC参数），找到的日志片段如下所示。从日志中可以看出，真正执行GC动作的时间不是很长，但从准备开始GC，到真正开始GC之间所消耗的时间却占了绝大部分。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2012-08-29T19：14：30.968+0800：10069.800：[<span class="string">GC10099.225：[SoftReference，0 refs，0.0000109 secs</span>]10099.226：[<span class="string">WeakReference，4072 refs，0.0012099 secs</span>]10099.227：[<span class="string">FinalReference，984 refs，1.5822450 secs</span>]10100.809：[<span class="string">PhantomReference，251 refs，0.0001394 secs</span>]10100.809：[<span class="string">JNI Weak Reference，0.0994015 secs</span>] [<span class="string">PSYoungGen：175672K-＞8528K（167360K）</span>]251523K-＞100182K（353152K），31.1580402 secs][Times：user=0.61 sys=0.52，real=31.16 secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除GC日志之外，还观察到这个GUI程序内存变化的一个特点，当它最小化的时候，资源管理中显示的占用内存大幅度减小，但是虚拟内存则没有变化，因此怀疑程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生GC时就有可能因为恢复页面文件的操作而导致不正常的GC停顿。</p><p>&emsp;&emsp;在MSDN上查证后确认了这种猜想，因此，在Java的GUI程序中要避免这种现象，可以加入参数“-Dsun.awt.keepWorkingSetOnMinimize=true”来解决。这个参数在许多AWT的程序上都有应用，例如JDK自带的Visual VM，用于保证程序在恢复最小化时能够立即响应。在这个案例中加入该参数后，问题得到解决。</p><hr><h2 id="第三节-实战：Eclipse运行速度调优"><a href="#第三节-实战：Eclipse运行速度调优" class="headerlink" title="第三节 实战：Eclipse运行速度调优"></a><strong>第三节 实战：Eclipse运行速度调优</strong></h2><p>&emsp;&emsp;很多Java开发人员都有这样一种观念：系统调优的工作都是针对服务端应用而言的，规模越大的系统，需要越专业的调优运维团队参与。这个观点不能说不对，上一节中作者所列举的案例确实都是服务端运维和调优的例子，但服务端应用需要调优，并不说明其他应用就不需要了，作为一个普通的Java开发人员，前面讲的各种 虚拟机的原理和最佳实践的方法距离我们并不遥远，开发者身边的很多场景都可以使用上面这些知识。下面就通过一个普通程序员日常工作中可以随时接触到的开发工具开始这次实战。</p><h3 id="3-1-调优前的程序运行状态"><a href="#3-1-调优前的程序运行状态" class="headerlink" title="3.1 调优前的程序运行状态"></a><strong>3.1 调优前的程序运行状态</strong></h3><p>&emsp;&emsp;作者使用Eclipse 3.5作为日常工作中的主要IDE工具，由于安装的插件比较大（如 Klocwork、ClearCase LT等）、代码也很多，启动Eclipse直到所有项目编译完成需要四五分钟。一直对开发环境的速度感到不满意，趁着编写这本书的机会，决定对Eclipse进行“动刀”调优。</p><p>&emsp;&emsp;作者机器的Eclipse运行平台是32位Windows 7系统，虚拟机为HotSpot VM 1.5 b64，硬件为ThinkPad X201，Intel i5 CPU，4GB物理内存。在初始的配置文件eclipse.ini中，除了指定JDK的路径、设置最大堆为512MB及开启了JMX管理（需要在VisualVM中收集原始数据）外，未作任何改动，原始配置内容如代码清单5-3 所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">3</span> Eclipse <span class="number">3.5</span>初始配置</span><br><span class="line">-vm</span><br><span class="line">D：/_DevSpace/jdk1.<span class="number">5.0</span>/bin/javaw.exe</span><br><span class="line">-startup</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher_1</span>.<span class="number">0.201</span><span class="selector-class">.R35x_v20090715</span><span class="selector-class">.jar</span></span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher</span><span class="selector-class">.win32</span><span class="selector-class">.win32</span><span class="selector-class">.x86_1</span>.<span class="number">0.200</span>.v20090519</span><br><span class="line">-product</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.epp</span><span class="selector-class">.package</span><span class="selector-class">.jee</span><span class="selector-class">.product</span></span><br><span class="line">--launcher.XXMaxPermSize</span><br><span class="line"><span class="number">256</span>M</span><br><span class="line">-showsplash</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.platform</span></span><br><span class="line">-vmargs</span><br><span class="line">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span><br><span class="line">-Xmx512m</span><br><span class="line">-Dcom<span class="selector-class">.sun</span><span class="selector-class">.management</span><span class="selector-class">.jmxremote</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了与调优后的结果进行量化对比，调优开始前作者先做了一次初始数据测试。测试用例很简单，就是收集从Eclipse启动开始，直到所有插件加载完成为止的总耗时及运行状态数据，虚拟机的运行数据通过VisualVM及其扩展插件VisualGC进行采集。测试过程中反复启动Eclipse数次直到测试结果稳定后，取最后一次运行的结果作为数据样本（为了避免操作系统未能及时进行磁盘缓存而产生的影响），数据样本如图5-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010102.png" alt="Eclipse原始运行数据"></p><p>&emsp;&emsp;Eclipse启动的总耗时没有办法从监控工具中直接获得，因为VisualVM不可能知道Eclipse运行到什么阶段才算是启动完成。为了保证测试的准确性，作者写了一个简单的Eclipse插件，用于统计Eclipse的启动耗时。由于代码很简单，并且本书不是Eclispe RCP的开发教程，所以只列出代码清单5-4供读者参考，不再延伸讲解。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--代码清单<span class="number">5</span><span class="number">-4</span> Eclipse启动耗时统计插件ShowTime.java代码：</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.jface.dialogs.MessageDialog;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.swt.widgets.Display;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.swt.widgets.Shell;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.ui.IStartup;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*统计Eclipse启动耗时</span></span><br><span class="line"><span class="comment">*@author zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowTime</span> <span class="keyword">implements</span> <span class="title">IStartup</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> earlyStartup()&#123;</span><br><span class="line">        Display.getDefault().syncExec(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                long eclipseStartTime = Long.parseLong(System.getProperty(<span class="string">"eclipse.startTime"</span>));</span><br><span class="line">                long costTime = System.currentTimeMillis() - eclipseStartTime;</span><br><span class="line">                Shell shell = Display.getDefault().getActiveShell();</span><br><span class="line">                String message = <span class="string">"Eclipse启动耗时："</span> + costTime+<span class="string">"ms"</span>;</span><br><span class="line">                MessageDialog.openInformation(shell, <span class="string">"Information"</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--plugin.xml代码：</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span>encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;?eclipse version=<span class="string">"3.4"</span>?&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;extension point=<span class="string">"org.eclipse.ui.startup"</span>&gt;</span><br><span class="line">        &lt;startup <span class="class"><span class="keyword">class</span>="<span class="title">eclipsestarttime</span>.<span class="title">actions</span>.<span class="title">ShowTime</span>"/&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">extension</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码打包成jar后放到Eclipse的plugins目录中，反复启动几次后，插件显示的平均时间稳定在15秒左右，如图5-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010103.png" alt="耗时统计插件运行效果"></p><p>&emsp;&emsp;根据VisualGC和Eclipse插件收集到的信息，总结原始配置下的测试结果如下：</p><blockquote><ul><li>整个启动过程平均耗时约15秒。</li><li>最后一次启动的数据样本中，垃圾收集总耗时4.149秒，其中：Full GC被触发了19次，共耗时3.166秒；Minor GC被触发了378次，共耗时0.983秒。</li><li>加载类9115个，耗时4.114秒。</li><li>JIT的编译时间为1.999秒。</li><li>虚拟机512MB的堆内存被分配为40MB的新生代（31.5MB的Eden空间和2个4MB的 Surviver空间）及472MB的老年代。</li></ul></blockquote><p>&emsp;&emsp;客观地说，由于机器硬件还不错（请读者以2010年普通PC机的标准来衡量），15秒的启动时间其实还在可接受的范围以内，但是从VisualGC中反映的数据来看，主要问题是非用户程序时间（图5-2中的Compile Time、Class Loader Time、GC Time）非常高，占了整个启动过程耗时的一半以上（这里存在少许夸张成分，因为<br>如果JIT编译等动作是在后台线程完成的，用户程序在此期间也正常执行，所以并没有占用一半以上的绝对时间）。虚拟机后台占用太多时间也直接导致Eclipse在启动后的使用过程中经常有停顿的感觉，所以进行调优有较大的价值。</p><h3 id="3-2-升级JDK-1-6的性能变化及兼容问题"><a href="#3-2-升级JDK-1-6的性能变化及兼容问题" class="headerlink" title="3.2 升级JDK 1.6的性能变化及兼容问题"></a><strong>3.2 升级JDK 1.6的性能变化及兼容问题</strong></h3><p>&emsp;&emsp;对Eclipse进行调优的第一步就是先把虚拟机的版本做个升级，希望能先从虚拟机 版本上得到一些“免费的”性能提升。</p><p>&emsp;&emsp;每次JDK的大版本发布时，开发商肯定都会宣称虚拟机的运行速度比上一版本有了很大的提高，这虽然是个广告性质的宣言，经常被人从升级列表或技术白皮书中直接忽略过去，但从国内外的第三方评测数据来看，版本升级在某些方面确实带来了一定的性能改善，以下是一个第三方网站对JDK 1.5、1.6、1.7三个版本做的性能评测，分别测试了以下四个用例：</p><blockquote><ul><li>生成500万个字符串。</li><li>500万次ArrayList<string>数据插入，使用第一点生成的数据。</string></li><li>生成500万个HashMap&lt;String, Integer&gt;，每个键-值对通过并发线程计算，测试并发能力。</li><li>打印500万个ArrayList<string>中的值到文件，并重读回内存。</string></li></ul></blockquote><p>&emsp;&emsp;三个版本的JDK分别运行这些用例的测试程序，测试结果如图5-4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010104.png" alt="JDK横向性能对比"></p><p>&emsp;&emsp;从这4个用例的测试结果来看，JDK 1.6比1.5有大约15%的性能提升，尽管对JDK仅测试这4个用例并不能说明什么问题，需要通过测试数据来量化描述一个JDK比旧版提升了多少是很难做到非常科学准确的（要做稍微靠谱一点的测试，可以使用SPECjvm2008来完成，或者把相应版本的TCK中数万个测试用例的性能数据对比一<br>下可能更有说服力），但我还是选择相信这次“软广告”性质的测试，把JDK版本升级到1.6 Update 21，升级的最主要理由是：本书是基于JDK 1.6编写的。</p><p>&emsp;&emsp;这次升级到JDK 1.6之后，性能有什么变化暂且不谈，在使用几分钟之后，作者的Eclipse就和前面几个服务端的案例一样“不负众望”地发生了内存溢出，如图5-5所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010105.png" alt="Eclipse OutOfMemoryError"></p><p>&emsp;&emsp;这次内存溢出完全出乎作者的意料：决定对Eclipse做调优是因为速度慢，但开发环境一直都很稳定，至少没有出现过内存溢出的问题，而这次升级除了eclipse.ini中的JVM路径改了之外，还未进行任何运行参数的调整，进到Eclipse主界面之后随便开了几个文件居然就抛出内存溢出异常了，难道JDK 1.6 Update21有哪个API出现了严重的泄漏问题吗？</p><p>&emsp;&emsp;事实上并不是JDK 1.6出现了什么问题，根据前面讲解的原理和工具，我们要查明这个异常的原因并且解决它一点也不困难。打开VisualVM，监视页签中的内存曲线部分，如图5-6和图5-7所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010106.png" alt="Java堆监视曲线"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010107.png" alt="永久代监视曲线"></p><p>&emsp;&emsp;在Java堆的监视曲线里，“堆大小”曲线与“使用的堆”曲线一直都有很大的间隔距离，每当两条曲线开始出现互相靠近的趋势时，“最大堆”曲线就会快速向上转向，而“使用的堆”曲线会向下转向。“最大堆”曲线向上是虚拟机内部在进行堆扩容，运行参数中并没有指定最小堆（-Xms）的值与最大堆（-Xmx）相等，所以堆容量一开始并没有扩展到最大值，而是根据使用情况进行伸缩扩展。“使用的堆”曲线向下是因为虚拟机内部触发了一次垃圾收集，一些废弃对象的空间被回收后，内存用量相应少，从图形上看，Java堆运作是完全正常的。但永久代的监视曲线就很有问题了，“PermGen大小”曲线与“使用的PermGen”曲线几乎完全重合在一起，这说明永久代中没有可回收的资源，所以“使用的PermGen”曲线不会向下发展，永久代中也没有空间可以扩展，所以“PermGen大小”曲线不能向上扩展。那么这次很明显是永久代导致的内存溢出。</p><p>&emsp;&emsp;再注意看图5-7中永久代的最大容量：“67，108，864个字节”，也就是64MB，这恰好是JDK在未使用-XX:MaxPermSize参数明确指定永久代最大容量时的默认值，无论JDK 1.5还是JDK 1.6，这个默认值都是64MB。对于Eclipse这种规模的Java程序来说，64MB的永久代内存空间显然是不够的，溢出很正常，那为何在JDK 1.5中没有发生过溢出呢？</p><p>&emsp;&emsp;在VisualVM的“概述-JVM参数”页签中，分别检查使用JDK 1.5和JDK 1.6运行Eclipse时的JVM参数，发现使用JDK 1.6时只有以下3个JVM参数，如代码清单5-5 所示。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-5 JDK 1.6的Eclipse运行期参数</span><br><span class="line">-<span class="ruby">Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而使用JDK 1.5运行时有4个JVM参数，其中多出来的一个正好就是设置永久代最大 容量的-XX：MaxPermSize=256M，如代码清单5-6所示。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-6 JDK 1.5的Eclipse运行期参数</span><br><span class="line">-<span class="ruby">Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br><span class="line"><span class="ruby">-XX：MaxPermSize=<span class="number">256</span>M</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为什么会这样呢？作者从Eclipse的Bug List网站上找到答案：使用JDK 1.5时之所以有永久代容量这个参数，是因为在eclipse.ini中存在“-launcher.XXMaxPermSize 256M”这项设置，当launcher—Windows下的可执行程序eclipse.exe检测到是Eclipse运行在Sun公司的虚拟机上的话，就会把参数值转化为-XX:MaxPermSize传递给虚拟机进程，因为三大商用虚拟机中只有Sun系列的虚拟机才有永久代的概念，即只有HotSpot虚拟机需要设置这个参数，JRockit虚拟机和IBM J9虚拟机都不需要设置。</p><p>&emsp;&emsp;2010年4月10日，Oracle正式完成了对Sun的收购，此后无论是网页还是具体的程序产品，提供商都从Sun变为了Oracle，而eclipse.exe就是根据程序提供商判断是否是Sun的虚拟机，当JDK 1.6 Update21中java.exe、javaw.exe 的“Company”属性从“Sun Microsystems Inc.”变为“Oracle Corporation”之后，Eclipse就完全不认识这个虚拟机了，因此没有把最大永久代的参数传递过去。</p><p>&emsp;&emsp;了解原因之后，解决方案就简单了，launcher不认识就只好由人来告诉它，在eclipse.ini中明确指定-XX：MaxPermSize=256M这个参数就可以了。</p><h3 id="3-3-编译时间和类加载时间的优化"><a href="#3-3-编译时间和类加载时间的优化" class="headerlink" title="3.3 编译时间和类加载时间的优化"></a><strong>3.3 编译时间和类加载时间的优化</strong></h3><p>&emsp;&emsp;从Eclipse启动时间上看，升级到JDK 1.6所带来的性能提升是……嗯？基本上没有 提升？多次测试的平均值与JDK 1.5的差距完全在实验误差范围之内。</p><p>&emsp;&emsp;各位读者不必失望，Sun JDK 1.6性能白皮书描述的众多相对于JDK 1.5的提升不至于全部是广告，虽然总启动时间没有减少，但在查看运行细节的时候，却发现了一件很值得注意的事情：在JDK 1.6中启动完Eclipse所消耗的类加载时间比JDK 1.5长了接近一倍，不要看反了，这里写的是1.6的类加载比1.5慢一倍，测试结果 如代码清单5-7所示，反复测试多次仍然是相似的结果。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-7</span> JDK <span class="number">1.5</span>和<span class="number">1.6</span>中的类加载时间对比</span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.6</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">3552</span></span><br><span class="line"><span class="number">6372</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">6900</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">6372</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">7917</span> <span class="number">10190.3</span> <span class="number">0</span> <span class="number">0.0</span> <span class="number">8.18</span></span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.5</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">3552</span></span><br><span class="line"><span class="number">7272</span> Jps</span><br><span class="line"><span class="number">7216</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">7216</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">7902</span> <span class="number">9691.2</span> <span class="number">3</span> <span class="number">2.6</span> <span class="number">4.34</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在本例中类加载时间上的差距并不能作为一个普遍性的测试结果去说明JDK 1.6的类加载必然比1.5慢，作者测试了自己机器上的Tomcat和ClassFish启动过程，并没有出现类似的差距。在国内最大的Java社区中，作者发起过关于此问题的讨论，从参与者反馈的测试结果来看，此问题只在一部分机器上存在，而且JDK 1.6的各<br>个update版之间也存在很大差异。</p><p>&emsp;&emsp;多次试验后，发现在作者机器上的两个JDK进行类加载时，字节码验证部分的耗时差 距尤其严重。考虑到实际情况：Eclipse使用者甚多，它的编译代码我们认为是可靠的，不需要在加载的时候再进行字节码验证，因此通过参数-Xverify:none禁止掉字节码验证过程也可作为一项优化措施。加入这个参数后，两个版本的JDK类加载速度都有所提高，JDK 1.6的类加载速度仍然比1.5慢，但是两者的耗时已经接近了许多，测试数据如代码清单5-8所示。关于类与类加载的话题，譬如刚刚提到的字节码验证是怎么回事，本书专门规划了两个章节进行详细讲解，在此不再延伸。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-8</span> JDK <span class="number">1.5</span>和<span class="number">1.6</span>中取消字节码验证后的类加载时间对比</span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.6</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">5512</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">5596</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">5512</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">6749</span> <span class="number">8837.0</span> <span class="number">0</span> <span class="number">0.0</span> <span class="number">3.94</span></span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.5</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">4724</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">5412</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">4724</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">6885</span> <span class="number">9109.7</span> <span class="number">3</span> <span class="number">2.6</span> <span class="number">3.10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在取消字节码验证之后，JDK 1.5的平均启动时间降到了13秒，而JDK 1.6的测试数 据平均比JDK 1.5快1秒，平均下降到12秒左右，如图5-8所示。在类加载时间仍然落后的情况下，依然可以看到JDK 1.6在性能上比JDK 1.5略有优势，说明至少在Eclipse启动这个测试用例上，升级JDK版本确实能带来一些“免费的”性能提升。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010108.png" alt="运行在JDK 1.6下取消字节码验证的启动时间"></p><p>&emsp;&emsp;前面说过，除了类加载时间以外，在VisualGC的监视曲线中显示了两项很大的非用户程序耗时：编译时间（Compile Time）和垃圾收集时间（GC Time）。垃圾收集时间读者应该非常清楚了，而编译时间是什么？程序在运行之前不是已经编译了吗？虚拟机的JIT编译与垃圾收集一样，是本书的一个重要部分，后面有专门章节讲解，这里先简单介绍一下：<strong>编译时间</strong>是指虚拟机的<strong>JIT编译器</strong>（Just In Time Compiler）编译<strong>热点代码</strong>（Hot Spot Code）的耗时。我们知道Java语言为了实现跨平台的特性，Java代码编译出来后形成的Class文件中储存的是字节码（ByteCode），虚拟机通过解释方式执行字节码命令，比起C/C++编译成本地二进制代码来说，速度要慢不少。为了解决程序解释执行的速度问题，JDK 1.2以后，虚拟机内置了两个运行时编译器，如果一段Java方法被调用的次数到达一定程度，就会被判定为热代码，从而交给JIT编译器即时编译为本地代码，以提高运行速度（这就是HotSpot虚拟机名字的由来）。甚至有可能在运行期动态编译比C/C++的编译器静态编译出来的代码更优秀，因为运行期可以收集很多编译器无法知道的信息，甚至可以采用一些很激进的优化手段，在优化条件不成立的时候再逆优化退回来。所以Java程序只要代码没有问题（主要是泄漏问题，如内存泄漏、连接泄漏），随着代码被编译得越来越彻底，运行速度应当是越来越快。Java运行期编译最大的缺点就是编译需要消耗程序正常的运行时间，也就是上面所说的“编译时间”。</p><p>&emsp;&emsp;虚拟机提供了一个参数-Xint禁止编译器运作，强制虚拟机对字节码采用纯解释方式执行。如果读者想使用这个参数省下Eclipse启动中那2秒的编译时间获得一个“更好看”的成绩的话，那恐怕要失望了，加上这个参数之后虽然编译时间确实下降到0，但Eclipse启动的总时间将剧增到27秒。看来这个参数现在最大的作用就是让用户缅怀一下JDK 1.2之前那令人心酸和心碎的运行速度。</p><p>&emsp;&emsp;与解释执行相对应的另一方面，虚拟机还有力度更强的编译器：当虚拟机运行在client模式的时候，使用的是一个代号为C1的轻量级编译器，另外还有一个代号为C2的相对重量级的编译器，它能提供更多的优化措施。如果使用-server模式的虚拟机启动Eclipse将会用到C2编译器，这时从VisualGC可以看到启动过程中虚拟机 使用了超过15秒的时间去进行代码编译。如果读者的工作习惯是长时间不关闭Eclipse的话，C2编译器所消耗的额外编译时间最终还是会在运行速度的提升之中赚回来，这样使用-server模式也是一个不错的选择。不过至少在本次实战中，我们还是继续选用-client虚拟机来运行Eclipse。</p><h3 id="3-4-调整内存设置控制垃圾收集频率"><a href="#3-4-调整内存设置控制垃圾收集频率" class="headerlink" title="3.4 调整内存设置控制垃圾收集频率"></a><strong>3.4 调整内存设置控制垃圾收集频率</strong></h3><p>&emsp;&emsp;三大块非用户程序时间中，还剩下GC时间没有调整，而GC时间却是其中最重要的一块，并不只是因为它是耗时最长的一块，更因为它是一个持续稳定的过程。由于我们所做的测试是在检测程序的启动时间，类加载和编译时间在这项测试中的影响力被大幅度放大了。在绝大多数的应用中，不可能出现持续不断的类被加载和卸载。 在程序运行一段时间后，热点方法不断被编译，新的热点方法数量也总会下降，但是垃圾收集是随着程序的运行而不断运作的，所以它对性能的影响才尤为重要。</p><p>&emsp;&emsp;在Eclipse启动的原始数据样本中，短短15秒类共发生了19次Full GC和378次 Minor GC，一共397次GC，共造成了超过4秒的停顿，也就是超过1/4的时间都是在进行垃圾收集，这个运行数据看起来实在是太糟糕了。</p><p>&emsp;&emsp;首先来解决新生代中的Minor GC，虽然GC的总时间只有不到1秒，但却发生了378次之多。从VisualGC的线程监视中看到Eclipse启动期间一共发起了超过70个线程，同时在运行的线程数超过25个，每当发生一次垃圾收集的动作，所有的用户线程都必须跑到最近的一个安全点（SafePoint），然后挂起线程等待垃圾回收。这样 过于频繁的GC就会导致很多没有必要的安全点检测、线程挂起及恢复操作。</p><p>&emsp;&emsp;新生代GC频繁发生，很明显是由于虚拟机分配给新生代的空间太小而导致的，Eden区加上一个Survivor区还不到35MB，因此很有必要使用-Xmn参数调整新生代的大小。</p><p>&emsp;&emsp;再来看一看那19次Full GC，看起来19次并“不多”（相对于378次Minor GC来说），但总共消耗了3.166秒，占了绝大部分的GC时间，降低GC时间的主要目标就 是降低这部分时间。从VisualGC的曲线图上看得不够精确，这次直接从GC日志中分析一下这些Full GC是如何产生的，代码清单5-9中是启动最开始的2.5秒内发生的 10次Full GC的记录。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-9</span> Full GC记录</span><br><span class="line"><span class="number">0.278</span>：[GC <span class="number">0.278</span>：[DefNew：<span class="number">574</span>K-＞<span class="number">33</span>K（<span class="number">576</span>K），<span class="number">0.0012562</span> secs]<span class="number">0.279</span>：[Tenured：<span class="number">1467</span>K-＞<span class="number">997</span>K（<span class="number">1536</span>K），<span class="number">0.0181775</span> secs]<span class="number">1920</span>K-＞ <span class="number">997</span>K（<span class="number">2112</span>K），<span class="number">0.0195257</span> secs]</span><br><span class="line"><span class="number">0.312</span>：[GC <span class="number">0.312</span>：[DefNew：<span class="number">575</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0004974</span> secs]<span class="number">0.312</span>：[Tenured：<span class="number">1544</span>K-＞<span class="number">1608</span>K（<span class="number">1664</span>K），<span class="number">0.0191592</span> secs]<span class="number">1980</span>K＞<span class="number">1608</span>K（<span class="number">2240</span>K），<span class="number">0.0197396</span> secs]</span><br><span class="line"><span class="number">0.590</span>：[GC <span class="number">0.590</span>：[DefNew：<span class="number">576</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0006360</span> secs]<span class="number">0.590</span>：[Tenured：<span class="number">2675</span>K-＞<span class="number">2219</span>K（<span class="number">2684</span>K），<span class="number">0.0256020</span> secs]<span class="number">3090</span>K＞<span class="number">2219</span>K（<span class="number">3260</span>K），<span class="number">0.0263501</span> secs]</span><br><span class="line"><span class="number">0.958</span>：[GC <span class="number">0.958</span>：[DefNew：<span class="number">551</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0011433</span> secs]<span class="number">0.959</span>：[Tenured：<span class="number">3979</span>K-＞<span class="number">3470</span>K（<span class="number">4084</span>K），<span class="number">0.0419335</span> secs]<span class="number">4222</span>K＞<span class="number">3470</span>K（<span class="number">4660</span>K），<span class="number">0.0431992</span> secs]</span><br><span class="line"><span class="number">1.575</span>：[Full GC <span class="number">1.575</span>：[Tenured：<span class="number">4800</span>K-＞<span class="number">5046</span>K（<span class="number">5784</span>K），<span class="number">0.0543136</span> secs]<span class="number">5189</span>K-＞<span class="number">5046</span>K（<span class="number">6360</span>K），[Perm：<span class="number">12287</span>K-＞<span class="number">12287</span>K（<span class="number">12288</span>K）]， <span class="number">0.0544163</span> secs]</span><br><span class="line"><span class="number">1.703</span>：[GC <span class="number">1.703</span>：[DefNew：<span class="number">703</span>K-＞<span class="number">63</span>K（<span class="number">704</span>K），<span class="number">0.0012609</span> secs]<span class="number">1.705</span>：[Tenured：<span class="number">8441</span>K-＞<span class="number">8505</span>K（<span class="number">8540</span>K），<span class="number">0.0607638</span> secs]<span class="number">8691</span>K＞<span class="number">8505</span>K（<span class="number">9244</span>K），<span class="number">0.0621470</span> secs]</span><br><span class="line"><span class="number">1.837</span>：[GC <span class="number">1.837</span>：[DefNew：<span class="number">1151</span>K-＞<span class="number">64</span>K（<span class="number">1152</span>K），<span class="number">0.0020698</span> secs]<span class="number">1.839</span>：[Tenured：<span class="number">14616</span>K-＞<span class="number">14680</span>K（<span class="number">14688</span>K），<span class="number">0.0708748</span> secs]<span class="number">15035</span>K-＞<span class="number">14680</span>K（<span class="number">15840</span>K），<span class="number">0.0730947</span> secs]</span><br><span class="line"><span class="number">2.144</span>：[GC <span class="number">2.144</span>：[DefNew：<span class="number">1856</span>K-＞<span class="number">191</span>K（<span class="number">1856</span>K），<span class="number">0.0026810</span> secs]<span class="number">2.147</span>：[Tenured：<span class="number">25092</span>K-＞<span class="number">24656</span>K（<span class="number">25108</span>K），<span class="number">0.1112429</span> secs]<span class="number">26172</span>K-＞<span class="number">24656</span>K（<span class="number">26964</span>K），<span class="number">0.1141099</span> secs]</span><br><span class="line"><span class="number">2.337</span>：[GC <span class="number">2.337</span>：[DefNew：<span class="number">1914</span>K-＞<span class="number">0</span>K（<span class="number">3136</span>K），<span class="number">0.0009697</span> secs]<span class="number">2.338</span>：[Tenured：<span class="number">41779</span>K-＞<span class="number">27347</span>K（<span class="number">42056</span>K），<span class="number">0.0954341</span> secs]<span class="number">42733</span>K-＞<span class="number">27347</span>K（<span class="number">45192</span>K），<span class="number">0.0965513</span> secs]</span><br><span class="line"><span class="number">2.465</span>：[GC <span class="number">2.465</span>：[DefNew：<span class="number">2490</span>K-＞<span class="number">0</span>K（<span class="number">3456</span>K），<span class="number">0.0011044</span> secs]<span class="number">2.466</span>：[Tenured：<span class="number">46379</span>K-＞<span class="number">27635</span>K（<span class="number">46828</span>K），<span class="number">0.0956937</span> secs]<span class="number">47621</span>K-＞<span class="number">27635</span>K（<span class="number">50284</span>K），<span class="number">0.0969918</span> secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;括号中的数字代表着老年代的容量，这组GC日志显示了10次Full GC发生的原因全部都是老年代空间耗尽，每发生一次Full GC都伴随着一次老年代空间扩容：1536KB→1664KB→2684KB→……→42056KB→46828KB，10次GC以后老年代容量从起始的1536KB扩大到46828KB，当15秒后Eclipse启动完成时，老年代容量扩大到了103428KB，代码编译开始后，老年代容量达到顶峰473MB，整个Java堆达到最大容量512MB。</p><p>&emsp;&emsp;日志还显示有些时候内存回收状况很不理想，空间扩容成为获取可用内存的最主要手段，譬如，“Tenured：25092K→24656K（25108K），0.1112429 secs”代表老年代的当前容量为25108KB，内存使用到25092KB的时候发生Full GC，花费0.11秒把内存使用降低到24656KB，只回收了不到500KB的内存，这次GC基本没有什么回收效果，仅仅做了扩容，扩容过程比起回收过程可以看做是基本不需要花费时间的，所以说这0.11秒几乎是白白浪费了。</p><p>&emsp;&emsp;由上述分析可以得出结论：Eclipse启动时Full GC大多数是由于老年代容量扩展而导致的，由永久代空间扩展而导致的也有一部分。为了避免这些扩展所带来的性能浪费，我们可以把-Xms和-XX:PermSize参数值分别设置为-Xmx和-XX: PermSizeMax参数值，强制虚拟机在启动的时候就把老年代和永久代的容量固定下来，避免运行时自动扩展。</p><p>&emsp;&emsp;根据分析，优化计划确定为：把新生代容量提升到128MB，避免新生代频繁GC；把Java堆、永久代的容量分别固定为512MB和96MB，避免内存扩展。这几个数值都是根据机器硬件、Eclipse插件和工程数量来决定的，读者实战的时候应根据VisualGC中收集到的实际数据进行设置。改动后的eclipse.ini配置如代码清单510所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">10</span> 内存调整后的Eclipse配置文件</span><br><span class="line">-vm</span><br><span class="line">D：/_DevSpace/jdk1.<span class="number">6.0</span>_21/bin/javaw.exe</span><br><span class="line">-startup</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher_1</span>.<span class="number">0.201</span><span class="selector-class">.R35x_v20090715</span><span class="selector-class">.jar</span></span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher</span><span class="selector-class">.win32</span><span class="selector-class">.win32</span><span class="selector-class">.x86_1</span>.<span class="number">0.200</span>.v20090519</span><br><span class="line">-product</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.epp</span><span class="selector-class">.package</span><span class="selector-class">.jee</span><span class="selector-class">.product</span></span><br><span class="line">-showsplash</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.platform</span></span><br><span class="line">-vmargs</span><br><span class="line">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span><br><span class="line">-Xverify：<span class="attribute">none</span></span><br><span class="line">-Xmx512m</span><br><span class="line">-Xms512m</span><br><span class="line">-Xmn128m</span><br><span class="line">-XX：PermSize=<span class="number">96</span>m</span><br><span class="line">-XX：MaxPermSize=<span class="number">96</span>m</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在的这个配置之下，GC次数已经大幅度降低，图5-9是Eclipse启动后1分钟的监视曲线，只发生了8次Minor GC和4次Full GC，总耗时为1.928秒。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010109.png" alt="GC调整后的运行数据"></p><p>&emsp;&emsp;这个结果已经算是基本正常，但是还存在一点瑕疵：从Old Gen曲线上看，永久代直接固定在384MB，而内存使用量只有66MB，并且一直很平滑，完全不应该发生Full GC才对，那4次Full GC是怎么来的？使用jstat-gccause查询一下最近一次GC的原因，见代码清单5-11。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-11</span> 查询GC原因</span><br><span class="line">C：\Users\IcyFenix&gt;jps</span><br><span class="line"><span class="number">9772</span> Jps</span><br><span class="line"><span class="number">4068</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line">C：\Users\IcyFenix&gt;jstat-gccause <span class="number">4068</span></span><br><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT LGCC GCC</span><br><span class="line"><span class="number">0.00</span> <span class="number">0.00</span> <span class="number">1.00</span> <span class="number">14.81</span> <span class="number">39.29</span> <span class="number">6</span> <span class="number">0.422</span> <span class="number">20</span> <span class="number">5.992</span> <span class="number">6.414</span></span><br><span class="line">System.gc() No GC</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从LGCC（Last GC Cause）中看到原来是代码调用System.gc()显式触发的GC，在内存设置调整后，这种显式GC不符合我们的期望，因此在eclipse.ini中加入参数-XX:+DisableExplicitGC屏蔽掉System.gc()。再次测试发现启动期间的Full GC已经完全没有了，只有6次Minor GC，耗时417毫秒，与调优前4.149秒的测试样本相比，正好是十分之一。进行GC调优后Eclipse的启动时间下降非常明显，比整个GC时间降低的绝对值还大，现在启动只需要7秒多，如图5-10所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010110.png" alt="Eclipse启动时间"></p><h3 id="3-5-选择收集器降低延迟"><a href="#3-5-选择收集器降低延迟" class="headerlink" title="3.5 选择收集器降低延迟"></a><strong>3.5 选择收集器降低延迟</strong></h3><p>&emsp;&emsp;现在Eclipse启动已经比较迅速了，但我们的调优实战还没有结束，毕竟Eclipse是拿来写程序的，不是拿来测试启动速度的。我们不妨再在Eclipse中测试一个非常常用但又比较耗时的操作：代码编译。图5-11是当前配置下Eclipse进行代码编译时的运行数据，从图中可以看出，新生代每次回收耗时约65毫秒，老年代每次回收 耗时约725毫秒。对于用户来说，新生代GC的耗时还好，65毫秒在使用中无法察觉到，而老年代每次GC停顿的时间接近1秒钟，虽然比较长时间才会出现一次，但停顿还是太长了一些。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010111.png" alt="编译期间运行数据"></p><p>&emsp;&emsp;再注意看一下编译期间的CPU资源使用状况，图5-12是Eclipse在编译期间的CPU使用率曲线图，整个编译过程中平均只使用了不到30%的CPU资源，垃圾收集的CPU使用率曲线更是几乎与坐标横轴紧贴在一起，这说明CPU资源还有很多可利用的余地。</p><p>&emsp;&emsp;列举GC停顿时间、CPU资源富余的目的，都是为接下来替换掉Client模式的虚拟机 中默认的新生代及老年代串行收集器做铺垫。</p><p>&emsp;&emsp;Eclipse应当算是与使用者交互非常频繁的应用程序，由于代码太多，作者习惯在做全量编译或清理动作的时候，使用“Run in Backgroup”功能一边编译一边继续工作。回顾一下在第3章提到的几种收集器，很容易想到CMS是最符合这类场景的收集器。因此尝试在eclipse.ini中再加入两个参数-XX:+UseConcMarkSweepGC和XX:+UseParNewGC（ParNew收集器是使用CMS收集器后的默认新生代收集器，写上仅是为了使得配置更加清晰），要求虚拟机在新生代和老年代分别使用ParNew和CMS收集器进行垃圾回收。指定收集器之后，再次测试的结果如图5-13所示，与原来使用的串行收集器对比，新生代停顿从每次65毫秒下降到了每次53毫秒，而老年代的停顿时间更是从725毫秒大幅下降到了36毫秒。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010113.png" alt="指定ParNew和CMS收集器后的GC数据"></p><p>&emsp;&emsp;当然，CMS的停顿阶段只是收集过程中的一小部分，并不是真的把垃圾收集时间从 725毫秒变成36毫秒了。在GC日志中可以看到CMS与程序并发的时间约为400毫秒。不过由于CMS默认老年代使用了68%就进行收集，所以Full GC次数上升到了6次，为了避免总体吞吐量下降得太厉害，使用-XX:CMSInitiatingOccupancyFraction=85将GC临界值提升到85%，修改-XX:CMSInitiatingOccupancyFraction参数后，Full GC次数下降至3次，这样收集器的运作结果就比较令人满意了。</p><p>&emsp;&emsp;到这里为止，对于虚拟机内存的调优就基本结束了，这次实战可以看做是一次简化的服务端调优过程，服务端调优有可能还会出现在更多方面，如数据库、资源池、 磁盘I/O等，对于虚拟机内存部分的优化，与这次实战中的思路没有太大差别。即使读者实际工作中接触不到服务器，根据自己的工作环境做一些试验，总结几个参数让自己日常工作环境的速度有较大幅度的提升也是很划算的。最终eclipse.ini的配置如代码清单5-12所示。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-12 修改收集器配置后的Eclipse配置</span><br><span class="line">-<span class="ruby">vm</span></span><br><span class="line"><span class="ruby">D：/_DevSpace/jdk1.<span class="number">6.0_21</span>/bin/javaw.exe</span></span><br><span class="line"><span class="ruby">-startup</span></span><br><span class="line"><span class="ruby">plugins/org.eclipse.equinox.launcher_1.<span class="number">0</span>.<span class="number">201</span>.R35x_v20090715.jar</span></span><br><span class="line"><span class="ruby">--launcher.library</span></span><br><span class="line"><span class="ruby">plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.<span class="number">0</span>.<span class="number">200</span>.v20090519</span></span><br><span class="line"><span class="ruby">-product</span></span><br><span class="line"><span class="ruby">org.eclipse.epp.package.jee.product</span></span><br><span class="line"><span class="ruby">-showsplash</span></span><br><span class="line"><span class="ruby">org.eclipse.platform</span></span><br><span class="line"><span class="ruby">-vmargs</span></span><br><span class="line"><span class="ruby">-Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xverify：none</span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br><span class="line"><span class="ruby">-Xms512m</span></span><br><span class="line"><span class="ruby">-Xmn128m</span></span><br><span class="line"><span class="ruby">-XX：PermSize=<span class="number">96</span>m</span></span><br><span class="line"><span class="ruby">-XX：MaxPermSize=<span class="number">96</span>m</span></span><br><span class="line"><span class="ruby">-XX：+DisableExplicitGC</span></span><br><span class="line"><span class="ruby">-Xnoclassgc</span></span><br><span class="line"><span class="ruby">-XX：+UseParNewGC</span></span><br><span class="line"><span class="ruby">-XX：+UseConcMarkSweepGC</span></span><br><span class="line"><span class="ruby">-XX：CMSInitiatingOccupancyFraction=<span class="number">85</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="第四节-总结"><a href="#第四节-总结" class="headerlink" title="第四节 总结"></a><strong>第四节 总结</strong></h2><p>&emsp;&emsp;Java虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对我们程序的性能和稳定性有着非常大的影响，在本书的第2～5章中，作者从理论知识、异常现象、代码、工具、案例和实战等几个方面对其进行讲解，希望读者能有所收获。</p><p>&emsp;&emsp;本书关于虚拟机内存管理的部分到此为止就结束了，下一章我们将开始学习Class文件与虚拟机执行子系统方面的知识。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的虚拟机调优案例分析与实战，包括：概述，案例分析（高性能硬件上的程序部署策略、集群间同步导致的内存溢出、堆外内存导致的溢出错误、外部命令导致系统缓慢、服务器JVM进程崩溃、不恰当数据结构导致内存占用过大、由Windows虚拟内存导致的长时间停顿），实战：Eclipse运行速度调优（调优前的程序运行状态、升级JDK 1.6的性能变化及兼容问题、编译时间和类加载时间的优化、调整内存设置控制垃圾收集频率、选择收集器降低延迟），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
</feed>
