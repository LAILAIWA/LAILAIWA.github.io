<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-10-02T07:10:40.953Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Speciosity</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ（四）管理</title>
    <link href="http://linyishui.top/2020100201.html"/>
    <id>http://linyishui.top/2020100201.html</id>
    <published>2020-10-02T07:08:31.000Z</published>
    <updated>2020-10-02T07:10:40.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>参考：</p><blockquote><p>《RabbitMQ实战指南》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第三章《管理》，内容来自于《RabbitMQ实战指南》，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（三）进阶</title>
    <link href="http://linyishui.top/2020092801.html"/>
    <id>http://linyishui.top/2020092801.html</id>
    <published>2020-09-28T05:34:23.000Z</published>
    <updated>2020-09-30T06:20:35.764Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="第一节-消息何去何从"><a href="#第一节-消息何去何从" class="headerlink" title="第一节 消息何去何从"></a>第一节 消息何去何从</h2><h3 id="1-1-消息不可达时返回给生产者"><a href="#1-1-消息不可达时返回给生产者" class="headerlink" title="1.1 消息不可达时返回给生产者"></a>1.1 消息不可达时返回给生产者</h3><p> <code>channel.basicPublish</code> 两个容易混淆的参数：都可以在消息传递过程不可达目的地时将消息返回给生产者。</p><ul><li><p>mandatory：为 true 时，且交换器无法根据自身的类型和路由键找到一个符合条件的队列，调用 <code>Basic.Return</code> 命令将消息返回给生产者。为 false 时，消息直接被丢弃。</p><p>如下代码，输出 <code>&quot;Basic.Return 返回的结果是：mandatory test&quot;</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">true</span>,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        <span class="string">"mandatory test"</span>.getBytes());</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用channel.addReturnListener添加ReturnListener监听器来使生产者获取是否被正确路由到合适队列</span></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 AMQP.BasicProperties basicProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">"Basic.Return 返回的结果是："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMQP协议中对应的流转过程：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010165.png" alt></p></li><li><p>immediate：为true时，若交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时， 该消息会通过 <code>Basic.Return</code> 返回至生产者。</p><ul><li>RabbitMQ 3.0 时去除了对此参数的支持，会影响镜像队列的性能，建议用TTL和DLX方法替代。</li></ul></li></ul><p>概括来说， mandatory 参数告诉服务器至少将该消息路由到一个队列中，否则将消息返回给生产者。 immediate 参数告诉服务器，如果该消息关联的队列上有消费者，则立刻投递；如果所有匹配的队列上都没有消费者，则直接将消息返还给生产者，不用将消息存入队列而等待消费者了。</p><h3 id="1-2-备份交换器"><a href="#1-2-备份交换器" class="headerlink" title="1.2 备份交换器"></a>1.2 备份交换器</h3><p><strong>备份交换器</strong>，英文名称为 <strong>Alternate Exchange</strong> ，简称<strong>AE</strong>，或者更直白地称之为“备胎交换器”。</p><p>生产者在发送消息的时候如果不设置 mandatory 参数，那么消息在未被路由的情况下将会丢失；如果设置了 mandatory 参数，那么需要添加 ReturnListener 的编程逻辑，生产者的代码将变得复杂。</p><p><strong>既不想复杂化生产者的编程逻辑，又不想消息丢失，可以使用备份交换器</strong>，这样可以将未被路由的消息存储在 RabbitMQ 中，再在需要的时候去处理这些消息。</p><p><strong>消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。</strong></p><h4 id="1-2-1-实现方式"><a href="#1-2-1-实现方式" class="headerlink" title="1.2.1 实现方式"></a>1.2.1 实现方式</h4><p><strong>实现方式</strong>：</p><ul><li>调用 <code>channel.exchangeDeclare()</code> 时添加 <code>alternate-exchange</code> 参数实现；</li><li>通过策略（Policy）方式实现。默认第一种优先级高。</li></ul><p>添加 <code>alternate-exchange</code> 参数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"alternate-exchange"</span>, <span class="string">"myAe"</span>);</span><br><span class="line"><span class="comment">// 声明两个交换器，分别绑定相应队列</span></span><br><span class="line"><span class="comment">// 并且设置myAe为normalExchange的备份交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"normalExchange"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">channel.exchangeDeclare(<span class="string">"myAe"</span>, <span class="string">"fanout"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"normalQueue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"normalQueue"</span>, <span class="string">"normalExchange"</span>, <span class="string">"normalKey"</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"unroutedQueue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"unroutedQueue"</span>, <span class="string">"myAe"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>此时发送一条消息到交换器normalExchange，当路由键等于normalKey时，消息可以正确路由到队列normalQueue；否则消息会发送给备份交换器myAe，并发送到队列unroutedQueue。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010166.png" alt></p><p>策略实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy AE <span class="string">"^normalExchange$"</span> <span class="string">'&#123;"alternate-exchange": "myAE"&#125;'</span></span></span><br></pre></td></tr></table></figure><p><strong>建议设置备份交换器为 fanout 类型</strong>：如果备份交换器的类型是 direct 并且有一个与其绑定的队列，假设绑定的路由键是 key1 当某条携带路由键为 key2 的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失。如果消息携带的路由键为 key1 ，则可以存储到队列中。</p><h4 id="1-2-2-特殊情况"><a href="#1-2-2-特殊情况" class="headerlink" title="1.2.2 特殊情况"></a>1.2.2 特殊情况</h4><ul><li>如果设置的备份交换器不存在，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li><li>如果备份交换器没有绑定任何队列，客户端和 RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li><li>如果备份交换器没有任何匹配的队列，客户端和 RabbitMQ 服务端都不会有异常出现， 此时消息会丢失。</li><li>如果备份交换器和 mandatory 参数一起使用，那么 mandatory 参数无效。</li></ul><h2 id="第二节-过期时间-TTL"><a href="#第二节-过期时间-TTL" class="headerlink" title="第二节 过期时间(TTL)"></a>第二节 过期时间(TTL)</h2><p>过期时间（Time to Live，TTL），可以对消息和队列设置TTL。</p><h3 id="2-1-设置消息的TTL"><a href="#2-1-设置消息的TTL" class="headerlink" title="2.1 设置消息的TTL"></a>2.1 设置消息的TTL</h3><p>设置方式：</p><ul><li><p><strong>通过队列属性设置</strong>，队列内所有消息都有相同的TTL；</p><ul><li><p>在 <code>channel.queueDeclare()</code> 中加入 <code>x-message-ttl</code> 参数，单位毫秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"x-message-ttl"</span>, <span class="number">6000</span>);</span><br><span class="line">channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);</span><br></pre></td></tr></table></figure></li><li><p>通过策略-Policy来设置TTL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy TTL <span class="string">".*"</span> <span class="string">'&#123;"message-ttl":60000&#125;'</span> --apply-to queues</span></span><br></pre></td></tr></table></figure></li><li><p>通过调用HTTP API接口设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root -H <span class="string">"content-type:application/json"</span>-X PUT -d<span class="string">'&#123;"auto_delete":false,"durable":true,"arguments":&#123;"x-message-ttl": 60000&#125;&#125;'</span> http://localhost:15672/api/queues/&#123;vhost&#125;/&#123;queuename&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>对消息本身进行单独设置</strong>，两种一起使用以较小的值为准。</p><ul><li><p>在 <code>channel.basicPublish()</code> 中加入 expiration 属性参数，单位毫秒：(消息过期后马上从队列抹去，因为过期消息都在队列头部，只要定期扫描头部并删除即可)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line"><span class="comment">// 持久化消息</span></span><br><span class="line">builder.deliveryMode(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 设置TTL=60000ms</span></span><br><span class="line">builder.expiration(<span class="string">"60000"</span>);</span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties. <span class="string">"ttlTestMessage"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties;</span><br><span class="line"><span class="comment">// 持久化消息</span></span><br><span class="line">properties.setDeliveryMode(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 设置TTL=60000ms</span></span><br><span class="line">properties.setExpiration(<span class="string">"60000"</span>);</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties. <span class="string">"ttlTestMessage"</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>通过调用HTTP API接口设置：（消息过期不会马上抹去，因为每条消息过期时间不同，需要扫描整个队列，不如等被消费时再做判断）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root -H <span class="string">"content-type:application/json"</span>-X POST -d<span class="string">'&#123;"properties":&#123;"expiration":"60000"&#125;,"routing_key":"routingKey","payload":"my body","payload_encoding":"string"&#125;'</span> http://localhost:15672/api/queues/&#123;vhost&#125;/&#123;exchange</span></span><br><span class="line">name&#125;/publish</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>消息在队列中生存时间超过TTL时，会变成“死信”（Dead Message）。不设置TTL，默认不会过期；若设置为0，则表示直接投递到消费者，否则直接丢弃，可以部分替代上文所提 immediate 参数，但没有 <code>Basic.Return</code> 返回消息（可以通过死信队列来实现）。</p><h3 id="2-2-设置队列的TTL"><a href="#2-2-设置队列的TTL" class="headerlink" title="2.2 设置队列的TTL"></a>2.2 设置队列的TTL</h3><p>通过 <code>channel.queueDeclare()</code> 方法中的 <code>x-expires</code> 参数可以控制队列被自动删除前处于未使用状态的时间。未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过 <code>Basic.Get</code> 命令。</p><p>设置队列里的 TTL 可以应用于类似 <strong>RPC 方式的回复队列</strong>，在 RPC 中，许多队列会被创建出来，但是却是未被使用的。RabbitMQ 会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时 。</p><p>创建一个过期时间为30分钟的队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">"x-expires"</span>, <span class="number">1800000</span>);</span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><h2 id="第三节-死信队列"><a href="#第三节-死信队列" class="headerlink" title="第三节 死信队列"></a>第三节 死信队列</h2><h3 id="3-1-死信交换器和死信队列"><a href="#3-1-死信交换器和死信队列" class="headerlink" title="3.1 死信交换器和死信队列"></a>3.1 死信交换器和死信队列</h3><p>死信交换器（Dead-Letter-Exchange，DLX）也可称为死信邮箱。当消息在一个队列中变成死信（dead message），能被重新被发送到另一交换器，这个交换器就是DLX，绑定DLX的队列就是死信队列。</p><p>DLX和普通交换器没区别，当设置的队列存在死信时，会自动的被发布到设置的DLX上，进而路由到死信队列，这个特性可以和TTL为0配合替代 immediate 参数。</p><h3 id="3-2-消息变为死信的原因"><a href="#3-2-消息变为死信的原因" class="headerlink" title="3.2 消息变为死信的原因"></a>3.2 消息变为死信的原因</h3><ul><li>消息被拒绝（ <code>Basic.Reject</code> / <code>Basic.Nack</code> ），井且设置 requeue 参数为 false;</li><li>消息过期；</li><li>队列达到最大长度。</li></ul><h3 id="3-3-实现方式"><a href="#3-3-实现方式" class="headerlink" title="3.3 实现方式"></a>3.3 实现方式</h3><ul><li><p>通过 <code>channel.queueDeclare()</code> 方法中设置 <code>x-dead-letter-exchange</code> 参数来为队列添加DLX：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建DLX</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"dlx_exchange"</span>, <span class="string">"direct"</span>);</span><br><span class="line"><span class="comment">//通过</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;;</span><br><span class="line">args.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">" dlx_exchange "</span>);</span><br><span class="line"><span class="comment">//也可以为DLX指定路由键，默认为原队列的路由键</span></span><br><span class="line">args.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"dlx-routing-key"</span>);</span><br><span class="line"><span class="comment">//为队列myqueue添加DLX</span></span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过策略-Policy来设置TTL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_policy DLX <span class="string">".*"</span> <span class="string">'&#123;"dead-letter-exchange":" dlx_exchange "&#125;'</span> --apply-to queues</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-过程"><a href="#3-4-过程" class="headerlink" title="3.4 过程"></a>3.4 过程</h3><p>生产者首先发送一条携带路由键为 <code>rk</code> 的消息，然后经过交换器 <code>exchange.normal</code> 顺利地存储到队列 <code>queue.normal</code> 。由于队列 <code>queue.normal</code> 设置了过期时间为 10s ，在这 10s 内没有消费者消费这条消息，那么判定这条消息为过期。由于设置了 DLX ，过期之时，消息被丢给交换器 <code>exchange.dlx</code> 中，这时找到与 <code>exchange.dlx</code> 匹配的队列 <code>queue.dlx</code> 后消息被存储在 <code>queue.dlx</code> 这个死信队列中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010167.png" alt></p><h3 id="3-5-作用"><a href="#3-5-作用" class="headerlink" title="3.5 作用"></a>3.5 作用</h3><p>DLX 是一个非常有用的特性，它可以处理异常情况下，消息不能够被消费者正确消费（消费者调用了 <code>Basic.Nack</code> 或者 <code>Basic.Reject</code> ）而被置入死信队列中的情况，后续分析程序可以<strong>通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以改善和优化系统</strong>。</p><p><strong>DLX 配合 TTL 使用还可以实现延迟队列的功能</strong>。</p><h2 id="第四节-延迟队列"><a href="#第四节-延迟队列" class="headerlink" title="第四节 延迟队列"></a>第四节 延迟队列</h2><h3 id="4-1-延迟消息"><a href="#4-1-延迟消息" class="headerlink" title="4.1 延迟消息"></a>4.1 延迟消息</h3><p>延迟队列存储的对象是对应的延迟消息，所谓<strong>“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费</strong>。</p><h3 id="4-2-使用场景"><a href="#4-2-使用场景" class="headerlink" title="4.2 使用场景"></a>4.2 使用场景</h3><ul><li><strong>支付超时</strong>：在订单系统中， 一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些订单了。</li><li><strong>定时功能</strong>：用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将用户指令发送到延迟队列，当指令设定的时间到了再将指令推送到智能设备。</li></ul><h3 id="4-3-实现方式"><a href="#4-3-实现方式" class="headerlink" title="4.3 实现方式"></a>4.3 实现方式</h3><p>在 AMQP 协议中，或者 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面所介绍的 <strong>DLX + TTL 模拟出延迟队列的功能</strong>。</p><p>图4-4不仅展示的是死信队列的用法，也是延迟队列的用法， <code>queue.dlx</code> 这个死信队列可以看作延迟队列。假设一个应用中需要将每条消息都设置为 10 秒的延迟， 生产者通过 <code>exchange.normal</code> 这个交换器将发送的消息存储在 <code>queue.normal</code> 这个队列中。消费者订阅的并非是 <code>queue.normal</code> 这个队列，而是 <code>queue.dlx</code> 这个队列 。当消息从 <code>queue.normal</code> 这个队列中过期之后被存入 <code>queue.dlx</code> 这个队列中，消费者就恰巧消费到了延迟 10 秒的这条消息。</p><p>在真实应用中，对于延迟队列可以根据延迟时间的长短分为多个等级，一般分为 5秒、10 秒、30 秒、 1分钟、5分钟、10 分钟、30 分钟、 1小时这几个维度，当然也可以再细化一下。</p><p>图4-5为了简化说明，这里只设置了5秒、10 秒、30 秒、1分钟这四个等级。根据应用需求的不同，生产者在发送消息的时候通过设置不同的路由键，以此将消息发送到与交换器绑定的不同的队列中。这里队列分别设置了过期时间为5秒、10 秒、30 秒、1分钟，同时也分别配置了 DLX 和相应的死信队列。</p><p>当相应的消息过期时，就会转存到相应的死信队列（即延迟队列〉中，这样消费者根据业务自身的情况，分别选择不同延迟等级的延迟队列进行消费。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010168.png" alt></p><h2 id="第五节-优先级队列"><a href="#第五节-优先级队列" class="headerlink" title="第五节 优先级队列"></a>第五节 优先级队列</h2><p>优先级队列，顾名思义，具有高优先级的队列具有高的优先权，优先级高的消息具备优先被消费的特权。</p><p>可以通过设置队列的 <code>x-max-priority</code> 参数来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置一个队列的最大优先级</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-rnax-priority"</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"queue.priority"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args); </span><br><span class="line"><span class="comment">// 需要在发送时在消息中设置消息当前的优先级</span></span><br><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">builder.priority(<span class="number">5</span>);</span><br><span class="line">AMQP.BasicProperties properties = bulder.build();</span><br><span class="line">channel.basicPublish(<span class="string">"exchange_priority"</span>, <span class="string">"rk_priority"</span>, properties, (<span class="string">"messages"</span>).getBytes());</span><br></pre></td></tr></table></figure><p>上面的代码中设置消息的优先级为5。默认最低为0，最高为队列设置的最大优先级。优先级高的消息可以被优先消费，这个也是有前提的；如果在消费者的消费速度大于生产者的速度且 Broker 中没有消息堆积的情况下，对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</p><h2 id="第六节-RPC实现"><a href="#第六节-RPC实现" class="headerlink" title="第六节 RPC实现"></a>第六节 RPC实现</h2><h3 id="6-1-什么是RPC？"><a href="#6-1-什么是RPC？" class="headerlink" title="6.1 什么是RPC？"></a>6.1 什么是RPC？</h3><p>远程过程调用（Remote Procedure Call，RPC），它是一种通过网络从远程计算机上请求服务，而不需要了解底层网络的技术。 RPC的主要功用是让构建分布式计算更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</p><p>通俗点来说，假设有两台服务器A和B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在同一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><p>RPC的协议有很多，比如最早的 CORBA、Java RMI、WebService的RPC风格、 Hessian、Thrift、Dubbo等，甚至还有 Restful API。</p><h3 id="6-2-RabbitMQ如何进行RPC"><a href="#6-2-RabbitMQ如何进行RPC" class="headerlink" title="6.2 RabbitMQ如何进行RPC"></a>6.2 RabbitMQ如何进行RPC</h3><p>一般在 RabbitMQ 中进行 RPC 是很简单。客户端发送请求消息，服务端回复响应的消息。为了接收响应的消息，我们需<strong>要在请求消息中发送一个回调队列</strong>（参考下面代码中的 replyTo 可以使用默认的队列）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String callbackQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">BasicProperties props = <span class="keyword">new</span> BasicProperties.Bulder().replyTo(callbackQueueName).build();</span><br><span class="line">channel.basicPublish (<span class="string">""</span>,<span class="string">"rpc_queue"</span>, props, message.getBytes());</span><br><span class="line"><span class="comment">// then code to read a response message from the callback_queue ...</span></span><br></pre></td></tr></table></figure><p>BasicProperties包含14个属性，这里主要用到两个：</p><ul><li>replyTo：通常用来设置一个回调队列；</li><li>correlationId：用来关联请求（request）和其调用 RPC 之后的回复（response）。</li></ul><p>上述代码中为每个 RPC 请求创建一个回调队列是非常低效的。通用的解决方案一一<strong>可以为每个客户端创建一个单一的回调队列</strong>。</p><p>这样就产生了一个新的问题，对于回调队列而言，在其接收到一条回复的消息之后，它并不知道这条消息应该和哪一个请求匹配。这里就用到 correlationId 这个属性了，我们应该<strong>为每一个请求设置一个唯一的 correlationId</strong> 。之后<strong>在回调队列接收到回复的消息时，可以根据这个属性匹配到相应的请求</strong>。如果回调队列接收到一条未知 correlationId 的回复消息，可以简单地将其丢弃。</p><p>疑问：</p><ul><li>为什么要将回调队列中的位置消息丢弃而不是仅仅将其看作失败？</li><li><strong>这样可以针对这个失败做一些弥补措施</strong>。</li></ul><p>参考图 4-7 考虑这样一种情况：RPC 服务器可能在发送给回调队列（ <code>amq.gen-LhQzlgv3GhDOv8PIDabOXA</code> ）并且在确认接收到请求消息（rpc_queue中的消息）之后挂掉了，那么只需重启下 RPC 服务器即可，RPC 服务会重新消费 rpc_queue 队列中的请求，这样就不会出现 RPC 服务端未处理请求的情况。这里的回调队列可能会收到重复消息的情况，这需要客户端能够优雅地处理这种情况，并且 RPC 请求需要保证其本身是幂等的（补充：<strong>消费者消费消息一般是先处理业务逻辑，再使用 <code>Basic.Ack</code> 确认己接收到消息以防止消息不必要地丢失</strong>）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010169.png" alt></p><h3 id="6-3-RPC处理流程"><a href="#6-3-RPC处理流程" class="headerlink" title="6.3 RPC处理流程"></a>6.3 RPC处理流程</h3><p>RPC的处理流程如下：</p><ol><li>当客户端启动时，创建一个匿名的回调队列（名称由 RabbitMQ 自动创建，如图4-7的回调队列为 <code>amq.gen-LhQzlgv3GhDOv8PIDabOXA</code> ）。</li><li>客户端为 RPC 请求设置2个属性：replyTo-用来告知 RPC 服务端回复请求时的目的队列，即回调队列； correlationId-用来标记一个请求。</li><li>请求被发送到 rpc_queue 队列中。</li><li>RPC 服务端监听 rpc_queue 队列中的请求，当请求到来时，服务端会处理并且把带有结果的消息发送给客户端，接收的队列就是 replyTo 设定的回调队列。</li><li>客户端监听回调队列，当有消息时，检查 correlationId 属性，如果与请求匹配， 那就是结果了。</li></ol><h3 id="6-4-示例"><a href="#6-4-示例" class="headerlink" title="6.4 示例"></a>6.4 示例</h3><p>示例：RPC客户端通过 RPC 来调用服务端的方法以便得到相应斐波那契值。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE_NQME = <span class="string">"rpc_queue"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(IP_ADDRESS);</span><br><span class="line">        factory.setPort(PORT);</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">        Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(RPC_QUEUE_NQME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [x] Awaiting RPC requests"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                AMQP.BasicProperties replyProps = <span class="keyword">new</span> AMQP.BasicProperties()</span><br><span class="line">                        .builder()</span><br><span class="line">                        .correlationId(properties.getCorrelationId())</span><br><span class="line">                        .build();</span><br><span class="line">                String response = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                    <span class="keyword">int</span> n = Integer.parseInt(message);</span><br><span class="line">                    System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [.] fib("</span> + message + <span class="string">")"</span>);</span><br><span class="line">                    response += fib(n);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"RPCServer "</span> + LocalTime.now() + <span class="string">" [.] "</span> + e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">""</span>, properties.getReplyTo(),</span><br><span class="line">                            replyProps, response.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(RPC_QUEUE_NQME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> String requestQueueName = <span class="string">"rpc_queue"</span>;</span><br><span class="line">    <span class="keyword">private</span> String replyQueueName;</span><br><span class="line">    <span class="keyword">private</span> MyConsumer consumer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"101.200.124.26"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RPCClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"></span><br><span class="line">        replyQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">        consumer = <span class="keyword">new</span> MyConsumer(channel);</span><br><span class="line">        channel.basicConsume(replyQueueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ShutdownSignalException, ConsumerCancelledException,</span></span><br><span class="line"><span class="function">            InterruptedException </span>&#123;</span><br><span class="line">        String response = <span class="keyword">null</span>;</span><br><span class="line">        String corrId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties()</span><br><span class="line">                .builder()</span><br><span class="line">                .correlationId(corrId)</span><br><span class="line">                .replyTo(replyQueueName)</span><br><span class="line">                .build();</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, requestQueueName, properties, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            MyConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            <span class="keyword">if</span>(delivery.getProperties().getCorrelationId().equals(corrId))&#123;</span><br><span class="line">                response = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RPCClient fibRpc = <span class="keyword">new</span> RPCClient();</span><br><span class="line">        System.out.println(<span class="string">"RPCClient "</span> + LocalTime.now() + <span class="string">" [x] Requesting fib(30)"</span>);</span><br><span class="line">        String response = fibRpc.call(<span class="string">"30"</span>);</span><br><span class="line">        System.out.println(<span class="string">"RPCClient "</span> + LocalTime.now() + <span class="string">" [.] Got '"</span> + response + <span class="string">"'"</span>);</span><br><span class="line">        fibRpc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前版本MQ已废弃QueueingConsumer，自定义一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;Delivery&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//TODO someting</span></span><br><span class="line">        Delivery delivery = <span class="keyword">new</span> Delivery();</span><br><span class="line">        delivery.setBody(body);</span><br><span class="line">        delivery.setProperties(properties);</span><br><span class="line">        delivery.setEnvelope(envelope);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(delivery);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Delivery <span class="title">nextDelivery</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException, ShutdownSignalException, ConsumerCancelledException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Delivery <span class="title">nextDelivery</span><span class="params">(<span class="keyword">long</span> timeout)</span><span class="keyword">throws</span> InterruptedException, ShutdownSignalException, ConsumerCancelledException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delivery</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BasicProperties properties;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line">        <span class="keyword">private</span> Envelope envelope;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BasicProperties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(BasicProperties properties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(<span class="keyword">byte</span>[] body)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.body = body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Envelope <span class="title">getEnvelope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> envelope;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvelope</span><span class="params">(Envelope envelope)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.envelope = envelope;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">RPCServer</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">01.198</span> [x] <span class="symbol">Awaiting</span> <span class="symbol">RPC</span> requests</span><br><span class="line"><span class="symbol">RPCClient</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">06.135</span> [x] <span class="symbol">Requesting</span> fib(<span class="number">30</span>)</span><br><span class="line"><span class="symbol">RPCServer</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">07.315</span> [.] fib(<span class="number">30</span>)</span><br><span class="line"><span class="symbol">RPCClient</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">07.364</span> [.] <span class="symbol">Got</span> <span class="string">'832040'</span></span><br></pre></td></tr></table></figure><h2 id="第七节-持久化"><a href="#第七节-持久化" class="headerlink" title="第七节 持久化"></a>第七节 持久化</h2><h3 id="7-1-RabbitMQ的持久化"><a href="#7-1-RabbitMQ的持久化" class="headerlink" title="7.1 RabbitMQ的持久化"></a>7.1 RabbitMQ的持久化</h3><p>持久化可以提高 RabbitMQ 的可靠性，以防在异常情况（重启、关闭、宿机等）下的数据丢失。</p><p> RabbitMQ 的持久化分为三个部分：</p><ul><li>交换器的持久化；</li><li>队列的持久化；</li><li>消息的持久化。</li></ul><h3 id="7-2-实现方式"><a href="#7-2-实现方式" class="headerlink" title="7.2 实现方式"></a>7.2 实现方式</h3><h4 id="7-2-1-交换器的持久化"><a href="#7-2-1-交换器的持久化" class="headerlink" title="7.2.1 交换器的持久化"></a>7.2.1 交换器的持久化</h4><p>交换器的持久化是<strong>通过在声明队列时将 durable 参数置为 true 实现的</strong>。如果交换器不设置持久化，那么在 RabbitMQ 服务重启之后，相关的交换器元数据会丢失， 不过消息不会丢失，只是不能将消息发送到这个交换器中了。对于一个长期使用的交换器来说， 建议将其置为持久化的。</p><h4 id="7-2-2-队列的持久化"><a href="#7-2-2-队列的持久化" class="headerlink" title="7.2.2 队列的持久化"></a>7.2.2 队列的持久化</h4><p>队列的持久化是<strong>通过在声明队列时将 durable 参数置为 true 实现的</strong>。如果队列不设置持久化，那么在 RabbitMQ 服务重启之后，相关队列的元数据会丢失， 此时数据也会丢失 。正所谓 “皮之不存，毛将焉附”，队列都没有了，消息又能存在哪里呢？</p><h4 id="7-2-3-消息的持久化"><a href="#7-2-3-消息的持久化" class="headerlink" title="7.2.3 消息的持久化"></a>7.2.3 消息的持久化</h4><p>队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。</p><p><strong>通过将消息的投递模式 (BasicProperties 中的 deliveryMode 属性）设置为2,即可实现消息的持久化</strong>。前面示例中多次提及的 <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 实际上是封装了这个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BasicProperties PERSISTENT_TEXT_PLAIN = <span class="keyword">new</span> BasicProperties(<span class="string">"text/plain"</span>, (String)<span class="keyword">null</span>, (Map)<span class="keyword">null</span>, <span class="number">2</span>, <span class="number">0</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (Date)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (String)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>设置了队列和消息的持久化，当 RabbitMQ 服务重启之后，消息依旧存在。单单只设置队列持久化，重启之后消息会丢失；单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</p><p>注意要点：可以将所有的消息都设直为持久化，但是这样会严重影响 RabbitMQ 的性能（随机）。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一 个权衡。</p><h3 id="7-3-为何持久化不能保证数据不会丢失？"><a href="#7-3-为何持久化不能保证数据不会丢失？" class="headerlink" title="7.3 为何持久化不能保证数据不会丢失？"></a>7.3 为何持久化不能保证数据不会丢失？</h3><p>将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗？答案是否定的。</p><p>首先从消费者来说，如果在订阅消费队列时将 autoAck 参数设置为 true ，那么当消费者接收到相关消息之后，还没来得及处理就看宕机了，这样也算数据丢失。这种情况很好解决，将 autoAck 参数设置为 false ，并进行手动确认。</p><p>其次，在持久化的消息正确存入 RabbitMQ 之后，还需要有一段时间（虽然很短，但是不可忽视〉才能存入磁盘之中。 RabbitMQ 并不会为每条消息都进行同步存盘（调用内核的 <code>fsync</code> 方法）的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内 RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。</p><p>这个问题怎么解决呢？这里可以<strong>引入 RabbitMQ 镜像队列机制</strong>，相当于配置了副本，如果主节点（ master ）在此特殊时间内挂掉，可以自动切换到从节点（slave), 这样有效地保证了高可用性，除非整个集群都挂掉。虽然这样也不能完全保证 RabbitMQ 消息不丢失，但是配置了镜像队列要比没有配置镜像队列的可靠性要高很多，在实际生产环境中的关键业务队列一般都会设置镜像队列。</p><p>还可以<strong>在发送端引入事务机制</strong>或者<strong>发送方确认机制</strong>来保证消息己经正确地发送并存储至 RabbitMQ 中，前提还要保证在调用 <code>channel.basicPublish</code> 方法的时候交换器能够将消息正确路由到相应的队列之中。</p><h2 id="第八节-生产者确认"><a href="#第八节-生产者确认" class="headerlink" title="第八节 生产者确认"></a>第八节 生产者确认</h2><p>在使用 RabbitMQ 的时候，可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失，除此之外，我们还会遇到一个问题，<strong>当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢？</strong></p><p>如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化？</p><p>RabbitMQ 针对这个问题，提供了两种解决方式：</p><ul><li>通过事务机制实现；</li><li>通过发送方确认（publisher confirm）机制实现。</li></ul><h3 id="8-1-事务机制"><a href="#8-1-事务机制" class="headerlink" title="8.1 事务机制"></a>8.1 事务机制</h3><p>RabbitMQ 客户端中与事务机制相关的方法有 个：</p><ul><li><code>channel.txSelect</code> ：用于将当前的信道设置成事务模式；</li><li><code>channel.txCommit</code> ：用于提交事务；</li><li><code>channel.txRollback</code> ：用于事务回滚。</li></ul><p>在通过 channel.txSelect 方法开启事务之后，我们便可以发布消息给 RabbitMQ 了， 如果事务提交成功，则消息一定到达了 RabbitMQ 中，如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行 channel.txRollback 方法来实现事务回滚。注意这里的 RabbitMQ 中的事务机制与大多数数据库中的事务概念井不相同，需要注意区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"transaction messages"</span>.getBytes());</span><br><span class="line">channel.txCommit();</span><br></pre></td></tr></table></figure><p>上面代码对应的 AMQP 协议流转过程如图 4-8 示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010170.png" alt></p><p>可以发现开启事务机制与不开启（参考图2-10）相比多了四个步骤：</p><ul><li>客户端发送 <code>Tx.Select</code> ，将信道置为事务模式；</li><li>Broker 回复 <code>Tx Select-Ok</code> ，确认己将信道置为事务模式：</li><li>在发送完消息之后，客户端发送 <code>Tx.Commit</code> 提交事务</li><li>Broker回复 <code>Tx.Commit-Ok</code> ，确认事务提交。</li></ul><p>上面所陈述的是正常的情况下的事务机制运转过程，而事务回滚是什么样子呢？我们先来 参考下面一段示例代码（代码清单 4-15 ），来看看怎么使用事务回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       channel.txSelect();</span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">       channel.txCommit();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       channel.txRollback();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面代码中很明显有一个 <code>java.lang.ArithmeticException</code> ，在事务提交之前捕获到异常，之后显式地提交事务回滚，其 AMQP 议流转过程如图 4-9 所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010171.png" alt></p><p>如果要发送多条消息，则将 <code>channel.basicPublish</code> 和 <code>channel.txCommit</code> 等方法包裹进循环内即可，可以参考如下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; LOOP_TIMES;i++)&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, (<span class="string">"messages"</span> + i).getBytes());</span><br><span class="line">           channel.txCommit();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           channel.txRollback();</span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>事务确实能够解决消息发送方和 RabbitMQ 之间消息确认的问题，只有消息成功被 RabbitMQ 接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。</p><p>但是使用事务机制会“吸干” RabbitMQ 的性能，那么有没有更好的方法既能保证消息发送方确认消息已经正确送达，又能基本上不带来性能上的损失呢？从 AMQP 协议层面来看并没有更好的办法，但是 RabbitMQ 提供了一个改进方案，即发送方确认机制。</p><h3 id="8-2-发送方确认机制"><a href="#8-2-发送方确认机制" class="headerlink" title="8.2 发送方确认机制"></a>8.2 发送方确认机制</h3><p>前面介绍了 RabbitMQ 可能会遇到的一个问题，即消息发送方（生产者）并不知道消息是否真正地到达了 RabbitMQ 。随后了解到在 AMQP 协议层面提供了事务机制来解决这个问题， 但是采用事务机制实现会严重降低 RabbitMQ 的消息吞吐量，这里就引入了一种<strong>轻量级的方式</strong>一<strong>发送方确认</strong>（publisher confirm）机制。</p><p>生产者将信道设置成 confirm （确认）模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的ID （从1开始），一旦消息被投递到所有匹配的队列之后， RabbitMQ 会发送一个确认（ <code>Basic.Ack</code> ）给生产者（包含消息的唯一ID ），这就使得生产者知晓消息已经正确到达了目的地了。</p><p>如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。 RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号，此外 RabbitMQ 可以设置 <code>channel.basicAck</code> 方法中的 multiple 参数，表示到这个序号之前的所有消息都己经得到了处理，可以参考图 4-10 。注意辨别这里的确认和消费时候的确认之间的异同。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010172.png" alt></p><p>事务机制在一条消息发送之后会使发送端阻塞，以等待 RabbitMQ 的回应，之后才能继续发送下一条消息。相比之下，<strong>发送方确认机制最大的好处在于它是异步的</strong>，一旦发布一条消息， 生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用程序便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack ( <code>Basic.Nack</code> ）命令，生产者应用程序同样可以在回调方法中处理该 nack 命令。</p><p>生产者通过调用 <code>channel.confirmSelect</code> 方法（即 <code>Confirm.Select</code> 命令）将信道 设置为 confirm 模式，之后 RabbitMQ 会返回 <code>Confirm.Select-Ok</code> 命令表示同意生产者将当前信道设置为 confirm 模式。所有被发送的后续消息都被 ack 或者 nack 一次，不会出现一条消息既被 ack 又被 nack 情况，并且 RabbitMQ 并没有对消息被 confirm 的快慢做任何保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">// 将信道置为 publisher confirm 模式</span></span><br><span class="line">       channel.confirmSelect();</span><br><span class="line">       <span class="comment">// 之后正常发送消息</span></span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, <span class="string">"publisher confirm test"</span>.getBytes());</span><br><span class="line">       <span class="keyword">if</span>(!channel.waitFormConfirms()) &#123;</span><br><span class="line">           System.out.println(<span class="string">"send message failed"</span>);</span><br><span class="line">           <span class="comment">// do something else</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果发送多条消息，只需要将 <code>channel.basicPubish</code> 和 <code>channel. waitForConfirms</code> 方法包裹在循环里面即可，参考事务机制，不过不需要 <code>channel.confirmSelect</code> 方法包裹在循环内部。</p><p>在 <code>publisher confirm</code> 模式下发送多条消息的 AMQP 协议流转过程可参考图 4-11：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010173.png" alt></p><p>对于 <code>channel.waitForConfirms</code> 而言，在 RabbitMQ 客户端中它有4个同类 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForConfirmsOrDie</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForConfirmsOrDie</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException, InterruptedException, TimeoutException</span>;</span><br></pre></td></tr></table></figure><p>如果信道没有开启 <code>publisher confirm</code> 模式，则调用任何 <code>waitForConfirms</code> 方法都会报出 <code>java.lang.IllegalStateException</code> 。对于没有参数的 <code>waitForConfirms</code> 方法来说， 其返回的条件是客户端收到了相应的 <code>Basic.Ack / .Nack</code> 或者被中断。</p><p>参数 timeout 表示超时时间， 一旦等待 RabbitMQ 回应超时就会抛出 <code>java.util.concurrent.TimeoutException</code> 的异常。</p><p>两个 <code>waitForConfirmsOrDie</code> 方法在接收到 RabbitMQ 返回 <code>Basic.Nack</code> 之后会抛出 <code>java.io.IOException</code> 业务代码可以根据自身的特性灵活地运用这四种方法来保障消息的可靠发送。</p><p>前面提到过 RabbitMQ 引入了 <code>publisher confirm</code> 机制来弥补事务机制的缺陷，提高了整体的吞吐量，那么来对比下两者之间的QPS ，测试代码可以参考上面的示例代码。</p><p>测试环境：客户端和 Broker 机器配置一CPU 24 核、主频为 2600Hz 、内存为 64GB、硬盘为 1TB 。客户端发送的消息体大小为 10B ，单线程发送，并且消息都进行持久化处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010174.png" alt></p><p>图中的横坐标表示测试的次数，纵坐标表示 QPS，可以发现 publisher confirm 与事务机制相比， QPS 并没有提高多少，难道是 RabbitMQ 欺骗了我们？</p><p>我们再来回顾下前面的示例代码，可以发现 publisher confirm 模式是每发送一条消息后就调用 <code>channe.waitForConfirms</code> 方法，之后等待服务端的确认，这实际上是一种串行同步等待的方式。事务机制和它一样，发送消息之后等待服务端确认，之后再发送消息。两者的存储确认原理相同，尤其对于持久化的消息来说，两者都需要等待消息确认落盘之后才会返回（调 Linux 内核的 <code>fsync</code> 方法） 。在同步等待的方式下， publisher confirm 机制发送一条消息需要通信交互的命令是 <code>Basic.Publish</code> 、<code>Basic.Ack</code> ；事务机制是3条： <code>Basic.Publish</code> 、<code>Tx.Commmit/.Commit-Ok</code> （或者 <code>Tx Rollback/. Rollback-Ok</code> ），事务机制多了一个命令帧报文的交互，所以 QPS 会略微下降。</p><p>注意要点：</p><ol><li>事务机制和 <code>publisher confirm</code> 机制两者是互斥的，不能共存。如果企图将已开启事务模式的信道再设置为 <code>publisher confirm</code> 模式，RabbitMQ 会报错：<code>{amqp_error, precondition_failed, &quot;cannot switch from tx to confirm mode&quot;, &#39;confirm.select&#39;};</code> 或者如果企图将已开启 <code>publisher confirm</code> 模式的信道再设置为事务模式，RabbitMQ 也会报错： <code>{amqp_error, precondition_failed, &quot;cannot switch from tx to confirm mode&quot;, &#39;tx.select&#39; }</code> 。 </li><li>事务机制和 <code>publisher confirm</code> 机制确保的是消息能够正确地发送至 RabbitMQ ，这里的“发送至 RabbitMQ”的含义是指消息被正确地发往至 RabbitMQ 的交换器，如果此交换器没有匹配的队列，那么消息也会丢失。所以在使用这两种机制的时候要确保所涉及的交换器能够有匹配的队列，更进一步地讲，发送方要配合 mandatory 参数或者备份交换器一起使用来提高 消息传输的可靠性。</li></ol><p><code>publisher confirm</code> 的优势在于并不一定需要同步确认。这里我们改进了一下使用方式，总结有如下两种：</p><ul><li>批量confirm方法：每发送一批消息后，调用 <code>channel.waitForConfirms</code> 方法，等待服务器的确认返回；</li><li>异步confirm方法：提供一个回调方法，服务端确认了一条或者多条消息后客户端会因调这个方法进行处理。</li></ul><p>在批量 confirm 方法中，客户端程序需要定期或者定量（达到多少条），亦或者两者结合起来调用 <code>channel.waitForConfirms</code> 来等待 RabbitMQ 确认返回。相比于前面示例中的普通 confirm 方法，批量极大地提升了 confirm 效率，但是问题在于出现返回 <code>Basic.Nack</code> 或者超时情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且当消息经常丢失时，批量 confirm 性能应该是不升反降的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">// 将信道置为 publisher confirm 模式</span></span><br><span class="line">       channel.confirmSelect();</span><br><span class="line">       <span class="keyword">int</span> MsgCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">       channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, <span class="string">"batch confirm test"</span>.getBytes());</span><br><span class="line">           <span class="comment">// 将发送出去的消息存入缓存，缓存可以是ArrayList或BlockingQueue等</span></span><br><span class="line">           <span class="keyword">if</span>(++MsgCount &gt;= BATCH_COUNT) &#123;</span><br><span class="line">               MsgCount = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(channel.waitForConfirms()) &#123;</span><br><span class="line">                       <span class="comment">// 将缓存中的消息清空</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 将缓存中的消息重新发送</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                   <span class="comment">// 将缓存中的消息重新发送</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>异步 confirm 方法的编程实现最为复杂，在客户端 Channel 接口中提供的 <code>addConfirmListener</code> 方法可以添加 <code>ConfirmListener</code> 这个回调接口，这个 <code>ConfirmListener</code> 接口包含两个方法： <code>handleAck</code> 、<code>handleNack</code> ，分别用来处理 RabbitMQ 回传的 <code>Basic.Ack</code> 和 <code>Basic.Nack</code> 。在这两个方法中都包含有 个参数 <code>deliveryTag</code> （在 <code>publisher confirm</code> 模式下用来标记消息的唯一有序序号）。我们需要为每个信道维护一个“unconfirm ”的消息序号集合，每发送一条消息，集合中的元素加1。每当调 <code>ConfirmListener</code> 中的 <code>handleAck</code> 方法时，“ unconfirm ”集合中删掉相应的一条 ( multiple 设置为 false ）或者多条（ multiple 设置为 true ）记录。从程序运行效率上来看， 这个“unconfrrm ”集合最好采用有序集合 <code>SortedSet</code> 的存储结构。事实上， Java 客户端 SDK 中的 <code>waitForConfirms</code> 方法也是通过 SortedSet 维护消息序号的。</p><p>演示异步 confirm 的编码实现，其中的 confirmSet 就是一个 SortedSet 类型的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener()&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"Nack, SeqNo: "</span> + deliveryTag +</span><br><span class="line">                             <span class="string">", multiple: "</span> + multiple);</span><br><span class="line">           <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">               confirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               confirmSet.remove(deliveryTag);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">               confirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               confirmSet.remove(deliveryTag);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 注意这里需要添加处理消息重发的场景</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"><span class="comment">// 下面是演示一直发送消息的场景</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">       <span class="keyword">long</span> nextSeqNo = channel.getNextPublishSeqNo();</span><br><span class="line">       channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">       confirmSet.add(nextSeqNo);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后我们将事务、普通 confirm、批量 confirm 和异步 confirm 这4种方式放到一起来比较下彼此的 QPS。测试环境和数据和图 4-12 中的测试相同，具体测试对比如图 4-13 所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010175.png" alt></p><p>可以看到批量 confirm 和异步 confirm 这两种方式所呈现的性能要比其余两种好得多。</p><ul><li>事务机制和普通 confirm 的方式吐吞量很低，但是编程方式简单，不需要在客户端维护状态（这里指的是维护 deliveryTag 及缓存未确认的消息）。</li><li>批量 confirm 方式的问题在于遇到 RabbitMQ 服务端返回 <code>Basic.Nack</code> 需要重发批量消息而导致的性能降低。</li><li>异步 confirm 方式编程模型最为复杂，而且和批量 confirm 方式一样需要在客户端维护状态。</li></ul><p>在实际生产环境中采用何种方式，这里就仁者见仁智者见智了，不过<strong>强烈建议使用异步 confirm 的方式</strong>。</p><h2 id="第九节-消费端要点介绍"><a href="#第九节-消费端要点介绍" class="headerlink" title="第九节 消费端要点介绍"></a>第九节 消费端要点介绍</h2><p>消费者客户端可以通过推模式或者拉模式的方式来获取井消费消息，当消费者处理完业务逻辑需要手动确认消息己被接收，这样 RabbitMQ 才能把当前消息从队列中标记清除。当然如果消费者由于某些原因无法处理当前接收到的消息， 可以通过 <code>channel.basicNack</code> 或者 <code>channel.basicReject</code> 来拒绝掉。</p><p>这里对于 RabbitMQ 消费端来说，还有几点需要注意：</p><ul><li>消息分发；</li><li>消息顺序性；</li><li>弃用 <code>QueueingConsumer</code> 。</li></ul><h3 id="9-1-消息分发"><a href="#9-1-消息分发" class="headerlink" title="9.1 消息分发"></a>9.1 消息分发</h3><p>当 RabbitMQ 队列拥有多个消费者时，队列收到的消息将以轮询（ <code>round-robin</code> ）的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。</p><p>很多时候轮询的分发机制也不是那么优雅。默认情况下，如果有n个消费者，那么 RabbitMQ 会将第m条消息分发给第 <code>m%n</code>（取余的方式）个消费者，RabbitMQ 不管消费者是否消费并己经确认（ <code>Basic.Ack</code> ）了消息。试想一下，如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因（比如业务逻辑简单、机器性能卓越等）很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降。</p><p>那么该如何处理这种情况呢？这里就要用到 <code>channel.basicQos(int prefetchCount)</code> 这个方法，如前面章节所述， <code>channel.basicQos</code> 方法允许限制信道上的消费者所能保持的最大未确认消息的数量。</p><p>举例说明，在订阅消费队列之前，消费端程序调用了 <code>channel.basicQos(5)</code> ，之后订阅了某个队列进行消费。 RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么 RabbitMQ 就不会向这个消费者再发送任何消息。 直到消费者确认了某条消息之后 RabbitMQ 将相应的计数减1 ，之后消费者可以继续接收消息， 直到再次到达计数上限。这种机制可以类比于 TCP/IP 中的“滑动窗口”。</p><p>注意要点：<code>Basic.Qos</code> 的使用对于拉模式的消费方式无效。</p><p>channel.basicQos 有三种类型的重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchSize, <span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> gl bal)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>前面介绍的都只用到了 prefetchCount 这个参数，当 prefetchCount 设置为0则表示没有上限。还有 prefetchSize 这个参数表示消费者所能接收未确认消息的总体大小的上限， 单位为B，设置为0则表示没有上限。</p><p>对于一个信道来说，它可以同时消费多个队列，当设置了 prefetchCount 大于0时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的 prefetchCount 的值，这样会 RabbitMQ 的性能降低，尤其是这些队列分散在集群中的多个 Broker 节点之中。 RabbitMQ 为了提升相关的性能，在 AMQP 0-9-1 协议之上重新定义了 global 这个参数，对比如表 4-1 所示。</p><table><thead><tr><th>global 参数</th><th>AMQP 0-9-1</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>false</td><td>信道上所有的消费者都需要遵从 prefetch Count 的限定值</td><td>信道上新的消费者需要遵从 prefetchCount 的限定值</td></tr><tr><td>true</td><td>当前通信链路（ Connection ）上所有的消费者都需要遵从 prefetchCount 的限定值</td><td>信道上所有的消费者都需要遵从 prefetchCount 的限定值</td></tr></tbody></table><p>前面章节中的 <code>channel.basicQos</code> 方法的示例都是针对单个消费者的，而对于同一个信道上的多个消费者而言，如果设置了 prefetchCount 的值，那么都会生效。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例中有两个消费者，各自的能接收到的未确认消息的上限都为10</span></span><br><span class="line">Channel channel = ...;</span><br><span class="line">Consumer consumer1 = ...;</span><br><span class="line">Consumer consumer2 = ...;</span><br><span class="line"><span class="comment">// Per consumer limit</span></span><br><span class="line">channel.basicQos(<span class="number">10</span>);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue1"</span>, <span class="keyword">false</span>, consumer1);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue2"</span>, <span class="keyword">false</span>, consumer2);</span><br></pre></td></tr></table></figure><p>如果在订阅消息之前，既设置了 global 为 true 的限制，又设置了 global 为 false 的限制，那么哪个会生效呢？ RabbitMQ 会确保两者都会生效。举例说明，当前有两个队列 queue1 和 queue2：queue1 有 10 条消息，分别为1到10; queue2 也有10条消息，分别为11到20 。有两个消费者分别消费这两个队列，如代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">Consumer consumer1 = ...;</span><br><span class="line">Consumer consumer2 = ...;</span><br><span class="line"><span class="comment">// Per consumer limit</span></span><br><span class="line">channel.basicQos(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Per Channel limit</span></span><br><span class="line">channel.basicQos(<span class="number">5</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue1"</span>, <span class="keyword">false</span>, consumer1);</span><br><span class="line">channel.basicConsume(<span class="string">"my-queue2"</span>, <span class="keyword">false</span>, consumer2);</span><br></pre></td></tr></table></figure><p>那么这里每个消费者最多只能收到3个未确认的消息，两个消费者能收到的未确认的消息个数之和的上限为5。在未确认消息的情况下，如果 consumer1 接收到了消息 ，那么 consumer2 至多只能收到 11 到 12 。如果像这样同时使用两种 global 的模式，则会增加 RabbitMQ 的负载，因为 RabbitMQ 需要更多的资源来协调完成这些限制。如无特殊需要，最好只使用 global 为 false 设置，这也是默认的设置。</p><h3 id="9-2-消息顺序性"><a href="#9-2-消息顺序性" class="headerlink" title="9.2 消息顺序性"></a>9.2 消息顺序性</h3><p>消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。举个例子，不考虑消息重复的情况，如果生产者发布的消息分别为 msg1、msg2、msg3 ，那么消费者必然也是按照此顺序进行消费的。</p><p>目前很多资料显示 RabbitMQ 的消息能够保障顺序性，这是不正确的，或者说这个观点有很大的局限性。在不使用任何 RabbitMQ 高级特性，也没有消息丢失、网络故障之类异常的情况发生，并且只有一个消费者的情况下，最好也只有一个生产者的情况下可以保证消息的顺序性。如果有多个生产者同时发送消息，无法确定消息到达 Broker 的前后顺序，也就无法验证消息的顺序性。</p><p>那么哪些情况下 RabbitMQ 的消息顺序性会被打破呢？</p><p>常见情形：</p><ul><li>如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补偿发送这条消息，如果补偿发送是在另一个线程实现的，那么消息在生产者这个源头就出现了错序。同样，如果启用 publisher confirm 时，在发生超时、中断，又或者是收到 RabbitMQ 的 <code>Basic.Nack</code> 命令时，那么同样需要补偿发送，结果与事务机制一样会错序。或者这种说法有 些牵强，我们可以固执地认为消息的顺序性保障是从存入队列之后开始的，而不是在发迭的时候开始的。</li><li>考虑另一种情形，如果生产者发送的消息设置了不同的超时时间，井且也设置了死信队列， 整体上来说相当于一个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致。</li><li>再考虑一种情形，如果消息设置了优先级，那么消费者消费到的消息也必然不是顺序性的。</li><li>如果一个队列按照前后顺序分有 msg1、msg2、msg3、msg4 这4个消息，同时有 ConsumerA 和 ConsumerB 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中， ConsumerA 中的消息为 msg1 和 msg3, ConsumerB 中的消息为 msg2 和 msg4。ConsumerA 收到消息 msg1 之后并不想处理而调用了 <code>Basic Nack/.Reject</code> 将消息拒绝，与此同时将 requeue 设置为 true ，这样这条消息就可以重新存入队列中。消息 msg1 之后被发送到了 ConsumerB 中，此时 ConsumerB 己经消费了 msg2 和 msg4 ，之后再消费 msg1 ，这样消息顺序性也就错乱了。或者消息 msg1 又重新发往 ConsumerA 中，此时 ConsumerA 消费了 msg3, 那么再消费 msg1 ，消息顺序性也无法得到保障。同样可以用在 <code>Basic.Recover</code> 这个 AMQP 命令中。</li></ul><p>包括但不仅限于以上几种情形会使 RabbitMQ 消息错序。如果要保证消息的顺序性，需要业务方使用 RabbitMQ 之后做进一步的处理，比如在消息体内添加全局有序标识（类似 Sequence ID ）来实现。</p><h3 id="9-3-弃用QueueingConsumer"><a href="#9-3-弃用QueueingConsumer" class="headerlink" title="9.3 弃用QueueingConsumer"></a>9.3 弃用QueueingConsumer</h3><p>在前面的章节中所介绍的订阅消费的方式都是通过继承 <code>DefaultConsumer</code> 类来实现的，建议不要使用 <code>QueueingConsumer</code> 这个类来实现订阅消费，在 4.x 版本开始被标记为 <code>＠Deprecated</code> ，想必这个类中有些无法弥补的缺陷：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"><span class="comment">//channel.basicQos(64); //使用QueueingConsumer一定要添加</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, <span class="string">"consumer_zzh"</span>, consumer);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">       String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">       System.out.println(<span class="string">" [X] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">       channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>乍一看没什么问题，而且实际生产环境中如果不是太“傲娇”地使用也不会造成什么大问题。QueueingConsumer 本身有几个大缺陷，需要在使用时特别注意 ：</p><ul><li>首当其冲的就是内存溢出的问题，如果由于某些原因，队列之中堆积了比较多的消息，就可能导致消费者客户端内存溢出假死，于是发生恶性循环，队列消息不断堆积而得不到消化。</li><li>QueueingConsumer 会拖累同一个 Connection 下的所有信道，使其性能降低；</li><li>同步递归调用 QueueingConsumer 会产生死锁：</li><li>RabbitMQ 的自动连接恢复机制（ automatic connection recove可）不支持 Queueing Consumer 的这种形式：</li><li>QueueingConsumer 不是事件驱动的。</li></ul><p>采用代码清单 4-22 中的代码进行演示 首先向一个队列发送 200多MB 的消息，然后进行消费。在客户端调用 channel.basicConsume 方法订阅队列的时候， RabbitMQ 会持续地将消息发往 QueueingConsumer 中， QueueingConsumer 内部使用 LinkedBlockingQueue 来缓存这些消息。通过 JVisualVM 可以看到堆内存的变化，如图 4-14 示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010176.png" alt></p><p>可以看到堆内存一直在增加，这里只测试了发送 200MB 左右的消息，如果发送更多的消息，那么这个堆内存会变得更大，直到出现 <code>java.lang.OutOfMemoryError</code> 的报错。</p><p>这个内存溢出的问题可以使用 <code>Basic.Qos</code> 来得到有效的解决，<code>Basic.Qos</code> 可以限制某个消费者所保持未确认消息的数量，也就是间接地限制了 QueueingConsumer 中的 LinkedBlockingQueue 的大小。注意一定要在调用 <code>Basic.Consume</code> 之前调用 <code>Basic.Qos</code> 才能生效。</p><p>为了避免不必要的麻烦，建议在消费的时候尽量使用继承 DefaultConsumer 的方式。</p><h2 id="第十节-消息传输保障"><a href="#第十节-消息传输保障" class="headerlink" title="第十节 消息传输保障"></a>第十节 消息传输保障</h2><p>消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题， 一般消息中间件的消息传输保障分为三个层级：</p><ul><li>At most once：最多一次。消息可能会丢失，但绝不会重复传输。</li><li>At least once：最少一次。消息绝不会丢失，但可能会重复传输。</li><li>Exactly once：恰好一次。每条消息肯定会被传输一次且仅传输一次。</li></ul><p>RabbitMQ 支持其中的“最多一次”和“最少一次”。其中“最少一次”投递实现需要考虑以下这个几个方面的内容：</p><ol><li>消息生产者需要开启事务机制或者 publisher confirm 机制，以确保消息可以可靠地传输到 RabbitMQ 中。</li><li>消息生产者需要配合使用 mandatory 参数或者备份交换器来确保消息能够从交换器路由到队列中，进而能够保存下来而不会被丢弃。</li><li>消息和队列都需要进行持久化处理，以确保 RabbitMQ 务器在遇到异常情况时不会造成消息丢失。</li><li>消费者在消费消息的同时需要将 autoAck 设置为 false ，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。</li></ol><p>“最多一次”的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这样很难确保消息不会丢失。</p><p>“恰好一次”是 RabbitMQ 目前无法保障的。考虑这样一种情况，消费者在消费完一条消息之后向 RabbitMQ 发送确认 <code>Basic.Ack</code> 命令，此时由于网络断开或者其他原因造成 RabbitMQ 并没有收到这个确认命令，那么 RabbitMQ 不会将此条消息标记删除。在重新建立连接之后， 消费者还是会消费到这一条消息，这就造成了重复消费。再考虑一种情况，生产者在使用 publisher confirm 机制的时候，发送完一条消息等待 RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送，这样 RabbitMQ 中就有两条同样的消息，在消费的时候，消费者就会重复消费。</p><p>那么 RabbitMQ 有没有去重的机制来保证“恰好一次”呢？答案是并没有，不仅是 RabbitMQ, 目前大多数主流的消息中间件都没有消息去重机制，也不保障“恰好一次”。去重处理一般是在业务客户端实现，比如引入 GUID (Globally Unique Identifier）的概念。针对 GUID ，如果从客户端的角度去 ，那么需要引入集中式缓存，必然会增加依赖复杂度，另外缓存的大小也难以界定。建议在实际生产环境中，业务方根据自身的业务特性进行去重，比如业务消息本身具备幂等性，或者借助 Redis 等其他产品进行去重处理。</p><hr><p>参考：</p><blockquote><p>《RabbitMQ实战指南》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第三章《进阶》，内容来自于《RabbitMQ实战指南》，内容包括：消息何去何从，过期时间，死信队列，延迟队列，优先级队列，RPC实现，持久化，生产者确认，消费端要点，消息传输保障等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>数据备份mysqldump</title>
    <link href="http://linyishui.top/2020092601.html"/>
    <id>http://linyishui.top/2020092601.html</id>
    <published>2020-09-27T06:46:17.000Z</published>
    <updated>2020-09-28T03:30:43.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据备份mysqldump"><a href="#数据备份mysqldump" class="headerlink" title="数据备份mysqldump"></a>数据备份mysqldump</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-什么是mysqldump？"><a href="#1-1-什么是mysqldump？" class="headerlink" title="1.1 什么是mysqldump？"></a>1.1 什么是mysqldump？</h3><p> <code>mysqldump</code> 是用于转存储 <code>mysql</code> 数据库的实用程序。生成一个 <code>SQL</code> 脚本，其中包含从头重新创建数据库的所有命令。</p><p>导出脚本的大概过程：创建数据库判断语句、删除表、创建表、锁表、禁用索引、插入数据、启用索引、解锁表。</p><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a>1.2 简单使用</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># game 是库名</span><br><span class="line"></span><br><span class="line"># 完整导出一个库</span><br><span class="line"># 包括建库语句、表结构、数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 --databases game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 只导出表结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -d game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 只导出数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -t game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 导出一个数据库中多个表的数据和结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game --tables articles users &gt; test.sql</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"># 恢复导出数据</span><br><span class="line">mysql -u username -proot databse &lt; backup.sql</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>--user=user_name, -u user_name</code> ：连接数据库的用户名。</li><li><code>--password=password, -p[password]</code> ：连接数据库的密码，如果使用 <code>-p</code> 缩写，和密码之间不能有空格。</li><li><code>--opt or --compact</code> ：<ul><li>使用 <code>--opt</code> 等于使用这些参数 <code>--add-drop-table, --add-locks, --create-options, --disable-keys, --extended-insert, --lock-tables, --quick, and --set-charset</code>，默认情况下即使不加 <code>--opt</code> 参数也是开启的。</li><li>使用 <code>--compact</code> 等于使用这些参数 <code>--skip-add-drop-table, --skip-add-locks, --skip-comments, --skip-disable-keys, and --skip-set-charset</code>，默认不开启。</li></ul></li><li><code>--databases, -B</code> ：指定导出的库名。</li><li><code>--all-databases</code> ：表示导出所有的库。</li><li><code>--tables</code> ：会覆盖 –databases or -B 选项，指定导出某个表就会忽略库选项。</li><li><code>--no-data, -d</code> ：不导出数据，只导出表结构。</li><li><code>--no-create-info, -t</code> ：只导出数据，不导出表结构，不添加 <code>CREATE TABLE</code> 语句。</li><li><code>--no-create-db, -n</code> ：不添加 <code>CREATE DATABASE</code> 建库语句。</li><li><code>--routines, -R</code> ：导出存储过程以及自定义函数。</li></ul><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><p>实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 导出一个数据库</span><br><span class="line">// 包括建库语句、删表语句、建表语句、插入数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 --databases game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="comment">/*!32312 IF NOT EXISTS*/</span> <span class="string">`game`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> <span class="string">`game`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `address`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`address`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`address`</span> (</span><br><span class="line">        ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`address`</span> WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ...</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` ENABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// -d 不导出数据，导出所有的建表删表语句，不包括建库语句，</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -d game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`address`</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = utf8 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`address`</span> (</span><br><span class="line">        ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// -t 不导出结构，导出所有表中的数据，不包括建库语句，都是插入语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 -t game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`address`</span> WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` DISABLE KEYS */</span>;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `address` ENABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line"></span><br><span class="line">// 导出一个数据库的表结构以及数据，不包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --port=3306 game &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的表结构以及数据，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -B game game2 &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的结构，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -d -B game game2 &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出多个数据库的数据，包括建库语句</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -t -B game game2 &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>导出某张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 导出一个数据库中一个表的结构，导出 articles 表的结构和数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的数据和结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game --tables articles users &gt; test.sql</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的结构</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -d game articles users &gt; test.sql</span></span><br><span class="line"></span><br><span class="line">// 导出一个数据库中多个表的数据</span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 -t game articles users &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>数据表条件导出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出 articles 表 id = 1 的数据</span></span><br><span class="line">mysqldump -u root -p root <span class="comment">--host=127.0.0.1 --where='id=1' game articles &gt; test.sql</span></span><br></pre></td></tr></table></figure><p>忽略某张表：多次添加忽略多张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--ignore-table database.tableName</span></span><br></pre></td></tr></table></figure><p>导入某个表数据脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 数据来源</span><br><span class="line">src_user="root" # 用户名</span><br><span class="line">src_password="root" # 密码</span><br><span class="line">src_host="localhost" # Host</span><br><span class="line">src_port="3306" # 端口</span><br><span class="line">src_database="test" # 数据库名</span><br><span class="line">src_table="edu" # 表名</span><br><span class="line"></span><br><span class="line"># 数据导入的数据库配置</span><br><span class="line">dst_user="root" # 用户名</span><br><span class="line">dst_password="root" # 密码</span><br><span class="line">dst_host="localhost" # Host</span><br><span class="line">dst_port="3306" # 端口</span><br><span class="line">dst_database="test" # 数据库名</span><br><span class="line"></span><br><span class="line">mysqldump <span class="comment">--host=$src_host --port=$src_port -u$src_user -p$src_password $src_database --tables $src_table | mysql --host=$dst_host --port=$dst_port -u$dst_user -p$dst_password $dst_database</span></span><br></pre></td></tr></table></figure><p>备份脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 以下配置信息请自己修改</span><br><span class="line">mysql_user="root" #MySQL备份用户</span><br><span class="line">mysql_password="root" #MySQL备份用户的密码</span><br><span class="line">mysql_host="localhost"</span><br><span class="line">mysql_port="3306"</span><br><span class="line">mysql_charset="utf8mb4" #MySQL编码</span><br><span class="line">backup_db_arr=("db1" "db2") #要备份的数据库名称，多个用空格分开隔开 如("db1" "db2" "db3")</span><br><span class="line">backup_location=/var/www/mysql  #备份数据存放位置，末尾请不要带"/",此项可以保持默认，程序会自动创建文件夹</span><br><span class="line">expire_backup_delete="OFF" #是否开启过期备份删除 ON为开启 OFF为关闭</span><br><span class="line">expire_days=3 #过期时间天数 默认为三天，此项只有在expire_backup_delete开启时有效</span><br><span class="line"></span><br><span class="line"># 本行开始以下不需要修改</span><br><span class="line">backup_time=`date +%Y%m%d%H%M`  #定义备份详细时间</span><br><span class="line">backup_Ymd=`date +%Y-%m-%d` #定义备份目录中的年月日时间</span><br><span class="line">backup_3ago=`date -d '3 days ago' +%Y-%m-%d` #3天之前的日期</span><br><span class="line">backup_dir=$backup_location/$backup_Ymd  #备份文件夹全路径</span><br><span class="line">welcome_msg="Welcome to <span class="keyword">use</span> MySQL <span class="keyword">backup</span> tools!<span class="string">" #欢迎语</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 判断MYSQL是否启动,mysql没有启动则备份退出</span></span><br><span class="line"><span class="string">mysql_ps=`ps -ef |grep mysql |wc -l`</span></span><br><span class="line"><span class="string">mysql_listen=`netstat -an |grep LISTEN |grep $mysql_port|wc -l`</span></span><br><span class="line"><span class="string">if [ [$mysql_ps == 0] -o [$mysql_listen == 0] ]; then</span></span><br><span class="line"><span class="string">        echo "</span><span class="keyword">ERROR</span>:MySQL <span class="keyword">is</span> <span class="keyword">not</span> running! <span class="keyword">backup</span> <span class="keyword">stop</span>!<span class="string">"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">        echo $welcome_msg</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 连接到mysql数据库，无法连接则备份退出</span></span><br><span class="line"><span class="string">mysql -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password &lt;&lt;end</span></span><br><span class="line"><span class="string">use mysql;</span></span><br><span class="line"><span class="string">select host,user from user where user='root' and host='localhost';</span></span><br><span class="line"><span class="string">exit</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">flag=`echo $?`</span></span><br><span class="line"><span class="string">if [ $flag != "</span><span class="number">0</span><span class="string">" ]; then</span></span><br><span class="line"><span class="string">        echo "</span><span class="keyword">ERROR</span>:Can<span class="string">'t connect mysql server! backup stop!"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">        echo "MySQL connect ok! Please wait......"</span></span><br><span class="line"><span class="string">        # 判断有没有定义备份的数据库，如果定义则开始备份，否则退出备份</span></span><br><span class="line"><span class="string">        if [ "$backup_db_arr" != "" ];then</span></span><br><span class="line"><span class="string">                #dbnames=$(cut -d '</span>,<span class="string">' -f1-5 $backup_database)</span></span><br><span class="line"><span class="string">                #echo "arr is ($&#123;backup_db_arr[@]&#125;)"</span></span><br><span class="line"><span class="string">                for dbname in $&#123;backup_db_arr[@]&#125;</span></span><br><span class="line"><span class="string">                do</span></span><br><span class="line"><span class="string">                        echo "database $dbname backup start..."</span></span><br><span class="line"><span class="string">                        `mkdir -p $backup_dir`</span></span><br><span class="line"><span class="string">                        `mysqldump -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password $dbname --default-character-set=$mysql_charset | gzip &gt; $backup_dir/$dbname-$backup_time.sql.gz`</span></span><br><span class="line"><span class="string">                        flag=`echo $?`</span></span><br><span class="line"><span class="string">                        if [ $flag == "0" ];then</span></span><br><span class="line"><span class="string">                                echo "database $dbname success backup to $backup_dir/$dbname-$backup_time.sql.gz"</span></span><br><span class="line"><span class="string">                        else</span></span><br><span class="line"><span class="string">                                echo "database $dbname backup fail!"</span></span><br><span class="line"><span class="string">                        fi</span></span><br><span class="line"><span class="string">                        </span></span><br><span class="line"><span class="string">                done</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">                echo "ERROR:No database to backup! backup stop"</span></span><br><span class="line"><span class="string">                exit</span></span><br><span class="line"><span class="string">        fi</span></span><br><span class="line"><span class="string">        # 如果开启了删除过期备份，则进行删除操作</span></span><br><span class="line"><span class="string">        if [ "$expire_backup_delete" == "ON" -a  "$backup_location" != "" ];then</span></span><br><span class="line"><span class="string">                 #`find $backup_location/ -type d -o -type f -ctime +$expire_days -exec rm -rf &#123;&#125; \;`</span></span><br><span class="line"><span class="string">                 `find $backup_location/ -type d -mtime +$expire_days | xargs rm -rf`</span></span><br><span class="line"><span class="string">                 echo "Expired backup data delete complete!"</span></span><br><span class="line"><span class="string">        fi</span></span><br><span class="line"><span class="string">        echo "All database backup success! Thank you!"</span></span><br><span class="line"><span class="string">        exit</span></span><br><span class="line"><span class="string">fi</span></span><br></pre></td></tr></table></figure><p>修改shell脚本的属性：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">600</span> <span class="regexp">/root/my</span>sql_backup.sh</span><br><span class="line">chmod +x <span class="regexp">/root/my</span>sql_backup.sh</span><br></pre></td></tr></table></figure><p>设置好属性之后，把命令加入 <code>crontab</code>，设置每天 <code>00:00</code> 定时自动备份。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00 </span><span class="number">00</span> * * * /path/<span class="keyword">to</span>/mysql_backup.sh</span><br></pre></td></tr></table></figure><p>恢复备份：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql -u username -proot databse &lt; backup.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和建库语句一起导入</span></span><br><span class="line">mysql -u root -p root --host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port=<span class="number">33006</span>  &lt; global.sql</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">use dbname;</span><br><span class="line"></span><br><span class="line">source dbname.sql</span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="https://juejin.im/post/6844903653183062030" target="_blank" rel="noopener">mysqldump 深入浅出</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据迁移</title>
    <link href="http://linyishui.top/2020092701.html"/>
    <id>http://linyishui.top/2020092701.html</id>
    <published>2020-09-27T06:06:40.000Z</published>
    <updated>2020-09-27T07:46:25.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-什么是数据迁移？"><a href="#1-1-什么是数据迁移？" class="headerlink" title="1.1 什么是数据迁移？"></a>1.1 什么是数据迁移？</h3><p><strong>数据迁移</strong>（英语：data migration）是指<strong>选择、准备、提取和转换数据</strong>，并<strong>将数据从一个计算机存储系统永久地传输到另一个计算机存储系统</strong>的过程。此外，<strong>验证迁移数据的完整性</strong>和<strong>退役原来旧的数据存储</strong>，也被认为是整个数据迁移过程的一部分。数据迁移是任何系统实现、升级或集成的关键考虑因素，通常以尽可能自动化的方式执行，从而将人力资源从繁琐的任务中解放出来。数据迁移有多种原因，包括服务器或存储设备更换、维护或升级、应用程序迁移、网站集成、灾难恢复和数据中心迁移。</p><h3 id="1-2-为什么需要迁移数据？"><a href="#1-2-为什么需要迁移数据？" class="headerlink" title="1.2 为什么需要迁移数据？"></a>1.2 为什么需要迁移数据？</h3><ul><li>数据备份</li><li>数据转换</li><li>业务需求</li><li>……</li></ul><h3 id="1-3-常见方案"><a href="#1-3-常见方案" class="headerlink" title="1.3 常见方案"></a>1.3 常见方案</h3><ul><li>mysqldump：导出一个SQL文件，再在新数据库中执行。效率低耗时高，失败率高。<ul><li>参考：《<a href="../2020092601.html" title="Title">数据备份mysqldump</a>》</li></ul></li><li>脚本迁移：<ul><li><strong>实现一个迁移脚本</strong>，远程连接源数据库，分块读取后再写入目标数据库。可以通过切分然后多线程执行的方式进行优化，但<strong>只能先读后写</strong>。</li><li><strong>通过 Redis 搭建一个生产者+ 消费者的迁移方案</strong>，在源数据服务器运行一个多线程脚本，并行读取数据，并生产到Redis队列；在目标服务器也运行一个多线程脚本，远程连接Redis，并行读取队列中的数据，并把数据写入目标数据库。相比前一个方案，这种方式是<strong>异步</strong>的，<strong>读和写可以同时进行</strong>。</li></ul></li><li>文件迁移：SqlLoader（Oracle）或 <code>load data infile</code>（MySql）如： <code>select data into outfile file.txt</code>、<code>load data infile file.txt into table</code> 的命令。<ul><li>参考：《<a href="../2020092401.html" title="Title">SqlLoader</a>》</li></ul></li></ul><h2 id="第二节-方案实战"><a href="#第二节-方案实战" class="headerlink" title="第二节 方案实战"></a>第二节 方案实战</h2><p>数据准备，一张日志表：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010163.png" alt></p><p>数据量为一千万：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010164.png" alt></p><p>将其从 test 库迁移到 test_b 库。</p><h3 id="2-1-mysqldump"><a href="#2-1-mysqldump" class="headerlink" title="2.1 mysqldump"></a>2.1 mysqldump</h3><h3 id="2-MySql-SqlLoader"><a href="#2-MySql-SqlLoader" class="headerlink" title="2. MySql SqlLoader"></a>2. MySql SqlLoader</h3><p>1.在源数据库导出数据文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'logs1.txt'</span>;</span><br></pre></td></tr></table></figure><p>执行耗时：（只需半分钟）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010160.png" alt></p><p>文件大小：676MB</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010161.png" alt></p><p>生成文件格式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1811</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span>首页</span><br><span class="line"><span class="selector-tag">1812</span><span class="selector-tag">2</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:01</span>首页</span><br><span class="line"><span class="selector-tag">1813</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span>首页</span><br><span class="line"><span class="selector-tag">1814</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:03</span>首页</span><br><span class="line"><span class="selector-tag">1815</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:04</span>首页</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>2.复制数据文件到目标服务器：（如果是在服务器端操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip fans.zip /data/fans.txt</span><br><span class="line">scp fans.zip root@ip:/data/ </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在目标数据库导入文件</span></span><br><span class="line">unzip /data/fans.zip</span><br></pre></td></tr></table></figure><p>3.目标数据库执行命令：（需要先导入表结构）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'logs1.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> logs1(<span class="keyword">id</span>, logtype, logurl, logip, logdz, ladduser, lfadduser, laddtime, htmlname);</span><br></pre></td></tr></table></figure><p>执行耗时：（只需5分钟左右）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010162.png" alt></p><p>对比导出SQL文件，耗时从将近1小时缩短到5分钟。</p><p>在mysql执行 <code>load data infile</code> 和 <code>into outfile</code> 命令都需要在mysql开启了 <code>secure_file_priv</code> 选项， 可以通过 <code>show global variables like &#39;%secure%&#39;;</code> 查看mysql是否开启了此选项，默认值Null标识不允许执行导入导出命令。通过 <code>vim /etc/my.cnf</code> （Windows修改 <code>my.ini</code> ）修改mysql配置项，将 <code>secure_file_priv</code> 的值设置为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">  secure_file_priv=&apos;&apos;</span><br></pre></td></tr></table></figure><p>在导入数据的时候，可以通过设置字段名来匹配目标字段的数据，可以通过<code>@dummy</code>丢弃掉不需要的目标字段数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/data/fans.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> wxa_fans(<span class="keyword">id</span>,appid,openid,unionid,@dummy,created_at,@dummy,nickname,gender,avatar_url,@dummy,@dummy,@dummy,@dummy,<span class="keyword">language</span>,country,province,city,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy,@dummy);</span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="https://juejin.im/post/6844903630227636237" target="_blank" rel="noopener">Mysql百万级数据迁移实战笔记</a></p></blockquote><blockquote><p><a href="https://cloud.google.com/solutions/database-migration-concepts-principles-part-1?hl=zh-cn" target="_blank" rel="noopener">数据库迁移：概念和原则（第 1 部分）</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理一下数据库中数据迁移相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>SqlLoader</title>
    <link href="http://linyishui.top/2020092401.html"/>
    <id>http://linyishui.top/2020092401.html</id>
    <published>2020-09-24T07:26:04.000Z</published>
    <updated>2020-09-27T08:38:21.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SqlLoader"><a href="#SqlLoader" class="headerlink" title="SqlLoader"></a>SqlLoader</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-常见的几种数据迁移方式"><a href="#1-1-常见的几种数据迁移方式" class="headerlink" title="1.1 常见的几种数据迁移方式"></a>1.1 常见的几种数据迁移方式</h3><p>日常开发中会经常遇到这样的需求，大批量的数据需要在不同的数据库间迁移，一般会有如下几种方式（不一定涵盖所有）：</p><ul><li>源数据库直接导出SQL文件，目标数据库执行；<ul><li>数据量大时效率很低，甚至可能会卡死客户端。</li></ul></li><li>创建数据库间的DBLink，用 <code>create table B as select * from A@dblink where ...</code> ，或 <code>insert into B select * from A@dblink where ...</code> ；</li><li>exp A 表，再 imp 到 B 表，exp 时可加查询条件；</li><li>程序实现 <code>select from A ..</code> ，然后 <code>insert into B ...</code> ，也要分批提交；</li><li>SqlLoader导入数据。</li></ul><h3 id="1-2-什么是SqlLoader"><a href="#1-2-什么是SqlLoader" class="headerlink" title="1.2 什么是SqlLoader"></a>1.2 什么是SqlLoader</h3><p>Oracle提供了 <code>sqlldr</code> 命令，参数：</p><ul><li>userid：username/password[@servicename]；</li><li>control：控制文件，可能包含表的数据；</li><li>log：记录导入时的日志文件，默认为 控制文件(去除扩展名).log；</li><li>bad：坏数据文件，默认为 控制文件(去除扩展名).bad；</li><li>data：数据文件，一般在控制文件中指定。用参数控制文件中不指定数据文件更适于自动操作；</li><li>errors：允许的错误记录数，可以用他来控制一条记录都不能错；</li><li>rows：多少条记录提交一次，默认为 64；</li><li>skip：跳过的行数，比如导出的数据文件前面几行是表头或其他描述。</li></ul><p>sqlldr是在处理大数据量的操作中建议采用的方式，它有许多性能相关的开关，能最大程度的减少 redo，undo 的生成。</p><p>MySql中对应的语句：<code>load data infile</code> 。</p><h3 id="1-3-SqlLoader用法"><a href="#1-3-SqlLoader用法" class="headerlink" title="1.3 SqlLoader用法"></a>1.3 SqlLoader用法</h3><p>控制文件 <code>.ctl</code> 格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 控制文件标识</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 要导入的数据文件名</span></span><br><span class="line"><span class="keyword">INFILE</span> <span class="string">'xxx.txt'</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 将文件插入到数据库的 test 表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 用于分割一行中各个属性值的符号（例如每个属性值用逗号分割， 那么就把 X'09' 改为','）</span></span><br><span class="line"><span class="keyword">Fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> X<span class="string">'09'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. test表中对应的属性名</span></span><br><span class="line">(<span class="keyword">id</span>, username, passwprd, ......)</span><br></pre></td></tr></table></figure><p>操作类型有：</p><ol><li>insert：为缺省方式，在数据装载开始时要求表为空；</li><li>append：在表中追加新记录；</li><li>replace：删除旧记录(用 delete from table 语句)，替换成新装载的记录；</li><li>truncate：删除旧记录(用 truncate table 语句)，替换成新装载的记录。</li></ol><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此文件格式是.log，用文本文件的方法可以导入进去</span></span><br><span class="line"><span class="keyword">infile</span> <span class="string">'D:/xxx/xxx.log'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- insert为缺省方式，插入时要求表为空</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> database_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据文件每个字段也就是属性是按照|来分割的</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'|'</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据中某些属性可能是null值 ， 如果不加入这行导入到数据库的时候就会自动跳过null值的列, 这样数据插入后就会属性和值对应不上</span></span><br><span class="line">trailing nullcols </span><br><span class="line"></span><br><span class="line"><span class="comment">-- content运用的类型是clob，当使用sqlldr加载很长的字符串(超过4000)到表中的clob类型中时会报错：数据文件的字段超出最大长度；sqlldr每次读入文件中数据流的数据类型默认为CHAR ,长度为 255 .所以只要超过255字符的段都会报这个错，所以char(10000)用来控制上限</span></span><br><span class="line">(<span class="keyword">time</span>, user_id, <span class="keyword">type</span>, longitude, latitude, height, <span class="keyword">content</span> <span class="built_in">char</span>(<span class="number">10000</span>))</span><br></pre></td></tr></table></figure><p>接下来可以直接通过 <code>sqlldr</code> 语句导入，一般项目会通过一个数据文件和一个控制文件来实现此功能，这样可以将模板和数据分离，可以重复使用：</p><ul><li>数据文件：可以是PL/SQL或Toad导出、SqlPlus的Spool格式化产出、UTL_FILE包生成。</li></ul><h3 id="1-4-LOAD-DATA-INFILE用法"><a href="#1-4-LOAD-DATA-INFILE用法" class="headerlink" title="1.4 LOAD DATA INFILE用法"></a>1.4 LOAD DATA INFILE用法</h3><p><code>LOAD DATA INFILE</code> 是  <code>SELECT ... INTO OUTFILE</code> 的相对语句。把表的数据备份到文件使用 <code>SELECT ... INTO OUTFILE</code> ，从备份文件恢复表数据，使用  <code>LOAD DATA INFILE</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">CONCURRENT</span>] [<span class="keyword">LOCAL</span>] <span class="keyword">INFILE</span> <span class="string">'file_name.txt'</span></span><br><span class="line">    [<span class="keyword">REPLACE</span> | <span class="keyword">IGNORE</span>]</span><br><span class="line">    <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tbl_name</span><br><span class="line">    [<span class="keyword">FIELDS</span></span><br><span class="line">        [<span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">        [[<span class="keyword">OPTIONALLY</span>] <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'char'</span>]</span><br><span class="line">        [<span class="keyword">ESCAPED</span> <span class="keyword">BY</span> <span class="string">'char'</span> ]</span><br><span class="line">    ]</span><br><span class="line">    [<span class="keyword">LINES</span></span><br><span class="line">        [<span class="keyword">STARTING</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">        [<span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'string'</span>]</span><br><span class="line">    ]</span><br><span class="line">    [<span class="keyword">IGNORE</span> <span class="built_in">number</span> <span class="keyword">LINES</span>]</span><br><span class="line">    [(col_name_or_user_var,...)]</span><br><span class="line">    [<span class="keyword">SET</span> col_name = expr,...)]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'data.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tbl_name </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> </span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span> </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只载入部分列</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'persondata.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> persondata (col1,col2)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p>LOW_PRIORITY：适用于表锁存储引擎，比如MyISAM, MEMORY, 和 MERGE，在写入过程中如果有客户端程序读表，写入将会延后，直至没有任何客户端程序读表再继续写入。</p></li><li><p>CONCURRENT：使用该参数，允许在写入过程中其它客户端程序读取表内容。</p></li><li><p>LOCAL：关键字影响数据文件定位和错误处理，影响在哪里找到数据文件。只有当 mysql-server 和 mysql-client 同时在配置中指定允许使用，LOCAL关键字才会生效。</p><ul><li><p>LOCAL load operations：如果指定了LOCAL，数据文将被客户端程序从客户端主机读取，然后发送给服务器主机。将在服务器主机的临时目录创建一个数据文件的副本，如果临时目录剩余空间不足，将导致语句执行失败。</p></li><li><p>Non-LOCAL load operations：如果没有指定LOCAL，数据文件必须位于服务器值机上，直接由 mysql-server 读取。mysql-serve 使用如下规则来定位文件：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>数据文件使用绝对路径，直接使用</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>数据文件使用相对路径并且有前导的部分，将相对于 mysql-server 的数据目录查找，例如 ./myfile.txt</span><br><span class="line"></span><br><span class="line"><span class="bullet">3. </span>数据文件使用相对路径并且没有前导的部分，将相对于默认数据库的数据文件目录查找,例如 myfile.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>根据上面的规则，./myfile.txt  将被定位到 mysql-server 的 data directory,而 myfile.txt 将被定位到 default database 的  database directory。如果 db1 时默认数据库，则下面的语句将从 db1 的数据库目录读取 data.txt,即使明确指定把数据装载到 db2：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'data.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> db2.my_table;</span><br></pre></td></tr></table></figure>Non-LOCAL load operations 从服务器主机上读取数据文将。出于安全原因，这个操作需要文件权限。 如果secure_file_priv 系统变量的value 不为空，数据文件必须放在该变量指定的目录。如果该变量为空，数据文件必须可读。使用LOCAL将比让服务器直接存取文件慢些，因为文件的内容必须从客户主机传送到服务器主机。在另一方面，你不需要file权限装载本地文件。</code></pre><ul><li><p>LOCAL关键字对错误处理的影响：</p><ol><li>使用 LOAD DATA INFILE,data-interpretation 和 duplicate-key 错误会终止操作；</li><li>使用 LOAD DATA LOCAL INFILE，data-interpretation 和 duplicate-key 错误会发出警告，操作将继续执行。对于duplicate-key错误，效果和指定了 IGNORE 关键字一样。</li></ol></li></ul><ul><li><p>REPLACE | IGNORE：控制对现有的唯一键记录的重复的处理。</p><ul><li>指定REPLACE，新行将代替有相同的唯一键值的现有行。</li><li>指定IGNORE，跳过有唯一键的现有行的重复行的输入。</li><li>不指定任何一个选项，当找到重复键键时，出现一个错误，并且文本文件的余下部分被忽略时。</li></ul></li><li><p>FIELDS：</p><ul><li><p>基本用法：如果指定一个FIELDS子句，它的每一个子句(TERMINATED BY, [OPTIONALLY] ENCLOSED BY和ESCAPED BY)也是可选的，但是必须至少指定一个。</p><p>如果你指定 FIELDS 或 LINES ，缺省值为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'</span><br><span class="line">LINES TERMINATED BY '\n' STARTING BY ''</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>缺省值导致读取输入时，LOAD DATA INFILE表现如下：1. 在 \n 处寻找行边界2. 在 \t 处将行分进字段3. 不要期望字段由任何引号字符封装4. 将由“\”开头的定位符、换行符或“\”解释成转义序列。例如 \t, \n, and \ 分别解释成 定位符，换行，反斜杠。相反，缺省值导致在写入输出时，SELECT ... INTO OUTFILE表现如下：1. 在字段之间写 \t2. 不用任何引号字符封装字段3. 使用“\”转义出现在字段中的 定位符、换行符或“\”字符4. 在行尾处写换行符</code></pre><ul><li><p>FIELDS [OPTIONALLY] ENCLOSED BY：控制哪些字段应该包裹在引号里面。</p><p>对于SELECT … INTO OUTFILE 输出，如果不包含OPTIONALLY选项，所有的字段将会被ENCLOSED BY指定的字符包裹，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1"</span>,<span class="string">"a string"</span>,<span class="string">"100.20"</span>  </span><br><span class="line"><span class="string">"2"</span>,<span class="string">"a string containing a , comma"</span>,<span class="string">"102.20"</span>  </span><br><span class="line"><span class="string">"3"</span>,<span class="string">"a string containing a \" quote"</span>,<span class="string">"102.20"</span>  </span><br><span class="line"><span class="string">"4"</span>,<span class="string">"a string containing a \", quote and comma"</span>,<span class="string">"102.20"</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>如果我们指定OPTIONALLY，只有string数据类型（如 CHAR, BINARY, TEXT, 或 ENUM）的字段才会被ENCLOSED BY指定的字符包裹，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a \" quote"</span>,102.20  </span><br><span class="line">4,<span class="string">"a string containing a \", quote and comma"</span>,102.20</span><br></pre></td></tr></table></figure>注意，如果在字段值内出现ENCLOSED BY字符，则通过使用ESCAPED BY字符作为前缀，对ENCLOSED BY字符进行转义。另外，要注意，如果指定了一个空ESCAPED BY值，则可能会生成不能被LOAD DATAINFILE 正确读取的输出值。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a "</span> quote<span class="string">",102.20  </span></span><br><span class="line"><span class="string">4,"</span>a string containing a <span class="string">", quote and comma"</span>,102.20</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>FIELDS ESCAPED BY：用来控制如何对特殊字符进行读写。</p><p>如上面一个例子，导出和导入时指定FIELDS ESCAPED BY为双引号[“]才能被正确的导入，导出的格式如下，对字段内的双引号[“]进行了转义。</p></li></ul><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,<span class="string">"a string"</span>,100.20  </span><br><span class="line">2,<span class="string">"a string containing a , comma"</span>,102.20  </span><br><span class="line">3,<span class="string">"a string containing a #"</span> quote<span class="string">",102.20  </span></span><br><span class="line"><span class="string">4,"</span>a string containing a <span class="comment">#", quote and comma",102.20</span></span><br></pre></td></tr></table></figure>对于输入： 假如FIELDS ESCAPED BY指定字符非空，则输入时该字符被移除，后续的内容被添加到字段里。一些两个字符的字符串序列且第一个字符是转义字符的例外 。这些字符序列见下表：| Character | Escape Sequence                || :-------: | ------------------------------ ||    \0     | An ASCII NUL (X&apos;00&apos;) character ||    \b     | A backspace character          ||    \n     | A newline (linefeed) character ||    \r     | A carriage return character    ||    \t     | A tab character.               ||    \Z     | ASCII 26 (Control+Z)           ||    \N     | NULL                           |假如FIELDS ESCAPED BY指定字符为空，将不会发生转义序列的解释。对于输出，如果FIELDS ESCAPED BY指定字符非空，字符作为以下输出的前缀：1. FIELDS ESCAPED BY 字符，例如 \2. FIELDS [OPTIONALLY] ENCLOSED BY 字符，例如 &quot;3. FIELDS TERMINATED BY and LINES TERMINATED BY 的 value 的第一个字符,例如\n4. ASCII 0如果LINES TERMINATED BY是空字符串，FIELDS TERMINATED BY非空,字符将不会被转义，NULL 将输出为 NULL而不是 \N。指定LINES TERMINATED BY为空字符串并不是个好主意，特别当内容中包含上表列出的特殊字符时。</code></pre><ul><li><p>LINES STARTING BY：如果所有希望读入的行都含有一个我们希望忽略的共用前缀，则可以使用 LINES STARTING BY ‘prefix_string’  来跳过前缀（以及该前缀前的所有字符）。如果某行不包括前缀，则整个行被跳过。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> </span><br><span class="line">   <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>  <span class="keyword">LINES</span> <span class="keyword">STARTING</span> <span class="keyword">BY</span> <span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure></li></ul><pre><code>假如/tmp/test.txt文件内容如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx"abc",1  </span><br><span class="line">something xxx"def",2  </span><br><span class="line">"ghi",3</span><br></pre></td></tr></table></figure>则我们读入的内容包括(&quot;abc&quot;,1) 和 (&quot;def&quot;,2)，第三行直接被跳过。</code></pre><ul><li><p>IGNORE number LINES：该选项可以被用于在文件的开始处忽略行。例如，我们可以使用IGNORE 1 LINES来跳过一个包含列名称的起始标题行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">IGNORE</span> <span class="number">1</span> <span class="keyword">LINES</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在特定情况下，field-和line-handling选项相互影响：</p><ol><li>如果LINES TERMINATED BY是空字符串，FIELDS TERMINATED BY非空,行以FIELDS TERMINATED BY指定的字符串作为结尾。</li><li>如果FIELDS TERMINATED BY 与 FIELDS ENCLOSED BY值均为空(‘’)，将使用固定行（无分割）格式。使用固定行格式，字段之间将没有分隔符（行终止符依然可使用），列字段数据的读取和写入均按照字段定义的宽度去操作，如 TINYINT, SMALLINT, MEDIUMINT, INT, 和 BIGINT, 字段宽度分别为4, 6, 8, 11, 和 20。</li></ol></li><li><p>不适合使用 LOAD DATA INFILE 的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用固定行格式（即FIELDS TERMINATED BY 和 FIELDS ENCLOSED BY 均为空）,列字段类型为BLOB或TEXT。</span><br><span class="line">2. 指定分隔符与其它选项前缀一样，<span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>不能对输入做正确的解释。例如：</span><br><span class="line">   <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'"'</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span>  </span><br><span class="line"><span class="number">3.</span> 如果 <span class="keyword">FIELDS</span> <span class="keyword">ESCAPED</span> <span class="keyword">BY</span> 为空，字段值包含 <span class="keyword">FIELDS</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> 指定字符，或者 <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> 的字符在 <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> 之前，都会导致过早的停止 <span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>操作。因为<span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span>不能准确的确定行或列的结束。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>IGNORE number LINES 选项：IGNORE number LINES选项可以被用于在文件的开始处忽略行。<br>您可以使用IGNORE 1 LINES来跳过一个包含列名称的起始标题行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/tmp/test.txt'</span>  <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">IGNORE</span> <span class="number">1</span> <span class="keyword">LINES</span>;</span><br></pre></td></tr></table></figure></li><li><p>选择导入的列：</p><p>下面的语句会导入文件的所有列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'persondata.txt'</span> INTO TABLE persondata;</span><br></pre></td></tr></table></figure><p>如果我们想导入表的某些列，需要指定列的列表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'persondata.txt'</span> <span class="function">INTO TABLE <span class="title">persondata</span> (<span class="params">col1,col2,...</span>)</span>;</span><br></pre></td></tr></table></figure><p>如果输入文件与表的列顺序不同，我们必须指定一个列清单，否则mysql不能把输入文件的字段与表的列匹配起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA INFILE <span class="string">'/tmp/loadtest.txt'</span> INTO TABLE loadtest </span><br><span class="line">   FIELDS TERMINATED BY <span class="string">','</span> </span><br><span class="line">   OPTIONALLY ENCLOSED BY <span class="string">'"'</span> </span><br><span class="line">   ESCAPED BY <span class="string">'#'</span> </span><br><span class="line">   LINES TERMINATED BY <span class="string">'\n'</span> </span><br><span class="line">   (c1, c2, c4, c3);</span><br></pre></td></tr></table></figure><p>列的清单可以包含列名或者用户变量，在写入列前我们需要使用SET语句对用户变量进行转换。对set语句及用户变量有如下使用方法：</p><p>方法1：在用户变量用于第一列之前，先把第一列的值赋予用户变量，进行除法操作后输入到c1。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, <span class="meta">@var</span>1)</span><br><span class="line">  SET column2 = <span class="meta">@var</span>1/<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>方法2The SET clause can be used to supply values not derived from the input file. 。使用下面例子把c3列设为当前时间</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, column2)</span><br><span class="line">  SET column3 = CURRENT_TIMESTAMP;</span><br></pre></td></tr></table></figure><p>方法3：把输入赋予用户变量，而不把用户变量赋予表中的列，来丢弃此输入值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">'file.txt'</span></span><br><span class="line">  INTO TABLE t1</span><br><span class="line">  (column1, <span class="meta">@dummy</span>, column2, <span class="meta">@dummy</span>, column3);</span><br></pre></td></tr></table></figure></li><li><p>通过管道导入数据：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在unix系统中，如果我们想要从管道（pipe）中load data，需要用如下方法：</span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># mkfifo /tmp/ls.dat  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># chmod 666 /tmp/ls.dat  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># find / -ls &gt; /tmp/ls.dat &amp;  </span></span><br><span class="line">[root<span class="symbol">@localhost</span> tmp]<span class="meta"># mysql -e <span class="string">"LOAD DATA INFILE '/tmp/ls.dat' INTO TABLE test.tb1 FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"</span><span class="string">' ESCAPED BY '</span>#<span class="string">' LINES TERMINATED BY '</span>\n<span class="string">'"</span></span></span><br></pre></td></tr></table></figure><p>注意：sql-mode使用严格事物模式STRICT_TRANS_TABLES会报错</p><p>在另一窗口将数据写入管道</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> <span class="regexp">/]# cat /</span>tmp<span class="regexp">/loadtest.txt &gt; /</span>tmp/ls.dat</span><br></pre></td></tr></table></figure><p>注：可以先读或者先写管道，谁先谁后都可以，在写入管道的数据被全部读出前，处于阻塞状态。</p></li></ul><h2 id="第二节-实战"><a href="#第二节-实战" class="headerlink" title="第二节 实战"></a>第二节 实战</h2><h3 id="2-1-导出SQL"><a href="#2-1-导出SQL" class="headerlink" title="2.1 导出SQL"></a>2.1 导出SQL</h3><p>导出一千万条数据，耗时-5分钟，sql文件大小-1.17 GB</p><p>直接执行SQL文件，耗时54分41秒</p><h3 id="2-2-load-data-infile"><a href="#2-2-load-data-infile" class="headerlink" title="2.2 load data infile"></a>2.2 load data infile</h3><p>1.在源数据库导出数据文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'logs1.txt'</span>;</span><br></pre></td></tr></table></figure><p>执行耗时：（只需半分钟）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010160.png" alt></p><p>文件大小：676MB</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010161.png" alt></p><p>生成文件格式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1811</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span>首页</span><br><span class="line"><span class="selector-tag">1812</span><span class="selector-tag">2</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:01</span>首页</span><br><span class="line"><span class="selector-tag">1813</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:02</span>首页</span><br><span class="line"><span class="selector-tag">1814</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:03</span>首页</span><br><span class="line"><span class="selector-tag">1815</span><span class="selector-tag">1</span>/<span class="selector-tag">index</span><span class="selector-tag">0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:1</span>\<span class="selector-tag">N</span>\<span class="selector-tag">N</span><span class="selector-tag">null</span><span class="selector-tag">2020-01-01</span> <span class="selector-tag">00</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:04</span>首页</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>3.目标数据库执行命令：（需要先导入表结构）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'logs1.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> logs1(<span class="keyword">id</span>, logtype, logurl, logip, logdz, ladduser, lfadduser, laddtime, htmlname);</span><br></pre></td></tr></table></figure><p>执行耗时：（只需5分钟左右）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010162.png" alt></p><p>对比导出SQL文件，耗时从将近1小时缩短到5分钟。</p><h3 id="2-3-SqlLoader"><a href="#2-3-SqlLoader" class="headerlink" title="2.3 SqlLoader"></a>2.3 SqlLoader</h3><p>1.导出数据文件，可以是任意支持格式，如 <code>.txt</code>，<code>.csv</code> 等。</p><p>2.创建控制文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS (skip=1,rows=128) <span class="comment">-- sqlldr 命令显示的 选项可以写到这里边来,skip=1 用来跳过数据中的第一行  </span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span>  </span><br><span class="line"><span class="keyword">INFILE</span> <span class="string">"users_data.csv"</span> <span class="comment">--指定外部数据文件，可以写多 个 INFILE "another_data_file.csv" 指定多个数据文件  </span></span><br><span class="line"><span class="comment">--这里还可以使 用 BADFILE、DISCARDFILE 来指定坏数据和丢弃数据的文件，  </span></span><br><span class="line"><span class="keyword">truncate</span> <span class="comment">--操作类型，用 truncate table 来清除表中原有 记录  </span></span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> <span class="comment">-- 要插入记录的表  </span></span><br><span class="line"><span class="keyword">Fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">","</span> <span class="comment">-- 数据中每行记录用 "," 分隔  </span></span><br><span class="line"><span class="keyword">Optionally</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">'"'</span> <span class="comment">-- 数据中每个字段用 '"' 框起，比如字段中有 "," 分隔符时  </span></span><br><span class="line">trailing nullcols <span class="comment">--表的字段没有对应的值时允 许为空  </span></span><br><span class="line">(  </span><br><span class="line">  virtual_column FILLER, <span class="comment">--这是一个虚拟字段，用来跳 过由 PL/SQL Developer 生成的第一列序号  </span></span><br><span class="line">  user_id <span class="built_in">number</span>, <span class="comment">--字段可以指定类型，否则认 为是 CHARACTER 类型, log 文件中有显示  </span></span><br><span class="line">  user_name,  </span><br><span class="line">  login_times,  </span><br><span class="line">  last_login <span class="built_in">DATE</span> <span class="string">"YYYY-MM-DD HH24:MI:SS"</span> <span class="comment">-- 指定接受日期的格式，相当用 to_date() 函数转换  </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行完 sqlldr 后可以留意一下生成的几个文件，如 users.log 日志文件、users.bad 坏数据文件等。特别是要看看日志文件，从中可让你更好的理解 Sql Loader，里面有对控制文件的解析、列出每个字段的类型、加载记录的统计、出错原因等信息。</p><h2 id="第三节-SqlLoader细节"><a href="#第三节-SqlLoader细节" class="headerlink" title="第三节 SqlLoader细节"></a>第三节 SqlLoader细节</h2><p>SqlLoader 的性能与并发操作：</p><ol><li><p>ROWS 的默认值为 64，可以根据实际指定更合适的 ROWS 参数来指定每次提交记录数。</p></li><li><p>常规导入可以通过使用 INSERT语句来导入数据。Direct 导入可以跳过数据库的相关逻辑(DIRECT=TRUE)，而直接将数据导入到数据文件中，可以提高导入数据的性能。当然，在很多情况下，不能使用此参数(如果主键重复的话会使索引的状态变成UNUSABLE!)。</p></li><li><p>通过指定 UNRECOVERABLE选项，可以关闭数据库的日志(是否要 alter table table1 nologging 呢?)。这个选项只能和 direct 一起使用。</p></li><li><p>对于超大数据文件的导入就要用并发操作了，即同时运行多个导入任务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlldr userid=/ control=result1.ctl direct=true parallel=true   </span><br><span class="line">sqlldr userid=/ control=result2.ctl direct=true parallel=true   </span><br><span class="line">sqlldr userid=/ control=result2.ctl direct=true parallel=true</span><br></pre></td></tr></table></figure></li><li><p>当加载大量数据时（大约超过10GB），最好抑制日志的产生：  <code>SQL&gt;ALTER  TABLE  RESULTXT  nologging;</code> 这样不产生REDO LOG，可以提高效率。然后在 CONTROL 文件中 load data 上面加一行：unrecoverable， 此选项必须要与DIRECT共同应用。</p></li><li><p>在并发操作时，ORACLE声称可以达到每小时处理100GB数据的能力！其实，估计能到 1－10G 就算不错了，开始可用结构相同的文件，但只有少量数据，成功后开始加载大量数据，这样可以避免时间的浪费。（注意：一般只能用ASCII码形式，切记要转换编码，不然导入数据为空）</p></li></ol><p><a href="https://cloud.tencent.com/developer/article/1059843" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1059843</a></p><hr><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/shadow_zed/article/details/82661118" target="_blank" rel="noopener">oracle sqlldr 用法详解</a></p></blockquote><blockquote><p><a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">MySql官方文档-LOAD DATA Statement</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/bcafd8f3ad8e" target="_blank" rel="noopener">LOAD DATA INFILE 导入数据</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理一下SqlLoader相关内容，简单使用，实战案例等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
      <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（二）客户端开发</title>
    <link href="http://linyishui.top/2020092001.html"/>
    <id>http://linyishui.top/2020092001.html</id>
    <published>2020-09-20T04:34:35.000Z</published>
    <updated>2020-09-29T13:34:36.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a><strong>客户端开发</strong></h1><h2 id="第一节-连接RabbitMQ"><a href="#第一节-连接RabbitMQ" class="headerlink" title="第一节 连接RabbitMQ"></a><strong>第一节 连接RabbitMQ</strong></h2><p>客户端给定参数（IP地址、端口号、用户名、密码等）连接RabbitMQ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUsername(USERNAME);</span><br><span class="line">factory.setPassword(PASSWORD);</span><br><span class="line">factory.setVirtualHost(virtualHost);</span><br><span class="line">factory.setHost(IP_ADDRESS);</span><br><span class="line">factory.setPort(PORT);</span><br><span class="line">Connection conn = factory.newConnection();</span><br></pre></td></tr></table></figure><p>也可以用URL的方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUri(<span class="string">"amqp://userName:password@ipAddress:portNumber/virtualHost"</span>);</span><br><span class="line">Connection conn = factory.newConnection();</span><br><span class="line"><span class="comment">//Connection 接口被用来创建一个 Channel:</span></span><br><span class="line">Channel channel= conn.createChannel();</span><br><span class="line"><span class="comment">//在创建之后，Channel可以用来发送或者接收消息了</span></span><br></pre></td></tr></table></figure><p>Connection 可以用来创建多个 Channel 实例，但是 Channel 实例不能在线程问共享， 应用程序应该为每一个线程开辟一个 Channel 。多线程问共享 Channel 实例是非线程安全的。</p><p>Channel 或者 Connection 中有个 <code>isOpen</code> 方法可以用来检测其是否己处于开启状态，这个方法的返回值依赖于 <code>shutdownCause</code> ，不推荐在生产环境使用，可能会产生竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.shutdownCause == <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误地使用 <code>isOpen</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brokenMethod</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.isOpen())&#123;</span><br><span class="line">        <span class="comment">//The following code depends on the channel being in opeηstate.</span></span><br><span class="line">        <span class="comment">//However there is a possibility of the change in the channel state</span></span><br><span class="line">        <span class="comment">//between isOpen() and basicQos(l) call</span></span><br><span class="line">        ...</span><br><span class="line">        channel.basicQos(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，在调用 <code>createXXX</code> 或者 <code>newXXX</code> 方法之后，我们可以简单地认为 Connection 或者 Channel 已经成功地处于开启状态，而并不会在代码中使用 <code>isOpen</code> 这个检测方法。如果在使用 Channel 的时候其己经处于关闭状态，那么程序会抛出一个 <code>com.rabbitmq.client.ShutdownSignalException</code> ，我们只需捕获这个异常即可。当然同时也要试着捕获 <code>IOException</code> 或者 <code>SocketException</code> ，以防 Connection 意外关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validMethod</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">channel.basicQos(l);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ShutdownSignalException sse) &#123;</span><br><span class="line">        <span class="comment">//possibly check if channel was closed</span></span><br><span class="line">        <span class="comment">//by the time we started action and reasons for</span></span><br><span class="line">        <span class="comment">//closing it</span></span><br><span class="line">        ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="comment">//check why connection was closed </span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-使用交换器和队列"><a href="#第二节-使用交换器和队列" class="headerlink" title="第二节 使用交换器和队列"></a><strong>第二节 使用交换器和队列</strong></h2><p>交换器和队列是 AMQP high-level 层面的构建模块，应用程序需确保在使用它们的时候就已经存在了，在使用之前需要先声明（declare）它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个持久化的、非自动删除的、绑定类型为 direct 交换器</span></span><br><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//同时也创建一个非持久化的、排他的、自动删除的队列（此队列的名称由 RabbitMQ 自动生成）</span></span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//使用路由键将队列和交换器绑定起来</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure><p>上面声明的队列具备如下特性：只对当前应用中同一个 Connection 层面可用，同一个 Connection 的不同 Channel 可共用，并且也会在应用连接断开时自动删除。</p><p>如果要在应用中共享一个队列，可以做如下声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上</span></span><br><span class="line">channel.exchangeDeclare(exchangeName , <span class="string">"direct"</span>, <span class="keyword">true</span>) ;</span><br><span class="line"><span class="comment">//队列被声明为持久化的 非排他的、非自动删除的，而且也被分配另一个确定的己知的名称（由客户端分配而非 RabbitMQ 自动生成）</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(queueName , exchangeName , routingKey) ;</span><br></pre></td></tr></table></figure><p>生产者和消费者都可以声明一个交换器或者队列。</p><h3 id="2-1-exchangeDeclare"><a href="#2-1-exchangeDeclare" class="headerlink" title="2.1 exchangeDeclare()"></a><strong>2.1 exchangeDeclare()</strong></h3><p><code>exchangeDeclare()</code> 用来声明交换器，有多种重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> autoDelete, <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String , Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li><code>Exchange.DeclareOk</code> ：用来标识成功声明了一个交换器。</li><li>exchange：交换器的<strong>名称</strong>。</li><li>type：交换器的<strong>类型</strong>。<ul><li>常见的如fanout，direct，topic。</li></ul></li><li>durable：设置<strong>是否持久化</strong>。<ul><li>持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li></ul></li><li>autoDelete：设置<strong>是否自动删除</strong>。<ul><li>自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。</li><li>注意不能错误地把这个参数理解为：当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器。</li></ul></li><li>internal：设置<strong>是否是内置的的交换器</strong>。<ul><li>客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li></ul></li><li>argument：其他一些<strong>结构化参数</strong>，比如 <code>alternate-exchange</code> </li></ul><p>类似的方法：</p><ul><li>exchangeDeclareNoWait：无返回值，不建议使用，刚声明完交换器紧接着就使用，可能导致因交换器未创建而发生异常。</li><li>exchangeDeclarePassive：用来检测相应的交换器是否存在，不存在抛出异常 <code>404 channel exception</code> 同时关闭 Channel 。</li><li>exchangeDelete：删除交换器。</li><li>exchangeDeleteNoWait：无返回删除。</li></ul><h3 id="2-2-queueDeclare"><a href="#2-2-queueDeclare" class="headerlink" title="2.2 queueDeclare()"></a><strong>2.2 queueDeclare()</strong></h3><p><code>queueDeclare()</code> 创建一个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>无参方法默认构建一个 RabbitMQ命名的、排他的、自动删除的、非持久化的队列。</li><li>queue：队列<strong>名称</strong></li><li>durable：设置<strong>是否持久化</strong>。<ul><li>持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li></ul></li><li>exclusive：设置<strong>是否排他</strong>。<ul><li>如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。</li><li>这里需要注意三点：<ul><li>排他队列是基于连接（ Connection ）可见的，同一个连接的不同信道（Channel) 是可以同时访问同一连接创建的排他队列；</li><li>“首次”是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；</li><li>即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。</li></ul></li></ul></li><li>autoDelete：设置是否自动删除。<ul><li>自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为：“当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li></ul></li><li>arguments：设置队列的其他一些参数。<ul><li>如 <code>x-message-ttl</code> <code>x-expires</code> <code>x-max-length</code> <code>x-max-length-bytes</code> <code>x-dead-letter-exchange</code> <code>x-dead-letter-routing-key</code> , <code>x-max-priority</code> 等。</li></ul></li></ul><p>注意：生产者和消费者都能够使用 queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道置为“传输”模式，之后才能声明队列。</p><p>类似的方法这里不再赘述。</p><h3 id="2-3-queueBind"><a href="#2-3-queueBind" class="headerlink" title="2.3 queueBind()"></a><strong>2.3 queueBind()</strong></h3><p><code>queueBind()</code> 将队列与交换器绑定/解绑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">BindOk <span class="title">queueBind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Queue.<span class="function">UnbindOk <span class="title">queueUnbind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>queue：队列名称；</li><li>exchange：交换器的名称；</li><li>routingKey：用来绑定队列和交换器的路由键；</li><li>arguments：定义绑定的一些参数。</li></ul><h3 id="2-4-exchangeBind"><a href="#2-4-exchangeBind" class="headerlink" title="2.4 exchangeBind()"></a><strong>2.4 exchangeBind()</strong></h3><p><code>exchangeBind()</code> 将交换器与交换器绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">BindOk <span class="title">exchangeBind</span><span class="params">(String destination, String source , String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>绑定之后，消息从 source 交换器转发到 destination 交换器，后者可以看作是一个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别声明source和destination交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"source"</span>, <span class="string">"direct"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>) ;</span><br><span class="line">channel.exchangeDeclare(<span class="string">"destination"</span>, <span class="string">"fanout"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//绑定两者</span></span><br><span class="line">channel.exchangeBind(<span class="string">"destination"</span>, <span class="string">"source"</span>, <span class="string">"exKey"</span>);</span><br><span class="line"><span class="comment">//声明队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">"queue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//绑定destination交换器和队列</span></span><br><span class="line">channel.queueBind(<span class="string">"queue"</span>, <span class="string">"destination"</span>，<span class="string">""</span>);</span><br><span class="line"><span class="comment">//source推送消息</span></span><br><span class="line">channel.basicPublish(<span class="string">"source"</span>, <span class="string">"exKey"</span>, <span class="keyword">null</span>, <span class="string">"exToExDemo"</span>. getBytes());</span><br></pre></td></tr></table></figure><p>生产者发送消息至交换器 source 中，交换器 source 根据路由键找到与其匹配 的另一个交换器 destination 井把消息转发到 destination 中，进而存储在 destination 绑定的队列 queue 中：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010156.png" alt></p><h3 id="2-5-何时创建"><a href="#2-5-何时创建" class="headerlink" title="2.5 何时创建"></a><strong>2.5 何时创建</strong></h3><p>RabbitMQ 的<strong>消息存储在队列中</strong>，交换器的使用并不真正耗费服务器的性能，而队列会。 如果要衡量 RabbitMQ 当前的 QPS ，只需看队列的即可。<strong>在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值</strong>，以便在固定硬件资源的情况下能够进行合理有效的分配。 </p><p>按照 RabbitMQ 官方建议，<strong>生产者和消费者都应该尝试创建（这里指声明操作）队列</strong>。这是一个很好的建议，但不适用于所有的情况。如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好（<strong>比如通过页面管理、 RabbitMQ 命令或者更好的是从配置中心下发</strong>），这样业务程序也可以免去声明的过程，直接使用即可。 </p><p>预先创建好资源还有一个好处是，<strong>可以确保交换器和队列之间正确地绑定匹配</strong>。很多时候， 由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失；或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。 当然<strong>可以配合 mandatory 参数或者备份交换器来提高程序的健壮性</strong>。 </p><p>与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。 </p><p>如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，<strong>也完全可以在业务程序中声明队列</strong>。 至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。</p><hr><h2 id="第三节-发送消息"><a href="#第三节-发送消息" class="headerlink" title="第三节 发送消息"></a><strong>第三节 发送消息</strong></h2><p><code>channel.basicPublish()</code> 可以用来发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送一条持久化的消息 hello world!</span></span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//mandatory参数可以更好的控制发送</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes) ; </span><br><span class="line"></span><br><span class="line"><span class="comment">//这条消息的投递模式（delivery mode）为2，消息会被持久化到服务器中</span></span><br><span class="line"><span class="comment">//消息的优先级设置为1，contentType为text/plain</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQPBasicProperties.Builder()</span><br><span class="line">                           .contentType(<span class="string">"text/plain"</span>)</span><br><span class="line">                           .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                           .priority(<span class="number">1</span>)</span><br><span class="line">                           .userld(<span class="string">"hidden"</span>)</span><br><span class="line">                           .build()), messageBodyBytes); </span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以设置消息的headers</span></span><br><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;String Object&gt;();</span><br><span class="line">headers.put(<span class="string">"localtion"</span>，<span class="string">"here"</span>);</span><br><span class="line">headers.put(<span class="string">"time"</span>, <span class="string">"today"</span>);</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                           .headers(headers)</span><br><span class="line">                           .build()), messageBodyBytes); </span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以带过期时间</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                           .expiration(<span class="string">"60000"</span>) </span><br><span class="line">                           .build()), messageBodyBytes);</span><br></pre></td></tr></table></figure><p>包括各种重载方法，有以下具体参数：</p><ul><li>exchange：交换器的名称，指明消息需要发送到哪个交换器中，如果设置为空字符串， 则消息会被发送到 RabbitMQ 默认的交换器中。 </li><li>routingKey：路由键，交换器根据路由键将消息存储到相应的队列之中 </li><li>props：消息的基本属性集，其包含 14 个属性成员，分别有 <code>contentType</code> 、<code>contentEncoding</code> 、 <code>headers(Map&lt;String, Object&gt;)</code> 、<code>deliveryMode</code> 、<code>priority</code> 、<code>correlationId</code> 、<code>replyTo</code> 、<code>expiration</code> 、<code>messageId</code> 、<code>timestamp</code> 、<code>type</code> 、<code>userId</code> 、<code>appId</code> 、<code>clusterId</code> </li><li>byte[] body：消息体，真正要发送的消息。</li><li>mandatory：为 true 时，且交换器无法根据自身的类型和路由键找到一个符合条件的队列，调用 <code>Basic.Return</code> 命令将消息返回给生产者。为 false 时，消息直接被丢弃。</li><li>immediate：为true时，若交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时， 该消息会通过 <code>Basic.Return</code> 返回至生产者。</li></ul><hr><h2 id="第四节-消费消息"><a href="#第四节-消费消息" class="headerlink" title="第四节 消费消息"></a><strong>第四节 消费消息</strong></h2><p>两种模式：</p><ul><li>推模式：采用 <code>Basic.Consume</code> 进行消费；</li><li>拉模式：采用 <code>Basic.Get</code> 进行消费。</li></ul><h3 id="4-1-推模式"><a href="#4-1-推模式" class="headerlink" title="4.1 推模式"></a>4.1 推模式</h3><p>通过持续订阅的方式消费消息，接收消息一般通过实现 <code>Consumer</code> 接口或者继承 <code>DefaultConsumer</code> 类来实现。不同的订阅采用不同的消费者标签（ConsumerTag）来区分彼此。</p><p>主要通过方法 <code>channel.basicConsume()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">      <span class="comment">//接收到消息之后进行显式 ack 操作 channel.basicAck 对于消费者很必要，防止消息不必要的消失</span></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">      channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">      channel.basicConsume(QUEUE_NAME, autoAck, <span class="string">"myConsumerTag"</span>,</span><br><span class="line">              <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                      String routingKey = envelope.getRoutingKey();</span><br><span class="line">                      String contentType = properties.getContentType();</span><br><span class="line">                      <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                      <span class="comment">// process the message components here ...</span></span><br><span class="line">                      channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>queue：队列的名称；</li><li>autoAck：设置是否自动确认。建议设成 false ，即不自动确认；</li><li>consumerTag：消费者标签，用来区分多个消费者；</li><li>noLocal 设置为 true 则表示不能将同一个 Connection 中生产者发送的消息传送给这个 Connection 中的消费者；</li><li>exclusive：设置是否排他 ；</li><li>arguments：设置消费者的其他参数；</li><li>callback：设置消费者的回调函数。用来处理 RabbitMQ 推送过来的消息，比如 DefaultConsumer 使用时需要客户端重写其中的方法。</li></ul><p>消费者客户端可以重写多种方法：</p><ul><li><code>handleDelivery()</code></li><li><code>handleConsumerOk()</code> ：会在其他方法之前调用，返回消费者标签。</li><li><code>handleCancelOk()</code> ：消费端可以在显式地取消订阅的时候调用。</li><li><code>handleCancel()</code> ：消费端可以在隐式地取消订阅的时候调用</li><li><code>handleShutdownSignal()</code> ：当 Channel 或者 Connection 关闭的时候会调用。</li><li><code>handleRecoverOk()</code></li></ul><p>通过 <code>channel.basicCancel()</code> 显式地取消一个消费者的订阅，先触发 <code>handleConsumerOk()</code> ，然后是 <code>handleDelivery()</code> ，最后是 <code>handleCancelOk()</code> 。</p><p>和生产者一样，消费者客户端同样需要考虑线程安全的问题。消费者客户端的这些 callback 会被分配到与 Channel 不同的线程池上，这意味着消费者客户端可以安全地调用这些阻塞方法，比如 <code>channel.queueDeclare</code> ， <code>channel.basicCancel</code> 等。 </p><p>每个 Channel 都拥有自己独立的线程。最常用的做法是一个 Channel 对应一个消费者， 也就是意味着消费者彼此之间没有任何关联。当然也可以在一个 Channel 中维持多个消费者， 但是要注意一个问题，如果 Channel 中的一个消费者一直在运行，那么其他消费者的 callback 会被“耽搁”。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png" alt></p><h3 id="4-2-拉模式"><a href="#4-2-拉模式" class="headerlink" title="4.2 拉模式"></a>4.2 拉模式</h3><p>通过 <code>channel.basicGet()</code> 可以单条的获取消息，当 autoAck 设置为false，需要用 <code>channel.basicAck()</code> 来确认消息已被成功接收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out,println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010158.png" alt></p><p><code>Basic.Consume</code> 将信道（Channel）置为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 <code>Basic.Qos</code> 的限制．如果只想从队列获得单条消息而不是持续订阅，建议还是使用 <code>Basic.Get</code> 进行消费．但是不能将 <code>Basic.Get</code> 放在一个循环里来代替 <code>Basic.Consume</code> ，这样做会严重影响 RabbitMQ 的性能．如果要实现高吞吐量，消费者理应使用 <code>Basic.Consume</code> 方法。</p><hr><h2 id="第五节-消费端的确认与拒绝"><a href="#第五节-消费端的确认与拒绝" class="headerlink" title="第五节 消费端的确认与拒绝"></a><strong>第五节 消费端的确认与拒绝</strong></h2><p>为了保证消息从队列可靠地达到消费者， RabbitMQ 提供了消息确认机制 （message acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false 时， RabbitMQ 会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。当 autoAck 等于 true 时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息。</p><p>采用消息确认机制后，只要设置 autoAck 参数为 false ，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题 因为 RabbitMQ 会一直等待持有消息直到消费者显式调 <code>Basic.Ack</code> 命令为止。</p><p>当 autoAck 参数置为 false ，对于 RabbitMQ 服务端而言，队列中的消息分成了两个部分：一部分是等待投递给消费者的消息；一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p><p>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。 </p><p>RabbtiMQ 的 Web 管理平台上可以看到当前队列中的“Ready ”状态 和“Unacknowledged ＂状态的消息数，分别对应上文中的等待投递给消费者的消息数和己经投递给消费者但是未收到确认信号的消息数：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010159.png" alt></p><p>也可以通过相应的命令来查看上述信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_queues name message_ready messages_unacknowledged</span></span><br><span class="line">Listing queues ...</span><br><span class="line">queue         1   0</span><br><span class="line">queue_demo    0</span><br></pre></td></tr></table></figure><p>在消费者接收到消息后，如果想明确拒绝当前的消息而不是确认，那么应该怎么做呢？通过 <code>Basic.Reject</code> 这个命令，消费者客户端可以调用与其对应的 <code>channel.basicReject</code> 方法来告诉 RabbitMQ 拒绝这个消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>deliveryTag：消息编号，64位的长整型值。</li><li>requeue：当为true时，RabbitMQ会重新将此条消息存入队列，以便可以发送给下一个订阅的消费者；当为false时，立即将消息从队列中移除。</li></ul><p>批量拒绝消息需要 <code>Basic.Nack</code> ，客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>multiple：为false时，表示拒绝单条消息；为true时，拒绝编号前所有未被消费者确认的消息。</li></ul><p><code>channel.basicRecover()</code> 请求RabbitMQ重新发送还未被确认的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Basic.<span class="function">RecoverOk <span class="title">basicRecover</span><span class="params">(<span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>requeue：为true，未被确认的消息会被重新加入到队列，可能会被分配给另外一个消费者；为false，同一条消息会被分配给之前相同的消费者。</li></ul><hr><h2 id="第六节-关闭连接"><a href="#第六节-关闭连接" class="headerlink" title="第六节 关闭连接"></a><strong>第六节 关闭连接</strong></h2><p>在应用程序使用完之后，需要关闭连接，释放资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>在 Connection 关闭的时候， Channel 也会自动关闭。</p><p>Connection Channel 所具备的生命周期如下所述：</p><ul><li>Open：开启状态，代表当前对象可以使用。 </li><li>Closing：正在关闭状态。当前对象被显式地通知调用关闭方法（shutdown），这样就产生了一个关闭请求让其内部对象进行操作并等待这些关闭操作的完成。 </li><li>Closed：已经关闭状态。当前对象己经接收到所有的内部对象己完成关闭动作的通知，并且其也关闭了自身。</li></ul><p>当 Connection 或者 Channel 的状态转变为 Closed 的时候会调用  <code>ShutdownListener</code> 。而且如果将一个 <code>ShutdownListener</code> 注册到一个己经处于 Closed 状态的对象（这里特指 Connection 和 Channel 对象），会立刻调用  <code>ShutdownListener</code> 。</p><p><code>getCloseReason</code> 方法可以让你知道对象关闭的原因 <code>isOpen</code> 方法检测对象当前是否处于开启状态： <code>close(int closeCode , String closeMessage)</code> 方法显式地通知当前对象执行关闭操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.addShutdownListener(<span class="keyword">new</span> ShutdownListener()&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownCompleted</span><span class="params">(ShutdownSignalException cause)</span></span>&#123;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>当触发 ShutdownListener 的时候，就可以获取到 ShutdownSignalException ，这个 ShutdownSignalException 包含了关闭的原因，可以通过<code>getCloseReason</code> 方法获取。 <code>isHardError</code> 方法 可以知道是 <code>Connection</code> 的还是 <code>Channel</code> 的错误； <code>getReason</code> 方法可以获取 cause 相关的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownCompleted</span><span class="params">(ShutdownSignal cause)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(cause.isHardError())&#123;</span><br><span class="line">           Connection conn = (Connection) cause.getReference();</span><br><span class="line">           <span class="keyword">if</span>(!cause.isInitiatedByApplication())&#123;</span><br><span class="line">               Method reason = cause.getReason();</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Channel ch = (Channel) cause.getReference();</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p>《RabbitMQ实战指南》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第二章《客户端开发》，内容来自于《RabbitMQ实战指南》，内容包括：连接RabbitMQ，使用交换器和队列，发送消息，消费消息，消费端的确认与拒绝，关闭连接。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（一）简介和入门</title>
    <link href="http://linyishui.top/2020091901.html"/>
    <id>http://linyishui.top/2020091901.html</id>
    <published>2020-09-19T04:30:19.000Z</published>
    <updated>2020-09-29T13:35:31.158Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（一）简介和入门"><a href="#RabbitMQ（一）简介和入门" class="headerlink" title="RabbitMQ（一）简介和入门"></a><strong>RabbitMQ（一）简介和入门</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a><strong>1.1 什么是消息中间件</strong></h3><p><strong>消息</strong>指在应用间传送的数据。可以只包含字符串、JSON等，也可以包括内嵌对象。</p><p><strong>消息队列中间件</strong>（Message Queue Middleware，即MQ）指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。<strong>通过消息传递和消息排队模型，可以在分布式环境下扩展进程间通信</strong>。</p><p>两种传递模式：</p><ul><li><strong>点对点模式</strong>（P2P）：基于队列，消息生产者发送消息到队列，消息消费者从队列接受消息。队列使消息的<strong>异步传输</strong>成为可能。</li><li><strong>发布/订阅模式</strong>（Pub/Sub）：订阅了如何向一个内容节点发布和订阅消息，内容节点被称为<strong>主题</strong>（topic），可以看作是消息传递的中介，消息发布者将消息发布到某个主题，订阅者从主题订阅消息。主题使发布者和订阅者相互独立，可以在消息的<strong>一对多广播</strong>时采用。</li></ul><p>消息中间件提供了基于存储和转发的应用程序之间的异步数据发生，即应用程序间不直接通信，而是作为中介的消息中间件通信。消息中间件封装了远程过程调用（RPC）和网络通信协议的细节。</p><h3 id="1-2-常见的消息中间件"><a href="#1-2-常见的消息中间件" class="headerlink" title="1.2 常见的消息中间件"></a><strong>1.2 常见的消息中间件</strong></h3><p>常见的几款开源消息中间件：</p><ul><li>RabbitMQ：基于AMQP协议，主流消息中间件之一，适合数据量没那么大的项目；</li><li>Kafka：诞生于LinkedIn公司，吞吐量大，可用性高，常用于大数据领域。</li><li>ActiveMQ：Apache老牌消息引擎；</li><li>RocketMQ：阿里巴巴开源产品，Java实现，参考了Kafka的设计，可用性和吞吐量很高，适合于电商和金融互联网场景。</li><li>Apollo：Apache的ActiveMQ子项目。</li></ul><h3 id="1-3-消息中间件的作用"><a href="#1-3-消息中间件的作用" class="headerlink" title="1.3 消息中间件的作用"></a><strong>1.3 消息中间件的作用</strong></h3><ul><li><strong>解耦</strong>：只要遵守同样的接口约束，我们可以独立的扩展和修改通信两端的处理过程。</li><li><strong>冗余（存储）</strong>：消息中间件可以把数据进行持久化直到被完全处理，可以规避数据丢失的风险。即消息在被从中间件删除前，需要处理系统明确的指出此消息已被处理完成。</li><li><strong>扩展性</strong>：因为解耦了应用的处理过程，所以提高消息的入队和处理效率很容易，只须增加处理过程，不需改动代码也不需调节参数。</li><li><strong>削峰</strong>：访问量剧增时，这种情况不一定是常态，如果以此为标准投入资源无疑是巨大的浪费。消息中间件可以使关键组件支撑突发访问压力，不会因为突发的超负荷请求而崩溃。</li><li><strong>可恢复性</strong>：消息中间件降低了进程间的耦合度，即使一个处理消息的进程挂掉，消息仍可以等到系统恢复后进行处理。</li><li><strong>顺序保证</strong>：大部分消息中间件支持一定程度上的数据处理的顺序性。</li><li><strong>缓冲</strong>：消息中间件通过一个缓冲层帮助任务以最高效率执行，有助于控制和优化数据流经过系统的速度。</li><li><strong>异步通信</strong>：有时应用不想也不需要立即处理消息，消息中间件提供了异步处理机制，应用可以放入一些消息但不立即处理。</li></ul><h3 id="1-4-RabbitMQ的发展历程"><a href="#1-4-RabbitMQ的发展历程" class="headerlink" title="1.4 RabbitMQ的发展历程"></a><strong>1.4 RabbitMQ的发展历程</strong></h3><p>RabbitMQ基于 Erlang 语言实现 <strong>AMQP</strong>（Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，起源于金融系统，用于在分布式系统中存储转发消息。</p><p>之前，商业的消息中间件如微软的MSMQ、IBM的WebSphere等没有创建标准来实现MQ产品的互通或允许应用自定义MQ平台。<strong>JMS</strong>（Java Message Service）应运而生，<strong>试图通过提供公共Java API的方式隐藏单独MQ产品的实际接口，来解决互通问题</strong>。<strong>ActiveMQ</strong>就是基于JMS的一种实现，但这种使用单独标准化接口来胶合不同的接口最终还是会暴露问题，所以业内需要一种新的消息通信标准化方案。</p><p>2006年6月，Cisco、Redhat、iMatix等联合制定了AMQP标准，它是应用层协议的一个开放标准，来解决众多消息中间件的需求和拓扑结构问题。<strong>面向消息的中间件设计，基于此协议的客户端和消息中间件可以传递消息，不受产品、开发语言的限制。</strong></p><p>RabbitMQ早期即实现了AMQP的一个特性：使用协议本身就可以对队列和交换器这样的资源进行配置。而商业MQ进行资源配置需要管理终端的特定工具。</p><h3 id="1-5-RabbitMQ的特点"><a href="#1-5-RabbitMQ的特点" class="headerlink" title="1.5 RabbitMQ的特点"></a><strong>1.5 RabbitMQ的特点</strong></h3><ul><li><strong>可靠性</strong>：通过如持久化、传输确认及发布确认等保障可靠性。</li><li><strong>灵活路由</strong>：消息进入队列前，通过交换器来路由消息。基本的路由功能由内置的交换器来实现，复杂的路由功能可以绑定多个路由器实现，也可以通过插件机制实现自定义的交换器。</li><li><strong>扩展性</strong>：多个RabbitMQ节点可以组成集群，可以根据实际业务情况动态扩展节点。</li><li><strong>高可用性</strong>：队列可以在集群的机器上设置镜像，在部分节点出现问题时仍能使用队列。</li><li><strong>多种协议</strong>：除了原生AMQP协议，还支持STOMP、MQTT等多种消息中间件协议。</li><li><strong>多语言客户端</strong>：支持几乎所有常用语言，如Java、Python、Ruby、PHP、C#、JavaScript等。</li><li><strong>管理界面</strong>：提供了一个易用的用户界面，可以监控和管理消息、集群中的节点等。</li><li><strong>插件机制</strong>：提供了许多插件，可以进行扩展，也可以自定义插件。</li></ul><hr><h2 id="第二节-RabbitMQ的安装和简单使用"><a href="#第二节-RabbitMQ的安装和简单使用" class="headerlink" title="第二节 RabbitMQ的安装和简单使用"></a><strong>第二节 RabbitMQ的安装和简单使用</strong></h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a><strong>2.1 安装</strong></h3><p>首先要安装Erlang，官网地址：<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">Erlang-Download</a> 。以下基于Linux操作系统安装。</p><h4 id="（1）安装Erlang"><a href="#（1）安装Erlang" class="headerlink" title="（1）安装Erlang"></a><strong>（1）安装Erlang</strong></h4><p>创建安装目录 <code>/opt/erlang</code> ，并下载安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# cd /opt</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# ls</span><br><span class="line">containerd  gitlab</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# mkdir /erlang</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# cd /erlang</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# wget http://erlang.org/download/otp_src_23.0.tar.gz</span><br><span class="line">--2020-09-21 16:20:16--  http://erlang.org/download/otp_src_23.0.tar.gz</span><br><span class="line">Resolving erlang.org (erlang.org)... 192.121.151.106</span><br><span class="line">Connecting to erlang.org (erlang.org)|192.121.151.106|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 88865562 (85M) [application/gzip]</span><br><span class="line">Saving to: ‘otp_src_23.0.tar.gz’</span><br><span class="line"></span><br><span class="line"><span class="meta"> 2%</span><span class="bash"> [=&gt;                                                                                                                   ] 1,907,973   6.64KB/s  eta 2h 40m</span></span><br></pre></td></tr></table></figure><p>官网下载速度太慢，访问 <a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="noopener">RabbitMQ - Erlang</a> 选择对应服务器，复制下载地址：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010154.png" alt></p><p>先删除未下载完成的文件，重新下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">otp_src_23.0.tar.gz</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rm -f otp_src_23.0.tar.gz</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# wget https://packages.erlang-solutions.com/erlang/rpm/centos/7/x86_64/esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">--2020-09-21 16:37:11--  https://packages.erlang-solutions.com/erlang/rpm/centos/7/x86_64/esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">Resolving packages.erlang-solutions.com (packages.erlang-solutions.com)... 13.227.21.48, 13.227.21.118, 13.227.21.90, ...</span><br><span class="line">Connecting to packages.erlang-solutions.com (packages.erlang-solutions.com)|13.227.21.48|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 43642720 (42M) [application/x-rpm]</span><br><span class="line">Saving to: ‘esl-erlang_23.0.3-1~centos~7_amd64.rpm’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[====================================================================================================================&gt;] 43,642,720  23.1KB/s   <span class="keyword">in</span> 24m 34s</span></span><br><span class="line"></span><br><span class="line">2020-09-21 17:01:49 (28.9 KB/s) - ‘esl-erlang_23.0.3-1~centos~7_amd64.rpm’ saved [43642720/43642720]</span><br></pre></td></tr></table></figure><p>通过 <code>yum install</code> 安装程序：（会安装到默认目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# yum install esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Examining esl-erlang_23.0.3-1~centos~7_amd64.rpm: esl-erlang-23.0.3-1.x86_64</span><br><span class="line">Marking esl-erlang_23.0.3-1~centos~7_amd64.rpm to be installed</span><br><span class="line">Resolving Dependencies</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package esl-erlang.x86_64 0:23.0.3-1 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libodbc.so.2()(64bit) <span class="keyword">for</span> package: esl-erlang-23.0.3-1.x86_64</span></span><br><span class="line">Determining fastest mirrors</span><br><span class="line">base                                                                                                                                   | 3.6 kB  00:00:00     </span><br><span class="line">docker-ce-stable                                                                                                                       | 3.5 kB  00:00:00     </span><br><span class="line">epel                                                                                                                                   | 4.7 kB  00:00:00</span><br><span class="line">......</span><br><span class="line">gitlab_gitlab-ee/x86_64/primary                                                                                                        | 2.6 MB  00:00:06     </span><br><span class="line">gitlab_gitlab-ee                                                                                                                                      623/623</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Total size: 107 M</span><br><span class="line">Total download size: 462 k</span><br><span class="line">Installed size: 107 M</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过rpm查看软件是否安装</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -qa | grep erlang</span><br><span class="line">esl-erlang-23.0.3-1.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看软件安装目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -ql esl-erlang-23.0.3-1.x86_64</span><br><span class="line">/usr/bin/cpu_sup</span><br><span class="line">/usr/bin/ct_run</span><br><span class="line">/usr/bin/dialyzer</span><br><span class="line">/usr/bin/epmd</span><br><span class="line">/usr/bin/erl</span><br><span class="line">/usr/bin/erl_call</span><br><span class="line">/usr/bin/erlc</span><br><span class="line">/usr/bin/escript</span><br><span class="line">/usr/bin/etop</span><br><span class="line">/usr/bin/getop</span><br><span class="line">/usr/bin/heart</span><br><span class="line">/usr/bin/memsup</span><br><span class="line">/usr/bin/run_erl</span><br><span class="line">/usr/bin/run_test</span><br><span class="line">/usr/bin/start_erl</span><br><span class="line">/usr/bin/start_webtool</span><br><span class="line">/usr/bin/to_erl</span><br><span class="line">/usr/bin/typer</span><br><span class="line">/usr/lib/erlang/COPYRIGHT</span><br><span class="line">/usr/lib/erlang/Install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者直接查看目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -qal | grep erlang</span><br></pre></td></tr></table></figure><p>若出现报错：No curses library functions found 。需要安装 ncurses：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ncurses-devel</span><br></pre></td></tr></table></figure><p>若继续出现如 No XXXXX found 的提示，可以自行安装对应包，之后再次尝试安装Erlang直到提示安装完毕。</p><p>修改 <code>/etc/profile</code> 配置文件，添加如下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# cd /</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# vi /etc/profile</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/bin</span><br></pre></td></tr></table></figure><p>修改完，执行如下命令使配置文件生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# source /etc/profile</span><br></pre></td></tr></table></figure><p>通过 <code>erl</code> 命令验证是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# erl -version</span><br><span class="line">Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 11.0.3</span><br></pre></td></tr></table></figure><h4 id="（2）安装RabbitMQ"><a href="#（2）安装RabbitMQ" class="headerlink" title="（2）安装RabbitMQ"></a><strong>（2）安装RabbitMQ</strong></h4><p>首先下载安装包，官网地址：<a href="http://www.rabbitmq.com/releases/rabbitmq-server/" target="_blank" rel="noopener">RabbitMQ</a> 。</p><p>然后可以将RabbitMQ和Erlang安装在同一目录（/opt）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">--2020-09-21 17:39:13--  https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">Resolving www.rabbitmq.com (www.rabbitmq.com)... 104.20.11.224, 172.67.16.25, 104.20.10.224, ...</span><br><span class="line">Connecting to www.rabbitmq.com (www.rabbitmq.com)|104.20.11.224|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 5075721 (4.8M) [application/x-redhat-package-manager]</span><br><span class="line">Saving to: ‘rabbitmq-server-3.6.15-1.el7.noarch.rpm’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[====================================================================================================================&gt;] 5,075,721   1.73MB/s   <span class="keyword">in</span> 2.8s   </span></span><br><span class="line"></span><br><span class="line">2020-09-21 17:39:18 (1.73 MB/s) - ‘rabbitmq-server-3.6.15-1.el7.noarch.rpm’ saved [5075721/5075721]</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# ls</span><br><span class="line">rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# yum install rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过rpm查看软件是否安装</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rpm -qa | grep rabbitmq</span><br><span class="line">rabbitmq-server-3.6.15-1.el7.noarch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看软件安装目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rpm -ql rabbitmq-server-3.6.15-1.el7.noarch</span><br><span class="line">/etc/logrotate.d/rabbitmq-server</span><br><span class="line">/etc/rabbitmq</span><br><span class="line">/usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server</span><br><span class="line">/usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server-ha</span><br><span class="line">......</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmq-plugins</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmq-server</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmqctl</span><br><span class="line">/usr/lib/systemd/system/rabbitmq-server.service</span><br><span class="line">/usr/lib/tmpfiles.d/rabbitmq-server.conf</span><br><span class="line">/usr/sbin/rabbitmq-plugins</span><br><span class="line">/usr/sbin/rabbitmq-server</span><br><span class="line">/usr/sbin/rabbitmqctl</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>同样修改 <code>/etc/profile</code> 文件，添加如下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# vi /etc/profile</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/sbin</span><br></pre></td></tr></table></figure><p>同样使配置文件生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="（3）卸载"><a href="#（3）卸载" class="headerlink" title="（3）卸载"></a><strong>（3）卸载</strong></h4><p>卸载前先停掉rabbitmq服务，执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service rabbitmq-server stop</span></span><br></pre></td></tr></table></figure><p>查看rabbitmq安装的相关列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum list | grep rabbitmq</span></span><br></pre></td></tr></table></figure><p>卸载rabbitmq已安装的相关内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove rabbitmq-server.noarch</span></span><br></pre></td></tr></table></figure><p>查看erlang安装的相关列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum list | grep erlang</span></span><br></pre></td></tr></table></figure><p>卸载erlang已安装的相关内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove erlang-*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove erlang.x86_64</span></span><br></pre></td></tr></table></figure><h3 id="2-2-运行"><a href="#2-2-运行" class="headerlink" title="2.2 运行"></a><strong>2.2 运行</strong></h3><p>任意开启Shell，运行RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> detached参数使RabbitMQ以守护进程的方式在后台运行，不会因为Shell的关闭而影响服务</span></span><br><span class="line">rabbitmq-server -detached</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看RabbitMQ是否正常启动</span></span><br><span class="line">rabbitmqctl status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群信息，当前只有一个节点</span></span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p>运行失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmq-server -detached</span><br><span class="line">Warning: PID file not written; -detached was passed.</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmqctl status</span><br><span class="line">Status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Error: unable to connect to node rabbit@iZ2zeet6kto8eqx1w7sluzZ: nodedown</span><br><span class="line"></span><br><span class="line">DIAGNOSTICS</span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">attempted to contact: [rabbit@iZ2zeet6kto8eqx1w7sluzZ]</span><br><span class="line"></span><br><span class="line">rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">  * connected to epmd (port 4369) on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">  * epmd reports: node 'rabbit' not running at all</span><br><span class="line">                  no other nodes on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">  * suggestion: start the node</span><br><span class="line"></span><br><span class="line">current node details:</span><br><span class="line">- node name: 'rabbitmq-cli-57@iZ2zeet6kto8eqx1w7sluzZ'</span><br><span class="line">- home dir: /var/lib/rabbitmq</span><br><span class="line">- cookie hash: 63rISb5yZX97fhoF8LdjSg==</span><br></pre></td></tr></table></figure><p>首先排除是否是防火墙的问题：（不是这个原因）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙开放端口</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# firewall-cmd --zone=public --list-ports</span><br><span class="line">8025/tcp 6725/tcp</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# systemctl stop firewalld.service</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# service rabbitmq-server start</span><br><span class="line">Redirecting to /bin/systemctl start rabbitmq-server.service</span><br><span class="line">Job for rabbitmq-server.service failed because the control process exited with error code. See "systemctl status rabbitmq-server.service" and "journalctl -xe" for details.</span><br></pre></td></tr></table></figure><p>删除 <code>/var/lib/rabbitmq/mnesia</code> 目录下的文件，再重启：（不是这个原因）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# cd /var/lib/rabbitmq/mnesia</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# ls -AF</span><br><span class="line">rabbit@iZ2zeet6kto8eqx1w7sluzZ.pid</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# rm -rf rabbit@iZ2zeet6kto8eqx1w7sluzZ.pid</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# service rabbitmq-server start</span><br><span class="line">Redirecting to /bin/systemctl start rabbitmq-server.service</span><br><span class="line">Job for rabbitmq-server.service failed because the control process exited with error code. See "systemctl status rabbitmq-server.service" and "journalctl -xe" for details.</span><br></pre></td></tr></table></figure><p>查看详细错误信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# systemctl status rabbitmq-server.service</span><br><span class="line">● rabbitmq-server.service - RabbitMQ broker</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since Tue 2020-09-22 10:19:51 CST; 3s ago</span><br><span class="line">  Process: 27630 ExecStop=/bin/sh -c while ps -p $MAINPID &gt;/dev/null 2&gt;&amp;1; do sleep 1; done (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 27488 ExecStop=/usr/sbin/rabbitmqctl stop (code=exited, status=0/SUCCESS)</span><br><span class="line"><span class="meta">  #</span><span class="bash"> rabbitmq-server启动失败</span></span><br><span class="line">  Process: 27187 ExecStart=/usr/sbin/rabbitmq-server (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 27187 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Failed to start RabbitMQ broker.</span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Unit rabbitmq-server.service entered failed state.</span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service failed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# journalctl -xe</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: Stack trace:</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: []</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: &#123;"init terminating in do_boot",noproc&#125;</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: init terminating in do_boot (noproc)</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: Crash dump is being written to: erl_crash.dump...done</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service: main process exited, code=exited, status=1/FAILURE</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: Stopping and halting node rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: Error: unable to connect to node rabbit@iZ2zeet6kto8eqx1w7sluzZ: nodedown</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: DIAGNOSTICS</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: ===========</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: attempted to contact: [rabbit@iZ2zeet6kto8eqx1w7sluzZ]</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * connected to epmd (port 4369) on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * epmd reports: node 'rabbit' not running at all</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: no other nodes on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * suggestion: start the node</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: current node details:</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - node name: 'rabbitmq-cli-55@iZ2zeet6kto8eqx1w7sluzZ'</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - home dir: .</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - cookie hash: 63rISb5yZX97fhoF8LdjSg==</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Failed to start RabbitMQ broker.</span><br><span class="line">-- Subject: Unit rabbitmq-server.service has failed</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">-- </span><br><span class="line">-- Unit rabbitmq-server.service has failed.</span><br><span class="line">-- </span><br><span class="line">-- The result is failed.</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Unit rabbitmq-server.service entered failed state.</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service failed.</span><br><span class="line">lines 1389-1419/1419 (END)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 尝试重启</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ sbin]# rabbitmq-server restart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOT FAILED</span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">Error description:</span><br><span class="line">   noproc</span><br><span class="line"></span><br><span class="line">Log files (may contain more information):</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line"></span><br><span class="line">Stack trace:</span><br><span class="line">   []</span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 22-Sep-2020::20:41:05.655469 ===</span><br><span class="line">Error description:</span><br><span class="line">   noproc</span><br><span class="line"></span><br><span class="line">Log files (may contain more information):</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line"></span><br><span class="line">Stack trace:</span><br><span class="line">   []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;"init terminating in do_boot",noproc&#125;</span><br><span class="line">init terminating in do_boot (noproc)</span><br><span class="line"></span><br><span class="line">Crash dump is being written to: erl_crash.dump...done</span><br></pre></td></tr></table></figure><p>根据提示 <code>noproc</code> 考虑是否是版本不匹配，<a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">rabbitmq - erlang</a> 官网查询确认是否匹配：</p><ul><li>Erlang：23.0.3</li><li>RabbitMQ：3.6.15</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010155.png" alt></p><p>卸载当前RabbitMQ，再重新下载一个3.8.8版本的RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>阿里云服务器下载GitHub实在是太慢了，选择用Docker拉取镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# service docker restart</span><br><span class="line">Redirecting to /bin/systemctl restart docker.service</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management</span><br><span class="line">Unable to find image 'rabbitmq:3-management' locally</span><br><span class="line">3-management: Pulling from library/rabbitmq</span><br><span class="line">5d9821c94847: Downloading [=======================&gt;                           ]  12.53MB/26.7MB</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>仍然很慢，还是直接下载RPM文件，加上断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>下载成功后，重新安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# ls -AF</span><br><span class="line">rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# yum install rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>重新启动：(终于成功)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmq-server -detached</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl status</span><br><span class="line">Status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">Runtime</span><br><span class="line"></span><br><span class="line">OS PID: 4074</span><br><span class="line">OS: Linux</span><br><span class="line">Uptime (seconds): 89</span><br><span class="line">Is under maintenance?: false</span><br><span class="line">RabbitMQ version: 3.8.8</span><br><span class="line">Node name: rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Erlang configuration: Erlang/OTP 23 [erts-11.0.3] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:64] [hipe]</span><br><span class="line">Erlang processes: 275 used, 1048576 limit</span><br><span class="line">Scheduler run queue: 1</span><br><span class="line">Cluster heartbeat timeout (net_ticktime): 60</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群状态</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="2-3-生产和消费消息"><a href="#2-3-生产和消费消息" class="headerlink" title="2.3 生产和消费消息"></a><strong>2.3 生产和消费消息</strong></h3><p>RabbitMQ的默认用户名和密码都是 <code>guest</code>，此账户只能本地访问，远程网络访问会受限，所以我们要首先<strong>添加一个用户</strong>，并<strong>设置访问权限</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新增用户</span></span><br><span class="line">rabbitmqctl add_user root root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置所有权限</span></span><br><span class="line">rabbitmqctl set_permissions -p / root ".*" ".*" ".*"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置管理员角色</span></span><br><span class="line">rabbitmqctl set_user_tags root administrator</span><br></pre></td></tr></table></figure><p>若在使用RabbitMQ的过程中有 <code>com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN</code> 类似报错，很可能就是账户的问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. <span class="keyword">For</span> details see the broker logfile.</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">ERROR</span> com.rabbitmq.client.impl.ForgivingExceptionHandler - An unexpected<span class="built_in"> connection </span>driver <span class="builtin-name">error</span> occured</span><br><span class="line">java.net.SocketException: Socket Closed</span><br></pre></td></tr></table></figure><p>在Java项目中引入RabbitMQ客户端的Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建消息生产者，发送一条消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitProducer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY = <span class="string">"routingkey_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"queue_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"xxx.xxx.xxx.xxx"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">                TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">                ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">                factory.setHost(IP_ADDRESS);</span><br><span class="line">                factory.setPort(PORT);</span><br><span class="line">                factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">                factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">                Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">                Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">                <span class="comment">// 创建一个 type direct 、持久化的、非自动删除的交换器</span></span><br><span class="line">                channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//创建一个持久化、非排他的、非自动删除的队列</span></span><br><span class="line">                channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//将交换器与队列通过路由键绑定</span></span><br><span class="line">                channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line">                <span class="comment">//发送一条持久化的消息 hello world !</span></span><br><span class="line">                String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY,</span><br><span class="line">                        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                        message.getBytes());</span><br><span class="line">                <span class="comment">//关闭资源</span></span><br><span class="line">                channel.close();</span><br><span class="line">                connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"queue_demo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"xxx.xxx.xxx.xxx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里的连接方式与生产者的 demo 略有不同，注意辨别区别</span></span><br><span class="line">        Connection connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">        channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"recv message : "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, consumer);</span><br><span class="line">        <span class="comment">//等待回调函数执行完毕之后 关闭资源</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recv message : <span class="type">Hello</span> World!</span><br></pre></td></tr></table></figure><p>此处采用继承 <code>DefaultConsumer</code> 的方式来实现消费，也可以使用 <code>QueueingConsumer</code> 来实现，但会有些隐患，并且这种实现已被废弃。</p><hr><h2 id="第三节-Rabbit入门"><a href="#第三节-Rabbit入门" class="headerlink" title="第三节 Rabbit入门"></a><strong>第三节 Rabbit入门</strong></h2><p>RabbitMQ的模型架构是什么？AMQP协议是什么？两者间又有何种联系？消息从生产者发出到消费者消费的过程要经历什么？</p><h3 id="3-1-RabbitMQ基本概念"><a href="#3-1-RabbitMQ基本概念" class="headerlink" title="3.1 RabbitMQ基本概念"></a><strong>3.1 RabbitMQ基本概念</strong></h3><h4 id="（1）生产者和消费者模型"><a href="#（1）生产者和消费者模型" class="headerlink" title="（1）生产者和消费者模型"></a><strong>（1）生产者和消费者模型</strong></h4><p>RabbitMQ 整体上是一个<strong>生产者与消费者模型</strong>，主要<strong>负责接收、存储和转发消息</strong>。可以把消息传递的过程想象成当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。</p><p>从计算机术语层面来说， RabbitMQ模型更像是一种<strong>交换机模型</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010143.png" alt></p><p>消息一般包含2个部分：</p><ul><li><strong>消息体</strong>：消息体也可以称之为 payload ，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个 JSON 字符串。当然可以进一步对这个消息体进行序列化操作。</li><li><strong>标签</strong>（Label）：用来表述这条消息，比如一个交换器的名称和一个路由键。</li></ul><p>大致流程：</p><ul><li><strong>生产者（Producer）</strong>将业务数据封装（序列化）成消息（指定Exchange和RoutingKey等），把消息交由RabbitMQ，即发送给Broker （AMQP协议中对应命令为Basic.Publish）。</li><li><strong>Broker （消息中间件的服务节点）</strong>，大多数情况下可以将 RabbitMQ Broker 看作一台 RabbitMQ 服务器。RabbitMQ之后会根据标签把消息发送给感兴趣的<strong>消费者（Consumer）</strong>。</li><li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。当消费者消费一条消息时，<strong>只是消费消息的消息体</strong>（ payload ）。在消息路由的过程中，消息的标签会丢弃，<strong>存入到队列中的消息只有消息体</strong>，消费者也只会消费到消息体，也就<strong>不知道消息的生产者是谁</strong>，当然消费者也不需要知道。</li><li>消费者受到消息体后（AMQP协议中对应命令为Basic.Consume或Basic.Get）进行反序列化，得到对应的业务数据，并进行业务处理。</li></ul><p>消费者进行业务处理可以不和接收消息的逻辑使用同一线程，比如使用一个线程去接收消息存入内存（<code>BlockingQueue</code>），使用另一个线程从内存读取数据，这样可以进一步解耦，提高整体处理效率。 </p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010144.png" alt></p><h4 id="（2）队列"><a href="#（2）队列" class="headerlink" title="（2）队列"></a><strong>（2）队列</strong></h4><p><strong>队列</strong>（Queue）是 RabbitMQ 的内部对象，用来<strong>存储消息</strong>。<strong>消息只能存储在队列中</strong>，这与Kafka这种消息中间件相反（<strong>Kafka消息存储在主题topic逻辑层面</strong>），相对应的队列逻辑只是主题实际存储文件中的位移标识。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010145.png" alt></p><p>多个消费者可以订阅同一个队列，队列中的消息会被<strong>平均分摊</strong>（Round-Robin，即轮询）给多个消费者处理，<strong>不是每个消费者都收到所有的消息并处理</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010146.png" alt></p><p>RabbitMQ<strong>不支持队列层面的广播消费</strong>，如果需要只能进行二次开发。</p><h4 id="（3）交换器、路由键、绑定、交换器类型"><a href="#（3）交换器、路由键、绑定、交换器类型" class="headerlink" title="（3）交换器、路由键、绑定、交换器类型"></a><strong>（3）交换器、路由键、绑定、交换器类型</strong></h4><p>上面我们理解为生产者将消息直接投递到队列上，但其实并非如此。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010147.png" alt></p><p><strong>交换器</strong>（Exchange），生产者会先将消息发送到交换器，交换器负责将消息路由到一个或多个队列中。若路由不到，可以返回给生产者或直接丢弃。</p><p><strong>路由键</strong>（RoutingKey），生产者将消息发给交换器时，会指定一个路由键，用来指定消息的路由规则，可以决定消息流向哪里。路由键需要与<strong>交换器类型</strong>和<strong>绑定键</strong>（BindingKey）联合使用。</p><p><strong>绑定键</strong>（BindingKey），属于路由键的一种，通过绑定键将交换器和队列关联起来。<strong>某些情形下绑定键与路由键可以看作同一个东西。</strong></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010148.png" alt></p><p>可以这样区别路由键和绑定键：</p><ul><li>使用绑定时，需要的路由键是 BindingKey 。<ul><li>涉及的客户端方法：<code>channel.exchangeBind</code> 、<code>channel.queueBind</code> </li><li>对应AMQP命令：<code>Exchange.Bind</code> 、<code>Queue.Bind</code> 。</li></ul></li><li>发送消息时，需要的路由键是 RoutingKey 。<ul><li>涉及的客户端方法：<code>channel.basicPublish</code> </li><li>对应AMQP命令：<code>Basic.Publish</code> </li></ul></li></ul><p><strong>交换器类型</strong>：</p><ul><li><p><strong>fanout</strong>：会把发送到该交换器的消息路由到所有绑定的队列中。</p></li><li><p><strong>direct</strong>：会把消息路由到BindingKey和RoutingKey完全匹配的队列中。</p><p>如下案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由键为warning，消息会路由到Queue1和Queue2</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">"warning"</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">message.getBytes());</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010149.png" alt></p><p>若设置路由键为“info”或“debug”，消息只会路由到Queue2。</p></li><li><p><strong>topic</strong>：在匹配规则上相比direct进行了扩展，也是把消息路由到BindingKey和RoutingKey匹配的队列中，但匹配规则包括：</p><ul><li>RoutingKey和BindingKey为 <code>.</code> 分隔的字符串，如 <code>com.rabbitmq.client</code> 。</li><li>BindingKey中可以存着两个特殊字符串 <code>*</code> 和 <code>#</code> ，用于模糊匹配，<code>*</code> 用于匹配一个单词，<code>#</code> 用于匹配多规格单词。</li></ul><p>如下案例：</p><ul><li>路由键 <code>com.rabbitmq.client</code> 的消息同时路由到Queue1和Queue2；</li><li>路由键 <code>com.hidden.client</code> 的消息只路由到Queue2；</li><li>路由键 <code>com.hidden.demo</code> 的消息只路由到Queue2；</li><li>路由键 <code>java.rabbitmq.demo</code> 的消息只路由到Queue1；</li><li>路由键 <code>java.util.concurrent</code> 的消息会被丢弃或返回给生产者；</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010150.png" alt></p></li><li><p><strong>headers</strong>：不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时会制定一组键值对，消息到交换器时也有键值对形式的headers，对比若完全匹配就路由到此队列。<strong>这一类型性能很差且不实用</strong>。</p></li></ul><h4 id="（4）RabbitMQ运转流程"><a href="#（4）RabbitMQ运转流程" class="headerlink" title="（4）RabbitMQ运转流程"></a><strong>（4）RabbitMQ运转流程</strong></h4><p>生产者发送消息（最初状态）：</p><ol><li>生产者连接到 RabbitMQ Broker 建立一个<strong>连接</strong>（Connection），开启一个<strong>信道</strong>（Channel） ；</li><li>生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等；</li><li>生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等；</li><li>生产者通过路由键将交换器和队列绑定起来；</li><li>生产者发送消息至 RabbitMQ Broker，其中包含路由键、交换器等信息；</li><li>相应的交换器根据接收到的路由键查找相匹配的队列；</li><li>如果找到，则将从生产者发送过来的消息存入相应的队列中。</li><li>如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者。</li><li>关闭信道。</li><li>关闭连接。 </li></ol><p>消费者接收消息的过程： </p><ol><li>消费者连接到 RabbitMQ Broker ，建立一个<strong>连接</strong>（Connection），开启一个<strong>信道</strong>（Channel)；</li><li>消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作。 </li><li>等待 RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。</li><li>消费者确认（ack）接收到的消息。</li><li>RabbitMQ 从队列中删除相应己经被确认的消息。</li><li>关闭信道。</li><li>关闭连接。</li></ol><h4 id="（5）连接和信道"><a href="#（5）连接和信道" class="headerlink" title="（5）连接和信道"></a><strong>（5）连接和信道</strong></h4><p><strong>连接</strong>（Connection），即一条TCP连接。当TCP连接建立起来，客户端紧接着创建一个AMQP<strong>信道</strong>（Channel)，每个信道都会被指派一个唯一的ID。信道是虚拟链接，<strong>RabbitMQ处理每条AMQP指令都是通过信道完成</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010151.png" alt></p><p><strong>信道的作用？</strong></p><p>一个应用程序会有很多线程需要从MQ中消费消息或生产消息，所以要建立很多TCP连接。对于操作系统而言，<strong>建立和销毁TCP连接都需要昂贵的开销</strong>，所以 RabbitMQ 采用类似 NIO（Non-blocking I/O）的做法，选择<strong>TCP连接复用</strong>，既减少性能开销也便于管理。</p><p><strong>每个线程持有一个信道，信道复用了TCP连接，而 RabbitMQ 还可以保证每个线程的私密性和持有独立的连接一样。</strong>当单个信道流量很大时，多个信道复用一个连接就会产生性能瓶颈，此时可以开辟多个连接并进行均摊。</p><h3 id="3-2-AMQP协议"><a href="#3-2-AMQP协议" class="headerlink" title="3.2 AMQP协议"></a><strong>3.2 AMQP协议</strong></h3><p>AMQP协议的模型架构和 RabbitMQ的模型架构一样：生产者将消息发送给交换器，交换器与队列绑定，当生产者发送消息时所携带的 RoutingKey 与绑定时的 BindingKey 相匹配时，消息即被存入相应的队列之中。消费者可以订阅相应的队列来获取消息。</p><p>AMQP协议包括三层：</p><ul><li><strong>Module Layer</strong>：位于协议<strong>最高层</strong>，主要定义了一些供客户端调用的命令，客户端可以利用这些命令实现自己的业务逻辑。例如客户端可以使用 <code>Queue.Declare</code> 命令声明一个队列或者使用 <code>Basic.Consume</code> 订阅消费一个队列中的消息。 </li><li><strong>Session Layer</strong>：位于<strong>中间层</strong>，主要负责将客户端的命令发送给服务器，再将服务端的应答返回给客户端，主要为客户端与服务器之间的通信提供可靠性同步机制和错误处理。</li><li><strong>Transport Layer</strong> ：位于<strong>最底层</strong>，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。</li></ul><p><strong>AMQP说到底还是一个通信协议，都会涉及到报文交互</strong>，从 low level 举例来说，AMQP <strong>本身是应用层的协议，其填充于 TCP 协议层的数据部分</strong>。而从 high-level 来说 AMQP 是通过协议命令进行交互的。AMQP 协议可以看作一系列结构化命令的集合，这里的命令代表一种操作，类似于 HTTP 中的方法（GET、POST、PUT、DELETE 等）。</p><h4 id="（1）AMQP生产者流转过程"><a href="#（1）AMQP生产者流转过程" class="headerlink" title="（1）AMQP生产者流转过程"></a><strong>（1）AMQP生产者流转过程</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"><span class="comment">// 创建一个 type direct 、持久化的、非自动删除的交换器</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//创建一个持久化、非排他的、非自动删除的队列</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//将交换器与队列通过路由键绑定</span></span><br><span class="line">channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line"><span class="comment">//发送一条持久化的消息 hello world !</span></span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        message.getBytes());</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010152.png" alt></p><h4 id="（2）AMQP消费者者流转过程"><a href="#（2）AMQP消费者者流转过程" class="headerlink" title="（2）AMQP消费者者流转过程"></a><strong>（2）AMQP消费者者流转过程</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的连接方式与生产者的 demo 略有不同，注意辨别区别</span></span><br><span class="line">        Connection connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">        channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"recv message : "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, consumer);</span><br><span class="line">        <span class="comment">//等待回调函数执行完毕之后 关闭资源</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png" alt></p><h4 id="（3）AMQP命令概览"><a href="#（3）AMQP命令概览" class="headerlink" title="（3）AMQP命令概览"></a><strong>（3）AMQP命令概览</strong></h4><p>AMQP命令：</p><table><thead><tr><th>名称</th><th>是否包含内容体</th><th>对应客户端中的方法</th><th>简要描述</th></tr></thead><tbody><tr><td>Connection.Start</td><td>否</td><td>factory.newConnection</td><td>建立连接相关</td></tr><tr><td>Connection.Start-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Tune</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Tune-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Open</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Open-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Close</td><td>否</td><td>connection.close</td><td>关闭连接</td></tr><tr><td>Connection.Close-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Channel.Open</td><td>否</td><td>connection.openChannel</td><td>开启信道</td></tr><tr><td>Channel.Open-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Channel.Close</td><td>否</td><td>channel.close</td><td>关闭信道</td></tr><tr><td>Channel.Close-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Declare</td><td>否</td><td>channel.exchangeDeclare</td><td>声明交换器</td></tr><tr><td>Exchange.Declare-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Delete</td><td>否</td><td>channel.exchangeDelete</td><td>删除交换器</td></tr><tr><td>Exchange.Delete-Ok</td><td>否</td><td>向上</td><td>同上</td></tr><tr><td>Exchange.Bind</td><td>否</td><td>channel.exchangeBind</td><td>交换器与交换器绑定</td></tr><tr><td>Exchange.Bind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Unbind</td><td>否</td><td>channel.exchangeUnbind</td><td>交换器与交换器解绑</td></tr><tr><td>Exchange.Unbind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Declare</td><td>否</td><td>channel.queueDeclare</td><td>声明队列</td></tr><tr><td>Queue.Declare-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Bind</td><td>否</td><td>channel.queueBind</td><td>队列与交换器绑定</td></tr><tr><td>Queue.Bind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Purge</td><td>否</td><td>channel.queuePurge</td><td>清除队列中的内容</td></tr><tr><td>Queue.Purge-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Delete</td><td>否</td><td>channel.queueDelete</td><td>删除队列</td></tr><tr><td>Queue.Delete-Ok</td><td>否</td><td>同上</td><td>向上</td></tr><tr><td>Queue.Unbind</td><td>否</td><td>channel.queueUnbind</td><td>队列与交换器解绑</td></tr><tr><td>Queue.Unbind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Qos</td><td>否</td><td>channel.basicQos</td><td>设置未被确认消费的个数</td></tr><tr><td>Basic.Qos-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Consume</td><td>否</td><td>channel.basicConsume</td><td>消费消息（推模式）</td></tr><tr><td>BasiιConsume-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Cancel</td><td>否</td><td>channel.basicCancel</td><td>取消</td></tr><tr><td>Basic.Cancel-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Publish</td><td>否</td><td>channel.basicPublish</td><td>发送消息</td></tr><tr><td>Basic.Return</td><td>否</td><td>无</td><td>未能成功路由的消息返回</td></tr><tr><td>Basic.Deliver</td><td>否</td><td>无</td><td>Broker 推送消息</td></tr><tr><td>Basic.Get</td><td>否</td><td>channel.basicGet</td><td>消费消息（拉模式〉</td></tr><tr><td>Basic.Get-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Ack</td><td>否</td><td>channel.basicAck</td><td>确认</td></tr><tr><td>Basic.Reject</td><td>否</td><td>channel.basicReject</td><td>拒绝（单条拒绝）</td></tr><tr><td>Basic.Recover</td><td>否</td><td>channel.basicRecover</td><td>请求 Broker 重新发送未被确认的消息</td></tr><tr><td>Basic.Recover-Ok</td><td>否</td><td>向上</td><td>同上</td></tr><tr><td>Basic.Nack</td><td>否</td><td>channel.basicNack</td><td>拒绝（可批量拒绝〉</td></tr><tr><td>Tx.Select</td><td>否</td><td>channel.txSelect</td><td>开启事务</td></tr><tr><td>Tx.Select-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Tx.Commit</td><td>否</td><td>channel.txCommit</td><td>事务提交</td></tr><tr><td>Tx.Commit-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Tx.Rollback</td><td>否</td><td>channel.txRollback</td><td>事务回滚</td></tr><tr><td>Tx.Rollback-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Confirm Select</td><td>否</td><td>channel.confinnSelect</td><td>开启发送端确认模式</td></tr><tr><td>Confirm.Select-Ok</td><td>否</td><td>同上</td><td>同上</td></tr></tbody></table><hr><p>参考：</p><blockquote><p>《RabbitMQ实战指南》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第一章《简介和入门》，内容来自于《RabbitMQ实战指南》，内容包括：RabbitMQ概述，安装和简单使用，基本概念，AMQP协议等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>分布式概览（持续更新）</title>
    <link href="http://linyishui.top/2020091201.html"/>
    <id>http://linyishui.top/2020091201.html</id>
    <published>2020-09-12T12:20:42.000Z</published>
    <updated>2020-09-18T07:02:32.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式概览"><a href="#分布式概览" class="headerlink" title="分布式概览"></a><strong>分布式概览</strong></h1><h2 id="第一节-分布式系统"><a href="#第一节-分布式系统" class="headerlink" title="第一节 分布式系统"></a><strong>第一节 分布式系统</strong></h2><h3 id="1-1-什么是分布式系统？"><a href="#1-1-什么是分布式系统？" class="headerlink" title="1.1 什么是分布式系统？"></a><strong>1.1 什么是分布式系统？</strong></h3><p>分布式系统是一种<strong>组件分布在网络计算机上</strong>，<strong>组件之间仅仅通过消息传递来通信并协调行动</strong>的系统。</p><p>对于用户来说，他面对的只是一台服务器，但实际上这台服务器是由众多服务器组成的“一台超级计算机”。所以我们可以联想到我们日常使用的各种网站，它们背后都是一整个大型分布式系统在提供服务。</p><h3 id="1-2-分布式系统的意义？"><a href="#1-2-分布式系统的意义？" class="headerlink" title="1.2 分布式系统的意义？"></a><strong>1.2 分布式系统的意义？</strong></h3><p>为什么要从单一应用架构或垂直应用架构升级到分布式系统？</p><ul><li>升级单机处理能力的性价比越来越低</li><li>单机处理能力有瓶颈</li><li>分布式系统带来稳定性和可用性</li><li>单一应用不利于扩展和升级维护</li><li>单一应用拆分后，应用间的交互越来越复杂</li></ul><h3 id="1-3-基础知识补齐"><a href="#1-3-基础知识补齐" class="headerlink" title="1.3 基础知识补齐"></a><strong>1.3 基础知识补齐</strong></h3><h4 id="1-3-1-组成计算机的5要素"><a href="#1-3-1-组成计算机的5要素" class="headerlink" title="1.3.1 组成计算机的5要素"></a><strong>1.3.1 组成计算机的5要素</strong></h4><p>冯 · 诺依曼计算机的5个组成部分：</p><ul><li>运算器</li><li>控制器</li><li>存储器<ul><li>内存</li><li>外存：断电后仍能保存数据。</li></ul></li><li>输入设备</li><li>输出设备</li></ul><p>既然分布式系统看起来像一个超级计算机，是不是也有类似的结构呢？</p><h4 id="1-3-2-线程与进程的执行模式"><a href="#1-3-2-线程与进程的执行模式" class="headerlink" title="1.3.2 线程与进程的执行模式"></a><strong>1.3.2 线程与进程的执行模式</strong></h4><p>我们学习编程都是从单线程模式开始的，面对的都是<strong>程序的顺序、分支和循环执行</strong>。多线程（指单进程内的多线程）要处理<strong>线程间通信</strong>，要对<strong>线程并发</strong>做控制，做好<strong>线程间的协调工作</strong>。</p><p>在多核CPU的时代，程序的<strong>并发</strong>和<strong>并行</strong>很重要，决定着是否能够有效利用多核带来的性能提升。</p><p>多线程的几种交互模式：</p><ul><li><strong>互不通信的多线程模式</strong>：最简单的多线程模式，线程间无共享数据，也不需要做动作协调，就是多个独立的线程各自完成自己的任务。</li><li><strong>基于共享容器的多线程模式</strong>：多线程具有共享数据，如经典的生产者消费者问题。我们需要保证数据访问的正确性，对于存储数据的容器有线程安全或不安全之分，线程不安全的容器一般可以通过<strong>加锁（数据读写比例很高，采用读写锁而非互斥锁）或写时复制CopyOnWrite</strong>的方式来控制。</li><li><strong>通过事件协同的多线程模式</strong>：除了并发访问的控制，线程间还会有协调的需求。比如A、B两个线程，B线程需要等待某个状态或事件发生后才能继续工作，而这个改变和A线程有关，这时就需要完成线程间的协调（等待通知机制），这种情况下需要注意避免死锁。</li></ul><p>多进程模式：线程属于进程，所以一个进程内的多个线程共享了进程的内存空间，而进程之间的内存空间是独立的。所以多个进程间通过内存共享、交换数据的方式与多线程有所不同。</p><ul><li>单机多进程</li><li>多机多进程：单机OS所支持的功能需要另外实现，单个机器故障处理的好就不影响集群。</li></ul><h4 id="1-3-3-网络通信"><a href="#1-3-3-网络通信" class="headerlink" title="1.3.3 网络通信"></a><strong>1.3.3 网络通信</strong></h4><p><strong>OSI与TCP/IP网络模型</strong></p><p><img src alt></p><p><img src alt></p><p>OSI七层模型：</p><ul><li>应用层</li><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li><li>运输层</li><li>网路层</li><li>数据链路层</li><li>物理层</li></ul><p>五层协议：</p><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 <strong>HTTP</strong>、<strong>DNS</strong> 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<ul><li>传输控制协议 <strong>TCP</strong>，提供面向连接、可靠的数据传输服务，数据单位为报文段；</li><li>用户数据报协议 <strong>UDP</strong>，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。</li><li>TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li></ul></li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><p>TCP/IP：</p><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p>网络IO的实现方式：使用Socket套接字进行网络通信开发时，会使用哪些实现方式。</p><ul><li><strong>BIO</strong>：Blocking IO，阻塞式实现。一个套接字需要使用一个线程来处理，建立连接、读数据、写数据都可能会阻塞。</li><li><strong>NIO</strong>：Nonblocking IO，非阻塞式实现，基于事件驱动思想，采用 Reactor 模式。相比于BIO，NIO不用为每个套接字分配一个线程，而是一个线程处理多个套接字的相关工作。</li><li><strong>AIO</strong>：AsynchronousIO，异步IO，采用 Proactor 模式。与NIO的差异是，AIO在进行读写操作时，只需调用相应的 read/write 方法，并且传入 CompletionHandler（动作完成的处理器）；在动作完成后，会调用CompletionHandler。NIO的通知发生在动作之前，是在可写、可读的时候，Selector发现这些事件后调用 Handler 处理。</li></ul><h4 id="1-3-4-如何把应用从单机扩展到分布式"><a href="#1-3-4-如何把应用从单机扩展到分布式" class="headerlink" title="1.3.4 如何把应用从单机扩展到分布式"></a><strong>1.3.4 如何把应用从单机扩展到分布式</strong></h4><p>分布式这种“超级计算机”的五个组成部分的变化：</p><ul><li>输入设备：<ul><li>互相连接的多个节点，某个节点接受其他节点信息时，可以看作输入设备。</li><li>传统人机交互的输入设备。</li></ul></li><li>输出设备：<ul><li>互相连接的多个节点，某个节点向其他节点传递信息时，可以看作输出设备。</li><li>传统人机交互的输出设备，如屏幕。</li></ul></li><li>控制器：<ul><li>单机的控制器就是CPU中的控制器。</li><li>分布式中控制器负责协调或控制节点之间的动作和行为。如远程服务调用的场景，有几种实现方式：<ul><li><strong>硬件负载均衡</strong>：所有请求都要通过机器转发。</li><li><strong>LVS透明代理</strong>：增加了网络的开销（流量和延迟），因为多了一层转发；代理崩溃会影响所有请求。</li><li><strong>名称服务</strong>：没有代理地址，请求的发起者和处理者<strong>直接连接</strong>，只不过名称服务模块搜集处理服务器的地址信息，发起者先从本机名称服务获取地址。代码升级比较复杂。</li><li><strong>规则服务器</strong>：也是<strong>直接连接</strong>，区别是名称服务和处理者机器交互记录其地址，规则服务器则不和处理者交互，只提供规则给请求的发起者。</li><li><strong>Master+Worker</strong>：Master节点管理任务，分配给不同的Worker进行处理。</li></ul></li></ul></li><li>运算器：分布式系统运用多个节点的计算能力来协同完成整体的计算任务。<ul><li>例如我们需要日志处理服务器从应用服务器集群收集日志并处理，随着应用服务器的增多，单台日志处理服务器达到瓶颈，所以需要增加日志服务器来提升处理能力。</li><li>可以使用<strong>Master+Worker</strong>来控制日志服务器集群，当然也可以采用规则服务器等。</li></ul></li><li>存储器：<ul><li>单机中存储器分为内存和外存。</li><li>分布式中要把承担存储功能的多个节点组织在一起。</li><li>实现方式：（如KV存储服务器）<ul><li>代理服务器，根据请求的Key划分（Sharding）进行转发</li><li>名称服务，根据不同场景有两种实现：<ul><li>配合规则服务器，完成固定的Sharding策略</li><li>在消息中间件的应用场景，同等看待KV存储服务器，可以灵活的增加或减少服务器。</li></ul></li><li>规则服务器，除了对数据进行Sharding，还包括具体KV存储服务器的地址。</li><li>Master根据请求返回目标KV存储服务器地址，相比名称服务返回所有地址，Master根据请求返回对应地址；相比规则服务器把规则传给具体应用再由应用服务器解析并完成规则下的路由选择，Master自身完成了这件事情，只把结果传给应用服务器，应用服务器只须拿着地址去访问即可。</li></ul></li></ul></li></ul><h4 id="1-3-5-分布式系统的难点"><a href="#1-3-5-分布式系统的难点" class="headerlink" title="1.3.5 分布式系统的难点"></a><strong>1.3.5 分布式系统的难点</strong></h4><ul><li><strong>缺乏全局时钟</strong>：单机有机器时钟为标准，容易控制时序。分布式系统中同步本身就有时间差，很难保持所有机器的时间一致。不过我们使用时钟来区分动作间的顺序不需要准确的时间，一般会由一个单独的集群来区分动作间的顺序。</li><li><strong>面对故障独立性</strong>：分布式系统中，某个部分有问题而其他部分正常是经常发生的。</li><li><strong>处理单点故障</strong>：单点即在分布式系统中的某个功能只由单机在支持，其发生的故障即单点故障，SPoE（Single Point of Failure）。所以能扩展为集群的就尽量扩展，只能单点实现的：<ul><li>做好这个单点的备份，能够在出问题时及时恢复，最好能自动恢复、快速恢复。</li><li>降低单点故障的影响范围，尽量减少故障发生时的损失。</li></ul></li><li><strong>事务</strong>：两阶段提交（2PC）、最终一致、BASE、CAP、Paxos等</li></ul><hr><h2 id="第二节-大型网站架构演变历程"><a href="#第二节-大型网站架构演变历程" class="headerlink" title="第二节 大型网站架构演变历程"></a><strong>第二节 大型网站架构演变历程</strong></h2><h3 id="2-1-早期-用Java技术和单机来构建网站"><a href="#2-1-早期-用Java技术和单机来构建网站" class="headerlink" title="2.1 早期-用Java技术和单机来构建网站"></a><strong>2.1 早期-用Java技术和单机来构建网站</strong></h3><p><strong>熟悉的技术</strong>：LAMP、MVC框架、JSP、Servlet、JDBC、Spring、Struts、Hibernate、HTML、CSS、JavaScript、Python等。</p><p>举一个交易网站的例子，核心模块有<strong>用户、商品和交易</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010119.png" alt></p><h3 id="2-2-单机负载告警，数据库与应用分离"><a href="#2-2-单机负载告警，数据库与应用分离" class="headerlink" title="2.2 单机负载告警，数据库与应用分离"></a><strong>2.2 单机负载告警，数据库与应用分离</strong></h3><p>随着访问量增加，单台服务器负载持续增高，我们首先把数据库与应用分开到两条服务器。这种变更对系统影响很小，只须修改数据库地址即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010120.png" alt></p><h3 id="2-3-应用服务器负载告警，走向集群"><a href="#2-3-应用服务器负载告警，走向集群" class="headerlink" title="2.3 应用服务器负载告警，走向集群"></a><strong>2.3 应用服务器负载告警，走向集群</strong></h3><p>应用服务器压力不断增加，可以根据监测来进行针对性的优化，我们选用将应用服务器由单机转为集群的优化方式。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010121.png" alt></p><h4 id="（1）单机转为集群的两个问题"><a href="#（1）单机转为集群的两个问题" class="headerlink" title="（1）单机转为集群的两个问题"></a><strong>（1）单机转为集群的两个问题</strong></h4><p>变更为集群会带来两个要解决的问题：</p><ul><li>两个应用服务器的选择问题，我们可以通过DNS或负载均衡设备来解决。</li><li>Session问题。</li></ul><p>引入负载均衡设备后：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010122.png" alt></p><p>我们知道HTTP协议是无状态的，为了支持有状态的会话需求，我们需要Session机制，在会话开始时分配一个SessionId，通过Cookie告知浏览器，以后会话中的每次请求都会携带此SessionId来告知Web服务器此次属于哪个会话。<strong>Web服务器需要独立的存储会话信息</strong>，当Cookie禁用时会拼接到URL中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010123.png" alt></p><p>所以当服务器变为两台时，Session就出现了问题，保存在单机上的会话，和随机访问任一服务器的会话请求产生了矛盾。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010124.png" alt></p><h4 id="（2）Session问题的解决方案"><a href="#（2）Session问题的解决方案" class="headerlink" title="（2）Session问题的解决方案"></a><strong>（2）Session问题的解决方案</strong></h4><ol><li><p><strong>Session Sticky</strong>：通过负载均衡器保证同一个会话的请求都在同一个Web服务器上处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010125.png" alt></p><p>最简单的方案，但也存在问题：</p><ul><li>一台服务器宕机或重启，其会话数据会丢失，对应的用户需要重新登录；</li><li>因为会话标识是应用层的信息，负载均衡器将会话请求保存在同一个Web服务器，需要进行应用层（第7层）的解析，开销会比第4层的交换大；</li><li>负载均衡器也变成了一个有状态的节点，相比无状态节点，内存消耗更大，容灾方面更麻烦。</li></ul></li><li><p><strong>Session Replication</strong>：每台Web服务器都保存相同的会话信息。需要在Web服务器间进行数据同步，保证Session数据一致。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010126.png" alt></p><p>同样也有其问题：</p><ul><li><strong>网络开销越来越大</strong>：同步Session数据导致了网络带宽的开销，只要Session数据有变化，就需要同步到所有机器，机器数越多，带来的网络开销越大；</li><li><strong>内存占用越来越大</strong>：每台服务器都要保存所有的Session数据，当整个集群的用户量很多时，保存数据所需的空间会很大。</li></ul></li><li><p><strong>Session数据集中存储</strong>：集中的存放所有的Session数据，所有Web服务器向同样地址获取Session。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010127.png" alt></p><p>此方案的问题：</p><ul><li>读写Session数据引入了网络操作，相比本机数据读取存在时延和不稳定行（内网通信好一些）；</li><li>集中存储Session的机器有问题，会影响整个应用（扩展集群）。</li></ul></li><li><p><strong>Cookie Based</strong>：把Session存放在Cookie中，Web服务器从Cookie中生成对应Session数据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010128.png" alt></p><p>此方案的不足：</p><ul><li>Cookie有<strong>长度限制</strong>；</li><li><strong>安全性</strong>：Session数据本身是服务端数据，此方案是由客户端存放通过外部网络传输，所以要对写入Cookie的Session数据进行加密（并不绝对安全）。</li><li><strong>带宽消耗</strong>：指数据中心整体外部带宽的消耗（每次请求都增加了数据）。</li><li><strong>性能影响</strong>：每次HTTP请求和响应都带有Session数据，对Web服务器来说，响应的结果输出越少，支持的并发请求就越多。</li></ul></li></ol><p>大型网站比较适合 <strong>Session Sticky</strong> 和 <strong>Session数据集中存储</strong> ，根据具体场景做出选择和权衡。</p><h3 id="2-4-数据读压力增大，读写分离"><a href="#2-4-数据读压力增大，读写分离" class="headerlink" title="2.4 数据读压力增大，读写分离"></a><strong>2.4 数据读压力增大，读写分离</strong></h3><h4 id="（1）采用数据库作为读库"><a href="#（1）采用数据库作为读库" class="headerlink" title="（1）采用数据库作为读库"></a><strong>（1）采用数据库作为读库</strong></h4><p>对于大型网站，大部分业务是读多写少的场景，这种情况我们可以考虑<strong>读写分离</strong>的方式。</p><p>我们可以在架构中增加一个读库，它只负责读取服务。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010129.png" alt></p><p>带来问题：</p><ul><li><p><strong>数据复制问题</strong>：数据库一般会提供数据复制功能，可以直接使用。</p><ul><li>要考虑数据复制的时延问题;</li><li>复制过程中数据的源和目标之间的映射关系及过滤条件的支持问题。</li></ul><p>数据库支持：（数据库对数据复制的支持是相对有限的）</p><ul><li>MySQL：Master（主库）+ Slave（备库）的结构，5.5版本之前都是异步数据复制，会有延迟，提供完全镜像方式的复制，保证了备库和主库的数据一致性。5.5后加入了 semi-sync ，在数据安全性上更好，但从读写分离的角度看仍有复制延迟的可能。</li><li>Oracle：Data Guard方案，主要用于容灾、数据库保护以及故障恢复等场景，在实施中又分为物理备库（物理StandBy）和逻辑备库（逻辑StandBy）。</li></ul></li></ul><ul><li><strong>应用对于数据源的选择问题</strong>：写操作走主库，事务读也要走主库，还要考虑备库数据相对于主库的延迟。</li></ul><h4 id="（2）搜索引擎"><a href="#（2）搜索引擎" class="headerlink" title="（2）搜索引擎"></a><strong>（2）搜索引擎</strong></h4><p>当我们需要根据商品标题查询商品信息时，常规做法是通过数据库的 <code>like</code> 功能进行模糊查询。使用搜索引擎的倒排表方式可以大大提升检索速度。</p><p>搜索引擎首先要根据被搜索数据构建索引，数据改变索引也要改变。应用要选择什么数据走搜索引擎，什么数据走数据库。构建索引的过程也是一种数据复制的过程，只不过不是简单的复制对应数据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010130.png" alt></p><p>可以从两个维度对搜索系统构建索引的方式进行划分：</p><ul><li>按照<strong>全量/增量</strong>划分：第一次构建索引用全量，在全量基础上采用增量方式更新索引（一般加入每日的全量作为补充）。</li><li>按照<strong>实时/非实时</strong>划分：更新时间上倾向于实时的方式，非实时主要考虑对数据源头的保护。</li></ul><h4 id="（3）缓存"><a href="#（3）缓存" class="headerlink" title="（3）缓存"></a><strong>（3）缓存</strong></h4><ol><li><p><strong>数据缓存</strong>：数据缓存的目的类似于读库，一般用来保存和查询键值对，来加速应用在响应请求时的数据读取速度。</p><p>两种方式：</p><ul><li><strong>应用主动更新缓存</strong>：应用访问缓存，数据不存在则从数据库读出并放入缓存，当缓存容量不足时清除最近不被访问的数据。</li><li><strong>数据库记录变化更新缓存</strong>：数据库发生变化，主动把数据放入缓存，这样能够及时更新缓存中的数据，不会造成读取失效。<strong>一般用于全数据缓存，要求相关代码要结合业务逻辑。</strong></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010131.png" alt></p></li><li><p><strong>页面缓存</strong>：缓存一些动态产生的页面或页面的一部分内容，ESI是一种针对这种情况的规范。</p><ul><li>Web服务器产生的请求响应结果返回给Apache，处理后找到ESI标签，在缓存中获取标签对应内容；若内容不存在，Apache模板通过Web服务器渲染这些内容，再把结果放回缓存，用内容替换掉ESI标签并返回给客户。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010132.png" alt></p><ul><li>ESI模块总是要对响应结果进行解析，Web服务器处理时直接完成这项工作是更好的选择。所以改进为如下结构，把渲染和缓存功能放在Web服务器，这样更高效一些。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010133.png" alt></p></li></ol><p>使用缓存来加速数据读取时要注意：</p><ul><li>缓存命中率：太低就导致大量请求仍要回到数据库；</li><li>数据的分布和更新策略：<ul><li>分布上要考虑<strong>避免局部热点</strong>的机制，缓存服务器的扩容和缩容要尽量平滑（考虑<strong>一致性Has</strong>h）；</li><li>更新上会有<strong>定时失效、数据变更时失效和数据变更时更新</strong>几种策略。</li></ul></li></ul><h3 id="2-5-引入分布式存储系统"><a href="#2-5-引入分布式存储系统" class="headerlink" title="2.5 引入分布式存储系统"></a><strong>2.5 引入分布式存储系统</strong></h3><p>常见的分布式存储系统：</p><ul><li>分布式文件系统：弱格式，内容格式需要自行组织，解决小文件和大文件的存储问题；</li><li>分布式Key-Value系统：提供高性能的半结构化支持；</li><li>分布式数据库：提供一个支持大数据、高并发的数据库系统。</li></ul><p>分布式存储系统通过集群提供了一个高容量、高并发访问、数据冗余容灾的支持，直接代替原先的单机主库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010134.png" alt></p><h3 id="2-6-读写分离后，数据库又遇到瓶颈"><a href="#2-6-读写分离后，数据库又遇到瓶颈" class="headerlink" title="2.6 读写分离后，数据库又遇到瓶颈"></a><strong>2.6 读写分离后，数据库又遇到瓶颈</strong></h3><p>虽然进行了以上的优化，我们的核心功能数据（用户、商品和交易）还都在一个数据库中，随着数据量和访问量的增大，数据库的压力还在不断增加。</p><p>此时我们需要进行数据的<strong>垂直拆分</strong>和<strong>水平拆分</strong>。</p><h4 id="（1）专库专用，数据垂直拆分"><a href="#（1）专库专用，数据垂直拆分" class="headerlink" title="（1）专库专用，数据垂直拆分"></a><strong>（1）专库专用，数据垂直拆分</strong></h4><p>垂直拆分就是<strong>把数据库中不同业务数据拆分到不同的数据库</strong>，对于交易系统这个例子就是把用户、商品、交易数据分开。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010135.png" alt></p><p>带来的影响：</p><ul><li>应用配置多数据源；</li><li>单机跨业务事务要转为分布式事务；</li><li>表关联要改变实现。</li></ul><h4 id="（2）垂直拆分后的单机仍有瓶颈，数据水平拆分"><a href="#（2）垂直拆分后的单机仍有瓶颈，数据水平拆分" class="headerlink" title="（2）垂直拆分后的单机仍有瓶颈，数据水平拆分"></a><strong>（2）垂直拆分后的单机仍有瓶颈，数据水平拆分</strong></h4><p>水平拆分就是<strong>把同一个表中的数据拆分到多个数据库中</strong>。一般是因为某个业务的数据表的数据量太大，达到了单个数据库的瓶颈。</p><p><strong>水平拆分与读写分离</strong>：读写分离解决的是读压力过大的问题，对于数据量大或更新量的情况并不起作用。</p><p><strong>水平拆分与垂直拆分</strong>：垂直拆分把不同表放到不同数据库，水平拆分把同一个表拆到不同数据库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010136.png" alt></p><p>带来的影响：（假设拆分用户表）</p><ul><li><strong>解决SQL路由问题</strong>：用户信息被切分到了两个库，在进行数据库操作时要知道操作的数据在哪个库。</li><li><strong>解决主键问题</strong>：原先可能是Oracle的 Sequence 或MySQL的自增字段，现在要保证多个库的主键不重复。</li><li><strong>修改查询</strong>：同个业务的数据被拆分到不同数据库，所以一些查询要从多个库取数据，如果还要分页就很难处理。</li></ul><p>完成水平拆分后，我们能很好的应对数据量及写入量增长的情况。</p><h3 id="2-7-单机负载告警，数据库与应用分离"><a href="#2-7-单机负载告警，数据库与应用分离" class="headerlink" title="2.7 单机负载告警，数据库与应用分离"></a><strong>2.7 单机负载告警，数据库与应用分离</strong></h3><p>解决完数据库问题后，我们来看下应用的变化。我们之前完成了应用服务器从单机到多机的扩展，但随着业务的发展，应用功能越来越多，为了控制应用的大小，我们需要把应用拆开。</p><h4 id="（1）拆分应用"><a href="#（1）拆分应用" class="headerlink" title="（1）拆分应用"></a><strong>（1）拆分应用</strong></h4><p><strong>根据业务特性拆分</strong>：交易系统中就是拆成分别以交易和商品为主的两个应用，当然两个应用都有涉及用户的地方，我们先粗糙的让系统各自完成用户工作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010137.png" alt></p><p>通常新拆出的应用之间没有直接的相互调用，但可能会链接相同的数据库。如下，我们拆分了几个业务，它们之间没有直接的调用，都依赖底层的数据库、缓存、文件系统、搜索等。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010138.png" alt></p><h4 id="（2）服务化"><a href="#（2）服务化" class="headerlink" title="（2）服务化"></a><strong>（2）服务化</strong></h4><p>如下图，我们把应用分成了三层，最上层是Web系统，用于完成不同的业务功能；中间层是服务中心，各自提供不同的业务服务；最下层则是业务的数据库。（图中省略了缓存等基础系统）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010139.png" alt></p><p>服务化的区别：</p><ul><li><strong>方法调用</strong>：业务功能内不仅仅是单机的内部方法调用了，还<strong>需要远程服务调用</strong>（RPC）；</li><li><strong>共享代码</strong>：不再是散落在不同的应用，而是<strong>集中在各个服务中心</strong>。</li><li><strong>数据库连接</strong>：数据库交互工作在服务中心，Web应用专注于与浏览器交互的工作，不必多关注业务逻辑。服务中心不仅把散落的可共用的业务代码集中起来，还可以使其得到更好的维护。</li><li><strong>适合人员分工</strong>：每个服务都可以由固定的小团队来维护，更好的保持稳定性。</li></ul><h3 id="2-8-消息中间件"><a href="#2-8-消息中间件" class="headerlink" title="2.8 消息中间件"></a><strong>2.8 消息中间件</strong></h3><p>消息中间件（Message-oriented middleware，MOM）就是面向消息的系统，是在分布式系统中完成消息的发送和接收的基础软件。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010140.png" alt></p><p>消息中间件有两个为人熟知的优点：<strong>异步</strong>和<strong>解耦</strong>。</p><h3 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a><strong>2.9 总结</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010141.png" alt></p><hr><h2 id="第三节-Java中间件"><a href="#第三节-Java中间件" class="headerlink" title="第三节 Java中间件"></a><strong>第三节 Java中间件</strong></h2><p>在网站的演变过程中，无论是服务化、数据库的读写分离和拆分处理还是消息系统，都会用到相关的中间件。</p><p>中间件就是为软件应用提供除操作系统提供的服务以外的服务，让软件开发者更方便的处理通信、输入和输出，关注自己应用的部分。</p><p>我们这里主要了解三个领域的中间件：</p><ul><li><strong>远程过程调用和对象访问中间件</strong>：</li><li><strong>消息中间件</strong>：</li><li><strong>数据访问中间件</strong>：</li></ul><hr><h2 id="第四节-服务框架"><a href="#第四节-服务框架" class="headerlink" title="第四节 服务框架"></a><strong>第四节 服务框架</strong></h2><hr><h2 id="第五节-数据访问层"><a href="#第五节-数据访问层" class="headerlink" title="第五节 数据访问层"></a><strong>第五节 数据访问层</strong></h2><hr><h2 id="第六节-消息中间件"><a href="#第六节-消息中间件" class="headerlink" title="第六节 消息中间件"></a><strong>第六节 消息中间件</strong></h2><hr><h2 id="第七节-软负载中心与集中配置管理"><a href="#第七节-软负载中心与集中配置管理" class="headerlink" title="第七节 软负载中心与集中配置管理"></a><strong>第七节 软负载中心与集中配置管理</strong></h2><hr><h2 id="第八节-CDN"><a href="#第八节-CDN" class="headerlink" title="第八节 CDN"></a><strong>第八节 CDN</strong></h2><hr><h2 id="第九节-分布式存储"><a href="#第九节-分布式存储" class="headerlink" title="第九节 分布式存储"></a><strong>第九节 分布式存储</strong></h2><hr><h2 id="第十节-搜索系统"><a href="#第十节-搜索系统" class="headerlink" title="第十节 搜索系统"></a><strong>第十节 搜索系统</strong></h2><hr><h2 id="第十一节-其他"><a href="#第十一节-其他" class="headerlink" title="第十一节 其他"></a><strong>第十一节 其他</strong></h2><hr><p>参考：</p><blockquote><p>《大型网站系统与Java中间件实践》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      分布式相关知识内容的概览，简单整理了一下。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习dubbo（二）注册中心和监控中心</title>
    <link href="http://linyishui.top/2020090801.html"/>
    <id>http://linyishui.top/2020090801.html</id>
    <published>2020-09-08T09:50:24.000Z</published>
    <updated>2020-09-12T15:06:02.678Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo（二）注册中心和监控中心"><a href="#dubbo（二）注册中心和监控中心" class="headerlink" title="dubbo（二）注册中心和监控中心"></a><strong>dubbo（二）注册中心和监控中心</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-dubbo支持的几种注册中心"><a href="#1-1-dubbo支持的几种注册中心" class="headerlink" title="1.1 dubbo支持的几种注册中心"></a><strong>1.1 dubbo支持的几种注册中心</strong></h3><ul><li><strong>Multicast</strong>：不需要启动任何中心节点，只要广播地址一样，就可以互相发现。</li><li><strong>Zookeeper</strong>：Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</li><li><strong>Nacos</strong>：Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 <a href="https://github.com/apache/incubator-dubbo/tree/master/dubbo-registry/dubbo-registry-nacos" target="_blank" rel="noopener"><code>dubbo-registry-nacos</code></a> 则是 Dubbo 融合 Nacos 注册中心的实现。</li><li><strong>Redis</strong>：使用 Redis 的 Key/Map 结构存储数据结构，使用 Redis 的 Publish/Subscribe 事件通知数据变更。</li><li><strong>Simple</strong>：Simple 注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。</li></ul><h3 id="1-2-Zookeeper注册中心"><a href="#1-2-Zookeeper注册中心" class="headerlink" title="1.2 Zookeeper注册中心"></a><strong>1.2 Zookeeper注册中心</strong></h3><p>官方推荐的注册中心，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境。如下图树型结构。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/zookeeper.jpg" alt></p><p>流程说明：</p><ul><li><strong>服务提供者启动时</strong>: 向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li><strong>服务消费者启动时</strong>: 订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li><strong>监控中心启动时</strong>: 订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址。</li></ul><p>支持以下功能：</p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息。</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求。</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求。</li><li>当设置 <code>&lt;dubbo:registry check=&quot;false&quot; /&gt;</code> 时，记录失败注册和订阅请求，后台定时重试。</li><li>可通过 <code>&lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt;</code> 设置 zookeeper 登录信息。</li><li>可通过 <code>&lt;dubbo:registry group=&quot;dubbo&quot; /&gt;</code> 设置 zookeeper 的根节点，不配置将使用默认的根节点。</li><li>支持 <code>*</code> 号通配符 <code>&lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;</code>，可订阅服务的所有分组和所有版本的提供者。</li></ul><hr><h2 id="第二节-使用"><a href="#第二节-使用" class="headerlink" title="第二节 使用"></a><strong>第二节 使用</strong></h2><p>学习环境：LG笔记本 + Win10</p><h3 id="2-1-注册中心"><a href="#2-1-注册中心" class="headerlink" title="2.1 注册中心"></a><strong>2.1 注册中心</strong></h3><p>首先安装Zookeeper注册中心，下载地址：<a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">Zookeeper - download</a></p><p>包结构：</p><ul><li>bin：二进制执行文件，如 <code>zkServer.cmd</code> 可用于Win10执行。</li><li>conf：配置文件 <code>.cfg</code> 。</li><li>contrib：</li><li>dist-maven：</li><li>docs：</li><li>lib：</li><li>recipes：</li><li>src：</li></ul><p>首次启动 <code>zkServer.cmd</code> 会出错。</p><p>找到默认配置文件，创建副本并改名为 <code>zoo.cfg</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 数据存储位置</span><br><span class="line">dataDir=../data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure><p>再次启动 <code>zkServer.cmd</code> 。</p><p>启动 <code>zkCli.cmd</code> 简单使用以下Zookeeper。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取根目录文件</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] get /</span><br><span class="line"></span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看根目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建节点<span class="built_in">test</span></span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /test 123456</span><br><span class="line">Created /test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /</span><br><span class="line">[zookeeper, test]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取<span class="built_in">test</span>节点</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] get /test</span><br><span class="line">123456</span><br><span class="line">cZxid = 0x4</span><br><span class="line">ctime = Tue Sep 08 20:10:35 CST 2020</span><br><span class="line">mZxid = 0x4</span><br><span class="line">mtime = Tue Sep 08 20:10:35 CST 2020</span><br><span class="line">pZxid = 0x4</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x100061cf1510001</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h3 id="2-2-监控中心"><a href="#2-2-监控中心" class="headerlink" title="2.2 监控中心"></a><strong>2.2 监控中心</strong></h3><p>在GitHub找到dubbo项目：<a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">apache/dubbo</a>。往下找到ecosystem，首先下载Dubbo Admin这是一个管理控制台。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010101.png" alt></p><p>查看 <code>application.properties</code> 中Zookeeper地址是否正确。</p><p>在Idea中运行或用Maven打包启动，注意运行端口。</p><p>生产环境配置：</p><ol><li><p>下载代码: <code>git clone https://github.com/apache/dubbo-admin.git</code></p></li><li><p>在 <code>dubbo-admin-server/src/main/resources/application.properties</code>中指定注册中心地址</p></li><li><p>构建</p><blockquote><ul><li><code>mvn clean package</code></li></ul></blockquote></li><li><p>启动</p><ul><li><code>mvn --projects dubbo-admin-server spring-boot:run</code><br>或者</li><li><code>cd dubbo-admin-distribution/target; java -jar dubbo-admin-0.1.jar</code></li></ul></li><li><p>访问 <code>http://localhost:8080</code></p></li></ol><p>开发环境配置：</p><ul><li>运行<code>dubbo admin server</code> <code>dubbo admin server</code>是一个标准的spring boot项目, 可以在任何java IDE中运行它</li><li>运行<code>dubbo admin ui</code> <code>dubbo admin ui</code>由npm管理和构建，在开发环境中，可以单独运行: <code>npm run dev</code></li><li>页面访问 访问 <code>http://localhost:8081</code>, 由于前后端分开部署，前端支持热加载，任何页面的修改都可以实时反馈，不需要重启应用。</li></ul><p>部署完成后，可以访问 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 来查看所有的restful api。</p><p>访问UI对应地址。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010102.png" alt></p><p>默认使用 root/root 登陆。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010103.png" alt></p><p>登录后可以查看Dubbon Admin提供的基础功能。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010104.png" alt></p><h3 id="2-3-实例"><a href="#2-3-实例" class="headerlink" title="2.3 实例"></a><strong>2.3 实例</strong></h3><h4 id="（1）需求"><a href="#（1）需求" class="headerlink" title="（1）需求"></a><strong>（1）需求</strong></h4><p>描述：某电商系统，其订单服务需要调用用户服务获取指定用户的所有地址。</p><p>因此我们需要构建两个服务模块：订单服务Web模块，用户服务Service模块。</p><p>实现：订单服务Web模块部署于服务器A，用户服务Service模块部署于服务器B，A可以远程调用B。</p><h4 id="（2）架构"><a href="#（2）架构" class="headerlink" title="（2）架构"></a><strong>（2）架构</strong></h4><p>根据 dubbo《<a href="http://dubbo.apache.org/zh-cn/docs/user/best-practice.html" target="_blank" rel="noopener">服务化最佳实践</a>》：</p><ol><li><p><strong>分包</strong>：建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：<strong>重用发布等价原则</strong>(REP)，<strong>共同重用原则</strong>(CRP)。</p><p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：/xxx/dubbo-reference.xml。</p></li><li><p><strong>粒度</strong>：服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p><p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p><p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p></li><li><p><strong>版本</strong>：每个接口都应定义版本号，为后续不兼容升级提供可能，如： <code>&lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; version=&quot;1.0&quot; /&gt;</code>。</p><p>建议使用两位版本号，因为第三位版本号通常表示兼容升级，只有不兼容时才需要变更服务版本。</p><p>当不兼容时，先升级一半提供者为新版本，再将消费者全部升为新版本，然后将剩下的一半提供者升为新版本。</p></li><li><p><strong>兼容性</strong>：服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。</p><p>各协议的兼容性不同，参见：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/introduction.html" target="_blank" rel="noopener">服务协议</a> 。</p></li><li><p><strong>枚举值</strong>：</p><ul><li>如果是完备集，可以用 <code>Enum</code>，比如：<code>ENABLE</code>, <code>DISABLE</code>。</li><li>如果是业务种类，以后明显会有类型增加，不建议用 <code>Enum</code>，可以用 <code>String</code> 代替。</li><li>如果是在返回值中用了 <code>Enum</code>，并新增了 <code>Enum</code> 值，建议先升级服务消费方，这样服务提供方不会返回新值。</li><li>如果是在传入参数中用了 <code>Enum</code>，并新增了 <code>Enum</code> 值，建议先升级服务提供方，这样服务消费方不会传入新值。</li></ul></li><li><p><strong>序列号</strong>：</p><ul><li>服务参数及返回值建议使用 POJO 对象，即通过 <code>setter</code>, <code>getter</code> 方法表示属性的对象。</li><li>服务参数及返回值不建议使用接口，因为数据模型抽象的意义不大，并且序列化需要接口实现类的元信息，并不能起到隐藏实现的意图。</li><li>服务参数及返回值都必须是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" target="_blank" rel="noopener">传值调用</a>，而不能是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference" target="_blank" rel="noopener">传引用调用</a>，消费方和提供方的参数或返回值引用并不是同一个，只是值相同，Dubbo 不支持引用远程对象。</li></ul></li><li><p><strong>异常</strong>：</p><ul><li>建议使用异常汇报错误，而不是返回错误码，异常信息能携带更多信息，并且语义更友好。</li><li>如果担心性能问题，在必要时，可以通过 override 掉异常类的 <code>fillInStackTrace()</code> 方法为空方法，使其不拷贝栈信息。</li><li>查询方法不建议抛出 checked 异常，否则调用方在查询时将过多的 <code>try...catch</code>，并且不能进行有效处理。</li><li>服务提供方不应将 DAO 或 SQL 等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常。</li></ul></li><li><p><strong>调用</strong>：</p><ul><li>不要只是因为是 Dubbo 调用，而把调用 <code>try...catch</code> 起来。<code>try...catch</code> 应该加上合适的回滚边界上。</li><li>Provider 端需要对输入参数进行校验。如有性能上的考虑，服务实现者可以考虑在 API 包上加上服务 Stub 类来完成检验。</li></ul></li></ol><p>最终：</p><ul><li>gmall-order-web：订单服务Web模块。</li><li>gmall-user：用户服务Service模块</li><li>gmall-interface：公共接口层。</li></ul><h4 id="（3）编码"><a href="#（3）编码" class="headerlink" title="（3）编码"></a><strong>（3）编码</strong></h4><p>创建Maven项目gmall，并分别创建子项目：</p><ul><li>gmall-order-web：订单服务Web模块。</li><li>gmall-user：用户服务Service模块</li><li>gmall-interface：公共接口层。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010105.png" alt></p><p>使用dubbo：</p><ul><li>首先引入dubbo和操作zookeeper的客户端的依赖；</li><li>创建xml，并在文件中配置服务（即官网所说的用Spring配置暴露服务）；</li><li>在启动类中加载Spring配置。</li></ul><h5 id="1-user-service-provider"><a href="#1-user-service-provider" class="headerlink" title="1.user-service-provider"></a><strong>1.user-service-provider</strong></h5><p>pom.xml，分别引入dubbo和zookeeper客户端。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入dubbo --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>provider.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"user-service-provider"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"127.0.0.1:2181"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20882"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4、暴露服务   ref：指向服务的真正的实现对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"userServiceImpl01"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--统一设置服务提供方的规则  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务的实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl01"</span> <span class="attr">class</span>=<span class="string">"gmall.service.impl.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"userServiceImpl02"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl02"</span> <span class="attr">class</span>=<span class="string">"gmall.service.impl.UserServiceImpl2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 连接监控中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"provider.xml"</span>);</span><br><span class="line">ioc.start();</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserServiceImpl.....old..."</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">"北京市昌平区宏福科技园综合楼3层"</span>, <span class="string">"1"</span>, <span class="string">"李老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"Y"</span>);</span><br><span class="line">UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">"深圳市宝安区西部硅谷大厦B座3层（深圳分校）"</span>, <span class="string">"1"</span>, <span class="string">"王老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"N"</span>);</span><br><span class="line"><span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">Thread.sleep(4000);</span></span><br><span class="line"><span class="comment">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">e.printStackTrace();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserServiceImpl.....new..."</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">"北京市昌平区宏福科技园综合楼3层"</span>, <span class="string">"1"</span>, <span class="string">"李老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"Y"</span>);</span><br><span class="line">UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">"深圳市宝安区西部硅谷大厦B座3层（深圳分校）"</span>, <span class="string">"1"</span>, <span class="string">"王老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"N"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceStub</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceStub</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入的是userService远程的代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserServiceStub</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.userService = userService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"UserServiceStub....."</span>);</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isEmpty(userId)) &#123;</span><br><span class="line"><span class="keyword">return</span> userService.getUserAddressList(userId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-order-service-consumer"><a href="#2-order-service-consumer" class="headerlink" title="2.order-service-consumer"></a><strong>2.order-service-consumer</strong></h5><p>pom.xml，也分别引入dubbo和zookeeper。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>order-service-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入dubbo --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>consumer.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"gmall.service.impl"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"order-service-consumer"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  配置本地存根--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明需要调用的远程服务的接口；生成远程服务代理  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">1）、精确优先 (方法级优先，接口级次之，全局配置再次之)</span></span><br><span class="line"><span class="comment">2）、消费者设置优先(如果级别一样，则消费方优先，提供方次之)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- timeout="0" 默认是1000ms--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- retries="":重试次数，不包含第一次调用，0代表不重试--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 幂等（设置重试次数）【查询、删除、修改】、非幂等（不能设置重试次数）【新增】 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span> <span class="attr">retries</span>=<span class="string">"3"</span> <span class="attr">version</span>=<span class="string">"*"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:method name="getUserAddressList" timeout="1000"&gt;&lt;/dubbo:method&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置当前消费者的统一规则：所有的服务都不检查 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:consumer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:monitor address="127.0.0.1:7070"&gt;&lt;/dubbo:monitor&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</span><br><span class="line"></span><br><span class="line">OrderService orderService = applicationContext.getBean(OrderService.class);</span><br><span class="line"></span><br><span class="line">orderService.initOrder(<span class="string">"1"</span>);</span><br><span class="line">System.out.println(<span class="string">"调用完成...."</span>);</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、将服务提供者注册到注册中心（暴露服务）</span></span><br><span class="line"><span class="comment"> * 1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator)</span></span><br><span class="line"><span class="comment"> * 2）、配置服务提供者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2、让服务消费者去注册中心订阅服务提供者的服务地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"用户id："</span>+userId);</span><br><span class="line"><span class="comment">//1、查询用户的收货地址</span></span><br><span class="line">List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);</span><br><span class="line"><span class="keyword">for</span> (UserAddress userAddress : addressList) &#123;</span><br><span class="line">System.out.println(userAddress.getUserAddress());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addressList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-gmall-interface"><a href="#3-gmall-interface" class="headerlink" title="3.gmall-interface"></a><strong>3.gmall-interface</strong></h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>UserAddress</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userAddress; <span class="comment">//用户地址</span></span><br><span class="line">    <span class="keyword">private</span> String userId; <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> String consignee; <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNum; <span class="comment">//电话号码</span></span><br><span class="line">    <span class="keyword">private</span> String isDefault; <span class="comment">//是否为默认地址    Y-是     N-否</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//constructor and getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化订单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照用户id返回所有的收货地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）启动"><a href="#（4）启动" class="headerlink" title="（4）启动"></a><strong>（4）启动</strong></h4><p>分别启动服务提供者和消费者，控制台输出如下内容：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户id：<span class="number">1</span></span><br><span class="line">北京市昌平区宏福科技园综合楼<span class="number">3</span>层</span><br><span class="line">深圳市宝安区西部硅谷大厦B座<span class="number">3</span>层（深圳分校）</span><br><span class="line">调用完成....</span><br></pre></td></tr></table></figure><p>此时再启动dubbo-admin，使用 root / root 登录。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010106.png" alt></p><hr><h2 id="第三节-整合Spring-Boot"><a href="#第三节-整合Spring-Boot" class="headerlink" title="第三节 整合Spring Boot"></a><strong>第三节 整合Spring Boot</strong></h2><p>GitHub地址：<a href="https://github.com/apache/dubbo-spring-boot-project" target="_blank" rel="noopener">apache/dubbo-spring-boot-project</a> 。</p><p>下载项目与依赖，并跑通案例 <code>dubbo-spring-boot-samples</code> 。</p><h3 id="3-1-公共接口-sample-api"><a href="#3-1-公共接口-sample-api" class="headerlink" title="3.1 公共接口 sample-api"></a><strong>3.1 公共接口 sample-api</strong></h3><p>首先看 <code>dubbo-spring-boot-samples</code> / <code>sample-api</code> ，它是<strong>公共接口层</strong>，提供了生产者和消费者要使用的DemoService服务接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.spring.boot.sample.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-自动装配-auto-configure-samples"><a href="#3-2-自动装配-auto-configure-samples" class="headerlink" title="3.2 自动装配 auto-configure-samples"></a><strong>3.2 自动装配 auto-configure-samples</strong></h3><p>再看 <code>dubbo-spring-boot-samples</code> / <code>auto-configure-samples</code> 。</p><h4 id="（1）provider"><a href="#（1）provider" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>首先看服务提供者provider的内容，配置了应用信息、Dubbo协议信息等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application </span><br><span class="line"># 应用名</span><br><span class="line">spring.application.name=dubbo-auto-configuration-provider-demo</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line"># 扫描的基础包</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Protocol地址和端口，指定远程调用协议为dubbo，还可以为rmi、http等</span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=12345</span><br><span class="line">## Dubbo Registry</span><br><span class="line">## 注册中心服务器地址，N/A为默认值，表示不使用注册中心，直连客户端，地址可以是一个或多个，多个表示集群</span><br><span class="line">dubbo.registry.address=N/A</span><br></pre></td></tr></table></figure><p>provider实现了DemoService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random costTimeRandom = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先简单休眠一下</span></span><br><span class="line">        await();</span><br><span class="line">        <span class="comment">//自己添加的更直观的控制台输出</span></span><br><span class="line">        System.out.println(<span class="string">"sayHello: "</span> + name);</span><br><span class="line">        <span class="comment">//打印serviceName和实参</span></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> timeInMillisToWait = costTimeRandom.nextInt(<span class="number">500</span>);</span><br><span class="line">            Thread.sleep(timeInMillisToWait);</span><br><span class="line">            logger.info(<span class="string">"execution time : "</span> + timeInMillisToWait + <span class="string">" ms."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboAutoConfigurationProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        new SpringApplicationBuilder(DubboAutoConfigurationProviderBootstrap.class)</span></span><br><span class="line"><span class="comment">//                .run(args);</span></span><br><span class="line">        SpringApplication.run(DubboAutoConfigurationProviderBootstrap.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）consumer"><a href="#（2）consumer" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>再来看服务消费者consumer，只是配置了应用名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-auto-configure-consumer-sample</span><br></pre></td></tr></table></figure><p>consumer的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboAutoConfigurationConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务提供者注册的地址等信息</span></span><br><span class="line">    <span class="meta">@DubboReference</span>(</span><br><span class="line">            version = <span class="string">"1.0.0"</span>,</span><br><span class="line">            url = <span class="string">"dubbo://127.0.0.1:12345"</span>,</span><br><span class="line">            timeout = <span class="number">100</span>,</span><br><span class="line">            methods = &#123;</span><br><span class="line">                    <span class="meta">@Method</span>(name = <span class="string">"sayHello"</span>, timeout = <span class="number">300</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboAutoConfigurationConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"runner()"</span>);</span><br><span class="line">        <span class="comment">//调用公共接口demoService，通过指定的服务实现远程调用服务</span></span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动并观察是否正确打印出结果。</p><h3 id="3-3-外部化配置-externalized-configuration-samples"><a href="#3-3-外部化配置-externalized-configuration-samples" class="headerlink" title="3.3 外部化配置 externalized-configuration-samples"></a><strong>3.3 外部化配置 externalized-configuration-samples</strong></h3><h4 id="（1）provider-1"><a href="#（1）provider-1" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>provider与 <code>auto-configure-samples</code> 中唯一不同的是多了服务版本的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-externalized-configuration-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=12345</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=N/A</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>provider的服务实现，不同的是服务的版本号从配置文件中获取，并且没有sleep。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider的启动类完全一致。</p><h4 id="（2）consumer-1"><a href="#（2）consumer-1" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>消费者consumer则增加了一些配置，启动了一些dubbo端点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-externalized-configuration-consumer-sample</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &apos;*&apos;</span><br><span class="line">  endpoint:</span><br><span class="line">    dubbo:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboshutdown:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboconfigs:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboservices:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboreferences:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboproperties:</span><br><span class="line">      enabled: true</span><br><span class="line">  security:</span><br><span class="line">    ## Deprecated 2.x</span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line">## For Spring Boot 1.x demo</span><br><span class="line">endpoints:</span><br><span class="line">  dubbo:</span><br><span class="line">    enabled: true</span><br><span class="line">    sensitive: false</span><br><span class="line">  dubboshutdown:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboconfigs:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboservices:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboreferences:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboproperties:</span><br><span class="line">    enabled: true</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line">    url: dubbo://localhost:12345</span><br></pre></td></tr></table></figure><p>consumer的启动类中 <code>@DubboReference</code> 也改为从配置文件读取，并且增加了Get请求接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboExternalizedConfigurationConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>, url = <span class="string">"$&#123;demo.service.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboExternalizedConfigurationConsumerBootstrap.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/say-hello"</span>, method = GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别启动 provider 和 consumer 并访问服务接口：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010108.png" alt></p><h3 id="3-4-注册中心-registry-samples"><a href="#3-4-注册中心-registry-samples" class="headerlink" title="3.4 注册中心 registry-samples"></a><strong>3.4 注册中心 registry-samples</strong></h3><p>这个实例提供了Dubbo最常用的两种注册中心：Zookeeper 和 Nacos 。</p><h4 id="（1）Zookeeper"><a href="#（1）Zookeeper" class="headerlink" title="（1）Zookeeper"></a><strong>（1）Zookeeper</strong></h4><p>配置文件如下，有些许变更：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-registry-zookeeper-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">## Random port 此处改为随机端口，会分配一个没有被占用的端口</span><br><span class="line">dubbo.protocol.port=-1</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">## 指定了注册中心地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">## 使用文件缓存注册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储</span><br><span class="line">dubbo.registry.file = $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现没有变更：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sayHello : "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类没有变更：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRegistryZooKeeperProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(DubboRegistryZooKeeperProviderBootstrap.class).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer中配置文件中增加了注册中心的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-registry-zookeeper-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line"></span><br><span class="line">embedded:</span><br><span class="line">  zookeeper:</span><br><span class="line">    port: 2181</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;</span><br><span class="line">    file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br></pre></td></tr></table></figure><p>启动类中 <code>@DubboReference</code> 只配置了服务版本，因为之前是通过客户端直连，所以需要指定客户端地址，此时使用注册中心，只须关注服务接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRegistryZooKeeperConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboRegistryZooKeeperConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动并观察控制台。</p><h4 id="（2）Nacos"><a href="#（2）Nacos" class="headerlink" title="（2）Nacos"></a><strong>（2）Nacos</strong></h4><p>内容基本一致，暂略。</p><h3 id="3-5-服务自省-service-introspection-samples"><a href="#3-5-服务自省-service-introspection-samples" class="headerlink" title="3.5  服务自省 service-introspection-samples"></a><strong>3.5  服务自省 service-introspection-samples</strong></h3><h4 id="（1）provider-2"><a href="#（1）provider-2" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>增加了 <code>registry-type</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-zookeeper-service-introspection-provider-sample</span><br><span class="line"></span><br><span class="line"># Zookeeper Server Configuration</span><br><span class="line">zookeeper.server.host = 127.0.0.1</span><br><span class="line">zookeeper.server.port = 2181</span><br><span class="line"></span><br><span class="line"># Dubbo Spring Boot Externalization Configuration</span><br><span class="line">## Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line">## Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">## Random port</span><br><span class="line">dubbo.protocol.port=-1</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=zookeeper://$&#123;zookeeper.server.host&#125;:$&#123;zookeeper.server.port&#125;?registry-type=service</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现和启动类没有变化。</p><h4 id="（2）consumer-2"><a href="#（2）consumer-2" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>增加了 <code>registry-type</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-zookeeper-service-introspection-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line"></span><br><span class="line">embedded:</span><br><span class="line">  zookeeper:</span><br><span class="line">    port: 2181</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;/?registry-type=service</span><br><span class="line">    file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br></pre></td></tr></table></figure><p>启动类无变更。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboZooKeeperServiceIntrospectionConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboZooKeeperServiceIntrospectionConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-servlet容器-servlet-container-samples"><a href="#3-6-servlet容器-servlet-container-samples" class="headerlink" title="3.6 servlet容器 servlet-container-samples"></a><strong>3.6 servlet容器 servlet-container-samples</strong></h3><p>服务提供者也开放了服务的直接访问接口。</p><h4 id="（1）provider-3"><a href="#（1）provider-3" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-spring-boot-servlet-container-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=23456</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=N/A</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现无变更。</p><p>启动类增加了服务接口，配置了 <code>WebApplicationType</code> ，表示应用是基于Servlet的Web程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServletContainerProviderBootstrap</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/say/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Run as the generic Spring Boot Web(Servlet) Application</span></span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(DubboServletContainerProviderBootstrap.class);</span><br><span class="line">        application.setWebApplicationType(WebApplicationType.SERVLET);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）consumer-3"><a href="#（2）consumer-3" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>配置无变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-servlet-container-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line">    url: dubbo://127.0.0.1:23456</span><br></pre></td></tr></table></figure><p>启动类开放GET访问接口，通过读取配置文件地址直接远程调用客户端（服务提供者）服务实现，同样设置了 <code>WebApplicationType</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServletContainerConsumerBootstrap</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>, url = <span class="string">"$&#123;demo.service.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/say-hello"</span>, method = GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Run as the generic Spring Boot Web(Servlet) Application</span></span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(DubboServletContainerConsumerBootstrap.class);</span><br><span class="line">        application.setWebApplicationType(WebApplicationType.SERVLET);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="http://dubbo.apache.org/zh-cn/docs/user/dependencies.html" target="_blank" rel="noopener">Dubbo官网-文档</a></p></blockquote><blockquote><p>尚硅谷-dubbo</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习Dubbo，第二章《注册中心和监控中心》，并跑了一下Dubbo Spring Boot的示例。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="dubbo" scheme="http://linyishui.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>文档编辑器（持续更新）</title>
    <link href="http://linyishui.top/2020090601.html"/>
    <id>http://linyishui.top/2020090601.html</id>
    <published>2020-09-06T11:05:38.000Z</published>
    <updated>2020-09-06T11:53:20.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文档编辑器"><a href="#文档编辑器" class="headerlink" title="文档编辑器"></a><strong>文档编辑器</strong></h1><h3 id="MarkDown工具"><a href="#MarkDown工具" class="headerlink" title="MarkDown工具"></a><strong>MarkDown工具</strong></h3><p>记录一下日常使用过的md工具，一般都是用来写博客和日记，办公反而很少用到。</p><h4 id="（1）VSCode"><a href="#（1）VSCode" class="headerlink" title="（1）VSCode"></a><strong>（1）VSCode</strong></h4><p>最开始使用VSCode来编辑MarkDown文档，优点是大部分程序员都已经有了这个工具，不用再下载。</p><p>但早期写博客时，总感觉效率上还有所欠缺，因为VSCode的定位是一个文本编辑器，而不是富文本编辑器，所以不能像一些Markdown编辑器一样，获得所见即所得的体验。</p><p>所以在文档内容比较长时，就很难快速定位到想要修改的内容。</p><h4 id="（2）Typora"><a href="#（2）Typora" class="headerlink" title="（2）Typora"></a><strong>（2）Typora</strong></h4><p>因为我要整理的文档内容越来越长，所以如何提高写作效率成为我需要考虑的一个问题。我换用了正规的Markdown编辑器——Typora，它能让我像写Word一样的直接在效果页面写作，常用的MarkDown格式也很方便生成，并且支持多种格式的导入导出。</p><p>很长一段时间，我都在使用Typora作为写作工具。</p><p>推荐插件：</p><ul><li>Typora：<ul><li>VLOOK</li></ul></li></ul><p>但最近发现Typora经常会有一些莫名其妙的BUG，并且在文档超过2MB左右就会限制无法打开，这逼迫我必须再寻找一个工具来代替Typora。</p><h4 id="（3）MarkText"><a href="#（3）MarkText" class="headerlink" title="（3）MarkText"></a><strong>（3）MarkText</strong></h4><p>虽然没有文件大小限制，但非常卡顿，切换源码格式直接卡崩溃了，弃用。</p><p>无奈，先用VSCode来处理大文件，平时还继续用Typora。</p><h4 id="（4）VSCode插件"><a href="#（4）VSCode插件" class="headerlink" title="（4）VSCode插件"></a><strong>（4）VSCode插件</strong></h4><p>推荐插件：</p><ul><li>VSCode：<ul><li>Markdown All in One</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      简单整理工作和学习时常用的文档编辑器，持续更新中。
    
    </summary>
    
      <category term="实用工具" scheme="http://linyishui.top/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="tools" scheme="http://linyishui.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（四）第一天即开口</title>
    <link href="http://linyishui.top/2020090503.html"/>
    <id>http://linyishui.top/2020090503.html</id>
    <published>2020-09-05T13:28:52.000Z</published>
    <updated>2020-09-07T10:38:16.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一天即开口"><a href="#第一天即开口" class="headerlink" title="第一天即开口"></a><strong>第一天即开口</strong></h1><h3 id="词汇量不够怎么办"><a href="#词汇量不够怎么办" class="headerlink" title="词汇量不够怎么办"></a><strong>词汇量不够怎么办</strong></h3><p>当你作为初学者，要在第一天开口说外语时，你的第一反应是：“我还什么词都不会呢！”最初的一对一交流并不需要你说出几千个单词，可能你只需要掌握能够应对两三个问题的单词，感受一下说出这门语言是什么样子就够了。</p><h3 id="最初几小时"><a href="#最初几小时" class="headerlink" title="最初几小时"></a><strong>最初几小时</strong></h3><p>为第一次交谈做准备：</p><ul><li>选择一个正在使用目标语言的人，或是你觉得作为语言联系的搭档也许不错的人。</li><li>社交软件或邮件约一个具体时间。</li><li>通过线上方式用所学语言进行交流。</li></ul><p>几个小时的准备工作：</p><ul><li>可以看一些旅行常用语一类的书。</li><li>通过免费的资源学习一些常用语：<ul><li>How are you?</li><li>What`s your name?</li><li>My name is …</li><li>I don`t understand.</li><li>Could you repeat that / Again, please.</li><li>Can you speak slower please.</li><li>What does that/… mean?</li></ul></li><li>采用关键词记忆法来记住单词或固定词组：<ul><li>Yes、NO</li><li>Please、Thank you</li><li>Hello</li><li>Good Bye</li></ul></li></ul><h3 id="有不会的词就作个小弊"><a href="#有不会的词就作个小弊" class="headerlink" title="有不会的词就作个小弊"></a><strong>有不会的词就作个小弊</strong></h3><p>虽然你的初次对话可能只持续了10秒或20秒，但你可以回归书本或笔记，回想你想说但不会说的内容，把这些短语做成学习卡，然后学会它们。</p><p>你可以随身带一个小本子，列出你想说的内容以及还未掌握好的偏难词汇。</p><h3 id="改变措辞：让交谈简单直接"><a href="#改变措辞：让交谈简单直接" class="headerlink" title="改变措辞：让交谈简单直接"></a><strong>改变措辞：让交谈简单直接</strong></h3><p>初学者会很快学会一件事：<strong>在脑海中用母语组织好想表达的内容，然后再翻译成目标语言</strong>。但如果你想达到真正流利的水准，<strong>这个多余的步骤会把你的速度拖慢很多。</strong>当然作为初学者，这是可以容忍的。</p><p>比如你聊到未来的计划，你本来打算说:”I will travel to Spain in July for a two-week vacation.”。然而你突然意识到你不会用将来时，忘记了”travel to”（去旅行），甚至想不起”July”和”vacation”对应单词。</p><p>如果你是传统型的语言学习者，你应该会放弃了，接受自己还未“准备好”的事实。但执着于交流而不是表达准确性的人会考虑改换措辞，运用其他词汇来传达同样的意思。</p><p>为了省去动词将来时词形变化的烦恼，很多语言都有一个很便捷的特征：动词不定式跟在情态动词之后。比如”want”、”need”、”would like”、”should”、”may”、”can”这样的词的一般现在时形式与”I”连用，如”I want”、”I can”，后面就可以按词典上列出的不定式形式来使用你想用的重要动词”to travel”。想想”I want to travel”和”I will travel”的区别，虽然很重要，但对于表达意思又没那么重要了。你可能不知道”travel”这个词，但可以用”go”来代替。</p><p>所以上述句子可以转换为”I want to go to Spain this summer to be a tourist for two weeks”。</p><h3 id="最初几天"><a href="#最初几天" class="headerlink" title="最初几天"></a><strong>最初几天</strong></h3><p><strong>反馈至关重要。</strong>重复你在以前的谈话中说过的内容，每次都更加自信的说出来。准备你自己的“演讲稿”，在早期这种可预测的模板是可以接受的，当然以后的阶段就不太适用了。</p><h3 id="运用分类体系来管理学到的内容"><a href="#运用分类体系来管理学到的内容" class="headerlink" title="运用分类体系来管理学到的内容"></a><strong>运用分类体系来管理学到的内容</strong></h3><p>致力于语言交流和应试或顺畅阅读的学习者不同，前者所有的努力都指向同一个目标：在下一次会话中表现的更出色一些。</p><p>偶尔回归传统的语言课程，尤其是和一些聚焦口语的课程相比更能满足你自身学习需求的课程。在解决了“说”这个难题后，就可以尽量遵循课程建议进行学习。如果课程中的内容不适合现在的你学习，请跳过它。比如你可能要学习游客常见口语，但对于正在家中自学的你来说并不是最想学的内容，你可能只想问你的对话搭档今天做了什么。</p><h3 id="我不明白对方的回复"><a href="#我不明白对方的回复" class="headerlink" title="我不明白对方的回复"></a><strong>我不明白对方的回复</strong></h3><p>早期交流中，你听到的大部分内容似乎都是难以理解的。完全的理解整段话语内容在早期阶段并不合适，提取别人讲话中你能听懂的词汇或片段，由此推断对方在说什么。</p><p>不要抱定“我不懂”的想法不放，根据语境去猜测对方的内容，并进行合理的回复。</p><h3 id="作者的两小时波兰语经历"><a href="#作者的两小时波兰语经历" class="headerlink" title="作者的两小时波兰语经历"></a><strong>作者的两小时波兰语经历</strong></h3><p>作者曾因要做演讲而进行过一次两个小时的波兰语Skype学习：</p><ul><li>使用常用语手册学习一些初次会话的基础词汇：<ul><li>“I just started learning Polish”</li><li>“I am going to Poland soon”</li></ul></li><li>用电子词典查好交流要用的词汇。</li><li>在屏幕上打开一个文本文档，在上面记录可能记不住的词，准备几十个这样的词。</li><li>当对方说出一个你不会的词时，请他在聊天窗口打出来，复制下来并抽空学习。</li></ul><p>在这次半个小时的对话中，作者坚持一直使用波兰语，虽然很多次弄不懂对方说什么，自己也说不出一些简单的内容，这种不完美的感觉会一直伴随着学习的过程。</p><p>建议用两周的时间来学习一下世界语，有研究表明学习一年世界语再学一年法语的学生比直接学习两年法语的学生更有优势。</p><p>世界语的设计很简单，可以让你在很短的时间掌握好它，克服了第一门外语的难关后，你再次学习其他外语会简单很多。</p><h3 id="尽早开始全程目标语交流"><a href="#尽早开始全程目标语交流" class="headerlink" title="尽早开始全程目标语交流"></a><strong>尽早开始全程目标语交流</strong></h3><p>传统的学习方法会用你的母语教你这门语言怎么运作，整个学习过程你都在仔细的剖析目标语的语法和词汇。语言作为交流的手段，从一开始就应该是被使用的。</p><p><strong>你需要培养用目标语思考的习惯。</strong></p><p>在会话中使用其他语言只会拖慢你前进的步伐，关键就是要尽早下定决心，只要你能容忍较长的停顿和不断的查找单词，即使从第一天开口对话也是能做到的。</p><h3 id="对方用你的母语回复怎么办"><a href="#对方用你的母语回复怎么办" class="headerlink" title="对方用你的母语回复怎么办"></a><strong>对方用你的母语回复怎么办</strong></h3><p>好的老师或拍档应该只把母语最终手段来使用，请尽可能用一些手段来作为回报，让对方能尽量使用目标语来对话，指出你是为了学习这门语言而在努力，如果无法得到好的结果，就选择和其他人交谈吧。</p><h3 id="杰克-·-斯帕罗法则：避免因迟疑而耗费时间"><a href="#杰克-·-斯帕罗法则：避免因迟疑而耗费时间" class="headerlink" title="杰克 · 斯帕罗法则：避免因迟疑而耗费时间"></a><strong>杰克 · 斯帕罗法则：避免因迟疑而耗费时间</strong></h3><p>初学者要面临的一个问题是，你在刚开始对话时只会“嗯嗯啊啊”而不得不中止交谈，这很尴尬。早期对话中，犹豫和迟疑是不可避免的，但我们可以用一些小技巧让这些时刻变得不那么紧张和尴尬。</p><p>在《加勒比海盗》中，杰克 · 斯帕罗船长的肢体语言十分丰富，即使不说话也依然生动鲜活。这种方法可以用来保持对方的注意力，比如你想说”I want to go to the supermarket”，当你说道”go to”时你发现你忘记了超市怎么说，你需要一些时间来想想。这个时候你可以看着对方的眼睛，吸引他的全部注意，然后举起食指指向远方，并且面带沉思的凝望所指向的方向。这时你可以说你想去机场、沙漠……只要稍微练习，你可以把这些停顿运用的更加自然。</p><h3 id="碰杯法则：抛开害羞的想法"><a href="#碰杯法则：抛开害羞的想法" class="headerlink" title="碰杯法则：抛开害羞的想法"></a><strong>碰杯法则：抛开害羞的想法</strong></h3><p>碰杯法则——抛开我很害羞的想法，只要接近那个人跟他问好就是了。</p><h3 id="参与即理解"><a href="#参与即理解" class="headerlink" title="参与即理解"></a><strong>参与即理解</strong></h3><blockquote><p><strong>不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。学至于行而止矣。</strong></p><p>​                                                                                            ——中国谚语</p></blockquote><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（三）如何记单词</title>
    <link href="http://linyishui.top/2020090502.html"/>
    <id>http://linyishui.top/2020090502.html</id>
    <published>2020-09-05T10:03:08.000Z</published>
    <updated>2020-09-05T13:18:33.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何快速记住上千个单词"><a href="#如何快速记住上千个单词" class="headerlink" title="如何快速记住上千个单词"></a><strong>如何快速记住上千个单词</strong></h1><h3 id="为什么我们在学校学到的记忆方法不起作用"><a href="#为什么我们在学校学到的记忆方法不起作用" class="headerlink" title="为什么我们在学校学到的记忆方法不起作用"></a><strong>为什么我们在学校学到的记忆方法不起作用</strong></h3><p>如今我们有了越来越多的信息来源，很多人不再学习、背诵任何东西，因为随时可以Google到。这种情况很令人遗憾，因为我们没有发挥自己大脑的最大潜力。</p><p><strong>信息的重复出现让我们以为自己已经记住了它。</strong>我们在学校时，为了学会一个单词唯一的方法就是死记硬背。经过几十次甚至几百次的重复，你可能会在短期记住它，但能否运用就看运气了。</p><p><strong>与其简单的读出或识别出单词，不如尝试更有效的学习方法。</strong></p><h3 id="两种优秀的记忆方法"><a href="#两种优秀的记忆方法" class="headerlink" title="两种优秀的记忆方法"></a><strong>两种优秀的记忆方法</strong></h3><h4 id="方法一：关键字联想记忆法"><a href="#方法一：关键字联想记忆法" class="headerlink" title="方法一：关键字联想记忆法"></a><strong>方法一：关键字联想记忆法</strong></h4><p>当你要记忆一个单词或句子时，需要构建一个有趣的、栩栩如生的、令人难忘的画面或小故事。</p><p><strong>请自己从认识这个词语的第一印象开始，根据读音想象一个场景或故事。</strong></p><p>刚开始可能每个单词都要花费一两分钟来构思故事，但几天或一周后，你会变得熟练起来。而在三四次回想起故事后，你就可以牢牢记住这个词，以后就可以直接知道其含义。</p><h4 id="方法二：间隔重复记忆法"><a href="#方法二：间隔重复记忆法" class="headerlink" title="方法二：间隔重复记忆法"></a><strong>方法二：间隔重复记忆法</strong></h4><p><strong>通过单词卡和词组卡重新排列来辅助记忆。</strong>将记不住的单词排到前面，已知的单词排在后面。目前很多主流的APP都支持这种记忆法。</p><h3 id="用音乐来学习词组和整句"><a href="#用音乐来学习词组和整句" class="headerlink" title="用音乐来学习词组和整句"></a><strong>用音乐来学习词组和整句</strong></h3><p><strong>从词组和整句来开始学习语言可能效果会比从单词开始要更好。</strong>多使用如“厕所在哪里”、“这个多少钱”这样的常用句子。</p><p>记住这些句子并不容易，几百年来，人们常常通过唱歌来背诵文章。首先可以把句子和关键字记忆法结合，在短句的开头来启发记忆。其次，我们要相处适合的曲调来启发记忆，曲调要简洁，就像大本钟的钟声一样。记住想象越离奇，越有利于记忆。</p><h3 id="1分钟迷你讲话稿"><a href="#1分钟迷你讲话稿" class="headerlink" title="1分钟迷你讲话稿"></a><strong>1分钟迷你讲话稿</strong></h3><p>我们了解了怎样记住单词和词组，接下来就是更难的内容——记住整段文字。</p><p>请准备好陌生人见面的几个基本问题的答案：</p><ol><li>你是哪位？</li><li>你从哪里来？</li><li>你做什么工作？</li><li>你为什么要学这种语言？</li></ol><p>你可以用母语写好稿子，拜托一位以所学语言为母语的人帮忙准确的翻译它，或者从书上或网上找到地道的表述，请不要背电脑翻译或自己翻译的句子。</p><p>为每个问题都准备一张卡片，并用记忆法记住每个句子开头的单词和音节，再为每个句子找到一个调子或歌曲。</p><h3 id="单词就是你的武器"><a href="#单词就是你的武器" class="headerlink" title="单词就是你的武器"></a><strong>单词就是你的武器</strong></h3><blockquote><p><strong>不求与人相比，只求突破自己。</strong></p><p>​                                                ——嘉纳治五郎，柔道创始人</p></blockquote><p>学习语言的每一天，你的词汇量都在增加，同时你的沟通能力也会得到提升。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（二）计划</title>
    <link href="http://linyishui.top/2020090501.html"/>
    <id>http://linyishui.top/2020090501.html</id>
    <published>2020-09-05T09:02:28.000Z</published>
    <updated>2020-09-05T13:16:28.061Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a><strong>计划</strong></h1><h3 id="设定一个具体化的目标"><a href="#设定一个具体化的目标" class="headerlink" title="设定一个具体化的目标"></a><strong>设定一个具体化的目标</strong></h3><p><strong>如何定义“流利”这个词语？</strong>牛津字典上的定义：流利，形容词，可准确、自如地表达自己的想法。</p><p>请不要错误的把目标定位外语要达到母语的水平。欧洲几个主要的语言测试组织所使用的一套科学、成熟的语言入门标准——《欧洲共同语言参考标准》（Common European Framework of Reference for Languages，CEFRL系统）定义了三个等级：“A”表示初级水平，“B”表示中级，“C”代表高级。每个等级又分“1”（较差）和“2”（较好）两种程度。</p><p>A级水平就是常说的具有基本语言能力的游客水平，可以进行基础的对话交流。C级水平意味着已经掌握了这门语言，能够达到母语使用者的水平。</p><p><strong>我们将B2及以上的水平定位为流利，能够流利地、自然地以该种语言为母语的人经常进行交流，对于双方而言，这种交流都毫无阻碍。</strong></p><h3 id="达到流利需要多长时间"><a href="#达到流利需要多长时间" class="headerlink" title="达到流利需要多长时间"></a><strong>达到流利需要多长时间</strong></h3><p>作者推荐是3个月内先达到基本对话的水平（B1），高强度的语言学习计划需要绝对的集中和专心，即使你是全职工作，也要挤出时间，每天学几小时。<strong>如果你想要迅速的进步，每天至少两个小时的语言学习是必不可少的。</strong>如果你只能每周投入几个小时，那你没有可能在3个月就掌握流利的外语。</p><p>即使你的期限不是3个月、6个月，也请尽量将一年分成更小的、更可控的多个时间段。</p><h3 id="总是朝着更高一级的目标努力"><a href="#总是朝着更高一级的目标努力" class="headerlink" title="总是朝着更高一级的目标努力"></a><strong>总是朝着更高一级的目标努力</strong></h3><p>只要能和其他人交流，你的语言学习就不算失败。但是，<strong>注意不要用“任何一个小进步都是成功”来纵容自己的懒惰。一定要把自己推出“舒适地带”，如果你设定的目标是你百分百能达到的，说明你的目标还是太低了。</strong></p><h3 id="迷你任务：逼自己离开舒适区"><a href="#迷你任务：逼自己离开舒适区" class="headerlink" title="迷你任务：逼自己离开舒适区"></a><strong>迷你任务：逼自己离开舒适区</strong></h3><p>在语言学习的某个特定时期，你会遇到一些具体问题，“迷你任务”可以帮你尽快解决它们。</p><p>在作者刚开始学汉语时，因为语调不对，别人完全不能听懂他的话。所以他只关注语调，不去管词汇和阅读等问题。一周后，人们可以稍微听懂他的一点话了，之后才开始了基本词汇的学习。</p><p>第二周，作者最大的问题是过度依赖词汇书，所以练习自发的说话变成了迷你任务。很快他也能不看书的去说一些词汇了。</p><p>这种迷你任务可以给你一种真实的、辛苦得来的成就感和进步感，使你集中精力应对问题直到解决它们。比如作者学习汉语时没有给自己设定每周的词汇任务，而是每天看60张词汇卡片，卡片上的词汇都是关于怎样点菜的。</p><p>一个月后，作者达到了瓶颈期，可以凭借记忆进行简单的交谈，语调也还可以。但这些交谈只能持续10~15秒，不算是真正的交谈。所以他开始一个新的迷你任务——提升思维速度的“大脑融合”。“大脑融合”强迫你快速思维，根据听到的信息进行推断、搜索词汇的意思，同时根据语境来理解语言的含义。所以他约了汉语母语的朋友来进行一个小时以上的对话。</p><p>迷你任务的目的就是逼迫自己离开舒适区，从而不断升级、挺过艰难的学习阶段。</p><h3 id="倦怠是放弃语言学习的主要原因之一"><a href="#倦怠是放弃语言学习的主要原因之一" class="headerlink" title="倦怠是放弃语言学习的主要原因之一"></a><strong>倦怠是放弃语言学习的主要原因之一</strong></h3><p>如果整个学习过程都充满了“大脑融合”任务，你可能很快会倦怠。适当的休息，在这段时间忘记语言学习，可能会有效的帮助到你。</p><h3 id="制订行动计划"><a href="#制订行动计划" class="headerlink" title="制订行动计划"></a><strong>制订行动计划</strong></h3><p>没有付诸实践，任何好主意都一文不值。请记住以下几点：</p><ul><li>设定稍高的目标。</li><li>设定具体的期限。</li><li>集中学习语言时，使用迷你任务去专注解决眼前的最大问题。</li><li>如果你的全部时间都用来学习，就要保证休息，不要把自己搞得精疲力竭。</li><li>向外界展示你的学习任务，让朋友和家人监督你。</li></ul><h3 id="我的计划"><a href="#我的计划" class="headerlink" title="我的计划"></a><strong>我的计划</strong></h3><p>因为我最近刚好处于择业期，而且技术上有很多短板需要补齐，所以主要学习内容还是专业技术，语言则作为另一项同时进行的学习任务。</p><p><strong>我会把学习周期定为6个月，每天一个小时的语言学习时间。</strong>也就是明年3到4月份验收成果。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>职业规划</title>
    <link href="http://linyishui.top/2020090401.html"/>
    <id>http://linyishui.top/2020090401.html</id>
    <published>2020-09-04T06:28:26.000Z</published>
    <updated>2020-09-04T08:05:56.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a><strong>职业规划</strong></h1><h2 id="岗位选择"><a href="#岗位选择" class="headerlink" title="岗位选择"></a><strong>岗位选择</strong></h2><p>目前情况：Java后端开发，2年工作经验。</p><p>一年后：Java后端 / 大数据开发 ，3年工作经验</p><h2 id="设定目标"><a href="#设定目标" class="headerlink" title="设定目标"></a><strong>设定目标</strong></h2><p>统计岗位薪酬数据：</p><table><thead><tr><th>Java</th><th>北京</th><th>上海</th><th>杭州</th></tr></thead><tbody><tr><td>1-3年年收入-10分位</td><td>79.948</td><td>76.488</td><td>71.014</td></tr><tr><td>1-3年年收入-25分位</td><td>106.167</td><td>100.479</td><td>94.989</td></tr><tr><td>1-3年年收入-50分位</td><td>146.831</td><td>137.871</td><td>130.364</td></tr><tr><td>1-3年年收入-75分位</td><td>208.853</td><td>186.494</td><td>181.281</td></tr><tr><td>1-3年年收入-90分位</td><td>287.424</td><td>251.109</td><td>247.048</td></tr><tr><td>1-3年月平均收入和人数占比</td><td>13.904/19%</td><td>12.900/22%</td><td>12.608/32%</td></tr><tr><td>3-5年月平均收入和人数占比</td><td>18.544/56%</td><td>17.661/56%</td><td>18.103/55%</td></tr><tr><td>5-10年月平均收入和人数占比</td><td>25.207/24%</td><td>24.766/21%</td><td>24.068/12%</td></tr><tr><td>人数样本</td><td>4162601</td><td>2270467</td><td>1604825</td></tr></tbody></table><p><em>数据来源：Boss直聘</em></p><p>设定岗位筛选条件：3-5年经验，20k以上。</p><h2 id="统计要求"><a href="#统计要求" class="headerlink" title="统计要求"></a><strong>统计要求</strong></h2><table><thead><tr><th>要求</th><th>子项</th><th>掌握程度</th><th>次数</th></tr></thead><tbody><tr><td>工龄</td><td>3年</td><td></td><td>12</td></tr><tr><td>学历</td><td>本科</td><td></td><td>7</td></tr><tr><td>Java</td><td>基础</td><td>基础扎实，JDK源码，多态</td><td>11</td></tr><tr><td></td><td>IO</td><td></td><td>5</td></tr><tr><td></td><td>并发/多线程</td><td></td><td>6</td></tr><tr><td></td><td>集合</td><td></td><td>4</td></tr><tr><td></td><td>JVM</td><td>了解原理</td><td>5</td></tr><tr><td></td><td>网络编程</td><td></td><td>2</td></tr><tr><td>Web框架</td><td>Web开发</td><td>深入了解底层实现</td><td>9</td></tr><tr><td></td><td>Spring</td><td></td><td>8</td></tr><tr><td></td><td>SpringMVC</td><td></td><td>2</td></tr><tr><td></td><td>SpringBoot</td><td></td><td>5</td></tr><tr><td>ORM</td><td>Mybatis</td><td>深入了解底层实现</td><td>7</td></tr><tr><td>数据库</td><td>任一</td><td>熟悉数据库优化</td><td>10</td></tr><tr><td></td><td>Mysql</td><td></td><td>8</td></tr><tr><td></td><td>Oracle</td><td></td><td>4</td></tr><tr><td></td><td>db2</td><td></td><td>2</td></tr><tr><td></td><td>sql优化</td><td></td><td>1</td></tr><tr><td>分布式系统</td><td>项目</td><td>熟悉设计和应用</td><td>6</td></tr><tr><td></td><td>监控、部署</td><td></td><td>1</td></tr><tr><td></td><td>负载均衡</td><td></td><td>1</td></tr><tr><td>分布式缓存</td><td>任一</td><td>熟练使用，优化</td><td>9</td></tr><tr><td></td><td>Redis</td><td></td><td>6</td></tr><tr><td></td><td>Memcache</td><td></td><td>2</td></tr><tr><td></td><td>MongoDB</td><td></td><td>2</td></tr><tr><td></td><td>Hbase</td><td></td><td>1</td></tr><tr><td>消息队列</td><td>任一</td><td>熟悉解决方案及应用场景</td><td>9</td></tr><tr><td></td><td>RabbitMQ</td><td></td><td>4</td></tr><tr><td></td><td>ActiveMQ</td><td></td><td>1</td></tr><tr><td></td><td>Kafka</td><td></td><td>2</td></tr><tr><td>Web服务器</td><td>Nginx</td><td>优化配置与使用</td><td>2</td></tr><tr><td></td><td>Tomcat</td><td></td><td>2</td></tr><tr><td></td><td>缓存服务器</td><td></td><td>1</td></tr><tr><td>中间件</td><td>Elasticsearch</td><td>使用和原理</td><td>1</td></tr><tr><td>UML</td><td></td><td>熟悉</td><td>1</td></tr><tr><td>设计模式</td><td></td><td>了解</td><td>1</td></tr><tr><td>微服务</td><td>任一</td><td></td><td>5</td></tr><tr><td></td><td>Dubbo</td><td></td><td>3</td></tr><tr><td></td><td>Spring Cloud</td><td></td><td>2</td></tr><tr><td>工具</td><td>Docker</td><td>熟练掌握</td><td>1</td></tr><tr><td></td><td>K8s</td><td></td><td>1</td></tr><tr><td></td><td>Linux</td><td>熟悉操作，有Linux环境下多线程、并发、网络编程经验，常用命令</td><td>2</td></tr><tr><td>脚本语言</td><td>任一</td><td>熟悉</td><td>2</td></tr><tr><td></td><td>shell</td><td></td><td>2</td></tr><tr><td></td><td>php</td><td></td><td>1</td></tr><tr><td></td><td>python</td><td></td><td>1</td></tr><tr><td>前端</td><td>JS</td><td></td><td>2</td></tr><tr><td></td><td>Jquery</td><td></td><td>2</td></tr><tr><td></td><td>VUE</td><td></td><td>2</td></tr><tr><td>网络</td><td>基础</td><td></td><td>1</td></tr><tr><td></td><td>TCP/IP</td><td>原理</td><td>1</td></tr><tr><td>开源项目</td><td></td><td>有经验</td><td>2</td></tr><tr><td>高并发、高负载、高可用</td><td></td><td>设计和开发，优先</td><td>7</td></tr><tr><td>分布式队列</td><td></td><td>优先</td><td>1</td></tr><tr><td>分布式任务分发框架</td><td></td><td>优先</td><td>1</td></tr><tr><td>全文检索及分词</td><td></td><td>优先</td><td>1</td></tr><tr><td>海量数据存储和处理</td><td></td><td>优先</td><td>4</td></tr><tr><td>分布式存储</td><td></td><td>优先</td><td>1</td></tr><tr><td>Flink、Clickhouse</td><td></td><td>优先</td><td>1</td></tr><tr><td>Java EE、SOA、OSGI、jax-rs</td><td></td><td>熟悉相关技术</td><td>1</td></tr></tbody></table><h2 id="简单规划"><a href="#简单规划" class="headerlink" title="简单规划"></a><strong>简单规划</strong></h2><p>根据岗位要求进行简单规划，先学陌生的技术，再补不足。</p><p>需要学会和精通的技术：</p><ul><li>Java、集合、多线程、并发编程、网络编程、JVM、IO、NIO</li><li>Spring、Spring MVC、Spring Boot</li><li>MyBatis、MySql、Redis、RabbitMQ、ELK</li><li>Dubbo、Zookeeper 、Spring Cloud</li><li>Linux、Docker、k8s、shell</li><li>网络、操作系统、分布式系统、海量数据处理</li></ul><p>将以上内容补充到《<a href="../2018080801.html" title="Title">Java技术栈-学习路线</a>》。</p><p>最后罗列一下学习的优先级：</p><ul><li><p>需要系统学习：Mysql -&gt; RabbitMQ -&gt; Zookeeper + Dubbo -&gt; Spring Cloud -&gt; Redis</p></li><li><p>只要实战学习：MyBatis -&gt; ELK -&gt; Linux + shell -&gt; Docker -&gt; k8s</p></li></ul>]]></content>
    
    <summary type="html">
    
      简单整理一下Java职场信息，为自己设定一个一年后的目标。
    
    </summary>
    
      <category term="笔记杂谈" scheme="http://linyishui.top/categories/%E7%AC%94%E8%AE%B0%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="other" scheme="http://linyishui.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习dubbo（一）简介和搭建</title>
    <link href="http://linyishui.top/2020090301.html"/>
    <id>http://linyishui.top/2020090301.html</id>
    <published>2020-09-03T06:12:39.000Z</published>
    <updated>2020-09-08T09:47:43.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo（一）简介和搭建"><a href="#dubbo（一）简介和搭建" class="headerlink" title="dubbo（一）简介和搭建"></a><strong>dubbo（一）简介和搭建</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a><strong>1.1 背景</strong></h3><p>网站规模的扩大，技术架构经历了从<strong>单一应用架构</strong>到<strong>垂直应用架构</strong>，最后到<strong>分布式服务架构</strong>和<strong>流动计算架构</strong>的发展历程。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-roadmap.jpg" alt></p><ul><li><strong>单一应用架构</strong>：当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<ul><li>适合小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</li><li>缺点：<ul><li>性能扩展比较难</li><li>协同开发问题</li><li>不利于升级维护</li></ul></li></ul></li><li><strong>垂直应用架构</strong>：当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。<ul><li>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</li><li>缺点： 公用模块无法重复利用，开发性的浪费。</li></ul></li><li><strong>分布式服务架构</strong>：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架</strong>(RPC)是关键。</li><li><strong>流动计算架构</strong>：当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong>。</li></ul><p>分布式系统中每个功能模块之间有复杂的联系，需要有一个<strong>治理系统</strong>确保架构有条不紊的演进。</p><h3 id="1-2-RPC和RMI"><a href="#1-2-RPC和RMI" class="headerlink" title="1.2 RPC和RMI"></a><strong>1.2 RPC和RMI</strong></h3><p>RPC是指Remote Procedure Call Protocol，<strong>远程过程调用协议</strong>，是一种进程间通信方式。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>常见的开源框架包括：</p><ul><li><p>单语言：</p><ul><li><p><strong>RMI</strong>：Java RMI （Remote Method Invocation）- 远程方法调用，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化，能够<strong>让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法</strong>。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过<strong>依赖接口</strong>这种更简单自然的方式。</p></li><li><p><strong>Dubbo</strong>：阿里巴巴开发，只支持Java。</p></li><li><strong>Motan</strong>：微博开发，只支持Java。</li><li><strong>Tars</strong>：腾讯开发，只支持C++。</li><li><strong>Spring Cloud</strong>：Pivotal开发，只支持Java。</li></ul></li><li><p>跨语言：</p><ul><li><p><strong>gRPC</strong>：Google开发。</p></li><li><p><strong>Thrift</strong>：Facebook开发，它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的<a href="https://zh.wikipedia.org/wiki/跨平台" target="_blank" rel="noopener">跨平台</a>高效服务。以前是由Facebook开发的，但它现在是<a href="https://zh.wikipedia.org/wiki/Apache软件基金会" target="_blank" rel="noopener">Apache软件基金会</a>的开源项目了。</p></li><li><p><strong>Avro</strong>：一种远程过程调用和数据序列化框架，是在Apache的Hadoop项目之内开发的。它使用JSON来定义数据类型和通讯协议，使用压缩二进制格式来序列化数据。它主要用于Hadoop，它可以为持久化数据提供一种序列化格式，并为Hadoop节点间及从客户端程序到Hadoop服务的通讯提供一种电报格式。</p><p>它类似于Thrift，但当数据库模式改变时，它不要求运行代码生成程序，除非是对静态类型的语言。</p></li></ul></li></ul><h4 id="（1）RMI工作原理"><a href="#（1）RMI工作原理" class="headerlink" title="（1）RMI工作原理"></a><strong>（1）RMI工作原理</strong></h4><ol><li>服务端向 RMI 注册服务绑定自己的地址，</li><li>客户端通过 RMI 注册服务获取目标地址，</li><li>客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致，</li><li>本地存根对象将调用信息打包，通过网络发送到服务端，</li><li>服务端的 Skeleton 对象收到网络请求之后，将调用信息解包，</li><li>然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。</li></ol><p>服务之间的远程调用有两个关键部分：</p><ul><li>服务间通信：客户端与服务端要建立网络连接，并传递数据。所以通信效率决定着RPC框架的性能（如传递二进制流要快于XML或JSON）</li><li>对象序列化与反序列化：参数对象在网络中传递要进行序列化，接收到后要反序列化解析。所以序列化效率也决定着RPC框架的性能。</li></ul><h4 id="（2）RMI基本概念"><a href="#（2）RMI基本概念" class="headerlink" title="（2）RMI基本概念"></a><strong>（2）RMI基本概念</strong></h4><ol><li>通过<strong>接口</strong>进行远程调用：客户端需要依赖接口，而服务端需要提供该接口的实现。</li><li>通过客户端的 <strong>Stub 对象</strong>和服务端的 <strong>Skeleton 对象</strong>的帮助将远程调用伪装成本地调用：在 J2SE 1.5 版本之前需要通过 rmic 预先编译好客户端的 Stub 对象和服务端的 Skeleton 对象。在之后的版本中，不再需要事先生成 Stub 和 Skeleton 对象。</li><li>通过 <strong>RMI 注册服务</strong>完成服务的注册和发现。</li></ol><p>服务端注册方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化服务对象实例</span></span><br><span class="line">Hello obj = <span class="keyword">new</span> HelloImpl(); </span><br><span class="line"><span class="comment">// 生成可以与服务端通讯的 Stub 对象</span></span><br><span class="line">Hello stub = (Hello) UnicastRemoteObject.exportObject(obj, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// 创建一个本地的 RMI 注册服务，监听端口为 1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程</span></span><br><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>); </span><br><span class="line"><span class="comment">// 将 Stub 对象绑定到注册服务上，这样，客户端可以通过 *Hello* 这个名字查找到该远程对象</span></span><br><span class="line">registry.rebind(<span class="string">"Hello"</span>, stub);</span><br></pre></td></tr></table></figure><p>客户端的服务发现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取注册服务实例，在本例中，由于没有传入任何参数，假定要获取的注册服务实例部署在本机，并监听在 1099 端口上</span></span><br><span class="line">Registry registry = LocateRegistry.getRegistry();</span><br><span class="line"><span class="comment">// 从注册服务中查找服务名为 *Hello* 的远程对象</span></span><br><span class="line">Hello stub = (Hello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 通过获取的 Stub 对象发起一次 RMI 调用并获得结果</span></span><br><span class="line">String response = stub.sayHello();</span><br></pre></td></tr></table></figure><h3 id="1-3-为什么需要Dubbo？"><a href="#1-3-为什么需要Dubbo？" class="headerlink" title="1.3 为什么需要Dubbo？"></a><strong>1.3 为什么需要Dubbo？</strong></h3><p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p><p><strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</strong> 此时<strong>需要一个服务注册中心（Eureka、Zookeeper），动态地注册和发现服务，使服务的位置透明</strong>。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p><p><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。</p><p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-service-governance.jpg" alt></p><p>dubbo的核心特性：</p><ul><li><strong>远程方法调用</strong>：面向接口代理的高性能RPC调用，使用时只需调用接口即可。</li><li><strong>智能负载均衡</strong>：同一个服务可能有多台服务器在运行，每台服务器有不同的工作状态，负载均衡会尽量的挑选休闲的服务器。</li><li><strong>服务自动注册和发现</strong>：所有服务都要注册到中心，中心负责管理所有服务的生命周期，服务部署在哪些服务器这些信息可以在中心获取。</li><li><strong>高度可扩展</strong>：遵循微内核和插件的设计原则，核心功能如Protocol、Transport、Serialization都被设计为扩展点，同等对待内置实现和第三方实现。</li><li><strong>运行期流量调度</strong>：内置条件、脚本等路由策略，通过配置不同的路由规则，实现灰度发布、同机房优先等功能。</li><li><strong>可视化的服务治理与运维</strong>：提供丰富的服务治理、运维工具：随时查询服务元数据、服务健康状态以及调用统计，实时下发路由策略、调整配置参数。</li></ul><h3 id="1-4-技术架构"><a href="#1-4-技术架构" class="headerlink" title="1.4 技术架构"></a><strong>1.4 技术架构</strong></h3><p>如下图所示，每个节点角色之间的关系，注意只有消费者调用服务是同步，其他都是异步操作。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt="dubbo-architucture"></p><h5 id="节点角色说明"><a href="#节点角色说明" class="headerlink" title="节点角色说明"></a>节点角色说明</h5><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Provider</code></td><td>暴露服务的<strong>服务提供方</strong></td></tr><tr><td><code>Consumer</code></td><td>调用远程服务的<strong>服务消费方</strong></td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的<strong>注册中心</strong></td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的<strong>监控中心</strong></td></tr><tr><td><code>Container</code></td><td><strong>服务运行容器</strong></td></tr></tbody></table><h5 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h5><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。</p><h5 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h5><ul><li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li><li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li><li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li><li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li><li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li><li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li><li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li><li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li></ul><h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ul><h5 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h5><ul><li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li><li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li></ul><h5 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h5><p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-future.jpg" alt="dubbo-architucture-futures"></p><h5 id="节点角色说明-1"><a href="#节点角色说明-1" class="headerlink" title="节点角色说明"></a>节点角色说明</h5><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Deployer</code></td><td>自动部署服务的本地代理</td></tr><tr><td><code>Repository</code></td><td>仓库用于存储服务应用发布包</td></tr><tr><td><code>Scheduler</code></td><td>调度中心基于访问压力自动增减服务提供者</td></tr><tr><td><code>Admin</code></td><td>统一管理控制台</td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的注册中心</td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的监控中心</td></tr></tbody></table><hr><h2 id="第二节-入门"><a href="#第二节-入门" class="headerlink" title="第二节 入门"></a><strong>第二节 入门</strong></h2><p>项目地址：<a href="https://github.com/apache" target="_blank" rel="noopener">apache</a>/<strong><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">dubbo</a></strong></p><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a><strong>2.1 安装</strong></h3><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/dubbo.git</span><br><span class="line"><span class="built_in">cd</span> dubbo/dubbo-demo/dubbo-demo-xml</span><br><span class="line">运行 dubbo-demo-xml-provider中的org.apache.dubbo.demo.provider.Application</span><br><span class="line">如果使用Intellij Idea 请加上-Djava.net.preferIPv4Stack=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resources/spring/dubbo-provider.xml</span><br><span class="line">修改其中的dubbo:registry，替换成真实的注册中心地址，推荐使用zookeeper，如：</span><br><span class="line">&lt;dubbo:registry address=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span><br></pre></td></tr></table></figure><p>通过Idea打开项目，等待依赖下载完毕后按官网教程启动 <code>dubbo-demo-xml-provider</code> 。</p><p>启动失败，报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\WorkPlace\FromGitHub\dubbo-master\dubbo-config\dubbo-config-api\src\<span class="built_in">test</span>\java\org\apache\dubbo\config\bootstrap\rest\UserService.java</span><br><span class="line">Error:(22, 50) java: 程序包org.apache.dubbo.rpc.protocol.rest.support不存在</span><br><span class="line">Error:(37, 12) java: 找不到符号</span><br><span class="line">  符号: 变量 ContentType</span><br><span class="line">Error:(37, 48) java: 找不到符号</span><br><span class="line">  符号: 变量 ContentType</span><br></pre></td></tr></table></figure><p>找到（dubbo-config-api）<code>pom.xml</code> 并注释掉所有Maven的test作用域。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- FIXME, we shouldn't rely on these modules, even in test scope --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-rpc-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启，OK上述错误不再提示，但有了新的错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error:(26, 52) java: 程序包org.apache.dubbo.common.serialize.nativejava不存在</span><br><span class="line">Error:(99, 43) java: 找不到符号</span><br><span class="line">  符号:   类 NativeJavaSerialization</span><br><span class="line">  位置: 类 org.apache.dubbo.rpc.protocol.hessian.HessianProtocolTest</span><br><span class="line">Warning:(110, 59) java: org.apache.dubbo.common.serialize.ObjectInput中的readObject()已过时</span><br></pre></td></tr></table></figure><p>找到（dubbo-rpc-rest）<code>pom.xml</code> 并注释掉test作用域。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-serialization-jdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次启动，OK顺利运行。</p><h3 id="2-2-简单使用"><a href="#2-2-简单使用" class="headerlink" title="2.2 简单使用"></a><strong>2.2 简单使用</strong></h3><h4 id="（1）服务提供者"><a href="#（1）服务提供者" class="headerlink" title="（1）服务提供者"></a><strong>（1）服务提供者</strong></h4><p>找到 <code>dubbo-demo-interface</code> 子项目，其中有定义接口 <code>DemoService.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(sayHello(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到 <code>dubbo-demo-api</code> 子项目，其中有定义接口实现 <code>DemoServiceImpl.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.rpc.RpcContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Hello "</span> + name + <span class="string">", request from consumer: "</span> + RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">", response from provider: "</span> + RpcContext.getContext().getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过Spring的xml配置来将服务暴露，<code>provider.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.demo.provider.DemoServiceImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后在 <code>dubbo-demo-xml-provider</code> 启动类加载Spring配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/dubbo-provider.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）服务消费者"><a href="#（2）服务消费者" class="headerlink" title="（2）服务消费者"></a><strong>（2）服务消费者</strong></h4><p>首先通过 Spring 配置引用远程服务 dubbo-consumer.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer-of-helloworld-app"</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment">  contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment">  this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment">  The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment">  (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment">  the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"mapping-type"</span> <span class="attr">value</span>=<span class="string">"metadata"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"enable-auto-migration"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    &lt;dubbo:metadata-report address="zookeeper://127.0.0.1:2181"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">provided-by</span>=<span class="string">"demo-provider"</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">provided-by</span>=<span class="string">"demo-provider"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">group</span>=<span class="string">"greeting"</span> <span class="attr">id</span>=<span class="string">"greetingService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.GreetingService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后加载Spring配置，并调用远程服务Consumer.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"META-INF/spring/dubbo-demo-consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = (DemoService)context.getBean(<span class="string">"demoService"</span>); <span class="comment">// 获取远程服务代理</span></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// 执行远程方法</span></span><br><span class="line">        System.out.println( hello ); <span class="comment">// 显示调用结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.GreetingService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before</span></span><br><span class="line"><span class="comment">     * launch the application</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/dubbo-consumer.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = context.getBean(<span class="string">"demoService"</span>, DemoService.class);</span><br><span class="line">        GreetingService greetingService = context.getBean(<span class="string">"greetingService"</span>, GreetingService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String greetings = greetingService.hello();</span><br><span class="line">                System.out.println(greetings + <span class="string">" from separated thread."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            CompletableFuture&lt;String&gt; hello = demoService.sayHelloAsync(<span class="string">"world"</span>);</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + hello.get());</span><br><span class="line"></span><br><span class="line">            String greetings = greetingService.hello();</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + greetings);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li>该接口需单独打包，在服务提供方和消费方共享 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref1" target="_blank" rel="noopener">↩︎</a></li><li>对服务消费方隐藏实现 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref2" target="_blank" rel="noopener">↩︎</a></li><li>也可以使用 IoC 注入 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref3" target="_blank" rel="noopener">↩︎</a></li></ol><hr><p>参考：</p><blockquote><p><a href="http://dubbo.apache.org/zh-cn/docs/user/dependencies.html" target="_blank" rel="noopener">Dubbo官网-文档</a></p></blockquote><blockquote><p><a href="http://jm.taobao.org/2018/06/13/%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">第一个 Dubbo 应用</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习Dubbo，第一章《简介和搭建》
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="dubbo" scheme="http://linyishui.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（一）启程</title>
    <link href="http://linyishui.top/2020090101.html"/>
    <id>http://linyishui.top/2020090101.html</id>
    <published>2020-09-01T10:14:30.000Z</published>
    <updated>2020-09-05T13:17:13.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="启程"><a href="#启程" class="headerlink" title="启程"></a><strong>启程</strong></h1><h3 id="为什么要学习英语？"><a href="#为什么要学习英语？" class="headerlink" title="为什么要学习英语？"></a><strong>为什么要学习英语？</strong></h3><p>今天，当我终于下定决心要开始学习英语时，我发现最开始想要学习一门外语到现在已经过去了将近5年的时间。大部分人应该和我一样虽然会觉得自己应该至少学习一门外语，但在思考这个问题时，<strong>总是会想在一个更合适的时间开始学习</strong>。</p><p>在逃避学习的这段时间里，我有时忙于玩乐，有时忙于工作，一直在焦虑和麻木的状态中生活。时间来到这个月，我处于人生中的第二个求职阶段，面试的不顺利和内心的不甘心，让我突然发现，<strong>人生中的大部分时间我都是在被迫学习</strong>：少年时因为要考试而去学习；成年后进入大学，又为了奖学金而短暂学习过；工作后为了更好的岗位和薪水而去强迫自己学习。<strong>我还从来没有因为想要学一个东西而去认真的实现这个想法，这让我意识到不管明天会怎样，我都要从今天开始我的学习计划了</strong>。</p><p>我为自己想了几个学习英语的目的：</p><ul><li>为了和英语世界的人交流，认识更多的朋友。</li><li>不局限于中文环境，去见识和了解到更大范围的世界。</li><li>无障碍的看懂美剧而不用盯着字幕，可以听懂英文歌曲。</li><li>将来有更多的工作机会，以及在其他环境生活的机会。</li><li>增强自信心，提高我对自己的自我评价。</li></ul><p>我首先选择了一本在大学时就收藏的书籍《跟各国人都聊得来-三个月外语流利术》，在开启英语学习之路上，先汲取一下在同样事情上成功的人的经验。</p><hr><h3 id="学习语言的错误观点"><a href="#学习语言的错误观点" class="headerlink" title="学习语言的错误观点"></a><strong>学习语言的错误观点</strong></h3><p><strong>我们为学不会一种语言找的借口往往是对自我的错误认知。</strong></p><h4 id="观点1：年纪太大，不利于学习语言"><a href="#观点1：年纪太大，不利于学习语言" class="headerlink" title="观点1：年纪太大，不利于学习语言"></a>观点1：年纪太大，不利于学习语言</h4><p>这种观点从来没有理论或科学研究的支持，实际上无论学习什么东西，成年人都要比小孩子更有优势，因为我们成年人不是从零开始学习第一语音。根据研究，93%的情感交流都不是通过语言完成的，比如笑也是一种信息的传递方式，成年人不用再花大量时间去学习如何与人交流。</p><p><strong>相比于孩子，成年人要学习的内容更少。</strong>成年人有更多的学习经验应用到学习语言上面，成年人比孩子更有分析力。相反，成年人应该学习孩子不害怕犯错误这一点，享受学习的过程，不要害怕尴尬。</p><h4 id="观点2：我没有学习语言的天赋"><a href="#观点2：我没有学习语言的天赋" class="headerlink" title="观点2：我没有学习语言的天赋"></a>观点2：我没有学习语言的天赋</h4><p>事实上，所有人都有学习语言的天赋，在一些多语种的国家，人们都能在很多语言之间自由的切换，比如卢森堡的学生在毕业时能流利的使用法语、德语、卢森堡语。</p><p>我们在学习刚开始就要抛开这种自我怀疑。</p><h4 id="观点3：我没有时间"><a href="#观点3：我没有时间" class="headerlink" title="观点3：我没有时间"></a>观点3：我没有时间</h4><p>大部分人都有工作要做，这是一个很好的接口。但事实上，大部分学习语言很成功的人都有正式的工作，或是操持家务、照顾家人。</p><p>只要真正的抽出时间去学习，你就能取得进步。比如看电视、浏览各种APP、打游戏等等，这些活动占用了我们大量的时间，甚至还有一些是无意义的活动，还有如等电梯、坐公交车、地铁等。即使是几分钟的时间，用来学习几个单词或日常用语也是足够的。</p><p><strong>当你真正想要学习一门语言时，每一分钟都是可以利用的。</strong></p><p>当然，花几个月的时间去做一件事很不错，但如果没有这个条件，请尽量把能用的时间利用起来，虽然周期会长一些，但你总能达到目标的。</p><h4 id="观点4：学语言是有钱人的专利"><a href="#观点4：学语言是有钱人的专利" class="headerlink" title="观点4：学语言是有钱人的专利"></a>观点4：学语言是有钱人的专利</h4><p>昂贵的课程和学习产品并不比网上的免费工具、博客、以及和外国朋友聊天更有帮助。</p><h4 id="观点5：我在等待完美的语言课程"><a href="#观点5：我在等待完美的语言课程" class="headerlink" title="观点5：我在等待完美的语言课程"></a>观点5：我在等待完美的语言课程</h4><p>没有完美的课程，即使是优秀的语言课程能教给你的东西也是有限的，而且它<strong>并不比你努力学习更有效果</strong>。</p><h4 id="观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败"><a href="#观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败" class="headerlink" title="观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败"></a>观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败</h4><p><strong>最重要的事情是你终于开始学习了</strong>，而早期的错误并没有什么关系。遇到挫折，果断的去解决它，振作精神，重新开始，只要再坚持一下就可以了。</p><p><strong>不要把精力投入到研究哪种学习方法更好，而是把精力投入到学习和使用语言上面。</strong></p><h4 id="观点7：只有学到一定程度，我才能开始练习对话"><a href="#观点7：只有学到一定程度，我才能开始练习对话" class="headerlink" title="观点7：只有学到一定程度，我才能开始练习对话"></a>观点7：只有学到一定程度，我才能开始练习对话</h4><p>事实上，<strong>从学习的第一天开始，你就要尝试去说</strong>。这和传统认知并不相符，<strong>因为你永远不会有准备好的那一天</strong>，哪怕你已经掌握了一门语言，你还是能证明自己没有准备好，单词是永远也学不完的，语法也有很多的学习空间，发音也要更多的练习。</p><p><strong>要从现在就开始尽量去使用自己所学的语言，而不是等待很多年。</strong></p><h4 id="观点8：我不能集中精力"><a href="#观点8：我不能集中精力" class="headerlink" title="观点8：我不能集中精力"></a>观点8：我不能集中精力</h4><p><strong>只专注于眼前的任务，不管有多大的诱惑。</strong>一些优秀的人才也只是把各种兴趣爱好安排好，按照次序一一完成，而不是同时去做很多事情。他们也只是有耐心的、有条理的去做。</p><h4 id="观点9：有些语言太难了"><a href="#观点9：有些语言太难了" class="headerlink" title="观点9：有些语言太难了"></a>观点9：有些语言太难了</h4><p>没有人能在这种无意义的比较中获益，事实上即使是公认的难学习的语种也有很多人在使用它来交流。如果你正在学习一门语言，请忘掉其他学过的语言，集中热情在它上面吧！</p><h4 id="观点10：瓶颈期不可避免"><a href="#观点10：瓶颈期不可避免" class="headerlink" title="观点10：瓶颈期不可避免"></a>观点10：瓶颈期不可避免</h4><p>学习中确实难免遇到瓶颈期，初学者不会遇到此问题，直到有所进步后，比如能够交流后就停滞在那里了。这很可能是我们过往的学习方法在此阶段不再适合了，<strong>“愚蠢”的行为就是一直重复用同样的方法做事，却期望得到不同的结果</strong>。</p><p>不要怕，大胆的改变，改变练习的频率，改变对话的对象。</p><h4 id="观点11：完全掌握是不可能的任务"><a href="#观点11：完全掌握是不可能的任务" class="headerlink" title="观点11：完全掌握是不可能的任务"></a>观点11：完全掌握是不可能的任务</h4><p>如果说学一门语言，就是要用它来辩论各种哲学思想，并且不带一丝口音和停顿的话，那么这确实会花费上数十年。</p><p>但请仔细想想，<strong>你对自己的母语有掌握到什么样的程度，再想想为什么要对一门外语有这样的高要求？</strong></p><p>请把目标放在简单对话，再朝着流利的方向努力。</p><h4 id="观点12：学习过程很枯燥"><a href="#观点12：学习过程很枯燥" class="headerlink" title="观点12：学习过程很枯燥"></a>观点12：学习过程很枯燥</h4><p><strong>语言学习并不枯燥，也许只是你的方法枯燥而已。</strong>比如试试听音乐、看动画片、看电影、读杂志、看笑话。找一个互相帮助的伙伴，或者任何能调动你积极性的方式。</p><h4 id="观点13：当地人不会理我"><a href="#观点13：当地人不会理我" class="headerlink" title="观点13：当地人不会理我"></a>观点13：当地人不会理我</h4><p><strong>请记住，你永远也不会准备好，永远都有要学的东西，所以你可以一直给自己找借口。</strong>这种恶性循环导致很多人学了很多年也不敢开口说话。</p><p>现实中，大家往往会鼓励你、帮助你，会很有耐心和包容。比如你是那个本地人，当你遇到一个尝试努力学习你的母语的外人时，你会有怎样的感受？</p><h4 id="观点14：我总是有口音"><a href="#观点14：我总是有口音" class="headerlink" title="观点14：我总是有口音"></a>观点14：我总是有口音</h4><p>实际上有点口音是好事，这并不影响交流。即使是母语也存在很多发音问题，他们也有各种各样的口音。</p><h4 id="观点15：我的家人朋友不支持我"><a href="#观点15：我的家人朋友不支持我" class="headerlink" title="观点15：我的家人朋友不支持我"></a>观点15：我的家人朋友不支持我</h4><p>这个问题没有很好的解决方法，但你可以尽量的阐述自己很喜欢这门语言，表示出你认真的态度，如果对方能理解也许他们会支持你。</p><p>如果你得不到他们的支持，请相信在这个世界上有很多和你一样怀抱相同梦想的人，你会找到支持和理解的。</p><h4 id="观点16：每个人都说英语-汉语"><a href="#观点16：每个人都说英语-汉语" class="headerlink" title="观点16：每个人都说英语/汉语"></a>观点16：每个人都说英语/汉语</h4><p>学会一门新的语言，并不仅仅意味着你收获了这些知识，它会为你带来新的机会和体验。</p><h4 id="观点17：我跟不上比人的脚步"><a href="#观点17：我跟不上比人的脚步" class="headerlink" title="观点17：我跟不上比人的脚步"></a>观点17：我跟不上比人的脚步</h4><p>把自己和别人作比较这种行为本身就很有问题，但这是人的本性。但你要明白，你看到的只是别人展示给你的一面，他们分享经历时，只会说遇到的各种困难，已显示出其高大的形象。</p><p>遇到困难时，请抛弃“成功的人不会面对这样的问题，我还是放弃吧”这样的想法。而应该问自己“成功的人会怎么解决这个困难呢？”。</p><h4 id="观点18：以前失败，现在还会失败"><a href="#观点18：以前失败，现在还会失败" class="headerlink" title="观点18：以前失败，现在还会失败"></a>观点18：以前失败，现在还会失败</h4><p>如果你以前尝试过学习语言，但最终失败了。你可能会觉得自己不擅长学习语言，但请相信这只能说明过去的方法并不适合你。</p><p><strong>没有一种方法是完美适合每一个语言学习者的。</strong>如果你尝试着某种方法，但根本不起作用，请果断的放弃，并试着换另一种方法。</p><p><strong>请明白失败的并不是你这个人，而是你在用的方法。</strong>请在遇到问题时，多和别人交流，书本并不能解决所有的问题。有可能解决方案在你的已知的知识世界以外，而一个学过的人可以帮你轻松的跨过这个难关。</p><h4 id="观点19：一旦忘了某种语言，我就不可能再重新学会它了"><a href="#观点19：一旦忘了某种语言，我就不可能再重新学会它了" class="headerlink" title="观点19：一旦忘了某种语言，我就不可能再重新学会它了"></a>观点19：一旦忘了某种语言，我就不可能再重新学会它了</h4><p>我们小时候学过的语言，后面没有再学，所以总觉得错过了学习它的最佳机会。但其实只要重新开始努力，你会比初次更顺利的学好这门语言。</p><h4 id="观点20：残障人士学语言比正常人更难"><a href="#观点20：残障人士学语言比正常人更难" class="headerlink" title="观点20：残障人士学语言比正常人更难"></a>观点20：残障人士学语言比正常人更难</h4><p>我们会觉得自己有某种缺陷，在学习语言时会和别人不同。但现实中，很多残疾人士都能很好的克服身体上的缺陷，这些问题在你因为它而止步不前时是难以克服的难关，但请相信在你开始不断尝试之后，总会找到出路的。</p><hr><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a><strong>感受</strong></h3><blockquote><p><strong>不管你觉得自己行或不行，你都是对的。</strong></p><p>​                                                                ——亨利 · 福特</p></blockquote><p>语言学习需要面对挑战，需要付出努力，如果我们确信自己不行，那我们也失去了信心和热情，悲观主义情绪已经占了上风，我们也就注定学不好这种语言了。请大胆的承认失败，不要给自己找没有学好的借口。不管你遇到什么困难，别人都可能遇到过，并且克服过这个困难。</p><p>Benny Lewis的观点很能说动现在的我，好像每个问题都是我曾用来逃避的理由，但还好我现在比起以前有了些许的改变，也许迈出第一步之后，就是焕然一新的自己。</p><p>不仅仅是语言学习，这些常识性的问题在大多数学习场景都是雷同的，我们要克服的是自己的懦弱和懒惰。如果你是一个自命不凡的人，或者只是对现在的自己不够满意，就请不要再浪费时间在准备阶段了，尝试的去做吧。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>大数据量表的优化思路</title>
    <link href="http://linyishui.top/2020082201.html"/>
    <id>http://linyishui.top/2020082201.html</id>
    <published>2020-09-01T05:32:46.000Z</published>
    <updated>2020-09-02T07:19:13.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="大数据量表的优化思路"><a href="#大数据量表的优化思路" class="headerlink" title="大数据量表的优化思路"></a><strong>大数据量表的优化思路</strong></h1><h2 id="第一节-问题描述"><a href="#第一节-问题描述" class="headerlink" title="第一节 问题描述"></a><strong>第一节 问题描述</strong></h2><h2 id="1-1-常见问题"><a href="#1-1-常见问题" class="headerlink" title="1.1 常见问题"></a><strong>1.1 常见问题</strong></h2><ol><li>单表数据量达到千万级别后，查询操作耗时过久。</li><li>针对海量的数据表进行修改操作。</li></ol><h2 id="1-2-MySql模拟"><a href="#1-2-MySql模拟" class="headerlink" title="1.2 MySql模拟"></a><strong>1.2 MySql模拟</strong></h2><p>创建千万条模拟数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#创建MyISAM模式表方便批量跑数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`logs1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`logtype`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logurl`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logip`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logdz`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ladduser`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lfadduser`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`laddtime`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`htmlname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM  AUTO_INCREMENT=<span class="number">1811</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'日志表'</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#创建存储过程</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_insert;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> n <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> in_dateTime <span class="keyword">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="string">'2020-01-01 00:00:00'</span>;</span><br><span class="line">        while n &lt;= 10000000 do</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`logs1`</span>(<span class="string">`logtype`</span>,<span class="string">`logurl`</span>,<span class="string">`logip`</span>,<span class="string">`logdz`</span>,<span class="string">`ladduser`</span> ,<span class="string">`lfadduser`</span>,<span class="string">`laddtime`</span>,<span class="string">`htmlname`</span>) <span class="keyword">VALUES</span> (<span class="keyword">FLOOR</span>(<span class="number">1</span> + (<span class="keyword">RAND</span>() * <span class="number">2</span>)), <span class="string">'/index'</span>, <span class="string">'0:0:0:0:0:0:0:1'</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">'null'</span>, in_dateTime, <span class="string">'首页'</span>);</span><br><span class="line">            <span class="keyword">set</span> in_dateTime = in_dateTime + <span class="built_in">interval</span> <span class="number">1</span> MINUTE_SECOND;</span><br><span class="line">            <span class="keyword">SET</span> n = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"> </span><br><span class="line">#执行存储过程</span><br><span class="line"><span class="keyword">CALL</span> my_insert();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#数据插入成功后修改表模式InnoDB 时间稍微久点</span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`logs1`</span> <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查询表中行数，用时2.6s左右</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> logs1;</span><br><span class="line"></span><br><span class="line">#分页查询，id从1811开始，查询第6001条到6010条数据，用时0.025s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">6000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时0.048s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">60000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时0.256s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">600000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时4.372s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">9000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。</strong></p><hr><h2 id="第二节-解决流程"><a href="#第二节-解决流程" class="headerlink" title="第二节 解决流程"></a><strong>第二节 解决流程</strong></h2><h2 id="2-1-索引"><a href="#2-1-索引" class="headerlink" title="2.1 索引"></a><strong>2.1 索引</strong></h2><p>explain得知查询并未走索引，首先增加索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># type=all全表查询，先创建索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> logs1 <span class="keyword">where</span> logtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#增加唯一索引和普通索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_id (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_logtype (logtype)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_laddtime (laddtime)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_logtype</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_laddtime</span><br><span class="line"></span><br><span class="line">#<span class="keyword">type</span>是选择性低的属性，而<span class="keyword">time</span>则不是，所以索引的影响也不同</span><br><span class="line">#全表查询 <span class="number">5.073</span>-&gt;索引 <span class="number">4.226</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> logtype <span class="keyword">from</span> logs1 <span class="keyword">where</span> logtype &gt; <span class="number">1</span>;</span><br><span class="line">#ALL 3.566-&gt;range 0.426</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span>;</span><br></pre></td></tr></table></figure><p>索引并非万能的，如果我们查询的属性列是多个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#index 4.572</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,logtype,laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span>;</span><br><span class="line"></span><br><span class="line">#增加where后判断条件</span><br><span class="line">#0.966-&gt;0.853</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,logtype,laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span> <span class="keyword">and</span> <span class="keyword">id</span> &gt; <span class="string">'9001812'</span> <span class="keyword">and</span> logtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#创建组合索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_union (<span class="keyword">id</span>,logtype,laddtime)</span><br></pre></td></tr></table></figure><h2 id="2-2-优化SQL"><a href="#2-2-优化SQL" class="headerlink" title="2.2 优化SQL"></a><strong>2.2 优化SQL</strong></h2><p>避免select *，将需要查找的字段列出来</p><p>使用连接(join)来代替子查询</p><p>拆分大的delete或insert语句</p><p>通过开启慢查询日志来找出较慢的SQL</p><p>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</p><p>sql语句尽可能简单：一条sql只能在一个cpu运算;大语句拆小语句，减少锁时间;一条大sql可以堵死整个库</p><p>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</p><p>避免%xxx式查询</p><p>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p><p>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</p><p>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</p><h2 id="2-3-分区"><a href="#2-3-分区" class="headerlink" title="2.3 分区"></a><strong>2.3 分区</strong></h2><p>MySql 5.1版本引入，用户需要在建表的时候加上分区参数。分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。</p><p><strong>分区的好处是：</strong></p><ol><li>可以让单表存储更多的数据</li><li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li><li>部分查询能够从查询条件确定只落在少数分区上，速度会很快</li><li>分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备</li><li>可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li><li>可以备份和恢复单个分区</li></ol><p><strong>分区的限制和缺点：</strong></p><ol><li>一个表最多只能有1024个分区</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li>分区表无法使用外键约束</li><li>NULL值会使分区过滤无效</li><li>所有分区必须使用相同的存储引擎</li></ol><p><strong>分区的类型：</strong></p><ol><li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li><li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li><li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li><li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li><li>具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。</li></ol><h2 id="2-4-分表"><a href="#2-4-分表" class="headerlink" title="2.4 分表"></a><strong>2.4 分表</strong></h2><p>分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。</p><p>分表分为垂直拆分和水平拆分，通常以某个字段做拆分项。比如以id字段拆分为100张表： 表名为 tableName_id%100</p><p>但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高!!!而且选择这个方案，都不如选择我提供的第二第三个方案的成本低!故不建议采用。</p><h2 id="2-5-分库"><a href="#2-5-分库" class="headerlink" title="2.5 分库"></a><strong>2.5 分库</strong></h2><p>把一个数据库分成多个，建议做个读写分离就行了，真正的做分库也会带来大量的开发成本，得不偿失!不推荐使用。</p><h2 id="2-5-升级数据库"><a href="#2-5-升级数据库" class="headerlink" title="2.5 升级数据库"></a><strong>2.5 升级数据库</strong></h2><p>选用一款兼容MySql的高性能数据库。</p><h2 id="2-6-换大数据引擎处理数据"><a href="#2-6-换大数据引擎处理数据" class="headerlink" title="2.6 换大数据引擎处理数据"></a><strong>2.6 换大数据引擎处理数据</strong></h2><p>当数据量过亿，可能实现无法支撑，只能更换Hadoop等大数据引擎来代替传统数据库。</p><p>或者购买专业的大数据云解决方案，比较便宜省人力。</p><hr><p><em>参考内容：</em></p><blockquote><p><a href="https://database.51cto.com/art/201902/592522.htm" target="_blank" rel="noopener">记录一次MySQL两千万数据的大表优化解决过程，提供三种解决方案</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentSkipListMap</title>
    <link href="http://linyishui.top/2020070801.html"/>
    <id>http://linyishui.top/2020070801.html</id>
    <published>2020-07-08T08:56:37.000Z</published>
    <updated>2020-08-25T05:23:27.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a><strong>ConcurrentSkipListMap</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是ConcurrentSkipListMap"><a href="#1-1-什么是ConcurrentSkipListMap" class="headerlink" title="1.1 什么是ConcurrentSkipListMap"></a><strong>1.1 什么是ConcurrentSkipListMap</strong></h3><p>ConcurrentSkipListMap是由并发包提供的一种线程安全的并发容器，（优点）使我们能够<strong>以无锁方式实现线程安全</strong>，<strong>底层是通过跳表来实现</strong>的能够保证<strong>元素有序</strong>。</p><p>跳表是一个链表，但是通过使用<strong>“跳跃式”</strong>查找的方式使得插入、读取数据时复杂度变成了 <strong>O(logn)</strong> 。注意：<code>size()</code> 由于多个线程可以同时对映射进行操作，所以需要遍历整个映射才能返回元素个数，这是个 <strong>O(logn)</strong> 的操作。</p><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a><strong>1.2 简单使用</strong></h3><p>一个简单的实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ConcurrentSkipListMap&lt;Integer, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(</span><br><span class="line">            Comparator.comparingInt(v -&gt; v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过put添加</span></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(-<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">600</span>);</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//遍历线程集合，构建每个线程，每个线程都分别调用线程安全和不安全的计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="comment">//分别调用安全和不安全的计数器</span></span><br><span class="line">                    map.put(i, i + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历执行所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待所有线程执行完成</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印最终结果</span></span><br><span class="line">    map.forEach((k,v) -&gt; &#123;System.out.println(<span class="string">"k: "</span> + k + <span class="string">" v: "</span> + v);&#125;);</span><br><span class="line">    System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">98</span> <span class="string">v:</span> <span class="number">98</span></span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">82</span></span><br></pre></td></tr></table></figure><p>把 ConcurrentSkipListMap 替换为 TreeMap 。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line"><span class="string">k:</span> <span class="number">3</span> <span class="string">v:</span> <span class="number">3</span></span><br><span class="line"><span class="string">k:</span> <span class="number">4</span> <span class="string">v:</span> <span class="number">4</span></span><br><span class="line"><span class="string">k:</span> <span class="number">5</span> <span class="string">v:</span> <span class="number">5</span></span><br><span class="line"><span class="string">k:</span> <span class="number">6</span> <span class="string">v:</span> <span class="number">6</span></span><br><span class="line"><span class="string">k:</span> <span class="number">7</span> <span class="string">v:</span> <span class="number">7</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line"><span class="string">k:</span> <span class="number">8</span> <span class="string">v:</span> <span class="number">8</span></span><br><span class="line"><span class="string">k:</span> <span class="number">9</span> <span class="string">v:</span> <span class="number">9</span></span><br><span class="line"><span class="string">k:</span> <span class="number">10</span> <span class="string">v:</span> <span class="number">10</span></span><br><span class="line"><span class="string">k:</span> <span class="number">11</span> <span class="string">v:</span> <span class="number">11</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">50</span> <span class="string">v:</span> <span class="number">50</span></span><br><span class="line"><span class="string">k:</span> <span class="number">51</span> <span class="string">v:</span> <span class="number">51</span></span><br><span class="line"><span class="string">k:</span> <span class="number">52</span> <span class="string">v:</span> <span class="number">52</span></span><br><span class="line"><span class="string">k:</span> <span class="number">53</span> <span class="string">v:</span> <span class="number">53</span></span><br><span class="line"><span class="string">k:</span> <span class="number">54</span> <span class="string">v:</span> <span class="number">54</span></span><br><span class="line"><span class="string">k:</span> <span class="number">55</span> <span class="string">v:</span> <span class="number">55</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">56</span> <span class="string">v:</span> <span class="number">56</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">58</span> <span class="string">v:</span> <span class="number">58</span></span><br><span class="line"><span class="string">k:</span> <span class="number">59</span> <span class="string">v:</span> <span class="number">59</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">46</span></span><br></pre></td></tr></table></figure><p>可以得到一个初印象：TreeMap 多线程环境下非线程安全，但单线程的有序映射有较好的性能，而 ConcurrentSkipListMap 则可以在相同需求的多线程场景作为替代品。  </p><hr><h2 id="第二节-跳表"><a href="#第二节-跳表" class="headerlink" title="第二节 跳表"></a><strong>第二节 跳表</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h3><p> 跳表（SkipList）：是一种优秀的数据结构，<strong>使得包含n个元素的有序序列的查找和插入操作的平均时间复杂度都是 O(logn) ，要优于数组的 O(n) </strong>。</p><p>快速的查询效果是<strong>通过维护一个多层次的链表实现的</strong>，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少（见下图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择或确定性选择，其中前者更为常见。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010118.png" alt></p><p><em>一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。</em></p><h3 id="2-2-算法"><a href="#2-2-算法" class="headerlink" title="2.2 算法"></a><strong>2.2 算法</strong></h3><p>跳跃列表是按层建造的。<strong>底层是一个普通的有序链表</strong>。每个更高层都充当下面列表的<strong>“快速通道”</strong>，这里在第 i 层中的元素按某个固定的概率 p（通常为 1/2 或 1/4 ）出现在第 i+1 层中。每个元素平均出现在 1 / 1-p 个列表中，而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）在 log~1/p~n 个列表中出现。</p><p>在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾。如果该元素等于目标元素，则表明该元素已被找到；如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。每层链表中预期的查找步数最多为 1/p ，而层数为 log~1/p~n ，所以查找的总体步数为 -log~p~n / p，由于 p 是常数，查找操作总体的时间复杂度为 O(log n) 。而通过选择不同 p 值，就可以在查找代价和存储代价之间获取平衡。</p><p>跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。跳跃列表在并行计算中也很有用：插入可以在跳跃列表不同的部分并行地进行，而不用对数据结构进行全局的重新平衡。</p><h3 id="2-3-实现细节"><a href="#2-3-实现细节" class="headerlink" title="2.3 实现细节"></a><strong>2.3 实现细节</strong></h3><p>因为跳跃列表中的元素可以在多个列表中，所以每个元素可以有多于一个指针。</p><p>跳跃列表的插入和删除的实现与普通的链表操作类似，但高层元素必须在进行多个链表中进行插入或删除。</p><p>跳跃列表的最坏时间性能具有一定随机性，但是可以通过时间复杂度为 O(n) 的遍历操作（例如在打印列表全部内容时）以无随机的算法重整列表的结构，从而使跳跃列表的实际查找时间复杂度尽量符合理论平均值 O(log n) 。</p><h4 id="（1）插入操作"><a href="#（1）插入操作" class="headerlink" title="（1）插入操作"></a><strong>（1）插入操作</strong></h4><p>往跳跃列表中插入一个元素，如图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/Skip_list_add_element-en.gif" alt></p><ol><li>新节点和各层索引节点逐一比较，确定原链表的插入位置，O(log n)。</li><li>把索引插入到原链表，O(1)。</li><li>利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止，O(log n)。</li></ol><p>总体上，跳跃表插入操作的时间复杂度是 O(log n) ，而这种数据结构所占空间是2N，既空间复杂度是 O(n) 。</p><h4 id="（2）删除操作"><a href="#（2）删除操作" class="headerlink" title="（2）删除操作"></a><strong>（2）删除操作</strong></h4><p>在索引层找到要删除的节点，依次删除每层相同节点即可。若某层索引在删除后只剩下一个节点，可以删除此层。</p><ol><li>自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点，O(log n) 。</li><li>删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外），O(log n) 。</li></ol><p>总体上，跳跃表删除操作的时间复杂度是 O(log n) 。</p><h3 id="2-4-跳跃表和二叉树的区别"><a href="#2-4-跳跃表和二叉树的区别" class="headerlink" title="2.4 跳跃表和二叉树的区别"></a><strong>2.4 跳跃表和二叉树的区别</strong></h3><ul><li>跳表维持结构平衡的成本较低，完全依靠随机；二叉树则在多次插入删除后，通过再平衡操作来重新调整结构平衡。</li><li>跳表非树结构，分索引节点和底层链表节点，索引节点只有右边和下边两条索引，链表节点则只有下个节点索引，而二叉树节点则有左右子结点。</li></ul><p>补充：Redis通过跳跃表的优化实现Sorted-set维护有序集合，而关系型数据库则采用B+树。</p><hr><h2 id="第三节-源码解析"><a href="#第三节-源码解析" class="headerlink" title="第三节 源码解析"></a><strong>第三节 源码解析</strong></h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a><strong>1.1 基本结构</strong></h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank" rel="noopener">ConcurrentSkipListMap</a> 中包括 Node 和 Index 两种节点，其中 Node 即普通链表节点，而 Index 则是索引节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳表的最高头索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护映射内元素顺序的比较器，可以为空表示自然顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 延迟初始化的键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; keySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的条目集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet&lt;K,V&gt; entrySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的值集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Values&lt;V&gt; values;</span><br><span class="line">    <span class="comment">/** 延迟初始化的降序键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ConcurrentNavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> Object value;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个新的标记节点. 标记的区别在于其值字段指向自身。标记节点也具有空键，这一事实在一些地方得到了利用，但这并不能将标记与也具有空键的基本级别标头节点（head.node）区分开。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置value字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置next字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//重新检查链接，然后在每个调用中仅执行一个help-out阶段，这样可以最大程度地减少帮助线程之间的CAS干扰</span></span><br><span class="line">            <span class="comment">//如果f是此节点的下个节点，b是此节点的前个节点</span></span><br><span class="line">            <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">                <span class="comment">//如果f为空或f的value字段不等于f，则尝试CAS将新Node节点插入f前</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">                    casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">                <span class="comment">//否则，用f的下个节点覆盖f</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; node;<span class="comment">//对应链表节点，即value</span></span><br><span class="line">        <span class="keyword">final</span> Index&lt;K,V&gt; down;<span class="comment">//下层索引节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Index&lt;K,V&gt; right;<span class="comment">//右边索引节点</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置right字段，CAS set right value</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casRight</span><span class="params">(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, rightOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否已删除此索引的节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">indexesDeletedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS索引节点newSucc作为当前节点的新右边节点（插入），并将原右边节点succ右移一位</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; n = node;</span><br><span class="line">            newSucc.right = succ;</span><br><span class="line">            <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS覆盖当前节点的右边节点succ。如果已知已删除此节点，则失败(强制调用者进行遍历) </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> rightOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = Index.class;</span><br><span class="line">                rightOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"right"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-get"><a href="#1-2-get" class="headerlink" title="1.2 get"></a><strong>1.2 get</strong></h3><p>通过 <code>get()</code> 获取键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//键不允许为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">//outer配合break，外层循环</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，找到所给键的前驱节点b，并找到键对应节点n</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="comment">//找到节点已为null，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">//若此时数据已发生改变，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//n节点的值已为null，说明已被删除，调用helpDelete删掉此节点，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//b已被删除，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若命中，则返回value</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所给键小于找到的n节点键，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">//否则右移，继续循环判断</span></span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-put"><a href="#1-3-put" class="headerlink" title="1.3 put"></a><strong>1.3 put</strong></h3><p>通过 <code>put()</code> 放置键值对，前面和 <code>get()</code> 流程类似，当新增节点时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非只覆盖value，新增了节点，通过随机数维持平衡</span></span><br><span class="line">    <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">        <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            ++level;</span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">            level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                h = head;</span><br><span class="line">                <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                    newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                    h = newh;</span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find insertion points and splice in</span></span><br><span class="line">        splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = h.level;</span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> splice;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                    <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        findNode(key);</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-remove"><a href="#1-4-remove" class="headerlink" title="1.4 remove"></a><strong>1.4 remove</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-findPredecessor"><a href="#1-5-findPredecessor" class="headerlink" title="1.5 findPredecessor"></a><strong>1.5 findPredecessor</strong></h3><p>通过 <code>findPredecessor()</code> 查找给定键和比较器的前驱节点（小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个其键严格小于给定键的base-level节点，如果没有这样的节点，则返回base-level header。</span></span><br><span class="line"><span class="comment"> * 通过不断右移和下移索引，找到对应链表节点，过程中会unlink发现到的已删除节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    <span class="comment">//外层循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，从头索引开始</span></span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            <span class="comment">//右边还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                K k = n.key;</span><br><span class="line">                <span class="comment">//右边索引对应Node所存值为空，则删掉它，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r)) <span class="comment">//删掉右边索引节点</span></span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    r = q.right;         <span class="comment">// 更新右边索引节点（原右边节点的右边节点）</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若所给键大于右边节点的键，则指针右移，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前索引节点没有下层索引，直接返回其Node节点</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">            <span class="comment">//否则指针q下移到下层索引，同时更新d</span></span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-findNode"><a href="#1-6-findNode" class="headerlink" title="1.6 findNode"></a><strong>1.6 findNode</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns node holding key or null if no such, clearing out any</span></span><br><span class="line"><span class="comment"> * deleted nodes seen along the way.  Repeatedly traverses at</span></span><br><span class="line"><span class="comment"> * base-level looking for key starting at predecessor returned</span></span><br><span class="line"><span class="comment"> * from findPredecessor, processing base-level deletions as</span></span><br><span class="line"><span class="comment"> * encountered. Some callers rely on this side-effect of clearing</span></span><br><span class="line"><span class="comment"> * deleted nodes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Restarts occur, at traversal step centered on node n, if:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (1) After reading n's next field, n is no longer assumed</span></span><br><span class="line"><span class="comment"> *       predecessor b's current successor, which means that</span></span><br><span class="line"><span class="comment"> *       we don't have a consistent 3-node snapshot and so cannot</span></span><br><span class="line"><span class="comment"> *       unlink any subsequent deleted nodes encountered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (2) n's value field is null, indicating n is deleted, in</span></span><br><span class="line"><span class="comment"> *       which case we help out an ongoing structural deletion</span></span><br><span class="line"><span class="comment"> *       before retrying.  Even though there are cases where such</span></span><br><span class="line"><span class="comment"> *       unlinking doesn't require restart, they aren't sorted out</span></span><br><span class="line"><span class="comment"> *       here because doing so would not usually outweigh cost of</span></span><br><span class="line"><span class="comment"> *       restarting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (3) n is a marker or n's predecessor's value field is null,</span></span><br><span class="line"><span class="comment"> *       indicating (among other possibilities) that</span></span><br><span class="line"><span class="comment"> *       findPredecessor returned a deleted node. We can't unlink</span></span><br><span class="line"><span class="comment"> *       the node because we don't know its predecessor, so rely</span></span><br><span class="line"><span class="comment"> *       on another call to findPredecessor to notice and return</span></span><br><span class="line"><span class="comment"> *       some earlier predecessor, which it will do. This check is</span></span><br><span class="line"><span class="comment"> *       only strictly needed at beginning of loop, (and the</span></span><br><span class="line"><span class="comment"> *       b.value check isn't strictly needed at all) but is done</span></span><br><span class="line"><span class="comment"> *       each iteration to help avoid contention with other</span></span><br><span class="line"><span class="comment"> *       threads by callers that will fail to be able to change</span></span><br><span class="line"><span class="comment"> *       links, and so will retry anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The traversal loops in doPut, doRemove, and findNear all</span></span><br><span class="line"><span class="comment"> * include the same three kinds of checks. And specialized</span></span><br><span class="line"><span class="comment"> * versions appear in findFirst, and findLast and their</span></span><br><span class="line"><span class="comment"> * variants. They can't easily share code because each uses the</span></span><br><span class="line"><span class="comment"> * reads of fields held in locals occurring in the orders they</span></span><br><span class="line"><span class="comment"> * were performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node holding key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findNode</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">跳跃列表</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/java-concurrent-skip-list-map" target="_blank" rel="noopener">Guide to the ConcurrentSkipListMap</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了下Java中ConcurrentSkipListMap的实现原理，包括：概述，跳表，源码解析等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>算法复习 (二) 查找-散列表</title>
    <link href="http://linyishui.top/2020070501.html"/>
    <id>http://linyishui.top/2020070501.html</id>
    <published>2020-07-05T09:35:09.000Z</published>
    <updated>2020-08-06T16:34:57.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><strong>散列表</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是散列表"><a href="#1-1-什么是散列表" class="headerlink" title="1.1 什么是散列表"></a><strong>1.1 什么是散列表</strong></h3><p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<strong>键</strong>（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><p>通过散列表我们可以在一般应用中拥有（均摊后）<strong>常数级别</strong>的查找和插入操作。</p><p>散列表的查找分为两步：</p><ol><li>通过<strong>散列函数</strong>将被查找的键转化为数组的一个索引。</li><li>处理<strong>碰撞冲突</strong>的情况。</li></ol><h3 id="1-2-散列函数"><a href="#1-2-散列函数" class="headerlink" title="1.2 散列函数"></a><strong>1.2 散列函数</strong></h3><p>散列函数的计算过程将键转化为数组的索引：如果我们有一个能保持M个键值对的数组，就需要一个能够将任意键转化为该数组范围内的索引（[0,M-1]）的<strong>散列函数</strong>。</p><p>严格来说，<strong>对于每种类型的键都需要一个与之对应的散列函数</strong>。</p><ul><li>正整数：常用<strong>除留余数法</strong>，数组大小为素数M，任意整数k除以M获得余数。选用素数的原因是避免无法均匀的散列。</li><li>浮点数：0到1间的实数，可以乘以M并四舍五入得到一个0至M-1间的索引值。但这种方法使键的高位占更大作用，低位则没什么影响，Java中采用的修正方法是<strong>将键表示为二进制再使用除留余数法</strong>。</li><li>字符串：也可以使用<strong>除留余数法</strong>，Java中有 <code>charAt()</code> 函数能返回一个char值，即一个非负16位整数。把字符串当作一个N位的R进制值，除以M并取余。Java默认使用类似 <code>Horner</code> 方法的算法，用N次乘法、加法和取余计算一个字符串的散列值。</li><li>组合键：键类型包含多种类型，如多个整型变量组合，比如Date类型，可以通过 <code>int hash = (((day * R + month) % M ) * R + year) % M</code> 来计算散列值。只要R足够小，就可以得到一个0至M-1间的散列值。</li></ul><p>Java为很多常用的数据类型重写了 <code>hashcode()</code> 方法（如String、Integer、Double、File和URL）。</p><h3 id="1-3-哈希碰撞"><a href="#1-3-哈希碰撞" class="headerlink" title="1.3 哈希碰撞"></a><strong>1.3 哈希碰撞</strong></h3><p>对不同的关键字可能得到同一散列地址，即 k~1~ != k~2~ ，而 f(k~1~) == f(k~2~) ，这种现象称为<strong>冲突</strong>（英语：Collision），也叫哈希冲突/碰撞。</p><p>两种处理哈希碰撞的方法：</p><ul><li><strong>开放地址法</strong>：当遇到哈希冲突时，依照增量规则向后取地址直到有未被占用地址为止。实例公式：<code>Hash(key) = (Hash(key) + di) mod TableSize</code> ，di表示增量序列，di不同的增长可分为：<ul><li><strong>线性探测法</strong>：di = i++ [1,2,3……，TableSize-1] ，即依次按地址后取，当一个键散列值被占用时，直接检查散列表的下一个位置（索引值加1），弊端是元素积聚，没有均匀的分布元素，导致性能降低，多查询了越来越多的无关项。</li><li><strong>二次探测法</strong>：di = (i++)^2^ * (di  / |di|) [1,-1,4,-4,9,-9……] ，弊端是当剩余空间较少时，在还有空间的情况下会极有可能插入失败。</li><li><strong>双散列探测法</strong>：di = (i++) * Hash2(key) [1H,2H,3H……] ，<code>Hash2(key) = p – (key mod p)</code> ，<code>Hash2(key) = (key % 97) + 1</code> ，其中p为小于表长的任意素数。通过另外一个散列函数来减少积聚问题，第二个函数需要排出散列值为0的情况，计算的散列值要和表长互素。</li></ul></li><li><strong>链地址法/拉链法</strong>：即将散列表每一个地址都对应一个链表，似乎链表会占用更多的空间，但实际使用中，因为装填因子的存在所以链地址法可能会更节省空间。通常情况下哈希表都非常高效，插入或查询都是O(1)，最差情况是集中映射到少量地址上，就会退化为链表查询，若被人通过Hash攻击的方式产生大量的碰撞，会导致本来高效的服务处理变得异常缓慢，可以通过限制表单提交长度等方法来防止此类攻击。</li></ul><hr><h2 id="第二节-实现"><a href="#第二节-实现" class="headerlink" title="第二节 实现"></a><strong>第二节 实现</strong></h2><h3 id="2-1-基于拉链法的散列表"><a href="#2-1-基于拉链法的散列表" class="headerlink" title="2.1 基于拉链法的散列表"></a><strong>2.1 基于拉链法的散列表</strong></h3><p>下面这个简单的符号表维护了一条链表数组，通过散列函数来为每个键选择链表。创建 <code>st[]</code> 时需要进行类型转换，因为 Java 不允许泛型的数组。默认构造器会使用997条链表，此段简单的代码已经可以在已知符号表大小时得到不错的性能，当然还可以添加<strong>动态调整链表数组的大小</strong>（rehash-再散列）的功能，从而能在任意大小都能保证链表的短小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表大小</span></span><br><span class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st;<span class="comment">//存放链表对象的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建M条链表</span></span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">            st[i] = <span class="keyword">new</span> SequentialSearchST();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value) st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-基于线性探测法的散列表"><a href="#2-2-基于线性探测法的散列表" class="headerlink" title="2.2 基于线性探测法的散列表"></a><strong>2.2 基于线性探测法的散列表</strong></h3><p>线性探测表<strong>通过空（null）来表示一簇键的结束</strong>，对于删除操作来说，直接将对应元素值设置为 <code>null</code> 是不行的，会导致此位置之后的元素无法被查找。正确的做法是将右侧所有键重新插入散列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">16</span>;<span class="comment">//线性探测表大小</span></span><br><span class="line">    <span class="keyword">private</span> key[] keys;<span class="comment">//键数组</span></span><br><span class="line">    <span class="keyword">private</span> value[] vals;<span class="comment">//值数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = (key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        vals = (value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;<span class="comment">//散列函数</span></span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;<span class="comment">//再散列</span></span><br><span class="line">        <span class="comment">//实例化新的线性探测表</span></span><br><span class="line">        LinearProbingHashST&lt;Key, Value&gt; t;</span><br><span class="line">        t = <span class="keyword">new</span> LinearProbingHashST&lt;Key, Value&gt;(cap);</span><br><span class="line">        <span class="comment">//循环遍历拷贝旧表元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">        <span class="keyword">if</span>(keys[i] != <span class="keyword">null</span>)</span><br><span class="line">                t.put(keys[i], vals[i]);</span><br><span class="line">        <span class="comment">//更新当前引用，t为局部变量</span></span><br><span class="line">        keys = t.keys;</span><br><span class="line">        vals = t.vals;</span><br><span class="line">        M = t.M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N &gt;= M/<span class="number">2</span>) resize(M*<span class="number">2</span>); <span class="comment">//M加倍扩容散列表</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//i散列得到索引，若键相等则替换值，否则检查下一个位置，直到对应key为空</span></span><br><span class="line">        <span class="keyword">for</span>(i = hash(key);keys[i] != <span class="keyword">null</span>;i = (i + <span class="number">1</span>) % M)</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))&#123;</span><br><span class="line">                vals[i] = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//将键值放入当前i</span></span><br><span class="line">        keys[i] = key;</span><br><span class="line">        vals[i] = val;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key);keys[i] != <span class="keyword">null</span>;i = (i + <span class="number">1</span>) % M)</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))</span><br><span class="line">                <span class="keyword">return</span> vals[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = hash(key);</span><br><span class="line">        <span class="comment">//遍历键簇直到找到对应key</span></span><br><span class="line">        <span class="keyword">while</span>(!key.equals(key[i]))</span><br><span class="line">            i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先将对应索引置空</span></span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        vals[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新i到下一个位置</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环将后面元素重新加入散列表，直到遍历到下一个空</span></span><br><span class="line">        <span class="keyword">while</span>(keys[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Key keyToRedo = keys[i];</span><br><span class="line">            Value valueToRedo = vals[i];</span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        vals[i] = <span class="keyword">null</span>;</span><br><span class="line">            N--;</span><br><span class="line">            put(keyToRedo, valueToRedo);</span><br><span class="line">            i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">//若此时键值对总数达到1/8表大小，则再散列缩小</span></span><br><span class="line">        <span class="keyword">if</span>(N &gt; <span class="number">0</span> &amp;&amp; N == M/<span class="number">8</span>) </span><br><span class="line">            resize(M/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-查找总结"><a href="#第三节-查找总结" class="headerlink" title="第三节 查找总结"></a><strong>第三节 查找总结</strong></h2><h3 id="3-1-各种符号表渐进性能的总结"><a href="#3-1-各种符号表渐进性能的总结" class="headerlink" title="3.1 各种符号表渐进性能的总结"></a><strong>3.1 各种符号表渐进性能的总结</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010117.jpg" alt></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了散列表的相关内容，内容包括：概述（什么是散列表、散列函数、哈希碰撞），实现（基于拉链法的散列表、基于线性探测法的散列表），查找总结。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="hash" scheme="http://linyishui.top/tags/hash/"/>
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>B树和B+树</title>
    <link href="http://linyishui.top/2020070201.html"/>
    <id>http://linyishui.top/2020070201.html</id>
    <published>2020-07-02T08:40:04.000Z</published>
    <updated>2020-08-05T16:11:59.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><strong>B树和B+树</strong></h1><h2 id="第一节-B树"><a href="#第一节-B树" class="headerlink" title="第一节 B树"></a><strong>第一节 B树</strong></h2><h3 id="1-1-什么是B树"><a href="#1-1-什么是B树" class="headerlink" title="1.1 什么是B树"></a><strong>1.1 什么是B树</strong></h3><p>B树是一种<strong>自平衡</strong>的树，能够保持数据<strong>有序</strong>。保证查找数据、顺序访问、插入数据、删除等操作都能在<strong>对数时间</strong>内完成。</p><p>B树也属于二叉查找树，<strong>一个节点允许拥有两个以上的子节点</strong>。与平衡二叉树不同的是，B树适用于读写相对较大的数据块的存储系统，如磁盘。</p><p>B树减少定位记录时所经历的中间过程，从而加快存取速度。</p><p><strong>2-3树、红黑树都是常见的B树</strong>。</p><h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a><strong>1.2 应用场景</strong></h3><p>B树这种数据结构可以用来描述外部存储。常被应用在<strong>数据库</strong>和<strong>文件系统</strong>的实现上。</p><h3 id="1-3-描述"><a href="#1-3-描述" class="headerlink" title="1.3 描述"></a><strong>1.3 描述</strong></h3><p>几个定义：</p><ul><li><strong>内部节点</strong>：内部节点是除叶子节点和根节点之外的所有节点。它们通常被表示为一组有序的元素和指向子节点的指针。</li><li><strong>根节点</strong>：根节点拥有的子节点数量的上限和内部节点相同，但是没有下限。</li><li><strong>叶子节点</strong>：叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。</li></ul><p>B树的内部结点（非叶子）可以拥有可变数量的子结点。因为子结点可变数量这一特性，B树不需要像其他平衡二叉树那样频繁的进行重新保持平衡的操作，但相应的也造成了空间浪费（以空间换时间）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/400px-B-tree.svg.png" alt></p><p>子节点数量的上界和下界依特定的实现而设置。例如，在一个2-3 B树（通常简称<a href="https://zh.wikipedia.org/wiki/2-3树" target="_blank" rel="noopener">2-3树</a>），每一个内部节点只能有2或3个子节点。</p><h3 id="1-4-操作"><a href="#1-4-操作" class="headerlink" title="1.4 操作"></a><strong>1.4 操作</strong></h3><h4 id="（1）搜索"><a href="#（1）搜索" class="headerlink" title="（1）搜索"></a><strong>（1）搜索</strong></h4><p>B树的搜索和二叉搜索树类似：从根节点开始，从上到下<strong>递归的遍历树</strong>。在每一层上，搜索的范围被减小到包含了搜索值的子树中（左小右大）。子树值的范围被它的父节点的键确定。</p><h4 id="（2）插入"><a href="#（2）插入" class="headerlink" title="（2）插入"></a><strong>（2）插入</strong></h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/B_tree_insertion_example.png" alt></p><p>所有的插入都从根节点开始。要插入一个新的元素，首先搜索这棵树找到新元素应该被添加到的对应节点。将新元素插入到这一节点中的步骤如下：</p><ol><li>如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序。</li><li>否则的话这一节点已经满了，将它平均地分裂成两个节点：<ol><li>从该节点的原有元素和新的元素中选择出中位数。</li><li>小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值。</li><li>分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）。</li></ol></li></ol><h4 id="（3）删除叶子节点中的元素"><a href="#（3）删除叶子节点中的元素" class="headerlink" title="（3）删除叶子节点中的元素"></a><strong>（3）删除叶子节点中的元素</strong></h4><ol><li>搜索要删除的元素。</li><li>如果它在叶子节点，将它从中删除。</li><li>如果发生了下溢出，按照后面<strong>删除后重新平衡</strong>部分的描述重新调整树。</li></ol><h4 id="（4）删除内部节点中的元素"><a href="#（4）删除内部节点中的元素" class="headerlink" title="（4）删除内部节点中的元素"></a><strong>（4）删除内部节点中的元素</strong></h4><p>内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：</p><ol><li>选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。</li><li>前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。</li></ol><h4 id="（5）删除后的重新平衡"><a href="#（5）删除后的重新平衡" class="headerlink" title="（5）删除后的重新平衡"></a><strong>（5）删除后的重新平衡</strong></h4><p>重新平衡从叶子节点开始向根节点进行，直到树重新平衡（自底向上）。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点<strong>合并</strong>。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：</p><ul><li>如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转：<ol><li>将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）。</li><li>将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）。</li><li>树又重新平衡。</li></ol></li><li>否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转：<ol><li>将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）。</li><li>将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）。</li><li>树又重新平衡。</li></ol></li><li>否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并：<ol><li>将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）。</li><li>将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）。</li><li>将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）。<ul><li>如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）。</li><li>否则，如果父节点的元素数量小于最小值，重新平衡父节点。</li></ul></li></ol></li></ul><h3 id="1-5-变体"><a href="#1-5-变体" class="headerlink" title="1.5 变体"></a><strong>1.5 变体</strong></h3><p>B树在内部结点上存储键值，但不需要在叶子结点上存储这些键值的记录。</p><ul><li><strong>B+树</strong>：<ul><li>这些键值的拷贝被存储在内部结点；</li><li>键值和记录存储在叶子结点；</li><li>一个叶子结点可以包含一个指针，指向另一个叶子结点以加速顺序存取。</li></ul></li><li><strong>B*树</strong>：分支出更多的内部邻居节点以保持内部节点更密集地填充。此变体要求非根节点至少2/3填充，而不是1/2。为了维持这样的结构，当一个节点填满之后将不会再立即分割节点，而是将它的键值与下一个节点共享。当两个节点都填满之后，分割成3个节点。</li><li>计数B树存储，每一树都带有一个指针和其指向子树的节点数目。这就允许了以键值为序快速查找第N笔记录，或是统计2笔记录之间的记录数目，还有其他很多相关的操作。</li></ul><h3 id="1-6-B树与平衡二叉树的区别"><a href="#1-6-B树与平衡二叉树的区别" class="headerlink" title="1.6 B树与平衡二叉树的区别"></a><strong>1.6 B树与平衡二叉树的区别</strong></h3><p>平衡二叉树通常是指查找路径只有两种（即只有二叉），而B树则不仅仅二叉，所以也叫<strong>平衡多路查找树</strong>。</p><p>B树相比平衡二叉树在每个结点所包含的内容更多，在应用到数据库中的时候，充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把结点大小限制和充分使用在磁盘块大小范围。所以树的结点能包含更多的内容后，树的层级比原来的二叉树少了，就可以减少数据查找的次数和复杂度。</p><hr><h2 id="第二节-B-树"><a href="#第二节-B-树" class="headerlink" title="第二节 B+树"></a><strong>第二节 B+树</strong></h2><h3 id="2-1-什么是B-树"><a href="#2-1-什么是B-树" class="headerlink" title="2.1 什么是B+树"></a><strong>2.1 什么是B+树</strong></h3><p><strong>B+ 树</strong>是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是<strong>能够保持数据稳定有序</strong>，其<strong>插入与修改拥有较稳定的对数时间复杂度</strong>。B+ 树元素<strong>自底向上插入</strong>，这与二叉树恰好相反。</p><p>B+ 树在节点访问时间远远超过节点内部访问时间的时候，比其他可作为替代的实现有着实在的优势。这通常在多数节点在次级存储比如硬盘中的时候出现。<strong>通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了</strong>。通常需要每个节点在次级存储中占据完整的磁盘块或近似的大小。</p><p>B+ 背后的设计思想是<strong>内部节点可以有在预定范围内的可变量目的子节点</strong>。因此，B+ 树不需要像其他自平衡二叉查找树那样经常的重新平衡。对于特定的实现在子节点数目上的低和高边界是固定的。</p><p>B+ 树的创造者 <code>Rudolf Bayer</code> 没有解释 <code>B</code> 代表什么。最常见的观点是 <code>B</code> 代表<strong>平衡</strong>(balanced)，因为所有的叶子节点在树中都在相同的级别上。<code>B</code> 也可能代表 <code>Bayer</code>，或者是<a href="https://zh.wikipedia.org/wiki/波音" target="_blank" rel="noopener">波音</a>（Boeing），因为他曾经工作于<em>波音科学研究实验室</em>。</p><p>如下图，把键 <code>1-7</code> 连接到值 <code>d1-d7</code> 的B+树。链表（红色）用于快速顺序遍历叶子节点。树的分叉因子 <code>b=4</code> 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/400px-Bplustree.png" alt></p><h3 id="2-2-节点结构"><a href="#2-2-节点结构" class="headerlink" title="2.2 节点结构"></a><strong>2.2 节点结构</strong></h3><p>在B+树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的阶数是 <code>m</code> ，则除了根之外的每个节点都包含最少 <code>m/2</code> 个元素最多 <code>m-1</code> 个元素，对于任意的结点有最多 <code>m</code> 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。</p><p>如下图所示，非叶子结点的关键字不保存数据，只用来索引，所有数据都保存在叶子节点。所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010115.png" alt></p><h3 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a><strong>2.3 算法</strong></h3><h4 id="2-3-1-查找"><a href="#2-3-1-查找" class="headerlink" title="2.3.1 查找"></a><strong>2.3.1 查找</strong></h4><p>查找以典型的方式进行，类似于<a href="https://zh.wikipedia.org/wiki/二叉查找树" target="_blank" rel="noopener">二叉查找树</a>。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是<a href="https://zh.wikipedia.org/wiki/二分查找" target="_blank" rel="noopener">二分查找</a>来确定这个位置。</p><h4 id="2-3-2-插入"><a href="#2-3-2-插入" class="headerlink" title="2.3.2 插入"></a><strong>2.3.2 插入</strong></h4><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。</p><ol><li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li></ol><h4 id="2-3-3-删除"><a href="#2-3-3-删除" class="headerlink" title="2.3.3 删除"></a><strong>2.3.3 删除</strong></h4><ol><li>首先，查找要删除的值。接着从包含它的节点中删除这个值。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果节点处于违规状态则有两种可能情况：<ol><li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。</li><li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li></ol></li></ol><h3 id="2-4-实例说明"><a href="#2-4-实例说明" class="headerlink" title="2.4 实例说明"></a><strong>2.4 实例说明</strong></h3><p>假设B+树结点最多容纳存放3个键和4个指针， <code>m = 3</code> 为奇数，<code>d = 1</code> ，叶子结点至少2个条目（d + 1），非叶子结点至少2个指针（d + 1），1个条目。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010101.png" alt></p><p>首先插入1：判断根结点为空直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010102.png" alt></p><p>接着连续插入3、5：根结点未满，连续放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010103.png" alt></p><p>接着插入7：此时根结点达到max，判断需要分裂：<strong>当节点元素数量大于m-1的时候，从中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，当然本身中间元素还是分裂右边这一部分的，保证左小右大的规则</strong>。所以分裂成两个子结点，1和3下沉到左边，5和7下沉到右边，内部结点只保存索引，最底层叶子结点连成有序链表。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010104.png" alt></p><p>接着插入9：找到位置，还有空间，直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010105.png" alt></p><p>接着插入2：如上放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010106.png" alt></p><p>接着插入4：此时对应叶子结点已放满，需要再度分裂成两个结点，1和2保留在左结点，3和4则移到新结点，并将新结点首个元素指向父结点（此时父结点仍有空间）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010107.png" alt></p><p>接着插入6：对应叶子结点同样已满，继续相同分裂操作，并将新结点首个元素指向父结点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010108.png" alt></p><p>接着插入8：仍有空间，直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010109.png" alt></p><p>接着插入10：此时对应叶子结点已满，所以先分裂开，7和8保留，9和10生成新叶子结点，将新叶子结点首个元素指向父结点，此时父结点超过上限（已是根结点，递归向上分裂，直到根结点分裂，增加高度），所以根结点分裂，中间元素7成为新的根结点，左小右大，新的结构仍是稳定的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010110.png" alt></p><p>接下来我们看B+树的删除操作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010111.png" alt></p><p>首先删除9：查找9所在结点，把它删除，然后判断此时树状态，发现叶子结点违规：叶子结点至少2个条目（d + 1），非叶子结点至少2个指针（d + 1），1个条目。合并兄弟结点，10、11和12合并，此时父结点因为少了一个子结点违规，所以需要继续处理。（此处为何为9还未搞懂）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010112.png" alt></p><p>接着删除7：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010113.png" alt></p><p>接着删除8：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010114.png" alt></p><h3 id="2-5-B-树的特点"><a href="#2-5-B-树的特点" class="headerlink" title="2.5 B+树的特点"></a><strong>2.5 B+树的特点</strong></h3><ol><li>B+树的非叶子结点不保存关键字记录的指针，只进行数据索引，这样可以使B+树每个非叶子结点所能保存的关键字数大大增加。</li><li>B+树叶子结点保存了父结点的所有关键字记录的指针，所有数据地址必须到叶子结点才能获取到，所以每次数据查询的次数都相同。</li><li>B+树叶子结点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li><strong>非叶子节点的子节点数</strong> = <strong>关键字数</strong>，或者<strong>非叶节点的关键字数</strong> = <strong>子节点数</strong> - 1，虽然他们数据排列结构不一样，但其原理还是一样的，Mysql 的B+树是用第一种方式实现。</li></ol><h3 id="2-6-B-树与B树的区别"><a href="#2-6-B-树与B树的区别" class="headerlink" title="2.6 B+树与B树的区别"></a><strong>2.6 B+树与B树的区别</strong></h3><ol><li>B+树的<strong>层级更少</strong>：相较于B树，B+树的每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li><li>B+树<strong>查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li><li>B+树<strong>天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li></ol><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><table><thead><tr><th style="text-align:center">S.NO</th><th style="text-align:center">B TREE</th><th style="text-align:center">B+ TREE</th></tr></thead><tbody><tr><td style="text-align:center">1.</td><td style="text-align:center">所有的内部和叶子结点都有数据指针</td><td style="text-align:center">只有叶子结点有数据指针</td></tr><tr><td style="text-align:center">2.</td><td style="text-align:center">由于叶子结点上的所有键都不可用，所以搜索通常更费时</td><td style="text-align:center">所有键都在叶节点上，因此搜索更快，更准确</td></tr><tr><td style="text-align:center">3.</td><td style="text-align:center">树中没有重复的键</td><td style="text-align:center">允许重复的键，并且所有结点都存在于叶子上</td></tr><tr><td style="text-align:center">4.</td><td style="text-align:center">插入会花费更多时间，有时无法预测</td><td style="text-align:center">插入更容易，结果始终相同</td></tr><tr><td style="text-align:center">5.</td><td style="text-align:center">内部结点的删除非常复杂，并且树必须进行大量转换</td><td style="text-align:center">删除任何节点都很容易，因为所有结点都可以在叶子上找到</td></tr><tr><td style="text-align:center">6.</td><td style="text-align:center">叶子结点不存储为结构链表</td><td style="text-align:center">叶子结点存储为结构链表</td></tr><tr><td style="text-align:center">7.</td><td style="text-align:center">没有多余的搜索键</td><td style="text-align:center">可能存在多余的搜索键</td></tr></tbody></table><h3 id="2-7-B-树与B-树的区别"><a href="#2-7-B-树与B-树的区别" class="headerlink" title="2.7 B+树与B*树的区别"></a><strong>2.7 B+树与B*树的区别</strong></h3><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ol><li><p>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是 <code>cei(m/2)</code> ，<code>b*</code> 树的初始化个数为<code>cei(2/3*m)</code> 。</p></li><li><p>B+树节点满时就会分裂，而B<em>树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</em></p></li><li>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</li></ol><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/B树" target="_blank" rel="noopener">B树-维基百科</a></p></blockquote><blockquote><p><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B+树-维基百科</a></p></blockquote><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了B树和B+树的相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
</feed>
