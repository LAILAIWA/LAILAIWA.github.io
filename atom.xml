<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-11-18T08:54:23.757Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死亡会是解脱吗</title>
    <link href="http://linyishui.top/2019111201.html"/>
    <id>http://linyishui.top/2019111201.html</id>
    <published>2019-11-12T10:03:51.000Z</published>
    <updated>2019-11-18T08:54:23.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-oauNRCyF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-oauNRCyF"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "曾经我也想过一了百了",              author: "中島美嘉",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/%E4%B8%AD%E5%B3%B6%E7%BE%8E%E5%98%89%20-%20%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp3",              pic: "http://p1.music.126.net/HE-K4mxyNGF84xlyuxx9Wg==/109951163825342747.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-VYGPztIa" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-VYGPztIa"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "僕らの手には何もないけど、",              author: "RAM WIRE",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/RAM%20WIRE%20-%20%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81.mp3",              pic: "http://p2.music.126.net/V1o9XDhAnI1ayWW5elJwFQ==/109951163338252165.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-eZycMzrj" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-eZycMzrj"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "ごはんを食べよう",              author: "Goose house",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/Goose%20house%20-%20%E3%81%94%E3%81%AF%E3%82%93%E3%82%92%E9%A3%9F%E3%81%B9%E3%82%88%E3%81%86.mp3",              pic: "http://p1.music.126.net/niXAzTEt2zlFpcLiPedX3g==/5754843859843186.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>&emsp;&emsp;可能会有那么一刻感叹自己的人生很空虚，世界好像和我无关，就算在这里死掉也不会有人会发现吧。</p><p>&emsp;&emsp;可能会有那么一刻觉得活着好累，死了就会好一些吧。</p><p>&emsp;&emsp;可能会有那么一刻无力反抗背上的压力，想着死了就轻松了吧。</p><p>&emsp;&emsp;活着似乎总是要担负一些东西，嘴里说着要放下一切，只有死去的那一刻才能真的放下吧。</p><p>&emsp;&emsp;世界是这样吗，不像幻想中那么美好、那么宽容，我好像也没那么坚强。</p><p>&emsp;&emsp;也曾想向世界传递善意，但身边的世界好像是空空的，是不是只有坏的记忆才能留在人的心里。</p><p>&emsp;&emsp;也曾想对世界倾诉，但好像没人有在乎，渐渐的也不知道该怎么说话了。</p><p>&emsp;&emsp;是啊，大家活着都很累啊，慢慢地封闭了自己的内心。</p><p>&emsp;&emsp;为了不受伤害而戴上的面具，也遮挡住了阳光，勉强才能维持着正常人的姿态。</p><p>&emsp;&emsp;“你没事吧”，“休息一下就好了”，“为家人考虑一下”，“再多坚强一些”，“还是内心不够强大”，“看不起这种自私的人”</p><p>&emsp;&emsp;说什么把握当下，生命要活得精彩，只是漂亮话罢了。</p><p>&emsp;&emsp;永别的时候告诉自己这不是放弃，是放下了。</p><p>&emsp;&emsp;好像这一生积攒的勇气终于释放了，好像扮演了一生的舞台剧终于谢幕了。</p><p>&emsp;&emsp;黑暗中死的无声无息，似乎从来没有存在过，直到最后也没有选择在阳光下，是担心围观的人肆意评论吗，人的恶意从来不会消失吧。</p><p>&emsp;&emsp;曾经也活着啊，匆匆的这一生有什么意义？</p><p>&emsp;&emsp;可能最后时刻的你也曾许愿，如果有来生，希望和能相互拥抱的人相遇。</p><p>&emsp;&emsp;哪怕一直聊着没有营养的话题，只想这样呆在一起。</p><p>&emsp;&emsp;就算还是一样活的辛苦，至少能感受到温暖。</p><p>&emsp;&emsp;希望那时可以相信这世界一切美好的存在，希望我也能成为温暖别人的存在。</p><p>&emsp;&emsp;但死了就什么都没有了，如果坚持到明天会不会有不同？</p><p>&emsp;&emsp;已放下所有的你，也许在明天的街头，可以邂逅一个阳光一样的人，也许再尝试一次就能找到一个同样孤独的人相拥取暖。</p><p>&emsp;&emsp;也许是一个多年未联系的老友，敞开心扉后，发现被社会打磨的油滑的他内心也还保留着一颗温热的心。</p><p>&emsp;&emsp;即便因奔忙无法相见，即便相互已无法变得坦率，但只要能够回到每个人都怀念的那个地方的话，是能让时光从那个时候开始延续吧</p><p>&emsp;&emsp;找到一个活下去的理由，只要能继续努力的活着，一切都还有重来的机会。</p><p>&emsp;&emsp;原本以为做不到的事情实际却可以做到的，世界渐渐变得广阔，因为相信现在所处的世界，即使一无所有仍可以顽强的活下去。</p><p>&emsp;&emsp;是啊，活着就是一件麻烦的事情，觉得不行了就暂停一下，无法面对了就逃避一下，总有一天，我们会从所有束缚我们的事之中，从肉眼看不到的微痛之中，得以解放。</p>        <div id="aplayer-OpDLKfTe" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-OpDLKfTe"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "面会菜",              author: "林生祥",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/OM/%E6%9E%97%E7%94%9F%E7%A5%A5%20-%20%E9%9D%A2%E4%BC%9A%E8%8F%9C.mp3",              pic: "http://p2.music.126.net/cLoAM3X8pIuCil_oJpxjWw==/18511377767183768.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><blockquote><p>&emsp;&emsp;这篇博客算是记录一下最近几年的一些感想吧，经历了一些生活中、网络中发生的事情会有些感受，这些碎片式的感受还挺难整理的，很多回忆融合到一起，写的时候有些混乱了，写着写着也搞不清想要说什么了。<br>&emsp;&emsp;有些事情发生了，可能并没有一个简单的答案，局外人却可以随心所欲的谈论自己的观点，虽然他们可能什么都不知道，却能没有责任的随便开口。事情已经发生了，当事人也没办法为自己辩护了。<br>&emsp;&emsp;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日志" scheme="http://linyishui.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="diary" scheme="http://linyishui.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>重构、测试和调试</title>
    <link href="http://linyishui.top/2019092601.html"/>
    <id>http://linyishui.top/2019092601.html</id>
    <published>2019-09-26T10:12:04.000Z</published>
    <updated>2019-11-23T19:12:30.311Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a><strong>Java8的新特性</strong></h1><h2 id="第一节-为改善可读性和灵活性重构代码"><a href="#第一节-为改善可读性和灵活性重构代码" class="headerlink" title="第一节 为改善可读性和灵活性重构代码"></a><strong>第一节 为改善可读性和灵活性重构代码</strong></h2><p>&emsp;&emsp;学会了Lambda和流后我们可以在新项目中使用这些新特性，而一些老项目我们可能也想要用新的方式来重构代码，提高代码的可读性和灵活性。</p><p>&emsp;&emsp;用Lambda表达式可以相比匿名类更简洁，代码会更灵活，在需求有变更时，行为参数化的模式可以更有效的来应对。</p><blockquote><p>为何说Java 8的新特性可以提高可读性？</p><ul><li>减少冗长的代码，代码更容易理解。</li><li>通过方法引用和Stream API，代码会更直观。</li></ul></blockquote><blockquote><p>如何通过Java 8的新特性提高可读性？</p><ul><li>重构代码，用Lambda表达式取代匿名类</li><li>用方法引用重构Lambda表达式</li><li>用Stream API重构命令式的数据处理</li></ul></blockquote><h3 id="1-1-匿名类到Lambda表达式"><a href="#1-1-匿名类到Lambda表达式" class="headerlink" title="1.1 匿名类到Lambda表达式"></a><strong>1.1 匿名类到Lambda表达式</strong></h3><p>&emsp;&emsp;用Lambda表达式代替匿名类时要注意二者的不同，如this和super在二者有不同的含义，对于匿名类this是类自身，而Lambda则表示包含类。匿名类可以屏蔽包含类变量，Lambda表达式则不行。对于重载的场景，Lambda表达式可能会有些歧义，多个函数可能都合法，可以通过显式的类型转换来解决此问题。</p><h3 id="1-2-Lambda表达式到方法引用"><a href="#1-2-Lambda表达式到方法引用" class="headerlink" title="1.2 Lambda表达式到方法引用"></a><strong>1.2 Lambda表达式到方法引用</strong></h3><p>&emsp;&emsp;方法名可以更直接的表达代码的意图，请尽量使用静态辅助方法。</p><h3 id="1-3-命令式数据处理到Stream"><a href="#1-3-命令式数据处理到Stream" class="headerlink" title="1.3 命令式数据处理到Stream"></a><strong>1.3 命令式数据处理到Stream</strong></h3><p>&emsp;&emsp;所有使用迭代器这种处理模式来处理集合的代码都应该转换为Stream API的方式，流更能清楚的表达数据处理管道的意图，通过短路和延迟载入以及多核架构可以进行优化处理。</p><p>&emsp;&emsp;将命令式数据处理转换到Stream不是一件容易的事情，需要考虑控制流语句，选择恰当的流操作，不过已有一些工具可以辅助进行这一步转换。</p><h3 id="1-4-增加代码灵活性"><a href="#1-4-增加代码灵活性" class="headerlink" title="1.4 增加代码灵活性"></a><strong>1.4 增加代码灵活性</strong></h3><h4 id="1-4-1-采用函数式接口"><a href="#1-4-1-采用函数式接口" class="headerlink" title="1.4.1 采用函数式接口"></a><strong>1.4.1 采用函数式接口</strong></h4><p>&emsp;&emsp;Lambda表达式的使用依赖于函数式接口，我们可以基于两种模式来重构代码：<strong>有条件的延迟执行</strong>和<strong>环绕执行</strong>。</p><h4 id="1-4-2-有条件的延迟执行"><a href="#1-4-2-有条件的延迟执行" class="headerlink" title="1.4.2 有条件的延迟执行"></a><strong>1.4.2 有条件的延迟执行</strong></h4><p>&emsp;&emsp;控制语句经常会被混杂在业务逻辑代码之中，典型的场景就是安全性检查以及日志输出，如下述代码所示。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span>(logger.isLoggable(Level.FINER))&#123;</span><br><span class="line">    <span class="selector-tag">logger</span><span class="selector-class">.finer</span>(<span class="string">"Problem: "</span> + generateDiagnostic());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中日志器的状态被isLoggable暴露给了客户端代码，在每次输出日志前都要查询日志器对象的状态，可以尝试下列改造。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.<span class="built_in">log</span>(Level.FINER, <span class="string">"Problem: "</span> + generateDiagnostic());</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样隐藏了日志器状态，也少去了条件判断，log方法会在内部检查日志对象是否已被设置为恰当的日志等级。但日志消息的输出与否每次仍需要进行判断，即使你已经传递了参数，不开启日志。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logger.log<span class="function"><span class="params">(Level.FINER, () -&gt; <span class="string">"Problem: "</span> + generateDiagnostic())</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">void</span> <span class="title">log</span><span class="params">(Level level, Supplier&lt;String&gt; msgSupplier)</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(logger.isLoggable(level))</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">log</span><span class="params">(level, msgSupplier.get())</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 8提供了log方法的重载版，提供了Supplier参数，主要思路就是<strong>延迟消息构造</strong>：如果你需要频繁的从客户端去查询一个对象的状态，只是为了传递参数、调用该对象的一个方法，那么就可以考虑实现一个新的方法，以Lambda或方法表达式作为参数，新方法在检查完该对象的状态后才调用原来的方法，这样的一层处理会使代码结构更清晰和易读，封装性更好。</p><h4 id="1-4-3-环绕执行"><a href="#1-4-3-环绕执行" class="headerlink" title="1.4.3 环绕执行"></a><strong>1.4.3 环绕执行</strong></h4><p>&emsp;&emsp;环绕执行模式：<strong>如资源处理等场景往往需要打开一个资源，进行处理，然后关闭资源，准备和清理会环绕着执行处理的那些重要代码</strong>。业务代码虽然各不相同，但都有同样的准备和清理阶段。我们可以重用准备和清理阶段的逻辑，减少重复冗余的代码，如下所示，我们把打开和关闭文件看作重复操作，抽离出不同的处理方法。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//通过函数式接口<span class="keyword">BufferedReaderProcesser，可以传递各种Lambda表达式对BufferedReader对象进行处理</span></span><br><span class="line"><span class="keyword">String </span>oneLine = processFile((<span class="keyword">BufferedReader </span><span class="keyword">b) </span>-&gt; <span class="keyword">b.readLine());</span></span><br><span class="line"><span class="keyword">String </span>twoLine = processFile((<span class="keyword">BufferedReader </span><span class="keyword">b) </span>-&gt; <span class="keyword">b.readLine() </span>+ <span class="keyword">b.readLine());</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">public </span>static <span class="keyword">String </span>processFile(<span class="keyword">BufferedReaderProcesser </span>p)throws IOException&#123;</span><br><span class="line">    try(<span class="keyword">BufferedReader </span><span class="keyword">br </span>= new <span class="keyword">BufferedReader(new </span>FileReader(<span class="string">"d:/data.txt"</span>)))&#123;</span><br><span class="line">        return p.process(<span class="keyword">br);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">public</span> interface <span class="keyword">BufferedReaderProcesser&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">String </span>process(<span class="keyword">BufferedReader </span><span class="keyword">b)throws </span>IOException<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-使用Lambda重构面向对象的设计模式"><a href="#第二节-使用Lambda重构面向对象的设计模式" class="headerlink" title="第二节 使用Lambda重构面向对象的设计模式"></a><strong>第二节 使用Lambda重构面向对象的设计模式</strong></h2><p>&emsp;&emsp;新特性的出现往往会代替旧的编程模式，如Java 5时引入的for-each，因为其稳健性和简洁性，已在大部分场合代替了显式使用迭代器的方式。Java 7时推出的&lt;&gt;菱形操作符使创建实例时无需显式使用泛型，也推动了开发者们使用类型接口进行程序设计。</p><p>&emsp;&emsp;Lambda表达式为传统设计模式所面对的问题提供了更高效和简单的新解决方案，以下会简单整理几个常见的设计模式，以及Lambda表达式对于这些设计模式的实现优化。</p><h3 id="2-1-策略模式"><a href="#2-1-策略模式" class="headerlink" title="2.1 策略模式"></a><strong>2.1 策略模式</strong></h3><blockquote><ul><li>一个代表某个算法的接口</li><li>一个或多个此接口的具体实现</li><li>一个或多个使用策略对象的客户</li></ul></blockquote><blockquote><p>客户-&gt;策略-&gt;实现</p></blockquote><p>&emsp;&emsp;我们通过传统的方式实现一个策略模式的实例——字符串校验器，用户根据需求实现策略对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口-校验策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationStratery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现-是否全部小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsAllLowerCase</span> <span class="keyword">implements</span> <span class="title">ValidationStratery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"[a-z]+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现-是否数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsNumeric</span> <span class="keyword">implements</span> <span class="title">ValidationStratery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"\\d+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口实现类-校验器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValidationStratery stratery;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Validator</span><span class="params">(ValidationStratery v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stratery = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stratery.execute(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多个使用策略对象的客户</span></span><br><span class="line">        Validator numberValidator = <span class="keyword">new</span> Validator(<span class="keyword">new</span> IsNumeric());</span><br><span class="line">        <span class="keyword">boolean</span> b1 = numberValidator.validate(<span class="string">"aaaa"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b1 : "</span> + b1);<span class="comment">//false</span></span><br><span class="line">        Validator lowerCaseValidator = <span class="keyword">new</span> Validator(<span class="keyword">new</span> IsAllLowerCase());</span><br><span class="line">        <span class="keyword">boolean</span> b2 = lowerCaseValidator.validate(<span class="string">"bbbb"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b2 : "</span> + b2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过Lambda表达式改写，代码如下。我们有函数式接口ValidationStratery，无需通过类来构建策略实现，实现的代码块通过Lambda表达式来参数化。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Validator numberValidatorL = <span class="keyword">new</span> Validator<span class="function"><span class="params">((String s) -&gt; s.matches(<span class="string">"\\d+"</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">boolean</span> <span class="title">b3</span> = <span class="title">numberValidatorL</span>.<span class="title">validate</span><span class="params">(<span class="string">"aaaa"</span>)</span>;</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"b3 : "</span> + b3)</span>;//<span class="title">false</span></span></span><br><span class="line"><span class="function"><span class="title">Validator</span> <span class="title">lowerCaseValidatorL</span> = <span class="title">new</span> <span class="title">Validator</span><span class="params">((String s) -&gt; s.matches(<span class="string">"[a-z]+"</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">boolean</span> <span class="title">b4</span> = <span class="title">lowerCaseValidatorL</span>.<span class="title">validate</span><span class="params">(<span class="string">"bbbb"</span>)</span>;</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"b4 : "</span> + b4)</span>;//<span class="title">true</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-模板方法"><a href="#2-2-模板方法" class="headerlink" title="2.2 模板方法"></a><strong>2.2 模板方法</strong></h3><p>&emsp;&emsp;有时你会希望使用某个算法，但需要对其中某些代码行进行改进从而达到想要的效果，模板方法模式可以解决这一需求。通常会使用抽象类来来表示算法，需要修改的部分方法可以通过继承来实现。</p><p>&emsp;&emsp;如下列在线银行需求，processCustomer方法搭建了在线银行算法的框架，不同的支行可以通过继承OnlineBanking类，对该方法提供差异性的实现。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在线银行：用户输入账户，应用从数据库获取用户详细信息，最终完成一些让用户满意的操作，不同分行的满意方式会不同。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">OnlineBanking</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取客户提供的ID，然后使客户满意</span></span><br><span class="line"><span class="comment">     * @param id 账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processCustomer</span>(<span class="params"><span class="keyword">int</span> id</span>)</span>&#123;</span><br><span class="line">        Customer c = DataBase.getCustomerWithId(id);</span><br><span class="line">        makeCustomerHappy(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeCustomerHappy</span>(<span class="params">Customer c</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;引入Lambda表达式，我们就可以不用再继承OnlineBanking类，只须传递不同的实现即可。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载processCustomer，引入函数式接口参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 账户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> makeCustomerHappy 不同实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">processCustomer</span><span class="params">(<span class="keyword">int</span> id, Consumer&lt;Customer&gt; makeCustomerHappy)</span></span>&#123;</span><br><span class="line">    Customer c = DataBase.getCustomerWithId(id);</span><br><span class="line">    makeCustomerHappy.accept(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> OnlineBankingNotAbs().processCustomer(<span class="number">1</span>,(Customer c) -&gt; System.out.println(<span class="string">"Hello "</span> + c.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-观察者模式"><a href="#2-3-观察者模式" class="headerlink" title="2.3 观察者模式"></a><strong>2.3 观察者模式</strong></h3><p>&emsp;&emsp;某些事件发生时（如状态转变），如果一个对象（主题）需要自动的通知多个对象（观察者），就会采用观察者模式。</p><p>&emsp;&emsp;假设我们要为Twitter实现一个定制化的通知系统，如果一些报社订阅了新闻，在新闻中包含他们关注的关键字时会得到特别通知，实现代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当接收到一条新闻时，会调用此方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tweet 内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者—纽约时报</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYTimes</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"money"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Breaking news in NY! "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者—卫报</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Guardian</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"queen"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Yet another news in London... "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者—世界报</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lemonde</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"wine"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Today cheese, wine and news! "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题—通知接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tweet 内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String tweet)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题实现—通知器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Feed</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//观察者集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        observers.forEach(o -&gt; o.notify(tweet));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Feed f = <span class="keyword">new</span> Feed();</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> NYTimes());</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> Guardian());</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> Lemonde());</span><br><span class="line">        f.notifyObservers(<span class="string">"The queen said her favourite book is Java 8 in Action!"</span>);</span><br><span class="line">        <span class="comment">//Yet another news in London... The queen said her favourite book is Java 8 in Action!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果引入Lambda表达式，我们就没必要去构建每个观察者的实现类了，无需显式的实例化观察者对象，直接传递Lambda表达式来表示需要执行的行为即可。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Feed f1 = <span class="keyword">new</span> Feed();</span><br><span class="line">f1.registerObserver<span class="function"><span class="params">((String tweet) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(tweet != <span class="literal">null</span> &amp;&amp; tweet.contains(<span class="string">"money"</span>))&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        System.out.println(<span class="string">"Breaking news in NY! "</span> + tweet);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span>;</span></span><br><span class="line"><span class="function"><span class="title">f1</span>.<span class="title">registerObserver</span><span class="params">((String tweet) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(tweet != <span class="literal">null</span> &amp;&amp; tweet.contains(<span class="string">"queen"</span>))&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        System.out.println(<span class="string">"Yet another news in London... "</span> + tweet);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span>;</span></span><br><span class="line"><span class="function"><span class="title">f1</span>.<span class="title">registerObserver</span><span class="params">((String tweet) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(tweet != <span class="literal">null</span> &amp;&amp; tweet.contains(<span class="string">"wine"</span>))&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        System.out.println(<span class="string">"Today cheese, wine and news! "</span> + tweet);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span>;</span></span><br><span class="line"><span class="function"><span class="title">f1</span>.<span class="title">notifyObservers</span><span class="params">(<span class="string">"The queen said her favourite book is Java 8 in Action!"</span>)</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果代码块很复杂，甚至还包含状态的话就不应该再使用Lambda表达式来代替类了。</p><h3 id="2-4-责任链模式"><a href="#2-4-责任链模式" class="headerlink" title="2.4 责任链模式"></a><strong>2.4 责任链模式</strong></h3><p>&emsp;&emsp;责任链模式则是一种创建处理对象序列的通用方案。一个处理对象可能需要在完成一些工作后，将结果传递给另一个对象，这个对象接着做一些工作，再转交给下个对象，以此类推。</p><p>&emsp;&emsp;通常此模式通过定义一个代表处理对象的抽象类来实现，successor记录后续对象，一旦对象完成工作，就会将工作转交给后继。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingObject</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> ProcessingObject&lt;T&gt; successor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(ProcessingObject&lt;T&gt; successor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function">T <span class="title">handle</span><span class="params">(T input)</span></span>&#123;</span><br><span class="line">        T r = handleWork(input);</span><br><span class="line">        <span class="keyword">if</span>(successor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> successor.<span class="title">handle</span><span class="params">(r)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function">T <span class="title">handleWork</span><span class="params">(T input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种实现就是模板方法设计模式，我们尝试继承并实现抽象方法，代码如下。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HeaderTextProcessing</span> <span class="keyword">extends</span> <span class="title">ProcessingObject&lt;String&gt;</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> handleWork(<span class="type">String</span> input) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"From Raoul, Mario, and Alan: "</span> + input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SpellCheckerProcessing</span> <span class="keyword">extends</span> <span class="title">ProcessingObject&lt;String&gt;</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> handleWork(<span class="type">String</span> input) &#123;</span><br><span class="line">        <span class="keyword">return</span> input.replaceAll(<span class="string">"labda"</span>,<span class="string">"lambda"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">ProcessingObject</span>&lt;<span class="type">String</span>&gt; p1 = <span class="keyword">new</span> <span class="type">HeaderTextProcessing</span>();</span><br><span class="line">        <span class="type">ProcessingObject</span>&lt;<span class="type">String</span>&gt; p2 = <span class="keyword">new</span> <span class="type">SpellCheckerProcessing</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将两个处理链接起来</span></span><br><span class="line">        p1.setSuccessor(p2);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> result = p1.handle(<span class="string">"Aren`t labdas really sexy?!!"</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(result);<span class="comment">//From Raoul, Mario, and Alan: Aren`t lambdas really sexy?!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果引入Lambda表达式，我们可以不用构建不同的处理对象，而是将对象作为UnaryOperator的一个实例，并通过andThen进行连接。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UnaryOperator&lt;<span class="built_in">String</span>&gt; headerTextProcessing = (<span class="built_in">String</span> input) -&gt; <span class="string">"From Raoul, Mario, and Alan: "</span> + input;</span><br><span class="line">UnaryOperator&lt;<span class="built_in">String</span>&gt; spellCheckerProcessing = (<span class="built_in">String</span> input) -&gt; input.replaceAll(<span class="string">"labda"</span>,<span class="string">"lambda"</span>);</span><br><span class="line"><span class="comment">//将两个方法结合起来</span></span><br><span class="line">Function&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; pipeline = headerTextProcessing.andThen(spellCheckerProcessing);</span><br><span class="line"><span class="built_in">String</span> result1 = pipeline.apply(<span class="string">"Aren`t labdas really sexy?!!"</span>);</span><br><span class="line">System.out.println(result1);<span class="comment">//From Raoul, Mario, and Alan: Aren`t lambdas really sexy?!!</span></span><br></pre></td></tr></table></figure><h3 id="2-5-工厂模式"><a href="#2-5-工厂模式" class="headerlink" title="2.5 工厂模式"></a><strong>2.5 工厂模式</strong></h3><p>&emsp;&emsp;工厂模式可以隐藏实例化的逻辑而完成对象的创建。我们不会再暴露构造函数或配置给客户，也使客户创建产品时更加容易。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"loan"</span> : <span class="keyword">return</span> <span class="keyword">new</span> Loan();<span class="comment">//贷款</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"stock"</span> : <span class="keyword">return</span> <span class="keyword">new</span> Stock();<span class="comment">//股票</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"bond"</span> : <span class="keyword">return</span> <span class="keyword">new</span> Bond();<span class="comment">//债券</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No such product "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        Product p = ProductFactory.createProduct(<span class="string">"loan"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果引入Lambda表达式，我们可以首先引用构造函数构建Map，通过函数式接口Supplier来传递构造器引用。但如果我们需要多个参数来构建产品时，这种方案的扩展性不是很好，你需要提供不同的函数接口，而无法采用统一使用一个简单接口的方式。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Product createProductL(<span class="keyword">String</span> name)&#123;</span><br><span class="line">    Supplier&lt;Product&gt; p = <span class="built_in">map</span>.<span class="built_in">get</span>(name);</span><br><span class="line">    <span class="built_in">if</span>(p != null) <span class="built_in">return</span> p.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such product "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, Supplier&lt;Product&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"loan"</span>,Loan::<span class="keyword">new</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"stock"</span>,Stock::<span class="keyword">new</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"bond"</span>,Bond::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    Product p1 = ProductFactory.createProductL(<span class="string">"loan"</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-测试Lambda表达式"><a href="#第三节-测试Lambda表达式" class="headerlink" title="第三节 测试Lambda表达式"></a><strong>第三节 测试Lambda表达式</strong></h2><hr><h2 id="第四节-调试"><a href="#第四节-调试" class="headerlink" title="第四节 调试"></a><strong>第四节 调试</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em> H  H</p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——重构、测试和调试
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>流（四）并行化处理</title>
    <link href="http://linyishui.top/2019092501.html"/>
    <id>http://linyishui.top/2019092501.html</id>
    <published>2019-09-25T10:38:14.000Z</published>
    <updated>2019-11-22T10:55:30.355Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流（四）并行化处理"><a href="#流（四）并行化处理" class="headerlink" title="流（四）并行化处理"></a><strong>流（四）并行化处理</strong></h1><h2 id="第九节-并行化数据处理"><a href="#第九节-并行化数据处理" class="headerlink" title="第九节 并行化数据处理"></a><strong>第九节 并行化数据处理</strong></h2><p>&emsp;&emsp;在早期版本中，并行处理数据集合非常麻烦。第一，我们要把包含数据的数据结构分成若干子部分。第二，我们要给每个子部分分配一个独立的线程。第三，我们需要在恰当的时候对它们进行同步来避免竞争条件，等待所有线程完成，最后把这些结果合并。</p><p>&emsp;&emsp;Java 7时引入了<strong>分支/合并框架</strong>，使这些操作更稳定。</p><h3 id="9-1-并行流"><a href="#9-1-并行流" class="headerlink" title="9.1 并行流"></a><strong>9.1 并行流</strong></h3><p>&emsp;&emsp;<strong>并行流就是一个把内容分成多个数据块，并用不同线程分别处理每个数据块的流</strong>。通过parallelStream()方法把集合转换为并行流。通过parallel()方法将顺序流转为并行流。sequential()方法可以使并行流转为顺序流。所以结合这两个方法可以细化的控制哪些操作并行执行哪些操作顺序执行，但最后一次会决定整个流水线何种执行。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算从1到给定数字的和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> sequentialSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(<span class="number">1</span>L, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .reduce(<span class="number">0</span>L, <span class="keyword">Long</span>::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代计算从1到给定数字的和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> iterativeSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">1</span>L;i &lt;= n;i++)&#123;</span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并行计算从1到给定数字的和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> parallelSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(<span class="number">1</span>L, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .parallel() <span class="comment">//将流转为并行流</span></span><br><span class="line">            .reduce(<span class="number">0</span>L, <span class="keyword">Long</span>::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;parallel()只是改变了一个布尔标识，流本身不会有其他变化。</p><p>&emsp;&emsp;并行流的内部使用了默认的ForkJoinPool，默认线程数量为处理器数量(Runtime.getRuntime().availableProcessors()获取)。</p><h4 id="对比并行流和顺序流性能"><a href="#对比并行流和顺序流性能" class="headerlink" title="对比并行流和顺序流性能"></a><strong>对比并行流和顺序流性能</strong></h4><p>&emsp;&emsp;测试并行流性能，代码如下。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Sequential sum done in "</span> + measureSumPerf(ParallelTest::sequentialSum, <span class="number">10</span>_000_000) + <span class="string">" mscs"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Iterative sum done in "</span> + measureSumPerf(ParallelTest::iterativeSum, <span class="number">10</span>_000_000) + <span class="string">" mscs"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Parallel sum done in "</span> + measureSumPerf(ParallelTest::parallelSum, <span class="number">10</span>_000_000) + <span class="string">" mscs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> measureSumPerf(<span class="function"><span class="keyword">Function</span>&lt;<span class="title">Long</span>, <span class="title">Long</span>&gt; <span class="title">adder</span>, <span class="title">long</span> <span class="title">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> fastest = <span class="keyword">Long</span>.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;<span class="comment">//测试运行10次</span></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> sum = adder.apply(n);<span class="comment">//执行函数</span></span><br><span class="line">        <span class="keyword">long</span> duration = (System.nanoTime() - start) / <span class="number">1</span>_000_000;<span class="comment">//取运行时间的毫秒值</span></span><br><span class="line">        <span class="keyword">if</span>(duration &lt; fastest)<span class="comment">//检查执行是否是最快的一个</span></span><br><span class="line">            fastest = duration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下。传统for循环迭代版本相比顺序流要快很多，因为它更底层以及不需要对原始类型做任何装箱/拆箱操作。但并行流却意外的比顺序流还要多消耗一倍时间。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sequential</span> <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">181</span> mscs</span><br><span class="line">Iterative <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">5</span> mscs</span><br><span class="line">Parallel <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">378</span> mscs</span><br></pre></td></tr></table></figure><blockquote><p>并行版本慢的原因：</p><ul><li>iterate生成的是装箱的对象，必须要拆箱才能求和</li><li>很难吧iterate分成多个独立块执行（在实现斐波那契数列有提到iterate不利于并行化）</li></ul></blockquote><p>&emsp;&emsp;iterate迭代操作很难并行化，每次应用时都要依赖于前一次应用的结果。所以我们实际上并没有使操作并行，每次还要把求和操作分配到另一个线程，额外增加了开销。</p><p>&emsp;&emsp;如何优化上述代码使其达到并行化效果呢？首先我们通过LongStream.rangeClosed方法直接生成原始类型long数值，对比顺序流效率可以感受拆箱的开销。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有装箱的求和函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> rangedSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>, n).reduce(<span class="number">0</span>L, <span class="keyword">Long</span>::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下，数值流避免了非针对性流这些没必要的自动装箱/拆箱操作，最终明显的降低了开销，选择合适的数据结构比并行化算法更显得重要。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Range</span> <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">7</span> mscs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;尝试把数值流应用于并行流，再观察开销。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并行没有装箱的计算从1到给定数字的和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> parallelRangedSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>, n)</span><br><span class="line">            .parallel()</span><br><span class="line">            .reduce(<span class="number">0</span>L, <span class="keyword">Long</span>::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下，终于并行结果要快于顺序执行了，因为这次终于分开了数据块进行了并行运算。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parallel <span class="built_in">range</span> <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">2</span> mscs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;并行化其实有额外的代价，需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，把操作的结果合并到一个值等。而且在多核之间移动数据也有很大的开销，所以最重要的是要<strong>保证在内核中并行执行工作的时间要比在内核间传输数据的时间长</strong>，要合理的选择并行化。</p><h4 id="正确使用并行流"><a href="#正确使用并行流" class="headerlink" title="正确使用并行流"></a><strong>正确使用并行流</strong></h4><p>&emsp;&emsp;错误的运用并行流的主要原因是使用的算法改变了某些共享状态。</p><p>&emsp;&emsp;下述代码sideEffectSum方法类似于我们常用的指令式迭代求和，其算法本质上就是顺序的，因为累加器的total变量每次访问都会出现竞争，我们可以尝试并行化它，看最终执行效果。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过累加器类对前n个自然数求和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> sideEffectSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">        Accumulator accumulator = <span class="keyword">new</span> Accumulator();</span><br><span class="line">        LongStream.rangeClosed(<span class="number">1</span>, n).<span class="keyword">forEach</span>(accumulator::add);</span><br><span class="line">        <span class="keyword">return</span> accumulator.total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过累加器类对前n个自然数求和（并行化）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> sideEffectParallelSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">        Accumulator accumulator = <span class="keyword">new</span> Accumulator();</span><br><span class="line">        LongStream.rangeClosed(<span class="number">1</span>, n).parallel().<span class="keyword">forEach</span>(accumulator::add);</span><br><span class="line">        <span class="keyword">return</span> accumulator.total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 累加器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> void add(<span class="keyword">long</span> value)&#123;</span><br><span class="line">        total += value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下，并行时每次执行结果都是错误值，因为我们并行化的多线程处理操作都不是原子操作，<strong>根源就在于forEach所调用的函数会改变多线程共享变量的状态</strong>，所以并行化时应该避免共享可变状态。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Result</span>&lt;<span class="number">1</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">2</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">3</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">4</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">5</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">6</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">7</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">8</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">9</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">10</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line">Side effect sum done <span class="keyword">in</span> <span class="number">7</span> mscs</span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">1</span>&gt;: <span class="number">8130267751928</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">2</span>&gt;: <span class="number">7068326376926</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">3</span>&gt;: <span class="number">8906998285116</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">4</span>&gt;: <span class="number">8213474338667</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">5</span>&gt;: <span class="number">9907376000941</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">6</span>&gt;: <span class="number">8850837255635</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">7</span>&gt;: <span class="number">7447244528787</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">8</span>&gt;: <span class="number">8092934175612</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">9</span>&gt;: <span class="number">8285103974383</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">10</span>&gt;: <span class="number">7964325408454</span></span><br><span class="line">Side effect <span class="keyword">parallel</span> sum done <span class="keyword">in</span> <span class="number">88</span> mscs</span><br></pre></td></tr></table></figure><h4 id="高效使用并行流"><a href="#高效使用并行流" class="headerlink" title="高效使用并行流"></a><strong>高效使用并行流</strong></h4><p>&emsp;&emsp;给出准确的使用并行流建议是不现实的，不同的场景和需求都会有无法定量的差异存在。</p><blockquote><ul><li><strong>多做测试</strong>：顺序流转为并行流是很容易的，但并行流未必比顺序流更快，所以请多测试。</li><li><strong>注意装箱</strong>：自动装箱和拆箱操作会大大降低性能，请多留意。</li><li><strong>避免有序</strong>：一些操作注定在并行流上效率要差于顺序流，特别是limit和findFirst等依赖于元素顺序的操作，如findAny因为不需要有序就要比findFirst快，unordered方法可以把有序流转为无序流，在满足有些需求的情况下能提高这些操作的性能。</li><li><strong>单次成本</strong>：假设N是元素总数，Q是单个元素通过流水线的成本，Q值越大则表示并行化更高效的可能性更大，我们要注意流水线的总计算成本。</li><li><strong>避免小数据</strong>：小量数据对于并行化总不会是一个好的应用场景，带来的好处抵不上额外开销。</li><li><strong>数据结构的分解效率</strong>：一些数据结构的拆分效率需要额外注意，如ArrayList的拆分就比LinkedList高效，实现Spliterator可以掌握分解流程。</li><li><strong>流与中间操作的影响</strong>：流自身的特点，以及流水线的中间操作修改流的方式，都会影响到分解过程的性能。如一个SIZED流可以分为大小相等的两块，每块都可以高效并行处理，但筛选操作丢弃的个数却无法预测，会导致流自身大小未知。</li><li><strong>终端合并的代价</strong>：要考虑终端操作合并步骤的代价，如果最后代价太大，可能会超过并行带来的性能提升。</li></ul></blockquote><table><thead><tr><th style="text-align:left">源</th><th style="text-align:center">可分解性</th></tr></thead><tbody><tr><td style="text-align:left">ArrayList</td><td style="text-align:center">极佳</td></tr><tr><td style="text-align:left">LinkedList</td><td style="text-align:center">差</td></tr><tr><td style="text-align:left">IntStream.range</td><td style="text-align:center">极佳</td></tr><tr><td style="text-align:left">Stream.iterate</td><td style="text-align:center">差</td></tr><tr><td style="text-align:left">HashSet</td><td style="text-align:center">好</td></tr><tr><td style="text-align:left">TreeSet</td><td style="text-align:center">好</td></tr></tbody></table><h3 id="9-2-分支-合并框架"><a href="#9-2-分支-合并框架" class="headerlink" title="9.2 分支/合并框架"></a><strong>9.2 分支/合并框架</strong></h3><p>&emsp;&emsp;分支/合并框架的目的是以递归的方式将可以并行的任务拆分为更小的子任务，将每个子任务的结果合并成整体结果。它是ExecutorService接口的一个实现，把子任务分配给线程池（ForkJoinPool）中的工作线程。</p><h4 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a><strong>RecursiveTask</strong></h4><p>&emsp;&emsp;R是并行化任务产生的结果类型，若任务不返回结果，则是RecursiveAction类型。</p><p>&emsp;&emsp;定义RecursiveTask只须实现compute方法，此方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。</p><p>&emsp;&emsp;此方法的实现如下述伪代码，只不过是著名的分治算法的并行版本。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(任务足够小或不可分)</span></span>&#123;</span><br><span class="line">    顺序计算该任务</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以实现一个分支合并任务进行并行求和，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支合并框架进行并行求和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] numbers;<span class="comment">//要进行求和的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;<span class="comment">//子任务处理的数组起始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;<span class="comment">//子任务处理的数组终止位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD = <span class="number">10</span>_000;<span class="comment">//停止分解子任务的数组大小</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = start - end;<span class="comment">//要进行求和的部分大小</span></span><br><span class="line">        <span class="keyword">if</span>(length &lt;= THRESHOLD)&#123;<span class="comment">//如果大小小于或等于阈值，就执行顺序计算结果</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">computeSequentially</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个子任务为数组的前一半求和</span></span><br><span class="line">        ForkJoinSumCalculator leftTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers,start,start + length/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//利用另一个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        <span class="comment">//创建一个子任务为数组的后一半求和</span></span><br><span class="line">        ForkJoinSumCalculator rightTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers,start + length/<span class="number">2</span>,end);</span><br><span class="line">        <span class="comment">//同步执行第二个子任务，有可能允许进一步递归划分</span></span><br><span class="line">        Long rightResult = rightTask.compute();</span><br><span class="line">        <span class="comment">//读取第一个子任务的结果，如果未完成则等待</span></span><br><span class="line">        Long leftResult = leftTask.join();</span><br><span class="line">        <span class="comment">//任务结果为两个子任务结果合并</span></span><br><span class="line">        <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺序求和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">long</span> <span class="title">computeSequentially</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt; end;i++)&#123;</span><br><span class="line">            sum += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers)</span></span>&#123;<span class="comment">//公共构造器用于创建主任务</span></span><br><span class="line">        <span class="keyword">this</span>(numbers,<span class="number">0</span>,numbers.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;<span class="comment">//私有构造器用于以递归的方式创建子任务</span></span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后再通过forkJoinSum方法调用算法进行并行计算。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分支合并框架对前n个自然数求和</span></span><br><span class="line"><span class="comment"> * @param n 值</span></span><br><span class="line"><span class="comment"> * @return 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> forkJoinSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="comment">//LongStream生成前n个自然数的数组</span></span><br><span class="line">    <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1</span>, n).toArray();</span><br><span class="line">    <span class="comment">//根据数组实例化ForkJoinTask</span></span><br><span class="line">    ForkJoinTask&lt;<span class="keyword">Long</span>&gt; <span class="keyword">task</span> = <span class="keyword">new</span> ForkJoinSumCalculator(numbers);</span><br><span class="line">    <span class="comment">//实例化ForkJoinPool并把任务交给其调用方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool().invoke(<span class="keyword">task</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下，相比并行流版本要慢一些，因为要把整个数字流都放入一个long[]后才可以在ForkJoinSumCalculator任务中调用数组。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fork <span class="keyword">join</span> <span class="keyword">sum</span> done <span class="keyword">in</span> <span class="number">47</span> mscs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际应用中，使用多个ForkJoinPool没有什么意义，所以一般将其实例静态化成为单例，方便在软件中重用。</p><h4 id="正确使用分支-合并框架"><a href="#正确使用分支-合并框架" class="headerlink" title="正确使用分支/合并框架"></a><strong>正确使用分支/合并框架</strong></h4><blockquote><ul><li><strong>阻塞</strong>：对一个任务调用join方法会阻塞调用者，直到任务执行出结果。所以最好在两个任务的计算都开始后再调用它，否则每个子任务间要相互等待。</li><li><strong>invoke</strong>：不要在RecursiveTask内部使用ForkJoinPool的invoke方法，只有顺序代码才应该由invoke方法启动来进行并行计算，应该始终直接调用compute或fork方法。</li><li><strong>fork</strong>：对子任务调用fork方法可以把它加入ForkJoinPool，但要注意同时对两个子任务调用fork效率会比直接对一个调用compute低。这样可以为一个子任务重用同一线程，从而避免了线程池中多分配一个任务所造成的开销。</li><li><strong>测试</strong>：对分支合并框架的并行计算进行测试会有些麻烦，比如我们常用IDE的栈跟踪来寻找问题，但分支合并计算中调用compute的线程并不是概念上的调用方，后者是调用fork的那个。</li><li><strong>合理使用</strong>：和并行流一样，多核环境使用分支合并框架不一定会比顺序计算快。只有一个任务可以分解成多个独立的子任务，才能使并行化时性能有提升。子任务的运行时间应该大于拆分子任务所消耗的时间。比如将输入输出放到一个子任务，把计算放到另一个子任务，这样就可以同时进行二者。还有分支合并框架需要“预热”或者说执行几遍才会被JIT编译器优化，所以测量性能时要注意多跑几遍。编译器内置的优化可能会给顺序的版本带来一些优势。</li></ul></blockquote><p>&emsp;&emsp;使用分支合并框架，我们需要制定一个策略：决定任务是进一步拆分还是已小到可以顺序求值。</p><h4 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a><strong>工作窃取</strong></h4><p>&emsp;&emsp;在求和例子中，我们设定求和数组达到1万个项目就不再创建子任务，这个策略比较随意，假设我们有一个1000万项目的数组，那么就需要开辟1000个子任务，而我们的PC可能只有4核。理想的情况下，我们划分的每个子任务都有相同的运行时间，但实际会因为划分策略效率低，或其他不可预知的原因导致子任务间运行差别很大。</p><p>&emsp;&emsp;分支合并框架采用一种叫<strong>工作窃取</strong>的技术来解决这一问题。子任务差不多会被平均分配到ForkJoinPool的所有线程上，每个线程都会为分配的任务保存一个双向链式队列，每完成一个任务就会从队列取出下一个任务执行，所以有些线程会提前完成分配的任务，这时此线程会随机选择一个线程，然后从其队列尾巴上“偷走”一个任务。所以这种模式下，更多的子任务有利于工作线程间平衡负载。</p><p>&emsp;&emsp;工作窃取被用来在线程池中的工作线程间重新分配和平衡任务。闲置线程会不断地尝试窃取别的线程的任务，一个线程中的任务切分为两个子任务时就会被一个闲置线程拿走一个，这个过程可以不断递归，直到规定子任务应顺序执行的条件为真。</p><h3 id="9-3-Spliterator"><a href="#9-3-Spliterator" class="headerlink" title="9.3 Spliterator"></a><strong>9.3 Spliterator</strong></h3><p>&emsp;&emsp;我们在使用并行流时并没有指定拆分多个任务的逻辑，所以应该有一种自动机制来帮助我们做了这一工作。<strong>可分迭代器-Spliterator</strong>，和迭代器-Iterator一样都用于遍历数据源中的元素，区别就是Spliterator专门为并行执行而设计。Java 8为集合框架包含的所有数据结构提供了一个默认的Spliterator实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="comment">//T是Spliterator遍历元素的类型</span></span><br><span class="line">    <span class="comment">//类似于Iterator，顺序的遍历Spliterator中的元素，如果还有其他元素需要遍历返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">    <span class="comment">//可以把一些元素划分给另一个Spliterator，并使其并行处理</span></span><br><span class="line">    <span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//估计还需要遍历的元素个数，未必准确</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//此迭代器本身特性ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Spliterator还有一个功能是在第一次遍历、第一次拆分或第一次查询估计大小时绑定元素的数据源，而不是在创建时绑定。这样的Spliterator被称为<strong>延迟绑定</strong>的Spliterator。</p><h4 id="拆分过程"><a href="#拆分过程" class="headerlink" title="拆分过程"></a><strong>拆分过程</strong></h4><p>&emsp;&emsp;将Stream拆分为多个部分的算法是一个递归过程。</p><blockquote><ol><li>对一个Spliterator调用trySplit，生成第二个Spliterator</li><li>对这两个Spliterator调用trySplit，就有了四个Spliterator。</li><li>对每一个Spliterator不断地分割，直到trySplit返回null表示数据结构不能再分割了。</li><li>最终所有的Spliterator调用trySplit都返回null，终止。</li></ol></blockquote><p>&emsp;&emsp;拆分过程受Spliterator的特性的影响</p><h4 id="Spliterator的特性"><a href="#Spliterator的特性" class="headerlink" title="Spliterator的特性"></a><strong>Spliterator的特性</strong></h4><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ORDERED</td><td style="text-align:left">元素有既定的顺序(如List)，因此Spliterator在遍历和划分时也会遵守这一顺序</td></tr><tr><td style="text-align:left">DISTINCT</td><td style="text-align:left">对于任意一对遍历过的元素x和y，x.equals(y)返回false</td></tr><tr><td style="text-align:left">SORTED</td><td style="text-align:left">遍历的元素按照一个预定义的顺序排序</td></tr><tr><td style="text-align:left">SIZED</td><td style="text-align:left">该Spliterator由一个已知大小的源建立(如Set)，因此estimatedSize()返回的是准确值</td></tr><tr><td style="text-align:left">NONNULL</td><td style="text-align:left">保证遍历的元素不会为null</td></tr><tr><td style="text-align:left">IMMUTABLE</td><td style="text-align:left">Spliterator的数据源不能修改，意味着遍历时不能添加、删除或修改任何元素</td></tr><tr><td style="text-align:left">CONCURRENT</td><td style="text-align:left">Spliterator的数据源可以被其他线程同时修改而无需同步</td></tr><tr><td style="text-align:left">SUBSIZED</td><td style="text-align:left">Spliterator和所有由它拆分出来的Spliterator都是SIZED</td></tr></tbody></table><h4 id="自定义Spliterator"><a href="#自定义Spliterator" class="headerlink" title="自定义Spliterator"></a><strong>自定义Spliterator</strong></h4><p>&emsp;&emsp;假设需要统计一个字符串的单词数（任意空格为分隔符），我们首先用传统的迭代版本实现。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计字符串中单词个数</span></span><br><span class="line"><span class="comment"> * @param s 字符串</span></span><br><span class="line"><span class="comment"> * @return 单词个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> countWordsIteratively(<span class="keyword">String</span> s)&#123;</span><br><span class="line">    <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">boolean</span> lastSpace = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">char</span> c : s.toCharArray())&#123;<span class="comment">//逐个遍历字符串的所有字符</span></span><br><span class="line">        <span class="keyword">if</span>(Character.isWhitespace(c))&#123;</span><br><span class="line">            lastSpace = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lastSpace) counter++;<span class="comment">//上个字符是空格，而当前字符不是空格，计数器+1</span></span><br><span class="line">            lastSpace = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统迭代版本</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> SENTENCE = <span class="string">" Nel   mezzo del cammin  di nostra  vita "</span> +</span><br><span class="line">            <span class="string">"mi  ritrovai in una  selva oscura"</span> +</span><br><span class="line">            <span class="string">" che la  dritta via era   smarrita"</span>;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Found "</span> + countWordsIteratively(SENTENCE) + <span class="string">" words"</span>);<span class="comment">//Found 19 words</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们尝试用函数式的风格来重写单词计数器，因为归约时必须要保存两个状态，所以只能创建一个WordCounter类来封装状态，每次遍历到一个元素会调用accumulate方法，定义了WordCounter如何更新状态（我们并不做状态修改，而选择了用新的WordCounter来存储新的状态），combine方法合并流的两个子部分的结果。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> counter;<span class="comment">//当前统计数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> lastSpace;<span class="comment">//上个字符是否空格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">WordCounter <span class="title">accumulate</span><span class="params">(Character c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isWhitespace(c))&#123;<span class="comment">//如果此字符是空格</span></span><br><span class="line">            <span class="comment">//上个字符是空格，返回当前计数器；</span></span><br><span class="line">            <span class="comment">// 上个字符不是空格，返回新的计数器，并标记lastSpace</span></span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">this</span> : <span class="keyword">new</span> WordCounter(counter, <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//此字符不是空格</span></span><br><span class="line">            <span class="comment">//上个字符是空格，返回新计数器，统计+1，重置lastSpace；</span></span><br><span class="line">            <span class="comment">// 上个字符不是空格，返回当前计数器</span></span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">new</span> WordCounter(counter+<span class="number">1</span>, <span class="keyword">false</span>) : <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">WordCounter <span class="title">combine</span><span class="params">(WordCounter wordCounter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WordCounter(counter + wordCounter.counter,wordCounter.lastSpace);<span class="comment">//lastSpace不重要</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过自定义WordCounter对字符流进行计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stream 流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单词个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">countWords</span><span class="params">(Stream&lt;Character&gt; stream)</span></span>&#123;</span><br><span class="line">        WordCounter wordCounter = stream.reduce(<span class="keyword">new</span> WordCounter(<span class="number">0</span>,<span class="keyword">true</span>),</span><br><span class="line">                WordCounter::accumulate,</span><br><span class="line">                WordCounter::combine);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> wordCounter.<span class="title">getCounter</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//函数式版本</span></span><br><span class="line">        <span class="comment">//首先把字符串转换为流</span></span><br><span class="line">        Stream&lt;Character&gt; stream = IntStream.range(<span class="number">0</span>,SENTENCE.length()).mapToObj(SENTENCE::charAt);</span><br><span class="line">        <span class="comment">//然后进行归约计算字数</span></span><br><span class="line">        <span class="comment">//保留两个变量状态：当前统计数目，上个字符是否空格</span></span><br><span class="line">        System.out.println(<span class="string">"Found "</span> + countWords(stream) + <span class="string">" words"</span>);<span class="comment">//Found 19 words</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们尝试把WordCounter并行的工作，但结果却不正确，原因就是字符串会在任意位置拆分，所以有些词会被拆分为两个词，所以并行流导致了结果出错。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; stream1 = IntStream.<span class="keyword">range</span>(0,SENTENCE.<span class="built_in">length</span>()).mapToObj(SENTENCE::charAt);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"Found "</span> + countWords(stream1.parallel()) + <span class="string">" words"</span>);<span class="comment">//Found 41 words</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解决这个问题我们需要确保String只在词尾切分，所以要改变流的切分方式，只能自定义Spliterator，让这个迭代器只会在两个词间进行切分。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词切分迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> WordCounterSpliterator implements Spliterator&lt;Character&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentChar = <span class="number">0</span>;<span class="comment">//当前坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean tryAdvance(Consumer&lt;? <span class="keyword">super</span> Character&gt; action) &#123;</span><br><span class="line">        action.accept(<span class="built_in">string</span>.charAt(currentChar++));<span class="comment">//处理当前字符串</span></span><br><span class="line">        <span class="keyword">return</span> currentChar &lt; <span class="built_in">string</span>.length();<span class="comment">//若还有字符串要处理，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Spliterator&lt;Character&gt; trySplit() &#123;</span><br><span class="line">        <span class="keyword">int</span> currentSize = <span class="built_in">string</span>.length() - currentChar;</span><br><span class="line">        <span class="keyword">if</span>(currentSize &lt; <span class="number">10</span>)&#123;<span class="comment">//此时切分的已足够小，返回null进行顺序处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始试探拆分的位置为当前字符串中间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> splitPos = currentSize / <span class="number">2</span> + currentChar; splitPos &lt; <span class="built_in">string</span>.length() ; splitPos++)&#123;</span><br><span class="line">            <span class="comment">//让拆分位置前进到下一个空格</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isWhitespace(<span class="built_in">string</span>.charAt(splitPos)))&#123;</span><br><span class="line">                <span class="comment">//创建一个新的WordCounterSpliterator来解析开始到拆分位置的部分</span></span><br><span class="line">                Spliterator&lt;Character&gt; spliterator = <span class="keyword">new</span> WordCounterSpliterator(<span class="built_in">string</span>.substring(currentChar,splitPos));</span><br><span class="line">                <span class="comment">//再把此Spliterator的起始位置设置为拆分位置</span></span><br><span class="line">                currentChar = splitPos;</span><br><span class="line">                <span class="keyword">return</span> spliterator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> estimateSize() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.length() - currentChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> characteristics() &#123;</span><br><span class="line">        <span class="keyword">return</span> ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> WordCounterSpliterator(String <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">string</span> = <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        Spliterator&lt;Character&gt; spliterator = <span class="keyword">new</span> WordCounterSpliterator(SENTENCE);</span><br><span class="line">        <span class="comment">//第二个参数为true表示创建并行流</span></span><br><span class="line">        Stream&lt;Character&gt; stream2 = StreamSupport.stream(spliterator, <span class="literal">true</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Found "</span> + countWords(stream2) + <span class="string">" words"</span>);<span class="comment">//Found 19 words</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;tryAdvance方法把字符串当前字符传给了Consumer，并使当前坐标+1。Consumer把要处理的字符传给了归约函数accumulate。</p><p>&emsp;&emsp;trySplit方法设定了下限10，然后把试探的拆分位置设在当前字符串中间，然后找到空格就创建一个新的Spliterator来遍历从当前位置到拆分位置的子串；把当前位置设置为拆分位置，因为之前的部分将由新的Spliterator处理。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——第四节，内容包括：并行流，分支/合并框架(RecursiveTask、正确使用、工作窃取)，Spliterator(拆分过程、特性、自定义Spliterator)。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
      <category term="spliterator" scheme="http://linyishui.top/tags/spliterator/"/>
    
  </entry>
  
  <entry>
    <title>流（三）收集器</title>
    <link href="http://linyishui.top/2019092401.html"/>
    <id>http://linyishui.top/2019092401.html</id>
    <published>2019-09-24T10:38:07.000Z</published>
    <updated>2019-11-22T10:56:06.227Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流（三）收集器"><a href="#流（三）收集器" class="headerlink" title="流（三）收集器"></a><strong>流（三）收集器</strong></h1><h2 id="第八节-用流收集数据"><a href="#第八节-用流收集数据" class="headerlink" title="第八节 用流收集数据"></a><strong>第八节 用流收集数据</strong></h2><h3 id="8-1-收集器"><a href="#8-1-收集器" class="headerlink" title="8.1 收集器"></a><strong>8.1 收集器</strong></h3><p>&emsp;&emsp;收集器简洁灵活的定义了collect用来生成结果集合的标准，collect操作本质是一个归约操作，遍历流中的每个元素，进行转换操作，将结果累积到一个数据结构中并最终输出。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">R</span>, A&gt; <span class="keyword">R</span> collect(Collector&lt;? super T, A, <span class="keyword">R</span>&gt; collector);</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">R</span>&gt; <span class="keyword">R</span> collect(Supplier&lt;<span class="keyword">R</span>&gt; supplier,</span><br><span class="line">              BiConsumer&lt;<span class="keyword">R</span>, ? super T&gt; accumulator,</span><br><span class="line">              BiConsumer&lt;<span class="keyword">R</span>, <span class="keyword">R</span>&gt; combiner);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Collector接口的实现决定了如何对流进行归约操作，Collectors提供了许多常用的静态工厂方法，主要提供了三个功能：将流元素归约为一个值，元素分组，元素分区。</p><h3 id="8-2-归约和汇总"><a href="#8-2-归约和汇总" class="headerlink" title="8.2 归约和汇总"></a><strong>8.2 归约和汇总</strong></h3><p>&emsp;&emsp;具体使用场景可以参考以下实例代码。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计：统计菜单有多少道菜肴</span></span><br><span class="line"><span class="keyword">long</span> dishedNum = menu.stream().<span class="keyword">collect</span>(Collectors.counting());</span><br><span class="line"><span class="keyword">long</span> dishedNum1 = menu.stream().<span class="keyword">count</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//求最大/最小值：找出热量最高的菜肴</span></span><br><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);</span><br><span class="line">Optional&lt;Dish&gt; mostCaloriesDish = menu.stream().<span class="keyword">collect</span>(Collectors.maxBy(dishCaloriesComparator));</span><br><span class="line">Optional&lt;Dish&gt; mostCaloriesDish1 = menu.stream().max(dishCaloriesComparator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//汇总求和：求所有菜肴总热量</span></span><br><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().<span class="keyword">collect</span>(Collectors.summingInt(Dish::getCalories));</span><br><span class="line"><span class="comment">////这种写法最简洁，且性能最好，避免了自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> totalCalories1 = menu.stream().mapToInt(Dish::getCalories).sum();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//汇总求平均：求所有菜肴热量平均值</span></span><br><span class="line"><span class="keyword">double</span> averageCalories = menu.stream().<span class="keyword">collect</span>(Collectors.averagingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次遍历求所有汇总结果</span></span><br><span class="line">IntSummaryStatistics statistics = menu.stream().<span class="keyword">collect</span>(Collectors.summarizingInt(Dish::getCalories));</span><br><span class="line">System.out.<span class="keyword">println</span>(statistics);<span class="comment">//IntSummaryStatistics&#123;count=9, sum=4200, min=120, average=466.666667, max=800&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接字符串</span></span><br><span class="line">String shortMenu = menu.stream().map(Dish::getName).<span class="keyword">collect</span>(Collectors.joining());</span><br><span class="line">System.out.<span class="keyword">println</span>(shortMenu);<span class="comment">//porkbeefchickenfrench friesriceseason fruitpizzaprawnssalmon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加分隔符</span></span><br><span class="line">String shortMenu1 = menu.stream().map(Dish::getName).<span class="keyword">collect</span>(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.<span class="keyword">println</span>(shortMenu1);<span class="comment">//pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面都是常用情况的便捷工具，Collectors提供的reducing()则需要三个参数(初始值，转换函数，操作)。有一个重载的单参数reducing()，流中第一个元素作为起点，转换函数为默认输入参数。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int totalCalories3 = menu.stream<span class="function"><span class="params">()</span>.<span class="title">collect</span><span class="params">(Collectors.reducing(<span class="number">0</span>,Dish::getCalories,(i,j) -&gt; i + j))</span>;</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="title">totalCalories4</span> = <span class="title">menu</span>.<span class="title">stream</span><span class="params">()</span>.<span class="title">map</span><span class="params">(Dish::getCalories)</span>.<span class="title">reduce</span><span class="params">(<span class="number">0</span>,(i,j) -&gt; i + j)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//单参数<span class="title">reducing</span><span class="params">()</span>，</span></span><br><span class="line"><span class="function"><span class="title">Optional</span>&lt;<span class="title">Dish</span>&gt; <span class="title">mostCaloriesDish2</span> = <span class="title">menu</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        .<span class="title">collect</span><span class="params">(Collectors.reducing(</span></span></span><br><span class="line"><span class="function"><span class="params">                (d1,d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 :d2))</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], b[<span class="number">0</span>]); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</span><br><span class="line">reducing(BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OptionalBox</span> <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> present = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (present) &#123;</span><br><span class="line">                value = op.apply(value, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                value = t;</span><br><span class="line">                present = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;T, OptionalBox, Optional&lt;T&gt;&gt;(</span><br><span class="line">            OptionalBox::<span class="keyword">new</span>, OptionalBox::accept,</span><br><span class="line">            (a, b) -&gt; &#123; <span class="keyword">if</span> (b.present) a.accept(b.value); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; Optional.ofNullable(a.value), CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="collect和reduce的区别"><a href="#collect和reduce的区别" class="headerlink" title="collect和reduce的区别"></a><strong>collect和reduce的区别</strong></h4><p>&emsp;&emsp;二者往往可以实现相同的功能，reduce方法旨在把两个值结合起来生成一个新值，是一个不可变的归约。collect方法则相反，设计上就是要改变容器，从而累积要输出的结果。还有一点就是collect方法相比reduce更适合并行工作。</p><h3 id="8-3-分组"><a href="#8-3-分组" class="headerlink" title="8.3 分组"></a><strong>8.3 分组</strong></h3><p>&emsp;&emsp;Collectors提供了静态工厂方法groupingBy，参数Function叫<strong>分类函数</strong>，用来把流中元素分成不同的组。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="built_in">Type</span>, <span class="built_in">List</span>&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(Collectors.groupingBy(Dish::getType));</span><br><span class="line">dishesByType.forEach((k,v) -&gt; System.out.println(k + <span class="string">"-&gt;"</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">//groupingBy</span></span><br><span class="line">public <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, <span class="built_in">Map</span>&lt;K, <span class="built_in">List</span>&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际开发中，用来分类的Type可能不存在，但我们可以<strong>自定义</strong>，并用Lambda表达式来描述逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以热量分组</span></span><br><span class="line">Map&lt;CaloricLevel,List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream().collect(Collectors.groupingBy(</span><br><span class="line">    dish -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">    &#125;</span><br><span class="line">));</span><br><span class="line">dishesByCaloricLevel.forEach((k,v) -&gt; System.<span class="keyword">out</span>.println(k + <span class="string">"-&gt;"</span> + v));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>多级分组</strong>需要调用双参数版本的groupingBy方法，可以扩展至任意层级的树形结构Map。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多级分组</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="built_in">Type</span>, <span class="built_in">Map</span>&lt;CaloricLevel, <span class="built_in">List</span>&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =</span><br><span class="line">        menu.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Dish::getType,</span><br><span class="line">                        Collectors.groupingBy(dish -&gt;&#123;</span><br><span class="line">                            <span class="keyword">if</span>(dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                        &#125;))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> &lt;T, K, A, D&gt;</span><br><span class="line">Collector&lt;T, ?, <span class="built_in">Map</span>&lt;K, D&gt;&gt; groupingBy(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> K&gt; classifier,</span><br><span class="line">                                      Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>按子组收集数据</strong>: groupingBy方法的第二个参数可以是任意Collector的实现，不一定非要是groupingBy。collectingAndThen方法则可以在收集器完成处理后转换返回类型，需要参数：收集器和转换函数，最后返回一个收集器。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分类汇总求和</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="keyword">Type</span>, Long&gt; typesCount =</span><br><span class="line">        menu.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Dish<span class="type">::getType</span>,Collectors.counting()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//分类汇总取最大值</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="keyword">Type</span>, Optional&lt;Dish&gt;&gt; mostCaloricByType =</span><br><span class="line">        menu.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Dish<span class="type">::getType</span>,Collectors.maxBy(Comparator.comparing(Dish<span class="type">::getCalories</span>))));</span><br><span class="line"></span><br><span class="line"><span class="comment">//收集后转换类型</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="keyword">Type</span>, Dish&gt; mostCaloricByType1 =</span><br><span class="line">        menu.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Dish<span class="type">::getType</span>,Collectors.collectingAndThen(</span><br><span class="line">                        Collectors.maxBy(Comparator.comparing(Dish<span class="type">::getCalories</span>)),Optional<span class="type">::get</span>)));</span><br><span class="line">mostCaloricByType1.forEach((k,v) -&gt; System.out.println(k + <span class="string">"-&gt;"</span> + v));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原始流先根据分类函数分为多个子流，每个子流再由第二个收集器进行处理，归约收集器返回取得的最大值Optional<dish>，collectingAndThen收集器返回从Optional<dish>提取的值，最后第二级收集器的结果成为分组映射的值。</dish></dish></p><h3 id="8-4-分区"><a href="#8-4-分区" class="headerlink" title="8.4 分区"></a><strong>8.4 分区</strong></h3><p>&emsp;&emsp;分区是分组的特殊情况，<strong>由一个谓词作为分类函数</strong>，即分区函数。分区函数返回一个布尔值，意味着得到的分组Map的键值为Boolean，所以只能分为两组。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;Dish&gt;&gt; partitionedMenu = menu.stream().collect(Collectors.partitioningBy(Dish<span class="type">::isVegetarian</span>));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分区也可以像分组那样多级组合，可以看作是特殊的使用谓词来做分组函数的分组。</p><h3 id="8-5-收集器接口"><a href="#8-5-收集器接口" class="headerlink" title="8.5 收集器接口"></a><strong>8.5 收集器接口</strong></h3><p>&emsp;&emsp;Collector接口为实现具体的归约操作（收集器）提供了范本，</p><blockquote><ul><li>T是流中要收集的项目的泛型。</li><li>A是累加器的类型，累加器在收集过程中用于累积部分结果的对象。</li><li>R是收集操作得到的对象类型。</li></ul></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public interface Collector<span class="params">&lt;T, A, R&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//创建并返回新的可变结果容器的函数</span></span><br><span class="line">    Supplier<span class="params">&lt;A&gt;</span> supplier();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将值折叠到可变结果容器中的函数</span></span><br><span class="line">    BiConsumer<span class="params">&lt;A, T&gt;</span> accumulator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受两个部分结果并将其合并的函数。</span></span><br><span class="line">    <span class="comment">//组合器函数可以将状态从一个参数折叠到另一个参数并返回该参数，或者返回一个新的结果容器。</span></span><br><span class="line">    BinaryOperator<span class="params">&lt;A&gt;</span> combiner();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行从中间累积类型A到最终结果类型R的最终转换</span></span><br><span class="line">    Function<span class="params">&lt;A, R&gt;</span> finisher();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Collector.Characteristics的Set，指示此收集器的特征。这个集合应该是不可变的。</span></span><br><span class="line">    Set<span class="params">&lt;Characteristics&gt;</span> characteristics();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由给定的supplier、accumulator和combiner函数描述的新Collector。生成的Collector具有Collector.Characteristics.IDENTITY_FINISH特征。</span></span><br><span class="line">    public static<span class="params">&lt;T, R&gt;</span> Collector<span class="params">&lt;T, R, R&gt;</span> of(Supplier<span class="params">&lt;R&gt;</span> supplier,</span><br><span class="line">                                              BiConsumer<span class="params">&lt;R, T&gt;</span> accumulator,</span><br><span class="line">                                              BinaryOperator<span class="params">&lt;R&gt;</span> combiner,</span><br><span class="line">                                              Characteristics... characteristics) &#123;</span><br><span class="line">        Objects.requireNonNull(supplier);</span><br><span class="line">        Objects.requireNonNull(accumulator);</span><br><span class="line">        Objects.requireNonNull(combiner);</span><br><span class="line">        Objects.requireNonNull(characteristics);</span><br><span class="line">        Set<span class="params">&lt;Characteristics&gt;</span> cs = (characteristics.length == <span class="number">0</span>)</span><br><span class="line">                                  ? Collectors.CH_ID</span><br><span class="line">                                  : Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH,</span><br><span class="line">                                                                           characteristics));</span><br><span class="line">        return new Collectors.CollectorImpl<span class="params">&lt;&gt;</span>(supplier, accumulator, combiner, cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由给定的supplier、accumulator、combiner和finisher函数描述的新Collector。</span></span><br><span class="line">    public static<span class="params">&lt;T, A, R&gt;</span> Collector<span class="params">&lt;T, A, R&gt;</span> of(Supplier<span class="params">&lt;A&gt;</span> supplier,</span><br><span class="line">                                                 BiConsumer<span class="params">&lt;A, T&gt;</span> accumulator,</span><br><span class="line">                                                 BinaryOperator<span class="params">&lt;A&gt;</span> combiner,</span><br><span class="line">                                                 Function<span class="params">&lt;A, R&gt;</span> finisher,</span><br><span class="line">                                                 Characteristics... characteristics) &#123;</span><br><span class="line">        Objects.requireNonNull(supplier);</span><br><span class="line">        Objects.requireNonNull(accumulator);</span><br><span class="line">        Objects.requireNonNull(combiner);</span><br><span class="line">        Objects.requireNonNull(finisher);</span><br><span class="line">        Objects.requireNonNull(characteristics);</span><br><span class="line">        Set<span class="params">&lt;Characteristics&gt;</span> cs = Collectors.CH_NOID;</span><br><span class="line">        if (characteristics.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cs = EnumSet.noneOf(Characteristics.class);</span><br><span class="line">            Collections.addAll(cs, characteristics);</span><br><span class="line">            cs = Collections.unmodifiableSet(cs);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Collectors.CollectorImpl<span class="params">&lt;&gt;</span>(supplier, accumulator, combiner, finisher, cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示Collector属性的特性，可用于优化缩减实现。</span></span><br><span class="line">    enum <span class="class">Characteristics </span>&#123;</span><br><span class="line">        <span class="comment">//指示此收集器是并发的，这意味着结果容器可以支持与来自多个线程的同一结果容器同时调用的累加器函数。</span></span><br><span class="line">        <span class="comment">//如果CONCURRENT收集器也不是UNORDERED，则仅当应用于无序数据源时，才应并发计算该收集器。</span></span><br><span class="line">        CONCURRENT,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指示集合操作不承诺保留输入元素的相遇顺序。（如果结果容器没有内在顺序，例如Set，则可能是这样的。）</span></span><br><span class="line">        UNORDERED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示分页装订器函数是标识函数，可以省略。如果设置了，则从A到R的未检查强制转换必须成功。</span></span><br><span class="line">        IDENTITY_FINISH</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-5-1-supplier"><a href="#8-5-1-supplier" class="headerlink" title="8.5.1 supplier"></a><strong>8.5.1 supplier</strong></h4><p>&emsp;&emsp;supplier方法返回一个结果为空的Supplier<a>，也就是一个无参数函数，被调用时会创建一个空的累加器实例，供数据收集过程使用。对于把累加器本身作为结果返回的收集器（如toList），在对空流操作时，这个空的累加器也代表着收集过程的结果。</a></p><h4 id="8-5-2-accumulator"><a href="#8-5-2-accumulator" class="headerlink" title="8.5.2 accumulator"></a><strong>8.5.2 accumulator</strong></h4><p>&emsp;&emsp;accumulator方法会返回执行归约操作的函数。当遍历到流的第n个元素时，此函数执行时会有两个参数：保存归约结果的累加器，和第n个元素。此函数会返回void，因为累加器是原位更新，即函数的执行改变了它的内部状态</p><h4 id="8-5-3-finisher"><a href="#8-5-3-finisher" class="headerlink" title="8.5.3 finisher"></a><strong>8.5.3 finisher</strong></h4><p>&emsp;&emsp;在遍历完流后，finisher方法返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果。</p><p>&emsp;&emsp;这三个方法已足够对流进行顺序归约。</p><h4 id="8-5-4-combiner"><a href="#8-5-4-combiner" class="headerlink" title="8.5.4 combiner"></a><strong>8.5.4 combiner</strong></h4><p>&emsp;&emsp;combiner方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得到的累加器要如何进行合并。</p><p>&emsp;&emsp;有了此方法就可以对流进行并行归约了，过程要用到分支/合并框架和Spliterator抽象。</p><blockquote><ul><li>原始流会以递归的方式拆分为子流，直到定义流是否需要进一步拆分的一个条件为非。</li><li>所以子流都可以并行处理，每个子流都可以进行顺序归约算法。</li><li>使用收集器combiner返回的函数，将所有部分结果两两合并。</li></ul></blockquote><h4 id="8-5-5-characteristics"><a href="#8-5-5-characteristics" class="headerlink" title="8.5.5 characteristics"></a><strong>8.5.5 characteristics</strong></h4><p>&emsp;&emsp;characteristics会返回一个不可变的Characteristics集合，它定义了收集器的行为——尤其是关于流是否可以进行并行归约，以及可以使用哪些优化的提示。</p><blockquote><p>枚举类Characteristics包含三个项目</p><ul><li>UNORDERED：归约结果不受流中项目的遍历和累积顺序的影响。</li><li>CONCURRENT：accumulator函数可以从多个线程同时调用，且该收集器可以进行并行归约流。如果收集器没有标注UNORDERED，则仅当应用于无序数据源时才应并发归约。</li><li>IDENTITY_FINISH：表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象会直接用作归约过程的最终结果。也意味着将累加器A不加检查的转换为结果R是安全的。</li></ul></blockquote><h4 id="8-5-6-融合实现ToListCollector"><a href="#8-5-6-融合实现ToListCollector" class="headerlink" title="8.5.6 融合实现ToListCollector"></a><strong>8.5.6 融合实现ToListCollector</strong></h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ToListCollector</span>&lt;T&gt; <span class="title">implements</span> <span class="title">Collector</span>&lt;T, <span class="title">List</span>&lt;T&gt;, <span class="title">List</span>&lt;T&gt;&gt; &#123;</span></span><br><span class="line">    @Override</span><br><span class="line">    public Supplier&lt;List&lt;T<span class="meta">&gt;&gt; </span>supplier() &#123;<span class="regexp">//</span>创建集合操作的起始点</span><br><span class="line">        <span class="keyword">return</span> ArrayList::new;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;<span class="regexp">//</span>累积遍历过的项目，原位修改累加器</span><br><span class="line">        <span class="keyword">return</span> List::add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Function&lt;List&lt;T&gt;, List&lt;T<span class="meta">&gt;&gt; </span>finisher() &#123;<span class="regexp">//</span>恒等函数</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BinaryOperator&lt;List&lt;T<span class="meta">&gt;&gt; </span>combiner() &#123;<span class="regexp">//</span>修改第一个累加器，将其和第二个累加器内容合并</span><br><span class="line">        <span class="keyword">return</span> (list1, list2) -&gt; &#123;</span><br><span class="line">            list1.addAll(list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;Characteristics&gt; characteristics() &#123;<span class="regexp">//</span>累加器不是UNORDERED的，因为我们想保留顺序</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH,Characteristics.CONCURRENT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们实现的这个收集器和Collectors.toList()区别只是在一些优化上。collect()有一个三参数的重载方法(supplier,accumulator,combiner)，</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Dish&gt; dishes = menu.stream().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//toList是一个工厂方法由单例生成，ToListCollector则需要实例化</span></span><br><span class="line"><span class="built_in">List</span>&lt;Dish&gt; dishes1 = menu.stream().collect(<span class="literal">new</span> ToListCollector&lt;&gt;());</span><br><span class="line"><span class="comment">//简单但不易读，且收集器永远是IDENTITY_FINISH+CONCURRENT且非UNORDERED的</span></span><br><span class="line"><span class="built_in">List</span>&lt;Dish&gt; dishes2 = menu.stream().collect(ArrayList<span class="type">::new</span>, <span class="built_in">List</span><span class="type">::add</span>,<span class="built_in">List</span><span class="type">::addAll</span>);</span><br></pre></td></tr></table></figure><h3 id="8-6-实现收集器"><a href="#8-6-实现收集器" class="headerlink" title="8.6 实现收集器"></a><strong>8.6 实现收集器</strong></h3><p>&emsp;&emsp;</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;<span class="keyword">Boolean</span>, <span class="keyword">List</span>&lt;Integer&gt;&gt; primes = partitionPrimes(<span class="number">5</span>);</span><br><span class="line">primes.<span class="keyword">forEach</span>((k,v) -&gt; System.out.println(k + <span class="string">"-&gt;"</span> + v));</span><br><span class="line"><span class="comment">//false-&gt;[4]</span></span><br><span class="line"><span class="comment">//true-&gt;[2, 3, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;<span class="keyword">Boolean</span>, <span class="keyword">List</span>&lt;Integer&gt;&gt; partitionPrimes(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed().collect(Collectors.partitioningBy(candidate -&gt; isPrime(candidate)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrime(<span class="keyword">int</span> candidate)&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidateRoot).noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若除数本身不是质数则无需测试，只需要用被测试数之前的质数来测试，但我们所使用的收集器在收集过程无法访问部分结果，也就是我们无法访问已经找到的质数列表。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(List&lt;Integer&gt; primes, <span class="keyword">int</span> candidate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> primes.stream().noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们需要筛选已找到的质数中小于被测数的，通过filter只能对整个流进行筛选，如果流很大会造成问题，我们只要在质数大于被测数平方根的时候停下就行了。因此实现如下takeWhile方法。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrime(<span class="keyword">List</span>&lt;Integer&gt; primes, <span class="keyword">int</span> candidate)&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">    <span class="keyword">return</span> takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream().noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="keyword">List</span>&lt;A&gt; takeWhile(<span class="keyword">List</span>&lt;A&gt; <span class="keyword">list</span>, Predicate&lt;A&gt; p)&#123;<span class="comment">//给定一个排序集合和一个谓词，返回元素满足谓词的最长前缀</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(A item : <span class="keyword">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p.test(item))&#123;<span class="comment">//检查列表中的当前项目是否符合谓词</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">list</span>.subList(<span class="number">0</span>, i);<span class="comment">//不满足就返回该项目之前的前缀子列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;takeWhile方法是及时的，但我们需要一个延迟求值的方法来与noneMatch合并，需要熟悉Stream API的实现原理才可以实现。有了算法我们可以手动实现一个收集器了，代码如下。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PrimeNumbersCollector implements Collector&lt;<span class="built_in">Integer</span>,</span><br><span class="line">                                                        <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;,</span><br><span class="line">                                                        <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;&gt; supplier() &#123;</span><br><span class="line">        <span class="comment">//创建了作为累加器的map，并为true和false键初始化了空列表。</span></span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="literal">new</span> HashMap&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;()&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="literal">true</span>,<span class="literal">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                put(<span class="literal">false</span>,<span class="literal">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;, <span class="built_in">Integer</span>&gt; accumulator() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; acc, <span class="built_in">Integer</span> candidate) -&gt; &#123;</span><br><span class="line">            acc.get(isPrime(acc.get(<span class="literal">true</span>),candidate)) <span class="comment">//根据isPrime结果获取质数或非质数列表</span></span><br><span class="line">                    .add(candidate); <span class="comment">//将被测数添加到相应列表</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;&gt; combiner() &#123;</span><br><span class="line">        <span class="comment">//此收集器是无法并行运算的，因为算法本身是顺序的，所以当前combiner()无法被调用</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; map1, <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; map2) -&gt; &#123;</span><br><span class="line">            map1.get(<span class="literal">true</span>).addAll(map2.get(<span class="literal">true</span>));</span><br><span class="line">            map1.get(<span class="literal">false</span>).addAll(map2.get(<span class="literal">false</span>));</span><br><span class="line">            <span class="keyword">return</span> map1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Function&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;, <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;&gt; finisher() &#123;</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Set</span>&lt;Characteristics&gt; characteristics() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为质数</span></span><br><span class="line"><span class="comment">     * @param primes 已有质数列表</span></span><br><span class="line"><span class="comment">     * @param candidate 当前被测数</span></span><br><span class="line"><span class="comment">     * @return 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> isPrime(<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; primes, int candidate)&#123;</span><br><span class="line">        int candidateRoot = (int) Math.sqrt((double) candidate);</span><br><span class="line">        <span class="keyword">return</span> takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream().noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找符合谓词的元素集合</span></span><br><span class="line"><span class="comment">     * @param list 元素列表</span></span><br><span class="line"><span class="comment">     * @param p 谓词</span></span><br><span class="line"><span class="comment">     * @return 符合元素集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A&gt; <span class="built_in">List</span>&lt;A&gt; takeWhile(<span class="built_in">List</span>&lt;A&gt; <span class="built_in">list</span>, Predicate&lt;A&gt; p)&#123;</span><br><span class="line">        int i = <span class="number">0</span>;</span><br><span class="line">        for(A item : <span class="built_in">list</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p.test(item))&#123;<span class="comment">//检查列表中的当前项目是否符合谓词</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">list</span>.subList(<span class="number">0</span>, i);<span class="comment">//不满足就返回该项目之前的前缀子列表</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; partitionPrimesWithPrimeNumbersCollector(int n)&#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed().collect(<span class="literal">new</span> PrimeNumbersCollector());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; primes1 = partitionPrimesWithPrimeNumbersCollector(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以写一些测试代码对比一下性能提升比例，本机测试如下，大概提升了30%性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fastest execution <span class="keyword">done</span> <span class="keyword">in</span> 626 msecs</span><br><span class="line">Fastest execution <span class="keyword">done</span> <span class="keyword">in</span> 445 msecs</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——第三节，内容包括：收集器，归约和汇总(collect、reduce)，分组，分区，收集器接口(supplier、accumulator、finisher、combiner、characteristics、融合实现ToListCollector)，实现收集器。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
      <category term="collector" scheme="http://linyishui.top/tags/collector/"/>
    
  </entry>
  
  <entry>
    <title>流（二）使用和构建</title>
    <link href="http://linyishui.top/2019092301.html"/>
    <id>http://linyishui.top/2019092301.html</id>
    <published>2019-09-23T10:38:01.000Z</published>
    <updated>2019-11-22T10:56:13.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流（二）使用和构建"><a href="#流（二）使用和构建" class="headerlink" title="流（二）使用和构建"></a><strong>流（二）使用和构建</strong></h1><h2 id="第五节-流的使用"><a href="#第五节-流的使用" class="headerlink" title="第五节 流的使用"></a><strong>第五节 流的使用</strong></h2><h3 id="5-1-筛选和切片"><a href="#5-1-筛选和切片" class="headerlink" title="5.1 筛选和切片"></a><strong>5.1 筛选和切片</strong></h3><p>&emsp;&emsp;流怎样选择元素：用谓词筛选，筛选出各不相同的元素，忽略流中的头几个元素，或将流截短至指定长度。</p><h4 id="5-1-1-用谓词筛选"><a href="#5-1-1-用谓词筛选" class="headerlink" title="5.1.1 用谓词筛选"></a><strong>5.1.1 用谓词筛选</strong></h4><p>&emsp;&emsp;Stream接口支持filter方法，接受一个Predicate参数，并返回符合谓词元素T的流。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<span class="tag">&lt;<span class="name">T</span>&gt;</span> filter(Predicate<span class="php"><span class="meta">&lt;?</span> super T&gt; predicate);</span></span><br></pre></td></tr></table></figure><h4 id="5-1-2-筛选出各不相同的元素"><a href="#5-1-2-筛选出各不相同的元素" class="headerlink" title="5.1.2 筛选出各不相同的元素"></a><strong>5.1.2 筛选出各不相同的元素</strong></h4><p>&emsp;&emsp;Stream接口支持distinct方法，返回一个元素各异的流（根据流所生成元素的hashcode和equals方法实现），避免重复元素。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; distinct()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="5-1-3-截短流"><a href="#5-1-3-截短流" class="headerlink" title="5.1.3 截短流"></a><strong>5.1.3 截短流</strong></h4><p>&emsp;&emsp;Stream接口支持limit方法，返回一个不超过给定长度的流。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<span class="variable">&lt;T&gt;</span> <span class="keyword">limit</span>(long <span class="keyword">max</span>Size);</span><br></pre></td></tr></table></figure><h4 id="5-1-4-跳过元素"><a href="#5-1-4-跳过元素" class="headerlink" title="5.1.4 跳过元素"></a><strong>5.1.4 跳过元素</strong></h4><p>&emsp;&emsp;Stream接口支持skip方法，返回一个扔掉了前n个元素的流，如果流中元素不足n个，会返回一个空流。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;T&gt; skip(<span class="keyword">long</span> n);</span><br></pre></td></tr></table></figure><h3 id="5-2-映射"><a href="#5-2-映射" class="headerlink" title="5.2 映射"></a><strong>5.2 映射</strong></h3><p>&emsp;&emsp;类似于数据库查询表中指定属性列，流也可以从对象中选择信息。</p><h4 id="5-2-1-对流中每一个元素应用函数"><a href="#5-2-1-对流中每一个元素应用函数" class="headerlink" title="5.2.1 对流中每一个元素应用函数"></a><strong>5.2.1 对流中每一个元素应用函数</strong></h4><p>&emsp;&emsp;Stream接口支持map方法，接受一个Function参数，会应用到每个元素上，并将元素映射为一个新的元素，最后返回流。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="keyword">Stream&lt;R&gt; </span><span class="meta">map</span>(<span class="meta">Function</span>&lt;? super T, ? extends R&gt; mapper)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-2-流的扁平化"><a href="#5-2-2-流的扁平化" class="headerlink" title="5.2.2 流的扁平化"></a><strong>5.2.2 流的扁平化</strong></h4><p>&emsp;&emsp;如果我们对于一个字符串集合，需要返回一张列表，列出所有不同的字符。我们的实现过程可能如下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; words = Arrays.asList(<span class="string">"Java 8"</span>,<span class="string">"Lambdas"</span>,<span class="string">"In"</span>,<span class="string">"Action"</span>);</span><br><span class="line"><span class="comment">//对流中每个元素应用函数</span></span><br><span class="line">List&lt;Integer&gt; wordLengths = words.stream().<span class="built_in">map</span>(<span class="keyword">String</span>::length).collect(Collectors.toList());</span><br><span class="line">System.out.<span class="built_in">println</span>(wordLengths);</span><br><span class="line"></span><br><span class="line"><span class="comment">//流的扁平化</span></span><br><span class="line"><span class="comment">//首先通过map把单词映射为字符列表，再distinct去重，但返回是Stream&lt;String[]&gt;</span></span><br><span class="line">List&lt;<span class="keyword">String</span>[]&gt; wordCharsArray = words.stream().<span class="built_in">map</span>(<span class="keyword">word</span> -&gt; <span class="keyword">word</span>.split(<span class="string">""</span>)).distinct().collect(Collectors.toList());</span><br><span class="line">wordCharsArray.forEach(wordChar -&gt; System.out.<span class="built_in">println</span>(Arrays.toString(wordChar)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们想要的是Stream&lt;String&gt;而不是Stream&lt;String[]&gt;，Arrays::stream这个方法好像可以把数组转为流，但只是把字符数组变为了流</span></span><br><span class="line">words.stream().<span class="built_in">map</span>(<span class="keyword">word</span> -&gt; <span class="keyword">word</span>.split(<span class="string">""</span>)).<span class="built_in">map</span>(Arrays::stream).distinct().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//再通过flatMap</span></span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; wordChars = words.stream()</span><br><span class="line">        .<span class="built_in">map</span>(<span class="keyword">word</span> -&gt; <span class="keyword">word</span>.split(<span class="string">""</span>)) <span class="comment">//将每个单词转换为由其字母构成的数组</span></span><br><span class="line">        .flatMap(Arrays::stream) <span class="comment">//将各个生成流扁平化为单个流</span></span><br><span class="line">        .distinct() </span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.<span class="built_in">println</span>(wordChars);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">[J, a, v, a,  , <span class="number">8</span>]</span><br><span class="line">[L, a, m, b, d, a, s]</span><br><span class="line">[I, n]</span><br><span class="line">[A, c, t, i, o, n]</span><br><span class="line"></span><br><span class="line">[J, a, v,  , <span class="number">8</span>, L, m, b, d, s, I, n, A, c, t, i, o]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;flatMap()的作用是：各个数组并不是分别映射为一个流，而是映射为流的内容。所有map(Arrays::stream)生成的流都会被合并起来，扁平化为一个流。简单的说就是flatMap()会把一个流中每个值都换为另一个流，再把所有流连接起来成为一个流。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">R</span>&gt;</span> Stream<span class="tag">&lt;<span class="name">R</span>&gt;</span> flatMap(Function<span class="php"><span class="meta">&lt;?</span> super T, ? extends Stream<span class="meta">&lt;?</span> extends R&gt;&gt; mapper);</span></span><br></pre></td></tr></table></figure><h3 id="5-3-查找和匹配"><a href="#5-3-查找和匹配" class="headerlink" title="5.3 查找和匹配"></a><strong>5.3 查找和匹配</strong></h3><p>&emsp;&emsp;还有一个常见的数据处理套路是查询数据集中有某些元素是否匹配一个给定的数据。</p><h4 id="5-3-1-检查谓词是否至少匹配一个元素"><a href="#5-3-1-检查谓词是否至少匹配一个元素" class="headerlink" title="5.3.1 检查谓词是否至少匹配一个元素"></a><strong>5.3.1 检查谓词是否至少匹配一个元素</strong></h4><p>&emsp;&emsp;Stream接口支持anyMatch方法，接受一个Predicate参数，并返回布尔值，判断流中是否有一个元素可以匹配给定谓词。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="5-3-2-检查谓词是否匹配所有元素"><a href="#5-3-2-检查谓词是否匹配所有元素" class="headerlink" title="5.3.2 检查谓词是否匹配所有元素"></a><strong>5.3.2 检查谓词是否匹配所有元素</strong></h4><p>&emsp;&emsp;Stream接口支持allMatch方法，接受一个Predicate参数，并返回布尔值，判断流中是否所有元素可以匹配给定谓词。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;和allMatch相反的是noneMatch方法，判断流中是否没有元素可以匹配给定谓词。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>我们大概都学过短路技术，比如在一些逻辑判断时不需要进行所有操作就可以得到最终结果，对于流来说，如anyMatch、allMatch、noneMatch、findFirst、findAny这些操作也是可以应用短路的操作。在遇到无限流时，我们就能够把无限流变为有限流。</p></blockquote><h4 id="5-3-3-查找元素"><a href="#5-3-3-查找元素" class="headerlink" title="5.3.3 查找元素"></a><strong>5.3.3 查找元素</strong></h4><p>&emsp;&emsp;Stream接口支持findAny方法，返回当前流中的任意元素。通过Optional可以避免什么都没找到时返回null。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findAny()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-4-查找第一个元素"><a href="#5-3-4-查找第一个元素" class="headerlink" title="5.3.4 查找第一个元素"></a><strong>5.3.4 查找第一个元素</strong></h4><p>&emsp;&emsp;对于一些有序的流，你可能想要获取第一个元素。Stream接口支持findFirst方法，返回当前流中的第一个元素。通过Optional可以避免什么都没找到时返回null。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findFirst()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;findAny()相比findFirst()在并行上限制更小，所以如果只是需要获取一个元素，建议使用findAny()。</p><h3 id="5-4-归约"><a href="#5-4-归约" class="headerlink" title="5.4 归约"></a><strong>5.4 归约</strong></h3><p>&emsp;&emsp;“计算菜单中菜肴的总卡路里”和“菜单中卡路里最高的菜是哪个”，类似这种需要在元素间计算的复杂需求，需要我们把一个流中的元素反复组合起来，得到一个值。这样的查询我们称为归约操作（把流归约为一个值），一般称类似操作为折叠。</p><h4 id="5-4-1-元素求和"><a href="#5-4-1-元素求和" class="headerlink" title="5.4.1 元素求和"></a><strong>5.4.1 元素求和</strong></h4><p>&emsp;&emsp;reduce()方法接受两个参数，identity是初始值，accumulator是函数式接口BinaryOperator，定义了对同类型两个操作数的处理操作，并产生相同类型的结果。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span> reduce(<span class="built_in">T</span> identity, BinaryOperator&lt;<span class="built_in">T</span>&gt; accumulator);</span><br><span class="line"></span><br><span class="line">Optional&lt;<span class="built_in">T</span>&gt; reduce(BinaryOperator&lt;<span class="built_in">T</span>&gt; accumulator);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以统计一下菜单中菜肴的总卡路里。Lambda会反复结合每个元素，直到流被归约为一个值。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sum = menu.stream<span class="function"><span class="params">()</span>.<span class="title">map</span><span class="params">(Dish::getCalories)</span>.<span class="title">reduce</span><span class="params">(<span class="number">0</span>,(a, b) -&gt; a + b)</span>;</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"sum: "</span> + sum)</span>;//<span class="title">sum</span>: 4200</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;reduce()重载的一个没有初始值的变体，返回值是Optional。因为没有初始值，所以要考虑没有元素的情况。</p><h4 id="5-4-2-最大值和最小值"><a href="#5-4-2-最大值和最小值" class="headerlink" title="5.4.2 最大值和最小值"></a><strong>5.4.2 最大值和最小值</strong></h4><p>&emsp;&emsp;通过传递给reduce()一个求最大值/最小值的Lambda表达式就可以计算流中的最大值/最小值。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Optional</span>&lt;<span class="keyword">Integer</span>&gt; <span class="built_in">max</span> = menu.stream().map(Dish::getCalories).reduce(<span class="keyword">Integer</span>::<span class="built_in">max</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"max: "</span> + <span class="built_in">max</span>);//<span class="built_in">max</span>: <span class="keyword">Optional</span>[<span class="number">800</span>]</span><br><span class="line"><span class="keyword">Optional</span>&lt;<span class="keyword">Integer</span>&gt; <span class="built_in">min</span> = menu.stream().map(Dish::getCalories).reduce(<span class="keyword">Integer</span>::<span class="built_in">min</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"min: "</span> + <span class="built_in">min</span>);//<span class="built_in">min</span>: <span class="keyword">Optional</span>[<span class="number">120</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;map和reduce的连接通常称为map-reduce模式，因为Google用它进行网络搜索而知名，很容易并行化。</p><p>&emsp;&emsp;可变的累加器模式对并行化是死路一条，迭代求和要更新共享变量sum，非常不利于并行化，加入同步后线程竞争又抵消了并行本应带来的性能提升。当然归约方法也会有其限制，比如不能更改状态，操作必须满足结合律才能以任意顺序执行等。</p><p>&emsp;&emsp;如map或filter等操作从输入流获取每个元素，并在输出流中得到0或1个结果，这些操作一般是<strong>无状态</strong>的。而如reduce、sum和max等操作则需要<strong>内部状态</strong>来累积结果，但内部状态一般是有界的。对于sort和distinct等操作，它们和map很像，但却有一个关键区别：从流中排序或删除重复项都需要知道历史，排序需要把所有元素放入缓冲区后才能给输出流加入一个项目，这一操作的存储要求是无界的，如果流比较大甚至无限就会有问题。这些操作叫<strong>有状态操作</strong>。</p><h3 id="5-5-练习"><a href="#5-5-练习" class="headerlink" title="5.5 练习"></a><strong>5.5 练习</strong></h3><p>&emsp;&emsp;有交易员Trader和交易Transction，请解答以下问题。</p><blockquote><ol><li>找出2011年发生的所有交易，并按交易额升序排序</li><li>交易员都在哪些不同的城市工作过</li><li>查找所有来自于剑桥的交易员，并按姓名排序</li><li>返回所有交易员的姓名字符串，按字母顺序排序</li><li>有没有交易员是在米兰工作的</li><li>打印生活在剑桥的交易员的所有交易额</li><li>所有交易中，最高的交易额是多少</li><li>找到交易额最小的交易</li></ol></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">String</span> city;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> final Trader trader;</span><br><span class="line">    <span class="keyword">private</span> final int year;</span><br><span class="line">    <span class="keyword">private</span> final int value;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试数据</span></span><br><span class="line">        Trader raoul = <span class="keyword">new</span> <span class="type">Trader</span>(<span class="string">"Raoul"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader mario = <span class="keyword">new</span> <span class="type">Trader</span>(<span class="string">"Mario"</span>,<span class="string">"Milan"</span>);</span><br><span class="line">        Trader alan = <span class="keyword">new</span> <span class="type">Trader</span>(<span class="string">"Alan"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader brian = <span class="keyword">new</span> <span class="type">Trader</span>(<span class="string">"Brian"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Transaction&gt; transactions = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(brian,<span class="number">2011</span>,<span class="number">300</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(raoul,<span class="number">2012</span>,<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(raoul,<span class="number">2011</span>,<span class="number">400</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(mario,<span class="number">2012</span>,<span class="number">710</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(mario,<span class="number">2012</span>,<span class="number">700</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(alan,<span class="number">2012</span>,<span class="number">950</span>)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a><strong>解答</strong></h4><p>&emsp;&emsp;注释掉部分是因为书中有更好的解法。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        Trader raoul = <span class="keyword">new</span> Trader(<span class="string">"Raoul"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader mario = <span class="keyword">new</span> Trader(<span class="string">"Mario"</span>,<span class="string">"Milan"</span>);</span><br><span class="line">        Trader alan = <span class="keyword">new</span> Trader(<span class="string">"Alan"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader brian = <span class="keyword">new</span> Trader(<span class="string">"Brian"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Transaction&gt; transactions = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Transaction(brian,<span class="number">2011</span>,<span class="number">300</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(raoul,<span class="number">2012</span>,<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(raoul,<span class="number">2011</span>,<span class="number">400</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(mario,<span class="number">2012</span>,<span class="number">710</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(mario,<span class="number">2012</span>,<span class="number">700</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(alan,<span class="number">2012</span>,<span class="number">950</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//Question 1 : 找出2011年发生的所有交易，并按交易额升序排序</span></span><br><span class="line"><span class="regexp">        List&lt;Transaction&gt; result1 = transactions.stream()</span></span><br><span class="line"><span class="regexp">                .filter(t -&gt; 2011 == t.getYear())</span></span><br><span class="line"><span class="regexp">                .sorted(Comparator.comparing(Transaction::getValue))</span></span><br><span class="line"><span class="regexp">                .collect(Collectors.toList());</span></span><br><span class="line"><span class="regexp">        System.out.println("------------------------------\nQuestion 1 : ");</span></span><br><span class="line"><span class="regexp">        System.out.println(result1);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        //</span>Question <span class="number">2</span> : 交易员都在哪些不同的城市工作过</span><br><span class="line"><span class="regexp">//        List&lt;String&gt; result2 = transactions.stream()</span></span><br><span class="line"><span class="regexp">//</span>                .map(Transaction::getTrader)</span><br><span class="line"><span class="regexp">//                .map(Trader::getCity)</span></span><br><span class="line"><span class="regexp">//</span>                .distinct()</span><br><span class="line"><span class="regexp">//                .collect(Collectors.toList());</span></span><br><span class="line"><span class="regexp">        Set&lt;String&gt; result2 = transactions.stream()</span></span><br><span class="line"><span class="regexp">                .map(t -&gt; t.getTrader().getCity())</span></span><br><span class="line"><span class="regexp">                .collect(Collectors.toSet());</span></span><br><span class="line"><span class="regexp">        System.out.println("------------------------------\nQuestion 2 : ");</span></span><br><span class="line"><span class="regexp">        System.out.println(result2);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        //</span>Question <span class="number">3</span> : 查找所有来自于剑桥的交易员，并按姓名排序</span><br><span class="line">        List&lt;Trader&gt; result3 = transactions.stream()</span><br><span class="line">                .map(Transaction::getTrader)</span><br><span class="line">                .filter(t<span class="function"> -&gt;</span> <span class="string">"Cambridge"</span>.equals(t.getCity()))</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">"------------------------------\nQuestion 3 : "</span>);</span><br><span class="line">        System.out.println(result3);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//Question 4 : 返回所有交易员的姓名字符串，按字母顺序排序</span></span><br><span class="line"><span class="regexp">//</span>        String result4 = transactions.stream()</span><br><span class="line"><span class="regexp">//                .map(t -&gt; t.getTrader().getName())</span></span><br><span class="line"><span class="regexp">//</span>                .distinct()</span><br><span class="line"><span class="regexp">//                .sorted()</span></span><br><span class="line"><span class="regexp">//</span>                .reduce<span class="function"><span class="params">(<span class="string">""</span>,(s1,s2) -&gt; s1 + s2)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">String</span> <span class="title">result4</span> = <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">map</span><span class="params">(t -&gt; t.getTrader().getName())</span></span></span><br><span class="line"><span class="function">                .<span class="title">distinct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">sorted</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">collect</span><span class="params">(Collectors.joining())</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 4 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result4)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        //<span class="title">Question</span> 5 : 有没有交易员是在米兰工作的</span></span><br><span class="line"><span class="function">        <span class="title">boolean</span> <span class="title">result5</span> = <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">map</span><span class="params">(Transaction::getTrader)</span></span></span><br><span class="line"><span class="function">                .<span class="title">anyMatch</span><span class="params">(t-&gt;<span class="string">"Milan"</span>.equals(t.getCity()))</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 5 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result5)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        //<span class="title">Question</span> 6 : 打印生活在剑桥的交易员的所有交易额</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 6 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">filter</span><span class="params">(t -&gt; <span class="string">"Cambridge"</span>.equals(t.getTrader().getCity()))</span></span></span><br><span class="line"><span class="function">                .<span class="title">map</span><span class="params">(Transaction::getValue)</span></span></span><br><span class="line"><span class="function">                .<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        //<span class="title">Question</span> 7 : 所有交易中，最高的交易额是多少</span></span><br><span class="line"><span class="function">        <span class="title">Optional</span>&lt;<span class="title">Integer</span>&gt; <span class="title">result7</span> = <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">map</span><span class="params">(Transaction::getValue)</span></span></span><br><span class="line"><span class="function">                .<span class="title">reduce</span><span class="params">(Integer::max)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 7 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result7)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        //<span class="title">Question</span> 8 : 找到交易额最小的交易</span></span><br><span class="line"><span class="function">        <span class="title">Optional</span>&lt;<span class="title">Transaction</span>&gt; <span class="title">result8</span> = <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">min</span><span class="params">(Comparator.comparing(Transaction::getValue))</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 8 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result8)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打印结果如下。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">------------------------------</span><br><span class="line">Question 1 : </span><br><span class="line"><span class="meta">[&#123;Brian,2011,300&#125;, &#123;Raoul,2011,400&#125;]</span></span><br><span class="line">------------------------------</span><br><span class="line">Question 2 : </span><br><span class="line"><span class="meta">[Milan, Cambridge]</span></span><br><span class="line">------------------------------</span><br><span class="line">Question 3 : </span><br><span class="line"><span class="meta">[&#123;Alan,Cambridge&#125;, &#123;Brian,Cambridge&#125;, &#123;Raoul,Cambridge&#125;]</span></span><br><span class="line">------------------------------</span><br><span class="line">Question 4 : </span><br><span class="line">AlanBrianMarioRaoul</span><br><span class="line">------------------------------</span><br><span class="line">Question 5 : </span><br><span class="line">true</span><br><span class="line">------------------------------</span><br><span class="line">Question 6 : </span><br><span class="line">300</span><br><span class="line">1000</span><br><span class="line">400</span><br><span class="line">950</span><br><span class="line">------------------------------</span><br><span class="line">Question 7 : </span><br><span class="line">Optional[1000]</span><br><span class="line">------------------------------</span><br><span class="line">Question 8 : </span><br><span class="line">Optional[&#123;Brian,2011,300&#125;]</span><br></pre></td></tr></table></figure><hr><h2 id="第六节-数值流"><a href="#第六节-数值流" class="headerlink" title="第六节 数值流"></a><strong>第六节 数值流</strong></h2><h3 id="6-1-原始类型流特化"><a href="#6-1-原始类型流特化" class="headerlink" title="6.1 原始类型流特化"></a><strong>6.1 原始类型流特化</strong></h3><p>&emsp;&emsp;有时我们需要统计对象的某个数值属性列，根据归约我们可以如此实现。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sum = menu.stream<span class="function"><span class="params">()</span>.<span class="title">map</span><span class="params">(Dish::getCalories)</span>.<span class="title">reduce</span><span class="params">(<span class="number">0</span>,(a, b) -&gt; a + b)</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种实现存在一个装箱成本，Integer类型的属性需要转为int进行求和，你或许会想会什么不能直接调用sum()来进行求和。因为对于流接口来说，它对于对象求和是没有意义的，但Stream API提供了<strong>原始类型流特化</strong>，专门用来支持处理数值流的方法。</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">类型</th><th style="text-align:left">返回类型</th><th style="text-align:left">操作参数</th><th style="text-align:left">函数描述符</th></tr></thead><tbody><tr><td style="text-align:left">mapToInt</td><td style="text-align:left">中间</td><td style="text-align:left">IntStream</td><td style="text-align:left">ToIntFunction<t></t></td><td style="text-align:left">T -&gt; int</td></tr><tr><td style="text-align:left">mapToLong</td><td style="text-align:left">中间</td><td style="text-align:left">LongStream</td><td style="text-align:left">ToLongFunction<t></t></td><td style="text-align:left">T -&gt; long</td></tr><tr><td style="text-align:left">mapToDouble</td><td style="text-align:left">中间</td><td style="text-align:left">DoubleStream</td><td style="text-align:left">ToDoubleFunction<t></t></td><td style="text-align:left">T -&gt; double</td></tr></tbody></table><p>&emsp;&emsp;所以我们可以改写代码如下。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sumSpec = menu.stream()</span><br><span class="line">        .mapToInt(Dish::getCalories) <span class="comment">//先映射为IntStream</span></span><br><span class="line">        .<span class="keyword">sum</span>(); <span class="comment">//再调用IntStream提供的sum()求和</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>数值流也可以再转为对象流</strong>，通过boxed()进行装箱。</p><p>&emsp;&emsp;sum()有默认值0，但如求最大值等则需要Optional的特定版本：OptionalInt、OptionalDouble、OptionalLong来作为返回值。</p><h3 id="6-2-数值范围"><a href="#6-2-数值范围" class="headerlink" title="6.2 数值范围"></a><strong>6.2 数值范围</strong></h3><p>&emsp;&emsp;range()和rangeClosed()可以生成数值范围，两个参数分别是起始和结束值，range()不包括结束值。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">IntStream <span class="title">range</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startInclusive &gt;= endExclusive) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> Streams.RangeIntSpliterator(startInclusive, endExclusive, <span class="keyword">false</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">IntStream <span class="title">rangeClosed</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startInclusive &gt; endInclusive) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> Streams.RangeIntSpliterator(startInclusive, endInclusive, <span class="keyword">true</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-应用"><a href="#6-3-应用" class="headerlink" title="6.3 应用"></a><strong>6.3 应用</strong></h3><p>&emsp;&emsp;创建一个勾股数（若a^2 + b^2 = c^2，三个都是整数，则a、b、c是一组勾股数）。</p><p>&emsp;&emsp;我们需要能表示三元组(a, b, c)，可以采用数组int[]。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勾股数</span></span><br><span class="line">Stream&lt;int[]&gt; pythagoreanTriples = IntStream.rangeClosed(<span class="number">1</span>,<span class="number">100</span>) <span class="comment">//从1至100取值</span></span><br><span class="line">        .boxed() <span class="comment">//数值流装箱转换为Stream&lt;Integer&gt;</span></span><br><span class="line">        .<span class="function"><span class="title">flatMap</span>(a -&gt;</span> <span class="comment">//把生成的三元流扁平为一个三元数流</span></span><br><span class="line">                IntStream.rangeClosed(a,<span class="number">100</span>) <span class="comment">//从a至100取值，避免重复</span></span><br><span class="line">                        .<span class="function"><span class="title">filter</span>(b -&gt;</span> <span class="comment">//过滤不合法的(a, b)取值</span></span><br><span class="line">                                Math.<span class="built_in">sqrt</span>(a * a + b * b) % <span class="number">1</span> == <span class="number">0</span>) <span class="comment">//Math.sqrt(a * a + b * b) % 1 == 0判断c是否为整数</span></span><br><span class="line">                        .<span class="function"><span class="title">mapToObj</span>(b -&gt;</span> <span class="comment">//映射出三元组</span></span><br><span class="line">                                new int[]&#123;a, b, (int) Math.<span class="built_in">sqrt</span>(a * a + b * b)&#125;));</span><br><span class="line">System.out.println(<span class="string">"++++++++++++++++++++"</span>);</span><br><span class="line"><span class="function"><span class="title">pythagoreanTriples</span>.limit(5).forEach(t -&gt;</span> System.out.println(t[<span class="number">0</span>] + <span class="string">", "</span> + t[<span class="number">1</span>] + <span class="string">", "</span> + t[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line">Stream&lt;double[]&gt; pythagoreanTriples2 = IntStream.rangeClosed(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">        .boxed()</span><br><span class="line">        .<span class="function"><span class="title">flatMap</span>(a -&gt;</span></span><br><span class="line">                IntStream.rangeClosed(a, <span class="number">100</span>)</span><br><span class="line">                        .<span class="function"><span class="title">mapToObj</span>(b -&gt;</span> new double[]&#123;a, b, Math.<span class="built_in">sqrt</span>(a * a + b * b)&#125;) <span class="comment">//先生成所有三元组</span></span><br><span class="line">                        .<span class="function"><span class="title">filter</span>(t -&gt;</span> t[<span class="number">2</span>] % <span class="number">1</span> == <span class="number">0</span>)); <span class="comment">//再筛选掉不合法的</span></span><br></pre></td></tr></table></figure><hr><h2 id="第七节-构建流"><a href="#第七节-构建流" class="headerlink" title="第七节 构建流"></a><strong>第七节 构建流</strong></h2><h3 id="7-1-由值创建流"><a href="#7-1-由值创建流" class="headerlink" title="7.1 由值创建流"></a><strong>7.1 由值创建流</strong></h3><p>&emsp;&emsp;Stream.of()方法可以用来由值创建流。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="built_in">Stream</span>&lt;T&gt; of(T... values) &#123;</span><br><span class="line">    <span class="built_in">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由值创建流</span></span><br><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; stringStream = <span class="built_in">Stream</span>.of(<span class="string">"a"</span>,<span class="string">"b"</span>);</span><br></pre></td></tr></table></figure><h3 id="7-2-由数组创建流"><a href="#7-2-由数组创建流" class="headerlink" title="7.2 由数组创建流"></a><strong>7.2 由数组创建流</strong></h3><p>&emsp;&emsp;Arrays.stream()方法可以用来由数组创建流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stream(<span class="built_in">array</span>, <span class="number">0</span>, <span class="built_in">array</span>.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由数组创建流</span></span><br><span class="line">int[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Arrays.stream(a).boxed();</span><br></pre></td></tr></table></figure><h3 id="7-3-由文件生成流"><a href="#7-3-由文件生成流" class="headerlink" title="7.3 由文件生成流"></a><strong>7.3 由文件生成流</strong></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由文件生成流</span></span><br><span class="line"><span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">try</span>(<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; lines = Files.lines(Paths.<span class="built_in">get</span>(<span class="string">"d:/data.txt"</span>), Charset.defaultCharset()))&#123;</span><br><span class="line">    uniqueWords = lines.flatMap(<span class="built_in">line</span> -&gt; Arrays.stream(<span class="built_in">line</span>.split(<span class="string">" "</span>)))</span><br><span class="line">            .distinct()</span><br><span class="line">            .count();</span><br><span class="line">&#125;<span class="built_in">catch</span> (IOException ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"文件中不重复单词有："</span> + uniqueWords + <span class="string">"个"</span>);</span><br></pre></td></tr></table></figure><h3 id="7-4-由函数生成流：创建无限流"><a href="#7-4-由函数生成流：创建无限流" class="headerlink" title="7.4 由函数生成流：创建无限流"></a><strong>7.4 由函数生成流：创建无限流</strong></h3><p>&emsp;&emsp;Stream.iterate()和Stream.generate()方法用来从函数生成流，可以创建所谓的<strong>无限流</strong>：没有固定大小的流。注意加limit限制，防止无限的打印。</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a><strong>迭代</strong></h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="selector-tag">Stream</span><span class="selector-class">.iterate</span>(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">        <span class="selector-class">.limit</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="selector-class">.forEach</span>(System.<span class="attribute">out</span>::println);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;顺序的不断迭代+2，如果没有限制会无限的运行下去，这种流是无界的。</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a><strong>生成</strong></h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成</span></span><br><span class="line"><span class="selector-tag">Stream</span><span class="selector-class">.generate</span>(<span class="attribute">Math</span>::random)</span><br><span class="line">        <span class="selector-class">.limit</span>(<span class="number">5</span>)</span><br><span class="line">        <span class="selector-class">.forEach</span>(System.<span class="attribute">out</span>::println);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们使用的源（指向random的方法引用）是无状态的：它不会在任何地方记录任何值来以便备用。但也可以使用有存储状态的源，修改其状态，留给流生成下一个值时使用。</p><h4 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="headerlink" title="实现斐波那契数列"></a><strong>实现斐波那契数列</strong></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列，每个数字都是前两个数字之和</span></span><br><span class="line"><span class="comment">//打印二元组</span></span><br><span class="line"><span class="built_in">Stream</span>.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, temp -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;temp[<span class="number">1</span>], temp[<span class="number">0</span>] + temp[<span class="number">1</span>]&#125;)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .forEach(t -&gt; System.out.<span class="built_in">println</span>(<span class="string">"("</span> + t[<span class="number">0</span>] + <span class="string">", "</span> + t[<span class="number">1</span>] + <span class="string">")"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印斐波那契数列</span></span><br><span class="line"><span class="built_in">Stream</span>.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, temp -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;temp[<span class="number">1</span>], temp[<span class="number">0</span>] + temp[<span class="number">1</span>]&#125;)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .<span class="built_in">map</span>(t -&gt; t[<span class="number">0</span>])</span><br><span class="line">        .forEach(System.out::<span class="built_in">println</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化IntSupplier，修改状态，实现斐波那契数列</span></span><br><span class="line">IntSupplier fib = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getAsInt() &#123;</span><br><span class="line">        <span class="keyword">int</span> old = <span class="keyword">this</span>.pre;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="keyword">this</span>.pre + <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.current = next;</span><br><span class="line">        <span class="built_in">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">IntStream.generate(fib).limit(<span class="number">10</span>).forEach(System.out::<span class="built_in">println</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两种实现：使用iterate方法不会出现修改状态操作，但每次迭代都会创建新的元组。generate方法则实例化了IntSupplier接口，并在每次调用getAsInt方法时改变了对象的状态。不变的方法会有利于并行处理哦。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——第二节，内容包括：流的使用(筛选和切片、映射、查找和匹配、归约、练习)，数值流(原始类型流特化、数值范围、应用)，构建流(由值创建流、由数组创建流、由文件生成流、由函数生成流：创建无限流)。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>流（一）入门介绍</title>
    <link href="http://linyishui.top/2019092201.html"/>
    <id>http://linyishui.top/2019092201.html</id>
    <published>2019-09-22T02:15:53.000Z</published>
    <updated>2019-11-22T10:55:56.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流（一）入门介绍"><a href="#流（一）入门介绍" class="headerlink" title="流（一）入门介绍"></a><strong>流（一）入门介绍</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><h3 id="为什么有了集合还需要流？"><a href="#为什么有了集合还需要流？" class="headerlink" title="为什么有了集合还需要流？"></a><strong>为什么有了集合还需要流？</strong></h3><p>&emsp;&emsp;流的出现是为了在某些场景下能够代替集合，集合的业务中常常涉及到类似数据库的操作，当有一些复杂需求需要嵌套遍历运算时，集合就需要公式似的写一串代码，很难让人一眼看明白代码代表的意思。如下案例实现在集合中筛选金额较高的交易，并按货币分组。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建累积交易分组的Map</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Currency, <span class="built_in">List</span>&lt;Transaction&gt;&gt; transactionsByCurrencies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//遍历交易List</span></span><br><span class="line"><span class="keyword">for</span>(Transaction transaction : transactions)&#123;</span><br><span class="line">    <span class="comment">//筛选金额较高的交易</span></span><br><span class="line">    <span class="keyword">if</span>(transaction.getPrice() &gt; <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="comment">//提取交易货币</span></span><br><span class="line">        Currency currency = transaction.getCurrency();</span><br><span class="line">        <span class="built_in">List</span>&lt;Transaction&gt; transactionForCurrency = transactionsByCurrencies.<span class="keyword">get</span>(currency);</span><br><span class="line">        <span class="comment">//如果此货币分组为空，就新建一个</span></span><br><span class="line">        <span class="keyword">if</span>(transactionForCurrency == <span class="keyword">null</span>)&#123;</span><br><span class="line">            transactionForCurrency = <span class="keyword">new</span> ArratList();</span><br><span class="line">            transactionsByCurrencies.put(currency,transactionForCurrency);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前遍历的交易添加到具有同一货币的交易List中</span></span><br><span class="line">        transactionForCurrency.add(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果通过Stream API，可以改写上述代码如下。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> static java.util.stream.Collectors.toList;</span><br><span class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = transactions.stream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Transaction t) -&gt; t.getPrice() &gt; <span class="number">1000</span>)</span>.<span class="title">collect</span><span class="params">(groupingBy(Transaction::getCurrency))</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;流允许我们以声明性方式处理数据几个（通过查询语句实现，而不是临时编写一个实现）。</p><h3 id="流解决了集合的两个问题"><a href="#流解决了集合的两个问题" class="headerlink" title="流解决了集合的两个问题"></a><strong>流解决了集合的两个问题</strong></h3><p>&emsp;&emsp;两个问题是：集合处理时的固定套路和晦涩，以及难以有效利用多核性能。</p><p>&emsp;&emsp;<strong>集合的主要目的是为了存储和访问数据，而Stream则主要用于描述对数据的计算。</strong></p><p>&emsp;&emsp;集合需要手动实现迭代和运算处理，这种数据迭代叫<strong>外部迭代</strong>，而流式的迭代完全在库内部实现，叫做<strong>内部迭代</strong>。流则和SQL的思路一样，采用了更高级的语言表达，由<strong>实现</strong>（Streams库）来选择最佳的低级执行机制。这样就可以避免用synchronized编写代码，它不仅容易出错，且在多核环境下需要很大的成本。筛选一个集合的最快方案就是先转为Stream，再进行并行处理，最后再转换为List。编程中往往会有一些反复出现的数据处理模式，可以根据标准进行<strong>筛选数据</strong>、<strong>提取数据</strong>、<strong>给数据分组</strong>等会很方便。</p><p>&emsp;&emsp;<strong>这些操作往往可以并行化</strong>。比如在两个CPU上筛选集合，可以一个处理列表前半部，一个处理后半部，这叫做分支步骤(1)；然后CPU对各自半个集合进行筛选(2)；最后(3)，一个CPU将两个结果合并。</p><h3 id="流的优点"><a href="#流的优点" class="headerlink" title="流的优点"></a><strong>流的优点</strong></h3><blockquote><p>流相较集合的优点：</p><ul><li><strong>声明性</strong>：如果使用SQL这种数据库语言会发现一些查询语句转化为Java要变得很长，Java8的流支持这种简明的数据库查询式编程且用的是Java语法，我们的目标是说明要做什么，而不是要如何来实现这个操作。</li><li><strong>可复合</strong>：可以对流做一些集合不能做的优化操作，如可以将对同一个流的若干操作组合起来，从而只遍历一次数据，而不是花大代价的去多次遍历。</li><li><strong>可并行</strong>：Java可以自动的将流操作并行化，而集合则不行。</li><li>流被设计为无需同时将数据调入内存，这样就可以处理无法装入内存的流数据了。</li></ul></blockquote><hr><h2 id="第二节-流简介"><a href="#第二节-流简介" class="headerlink" title="第二节 流简介"></a><strong>第二节 流简介</strong></h2><h3 id="stream和parallelStream"><a href="#stream和parallelStream" class="headerlink" title="stream和parallelStream"></a><strong>stream和parallelStream</strong></h3><p>&emsp;&emsp;集合接口Collection在Java 8中增加了默认方法stream()和parallelStream()，分别代表着<strong>流的顺序和并行处理</strong>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; stream() &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; parallelStream() &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//顺序处理</span></span><br><span class="line"><span class="regexp">List&lt;Student&gt; result = students.stream().filter((Student s) -&gt; s.getAge() &gt; 18).collect(Collectors.toList());</span></span><br><span class="line"><span class="regexp">//</span>并行处理</span><br><span class="line">List&lt;Student&gt; result = students.parallelStream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span>.<span class="title">collect</span><span class="params">(Collectors.toList())</span>;</span></span><br></pre></td></tr></table></figure><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a><strong>流是什么</strong></h3><p>&emsp;&emsp;简单的定义，<strong>流是从支持数据处理操作的源生成的元素序列</strong>。</p><blockquote><ul><li><strong>元素序列</strong>：和集合一样，流也提供了接口Stream，可以访问特定元素类型的一组有序值。集合是数据结构，其目的是以特定的时间/空间复杂度存储和访问元素。流的目的是表达计算。集合表述数据，流表述计算。</li><li><strong>源</strong>：流会使用一个提供数据的源，如集合、数组或输入/输出资源。从有序集合生成流时会保留顺序。</li><li><strong>数据处理操作</strong>：流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行也可以并行执行。</li><li><strong>流水线</strong>：很多流操作本身会返回一个流，所以这些操作就可以链接起来，形成一个大的流水线。也为我们做如延迟和短路这些优化提供了可能。</li><li><strong>内部迭代</strong>：与使用迭代器进行显示迭代的集合不同，流的迭代操作是在背后进行的。</li></ul></blockquote><p>&emsp;&emsp;如下代码中，<strong>数据源</strong>是菜肴列表，它提供给流一个<strong>元素序列</strong>。一系列<strong>数据处理操作</strong>构成了<strong>流水线</strong>，最后的collect操作并没有返回流，而是返回List结果。在collect操作被调用前，流水线上其他操作都在排队等待。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; threeHighCaloricDishNames = menu.stream<span class="params">()</span> <span class="string">//</span>从集合获得流，准备创建流水线</span><br><span class="line">        <span class="string">.filter</span><span class="params">(d -&gt; d.getCalories()</span> &gt; 300) <span class="string">//</span>筛选高热量的菜肴</span><br><span class="line">        <span class="string">.map</span><span class="params">(Dish::getName)</span> <span class="string">//</span>获取菜名</span><br><span class="line">        <span class="string">.limit</span><span class="params">(3)</span> <span class="string">//</span>只选择头三个</span><br><span class="line">        <span class="string">.collect</span><span class="params">(Collectors.toList()</span>); <span class="string">//</span>将结果存在另一个List中</span><br><span class="line">System.out.println<span class="params">(threeHighCaloricDishNames)</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;流水线类似于<strong>构建器模式</strong>，一个调用链来设置一套配置，再调用build()方法。</p><hr><h2 id="第三节-流和集合"><a href="#第三节-流和集合" class="headerlink" title="第三节 流和集合"></a><strong>第三节 流和集合</strong></h2><p>&emsp;&emsp;我们可以把DVD中存储的电影（基于字节或帧无所谓）看作是一个集合，而网络中通过视频流看同一部电影看作是流。视频流不需要用户等待加载完整个视频，而是只要下载当前观看位置的那几帧就可以了。</p><p>&emsp;&emsp;这样看，<strong>流和集合的差异就在于何时进行计算</strong>，集合是一个内存中的数据结构，它包含了数据结构中目前的所有值，集合中的所有元素都要先计算出来才能添加到集合中，你可以对集合元素做增删操作，但每个元素都必须算出后存放在内存里。</p><p>&emsp;&emsp;流则只是概念上的固定数据结构，你不能增删元素，它的元素是按需计算的。这是一种生产者——消费者关系，流也可以看作是一个延迟创建的集合：只有消费者要求时才会计算值（需求驱动，实时制造）。集合则是急切创建的（供应商驱动）。比如我们需要创建一个所有质数的集合，质数是无穷无尽的，所以这个质数集合我们永远也拿不到。另一个例子是查询分页，集合就是我把所有元素都返回给用户，流则是根据需求返回优先级最高的一页数据。</p><h3 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a><strong>只能遍历一次</strong></h3><p>&emsp;&emsp;流和迭代器一样，只能遍历一次。如果还需要重新遍历就需要从数据源再重新获取一个新流，当然这里指的是集合之类可以重复的源，而不是I/O通道。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream s = menu.stream();</span><br><span class="line">s.<span class="keyword">for</span>Each(System.<span class="keyword">out</span>::println);</span><br><span class="line">s.<span class="keyword">for</span>Each(System.<span class="keyword">out</span>::println);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后抛出异常: stream has already been operated upon or closed</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.IllegalStateException</span>: stream has already been operated upon or closed</span><br><span class="line">at java<span class="selector-class">.util</span><span class="selector-class">.stream</span><span class="selector-class">.AbstractPipeline</span><span class="selector-class">.sourceStageSpliterator</span>(AbstractPipeline<span class="selector-class">.java</span>:<span class="number">279</span>)</span><br><span class="line">at java<span class="selector-class">.util</span><span class="selector-class">.stream</span><span class="selector-class">.ReferencePipeline</span><span class="variable">$Head</span>.forEach(ReferencePipeline<span class="selector-class">.java</span>:<span class="number">580</span>)</span><br><span class="line">at categories<span class="selector-class">.java</span><span class="selector-class">.a7stream</span><span class="selector-class">.Test</span><span class="selector-class">.main</span>(Test<span class="selector-class">.java</span>:<span class="number">31</span>)</span><br></pre></td></tr></table></figure><h3 id="外部迭代和内部迭代"><a href="#外部迭代和内部迭代" class="headerlink" title="外部迭代和内部迭代"></a><strong>外部迭代和内部迭代</strong></h3><p>&emsp;&emsp;集合Collection需要开发者自行去做迭代，叫外部迭代。流则是内部迭代，Stream库帮你做了迭代，并把得到的流值存放起来，你只要声明要做什么即可。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>&lt;<span class="type">String</span>&gt; names = <span class="function"><span class="keyword">new</span> <span class="title">ArrayList</span>&lt;&gt;();</span></span><br><span class="line"><span class="function"><span class="comment">//集合通过for-each循环外部迭代</span></span></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="type">Dish</span> dish : menu)&#123;</span></span><br><span class="line"><span class="function">    <span class="title">names</span>.<span class="title">add</span>(dish.getName());</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="comment">//集合通过迭代器做外部迭代</span></span></span><br><span class="line"><span class="function"><span class="title">Iterator</span>&lt;<span class="title">Dish</span>&gt; <span class="title">iterator</span> = <span class="title">menu</span>.<span class="title">iterator</span>();</span></span><br><span class="line"><span class="function"><span class="title">while</span> (iterator.hasNext())&#123;</span></span><br><span class="line"><span class="function">    <span class="title">Dish</span> <span class="title">d</span> = <span class="title">iterator</span>.<span class="title">next</span>();</span></span><br><span class="line"><span class="function">    <span class="title">names</span>.<span class="title">add</span>(d.getName());</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="comment">//流内部迭代</span></span></span><br><span class="line"><span class="function"><span class="title">names</span> = <span class="title">menu</span>.<span class="title">stream</span>().<span class="title">map</span>(<span class="type">Dish</span>::getName).<span class="title">collect</span>(<span class="type">Collectors</span>.toList());</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们设想一个应用场景，你需要女儿把地上的玩具收回箱子。如果是外部迭代，你需要一个个的指示她去整理所有玩具，需要显式的取出每个项目进行处理。如果是内部迭代，她可以选择一手拿一个，也可以自己决定先拿离盒子较近的玩具，而你只需要告诉她把所有的玩具收回箱子即可。流的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现，而集合就需要你自己手动来处理所有的并行问题。</p><hr><h2 id="第四节-流的操作"><a href="#第四节-流的操作" class="headerlink" title="第四节 流的操作"></a><strong>第四节 流的操作</strong></h2><p>&emsp;&emsp;可以连接起来的流操作称为<strong>中间操作</strong>，关闭流的操作叫<strong>终端操作</strong>。</p><blockquote><ul><li>一个数据源来执行一个查询</li><li>一个中间操作链，形成一条流水线</li><li>一个终端操作，执行流水线，并能生成结果</li></ul></blockquote><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a><strong>中间操作</strong></h3><p>&emsp;&emsp;除非流水线触发一个终端操作，否则中间操作不会执行任何处理，中间操作可以合并起来，在终端操作时一次性处理。</p><p>&emsp;&emsp;可以尝试在中间操作中添加打印，观察执行顺序。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印每个操作</span></span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; delayNames = menu.stream() <span class="comment">//从集合获得流，准备创建流水线</span></span><br><span class="line">        .filter(d -&gt; &#123;</span><br><span class="line">            <span class="keyword">System</span>.out.println(<span class="string">"filtering"</span> + d.<span class="built_in">getName</span>());</span><br><span class="line">            <span class="keyword">return</span> d.getCalories() &gt; <span class="number">300</span>;</span><br><span class="line">        &#125;) <span class="comment">//筛选高热量的菜肴</span></span><br><span class="line">        .map(d -&gt; &#123;</span><br><span class="line">            <span class="keyword">System</span>.out.println(<span class="string">"maping"</span> + d.<span class="built_in">getName</span>());</span><br><span class="line">            <span class="keyword">return</span> d.<span class="built_in">getName</span>();</span><br><span class="line">        &#125;) <span class="comment">//获取菜名</span></span><br><span class="line">        .limit(<span class="number">3</span>) <span class="comment">//只选择头三个</span></span><br><span class="line">        .collect(Collectors.toList()); <span class="comment">//将结果存在另一个List中</span></span><br><span class="line"><span class="keyword">System</span>.out.println(threeHighCaloricDishNames);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打印结果如下，可以发现Java通过流的延迟性质进行了多个优化：(1)通过limit操作和短路技巧可以只取前3个元素。(2)循环合并技术把filter和map操作合并到同一次遍历中了。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">filtering</span> pork</span><br><span class="line"><span class="symbol">maping</span> pork</span><br><span class="line"><span class="symbol">filtering</span> <span class="keyword">beef</span></span><br><span class="line"><span class="keyword">maping </span><span class="keyword">beef</span></span><br><span class="line"><span class="keyword">filtering </span>chicken</span><br><span class="line"><span class="symbol">maping</span> chicken</span><br><span class="line">[pork, <span class="keyword">beef, </span>chicken]</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">类型</th><th style="text-align:left">返回类型</th><th style="text-align:left">操作参数</th><th style="text-align:left">函数描述符</th></tr></thead><tbody><tr><td style="text-align:left">filter</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">Predicate<t></t></td><td style="text-align:left">T -&gt; boolean</td></tr><tr><td style="text-align:left">map</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<r></r></td><td style="text-align:left">Function&lt;T, R&gt;</td><td style="text-align:left">T -&gt; R</td></tr><tr><td style="text-align:left">limit</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">long maxSize</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">sorted</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">Comparator<t></t></td><td style="text-align:left">(T, T) -&gt; int</td></tr><tr><td style="text-align:left">peek</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">Consumer<t></t></td><td style="text-align:left">T -&gt; void</td></tr><tr><td style="text-align:left">distinct</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">skip</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">long n</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">mapToInt</td><td style="text-align:left">中间</td><td style="text-align:left">IntStream</td><td style="text-align:left">ToIntFunction<t></t></td><td style="text-align:left">T -&gt; int</td></tr><tr><td style="text-align:left">mapToLong</td><td style="text-align:left">中间</td><td style="text-align:left">LongStream</td><td style="text-align:left">ToLongFunction<t></t></td><td style="text-align:left">T -&gt; long</td></tr><tr><td style="text-align:left">mapToDouble</td><td style="text-align:left">中间</td><td style="text-align:left">DoubleStream</td><td style="text-align:left">ToDoubleFunction<t></t></td><td style="text-align:left">T -&gt; double</td></tr><tr><td style="text-align:left">flatMap</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<r></r></td><td style="text-align:left">Function&lt;T, Stream<r>&gt;</r></td><td style="text-align:left">T -&gt; R</td></tr><tr><td style="text-align:left">flatMapToInt</td><td style="text-align:left">中间</td><td style="text-align:left">IntStream</td><td style="text-align:left">Function&lt;T, IntStream&gt;</td><td style="text-align:left">T -&gt; int</td></tr><tr><td style="text-align:left">flatMapToLong</td><td style="text-align:left">中间</td><td style="text-align:left">LongStream</td><td style="text-align:left">Function&lt;T, LongStream&gt;</td><td style="text-align:left">T -&gt; long</td></tr><tr><td style="text-align:left">flatMapToDouble</td><td style="text-align:left">中间</td><td style="text-align:left">DoubleStream</td><td style="text-align:left">Function&lt;T, DoubleStream&gt;</td><td style="text-align:left">T -&gt; double</td></tr></tbody></table><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a><strong>终端操作</strong></h3><p>&emsp;&emsp;终端操作会从流水线生成非流的结果，如List、Integer、void等。</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">类型</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">forEach</td><td style="text-align:left">终端</td><td style="text-align:left">消费流中的每个元素并对其应用Lambda，返回void</td></tr><tr><td style="text-align:left">count</td><td style="text-align:left">终端</td><td style="text-align:left">返回流中元素的个数，返回long</td></tr><tr><td style="text-align:left">collect</td><td style="text-align:left">终端</td><td style="text-align:left">把流归约为集合，如List、Map甚至Integer</td></tr></tbody></table><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——第一节，内容包括：引文(为什么有了集合还需要流、流解决了集合的两个问题、流的优点)，流简介(stream和parallelStream、流是什么)，流和集合(只能遍历一次、外部迭代和内部迭代)，流的操作(中间操作、终端操作)
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>默认方法（未完成）</title>
    <link href="http://linyishui.top/2019092101.html"/>
    <id>http://linyishui.top/2019092101.html</id>
    <published>2019-09-21T03:13:17.000Z</published>
    <updated>2019-11-22T10:44:20.947Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a><strong>默认方法</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><blockquote><p><strong>把代码传递给方法（方法引用、Lambda）和接口中的默认方法这两种特性的补充可以看作是为Stream而设计的</strong>。</p></blockquote><p>&emsp;&emsp;默认方法的设计初衷是为了支持库设计师，辅助他们写出更容易改进的接口。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students1 = inventory.stream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span></span></span><br><span class="line"><span class="function">                                   .<span class="title">collect</span><span class="params">(toList())</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">List</span>&lt;<span class="title">Student</span>&gt; <span class="title">students2</span> = <span class="title">inventory</span>.<span class="title">parallelStream</span><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span></span></span><br><span class="line"><span class="function">                                   .<span class="title">collect</span><span class="params">(toList())</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 8之前，List是没有stream()或parallelStream()方法的，List所继承的Collection<t>接口也没有。那么对于设计者而言，最简单的做法就是把stream()方法加入Collection接口，并加入ArrayList类的实现。但这样的更新使Collection接口多出一个方法，以前版本中会有大量依照Collection接口而扩展的实体类，他们就必须都实现stream()方法，那么<strong>怎样才能改变已发布的接口而不用破坏已有的实现呢</strong>？</t></p><p>&emsp;&emsp;Java 8采用的做法就是<strong>允许接口包含实现类没有提供实现的方法签名，缺失的这些方法由接口来完成实现</strong>。所以<strong>Java 8提供了default关键字来在接口中实现默认方法</strong>。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List源码中sort方法的默认实现</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="built_in">sort</span>(Comparator&lt;? <span class="keyword">super</span> E&gt; c) &#123;</span><br><span class="line">    <span class="keyword">Object</span>[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">Object</span> e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.<span class="built_in">set</span>((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类可以实现多个接口，当默认实现冲突时，Java有一套处理和限制来避免类似C++的菱形继承问题。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>Optional（未完成）</title>
    <link href="http://linyishui.top/2019092701.html"/>
    <id>http://linyishui.top/2019092701.html</id>
    <published>2019-09-21T03:12:22.000Z</published>
    <updated>2019-11-20T10:59:43.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a><strong>Optional</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;函数式语言会通过更多的描述性数据类型来避免null，Java 8提供了Optional<t>类，使用它可以有效的避免NullPointerException。</t></p><p>&emsp;&emsp;Optional<t>类是一个容器类，可以包含也可以不包含值，代表一个值存在或不存在，其方法可以明确地处理值不存在的情况。</t></p><blockquote><ul><li>isPresent() 在值存在时返回true，否则返回false。</li><li>isPresent(Consumer<t> block) 在值存在时执行给定代码块。</t></li><li>T get() 在值存在时返回值，否则抛出异常NoSuchElement。</li><li>T orElse() 在值存在时返回值，否则返回一个默认值。</li></ul></blockquote><p>&emsp;&emsp;未完待续！！！第10章</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>行为参数化</title>
    <link href="http://linyishui.top/2019092001.html"/>
    <id>http://linyishui.top/2019092001.html</id>
    <published>2019-09-20T06:52:26.000Z</published>
    <updated>2019-11-22T10:44:29.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a><strong>行为参数化</strong></h1><p>&emsp;&emsp;行为参数化是一种开发模式，Lambda只是提供了更简洁的实现方式，让旧版本通过类和接口的实现方式变得更方便罢了。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a><strong>意义</strong></h2><p>&emsp;&emsp;应对频繁变更的需求：行为参数化意味着可以准备一段代码，并推迟它的执行，比如可以当作参数传递给另一个方法，等到需要时再执行。</p><hr><h2 id="旧版本实现行为参数化"><a href="#旧版本实现行为参数化" class="headerlink" title="旧版本实现行为参数化"></a><strong>旧版本实现行为参数化</strong></h2><p>&emsp;&emsp;如书中苹果集合筛选实例，客户从颜色开始提出需求，再到重量等，每个需求我们都需要实现一个filter。你可能会想，还是有办法只用一个filter的，于是你实现了filter(List<apple> inventory, String color, int weight, …)，但这并不能根本解决问题，比如需求变更为根据不同场景筛选对应的属性，或是组合多个属性进行复杂查询，又该如何减少重复代码呢？</apple></p><p>&emsp;&emsp;我们可以对苹果的筛选标准建模，定义一个<strong>谓词</strong>，返回一个boolean值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ApplePredicate&#123;</span><br><span class="line">    boolean test(Apple apple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以我们可以根据需求去扩展ApplePredicate的实现，不同的筛选策略就实现对应的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们把这些不同的策略看作是filter方法的不同行为，这类似于<strong>策略设计模式</strong>，我们可以封装一些算法，在运行时再去选择一个执行。ApplePredicate就是算法族，AppleHeavyWeightPredicate等就是不同策略。</p><p>&emsp;&emsp;下一步我们需要filterApples()方法能接收ApplePredicate对象，这就是行为参数化：<strong>让方法接受多种行为（策略）作为参数，并在内部使用，来完成不同的行为</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">List</span>&lt;Apple&gt; filterApples(<span class="keyword">List</span>&lt;Apple&gt; inventory, ApplePredicate p)&#123;</span><br><span class="line">    <span class="keyword">List</span>&lt;Student&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(Apple apple : inventory)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(apple))&#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述过程中我们已经做到了让filterApples()方法根据我们定义ApplePredicate对象传递的代码来选择行为，实际上就已经做到了行为参数化。</p><p>&emsp;&emsp;我们发现<strong>解决不断变更的需求这一问题时，通过把迭代集合这一行为和筛选逻辑判断行为进行了分离，随着需求而变的行为作为参数传递选择，从而通过重复使用一个方法来应对变化的需求</strong>。</p><hr><h2 id="对行为参数化进行优化"><a href="#对行为参数化进行优化" class="headerlink" title="对行为参数化进行优化"></a><strong>对行为参数化进行优化</strong></h2><p>&emsp;&emsp;因为filterApples()方法只能接受对象，所以我们传递的代码只能包装在对象中，但Java 8后就可以通过Lambda，直接把apple.getWeight() &gt; 150;这种表达式直接传递给filterApples()方法，而不用构建多个ApplePredicate对象。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a><strong>匿名类</strong></h3><p>&emsp;&emsp;熟悉Java的人可能会想到匿名类好像就可以解决重复创建ApplePredicate对象的问题，因为它可以随用随建。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; result = filterApples(<span class="name">inventory</span>, new ApplePredicate()&#123;</span><br><span class="line">    public boolean test(<span class="name">Apple</span> apple)&#123;</span><br><span class="line">        return apple.getWeight() &gt; <span class="number">150</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但匿名类仍存在一些缺点：1.它不太简洁。2.它让用户觉得难以理解。匿名类虽然解决了为ApplePredicate接口构建实体类的问题，但实际上仍需要创建这些对象，实际上并没有彻底的解决啰嗦的问题。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><strong>Lambda表达式</strong></h3><p>&emsp;&emsp;Lambda表达式的实现如下，彻底解决了啰嗦问题。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; result = filterApples(<span class="name">inventory</span>, (<span class="name">Apple</span> a) -&gt; apple.getWeight() &gt; <span class="number">150</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h3><p>&emsp;&emsp;通过泛型进一步抽象，让filterApples()能够适用更多的对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; filter(<span class="keyword">List</span>&lt;T&gt; <span class="keyword">list</span>, Predicate&lt;T&gt; p)&#123;</span><br><span class="line">    <span class="keyword">List</span>&lt;Student&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(T e : <span class="keyword">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(e))&#123;</span><br><span class="line">            result.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍了行为参数化这一概念，行为参数化的意义，在Java 8版本前如何实现行为参数化，Java 8又对行为参数化提供了哪些支持等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java8的新特性</title>
    <link href="http://linyishui.top/2019091901.html"/>
    <id>http://linyishui.top/2019091901.html</id>
    <published>2019-09-19T01:35:44.000Z</published>
    <updated>2019-11-22T10:42:54.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a><strong>Java8的新特性</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;Java 8是改动较大的一个版本，新增了Lambda表达式、函数式编程、流等，当然也有一些其他扩充功能的更新。这些变化主要反映了Java从注重改变现有值得经典面向对象思想转变为向函数式编程领域转变。这些改动会很大程度上对开发人员起到帮助，让编程更容易更轻松。</p><p>&emsp;&emsp;对于并发编程来说，Java 1.0时有线程和锁，甚至提供了内存模型，但没有相关专业知识的团队很难可靠的使用这些工具。Java 5时添加了工业级的构建模块，如线程池和并发集合。Java 7时添加了分支/合并（fork/join）框架，使得并行变得更加实用，但依旧会有些困难。Java 8则对并行提供了一个更简单的新思路。</p><hr><h2 id="第二节-三个新的编程概念"><a href="#第二节-三个新的编程概念" class="headerlink" title="第二节 三个新的编程概念"></a><strong>第二节 三个新的编程概念</strong></h2><h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a><strong>流处理</strong></h3><p>&emsp;&emsp;流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，以相同方式将数据项写入输出流。</p><p>&emsp;&emsp;比如在Unix或Linux中，很多程序从标准输入中读取数据（Unix和C中的stdin，Java中的System.in），然后把结果写入标准输出（Unix和C中的stdout，Java中的System.out）。如下命令，cat会把两个文件连接起来创建一个流，tr会转换流中的字符，sort会对流中的行进行排序，trail -3则会给出流的最后三行。Unix允许这些程序通过<strong>管道</strong>（|）连接起来。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 | <span class="type">tr</span> <span class="string">"[A-Z]"</span> <span class="string">"[a-z]"</span> | <span class="type">sort</span> | <span class="type">trail</span> <span class="number">-3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述语句会先把字母转为小写，然后打印出排序后的最后三个单词。sort会把一个行流作为输入，产生了另一个行流，进行排序并输出。在Unix中，这些命令是同时执行的，就像工厂式的流水线，虽然整个命令序列像是是一步一步完成的，但各个命令的运行是并行的。</p><p>&emsp;&emsp;基于此思想，Java 8在java.util.stream中添加了一个Stream API；可以把Stream<t>看作是一个迭代器，它可以链接起来形成一个流水线。它带来的好处就是我们可以像SQL那样写查询语句的思路，把这样的流转为那样的流，而不是一次只能处理一个项目，而且Java可以很透明的把输入中不相关的部分分开放到几个CPU内核上分别执行，这样自动的并行就省去我们去开辟线程的功夫了。</t></p><h3 id="用行为参数化把代码传递给方法"><a href="#用行为参数化把代码传递给方法" class="headerlink" title="用行为参数化把代码传递给方法"></a><strong>用行为参数化把代码传递给方法</strong></h3><p>&emsp;&emsp;比如我们有一组学生数据，包括其年龄，学期成绩，班级，学号等信息，我们可能有各种排序需求，真正想要的就是通过给sort一个参数让其定义顺序。我们可以写一个函数compareUsingAge来比较学生的年龄，但Java 8之前我们没法把这个方法传递给另一个方法，所以只能创建一个Comparator对象，然后把对象传递给sort方法。而有了行为参数化后，这样的需求就可以简单的实现了，我们可以把compareUsingAge方法作为参数传递给sort。</p><p>&emsp;&emsp;<strong>把代码传递给方法</strong>这种方式简洁的表达了<strong>行为参数化</strong>，也许你会想可以通过<strong>匿名类</strong>实现行为参数化，但Lambda和方法引用可以更清晰和简单的来实现这一需求。</p><h3 id="并行与共享的可变数据"><a href="#并行与共享的可变数据" class="headerlink" title="并行与共享的可变数据"></a><strong>并行与共享的可变数据</strong></h3><p>&emsp;&emsp;如果我们的代码可以拆分为多个副本并独立工作时，并行是可以确保的，但如果要写入一个共享变量或对象，如果两个线程都要同时修改这个变量，就是不能允许的了。当然你可以通过synchronized来打破<strong>不能有共享的可变数据</strong>这一原则，但打破的同时也就意味着放弃了所有相关的优化，同步就意味着要按照顺序执行，这与并行的宗旨相悖。</p><p>&emsp;&emsp;<strong>没有共享的可变数据</strong>，<strong>将代码传递给方法的能力</strong>这两个概念是<strong>函数式编程范式</strong>的基石。而相反的<strong>命令式编程范式</strong>中，程序是一系列改变状态的指令。</p><blockquote><p>Java 8为并行做的优化：</p><ul><li>库会负责分块，把大的流分成几个小的流，以便于并行处理。</li><li>流所提供的这个免费并行，只有在传递给filter之类的库方法的函数不会互动时才能工作。函数式编程中函数的主要意思是函数可以作为一等值，但也隐含着执行时元素间无互动的意思。</li></ul></blockquote><hr><h2 id="第三节-行为参数化"><a href="#第三节-行为参数化" class="headerlink" title="第三节 行为参数化"></a><strong>第三节 行为参数化</strong></h2><p>&emsp;&emsp;<a href="../2019092001.html" title="Title">行为参数化</a></p><hr><h2 id="第四节-默认方法"><a href="#第四节-默认方法" class="headerlink" title="第四节 默认方法"></a><strong>第四节 默认方法</strong></h2><p>&emsp;&emsp;<a href="../2019092101.html" title="Title">默认方法</a></p><hr><h2 id="第五节-Lambda表达式"><a href="#第五节-Lambda表达式" class="headerlink" title="第五节 Lambda表达式"></a><strong>第五节 Lambda表达式</strong></h2><p>&emsp;&emsp;<a href="../2019031802.html" title="Title">Lambda表达式</a></p><hr><h2 id="第六节-流"><a href="#第六节-流" class="headerlink" title="第六节 流"></a><strong>第六节 流</strong></h2><p>&emsp;&emsp;<a href="../2019092201.html" title="Title">流（一）入门介绍</a></p><p>&emsp;&emsp;<a href="../2019092301.html" title="Title">流（二）使用和构建</a></p><p>&emsp;&emsp;<a href="../2019092401.html" title="Title">流（三）收集器</a></p><p>&emsp;&emsp;<a href="../2019092501.html" title="Title">流（四）并行化处理</a></p><hr><h2 id="第七节-函数式编程"><a href="#第七节-函数式编程" class="headerlink" title="第七节 函数式编程"></a><strong>第七节 函数式编程</strong></h2><p>&emsp;&emsp;函数式编程是一种新的编程风格，核心就是把函数作为值。利用函数式编程可以用更少的时间，写出更清晰、简洁的代码。函数所指的这部分代码，可以被来回传递并加以组合，从而产生强大的编程语汇。</p><hr><h2 id="第八节-模式匹配-Switch"><a href="#第八节-模式匹配-Switch" class="headerlink" title="第八节 模式匹配-Switch"></a><strong>第八节 模式匹配-Switch</strong></h2><p>&emsp;&emsp;模式匹配可以在一些场景下代替if-then-else，但两者孰优孰劣并没有定论。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">expr</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;switch限制值为原始类型和String，函数式语言倾向于允许switch能用在更多的数据类型上。</p><p>&emsp;&emsp;未完待续！！！第14章</p><hr><h2 id="第九节-Optional"><a href="#第九节-Optional" class="headerlink" title="第九节 Optional"></a><strong>第九节 Optional</strong></h2><p>&emsp;&emsp;<a href="../2019092101.html" title="Title">Optional</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍一些Java8的新特性，内容包括：引文，三个新的编程概念（流处理、用行为参数化把代码传递给方法、并行与共享的可变数据），行为参数化，默认方法，Lambda表达式，流，函数式编程，模式匹配，Optional等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（三）主机规划与磁盘分区（未完成）</title>
    <link href="http://linyishui.top/2019091801.html"/>
    <id>http://linyishui.top/2019091801.html</id>
    <published>2019-09-18T09:20:59.000Z</published>
    <updated>2019-11-17T13:52:14.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-Linux"><a href="#第二章-Linux" class="headerlink" title="第二章 Linux"></a><strong>第二章 Linux</strong></h1><h2 id="第一节-硬件搭配"><a href="#第一节-硬件搭配" class="headerlink" title="第一节 硬件搭配"></a><strong>第一节 硬件搭配</strong></h2><p>&emsp;&emsp;Linux系统中，每个装置都会当作一个文件来看待。如IDE接口的硬盘文件名为/dev/sd[a-d]，a-d可选任意一个。几乎所有硬件装置文件都在/dev目录中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010104.png" alt="常见装置在Linux中的文件名"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010105.png" alt="常见装置在Linux中的文件名"></p><p>&emsp;&emsp;如果Linux所在机器是云端，可能得到的是虚拟机，为了加速，虚拟机中磁盘通过仿真器生成，对应的磁盘文件名为/dev/vd[a-p]系列文件名。</p><hr><h2 id="第二节-磁盘分区"><a href="#第二节-磁盘分区" class="headerlink" title="第二节 磁盘分区"></a><strong>第二节 磁盘分区</strong></h2><p>&emsp;&emsp;Linux系统作为一组程序，自然是要安装在磁盘中的。我们知道常见的磁盘接口有：SATA和SAS接口。近些年大部分的Linux distribution将IDE界面的磁盘文件名仿真成SATA了。虚拟机使用的<strong>虚拟磁盘</strong>并非是正规的磁盘界面，<strong>正常的实体机器基本都使用/dev/sd[a-]的磁盘文件名，而虚拟机环境下，为了加速，可能就会使用/dev/vd[a-p]这种装置文件名</strong>。</p><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（三）主机规划与磁盘分区，内容包括：等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（二）Linux简介</title>
    <link href="http://linyishui.top/2019091701.html"/>
    <id>http://linyishui.top/2019091701.html</id>
    <published>2019-09-17T03:20:42.000Z</published>
    <updated>2019-11-15T09:07:21.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-Linux"><a href="#第二章-Linux" class="headerlink" title="第二章 Linux"></a><strong>第二章 Linux</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;Linux就是一套操作系统，也就是核心和系统呼叫接口两层。操作系统是针对特定的硬件平台开发，所以不同的硬件平台自然无法运行一套操作系统，跨平台需要移植，Linux具有可移植性，是开源的操作系统。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010101.png" alt="操作系统的角色"></p><p>&emsp;&emsp;Linux从Unix沿袭了一个完整的操作系统中最底层的硬件控制与资源管理的完整架构，非常稳定和强大。</p><hr><h2 id="第二节-历史"><a href="#第二节-历史" class="headerlink" title="第二节 历史"></a><strong>第二节 历史</strong></h2><p>&emsp;&emsp;1969年，贝尔实验室的员工Ken Thompson以汇编语言写出了一组<strong>核心程序</strong>，以及一个小的<strong>文件系统</strong>。这个文件系统有两个重要的概念：<strong>（1）所有的程序或系统装置都是文件。（2）不管建构编辑器还是附属文件，所写的程序只有一个目的，且要有效的完成目标</strong>。这些概念对后续Linux的发展有很重要的影响。</p><p>&emsp;&emsp;1973年，Unix正式诞生，最开始Tompson和Ritchie合作用高阶语言：B语言来撰写，但实现出的核心效能并不好，后来Ritchie用C语言重新改写和编译Unics的核心，最后发行Unix的正式版本。</p><p>&emsp;&emsp;1977年，Unix分支–<strong>BSD</strong>诞生。1973年后Unix便和学术界进行了合作，加州伯克利大学的Bill Joy对Unix进行了移植，修改为实验室机器适合的版本，并增加了许多工具软件和编译程序，最终命名为Berkeley Software Distribution(BSD)。Bill Joy也是Sun公司的创办者。Unix具有高度可移植性和强大的效能，再加上当时并没有太多版权的纠纷，所以市场上出现了很多商业公司自家的Unix系统。在这个阶段各个公司还没有制定协议的概念，硬件各不相同所以开发出的Unix系统以及相关软件也无法在其他平台使用。</p><p>&emsp;&emsp;1979年，AT&amp;T推出System V第七版Unix，终于有了可以支持x86架构的个人计算机系统。但AT&amp;T在这一代尝试收回Unix版权，特别是限制了不可对学生提供源代码。</p><p>&emsp;&emsp;1984年，Andrew Tanenbaum教授自己手写了Minix这个Unix Like核心程序，为了避免版权纠纷，在开发时他完全脱离了Unix核心源代码，终于在1986年完成。但Minix并不是免费的，它的诞生就是作者为了教学，所以也没有后续的发展和更新。</p><p>&emsp;&emsp;1984年，Richard Mathew Stallman发起了<strong>GNU计划</strong>，对后来的自由和开源软件开启了大门。GNU计划的目的是：<strong>建立一个自由、开放的Unix操作系统</strong>。Stallman从开发免费的Unix程序开始慢慢打响了知名度，然后又撰写了C语言的编译程序：GNU C Compiler(gcc)，在这个过程中他还把写过的Emacs编辑器（可以在编辑时就指出语法的错误）移植到了Unix上，并公布了源代码。Stallman通过Emacs赚到了一定的资金并成立了<strong>自由软件基金会</strong>（FSF，Free Software Foundation），基金会请到了更多的开发者参与终于完成了GCC，之后Stallman还撰写了可以被呼叫的C函式库(GNU C library)，以及可以被使用来操作OS的基本接口BASH shell。</p><p>&emsp;&emsp;1985年，为了避免GNU开发的自由软件被他人注册为专利软件，Stallman和律师草拟了<strong>通用公共许可证</strong>（General Public License，GPL），并称呼为copyleft相比于专利软件的copyright。FSF的核心观念是【<strong>版权只读是促进社会进步的手段，但版权本身不是自然权利</strong>】，自由软件的重点不是指免费，而是指具有自由度的软件，<strong>使用者可以自由的执行、复制、再发行、学习、修改和强化自由软件</strong>。</p><p>&emsp;&emsp;GNU在开发的核心叫hurd，是一款架构非常先进的核心，但开发者对其要求太高，导致一直推迟了发布，也影响了后来Linux的开发。</p><p>&emsp;&emsp;1991年，芬兰的赫尔辛基大学的Linus Torvalds在BBS上贴了一则消息，说他以bash，gcc等GNU工具写了一个小的核心程序，不是GNU那样的专业程序，比较像玩具。但此核心程序可以在Intel的386个人计算机上运作，引起了很多人的兴趣。Torvalds通过学习Minix操作系统学习了核心程序设计的设计概念，但他对个人计算机缺少服务器的<strong>多任务处理能力</strong>不是很满意，所以他测试了很久386的硬件性能。在拿到Minix后，他也发现Minix虽然很棒，但创始人Tanenbaum教授不愿意加强其功能，所以Torvalds就动手开始改写自己的核心程序。</p><p>&emsp;&emsp;撰写程序首先需要的是能够工作的环境，再来则是可以将原始码编译为可执行文件的编译程序。<strong>还好GNU计划提供了bash工作环境和gcc编译程序等自由软件</strong>，Torvalds参考了Minix的设计理念和书籍上的程序代码，开始研究386个人计算机的效能优化，通过GNU自由软件将核心程序代码和386结合起来，最终写出了他需要的核心程序。最终这个玩具可以在386上运行，并且可以读取Minix的文件系统。之后他便将这个程序放到了网上供别人下载，并在BBS上贴了一则消息，而他放置这个程序的FTP目录为Linux，也就成为了它的名字。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010102.png" alt="Linus Torvalds在BBS上发布Linux"></p><p>&emsp;&emsp;之后Torvalds尝试在Linux上运行一些Unix的程序，但大部分都无法启动。所以他现在有两种选择：第一是修改软件，让其可以运行在Linux上；第二是修改Linux，让Linux符合软件运行的规范。Torvalds选择了后者，他希望Linux可以兼容Unix，于是他参考了标准的POSIX规范（可携式操作系统接口，由IEEE发布，主要针对Unix与一些软件运行时的标准），这个决定也是后来Linux发展状大的一个重要原因。</p><p>&emsp;&emsp;Linux的发展离不开社群的贡献，Torvalds在一开始便将Linux发布在网络中，有人使用后出现各种问题和需求，Torvalds就会及时的进行处理和更新。但一个人力量是有限的，因为Linux核心是Open Source的，所以网络和社群上的人很容易就可以跟随Linux的设计架构，并为一些硬件开发出兼容的驱动程序或软件等。Torvalds总是以【<strong>先求有且能运行，再求进一步改良</strong>】为准则，这鼓励到了很多志愿者加入了这个团队。同时<strong>为了适应这种随时都有程序代码加入的状况，Linux发展为具有模块的功能</strong>。将一些功能独立出核心，在需要时再加载进核心中，这样模块化的设计大大的提升了Linux核心的可维护能力。</p><p>&emsp;&emsp;1994年，Linux核心正式版上线。1996年完成了2.0版，2011年更新了3.0版，2015年更新了4.0版。</p><h3 id="自由软件和开源软件"><a href="#自由软件和开源软件" class="headerlink" title="自由软件和开源软件"></a><strong>自由软件和开源软件</strong></h3><blockquote><p>自由软件的特色：</p><ul><li>取得软件与原始码：你可以根据自己的需求来执行这个自由软件。</li><li>复制：你可以自由的复制该软件。</li><li>修改：你可以将取得的原始码进行修改，使其适应你的工作。</li><li>再发行：你可以将你修改过的程序，再度的自由发行，不会和原撰写者发生冲突。</li><li>回馈：你可以将你修改过的程序代码回馈给社群。</li></ul></blockquote><blockquote><p>自由软件禁止：</p><ul><li>修改授权：你不能把一个GPL授权的自由软件，在修改后取消GPL授权。</li><li>单纯贩卖：你不能单纯的贩卖自由软件。</li></ul></blockquote><p>&emsp;&emsp;<em>自由软件也是可以贩卖的，但不能单售卖自由软件，而是厂商自己开发和制作的部分，特别是服务</em></p><blockquote><p>开源软件规则：</p><ul><li>公布原始码且用户具有修改权：用户可以任意的修改和编译程序代码，与自由软件相同。</li><li>任意的再散布：此程序代码全部或部分可以被贩卖，且程序代码可以成为其他软件的组件之一，作者不应该称自己具有所有权，或收取额外的费用。</li><li>必须允许修改或衍生的作品，且可让再发布的软件使用相似的授权来发表即可。</li><li>承上，用户可使用与原本软件不同的名称或编号来散布。</li><li>不可限制某些个体或团体的使用权。</li><li>不可限制某些领域的应用：如不可限制其不能用于商业行为或学术行为等领域</li><li>不可限制在某些产品中，亦即程序代码可以应用于多种不同产品中。</li><li>不可具有排他条款，如不可限制此程序代码不能用于教育类研究中等。</li></ul></blockquote><p>&emsp;&emsp;GPL自由软件在商业上相比开源软件要有更多限制，所以许多商业公司选择拥抱其他open source开源软件授权，因为可以用于商业行为。<em>ps：有些专利软件也会通过Freeware和Shareware的模式来开放免费版本给大众使用噢</em>。</p><hr><h2 id="第三节-版本"><a href="#第三节-版本" class="headerlink" title="第三节 版本"></a><strong>第三节 版本</strong></h2><p>&emsp;&emsp;Linux的核心版本编号如下格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3<span class="selector-class">.10</span><span class="selector-class">.0-123</span><span class="selector-class">.e17</span><span class="selector-class">.x86_64</span></span><br><span class="line">主版本.次版本.释出版本<span class="selector-tag">-</span>修改版本</span><br></pre></td></tr></table></figure><h3 id="奇数偶数版本分类"><a href="#奇数偶数版本分类" class="headerlink" title="奇数偶数版本分类"></a><strong>奇数偶数版本分类</strong></h3><p>&emsp;&emsp;当主次版本为奇数，表示是<strong>发展中版本</strong>（development），如2.5.XX；当主次版本为偶数，则表示为<strong>稳定版本</strong>（stable）。<strong>释出版本</strong>是主次版本的架构不变时，新增功能累积到一定程度后释放的核心版本。修改版本就是使用者各自针对某个进行核心程序代码修改后的版本。</p><h3 id="主线版本和长期维护版本"><a href="#主线版本和长期维护版本" class="headerlink" title="主线版本和长期维护版本"></a><strong>主线版本和长期维护版本</strong></h3><p>&emsp;&emsp;3.0后奇数偶数编号格式就不再使用了，而是依据主线版本（MainLine）来开发，如3.10基于3.9架构继续开发。</p><p>&emsp;&emsp;旧版本在出现新的版本之前会有两种机制来处理，一是结束开发，表示此程序代码已结束不会再维护；二是保持该版本的持续维护，即长期维护版本，如3.10即为一个长期维护版本，如果出现BUG等问题，维护人员会进行更新维护。</p><h3 id="核心版本和发布商版本"><a href="#核心版本和发布商版本" class="headerlink" title="核心版本和发布商版本"></a><strong>核心版本和发布商版本</strong></h3><p>&emsp;&emsp;Linux核心版本和一些distribution的版本不相同，如Linux 7.x 应该是指CentOS这个distribution的版本。</p><p>&emsp;&emsp;为了让更多使用者能够使用Linux，许多商业公司和非盈利团体，将Linux Kernel（包括tools）与一些可运行软件整合起来，再加上了自己一些有创意的工具程序，可以让用户通过存储设备或网络来安装和管理Linux系统。这个【Kernel + Softwares + Tools + 可完全安装程序】就被叫作Linux distribution，Linux发布商套件。</p><p>&emsp;&emsp;比较知名的有Red Hat，SuSE，Ubuntu，Fedora，Debian等，这些系统重复性很高，并都基于<strong>Linux Standard Base</strong>（LSB）标准以及目录架构的<strong>File system Hierarchy Standard</strong>（FHS）来开发，所以不会有太大差异，区别可能就是平台自家开发的管理工具以及套件管理的模式吧。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010103.png" alt="Linux distribution分类"></p><p><em>商业版会稳定些，而社群版可能会有一些潜在的BUG</em></p><hr><h2 id="第四节-应用场景"><a href="#第四节-应用场景" class="headerlink" title="第四节 应用场景"></a><strong>第四节 应用场景</strong></h2><h3 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a><strong>网络服务器</strong></h3><p>&emsp;&emsp;Linux最热门的应用场景。Linux系统网络功能非常稳定和强大，特别适合用作网络服务器，如WWW，Mail Server，File Server等。</p><h3 id="关键任务的应用-金融数据库、大型企业网管环境"><a href="#关键任务的应用-金融数据库、大型企业网管环境" class="headerlink" title="关键任务的应用(金融数据库、大型企业网管环境)"></a><strong>关键任务的应用(金融数据库、大型企业网管环境)</strong></h3><p>&emsp;&emsp;关键任务就是企业最重要的业务，比如金融行业最重要的投资者和账户的数据，这些数据大部分是由数据库系统来作为存取接口，往往都采用Linux。</p><h3 id="学术机构的高效能运算任务"><a href="#学术机构的高效能运算任务" class="headerlink" title="学术机构的高效能运算任务"></a><strong>学术机构的高效能运算任务</strong></h3><p>&emsp;&emsp;Linux具有强大的运算能力，也具有支持度相当广泛的GCC编译软件，很适合一些学术机构的研究软件。</p><h3 id="个人计算机"><a href="#个人计算机" class="headerlink" title="个人计算机"></a><strong>个人计算机</strong></h3><p>&emsp;&emsp;桌面计算机（Desktop）的绝大部分功能需求Linux都已经可以满足了，旧版本缺少的窗口接口在Linux和X Window System结合后也得到了解决，Linux经过多年的发展已经兼容了绝大部分常用的办公和生活软件。</p><h3 id="移动设备"><a href="#移动设备" class="headerlink" title="移动设备"></a><strong>移动设备</strong></h3><p>&emsp;&emsp;Android就是Linux的一个分支。</p><h3 id="嵌入式设备"><a href="#嵌入式设备" class="headerlink" title="嵌入式设备"></a><strong>嵌入式设备</strong></h3><p>&emsp;&emsp;嵌入式系统基本不会有太大的更新，比如路由器、防火墙、收集、IP分享器、交换机、机器人芯片、家电产品等都可以使用Linux系统。</p><h3 id="云端应用"><a href="#云端应用" class="headerlink" title="云端应用"></a><strong>云端应用</strong></h3><p>&emsp;&emsp;随着个人计算机的CPU核心数越来越多，主机的性能有些过于强大，一些硬件资源经常会闲置，促进了虚拟化技术的发展，让数据集中在云程序中，用户通过端点设备联机到云中取到运算资源。<strong>云程序</strong>的底层就是Linux，而云程序搭建出的虚拟机，内容也是Linux操作系统。（通过虚拟化技术可以在一部主机上安装多个同时运作的操作系统，从而充分利用硬件资源）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（二）Linux简介，内容包括：引文，历史，版本，应用场景等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（一）计算机概论</title>
    <link href="http://linyishui.top/2019091601.html"/>
    <id>http://linyishui.top/2019091601.html</id>
    <published>2019-09-16T07:24:33.000Z</published>
    <updated>2019-11-15T03:32:15.678Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-计算机概论"><a href="#第一章-计算机概论" class="headerlink" title="第一章 计算机概论"></a><strong>第一章 计算机概论</strong></h1><h2 id="第一节-五大单元"><a href="#第一节-五大单元" class="headerlink" title="第一节 五大单元"></a><strong>第一节 五大单元</strong></h2><p>&emsp;&emsp;计算机由以下几个单元组成：输入单元、输出单元、CPU内部的控制单元和算数逻辑单元、主存储器。</p><p>&emsp;&emsp;计算机的重点是中央处理器（Central Processing Unit, CPU），CPU是一个具有特定功能的芯片，里面含有微指令集，主要工作是管理和运算，所以CPU又分为两个单元：算数逻辑单元与控制单元。<strong>算数逻辑单元主要负责程序运算与逻辑判断，控制单元主要协调周边组件和各单元间的工作</strong>。</p><p>&emsp;&emsp;所以数据从输入单元传输到主存储器，经过CPU处理后写回主存储器，最后再传输到输出单元。<em>（因为所有数据都要经过主存储器传输，如果内存容量不足，会对性能造成很大影响，所以提升内存被认为是提高机器性能的简单做法）</em></p><hr><h2 id="第二节-指令集"><a href="#第二节-指令集" class="headerlink" title="第二节 指令集"></a><strong>第二节 指令集</strong></h2><p>&emsp;&emsp;CPU的微指令集主要有两种设计理念：精简指令集（RISC）与复杂指令集（CISC）系统。</p><h3 id="精简指令集"><a href="#精简指令集" class="headerlink" title="精简指令集"></a><strong>精简指令集</strong></h3><p>&emsp;&emsp;如字面意思，此微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令执行效能较佳。但对于复杂的任务，就需要多个指令来完成。</p><p>&emsp;&emsp;常见的RISC微指令集CPU主要为：Oracle公司的SPARC系列、IBM公司的PowerPC系列、ARM公司的ARM CPU系列等。SPARC CPU主要用于学术领域的大型工作站，或者金融体系的主服务器。Power PC则有索尼的PS3等。ARM则是绝大部分主流手机、导航设备、网络设备等所采用的CPU。</p><h3 id="复杂指令集"><a href="#复杂指令集" class="headerlink" title="复杂指令集"></a><strong>复杂指令集</strong></h3><p>&emsp;&emsp;CISC每个小指令都可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同，消耗的时间较长，但可以处理较丰富的任务。</p><p>&emsp;&emsp;常见的CISC微指令集CPU主要有AMD、Intel、VIA等x86架构CPU。大量的PC都是采用x86架构CPU。</p><hr><h2 id="第三节-其他单元"><a href="#第三节-其他单元" class="headerlink" title="第三节 其他单元"></a><strong>第三节 其他单元</strong></h2><p>&emsp;&emsp;设备主要通过主板在硬件上连接起来，主板上有个连接沟通所有设备的芯片组，使CPU可以对各个设备下达命令。</p><blockquote><ul><li>系统单元：CPU、内存和主板等相关组件。主板上有很多连接界面和适配卡。</li><li>记忆单元：包括主存储器（RAM）与辅助内存。辅助内存就是硬盘、光盘等存储设备。</li><li>输入、输出单元：触摸屏、键盘、鼠标、打印机、HDMI、投影机、蓝牙等等。</li></ul></blockquote><hr><h2 id="第四节-常见单位"><a href="#第四节-常见单位" class="headerlink" title="第四节 常见单位"></a><strong>第四节 常见单位</strong></h2><h3 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a><strong>容量单位</strong></h3><p>&emsp;&emsp;最基础的单位就是bit，代表二进制0或1。</p><p>&emsp;&emsp;字节 Byte 是很多简单数据都是8比特大小而定义的单位，所以 1 Byte = 8 bit。</p><p>&emsp;&emsp;在字节之上就通过一系列简化单位来表示所代表的位数（K,M,G,T,P,E,Z等），二进制换算是每隔一代代表1024倍，十进制换算是每隔一代代表1000倍。</p><h3 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a><strong>速度单位</strong></h3><p>&emsp;&emsp;CPU的指令周期常用MHz或GHz等单位，Hz表示秒分之一。对于网络传输，因为网络使用bit作为单位，所以为Mbps（Mbits per second）也就是每秒多少Mbit。比如常见的100M宽带，如果转换为字节时，理论最大传输值为：每秒12.5Mbyte。</p><hr><h2 id="第五节-CPU"><a href="#第五节-CPU" class="headerlink" title="第五节 CPU"></a><strong>第五节 CPU</strong></h2><p>&emsp;&emsp;早期主板上的芯片组使用两个网桥来控制各个组件的沟通：(1)<strong>北桥</strong>：负责链接速度较快的CPU、主存储器与显式适配器界面等组件。(2)<strong>南桥</strong>：负责链接速度较慢的装置接口，如硬盘、USB、网卡等。因为北桥最主要的用处是桥接CPU和主存储器，所以后来的架构将北桥内存控制器封装到CPU中了，这样CPU和主存储器不再需要一层北桥，而是直接联系，可以释放浪费的带宽，提高速度。</p><p>&emsp;&emsp;多核CPU可以理解为CPU中有多个CPU处理单元，不同的微指令集也会影响到CPU的性能。CPU的频率就是CPU每秒钟可以进行的工作次数，如3.6GHz表示CPU可以一秒钟进行3.6*10^9次工作，只用频率来判定CPU性能是比较片面的，除了不同微指令集外，架构也不同，可用的第二层快取及其计算器制也可能不同，每次频率能进行的工作指令数也不同。</p><p>&emsp;&emsp;早期因为需要通过北桥来进行连接，所有设备工作频率需要相同，所以就有了<strong>前端总线</strong>（Front Side Bus, FSB）。因为CPU指令周期最快，所以有了外频和倍频的定义，<strong>外频</strong>就是CPU和外部组件进行传输的速度，<strong>倍频</strong>则是CPU内部用来加速工作效能的一个倍数，二者的积才是CPU的频率速度。比如一个CPU内频为3.0GHz，外频是333MHz，所以倍频就是9倍（3G = 3000M = 333M * 9）。</p><p>&emsp;&emsp;<strong>超频</strong>就是将CPU的倍频或外频通过主板设定为较高的频率，倍频通常不允许修改，一般修改的是外频。如333MHz提到400MHz，但超频之后CPU被提速，主板的各个组件都要相应的提速，变为原来的1.333倍（4/3），虽然CPU可能会达到3.6GHz，但可能会导致当机等问题。</p><p>&emsp;&emsp;北桥要慢于CPU，就会变成性能的瓶颈，所以后来就将内存控制器整合到了CPU内部。这时就不需要考虑同步的外频，只要考虑整体频率即可。</p><p>&emsp;&emsp;CPU每次能够处理的数据量称为<strong>字组大小</strong>，根据CPU设计有32位和64位，32位CPU因为能解析数据量有限，最多只能支持最大4GBytes的内存。</p><p>&emsp;&emsp;CPU的<strong>超线程</strong>（Hyper-Threading），CPU指令周期太快了，所以运算核心经常得以闲置，如今的系统基本都是多任务系统，同时会有很多任务让CPU执行，所以就可以让CPU“同时”执行多个程序，来充分利用其性能。多线程的原理在其他博文中已有整理，简单的说就是CPU将缓存器分为两块，多个程序同时竞争CPU的运算单元，这样4核的CPU可以有8核的效果。</p><hr><h2 id="第六节-内存"><a href="#第六节-内存" class="headerlink" title="第六节 内存"></a><strong>第六节 内存</strong></h2><p>&emsp;&emsp;主存储器的主要组件为<strong>动态随机存取内存</strong>（Dynamic Random Access Memory, DRAM），断电后数据即丢失。</p><p>&emsp;&emsp;DDR是所谓的<strong>双倍数据传送速度</strong>（Double Data Rate），可以在一次工作周期进行两次数据传送。</p><p>&emsp;&emsp;内存除了频率/带宽和型号外，其容量是非常重要的，所有数据都要加载到内存后才能被CPU读取，内存不够大会使大容量数据无法完整加载，内存需要释放未被使用的数据，现实使用中这些释放会和影响内存性能。</p><p>&emsp;&emsp;CPU内有<strong>第二层高速缓存</strong>（L2 cache），用来存放常用的程序或数据，避免再从主存储器中读取。L2内存的速度和CPU频率相同，但DRAM无法达到这个频率，所以需要<strong>静态随机存取内存</strong>（Static Random Access Memory, SRAM）。SRAM成本较高，很难做成大容量，所以利用其速度快的优势来作缓存是很好的方案。</p><p>&emsp;&emsp;CMOS主要用来记录主板上重要的参数，包括系统时间、CPU电压和评率、各项设备的I/O地址与IRQ等，记录这些需要通电，所以主板上也会有电池。</p><p>&emsp;&emsp;BIOS（Basic Input Output System）是写死在主板上内存芯片中的一套程序，这个芯片是<strong>只读存储器</strong>（ROM）即使没有通电也可以记录数据。BIOS随着计算机发展，需要不断地进行更新，所以只能放弃ROM，转为写入如闪存（flash）或EEPRO中。BIOS开机时执行，加载CMOS中的参数，并尝试呼叫存储设备中的开机程序从而进入操作系统。</p><p>&emsp;&emsp;显式适配器又叫VGA（Vifeo Graphics Array），图像的显式颜色需要占用内存，一些3D需要一定的运算，而CPU并非针对3D而设计的，所以就在VGA中嵌入了3D加速的芯片，也就是GPU。PCI是VGA的规格，经过了AGP后又发展为PCI-Express。</p><p>&emsp;&emsp;VGA和显示器连接的接口有：D-Sub(VGA端子)，DVI，HDMI，Display port(DP)。</p><hr><h2 id="第七节-机器语言到高级语言"><a href="#第七节-机器语言到高级语言" class="headerlink" title="第七节 机器语言到高级语言"></a><strong>第七节 机器语言到高级语言</strong></h2><p>&emsp;&emsp;<strong>机器语言</strong>就是一种指令集，也叫机器码，可以让CPU直接解读的语言，通过二进制代码来表示一些机器可以直接执行的指令集合。</p><p>&emsp;&emsp;因为机器只能识别0和1这种二进制语言，为了让机器执行特定的程序，需要参考机器自身的功能，程序最重要的运算和逻辑判断是通过CPU进行处理，所以为了让CPU执行程序需要参考CPU特有的微指令集，所以不同CPU微指令集不同时，移植就是一件麻烦事，程序需要和硬件结合才能开发时，程序就无法有效的复用，每次都要重新和硬件打交道。</p><p>&emsp;&emsp;为了解决这些麻烦，经过不断地发展，从机器语言到汇编语言，最后发展到一些现在的高级语言。</p><p>&emsp;&emsp;<strong>汇编语言</strong>通过助记符来代替机器指令的操作码，从而不用面对大量的二进制串，但汇编语言基本是和机器语言指令集一一对应的，所以不能解决不同平台不能移植的问题，不同指令集也就意味着不同的汇编语言，也没有降低编程的复杂度，但其性能和机器语言相当，要高于其他语言，所以到现在也会在一些场景继续发挥作用。</p><p>&emsp;&emsp;<strong>高级语言</strong>是高度封装后的编程语言，相比面向机器的汇编和机器语言，高级语言是面向用户的。高级语言不能直接被机器理解，所以需要一个翻译的过程，变为可以执行的机器语言。翻译方式有：编译和解释，编译就是先翻译程序后再执行，解释则是一边翻译一边执行。翻译的过程由<strong>编译程序</strong>来执行，开发人员只要专注于创造性的内容即可。</p><p>&emsp;&emsp;高级语言接近算法语言，简单易理解，更有结构化，使其开发的程序更具有可读性、可维护性、可靠性等，因为脱离了和硬件的对应，所以也实现了好的可移植性，提高了复用率。</p><hr><h2 id="第八节-操作系统"><a href="#第八节-操作系统" class="headerlink" title="第八节 操作系统"></a><strong>第八节 操作系统</strong></h2><p>&emsp;&emsp;如果程序想要把数据写入内存，必然需要分配一块内存区域用来放置数据，也就意味着要了解内存地址是如何定位的，而操作系统可以完成这种和硬件打交道重复撰写句柄的任务。</p><p>&emsp;&emsp;<strong>操作系统</strong>也是一组程序，其工作重点是管理计算机所由活动以及驱动系统中所有硬件。操作系统可以实现的这些功能就是其<strong>核心</strong>（Kernel），核心主要管控硬件与提供相关的能力，这些功能十分重要，所以核心程序会被放置到内存当中的区块中进行保护，开机后就会驻留在内存当中。</p><p>&emsp;&emsp;程序通过<strong>系统呼叫</strong>（System Call）来和核心交互，只要遵守操作系统提供的开发接口，核心的系统呼叫接口会主动的把程序语言的相关语法转为可以识别的任务函数，而开发人员不需要去了解核心或硬件了。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010101.png" alt="操作系统的角色"></p><p>&emsp;&emsp;核心程序提供的这一整组开发接口叫<strong>系统呼叫层</strong>，操作系统的核心层参考硬件信息来实现，没有其他程序的帮助操作系统只是在管理整个硬件资源，只是让计算机处于准备状态，应用程序开发时参考操作系统的开发接口，也只能运行在这个操作系统上。</p><blockquote><p>核心至少要具有以下功能：</p><ul><li>系统呼叫接口</li><li>程序管理</li><li>内存管理</li><li>文件系统管理</li><li>装置的驱动</li></ul></blockquote><p>&emsp;&emsp;驱动一般由硬件厂商提供，操作系统会提供给硬件厂商一组开发接口，让他们按照接口设计驱动程序，从而使操作系统可以识别任意版本的驱动。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（一）计算机概论，内容包括：计算机五大组成单元，指令集，其他单元，常见单位，CPU，内存，机器语言到高级语言，操作系统等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 &lt;整&gt;</title>
    <link href="http://linyishui.top/2019091501.html"/>
    <id>http://linyishui.top/2019091501.html</id>
    <published>2019-09-15T03:10:59.000Z</published>
    <updated>2019-11-13T07:48:14.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h1><h2 id="第一节-介绍"><a href="#第一节-介绍" class="headerlink" title="第一节 介绍"></a><strong>第一节 介绍</strong></h2><p>&emsp;&emsp;正则表达式（Regular expression）是一组由字母和符号组成的特殊文本, 用来从文本中找出满足条件格式的句子。</p><p>&emsp;&emsp;一个正则表达式是一种从左到右匹配主体字符串的模式。“Regular expression”可以用缩写的术语“regex”或“regexp”代替。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p><p>&emsp;&emsp;假设有如下限制：用户名只能包含小写字母、数字、下划线和连字符，并且限制用户名长度在3~15个字符之间</p><blockquote><p>^[a-z0-9_-]{3,15}&amp;</p></blockquote><p>&emsp;&emsp;^是开始标记，a-z0-9_-表示字母(a-z)、数字(0-9)、下划线和连字符，3-15表示允许3~15个字符长度，$是结束标记。</p><hr><h2 id="第二节-匹配模式"><a href="#第二节-匹配模式" class="headerlink" title="第二节 匹配模式"></a><strong>第二节 匹配模式</strong></h2><h3 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1 基本匹配"></a><strong>1 基本匹配</strong></h3><p>&emsp;&emsp;正则表达式是<strong>大小写敏感</strong>的，简单的“the”就表示规则：t紧接h再紧接e。</p><blockquote><p>“the” =&gt; The fat cat sat on <strong>the</strong> mat.</p></blockquote><h3 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2 元字符"></a><strong>2 元字符</strong></h3><p>&emsp;&emsp;正则表达式主要依赖于<strong>元字符</strong>。 元字符不代表他们本身的字面意思，他们都有特殊的含义。</p><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">句号匹配任意单个字符除了换行符。</td></tr><tr><td style="text-align:center">[ ]</td><td style="text-align:left">字符种类。匹配方括号内的任意字符。</td></tr><tr><td style="text-align:center">[^ ]</td><td style="text-align:left">否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">标记?之前的字符为可选.</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:left">匹配num个大括号之间的字符 (n &lt;= num &lt;= m).</td></tr><tr><td style="text-align:center">(xyz)</td><td style="text-align:left">字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td style="text-align:center">\</td><td style="text-align:left"></td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td style="text-align:center">\</td><td style="text-align:left">转义字符,用于匹配一些保留的字符: [ ] ( ) { } . * + ? ^ $ \ \</td><td></td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">从开始行开始匹配.</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">从末端开始匹配.</td></tr></tbody></table><h4 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a><strong>2.1 点运算符 .</strong></h4><p>&emsp;&emsp;.是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 </p><blockquote><p>“.ar” =&gt; The <strong>car</strong> <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a><strong>2.2 字符集</strong></h4><p>&emsp;&emsp;<strong>字符集</strong>也叫做字符类。方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。在方括号中的字符集不关心顺序。 例如，表达式[Tt]he 匹配 the 和 The。</p><blockquote><p>“[Tt]he” =&gt; <strong>The</strong> car parked in <strong>the</strong> garage.</p></blockquote><p>&emsp;&emsp;方括号的句号就表示句号。</p><blockquote><p>“ar[.]” =&gt; A garage is a good place to park a c<strong>ar.</strong></p></blockquote><h5 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a><strong>2.2.1 否定字符集</strong></h5><p>&emsp;&emsp;一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 =</p><blockquote><p>“[^c]ar” =&gt; The car <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a><strong>2.3 重复次数</strong></h4><p>&emsp;&emsp;后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。</p><h5 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a><strong>2.3.1 * 号</strong></h5><p>&emsp;&emsp;* 号匹配在 * 之前的字符出现大于等于0次。 例如，表达式 a<em> 匹配0或更多个以a开头的字符。表达式[a-z]</em> 匹配一个行中所有以小写字母开头的字符串。</p><blockquote><p>“[a-z]*” =&gt; Th<strong>e car parked in the garage</strong> #21.</p></blockquote><p>&emsp;&emsp;* 字符和 . 字符搭配可以匹配所有的字符 .* 。 * 和表示匹配空格的符号 \s 连起来用，如表达式\s*cat\s* 匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><blockquote><p>“\s<em>cat\s</em>“ =&gt; The fat <strong>cat</strong> sat on the con<strong>cat</strong>enation.</p></blockquote><h5 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a><strong>2.3.2 + 号</strong></h5><p>&emsp;&emsp;+号匹配+号之前的字符出现 &gt;=1 次。 例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。</p><blockquote><p>“c.+t” =&gt; The fat <strong>cat sat on the mat</strong>.</p></blockquote><h5 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a><strong>2.3.3 ? 号</strong></h5><p>&emsp;&emsp;在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 [T]?he 匹配字符串 he 和 The。</p><blockquote><p>“[T]he” =&gt; <strong>The</strong> car is parked in the garage.</p></blockquote><blockquote><p>“[T]?he” =&gt; <strong>The</strong> car is parked in t<strong>he</strong> garage.</p></blockquote><h4 id="2-4-符号"><a href="#2-4-符号" class="headerlink" title="2.4 符号 {}"></a><strong>2.4 符号 {}</strong></h4><p>&emsp;&emsp;在正则表达式中 {} 是一个量词，常用来一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。</p><blockquote><p>“[0-9]{2,3}” =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to <strong>10</strong>.0.</p></blockquote><p>&emsp;&emsp;我们可以省略第二个参数。 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。</p><blockquote><p>“[0-9]{2,}” =&gt; The number was 9.<strong>9997</strong> but we rounded it off to <strong>10</strong>.0.</p></blockquote><p>&emsp;&emsp;如果逗号也省略掉则表示重复固定的次数。 例如，[0-9]{3} 匹配3位数字</p><blockquote><p>“[0-9]{3}” =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to 10.0.</p></blockquote><h4 id="2-5-…-特征标群"><a href="#2-5-…-特征标群" class="headerlink" title="2.5 (…) 特征标群"></a><strong>2.5 (…) 特征标群</strong></h4><p>&emsp;&emsp;特征标群是一组写在 (…) 中的子模式。例如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加入特征标群则表示整个标群内的字符重复 N 次。例如，表达式 (ab)* 匹配连续出现 0 或更多个 ab。</p><p>&emsp;&emsp;我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par.</p><blockquote><p>“(c|g|p)ar” =&gt; The <strong>car</strong> is <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a><strong>2.6 | 或运算符</strong></h4><p>&emsp;&emsp;或运算符就表示或，用作判断条件。例如 (T|t)he|car 匹配 (T|t)he 或 car。</p><blockquote><p>“(T|t)he|car” =&gt; <strong>The car</strong> is parked in <strong>the</strong> garage.</p></blockquote><h4 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a><strong>2.7 转码特殊字符</strong></h4><p>&emsp;&emsp;反斜线 \ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \。</p><p>&emsp;&emsp;例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \. 以下这个例子 \.?是选择性匹配.</p><blockquote><p>“(f|c|m)at.?” =&gt; The <strong>fat cat</strong> sat on the <strong>mat.</strong></p></blockquote><h4 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a><strong>2.8 锚点</strong></h4><p>&emsp;&emsp;在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。</p><h5 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a><strong>2.8.1 ^ 号</strong></h5><p>&emsp;&emsp;^ 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>&emsp;&emsp;例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。</p><p>&emsp;&emsp;例如，^(T|t)he 匹配以 The 或 the 开头的字符串。</p><blockquote><p>“(T|t)he” =&gt; <strong>The</strong> car is parked in <strong>the</strong> garage.</p></blockquote><blockquote><p>“^(T|t)he” =&gt; <strong>The</strong> car is parked in the garage.</p></blockquote><h5 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a><strong>2.8.2 $ 号</strong></h5><p>&emsp;&emsp;同理于 ^ 号，$ 号用来匹配字符是否是最后一个。</p><p>&emsp;&emsp;例如，(at.)$ 匹配以 at. 结尾的字符串。</p><blockquote><p>“(at.)” =&gt; The fat c<strong>at.</strong> s<strong>at.</strong> on the m<strong>at.</strong></p></blockquote><blockquote><p>“(at.)$” =&gt; The fat cat. sat. on the m<strong>at.</strong></p></blockquote><h3 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3 简写字符集"></a><strong>3 简写字符集</strong></h3><p>&emsp;&emsp;正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr><th style="text-align:center">简写</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">除换行符外的所有字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配所有字母数字，等同于 [a-zA-Z0-9_]</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配所有非字母数字，即符号，等同于： [^\w]</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:left">匹配数字： [0-9]</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">匹配非数字： [^\d]</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">匹配所有空格字符，等同于： [\t\n\f\r\p{Z}]</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:left">匹配所有非空格字符： [^\s]</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:left">匹配一个换页符</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:left">匹配一个换行符</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:left">匹配一个回车符</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:left">匹配一个制表符</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:left">匹配一个垂直制表符</td></tr><tr><td style="text-align:center">\p</td><td style="text-align:left">匹配 CR/LF（等同于 \r\n），用来匹配 DOS 行终止符</td></tr></tbody></table><h3 id="4-零宽度断言（前后预查）"><a href="#4-零宽度断言（前后预查）" class="headerlink" title="4 零宽度断言（前后预查）"></a><strong>4 零宽度断言（前后预查）</strong></h3><p>&emsp;&emsp;先行断言和后发断言都属于非捕获簇（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p><p>&emsp;&emsp;例如，我们想要获得所有跟在 $ 符号后的数字，我们可以使用正后发断言 (?&lt;=\$)[0-9.]*。 这个表达式匹配 $ 开头，之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次。</p><p>&emsp;&emsp;零宽度断言如下：</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">?=</td><td style="text-align:left">正先行断言-存在</td></tr><tr><td style="text-align:center">?!</td><td style="text-align:left">负先行断言-排除</td></tr><tr><td style="text-align:center">?&lt;=</td><td style="text-align:left">正后发断言-存在</td></tr><tr><td style="text-align:center">?&lt;!</td><td style="text-align:left">负后发断言-排除</td></tr></tbody></table><h4 id="4-1-…-正先行断言"><a href="#4-1-…-正先行断言" class="headerlink" title="4.1 ?=… 正先行断言"></a><strong>4.1 ?=… 正先行断言</strong></h4><p>&emsp;&emsp;?=… 正先行断言，表示第一部分表达式之后必须跟着 ?=…定义的表达式。</p><p>&emsp;&emsp;返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=…)。</p><p>&emsp;&emsp;正先行断言的内容写在括号中的等号后面。 例如，表达式 (T|t)he(?=\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。</p><blockquote><p>“(T|t)he(?=\sfat)” =&gt; <strong>The</strong> fat cat sat on the mat.</p></blockquote><h4 id="4-2-…-负先行断言"><a href="#4-2-…-负先行断言" class="headerlink" title="4.2 ?!… 负先行断言"></a><strong>4.2 ?!… 负先行断言</strong></h4><p>&emsp;&emsp;负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!…)。</p><p>&emsp;&emsp;表达式 (T|t)he(?!\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。</p><blockquote><p>“(T|t)he(?!\sfat)” =&gt; The fat cat sat on <strong>the</strong> mat.</p></blockquote><h4 id="4-3-lt-…-正后发断言"><a href="#4-3-lt-…-正后发断言" class="headerlink" title="4.3 ?&lt;= … 正后发断言"></a><strong>4.3 ?&lt;= … 正后发断言</strong></h4><p>&emsp;&emsp;正后发断言 记作(?&lt;=…) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 (?&lt;=(T|t)he\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。</p><blockquote><p>“(?&lt;=(T|t)he\s)(fat|mat)” =&gt; The <strong>fat</strong> cat sat on the <strong>mat</strong>.</p></blockquote><h4 id="4-4-lt-…-负后发断言"><a href="#4-4-lt-…-负后发断言" class="headerlink" title="4.4 ?&lt;!… 负后发断言"></a><strong>4.4 ?&lt;!… 负后发断言</strong></h4><p>&emsp;&emsp;负后发断言 记作 (?&lt;!…) 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 例如，表达式 (?&lt;!(T|t)he\s)(cat) 匹配 cat，且其前不跟着 The 或 the。</p><blockquote><p>“(?&lt;!(T|t)he\s)(cat)” =&gt; The cat sat on <strong>cat</strong>.</p></blockquote><h3 id="5-标志"><a href="#5-标志" class="headerlink" title="5 标志"></a><strong>5 标志</strong></h3><p>&emsp;&emsp;标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr><th style="text-align:center">标志</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:left">忽略大小写。</td></tr><tr><td style="text-align:center">g</td><td style="text-align:left">全局搜索。</td></tr><tr><td style="text-align:center">m</td><td style="text-align:left">多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。</td></tr></tbody></table><h4 id="5-1-忽略大小写（Case-Insensitive）"><a href="#5-1-忽略大小写（Case-Insensitive）" class="headerlink" title="5.1 忽略大小写（Case Insensitive）"></a><strong>5.1 忽略大小写（Case Insensitive）</strong></h4><p>&emsp;&emsp;修饰语 i 用于忽略大小写。 例如，表达式 /The/gi 表示在全局搜索 The，在后面的 i 将其条件修改为忽略大小写，则变成搜索 the 和 The，g 表示全局搜索。</p><blockquote><p>“The” =&gt; <strong>The</strong> fat cat sat on the mat.</p></blockquote><blockquote><p>“/The/gi” =&gt; <strong>The</strong> fat cat sat on <strong>the</strong> mat.</p></blockquote><h4 id="5-2-全局搜索（Global-search）"><a href="#5-2-全局搜索（Global-search）" class="headerlink" title="5.2 全局搜索（Global search）"></a><strong>5.2 全局搜索（Global search）</strong></h4><p>&emsp;&emsp;修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 /.(at)/g 表示搜索 任意字符（除了换行）+ at，并返回全部结果。</p><blockquote><p>“/.(at)/“ =&gt; The <strong>fat</strong> cat sat on the mat.</p></blockquote><blockquote><p>“/.(at)/g” =&gt; The <strong>fat cat sat</strong> on the <strong>mat</strong>.</p></blockquote><h4 id="5-3-多行修饰符（Multiline）"><a href="#5-3-多行修饰符（Multiline）" class="headerlink" title="5.3 多行修饰符（Multiline）"></a><strong>5.3 多行修饰符（Multiline）</strong></h4><p>&emsp;&emsp;多行修饰符 m 常用于执行一个多行匹配。</p><p>&emsp;&emsp;像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。</p><p>&emsp;&emsp;例如，表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。</p><blockquote><p>“/.at(.)?$/“ =&gt; The fat<br>                cat sat<br>                on the <strong>mat</strong>.</p></blockquote><blockquote><p>“/.at(.)?$/gm” =&gt; The <strong>fat</strong><br>                  cat <strong>sat</strong><br>                  on the <strong>mat</strong>.</p></blockquote><h3 id="6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）"><a href="#6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）" class="headerlink" title="6 贪婪匹配与惰性匹配（Greedy vs lazy matching）"></a><strong>6 贪婪匹配与惰性匹配（Greedy vs lazy matching）</strong></h3><p>&emsp;&emsp;正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。</p><blockquote><p>“/(.*at)/“ =&gt; <strong>The fat cat sat on the mat</strong>. </p></blockquote><blockquote><p>“/(.*?at)/“ =&gt; <strong>The fat</strong> cat sat on the mat. </p></blockquote><hr><h2 id="第三节-捕获组和非捕获组"><a href="#第三节-捕获组和非捕获组" class="headerlink" title="第三节 捕获组和非捕获组"></a><strong>第三节 捕获组和非捕获组</strong></h2><p>&emsp;&emsp;捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。一般一个小括号括起来就是一个捕获组。捕获组可以进行嵌套。以深度优先进行编号，在js中编号从1开始。</p><p>&emsp;&emsp;参与匹配却不进行分组编号的捕获组，其形式为（?:exp）组成，还有其他的形式</p><hr><h2 id="第四节-贪婪、勉强和独占模式"><a href="#第四节-贪婪、勉强和独占模式" class="headerlink" title="第四节 贪婪、勉强和独占模式"></a><strong>第四节 贪婪、勉强和独占模式</strong></h2><h3 id="1-贪婪模式"><a href="#1-贪婪模式" class="headerlink" title="1 贪婪模式"></a><strong>1 贪婪模式</strong></h3><p>&emsp;&emsp;匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Blog<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Facebook<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：首先 .<em> 匹配任何字符（在非 DOTALL 模式下不匹配 \n,\r,\a 一类字符），在 source 中第一个被匹配的 &lt; li &gt; 后面直至最后一个字符（也就是&lt; /ol &gt;的 &gt;）都符合 .</em> 的匹配规则，但是显然如果 .* 匹配到最后一个字符，那么没有剩余的字符去匹配正则表达式中还未匹配的 &lt; /li &gt; 的，那么会引起匹配失败。但是失败后会回溯（这一点与独占量词不同，下面会讲到）。回溯后这段正则表达式将匹配到 source 中第一个 &lt; li &gt; 和第二个 &lt; /li &gt; 以及之间的内容，如上面的输出所示。</p><h3 id="2-勉强模式"><a href="#2-勉强模式" class="headerlink" title="2 勉强模式"></a><strong>2 勉强模式</strong></h3><p>&emsp;&emsp;匹配最短。在勉强量词模式下，正则表达式会匹配尽可能短的字符串。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*?&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Blog<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Facebook<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：source 中第一个&lt; li &gt;匹配到之后到第一个&lt; /li &gt;之间的字符都符合 .* 的匹配规则，同时如果继续匹配 &lt; /li &gt; 也符合这个规则，但是勉强模式下，它会尽可能短地匹配字符串，故第一个找到的字符串应该是 &lt; li &gt;Ggicci’s Blog&lt; /li &gt;，如上面输出所示。然后它会继续匹配剩余的字符串，找到第二个。</p><h3 id="3-独占模式"><a href="#3-独占模式" class="headerlink" title="3 独占模式"></a><strong>3 独占模式</strong></h3><p>&emsp;&emsp;同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*+&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：这段正则表达式将不会在 source 找到任何匹配的内容，因为 &lt; li &gt; 匹配到后， .*+ 所能匹配的字符尽可能长地匹配下去，直到 source 的最后一个字符，这必将引起匹配失败，但是在独占模式下一旦匹配失败就不会回溯，故不存在像贪婪模式一样回溯之后找到 &lt; /ol &gt;之前的&lt; /li &gt; 的情况。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" title="Title" target="_blank" rel="noopener">learn-regex</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍正则表达式，包括：简单介绍，元字符，用法，捕获组和非捕获组，贪婪、勉强和独占模式等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="regex" scheme="http://linyishui.top/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>CentOS（未完成）</title>
    <link href="http://linyishui.top/2019091401.html"/>
    <id>http://linyishui.top/2019091401.html</id>
    <published>2019-09-14T06:40:30.000Z</published>
    <updated>2019-11-11T08:42:51.676Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;远程连接密码和实例用户密码（root）</p><p>&emsp;&emsp;进入/usr/local目录</p><blockquote><p>cd /usr/local</p></blockquote><p>&emsp;&emsp;创建/usr/local/java目录</p><blockquote><p>mkdir java</p><p>cd java</p></blockquote><p>&emsp;&emsp;通过openjdk安装JDK8</p><blockquote><p>yum -y install java-1.8.0-openjdk</p><p>java -version</p></blockquote><p>&emsp;&emsp;重命名</p><blockquote><p>mv jdk1.8.0_171 jdk1.8</p></blockquote><p>&emsp;&emsp;解压</p><blockquote><p>tar -xzvf jdk-8u171-linux-x64.tar.gz</p></blockquote><p>&emsp;&emsp;未完待续</p>]]></content>
    
    <summary type="html">
    
      简单介绍CentOS系统。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器（三）内存分配与回收策略</title>
    <link href="http://linyishui.top/2019091301.html"/>
    <id>http://linyishui.top/2019091301.html</id>
    <published>2019-09-13T09:38:40.000Z</published>
    <updated>2019-11-11T08:39:53.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a><strong>内存分配与回收策略</strong></h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a><strong>前文</strong></h2><p>&emsp;&emsp;自动内存管理可以总结为自动化的处理两个问题：<strong>给对象分配内存</strong>和<strong>回收分配给对象的内存</strong>。给对象分配内存，宏观的看就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接的栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则也并非百分百固定，细节由当前所使用的收集器组合决定，以及虚拟机中与内存相关的参数的设置。</p><p>&emsp;&emsp;接下来会介绍几个最常见的内存分配规则，并通过代码去验证这些规则。所有代码在测试时使用Client模式虚拟机运行，没有手工的指定收集器组合，验证的是在使用Serial/Serial Old收集器下的内存分配和回收的策略（ParNew / Serial Old收集器组合的规则也基本一致）。</p><hr><h2 id="5-1-对象优先在Eden分配"><a href="#5-1-对象优先在Eden分配" class="headerlink" title="5.1 对象优先在Eden分配"></a><strong>5.1 对象优先在Eden分配</strong></h2><p>&emsp;&emsp;大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p>&emsp;&emsp;虚拟机提供了<strong>-XX:+PrintGCDetails</strong>这个收集器日志参数，使虚拟机在发生垃圾收集时打印内存回收日志，并且在进程退出时输出当前内存各区域的分配情况。在应用中内存回收日志一般是打印到文件后通过日志工具进行分析。</p><p>&emsp;&emsp;下列代码中testAllocation()方法中，尝试分配3个2MB大小和1个4MB大小的对象，在运行时通过-Xms20M、-Xmx20M、-Xmn10M这三个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果可以清晰的看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代总可用空间为9216KB（Eden区+1个Survivor区的总容量）。</p><p>&emsp;&emsp;执行testAllocation()中分配allocation4对象的语句时会发生一次Minor GC，这次GC的结果是新生代6651KB变为148KB，而总内存占用量则几乎没有减少（因为allocation1、allocation2、allocation3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只能通过分配担保机制提前转移到老年代。</p><p>&emsp;&emsp;这次GC结束后，4MB的allocation4顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、allocation2、allocation3占用）。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010128.png" alt="运行结果"></p><blockquote><p>Minor GC和Full GC不同点？</p><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随着至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul></blockquote><hr><h3 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a><strong>5.2 大对象直接进入老年代</strong></h3><p>&emsp;&emsp;所谓大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是较长的字符串或数组。大对象的内存分配是对虚拟机非常考验的事情，特别是一群“朝生夕死”的“短命大对象”，应该在编程时避免出现这种场景。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集来安置它们。</p><p>&emsp;&emsp;虚拟机提供了一个<strong>-XX:PretenureSizeThreshold</strong>参数，大于此参数值的对象会直接在老年代分配。这样的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p><p>&emsp;&emsp;执行下列代码的testPretenureSizeThreshold()后，Eden空间几乎没有被使用，老年代的10MB空间则被使用了40%，所以allocation对象是直接被分配在了老年代，原因就是PretenureSizeThreshold参数设置为3MB。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> * -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation;</span><br><span class="line">    allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010129.png" alt="运行结果"></p><blockquote><p>注意：PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不会识别此参数，此收集器一般不用设置，如果遇到需要使用此参数场景，推荐使用ParNew+CMS收集器组合。</p></blockquote><hr><h3 id="5-3-长期存活的对象将进入老年代"><a href="#5-3-长期存活的对象将进入老年代" class="headerlink" title="5.3 长期存活的对象将进入老年代"></a><strong>5.3 长期存活的对象将进入老年代</strong></h3><p>&emsp;&emsp;虚拟机采用分代收集的思想来管理内存，自然需要能够识别对象应被归属的代，所以虚拟机给每个对象定义了一个<strong>对象年龄计数器</strong>。如果对象在Eden出生并经过第一次Minor GC后仍然存活，且能被Survivor容纳的话，会被移动到Survivor空间，并且年龄设置为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就会增加1岁，当年龄增加到一定程度（默认为15），会被晋升到老年代。对象晋升到老年代的年龄阈值，可以通过参数<strong>-XX:MaxTenuringThreshold</strong>设置。</p><p>&emsp;&emsp;可以尝试分别以1和15为值设置参数MaxTenuringThreshold，测试下列代码的testTenuringThreshold()。对象allocation1需要256KB内存，Survivor空间可以容纳。当MaxTenuringThreshold=1时，allocation1在第二次GC发生时进入老年代，新生代已使用内存GC后非常干净的变为0KB。而MaxTenuringThreshold=15时，第二次GC发生后，allocation1对象还留在新生代Survivor空间，此时新生代仍有40KB占用。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment"> * -XX:PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarning</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    <span class="comment">//什么时候进入老年代取决于-XX:MaxTenuringThreshold设置</span></span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">null</span>;</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;MaxTenuringThreshold=1运行结果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010130.png" alt="运行结果"></p><p>&emsp;&emsp;MaxTenuringThreshold=15运行结果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010131.png" alt="运行结果"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010132.png" alt="运行结果"></p><hr><h3 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a><strong>5.4 动态对象年龄判定</strong></h3><p>&emsp;&emsp;为了更好的适应不同程序的内存状况，虚拟机并不是一直要求对象年龄必须达到MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>。</p><p>&emsp;&emsp;执行下列代码的testTenuringThreshold2()，设置-XX:MaxTenuringThreshold=15，可以发现运行结果中Survivor空间占用依然为0%，而老年代比预期增加6%，所以allocation1、allocation2直接进入了老年代，而不是等到age=15。这两个对象内存和为512KB，且年龄相同，满足同年占比一半的规则，可以注释掉其中一个对象观察结果。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment"> * -XX:PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarning</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testTenuringThreshold2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    <span class="comment">//allocation1+allocation2大于Survivor空间一半</span></span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010133.png" alt="运行结果"></p><hr><h3 id="5-5-空间分配担保"><a href="#5-5-空间分配担保" class="headerlink" title="5.5 空间分配担保"></a><strong>5.5 空间分配担保</strong></h3><p>&emsp;&emsp;在发生Minor GC之前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立则可以保证此Minor GC是安全的。如果不成立，虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则会尝试进行一次Minor GC，尽管这次是承担着风险的。如果HandlePromotionFailure值设置不允许，或者小于平均大小，则改为进行一次Full GC。</p><p>&emsp;&emsp;“冒险”是在承担什么风险？我们知道新生代使用复制收集算法，为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象Minor GC后仍然存活的情况，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。但老年代能进行担保的前提是其自身有足够的空间可以容纳这些对象，有多少对象在GC后会活下来是无法提前知道的，所以只好取每次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p><p>&emsp;&emsp;取平均值进行比较其实是一种动态概率的手段，如果某次Minor GC后存活的对象突然激增，依然会导致担保失败（HandlePromotionFailure）。如果出现了HandlePromotionFailure失败，就只好在失败后再发动一次Full GC。虽然担保失败时最麻烦，但大部分情况下都还会将HandlePromotionFailure开关打开，避免Full GC太过频繁，参考下列代码，在JDK 6 Update 24之前的版本中运行测试。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:HandlePromotionFailure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarning</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testHandlePromotion</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation1 = <span class="keyword">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">null</span>;</span><br><span class="line">    allocation5 = <span class="keyword">null</span>;</span><br><span class="line">    allocation6 = <span class="keyword">null</span>;</span><br><span class="line">    allocation7 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010134.png" alt="运行结果"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010135.png" alt="运行结果"></p><p>&emsp;&emsp;在JDK 6 Update 24之后的版本中结果会有差异，HandlePromotionFailure参数不再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然HandlePromotionFailure参数仍然被定义了，但代码中已不会再使用它，规则改变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> TenuredGeneration::promotion_attempt_is_safe(<span class="keyword">size_t</span></span><br><span class="line">max_promotion_in_bytes) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">//老年代最大可用的连续空间</span></span><br><span class="line">    <span class="keyword">size_t</span> available = max_contiguous_available();</span><br><span class="line">    <span class="comment">//每次晋升到老年代的平均大小</span></span><br><span class="line">    <span class="keyword">size_t</span> av_promo = (<span class="keyword">size_t</span>)gc_status()-&gt;avg_promoted()-&gt;padded_average();</span><br><span class="line">    <span class="comment">//老年代可用空间是否大于平均晋升大小，或者老年代可用空间是否大于当此GC时新生代所有对象容量</span></span><br><span class="line">    <span class="keyword">bool</span> res = (available &gt;= av_promo) || (available &gt;= max_promotion_in_bytes);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：对象优先在Eden分配，大对象直接进入老年代，长期存活的对象将进入老年代，动态对象年龄判定，空间分配担保等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器（二）垃圾收集算法</title>
    <link href="http://linyishui.top/2019091201.html"/>
    <id>http://linyishui.top/2019091201.html</id>
    <published>2019-09-12T09:26:28.000Z</published>
    <updated>2019-11-08T09:13:42.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第二节-垃圾收集算法"><a href="#第二节-垃圾收集算法" class="headerlink" title="第二节 垃圾收集算法"></a><strong>第二节 垃圾收集算法</strong></h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a><strong>2.1 标记-清除算法</strong></h3><p>&emsp;&emsp;<strong>最基础</strong>的收集算法是“标记-清除”算法(Mark-Sweep)算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。最基础是因为后续的收集算法都是基于此思路改进而来。主要有两点不足：一是效率问题，标记和清除过程都不高效；另一个是空间问题，标记和清除之后会产生大量不连续的内存碎片，会导致以后在程序需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010114.png" alt="“标记-清除”算法示意图"></p><hr><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a><strong>2.2 复制算法</strong></h3><p>&emsp;&emsp;复制算法是为了解决效率问题而设计，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活的对象复制到另一块上，然后将已使用过的内存空间一次清理掉。这样的做法使每次都是对整个半区进行内存回收，内存分配时就不用考虑到内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但此算法的代价是会将内存空间缩小一半，代价实在太高。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010115.png" alt="复制算法示意图"></p><p>&emsp;&emsp;<strong>当前的商业虚拟机都采用此算法来回收新生代</strong>，IBM研究表示新生代中对象98%都是“朝生夕死”，所以不需要对半划分内存空间，而是划分为一块大的Eden空间和两块较小的Survivor空间。每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的复制到另外一块Survivor空间上，最后清理掉Eden和用过的Survivor空间。(HotSpot默认Eden和Survivor空间大小比例为8:1，即每次新生代可用内存空间为整体的90%)。当Survivor空间不够用时，需要依赖其他内存(老年代)进行<strong>分配担保</strong>(Handle Promotion)。</p><p>&emsp;&emsp;分配担保类似于银行的担保人，如果一块Survivor空间没有足够的空间存放上次新生代收集下的存活对象，可以通过分配担保机制进入老年代，只要新生代有很好的“信誉”。具体实现此处不作详细描述。</p><hr><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a><strong>2.3 标记-整理算法</strong></h3><p>&emsp;&emsp;复制算法在对象存活率较高时需要进行较多的复制操作，会降低其运行效率。还有就是如果预留空间较小就需要额外的空间进行分配担保，以应对对象存活率极高的情况，所以老年代不会选用复制算法。</p><p>&emsp;&emsp;根据老年代的特点，有了标记-整理算法，标记过程等同于标记-清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010116.png" alt="“标记-整理”算法示意图"></p><hr><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a><strong>2.4 分代收集算法</strong></h3><p>&emsp;&emsp;<strong>当前的商业虚拟机的垃圾收集都采用分代收集算法</strong>，就是根据对象的存活周期的不同将内存划分为几块。一般把Java堆划分为新生代和老年代，可以根据各个代的特点采用最适合的收集算法。新生代中，每次垃圾收集会有大量对象被清理，仅有少量存活，就采用复制算法；老年代中对象存活率较高，没有额外的内存空间作分配担保，就采用标记-清除算法或标记-整理算法。</p><hr><h2 id="第三节-HotSpot算法实现"><a href="#第三节-HotSpot算法实现" class="headerlink" title="第三节 HotSpot算法实现"></a><strong>第三节 HotSpot算法实现</strong></h2><h3 id="3-1-枚举根节点"><a href="#3-1-枚举根节点" class="headerlink" title="3.1 枚举根节点"></a><strong>3.1 枚举根节点</strong></h3><p>&emsp;&emsp;可达性分析中从GC Roots节点找引用链这个操作为例，可以作为GC Roots的节点主要在<strong>全局性的引用</strong>(如常量或类静态属性)与<strong>执行上下文</strong>(如栈帧中的本地变量表)中，有些应用仅方法区就有数百兆，逐个检查这里面的引用是不现实的。</p><p>&emsp;&emsp;可达性分析中的GC停顿用来确保分析工作在一个保证一致性的“快照”中进行。在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不能在分析过程中对象关系还在不断地变化，不能满足这一点就无法保证最终分析结果的准确性。这就是GC进行时必须停顿所有Java执行线程的其中一个原因，即使CMS收集器号称不会发生停顿，枚举根节点时也必须停顿。</p><p>&emsp;&emsp;主流的Java虚拟机都是<strong>准确式GC</strong>(虚拟机可以知道内存中某个位置的数据类型具体是什么类型，如内存中有一个32位整数123456，虚拟机可以得知其是一个reference类型指向123456内存地址或者是一个数值为123456的整数，这样虚拟机才能在GC时判断堆上的数据是否还能被使用)。所以当执行系统停顿下来，并不需要一个不漏的检查完所有<strong>执行上下文</strong>和<strong>全局的引用设置</strong>，虚拟机有办法知道哪些地方存放着对象引用。在HotSpot的实现中，是通过一组被称为<strong>OopMap</strong>的数据结构来达到此目的，在<strong>类加载完成</strong>时，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在<strong>JIT编译过程</strong>中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。所以GC在扫描时就可以直接得知这些信息了。</p><p>&emsp;&emsp;下列代码是HotSpot Client VM生成的一段String.hashCode()方法的本地代码，可以看到在0x026eb7a9处的call指令有OopMap记录，它指明了EBX寄存器和栈中偏移量为16的内存区域中各有一个<strong>普通对象指针</strong>的引用，有效范围从call指令开始直到0x026eb730（指令流的起始位置）+142（OopMap记录的偏移量）=0x026eb7be，即hlt指令为止。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Verified Entry Point]</span><br><span class="line"><span class="number">0x026eb730</span>: <span class="keyword">mov</span>    %eax,-<span class="number">0x8000</span>(%esp)</span><br><span class="line">......</span><br><span class="line"><span class="comment">;; ImplicitNullCheckStub slow case</span></span><br><span class="line"><span class="number">0x026eb7a9</span>: <span class="keyword">call</span>   <span class="number">0x026e83e0</span>         <span class="comment">; OopMap&#123;ebx=Oop [16]=Oop off=142&#125;</span></span><br><span class="line">                                        <span class="comment">;*caload</span></span><br><span class="line">                                        <span class="comment">; - java.lang.String::hashCode@48 (line 1489)</span></span><br><span class="line">                                        <span class="comment">;    &#123;runtime_call&#125;</span></span><br><span class="line">  <span class="number">0x026eb7ae</span>: <span class="keyword">push</span>   <span class="number">$0</span>x83c5c18         <span class="comment">;    &#123;external_word&#125;</span></span><br><span class="line">  <span class="number">0x026eb7b3</span>: <span class="keyword">call</span>   <span class="number">0x026eb7b8</span></span><br><span class="line">  <span class="number">0x026eb7b8</span>: <span class="keyword">pusha</span></span><br><span class="line">  <span class="number">0x026eb7b9</span>: <span class="keyword">call</span>   <span class="number">0x0822bec0</span>         <span class="comment">;    &#123;runtime_call&#125;  </span></span><br><span class="line">  <span class="number">0x026eb7be</span>: <span class="keyword">hlt</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-2-安全点"><a href="#3-2-安全点" class="headerlink" title="3.2 安全点"></a><strong>3.2 安全点</strong></h3><p>&emsp;&emsp;在OopMap的帮助下，HotSpot可以快速且准确地完成GC Roots枚举，但随之而来的一个现实的问题：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样会导致GC的空间成本变得很高。</p><p>&emsp;&emsp;HotSpot实际上并没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为<strong>安全点</strong>（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只会在安全点暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以安全点的选定基本上是以程序“<strong>是否具有让程序长时间执行的特征</strong>”为标准进行选定的——因为每条指令的执行时间都非常短暂，程序不会因为指令流长度太长这个原因而过长时间运行，“<strong>长时间执行</strong>”的最明显特征就是<strong>指令序列复用</strong>，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>&emsp;&emsp;关于Safepoint，另外一个需要考虑的问题是如何在GC发生时让所有线程（不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。有两种实现方案：<strong>抢先式中断</strong>（Preemptive Suspension）和<strong>主动式中断</strong>（Voluntary Suspension）。</p><p>&emsp;&emsp;抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点，就恢复线程，让它“跑”到安全点上。但如今几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p><p>&emsp;&emsp;主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，而只是简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><p>&emsp;&emsp;下面代码中的test指令是HotSpot生成的轮询指令，当需要暂停线程时，虚拟机把0x160100的内存页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01b6d627</span>: <span class="keyword">call</span>   <span class="number">0x01b2b210</span>         <span class="comment">; OopMap&#123;[60]=Oop off=460&#125;</span></span><br><span class="line">                                        <span class="comment">;*invokeinterface size</span></span><br><span class="line">                                        <span class="comment">; - Client::main@113 (line 23)</span></span><br><span class="line">                                        <span class="comment">;    &#123;virtual_call&#125;</span></span><br><span class="line">  <span class="number">0x01b6d62c</span>: <span class="keyword">nop</span>                       <span class="comment">; OopMap&#123;[60]=Oop off=461&#125;</span></span><br><span class="line">                                        <span class="comment">;*if_icmplt</span></span><br><span class="line">                                        <span class="comment">; - Client::main@118 (line 23)</span></span><br><span class="line">  <span class="number">0x01b6d62d</span>: <span class="keyword">test</span>   %eax,<span class="number">0x160100</span>      <span class="comment">;   &#123;poll&#125;</span></span><br><span class="line">  <span class="number">0x01b6d633</span>: <span class="keyword">mov</span>    <span class="number">0x50</span>(%esp),%esi</span><br><span class="line">  <span class="number">0x01b6d637</span>: <span class="keyword">cmp</span>    %eax,%esi</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-安全区域"><a href="#3-3-安全区域" class="headerlink" title="3.3 安全区域"></a><strong>3.3 安全区域</strong></h3><p>&emsp;&emsp;Safepoint并没有完美地解决了如何进入GC的问题。Safepoint机制保证了程序执行时，在不久的时间内就会遇到可进入GC的Safepoint，但程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要<strong>安全区域</strong>（Safe Region）来解决。</p><p>&emsp;&emsp;安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。也可以把Safe Region看做是被扩展了的Safepoint。</p><p>&emsp;&emsp;在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了，在线程需要离开Safe Region时，它就要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><p>&emsp;&emsp;到此，简单介绍了HotSpot虚拟机如何去发起内存回收的问题，但是虚拟机如何具体地进行内存回收动作仍然未涉及，因为内存回收如何进行是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器，之后来看HotSpot中有哪些GC收集器。</p><hr><h2 id="第四节-垃圾收集器"><a href="#第四节-垃圾收集器" class="headerlink" title="第四节 垃圾收集器"></a><strong>第四节 垃圾收集器</strong></h2><p>&emsp;&emsp;如何说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），虚拟机包含的所有收集器如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010117.png" alt="HotSpot虚拟机的垃圾收集器"></p><p>&emsp;&emsp;上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明他们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来各节将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器，了解它们的部分运作细节。</p><h3 id="4-1-Serial收集器"><a href="#4-1-Serial收集器" class="headerlink" title="4.1 Serial收集器"></a><strong>4.1 Serial收集器</strong></h3><p>&emsp;&emsp;Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。此收集器是一个单线程的收集器，但其“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World” 这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了Serial / Serial Old 收集器运行过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010118.png" alt="Serial / Serial Old 收集器运行示意图"></p><p>&emsp;&emsp;对于“Stop The World”带给用户的不良体验，虚拟机设计者的苦衷是“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾，但垃圾收集是比打扫房间要复杂的多。</p><p>&emsp;&emsp;从JDK 1.3 开始，一直到现在HotSpot开发团队仍在致力于消除或减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成果Garbage First（G1）收集器，一个个越来越优秀也越来越复杂的收集器的不断出现，用户线程的停顿时间在不断缩短，但是仍无法完全消除。</p><p>&emsp;&emsp;Serial收集器到现在仍是虚拟机运行在Client模式下的默认新生代收集器，它还有相比于其他收集器的优点：<strong>简单而高效</strong>（单线程下）。对于限定单线程环境下，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以对于运行在Client模式下的虚拟机来说Serial收集器是很好的选择。</p><hr><h3 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a><strong>4.2 ParNew收集器</strong></h3><p>&emsp;&emsp;ParNew收集器其实就是Serial收集器的<strong>多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器一样，在实现上，这两种收集器也共用了很多相当多的代码。ParNew收集器的工作过程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010119.png" alt="ParNew / Serial Old 收集器运行示意图"></p><p>&emsp;&emsp;ParNew收集器除了多线程收集以外并没有其他创新之处，但它是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，<strong>目前只有它能与CMS收集器配合工作</strong>。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep，稍后详细介绍），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程基本上同时工作。</p><p>&emsp;&emsp;不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制执行它。</p><p>&emsp;&emsp;ParNew收集器在单CPU的环境中不会比Serial收集器好，甚至因为存在线程交互的开销，此收集器在通过超线程技术实现的两个CPU的环境中都不能百分百的超过Serial收集器。随着可使用CPU的数量增加，其对于GC时系统资源的有效利用还是很有好处的，它默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><blockquote><p><strong>并发编程</strong>的两个概念名词在垃圾收集器的上下文语境中的解释：</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。</li></ul></blockquote><hr><h3 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a><strong>4.3 Parallel Scavenge收集器</strong></h3><p>&emsp;&emsp;Parallel Scavenge收集器是一个新生代收集器，使用复制算法，还是并行的多线程收集器，似乎和ParNew收集器没什么区别。Parallel Scavenge收集器的特点是它的关注点和其他收集器不同，<strong>CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</strong>（Throughput）。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，如果虚拟机运行了100分钟，其中垃圾收集花费了1分钟，吞吐量就是99%。</p><p>&emsp;&emsp;停顿时间短意味着有较快的响应速度可以提升用户体验，适合与用户交互的程序；高吞吐量则可以高效率的利用CPU时间，尽快的完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>&emsp;&emsp;Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，-XX:MaxGCPauseMills，-XX:GCTimeRatio。</p><p>&emsp;&emsp;Parallel Scavenge收集器也经常被叫做“吞吐量优先”收集器，除了以上两个参数还有一个-XX:UseAdaptiveSizePolicy值得关注。</p><blockquote><ul><li>-XX:MaxGCPauseMills 此参数控制最大垃圾收集停顿时间。MaxGCPauseMills参数的值是大于0的毫秒数，收集器会尽可能地保证内存回收花费时间不超过设定时间。但并不是设置的小就会使垃圾收集速度变快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统会把新生代调小，也就导致垃圾收集会更频繁，所以吞吐量就会降低。</li><li>-XX:GCTimeRatio 此参数直接设置吞吐量大小。GCTimeRatio参数的值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。比如参数值为19，允许的最大GC时间就为1 / (1 + 19) = 5%的最大时间比率，如果为99，结果就为1%。</li><li>-XX:UseAdaptiveSizePolicy 它是一个<strong>开关参数</strong>，开启后就不需要手动指定新生代大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。这种调节方式叫GC自适应的调节策略（GC Ergonomics）。</li></ul></blockquote><p>&emsp;&emsp;如果开发者能力不足以进行优化工作，使用Parallel Scavenge收集器搭配自适应调节策略，把优化任务交给虚拟机来完成会是一个不错的选择。只需要把基本的内存数据设置好（-Xmx设置最大堆等），然后MaxGCPauseMills（关注最大停顿时间）或GCTimeRatio（关注最大吞吐量）参数给虚拟机设置一个优化目标，具体调节就由虚拟机去完成了。</p><p>&emsp;&emsp;自适应调节策略是Parallel Scavenge收集器和ParNew收集器的一个重要区别。</p><hr><h3 id="4-4-Serial-Old收集器"><a href="#4-4-Serial-Old收集器" class="headerlink" title="4.4 Serial Old收集器"></a><strong>4.4 Serial Old收集器</strong></h3><p>&emsp;&emsp;Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。此收集器的主要意义同样是在于给Client模式下的虚拟机使用。但在Server模式下，它还有两大用途：一种用途是在JDK 1.5 以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p><p>&emsp;&emsp;Serial Old收集器工作过程如下图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010118.png" alt="Serial / Serial Old 收集器运行示意图"></p><hr><h3 id="4-5-Parallel-Old收集器"><a href="#4-5-Parallel-Old收集器" class="headerlink" title="4.5 Parallel Old收集器"></a><strong>4.5 Parallel Old收集器</strong></h3><p>&emsp;&emsp;Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。此收集器从JDK 1.6开始提供，在此之前新生代的Parallel Scavenge收集器只能搭配老年代的Serial Old收集器，因为它无法与CMS收集器配合。Serial Old收集器在服务端应用性能上并不可靠，使用了Parallel Scavenge收集器也未必能够在整体应用上获得最大吞吐量的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年大很大而且硬件比较高级的环境中，这种组合甚至不一定比ParNew+CMS的组合更好。</p><p>&emsp;&emsp;Parallel Old收集器出现完善了“吞吐量优先”收集器有了合适的组合，在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的搭配。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010120.png" alt="Parallel Scavenge / Parallel Old 收集器运行示意图"></p><hr><h3 id="4-6-CMS收集器"><a href="#4-6-CMS收集器" class="headerlink" title="4.6 CMS收集器"></a><strong>4.6 CMS收集器</strong></h3><p>&emsp;&emsp;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，从而给用户带来较好的体验，CMS收集器非常适合这种需求。</p><p>&emsp;&emsp;从名字Mark Sweep便可以得知CMS收集器是基于“标记-清除”算法实现的，其运作过程相比前几个收集器相对复杂。</p><blockquote><p>CMS收集器运作过程：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：仅仅是标记一下GC Roots能直接关联到的对象，速度很快。初始标记和重新标记两个步骤仍需要“Stop The World”。</li><li><strong>并发标记</strong>（CMS concurrent mark）：进行GC Roots Tracing的过程。</li><li><strong>重新标记</strong>（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，此阶段的停顿时间一般会比初始标记阶段稍长，但比并发标记阶段短。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：并发清除和并发标记是耗时最长的阶段，这两个阶段收集器线程都可以与用户线程一起工作。</li></ul></blockquote><p>&emsp;&emsp;总体来说CMS收集器的内存回收过程是与用户线程一起并发执行的，下图可以看到CMS收集器的运作步骤中并发和需要停顿的时间。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010121.png" alt="Concurrent Mark Sweep 收集器运行示意图"></p><p>&emsp;&emsp;CMS是一款优秀的收集器，优点就是<strong>并发收集</strong>、<strong>低停顿</strong>，所以Sun公司文档中称其为<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector），但CMS也有明显的缺点。</p><h4 id="CMS的三个缺点"><a href="#CMS的三个缺点" class="headerlink" title="CMS的三个缺点"></a><strong>CMS的三个缺点</strong></h4><p>&emsp;&emsp;1. <strong>对CPU资源十分敏感</strong>，这是并发设计程序的通病。在并发阶段，虽然不会导致用户线程停顿，但会因为占用了一部分线程或者说CPU资源而导致应用程序变慢，总吞吐量会降低。</p><p>&emsp;&emsp;CMS默认启动的回收线程数是 (CPU数量 + 3) / 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就可能变得很大，如果CPU本身负载就比较大，还要分出一半的运算能力去执行收集器线程，就会导致用户程序的执行速度突然下降50%。</p><p>&emsp;&emsp;为了应对这种情况，虚拟机提供了一种称为<strong>增量式并发收集器</strong>（Incremental Concurrent Mark Sweep / i-CMS）的CMS收集器变种，所做的工作和单CPU年代PC机操作系统使用<strong>抢占式</strong>来模拟多任务机制的思路一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少线程独占资源的时间，这样整个垃圾收集的过程会更长，但会降低对用户程序的影响。但实际使用中i-CMS效果非常一般，所以后续版本已经弃用（deprecated）。</p><p>&emsp;&emsp;2. <strong>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生</strong>。因为CMS并发清理阶段用户线程还在运行，所以自然会不断地产生垃圾，这部分垃圾产生在标记过程之后，所以CMS无法在此次收集中处理它们，只能留到下次GC时再进行清理。这部分垃圾就被称为浮动垃圾（Floating Garbage）。因为垃圾收集阶段用户线程还在运行，还意味着需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎被填满了再去收集，而是需要预留一部分空间提供并发收集时的程序运作使用。</p><p>&emsp;&emsp;使用JDK 1.5默认设置时，CMS收集器当老年代使用了68%就会被激活，这个数值比较保守，可以通过提高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，从而降低内存回收次数获取更好的性能。JDK 1.6时，CMS收集器的启动阈值已经提升至92%。如果CMS运行期间预留的内存无法满足程序需要，会出现一次“Concurrent Mode Failure”失败，此时虚拟机将启动后背预案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以CMSInitiatingOccupancyFraction参数谨慎处理，设置太高反而可能导致性能降低。</p><p>&emsp;&emsp;3. <strong>生成大量的空间碎片</strong>。因为CMS收集器基于“标记-清除”算法，所以自然会在收集结束后产生大量的空间碎片，给大对象的分配造成困难，经常老年代仍有大量空间未使用，却无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p><p>&emsp;&emsp;为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，此过程无法并发，解决了空间碎片问题，但代价是延长了停顿时间。</p><p>&emsp;&emsp;虚拟机还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，此参数用来设置执行多少次不压缩Full GC后，跟着来一次带压缩的（默认为0，表示每次进入Full GC时都进行碎片整理）</p><hr><h3 id="4-7-G1收集器"><a href="#4-7-G1收集器" class="headerlink" title="4.7 G1收集器"></a><strong>4.7 G1收集器</strong></h3><p>&emsp;&emsp;G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，早在JDK 1.7时就有了进化特征，在JDK 6u14时有了Early Access版本提供实验、使用。直到JDK 7u4时达到成熟阶段。G1是一款面向服务端应用的垃圾收集器，其使命是替换掉JDK 1.5发布的CMS收集器。</p><blockquote><p>G1相比其它收集器的特点：</p><ul><li><strong>并行与并发</strong> ：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java线程继续执行。</li><li><strong>分代收集</strong> ：和其他收集器一样，G1仍然保留了分代概念。虽然G1能独立管理整个GC堆，不需要其他收集器配合，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li><strong>空间整合</strong> ：与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器。从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。这个特性有利于程序长时间运行，分配大对象不会因为找不到连续空间而提前触发下次GC。</li><li><strong>可预测的停顿</strong> ：这个特点是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul></blockquote><p>&emsp;&emsp;在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1收集器的Java堆内存布局会有很大变化，它将整个Java堆分为对个大小相等的独立区域（Region），虽然还保留了新生代和老年代的概念，但两者之间不再物理隔离，都是一部分Region（不需要连续）的集合。</p><p>&emsp;&emsp;G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（G1由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>&emsp;&emsp;G1把内存“化整为零”的思路，实际实现并不简单。一个细节为例：把Java堆分为多个Region后，垃圾收集是否就真的能以Region为单位进行了？似乎顺理成章，但仔细想想会发现问题所在：Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被此Region中的对象引用，而是可以和整个Java堆中任意的对象发生引用关系。那么在做可达性分析判定确定对象是否存活时，岂不是还要扫描整个Java堆才能保证准确性？这个问题并非G1独有，但G1尤其明显突出。在以前的分代收集中，新生代一般都比老年代要小许多，收集也要频繁许多，那么回收新生代对象时也面临着同样的问题，如果回收新生代对象时不能不同时扫描老年代的话，Minor GC的效率要下降不少。</p><p>&emsp;&emsp;G1收集器中Region间的对象引用，其他收集器中新生代和老年代之间的对象引用，都是通过 Remembered Set 来避免全堆扫描。在G1中每个 Region 都有一个对应的 Remembered Set ，当虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代的对象引用了新生代的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在GC根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。 </p><h4 id="运行步骤"><a href="#运行步骤" class="headerlink" title="运行步骤"></a><strong>运行步骤</strong></h4><p>&emsp;&emsp;G1收集器的前几个步骤和CMS收集器类似。</p><blockquote><p>不考虑维护 Remembered Set 的操作，G1收集器的运作步骤：</p><ul><li><strong>初始标记</strong>（Initial Marking）：仅仅是标记一下GC Roots能直接关联到的对象，并修改TAMS（Next To at Mark Start）的值，使下一阶段用户程序并发运行时，能在正确可用的Region中创建对象，这阶段需要<strong>停顿线程</strong>，但耗时很短。</li><li><strong>并发标记</strong>（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，此阶段耗时较长，但可与用户程序<strong>并发执行</strong>。</li><li><strong>最终标记</strong>（Final Marking）：此阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要<strong>停顿线程</strong>，但可以<strong>并发执行</strong>。</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：此阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，此阶段可以做到与用户程序一起并发执行，但因为只回收一部分 Region ，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ul></blockquote><p>&emsp;&emsp;通过下图可以比较清楚的看到G1收集器的运作步骤中并发和需要停顿的阶段。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010122.png" alt="G1收集器运行示意图"></p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a><strong>性能测试</strong></h4><p>&emsp;&emsp;通过简单的Java代码写个Microbenchmark程序来创建、移除Java对象，用-XX:+PrintGCDetails等参数来查看GC日志是很难去准确衡量其性能的。下面引用Sun实验室论文数据。</p><blockquote><ul><li>硬件：Sun V880 服务器（8×750MHz UltraSPARC Ⅲ CPU、32G内存、Solaris 10 OS）</li><li>软件：SPECjbb（模拟商业数据库应用，堆中存活对象约为165MB，结果反映吐量和最长事物处理时间）、telco（模拟电话应答服务应用，堆中存活对象约为100MB，结果反映系统能支持的最大吞吐量）。</li><li>补充：另外收集了一组用ParNew+CMS收集器的测试数据方便对比，所有测试都配置为与CPU数量相同的8条GC线程</li></ul></blockquote><p>&emsp;&emsp;在反应停顿时间的软实时目标（Soft Real-Time Goal）测试中，横向是两个测试软件的时间片段配置，单位是毫秒，以(X/Y)形式表示，代表在Y毫秒内最大运行GC时间为X毫秒（对于CMS收集器，无法直接指定这个目标，通过调整分代大小的方式大致模拟）。纵向是两个软件在对应配置和不同的Java堆容量下的测试结果，V%、avgV%和wV%分别表示以下含义：</p><blockquote><ul><li>V%：表示测试过程中软实时目标失败的概率，软实时目标失败即某个时间片段中实际GC时间超过了允许的最大GC时间。</li><li>avgV%：表示在所有实际GC时间超标的时间片段里，实际GC时间超过最大GC时间的平均百分比（实际GC时间减去允许最大GC时间，再除以总时间片段）。</li><li>wV%：表示在测试结果最差的时间片段里，实际GC时间占用执行时间的百分比。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010123.png" alt="测试结果"></p><p>&emsp;&emsp;从上图测试结果可见，对于telco，软实时目标失败的概率控制在0.5% ~ 0.7%之间，SPECjbb就要差一些，但也在2% ~ 5%之间。概率随着(X/Y)比值减小而增加。另一方面，失败时超出允许GC时间的比值随着总时间片段增加而变小，在(100/200)+512MB配置下，G1收集器出现了某些时间片段下100%时间在进行GC的最坏情况。相比之下CMS收集器的测试结果要差很多，3种Java堆容量下都出现100%GC情况。</p><p>&emsp;&emsp;吞吐量测试中，测试数据取3次SPECjbb和15次telco的平均结果，如下图所示。在SPECjbb应用下，各种配置下的G1表现了一致的行为，吞吐量看起来只与允许最大GC时间成正比关系，而telco应用下，不同配置对于吞吐量的影响则显得很微弱。与CMS收集器的吞吐量对比可以看到，在SPECjbb测试中，在堆容量超过768MB时，CMS收集器有5% ~ 10%的优势，而在telco测试中，优势要小一些，只有3% ~ 4%左右。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010124.png" alt="吞吐量测试结果"></p><p>&emsp;&emsp;如果你的应用追求低停顿，且对现有的收集器不够满意，可以尝试使用G1收集器，否则没有必要。</p><hr><h3 id="4-8-理解GC日志"><a href="#4-8-理解GC日志" class="headerlink" title="4.8 理解GC日志"></a><strong>4.8 理解GC日志</strong></h3><p>&emsp;&emsp;阅读GC日志是处理Java内存问题的基础技能，每种收集器的日志的形式都由其自身实现决定，虚拟机设计者为了方便用户阅读，是有对收集器维护一些共性。如下图所示两段GC日志，“33.125”和“100.667”表示GC发生时间，数字来源于虚拟机启动后经过的秒数。“[GC”和“[Full GC”表示了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC（比如新生代收集器ParNew的日志也会出现Full GC）。如果有Full表示这次GC发生了Stop-The-World。如果是调用System.gc()方法触发的收集，会显示“[Full GC(System)”。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010125.png" alt="GC日志"></p><p>&emsp;&emsp;“[DefNew”，“[Tenured”，“[Perm”表示GC发生的区域，区域名和收集器密切相关。如上述是Serial收集器，新生代名为“Def New Generation”，所以显示DefNew。如果是ParNew收集器，新生代名为“Parallel New Generation”，就显示“[ParNew”。如果是Parallel Scavenge收集器，新生代叫“PSYoungGen”。老年代和新生代一样也由收集器起名决定。</p><p>&emsp;&emsp;“3324K-&gt;152K(3712K)”含义是<strong>GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量(该内存区域总容量)</strong>。方括号外的“3324K-&gt;152K(11904K)”含义是<strong>GC前Java堆已使用容量-&gt;GC后Java堆已使用容量(Java堆总容量)</strong>。</p><p>&emsp;&emsp;“0.0025925 secs”表示该内存区域GC所占用时间，单位为秒。有些收集器会给出更具体的时间数据“[Time : user=0.01 sys=0.00, real=0.02 secs]”<br>三个参数分别代表用户态消耗的CPU时间，内核态消耗的CPU时间和操作从开始到结束经过的墙钟时间（Wall Clock Time）。当系统有多CPU或多核时，会叠加这些CPU时间，所以user或sys超过real是正常的。</p><blockquote><p>CPU时间和墙钟时间的区别是：墙钟时间包括各种非运算的等待耗时，如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时。</p></blockquote><hr><h3 id="4-9-垃圾收集器参数总结"><a href="#4-9-垃圾收集器参数总结" class="headerlink" title="4.9 垃圾收集器参数总结"></a><strong>4.9 垃圾收集器参数总结</strong></h3><p>&emsp;&emsp;整理了一下垃圾收集相关的常用参数。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010126.png" alt="垃圾收集相关的常用参数"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010127.png" alt="垃圾收集相关的常用参数"></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：垃圾收集算法(标记-清除算法、复制算法、标记-整理算法、分代收集算法)，枚举根节点，安全点，安全区域，垃圾收集器(Serial收集器、ParNew收集器、Parallel Scavenge收集器、Serial Old收集器、Parallel Old收集器、CMS收集器、G1收集器)，理解GC日志，参数总结等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>GitLab（未完成）</title>
    <link href="http://linyishui.top/2019091101.html"/>
    <id>http://linyishui.top/2019091101.html</id>
    <published>2019-09-11T01:30:56.000Z</published>
    <updated>2019-11-11T08:43:49.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a><strong>GitLab</strong></h1><h2 id="第一节-介绍"><a href="#第一节-介绍" class="headerlink" title="第一节 介绍"></a><strong>第一节 介绍</strong></h2><p>&emsp;&emsp;GitLab是由GitLab Inc.开发，使用MIT许可证的基于网络的Git仓库管理工具。它由 Ruby 写成。后来一些部分用 Go 语言重写。</p><h3 id="github和github区别"><a href="#github和github区别" class="headerlink" title="github和github区别"></a><strong>github和github区别</strong></h3><p>&emsp;&emsp;github和github都是基于git的web代码仓库管理软件。区别主要在于github上的仓库基本上都是开源的，当然也可以创建私有的代码仓库，但是费用比较昂贵。而gitlab是可以在企业内部搭建，可以创建私有的代码仓库，除此之外，gitlab还有一些其他的高级特性。相同之处是他们都是基于版本管理系统git，都使用git的命令进行操作。</p><hr><h2 id="第二节-安装"><a href="#第二节-安装" class="headerlink" title="第二节 安装"></a><strong>第二节 安装</strong></h2><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a><strong>选择版本</strong></h3><p>&emsp;&emsp;GitLab是建立在开放核心模型之上的。这意味着GitLab有两个版本: <strong>社区版</strong>和<strong>企业版</strong>。</p><p>&emsp;&emsp;社区版是开放源码的，拥有MIT的外籍许可证。企业版构建在社区版之上，使用相同的核心，但在此基础上添加了其他特性和功能，这是在专有许可下进行的。</p><p>&emsp;&emsp;对于这两个版本: GitLab中的所有javascript代码都是开源的。所有由GitLab编写的javascript代码都在同一个MIT许可下。</p><p>&emsp;&emsp;社区版升级到企业版的过程中需要停机，如果没有许可证企业版不会和社区版有明显差异。</p><p><a href="https://about.gitlab.com/installation" title="Title" target="_blank" rel="noopener">Install GitLab Enterprise Edition.</a></p><p><a href="https://about.gitlab.com/install/?version=ce" title="Title" target="_blank" rel="noopener">Install GitLab Community Edition.</a></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>&emsp;&emsp;安装环境是Ubuntu + Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不加 tag 则默认为最新版本 latest (一般使用这种)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull gitlab/gitlab-ce</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要下载其他版本，加上对应的 tag 即可，如：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull gitlab/gitlab-ce:rc</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;未完待续…</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://about.gitlab.com/install/ce-or-ee/" title="Title" target="_blank" rel="noopener">gitlab社区版和企业版</a></p></blockquote><blockquote><p><a href="http://jemgeek.com/archives/2019/docker-base-install.html" title="Title" target="_blank" rel="noopener">安装 Docker 和 Docker Compose (Ubuntu)</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/63786567" title="Title" target="_blank" rel="noopener">使用 Docker 搭建 GitLab</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/ade38a53b1ac" title="Title" target="_blank" rel="noopener">搭建gitlab仓库</a></p></blockquote><blockquote><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab" title="Title" target="_blank" rel="noopener">服务器上的 Git - GitLab</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/fb61299086b6" title="Title" target="_blank" rel="noopener">Gitlab详细操作</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      GitLab。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器（一）确认对象生死</title>
    <link href="http://linyishui.top/2019091001.html"/>
    <id>http://linyishui.top/2019091001.html</id>
    <published>2019-09-10T10:56:40.000Z</published>
    <updated>2019-11-06T02:01:38.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><strong>垃圾收集器</strong></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>&emsp;&emsp;诞生于1960年的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。如今内存的动态分配和内存回收技术已经非常成熟，了解垃圾收集(GC)和内存分配的原理，从而可以在排查内存溢出和内存泄漏问题时，在垃圾收集成为系统提高并发量的瓶颈时，我们有足够的能力进行监控和调节。</p><p>&emsp;&emsp;<a href="../2019050801.html" title="Title">Java内存区域和内存溢出异常</a>中介绍了内存运行时的各个区域，其中程序计数器、虚拟机栈、本地方法栈三个区域和线程共享相同生命周期；栈中的栈帧随着方法进入和退出进行入栈出栈操作，每个栈帧分配的内存大小在确定类结构时便可得知(不考虑JIT编译器优化)因此这些区域的内存分配和回收都具有确定性，在方法或线程结束时便已回收，所以无需多考虑回收问题。</p><p>&emsp;&emsp;Java堆和方法区则不同，一个接口的多个实现类需要的内存可能不同，一个方法内的多个分支需要的内存也可能不同，只有程序运行时才能得知要创建多少对象，这些区域的内存分配和回收都是动态的，所以值得讨论。</p><hr><h2 id="第一节-对象已死了吗"><a href="#第一节-对象已死了吗" class="headerlink" title="第一节 对象已死了吗"></a><strong>第一节 对象已死了吗</strong></h2><p>&emsp;&emsp;垃圾回收第一件工作便是确认对象是”存活”还是已”死亡”。</p><hr><h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a><strong>1.1 引用计数算法</strong></h3><p>&emsp;&emsp;常见的判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有地方引用它，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>&emsp;&emsp;<strong>引用计数算法</strong>(Reference Counting)的实现简单，判定效率也很高，所以也有很多著名的应用案例。但主流的Java虚拟机都没有选用引用计数算法来管理内存，主要的原因是它很难解决<strong>对象之间相互循环引用</strong>的问题。</p><p>&emsp;&emsp;比如，以下代码中的testGC()方法。objA和objB互相引用，所以计数都不为0，引用计数算法无法通知GC收集器回收它们。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * testGC()执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testGC()&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设在这行发生GC，objA和objB能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但运行并观察GC日志，发现虚拟机并没有因为对象互相引用就没有回收，也印证了虚拟机没有采用引用计数算法。</p><hr><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a><strong>1.2 可达性分析算法</strong></h3><p>&emsp;&emsp;主流商用程序语言的主流实现都是采用<strong>可达性分析</strong>(Reachability Analysis)来判定对象是否存活。基本思路是：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的。</p><p>&emsp;&emsp;如下图所示，对象5、6、7虽然互有关联，但它们到GC Roots是不可达的，所以会被判定为可回收对象。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010113.png" alt="可达性分析算法判定对象是否可回收"></p><blockquote><p>对于Java语言，可被视作GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li></ul></blockquote><hr><h3 id="1-3-引用"><a href="#1-3-引用" class="headerlink" title="1.3 引用"></a><strong>1.3 引用</strong></h3><p>&emsp;&emsp;无论采用哪种算法，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中对引用的定义很传统：<strong>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用</strong>。这种定义方式使对象只有被引用和没被引用两种状态，而无法描述这样一类对象：<strong>当内存空间还足够时，则能保留在内存中；如果内存空间在垃圾收集后还很紧张，则可以清除的对象</strong>。</p><p>&emsp;&emsp;在JDK 1.2以后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>(Strong Reference)、<strong>软引用</strong>(Soft Reference)、<strong>弱引用</strong>(Weak Reference)、<strong>虚引用</strong>(Phantom Reference)4种，这4种引用强度依次逐渐减弱。</p><blockquote><ul><li>强引用就是指在程序代码中普遍存在的，类似“Object obj = new Object()”这类引用，只要强引用还存在，垃圾收集器就不会回收被引用的对象。</li><li>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象列入回收范围之中进行二次回收。如果此次回收仍没有足够内存，才会抛出内存溢出异常。JDK 1.2以后，提供了SoftReference类来实现软引用。</li><li>弱引用也是用来描述非必需对象的，但相较软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。JDK 1.2以后，提供了WeakReference类来实现软引用。</li><li>虚引用也叫做幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间有任何影响，也无法通过虚引用来获取一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。JDK 1.2以后，提供了PhantomReference类来实现软引用。</li></ul></blockquote><hr><h3 id="1-4-生存还是死亡"><a href="#1-4-生存还是死亡" class="headerlink" title="1.4 生存还是死亡"></a><strong>1.4 生存还是死亡</strong></h3><p>&emsp;&emsp;即使在可达性分析算法中不可达的对象也并非是“非死不可”的，它们会先处于一个“缓刑”阶段，真正的迎来对象的死亡至少还要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机会将这两种情况都视为“没有必要执行”。</p><p>&emsp;&emsp;如果这个对象已经被判定为有必要执行finalize()方法，那么这个对象会被放置在一个叫F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去“执行”它。<strong>执行</strong>指的是虚拟机会触发这个方法，但并不承诺会等待它运行结束，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能导致F-Queue队列中其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象想要在这时“拯救自己”——只要重新与引用链上的任意一个对象建立关联即可(譬如把自己赋值给某个类变量或对象的成员变量)，它会在第二次标记时被移除出“即将回收”的集合。</p><p>&emsp;&emsp;以下代码演示对象在执行finalize()方法后仍可以存活。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> *  1.对象可以在被GC时自我拯救</span></span><br><span class="line"><span class="comment"> *  2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动的调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>&#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Throwable</span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功的拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码与上面完全相同，但这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下。SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，且在被收集前成功逃脱了。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finalize</span> <span class="function"><span class="keyword">method</span> <span class="title">executed</span>!</span></span><br><span class="line"><span class="function"><span class="title">yes</span>, <span class="title">i</span> <span class="title">am</span> <span class="title">still</span> <span class="title">alive</span> :</span>)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个值得注意的地方是，两段相同代码，一次逃脱成功，一次失败。原因就是任何对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，finalize()方法不会再次执行。</p><p>&emsp;&emsp;通过finalize()方法来避免GC并不是一种值得提倡的用法，其运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()方法能做的所有工作try-finally和其他方式都可以做个更好，finalize()可以被开发人员忽略。</p><hr><h3 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a><strong>1.5 回收方法区</strong></h3><p>&emsp;&emsp;方法区(HotSpot中的永久代)不强制要求VM实现垃圾收集，在堆中，尤其是新生代中，一次垃圾收集一般可以回收70%~95%的空间，而永久代要远低于此。</p><p>&emsp;&emsp;永久代的垃圾回收主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。</p><p>&emsp;&emsp;回收废弃常量类似于回收Java堆中的对象，以常量池中字面量的回收为例，假设一个字符串“abc”已经进入了常量池中，但当前系统没有任何一个String对象是叫“abc”的，也就是没有任何String对象或其他地方引用常量池中的“abc”常量，如果此时发生内存回收，有必要的话会将此常量清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。</p><h4 id="判断类是否无用"><a href="#判断类是否无用" class="headerlink" title="判断类是否无用"></a><strong>判断类是否无用</strong></h4><blockquote><p>判断类为无用类的三个条件：</p><ul><li>该类所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></blockquote><p>&emsp;&emsp;判断类是否无用相比判断常量是否废弃要苛刻许多，当类满足以上条件时，虚拟机才可以进行回收，但不会像对象一样，不使用就必然会回收。HotSpot虚拟机提供了-Xnoclassgc参数进行控制是否对类进行回收，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p><p>&emsp;&emsp;在大量使用反射、动态反射、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：引用计数算法，可达性分析算法，引用，对象判断生死过程，回收方法区等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机中程序执行过程（未完成）</title>
    <link href="http://linyishui.top/2019090901.html"/>
    <id>http://linyishui.top/2019090901.html</id>
    <published>2019-09-09T06:37:37.000Z</published>
    <updated>2019-11-11T08:44:20.664Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><strong>类加载过程</strong></h1><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a><strong>引文</strong></h2><p>&emsp;&emsp;在Java语言里，<strong>new表达式</strong>是负责创建实例的，调用<strong>构造器</strong>去对实例做初始化；构造器自身的返回值类型是void，并不是“构造器返回了新创建的对象的引用”，而是new表达式的值是新创建的对象的引用。</p><p>&emsp;&emsp;对应的，在JVM里，“new”字节码指令只负责把实例创建出来（包括分配空间、设定类型、所有字段设置默认值等工作），并且把指向新创建对象的引用压到操作数栈顶。此时该引用还不能直接使用，处于未初始化状态（uninitialized）；如果某方法a含有代码试图通过未初始化状态的引用来调用任何实例方法，那么方法a会通不过JVM的字节码校验，从而被JVM拒绝执行。</p><p>&emsp;&emsp;能对未初始化状态的引用做的唯一一种事情就是通过它调用实例构造器，在Class文件层面表现为特殊初始化方法“&lt; init &gt;”。实际调用的指令是invokespecial，而在实际调用前要把需要的参数按顺序压到操作数栈上。在上面的字节码例子中，压参数的指令包括dup和ldc两条，分别把隐藏参数（新创建的实例的引用，对于实例构造器来说就是“this”）与显式声明的第一个实际参数（”ab”常量的引用）压到操作数栈上。<br>在构造器返回之后，新创建的实例的引用就可以正常使用了。</p><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a><strong>举例分析</strong></h3><p>&emsp;&emsp;假设我们要运行Test类，首先虚拟机启动，尝试执行main方法发现类还未加载，即虚拟机还未包含Test类的二进制表示。加载过程通过引导类加载器查找.class并加载Test类。</p><p>&emsp;&emsp;Test类加载后，在调用main之前需要先进行初始化。所有的类或接口在初始化前要先进行链接。链接包括校验、准备和可选的解析。</p><p>&emsp;&emsp;校验阶段会检查被加载的Test类是否良构，是否具有正确的符号表，代码是否遵循Java编程语言和虚拟机的语义要求。</p><p>&emsp;&emsp;准备阶段涉及到静态存储的内存分配，以及所有在Java虚拟机的实现内部需要使用的数据结构的内存分配，比如方法表。</p><p>&emsp;&emsp;解析是检查Test中对其他类和接口的符号引用的过程，通过加载提及的其他类和接口来检查这些引用是否正确。可以选择非常早的解析也可以选择在符号引用被实际使用时再解析。</p><p>&emsp;&emsp;接着进入初始化过程，初始化顺序有所有的类变量初始化器和静态初始化器按行文顺序构成。要求直接超类的初始化顺序必须先于子类。</p><p>&emsp;&emsp;最后，完成初始化后Test类的main方法才会被调用。要求main函数必须声明为：public static void，且必须指定类型为String数组的形式参数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>... args)</span><br></pre></td></tr></table></figure><hr><h2 id="第一节-虚拟机启动"><a href="#第一节-虚拟机启动" class="headerlink" title="第一节 虚拟机启动"></a><strong>第一节 虚拟机启动</strong></h2><p>&emsp;&emsp;<strong>虚拟机的启动</strong>是通过加载指定的类，然后调用指定类中main方法。</p><p>&emsp;&emsp;Java虚拟机会动态的加载、链接与初始化类和接口。</p><blockquote><ul><li>加载是根据特定名称查找类或接口类型的二进制表示(.class)，并由二进制表示来创建类或接口的过程。</li><li>链接是为了让类或接口可以被Java虚拟机执行，而将类或接口并入虚拟机运行时状态的过程。</li><li>类或接口的初始化是指执行类或接口的初始化方法&lt; clinit &gt;</li></ul></blockquote><hr><h2 id="第二节-加载过程"><a href="#第二节-加载过程" class="headerlink" title="第二节 加载过程"></a><strong>第二节 加载过程</strong></h2><p>&emsp;&emsp;<strong>加载</strong>是指查找到具有特定名的类或接口类型的二进制形式的过程。</p><p>&emsp;&emsp;典型实现：获取之前由Java编译器对源代码进行计算产生的二进制表示，从该二进制形式中构建表示该类或接口的Class对象。二进制格式通常是.class文件格式，但也可以是其他满足虚拟机要求的格式。ClassLoader类的defineClass方法可以被用来从class文件格式的二进制表示中构建Class对象。</p><p>&emsp;&emsp;<strong>加载过程</strong>是由ClassLoader类以及其子类实现的。不同子类可以实现不同的加载策略，类加载器可以缓存类或接口的二进制表示、基于预期使用而预抓取它们，以及一起加载有关联的一组类。</p><p>&emsp;&emsp;类加载过程产生了错误，会抛出LinkageError子类(ClassCircularityError，ClassFormatError，NotClassDefFoundError)之一的异常。因为加载涉及到对新数据结构分配内存，所以有可能会抛出OutOfMemoryError。</p><blockquote><p>&emsp;&emsp;创建一个标记为N的类或接口C，首先虚拟机要在方法区上为C创建与虚拟机中实现匹配的内部表示，C的创建可以由另一个类或接口D触发，其运行时常量池引用了C，也可以由D调用反射等方法触发。(数组类直接由Java虚拟机创建，其没有外部的.class二进制表示，非数组类则由类加载器加载.class来创建)</p><p>&emsp;&emsp;虚拟机首先检查加载器L是否被记录为N的初始加载器，如果是则这次尝试创建操作无效，且加载动作会抛出异常LinkageError；如果不是，虚拟机尝试解析.class文件。解析阶段的异常先省略，解析C的直接父类或直接父接口省略。虚拟机标记C的定义类加载器为L，并记录L是C的初始加载器。</p></blockquote><hr><h2 id="第三节-链接过程"><a href="#第三节-链接过程" class="headerlink" title="第三节 链接过程"></a><strong>第三节 链接过程</strong></h2><p>&emsp;&emsp;<strong>链接</strong>是指获取类或接口类型的二进制形式，并将其与Java虚拟机的运行时状态结合起来，使其可以被执行的过程。</p><blockquote><p>链接涉及三种不同的行为：</p><ul><li>校验</li><li>准备</li><li>符号引用的解析</li></ul></blockquote><p>&emsp;&emsp;因为链接涉及到对新数据结构分配内存，所以有可能会抛出OutOfMemoryError。</p><blockquote><p>&emsp;&emsp;链接包括验证和准备类或接口、其直接父类、其直接父接口、其元素类型。解析这个类或接口中的符号引用是链接过程的可选部分，虚拟机可以选择在用到符号引用时再去解析(延迟解析)，或者验证类时就解析每个引用(预先解析)。要求类或接口链接前必须被成功的加载过，初始化之前必须被成功的验证和准备过。</p></blockquote><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a><strong>校验</strong></h3><p>&emsp;&emsp;校验可以保证类或接口的二进制表示在结构上正确。如果校验过程发生错误，会抛出LinkageError的子类VerifyError的异常。</p><blockquote><p>&emsp;&emsp;验证过程可能会使其他类或接口被加载，但未必需要验证或准备他们。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><p>&emsp;&emsp;准备包括创建类或接口的static域(类变量和类常量)和将这些域初始化为缺省值，不需要执行任何源代码，或者说虚拟机字节码指令，静态域的显式初始化器会作为初始化过程的一部分而执行，而不是准备过程的一部分。</p><blockquote><p>Java虚拟机的实现可以在准备阶段预计算额外的数据结构，以使后续对此类或接口的操作更加高效，特别有用的“方法表”或其他具有相同功能的数据结构，允许在类的实例上调用任何方法而无需在调用时搜索其超类。</p></blockquote><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h3><p>&emsp;&emsp;类或接口的二进制表示会使用其他类或接口的二进制名字来以符号方式引用其他类或接口，以及它们的域、方法和构造器。这些符号引用包括域和方法所属的类或接口类型的名字、域和方法自身的名字，以及恰当的类型信息。</p><blockquote><p>符号引用：一组符号描述锁引用的目标，如CONSTANT_XX_info等常量。其引用目标未必加载到内存中。在编译阶段时，类的实际地址还未可知，所以只能用符号引用来代替。</p><p>直接引用：可以是直接指向目标的指针，相对偏移量，一个能间接定位到目标的句柄。有了直接引用目标一定已经加载到内存了。</p></blockquote><p>&emsp;&emsp;在符号引用可以被使用前，它们必须先被解析，在解析时会检查符号引用是否正确，并且在典型情况下，若某个符号引用被重复的使用，那么它会被可以更高效处理的直接引用所替代。</p><p>&emsp;&emsp;如果在解析过程中发生错误，会抛出IncompatibleClassChangeError或其子类(IllegalAccessError，InstantiationError，NoSuchFieldError，NoSuchMethodError)之一。如果一个类声明了一个native方法，但找不到此方法的实现，就会抛出LinkageError的子类UnsatisfiedLinkError。</p><blockquote><p>&emsp;&emsp;<strong>解析</strong>是根据运行时常量池里的符号引用来动态决定具体指的过程，Java虚拟机通过一些指令将符号引用指向运行时常量池，执行指令(anewarray,checkcast,getfield,getstatic,instanceof,invokedynamic,invokeinterface,invokespecial,invokestatic,invokevirtual,ldc,ldc_w,multianewarray,new,putfield,putstatic)需要对符号引用进行解析。对于除invokedynamic以外的指令，碰到此指令并解析它的符号引用后，表示对其他指令相同的符号引用已被解析过了。各种符号引用的解析过程先省略。</p></blockquote><hr><h2 id="第四节-初始化过程"><a href="#第四节-初始化过程" class="headerlink" title="第四节 初始化过程"></a><strong>第四节 初始化过程</strong></h2><p>&emsp;&emsp;类的初始化包括执行其静态初始化器和执行用于在类中声明的static域(类变量)的初始化器。接口的初始化包括执行用于在接口中声明的域(常量)的初始化器。在类被初始化之前，其直接超类必须先被初始化，但该类实现的接口并没有初始化，类似的，接口的超接口在该接口被初始化之前，还没有被初始化。</p><p>&emsp;&emsp;</p><blockquote><p>&emsp;&emsp;初始化对于类或接口就是执行其初始化方法，只有以下指令会导致初始化：new，getstatic，putstatic，invokestatic。这些指令都会通过字段或方法引用来直接或间接引用某个类。执行new指令时，若指令引用的类或接口没初始化则进行初始化。在初始化以前，类或接口必须已经被链接过，即经过了验证和准备阶段，可能已经解析过了。</p></blockquote><blockquote><p>以下情况第一次方式时，类或接口类型T会在紧靠此时刻之前被初始化：</p><ul><li>T是类，并且创建了T的实例</li><li>T是类，并且T声明的static方法被调用</li><li>T声明的static域被赋值</li><li>T声明的static域被使用，并且该域不是常量变量</li><li>T是顶层类，并且在词法上嵌套在T内的assert语句被执行</li></ul></blockquote><p>&emsp;&emsp;对static域的引用只会导致实际声明它的类或接口被初始化，即使它可能是通过子类名、子接口名或实现了某个接口的类名而被引用的。</p><p>&emsp;&emsp;对Class类中和java.lang.reflect包中的某些反射方法的调用也会导致类和接口被初始化。</p><p>&emsp;&emsp;其他任何情况都不会使类或接口被初始化。</p><h3 id="实例-超类在子类之前被初始化"><a href="#实例-超类在子类之前被初始化" class="headerlink" title="实例 超类在子类之前被初始化"></a><strong>实例 超类在子类之前被初始化</strong></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"Super "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"One "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"Two "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        One o = <span class="keyword">null</span>;</span><br><span class="line">        Two t = <span class="keyword">new</span> Two();</span><br><span class="line">        System.out.<span class="built_in">print</span>((<span class="built_in">Object</span>) o == (<span class="built_in">Object</span>) t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。类One永远不会初始化，因此永远不会被链接。类Two只有在其超类Super被初始化之后才会被初始化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Super</span> Two <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="实例-只有声明static域的类才会被初始化"><a href="#实例-只有声明static域的类才会被初始化" class="headerlink" title="实例 只有声明static域的类才会被初始化"></a><strong>实例 只有声明static域的类才会被初始化</strong></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    static int taxi = <span class="number">1729</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    static &#123; <span class="type">System</span>.out.print(<span class="string">"Sub "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">System</span>.out.print(<span class="type">Sub</span>.taxi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。因为Sub类永远没有被初始化，对Sub.taxi的引用实际上是对在Super类中声明的域的引用，它不会触发对Sub类的初始化。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1729</span></span><br></pre></td></tr></table></figure><h3 id="实例-接口初始化不会初始化超接口"><a href="#实例-接口初始化不会初始化超接口" class="headerlink" title="实例 接口初始化不会初始化超接口"></a><strong>实例 接口初始化不会初始化超接口</strong></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface I &#123;</span><br><span class="line">    int i = 1, ii = Test.out(<span class="string">"ii"</span>,2);</span><br><span class="line">&#125;</span><br><span class="line">interface J extends I &#123;</span><br><span class="line">    int j = Test.out(<span class="string">"j"</span>,3), jj = Test.out(<span class="string">"jj"</span>,4);</span><br><span class="line">&#125;</span><br><span class="line">interface K extends J &#123;</span><br><span class="line">    int k = Test.out(<span class="string">"k"</span>,5);</span><br><span class="line">&#125;</span><br><span class="line">interface Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(J.i);</span><br><span class="line">        System.out.println(K.j);</span><br><span class="line">    &#125;</span><br><span class="line">    static int out(String s, int i)&#123;</span><br><span class="line">        System.out.println(s + <span class="string">"="</span> + i);</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。J.i引用的域是一个常量变量，因此它不会使I被初始化。K.j引用的域实际上是在接口J中声明的，它不是常量变量，它会导致J接口的域被初始化，但超接口I中的域和接口K中的域都不会初始化。</p><p>&emsp;&emsp;尽管K被用来引用接口J中的域j，但接口K并不会被初始化。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">j=<span class="number">3</span></span><br><span class="line">jj=<span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="详细的初始化过程"><a href="#详细的初始化过程" class="headerlink" title="详细的初始化过程"></a><strong>详细的初始化过程</strong></h3><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.4.2</p><hr><h2 id="第五节-创建新的类实例"><a href="#第五节-创建新的类实例" class="headerlink" title="第五节 创建新的类实例"></a><strong>第五节 创建新的类实例</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.5</p><hr><h2 id="第六节-类实例的终结"><a href="#第六节-类实例的终结" class="headerlink" title="第六节 类实例的终结"></a><strong>第六节 类实例的终结</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.6</p><hr><h2 id="第七节-卸载类和接口"><a href="#第七节-卸载类和接口" class="headerlink" title="第七节 卸载类和接口"></a><strong>第七节 卸载类和接口</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.7</p><hr><h2 id="第八节-程序退出"><a href="#第八节-程序退出" class="headerlink" title="第八节 程序退出"></a><strong>第八节 程序退出</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.8</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java语言规范》</p></blockquote><blockquote><p>《Java虚拟机规范》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的程序执行过程，包括：虚拟机启动，举例分析，加载过程，链接过程，初始化过程，创建新的类实例，类实例的终结，卸载类和接口，程序退出等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
</feed>
