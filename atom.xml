<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-12-29T14:05:19.823Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小厂开发模式的一些反思</title>
    <link href="http://linyishui.top/2019112101.html"/>
    <id>http://linyishui.top/2019112101.html</id>
    <published>2019-11-21T13:44:58.000Z</published>
    <updated>2019-12-29T14:05:19.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a><strong>加密算法</strong></h1><h2 id="为什么不重视设计？"><a href="#为什么不重视设计？" class="headerlink" title="为什么不重视设计？"></a><strong>为什么不重视设计？</strong></h2><h2 id="为什么做不好文档？"><a href="#为什么做不好文档？" class="headerlink" title="为什么做不好文档？"></a><strong>为什么做不好文档？</strong></h2><h2 id="为什么不重视单元测试？"><a href="#为什么不重视单元测试？" class="headerlink" title="为什么不重视单元测试？"></a><strong>为什么不重视单元测试？</strong></h2><h2 id="为什么都是人力测试，不做自动化测试？"><a href="#为什么都是人力测试，不做自动化测试？" class="headerlink" title="为什么都是人力测试，不做自动化测试？"></a><strong>为什么都是人力测试，不做自动化测试？</strong></h2><h2 id="为什么不做CodeReview？"><a href="#为什么不做CodeReview？" class="headerlink" title="为什么不做CodeReview？"></a><strong>为什么不做CodeReview？</strong></h2><p>因为小厂都是在做项目，而不是做产品。项目并没有什么维护下去的必要，一般验收后就不会继续迭代和维护，也就没有必要CodeReview，只要能过验收那一关即可。CodeReview本身应该是很消耗时间，且需要有设计进行有效的Review，这些对于小厂有些苛刻。且对于项目看不到任何效益，这些项目生产时产生的BUG也不会直接对乙方公司造成特别严重的伤害，Leader自然不会对代码质量有特别大的压力，稍微在测试流程或者开发流程上加一些压力就能满足项目的需求，再多的成本对于小公司来说可能是“浪费”了。</p><h2 id="这样的公司，核心的财富是什么呢？"><a href="#这样的公司，核心的财富是什么呢？" class="headerlink" title="这样的公司，核心的财富是什么呢？"></a><strong>这样的公司，核心的财富是什么呢？</strong></h2><h2 id="为什么不效仿一些大厂，让员工螺丝化？"><a href="#为什么不效仿一些大厂，让员工螺丝化？" class="headerlink" title="为什么不效仿一些大厂，让员工螺丝化？"></a><strong>为什么不效仿一些大厂，让员工螺丝化？</strong></h2><p>小厂好像唯一的优势就是身兼多职，甚至一个项目就是一个人，为什么不花些功夫来让生产流水化，一些核心员工的流失对于小厂是很大的损失，这样似乎也可以缓解这个问题。</p>]]></content>
    
    <summary type="html">
    
      瞎想一下这一两年在小公司工作的感受和反思。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="other" scheme="http://linyishui.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>Base64编码</title>
    <link href="http://linyishui.top/2019112001.html"/>
    <id>http://linyishui.top/2019112001.html</id>
    <published>2019-11-20T14:17:40.000Z</published>
    <updated>2019-12-29T13:20:50.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a><strong>加密算法</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;Base64不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种<strong>可逆</strong>的编码方式。</p><p>&emsp;&emsp;编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(26 + 26 + 10 + 1 + 1 = 64，其实是65个字符，“=”是填充字符。Base64要求把每三个8Bit的字节转换为四个6Bit的字节(3<em>8 = 4</em>6 = 24)，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。原文的字节最后不够3个的地方用0来补足，转换时Base64编码用=号来代替。这就是为什么有些Base64编码会以一个或两个等号结束的原因，中间是不可能出现等号的，但等号最多只有两个。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。)</p><p>&emsp;&emsp;Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”，对应GB2312格式的Base64编码是”yc/N+A==”。</p><p>&emsp;&emsp;标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。</p><p>&emsp;&emsp;为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。</p><p>&emsp;&emsp;另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”，“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。</p><p>&emsp;&emsp;此外还有一些变种，它们将“+/”改为“<em>-”或“.</em>”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“_:”（用于XML中的Name）。</p><hr><h2 id="第二节-Java中使用Base64编码"><a href="#第二节-Java中使用Base64编码" class="headerlink" title="第二节 Java中使用Base64编码"></a><strong>第二节 Java中使用Base64编码</strong></h2><h3 id="2-1-早期"><a href="#2-1-早期" class="headerlink" title="2.1 早期"></a><strong>2.1 早期</strong></h3><p>&emsp;&emsp;早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">    <span class="keyword">final</span> BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">text</span> =<span class="string">"Java深入"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">byte</span>[] textByte = <span class="built_in">text</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> encodedText = encoder.encode(textByte);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"编码后："</span> + encodedText);<span class="comment">//编码后：SmF2Yea3seWFpQ==</span></span><br><span class="line">    <span class="comment">//解码</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"解码后："</span> + <span class="keyword">new</span> <span class="keyword">String</span>(decoder.decodeBuffer(encodedText),<span class="string">"UTF-8"</span>));<span class="comment">//解码后：Java深入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Apache-Commons-Codec"><a href="#2-2-Apache-Commons-Codec" class="headerlink" title="2.2 Apache Commons Codec"></a><strong>2.2 Apache Commons Codec</strong></h3><p>&emsp;&emsp;Apache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Base64 base64 = <span class="keyword">new</span> Base64();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">text</span> = <span class="string">"Java深入"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">byte</span>[] textByte = <span class="built_in">text</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> encodedText = base64.encodeToString(textByte);System.out.<span class="built_in">println</span>(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="keyword">new</span> <span class="keyword">String</span>(base64.decode(encodedText),<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><h3 id="2-3-Java8"><a href="#2-3-Java8" class="headerlink" title="2.3 Java8"></a><strong>2.3 Java8</strong></h3><p>&emsp;&emsp;Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line"><span class="keyword">final</span> Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">text</span> = <span class="string">"Java深入"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">byte</span>[] textByte = <span class="built_in">text</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"编码后："</span> + encodedText);<span class="comment">//编码后：SmF2Yea3seWFpQ==</span></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"解码后："</span> + <span class="keyword">new</span> <span class="keyword">String</span>(decoder.decode(encodedText), <span class="string">"UTF-8"</span>));<span class="comment">//解码后：Java深入</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。</p><h4 id="2-3-1-三种编码"><a href="#2-3-1-三种编码" class="headerlink" title="2.3.1 三种编码"></a><strong>2.3.1 三种编码</strong></h4><blockquote><p>java.util.Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p><ol><li>Basic编码：标准的BASE64编码，用于处理常规的需求</li><li>URL编码：使用下划线替换反斜线“/”有特殊的意义，URL编码会替换掉反斜线</li><li>MIME编码：使用基本的字母数字产生BASE64输出，对MIME格式比较适配：每一行输出不超过76个字符，而且每行以“\r\n”符结束。</li></ol></blockquote><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//Basic编码</span></span><br><span class="line">        <span class="keyword">String</span> basicEncoded = Base64.getEncoder().encodeToString(<span class="string">"subjects?parm=abcd"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"basic encoder: "</span> + basicEncoded);<span class="comment">//basic encoder: c3ViamVjdHM/cGFybT1hYmNk</span></span><br><span class="line">        <span class="comment">//URL编码</span></span><br><span class="line">        <span class="keyword">String</span> urlEncoded = Base64.getUrlEncoder().encodeToString(<span class="string">"subjects?parm=abcd"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"url encoder: "</span> + urlEncoded);<span class="comment">//url encoder: c3ViamVjdHM_cGFybT1hYmNk</span></span><br><span class="line">        <span class="comment">//MIME编码</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> t = <span class="number">0</span>; t &lt; <span class="number">10</span>; ++t) &#123;</span><br><span class="line">            sb.<span class="built_in">append</span>(UUID.randomUUID().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">byte</span>[] toEncode = sb.toString().getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">String</span> mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"mime encoder: "</span> + mimeEncoded);</span><br><span class="line"></span><br><span class="line">mime encoder: NWZkZjNhYTAtNTM5OS00MWMzLWJkMzctNDQ5MTI2ZTM1MmFlNzgxMmZhYmItODllMS00ZDI5LThi</span><br><span class="line">MTktMzVjNjdiYzQyMzYyMWRmNjdjMmUtNmI4YS00Y2MxLWEwOTAtODdkM2Y2Mzk4OTM3NjYzY2E3</span><br><span class="line">NjEtMThkZi00NTAwLThiNTgtMWZiOTQ5YWUwOTNhN2NhYTIzYWEtMDg1Zi00YTIyLWI5OTAtMGEw</span><br><span class="line">ZGI5YTYzMTRmNzU1OTAwODMtYjg0My00MjQyLTkxZDEtYzgwZGFlZTBmNmIzNzkxM2RmZjEtNGVi</span><br><span class="line">Ny00YTgzLWEyYjYtMGI5NTY5OGE4MjQwYmMwZDE3NDktZTI2Mi00NGNlLWJmOTgtZjZjNWVhNzIw</span><br><span class="line">OTNjMTRjODJhMjUtYWNjNS00ODZhLWIzNmEtMGU4ZTJkYjAzNTFhZDc3OTUzOTItMWQ3NS00ZWZh</span><br><span class="line">LWE4YWItMjFlOWZiNjRkYjMz</span><br></pre></td></tr></table></figure><h4 id="2-3-2-流的支持"><a href="#2-3-2-流的支持" class="headerlink" title="2.3.2 流的支持"></a><strong>2.3.2 流的支持</strong></h4><p>&emsp;&emsp;java.util.Base64支持流，包括编码和效率都很高，编码器和解码器的输入和输出无需缓冲Buffer。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> wrapping() throws IOException &#123;</span><br><span class="line">    <span class="keyword">String</span> src = <span class="string">"This is the content of any resource read from somewhere"</span> +</span><br><span class="line">            <span class="string">" into a stream. This can be text, image, video or any other stream."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码器封装OutputStream, 文件/tmp/buff-base64.txt的内容是BASE64编码的形式</span></span><br><span class="line">    <span class="built_in">try</span> (OutputStream os = Base64.getEncoder().wrap(<span class="keyword">new</span> FileOutputStream(<span class="string">"/tmp/buff-base64.txt"</span>))) &#123;</span><br><span class="line">        os.<span class="built_in">write</span>(src.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码器封装InputStream, 以及以流的方式解码, 无需缓冲</span></span><br><span class="line">    <span class="comment">// is being consumed. There is no need to buffer the content of the file just for decoding it.</span></span><br><span class="line">    <span class="built_in">try</span> (InputStream is = Base64.getDecoder().wrap(<span class="keyword">new</span> FileInputStream(<span class="string">"/tmp/buff-base64.txt"</span>))) &#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">while</span> ((len = is.<span class="built_in">read</span>(bytes)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="keyword">new</span> <span class="keyword">String</span>(bytes, <span class="number">0</span>, len, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://segmentfault.com/a/1190000016083208" title="Title" target="_blank" rel="noopener">Java Base64 编码解码方案总结</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Base64编码。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>DES加密</title>
    <link href="http://linyishui.top/2019111901.html"/>
    <id>http://linyishui.top/2019111901.html</id>
    <published>2019-11-19T13:41:14.000Z</published>
    <updated>2019-12-26T14:14:22.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DES加密"><a href="#DES加密" class="headerlink" title="DES加密"></a><strong>DES加密</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a><strong>1.1 背景</strong></h3><p>&emsp;&emsp;在20世纪60年代后期，IBM公司成立了一个由Horst Feistel负责的计算机密码学研究项目。1971年设计出密码算法LUCIFER后，该项目宣告结束。LUCIFER被卖给了伦敦的Lloyd公司，用在同样由IBM公司开发的现金发放系统上。LUCIFER是分组长度为64位、密钥长度为128位、具有Feistel结构的分组密码算法。因为LUCIFER非常成功，IBM决定开发一个适合于芯片实现的商业密码产品。这一次由Walter Tuchman和Carl Meyer牵头，参与者不仅有IBM公司的研究人员，而且还有美国国家安全局（NSA）的技术顾问。这次努力的结果是给出了LUCIFER的一个修订版，它的抗密码分析能力更强，而且密钥长度减小为56位。</p><p>&emsp;&emsp;1973年，美国国家标准局（NBS）征求美国国家密码标准方案时，IBM将Tuchman-Meyer方案提交给NBS，它是所有应征方案中最好的一个，所以1977年NBS将它采纳为数据加密标准，即DES。</p><h3 id="1-2-DES是什么"><a href="#1-2-DES是什么" class="headerlink" title="1.2 DES是什么"></a><strong>1.2 DES是什么</strong></h3><p>&emsp;&emsp;<strong>数据加密标准</strong>（英语：Data Encryption Standard，缩写为 DES）是一种<strong>对称密钥加密块密码算法</strong>，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它<strong>基于使用56位密钥的对称算法</strong>。</p><p>&emsp;&emsp;这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。</p><p>&emsp;&emsp;DES现在已经不是一种安全的加密方法，主要因为它使用的56位密钥过短。1999年1月，distributed.net与电子前哨基金会合作，在22小时15分钟内即公开破解了一个DES密钥。也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性，可以使用DES的派生算法3DES来进行加密，虽然3DES也存在理论上的攻击方法。在2001年，DES作为一个标准已经被<strong>高级加密标准</strong>（AES）所取代。另外，DES已经不再作为国家标准科技协会（前国家标准局）的一个标准。</p><p>&emsp;&emsp;在某些文献中，作为算法的DES被称为DEA（Data Encryption Algorithm，数据加密算法），以与作为标准的DES区分开来。</p><h3 id="1-3-Feistel"><a href="#1-3-Feistel" class="headerlink" title="1.3 Feistel"></a><strong>1.3 Feistel</strong></h3><p>&emsp;&emsp;分组密码常用的结构有SP、Feistel、Lai-Massey、MISTY等，其中Feistel结构的使用较为普遍，不仅DES用到了，后续的很多经典算法中都有涉及。</p><p>&emsp;&emsp;Feistel是以发明者Horst Feistel的名字命名的。加解密的原理如右图1，左边表示的加密过程，右边表示解密过程。</p><p>&emsp;&emsp;加密和解密公式如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010151.jpg" alt="加密和解密公式"></p><p>&emsp;&emsp;在每一轮加密过程中，明文被分成左右两部分。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010150.jpg" alt="Feistel"></p><p>&emsp;&emsp;不同的是，在加密过程中，轮数和轮密钥从小开始递增；解密时正好相反，从最大开始递减。</p><p>&emsp;&emsp;从图中可以看出，加密最后一轮的操作与前面的有所不同，最后一轮得到的两个部分没有交换，之所以这样是为了保持解密的流程和加密一致，这样在硬件设计时可以使用相同的结构，进而减少硬件面积。</p><p>&emsp;&emsp;假设明文为（L0,R0），一共有两轮计算，每轮的密钥分别为k0、k1，加解密的流程如图2。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010152.jpg" alt="加解密的流程"></p><hr><h2 id="第二节-算法流程"><a href="#第二节-算法流程" class="headerlink" title="第二节 算法流程"></a><strong>第二节 算法流程</strong></h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010153.jpg" alt="DES算法原理"></p><blockquote><p>DES算法原理如上图，相关参数如下：　</p><ul><li>明文分组长度：64 bits</li><li>密钥长度：64 bits</li><li>轮数：16轮<br>　<br>整个操作可以分为3部分：</li><li>初始置换和逆初始置换：这是一对可逆操作，一组数字经过初始置换（或逆初始置换）后，再经过逆初始置换（或初始置换）即可恢复原来的值；</li><li>每轮的加解密操作：64位明文和48为密钥经过一定的操作，输出64位密文；</li><li>轮密钥计算：64位初始密钥经过置换、循环移位等得到16轮的密钥，每轮密钥长度为48位。</li></ul></blockquote><p>&emsp;&emsp;接下来分别对这三种核心操作进行介绍。</p><h3 id="2-1-初始置换与逆初始置换"><a href="#2-1-初始置换与逆初始置换" class="headerlink" title="2.1 初始置换与逆初始置换"></a><strong>2.1 初始置换与逆初始置换</strong></h3><p>&emsp;&emsp;置换的操作如下表1、表2，将一个64位的输入通过各位的提到得到一个新的64位输出。观察可以发现x = IP-1 ( IP(x) ) = IP ( IP-1(x) )。　　</p><p>&emsp;&emsp;需要注意的一点是，图中的索引值从1开始（下文中的数字也类似），有些资料中是从0开始的，如果从零开始，则所有的数字减1即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010154.jpg" alt="DES算法原理"></p><h3 id="2-2-每轮的操作"><a href="#2-2-每轮的操作" class="headerlink" title="2.2 每轮的操作"></a><strong>2.2 每轮的操作</strong></h3><p>&emsp;&emsp;每一轮的流程如图4，从图中可以看出DES用到了Feistel结构。F即为图中虚线框的内容。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010155.jpg" alt="轮操作流程"></p><blockquote><p>每一轮主要涉及3中操作：</p><ul><li>扩展/置换：将32位输入扩展成48位输出，如表3；</li><li>S盒：将48位输入分成8组分别作为8个S盒的输入，每组6位，最高位和最低位作为行索引，中间4位作为列索引，得到一个值x（0&lt;=x&lt;=15），表示为二进制即为4位，8个S盒的输出和在一起正好32位。表4是S1的数值；</li><li>置换：对32位输入进行位的变化，输出仍为32位，如表5。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010156.jpg" alt="轮操作流程"></p><h3 id="2-3-轮密钥扩展"><a href="#2-3-轮密钥扩展" class="headerlink" title="2.3 轮密钥扩展"></a><strong>2.3 轮密钥扩展</strong></h3><blockquote><p>从图1和图4中可以得出，密钥扩展流程可以表示如下：</p><ol><li>64位初始密钥P进行置换选择1，得到56位输出K；</li><li>将K循环左移一定位数，再进行置换选择2得到48位输出k1(即第一轮的密钥)；</li><li>循环步骤2)，直至得到16轮的密钥（k1、k2、……、k16）；</li><li>结束。</li></ol></blockquote><p>&emsp;&emsp;置换选择1、置换选择2和左移次数的值分别如表6、表7、表8。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010157.jpg" alt="轮操作流程"></p><hr><h2 id="第二节-源码解析"><a href="#第二节-源码解析" class="headerlink" title="第二节 源码解析"></a><strong>第二节 源码解析</strong></h2><p>&emsp;&emsp;暂无。</p><hr><h2 id="第三节-实战应用"><a href="#第三节-实战应用" class="headerlink" title="第三节 实战应用"></a><strong>第三节 实战应用</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.cnblogs.com/luop/p/4366902.html" title="Title" target="_blank" rel="noopener">密码算法详解——DES</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/songwenlong/p/5944139.html" title="Title" target="_blank" rel="noopener">安全体系（一）—— DES算法详解</a></p></blockquote><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96" title="Title" target="_blank" rel="noopener">数据加密标准</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍DES加密算法，内容包括：简介（背景、AES是什么、AES思维导图），算法流程（字节替代、行移位、列混淆、轮密钥加、密钥扩展算法、总结），源码解析，实战应用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>AES加密</title>
    <link href="http://linyishui.top/2019111801.html"/>
    <id>http://linyishui.top/2019111801.html</id>
    <published>2019-11-18T07:33:30.000Z</published>
    <updated>2019-12-26T13:56:21.663Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a><strong>AES加密</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a><strong>1.1 背景</strong></h3><p>&emsp;&emsp;我们知道<strong>数据加密标准</strong>（Data Encryption Standard: DES）的密钥长度是56比特，因此算法的理论安全强度是256。但二十世纪中后期正是计算机飞速发展的阶段，元器件制造工艺的进步使得<strong>计算机的处理能力越来越强</strong>，<strong>DES将不能提供足够的安全性</strong>。1997年1月2号，美国国家标准技术研究所（National Institute of Standards and Technology: NIST）宣布希望征集高级加密标准（Advanced Encryption Standard: AES）[3]，用以取代DES。AES得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终有5个候选算法进入最后一轮：Rijndael，Serpent，Twofish，RC6和MARS，下图分别为其中的5位作者。最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法获胜。</p><h3 id="1-2-AES是什么"><a href="#1-2-AES是什么" class="headerlink" title="1.2 AES是什么"></a><strong>1.2 AES是什么</strong></h3><p>&emsp;&emsp;Rijndael由比利时两位非常著名的密码学家Joan Daemen和Vincent Rijmen设计。Rijndael是一个<strong>分组密码算法族</strong>，其分组长度包括128比特、160比特、192比特、224比特、256比特，密钥长度也包括这五种长度，但是最终AES只选取了分组长度为128比特，密钥长度为128比特、192比特和256比特的三个版本。本文主要结合AES-128进行介绍，AES-196和AES-256的思路基本一样，只是密钥扩展算法的过程会稍有不同，加解密的轮数会适当增加，但加解密的操作都是一样的。另外，本文只对AES算法的各个模块、基本原理进行介绍，旨在加深对算法流程、密码算法实现的了解。在正式软件运用中并不推荐自己编写代码，很多开源项目如Linux，OPENSSL，SRTP等都有非常高效的实现。由于数学知识的缺陷，本文不介绍算法安全性分析相关的知识，有兴趣的读者可以自行阅读相关文献。</p><p>&emsp;&emsp;AES是一个<strong>分组密码</strong>，属于<strong>对称密码</strong>范畴，AES算法的模块在对称密码领域特别是分组密码领域常有使用。</p><h3 id="1-3-AES思维导图"><a href="#1-3-AES思维导图" class="headerlink" title="1.3 AES思维导图"></a><strong>1.3 AES思维导图</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010148.jpg" alt="AES思维导图"></p><hr><h2 id="第二节-算法流程"><a href="#第二节-算法流程" class="headerlink" title="第二节 算法流程"></a><strong>第二节 算法流程</strong></h2><p>&emsp;&emsp;Rijndael算法是基于代换-置换网络（SPN，Substitution-permutation network）的迭代算法。明文数据经过多轮次的转换后方能生成密文，每个轮次的转换操作由轮函数定义。轮函数任务就是根据密钥编排序列（即轮密码）对数据进行不同的代换及置换等操作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010149.png" alt="轮函数的流程"></p><p>&emsp;&emsp;上图左侧为轮函数的流程，主要涉及4种操作：<strong>字节替代</strong>（SubBytes）、<strong>行移位</strong>（ShiftRows）、<strong>列混淆</strong>（MixColumns）和<strong>轮密钥加</strong>（AddRoundKey）。图右侧为密钥编排方案，在Rijndael中称为<strong>密钥扩展算法</strong>（KeyExpansion）。</p><blockquote><p>下图给出了AES加解密的流程，从图中可以看出：</p><ol><li>解密算法的每一步分别对应加密算法的逆操作</li><li>加解密所有操作的顺序正好是相反的。</li></ol></blockquote><p>&emsp;&emsp;正是由于这几点（再加上加密算法与解密算法每步的操作互逆）保证了算法的正确性。加解密中每轮的密钥分别由种子密钥经过密钥扩展算法得到。算法中16字节的明文、密文和轮子密钥都以一个4x4的矩阵表示。AES标准算法将128位的明文，以特定次序生成一个4x4的矩阵（每个元素是一个字节，8位），即初始状态（state），经由轮函数的迭代转换之后又将作为下一轮迭代的输入继续参与运算直到迭代结束。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010139.png" alt="算法流程"></p><p>&emsp;&emsp;Rijndael算法支持大于128位的明文分组，所以需要列数更多的矩阵来描述。Rijndael轮函数的运算是在特殊定义的有限域GF(256)上进行的。有限域（Finite Field）又名伽罗瓦域（Galois field），简单言之就是一个满足特定规则的集合，集合中的元素可以进行加减乘除运算，且运算结果也是属于此集合。更详细有有关Rijndael算法的数学描述，在此不做熬述。</p><h3 id="2-1-字节替代"><a href="#2-1-字节替代" class="headerlink" title="2.1 字节替代"></a><strong>2.1 字节替代</strong></h3><p>&emsp;&emsp;字节代替的主要功能是通过S盒完成一个字节到另外一个字节的映射，S盒的详细构造方法就不展开了，这里直接给出构造好的结果，下图(a)为S盒，图(b)为S-1（S盒的逆）。S盒用于提供密码算法的<strong>混淆性</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010140.png" alt="S-BOX"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010141.png" alt="Inverse S-BOX"></p><p>&emsp;&emsp;S和S-1分别为16x16的矩阵，完成一个8比特输入到8比特输出的映射，输入的高4-bit对应的值作为行标，低4-bit对应的值作为列标。假设输入字节的值为a=a7a6a5a4a3a2a1a0，则输出值为S[a7a6a5a4][a3a2a1a0]，S-1的变换也同理。</p><p>&emsp;&emsp;例如：字节00000000B替换后的值为（S[0][0]=）63H，再通过S-1即可得到替换前的值，（S-1 [6][3]=）00H。</p><h3 id="2-2-行移位"><a href="#2-2-行移位" class="headerlink" title="2.2 行移位"></a><strong>2.2 行移位</strong></h3><p>&emsp;&emsp;行移位是一个4x4的矩阵内部字节之间的置换，用于提供算法的<strong>扩散性</strong>。</p><h4 id="2-2-1-正向行移位"><a href="#2-2-1-正向行移位" class="headerlink" title="2.2.1 正向行移位"></a><strong>2.2.1 正向行移位</strong></h4><p>&emsp;&emsp;正向行移位用于加密，其原理图如下。其中：第一行保持不变，第二行循环左移8比特，第三行循环左移16比特，第四行循环左移24比特。</p><p>&emsp;&emsp;假设矩阵的名字为state，用公式表示如下：state’[i][j] = state[i][(j+i)%4];其中i、j属于[0,3]。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010142.png" alt="行移位"></p><h4 id="2-2-2-逆向行移位"><a href="#2-2-2-逆向行移位" class="headerlink" title="2.2.2 逆向行移位"></a><strong>2.2.2 逆向行移位</strong></h4><p>&emsp;&emsp;逆向行移位即是相反的操作，即：第一行保持不变，第二行循环右移8比特，第三行循环右移16比特，第四行循环右移24比特。</p><p>&emsp;&emsp;用公式表示如下：state’[i][j] = state[i][(4+j-i)%4];其中i、j属于[0,3]。</p><h3 id="2-3-列混淆"><a href="#2-3-列混淆" class="headerlink" title="2.3 列混淆"></a><strong>2.3 列混淆</strong></h3><p>&emsp;&emsp;列混淆：利用GF(28)域上算术特性的一个代替，同样用于提供算法的<strong>扩散性</strong>。</p><h4 id="2-3-1-正向列混淆"><a href="#2-3-1-正向列混淆" class="headerlink" title="2.3.1 正向列混淆"></a><strong>2.3.1 正向列混淆</strong></h4><p>&emsp;&emsp;正向列混淆的原理图如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010143.png" alt="列混淆原理图"></p><p>&emsp;&emsp;根据矩阵的乘法可知，在列混淆的过程中，每个字节对应的值只与该列的4个值有关系。</p><blockquote><p>此处的乘法和加法都是定义在GF(28)上的，需要注意如下几点：</p><ol><li>将某个字节所对应的值乘以2，其结果就是将该值的二进制位左移一位，如果原始值的最高位为1，则还需要将移位后的结果异或00011011；[1]</li><li>乘法对加法满足分配率，例如：07·S0,0=(01⊕02⊕04)·S0,0= S0,0⊕(02·S0,0)(04·S0,0)</li><li>此处的矩阵乘法与一般意义上矩阵的乘法有所不同，各个值在相加时使用的是模28加法（异或运算）。</li></ol></blockquote><p>&emsp;&emsp;下面举一个例子，假设某一列的值如下图，运算过程如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010144.png" alt="运算过程"></p><p>&emsp;&emsp;在计算02与C9的乘积时，由于C9对应最左边的比特为1，因此需要将C9左移一位后的值与(0001 1011)求异或。同理可以求出另外几个值。</p><h4 id="2-3-2-逆向列混淆"><a href="#2-3-2-逆向列混淆" class="headerlink" title="2.3.2 逆向列混淆"></a><strong>2.3.2 逆向列混淆</strong></h4><p>　<br>&emsp;&emsp;逆向列混淆的原理图如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010145.png" alt="逆向列混淆原理图"></p><p>&emsp;&emsp;由于：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010146.png" alt="由于"></p><p>&emsp;&emsp;说明两个矩阵互逆，经过一次逆向列混淆后即可恢复原文。</p><h3 id="2-4-轮密钥加"><a href="#2-4-轮密钥加" class="headerlink" title="2.4 轮密钥加"></a><strong>2.4 轮密钥加</strong></h3><p>&emsp;&emsp;这个操作相对简单，其依据的原理是“任何数和自身的异或结果为0”。加密过程中，每轮的输入与轮子密钥异或一次；因此，解密时再异或上该轮的轮子密钥即可恢复。</p><h3 id="2-5-密钥扩展算法"><a href="#2-5-密钥扩展算法" class="headerlink" title="2.5 密钥扩展算法"></a><strong>2.5 密钥扩展算法</strong></h3><p>&emsp;&emsp;密钥扩展过程说明：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010147.png" alt="密钥扩展过程"></p><blockquote><ol><li>将种子密钥按图(a)的格式排列，其中k0、k1、……、k15依次表示种子密钥的一个字节；排列后用4个32比特的字表示，分别记为w[0]、w[1]、w[2]、w[3]；</li><li>按照如下方式，依次求解w[j]，其中j是整数并且属于[4,43]；</li><li>若j%4=0,则w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]；</li></ol></blockquote><blockquote><p>函数g的流程说明：</p><p>&emsp;&emsp;a)  将w循环左移8比特；</p><p>&emsp;&emsp;b)  分别对每个字节做S盒置换；</p><p>&emsp;&emsp;c)  与32比特的常量（RC[j/4],0,0,0）进行异或，RC是一个一维数组，其值如下。（RC的值只需要有10个，而此处用了11个，实际上RC[0]在运算中没有用到，增加RC[0]是为了便于程序中用数组表示。由于j的最小取值是4，j/4的最小取值则是1，因此不会产生错误。）</p></blockquote><p>&emsp;&emsp;RC = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36}</p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a><strong>2.6 总结</strong></h3><p>&emsp;&emsp;密码算法要求是可逆的，这样解密算法才能正确的恢复明文。拿AES来说，在密钥固定的情况下，明文和密文在整个输入空间是一一对应的。因此算法的各个部件也都是可逆的，再将各个部件的操作顺序设计成可逆的，密文就能正确的解密了。</p><hr><h2 id="第二节-源码解析"><a href="#第二节-源码解析" class="headerlink" title="第二节 源码解析"></a><strong>第二节 源码解析</strong></h2><p>&emsp;&emsp;暂无。</p><hr><h2 id="第三节-实战应用"><a href="#第三节-实战应用" class="headerlink" title="第三节 实战应用"></a><strong>第三节 实战应用</strong></h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class AesEncryptUtils &#123;</span><br><span class="line">    <span class="comment">//可配置到Constant中，并读取配置文件注入,16位,自己定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> KEY = <span class="string">"abcdefghijklmnop"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数分别代表 算法名称/加密模式/数据填充方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> ALGORITHMSTR = <span class="string">"AES/ECB/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * @param content 加密的字符串</span></span><br><span class="line"><span class="comment">     * @param encryptKey key值</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> encrypt(<span class="keyword">String</span> content, <span class="keyword">String</span> encryptKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        KeyGenerator kgen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        kgen.init(<span class="number">128</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(ALGORITHMSTR);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">new</span> SecretKeySpec(encryptKey.getBytes(), <span class="string">"AES"</span>));</span><br><span class="line">        <span class="built_in">byte</span>[] b = cipher.doFinal(content.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 采用base64算法进行转码,避免出现中文乱码</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * @param encryptStr 解密的字符串</span></span><br><span class="line"><span class="comment">     * @param decryptKey 解密的key值</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> decrypt(<span class="keyword">String</span> encryptStr, <span class="keyword">String</span> decryptKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        KeyGenerator kgen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        kgen.init(<span class="number">128</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(ALGORITHMSTR);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, <span class="keyword">new</span> SecretKeySpec(decryptKey.getBytes(), <span class="string">"AES"</span>));</span><br><span class="line">        <span class="comment">// 采用base64算法进行转码,避免出现中文乱码</span></span><br><span class="line">        <span class="built_in">byte</span>[] encryptBytes = Base64.decodeBase64(encryptStr);</span><br><span class="line">        <span class="built_in">byte</span>[] decryptBytes = cipher.doFinal(encryptBytes);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>(decryptBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> encrypt(<span class="keyword">String</span> content) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> encrypt(content, KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> decrypt(<span class="keyword">String</span> encryptStr) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> decrypt(encryptStr, KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">String</span> content = <span class="string">"dhfkKjhsd23wefsd"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"加密前："</span> + content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> encrypt = encrypt(content, KEY);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"加密后："</span> + encrypt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> decrypt = decrypt(encrypt, KEY);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"解密后："</span> + decrypt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://github.com/matt-wu/AES" title="Title" target="_blank" rel="noopener">matt-wu/AES</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/luop/p/4334160.html" title="Title" target="_blank" rel="noopener">密码算法详解——AES</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628" title="Title" target="_blank" rel="noopener">AES加密算法的详细介绍与实现</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍AES加密算法，内容包括：简介（背景、AES是什么、AES思维导图），算法流程（字节替代、行移位、列混淆、轮密钥加、密钥扩展算法、总结），源码解析，实战应用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security OAuth2（未完成）</title>
    <link href="http://linyishui.top/2019111701.html"/>
    <id>http://linyishui.top/2019111701.html</id>
    <published>2019-11-17T07:53:56.000Z</published>
    <updated>2020-01-02T02:14:24.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a><strong>Spring Security OAuth2</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><hr><h2 id="第二节-Spring新版本迁移"><a href="#第二节-Spring新版本迁移" class="headerlink" title="第二节 Spring新版本迁移"></a><strong>第二节 Spring新版本迁移</strong></h2><p>&emsp;&emsp;OAuth 2.0客户端和资源服务器从Spring Security OAuth 2.x移动到Spring Security 5.2.x的指南。由于<a href="https://github.com/spring-projects/spring-security" title="Title" target="_blank" rel="noopener">Spring Security</a>不提供授权服务器支持，因此迁移<a href="https://github.com/spring-projects/spring-security-oauth" title="Title" target="_blank" rel="noopener">Spring Security OAuth</a>授权服务器超出了本文档的范围</p><h3 id="2-1-客户端-Client"><a href="#2-1-客户端-Client" class="headerlink" title="2.1 客户端 Client"></a><strong>2.1 客户端 Client</strong></h3><p>&emsp;&emsp;通过添加@EnableOAuth2Client注释可以启用Spring Security OAuth对Authorization Code flow的支持，而其他的flows则需要构造并公开OAuth2ClientContext实例。</p><p>&emsp;&emsp;Spring Security的OAuth 2.0 Client则是通过oauth2Client的DSL方法启用支持的。</p><h4 id="2-1-1-RestTemplate-and-WebClient"><a href="#2-1-1-RestTemplate-and-WebClient" class="headerlink" title="2.1.1 RestTemplate and WebClient"></a><strong>2.1.1 RestTemplate and WebClient</strong></h4><p>&emsp;&emsp;Spring Security OAuth扩展了RestTemplate, 引入了OAuth2RestTemplate，这个类需要注册为@Bean并实例化。</p><p>&emsp;&emsp;Spring Security则选择了支持组合并提供了OAuth2AuthorizedClientService,用来帮助创建RestTemplate拦截器或WebClient交换过滤器函数。Spring Security同时为基于Servlet-和基于WebFlux-的应用程序提供了ExchangeFilterFunction。</p><h4 id="2-1-2-Simplified-Client-Resolution"><a href="#2-1-2-Simplified-Client-Resolution" class="headerlink" title="2.1.2 Simplified Client Resolution"></a><strong>2.1.2 Simplified Client Resolution</strong></h4><p>&emsp;&emsp;在Spring Security OAuth中检索当前授权的客户端，需要自动注入（autowire）OAuth2ClientContext实例。Spring Security OAuth通过Spring MVCs request以及session scope来存储OAuth2ClientContext实例。</p><p>&emsp;&emsp;在Spring Security中检索当前授权的客户端，需要@RegisteredOAuth2AuthorizedClient方法参数注解。Spring Security 把已授权的客户端存储在OAuth2AuthorizedClientRepository中。</p><h4 id="2-1-3-Enhanced-Client-Resolution"><a href="#2-1-3-Enhanced-Client-Resolution" class="headerlink" title="2.1.3 Enhanced Client Resolution"></a><strong>2.1.3 Enhanced Client Resolution</strong></h4><p>&emsp;&emsp;Spring Security OAuth通过Spring Boot properties配置单个客户端。</p><p>&emsp;&emsp;Spring Security使用ClientRegistrationRepository来表示客户端，客户端可以通过Spring Security DSL来提供或仍使用Spring Boot配置。</p><h4 id="2-1-4-Simplified-JWT-Support"><a href="#2-1-4-Simplified-JWT-Support" class="headerlink" title="2.1.4 Simplified JWT Support"></a><strong>2.1.4 Simplified JWT Support</strong></h4><p>&emsp;&emsp;Spring Security OAuth通过spring-security-jwt提供JWT支持。</p><p>&emsp;&emsp;Spring Security则依赖于Nimbus提供JWT支持。</p><h4 id="2-1-5-示例-Examples-Matrix"><a href="#2-1-5-示例-Examples-Matrix" class="headerlink" title="2.1.5 示例 Examples Matrix"></a><strong>2.1.5 示例 Examples Matrix</strong></h4><p>&emsp;&emsp;Spring Security和Spring Security OAuth2都提供了如何配置客户端的示例：</p><table><thead><tr><th style="text-align:left">用例</th><th style="text-align:left">Spring Security</th><th style="text-align:left">Spring Security OAuth</th></tr></thead><tbody><tr><td style="text-align:left">Authorization Code</td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-2-4-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">Refresh Token</td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-2-4-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">Client Credentials</td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-2-4-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">Resource Owner Password Credentials</td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-2-4-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td></tr></tbody></table><h3 id="2-2-登录-Login"><a href="#2-2-登录-Login" class="headerlink" title="2.2 登录 Login"></a><strong>2.2 登录 Login</strong></h3><h4 id="2-2-1-方法变更-Changes-In-Approach"><a href="#2-2-1-方法变更-Changes-In-Approach" class="headerlink" title="2.2.1 方法变更 Changes In Approach"></a><strong>2.2.1 方法变更 Changes In Approach</strong></h4><p>&emsp;&emsp;Spring Security称呼此功能为OAuth 2.0 Login而Spring Security OAuth则称为SSO。</p><p>&emsp;&emsp;Spring Security OAuth的SSO支持通过添加@EnableOAuth2Sso注解开启。</p><p>&emsp;&emsp;Spring Security的OAuth 2.0 Login支持通过oauth2Login() DSL方法启用的。</p><h3 id="2-3-资源服务器-Resource-Server"><a href="#2-3-资源服务器-Resource-Server" class="headerlink" title="2.3 资源服务器 Resource Server"></a><strong>2.3 资源服务器 Resource Server</strong></h3><h4 id="2-3-1-方法变更-Changes-In-Approach"><a href="#2-3-1-方法变更-Changes-In-Approach" class="headerlink" title="2.3.1 方法变更 Changes In Approach"></a><strong>2.3.1 方法变更 Changes In Approach</strong></h4><p>&emsp;&emsp;Spring Security OAuth的资源服务器支持通过添加@EnableResourceServer注解开启。</p><p>&emsp;&emsp;Spring Security的资源服务器支持通过oauth2ResourceServer DSL方法启用的。</p><p>&emsp;&emsp;Spring Security OAuth为资源服务器提供了两种不同的DSL方法，通过扩展ResourceServerConfigurerAdapter来配置。</p><p>&emsp;&emsp;Spring Security通过Spring Security DSL提供相同的功能, 通过扩展WebSecurityConfigurerAdapter来配置。</p><p>&emsp;&emsp;Spring Security OAuth为具体授权规则指定了两个位置，第一个是通过ResourceServerConfigurerAdapter - 此处的任意规则都是为存在（present）的bearer token设定，第二个是通过WebSecurityConfigurerAdapter - 此处的任意规则都是为缺席（absent）的bearer token设定。</p><p>&emsp;&emsp;Spring Security则标明所有的授权规则都是通过一个或多个WebSecurityConfigurerAdapter配置而来的。</p><p>&emsp;&emsp;Spring Security OAuth提供了一个自定义的SpEL变量oauth2。为了基于scope去进行授权请求或方法, 可以编写一个表达式如access(“#oauth2.hasScope(‘scope’)”)。</p><p>&emsp;&emsp;Spring Security转换scope遵循授权命名规范。为了基于scope去进行授权请求或方法, 可以编写一个表达式如hasAuthority(“SCOPE_scope”)。</p><h4 id="2-3-2-示例-Examples-Matrix"><a href="#2-3-2-示例-Examples-Matrix" class="headerlink" title="2.3.2 示例 Examples Matrix"></a><strong>2.3.2 示例 Examples Matrix</strong></h4><table><thead><tr><th style="text-align:left">用例</th><th style="text-align:left">Spring Security</th><th style="text-align:left">Spring Security OAuth</th></tr></thead><tbody><tr><td style="text-align:left">JWT + JWK</td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2resourceserver" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security-oauth2-boot/tree/master/samples/spring-boot-sample-secure-oauth2-resource-jwt" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">JWT + Key</td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2resourceserver-static" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/#oauth2-boot-resource-server-jwt-single-key" title="Title" target="_blank" rel="noopener">Doc</a></td></tr><tr><td style="text-align:left">Opaque Token</td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2resourceserver-opaque" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security-oauth2-boot/tree/master/samples/spring-boot-sample-secure-oauth2-resource" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">w/ Actuator</td><td style="text-align:left"><a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#multiple-httpsecurity" title="Title" target="_blank" rel="noopener">Doc</a></td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security-oauth2-boot/tree/master/samples/spring-boot-sample-secure-oauth2-actuator" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">Audience Validation</td><td style="text-align:left"><a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#oauth2resourceserver-jwt-validation-custom" title="Title" target="_blank" rel="noopener">Doc</a></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Authorizing Requests</td><td style="text-align:left"><a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#oauth2resourceserver-jwt-authorization" title="Title" target="_blank" rel="noopener">Doc</a></td><td style="text-align:left"><a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/#oauth2-boot-resource-server-authorization" title="Title" target="_blank" rel="noopener">Doc</a></td></tr></tbody></table><h4 id="2-3-3-未移植功能-Unported-Features"><a href="#2-3-3-未移植功能-Unported-Features" class="headerlink" title="2.3.3 未移植功能 Unported Features"></a><strong>2.3.3 未移植功能 Unported Features</strong></h4><p>&emsp;&emsp;There are some features that we currently have no plans to port over.</p><p>&emsp;&emsp;In Spring Security OAuth, you can configure a UserDetailsService to look up a user that corresponds with the incoming bearer token. There are no plans for Spring Security’s Resource Server support to pick up a UserDetailsService. This is still simple in Spring Security, though, via the jwtAuthenticationConverter DSL method. Notably, one can return a BearerTokenAuthentication which takes an instance of OAuth2AuthenticatedPrincipal for a principal.</p><p>&emsp;&emsp;In Spring Security OAuth, you can assign an identifier to the resource server via the ResourceServerSecurityConfigurer#resourceId method. This configures the realm name used by the authentication entry point as well as adds audience validation. No such identifier is planned for Spring Security. However, audience validation and a custom realm name are both simple to achieve by configuring an OAuth2TokenValidator and AuthenticationEntryPoint respectively.</p><hr><h2 id="第三节-实战：实现单点登录"><a href="#第三节-实战：实现单点登录" class="headerlink" title="第三节 实战：实现单点登录"></a><strong>第三节 实战：实现单点登录</strong></h2><p>&emsp;&emsp;</p><hr><h2 id="第四节-实战：APP平台第三方应用授权"><a href="#第四节-实战：APP平台第三方应用授权" class="headerlink" title="第四节 实战：APP平台第三方应用授权"></a><strong>第四节 实战：APP平台第三方应用授权</strong></h2><p>&emsp;&emsp;首先在平台官网注册成为开发者。</p><p>&emsp;&emsp;然后注册应用信息，并搭建好项目。</p><p>&emsp;&emsp;OAuth时序图如下，通过OAuth来对接个人项目和APP平台，之后开发完毕后，只要保证提供一个稳定可用的线上版本即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010138.jpg" alt="OAuth时序图"></p><p>&emsp;&emsp;官网文档提供了OAuth2.0的authorize接口、access token接口、获取用户信息接口。</p><p>&emsp;&emsp;怎么通过Spring Security配置OAuth2 Client？找了一下Spring官网Demo：<a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">OAuth-2.0-Migration-Guide</a>，直接按Demo来实现我们的需求。</p><p>&emsp;&emsp;代码就没必要再贴一遍了，了解OAuth2协议流程，对整个技术框架都会比较熟悉了，快速的实现需求后，再慢慢解决遇到的问题。</p><p>&emsp;&emsp;以下为部分配置文件内容。</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spring-Security</span></span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.provider=cpdemo</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.client-id=15764595791470995</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.client-secret=trmCkkXvNTEtURIZjqj0yQ0A13PJ90</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.authorization-grant-type=authorization_code</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.client-name=TEST</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.redirect-uri=&#123;<span class="attribute">baseUrl&#125;/login/oauth2/code/&#123;registrationId&#125;</span></span><br><span class="line"><span class="attribute">spring.security.oauth2.client.registration.cpdemo-client.scope=get_user_info</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">spring.security.oauth2.client.provider.cpdemo.authorization-uri=https</span>://www<span class="variable">.cpdemo</span><span class="variable">.com</span>/connect/oauth2/authorize</span><br><span class="line">spring<span class="variable">.security</span><span class="variable">.oauth</span>2<span class="variable">.client</span><span class="variable">.provider</span><span class="variable">.cpdemo</span><span class="variable">.token-uri</span>=https://www<span class="variable">.cpdemo</span><span class="variable">.com</span>/connect/oauth2/token</span><br><span class="line">spring<span class="variable">.security</span><span class="variable">.oauth</span>2<span class="variable">.client</span><span class="variable">.provider</span><span class="variable">.cpdemo</span><span class="variable">.user-info-uri</span>=https://api<span class="variable">.cpdemo</span><span class="variable">.com</span>/user/campus/get_user_info</span><br><span class="line">spring<span class="variable">.security</span><span class="variable">.oauth</span>2<span class="variable">.client</span><span class="variable">.provider</span><span class="variable">.cpdemo</span><span class="variable">.user-name-attribute</span>=user_name</span><br><span class="line"></span><br><span class="line"># 解决  Possible CSRF detected - state parameter was required but no state could be found  问题</span><br><span class="line">server<span class="variable">.servlet</span><span class="variable">.session</span><span class="variable">.cookie</span><span class="variable">.name</span>=OAUTH2CLIENTSESSION</span><br></pre></td></tr></table></figure><hr><h2 id="第五节-问题记录：得到授权code后无法获取访问令牌"><a href="#第五节-问题记录：得到授权code后无法获取访问令牌" class="headerlink" title="第五节 问题记录：得到授权code后无法获取访问令牌"></a><strong>第五节 问题记录：得到授权code后无法获取访问令牌</strong></h2><h3 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a><strong>1.1 问题描述</strong></h3><p>&emsp;&emsp;正常访问<a href="http://localhost:7990/，向server发出授权请求，并重定向到一个PC接口需要用APP端扫码二维码，扫码成功后发生异常，返回/login?error页面提示错误msg：[authorization_request_not_found]" target="_blank" rel="noopener">http://localhost:7990/，向server发出授权请求，并重定向到一个PC接口需要用APP端扫码二维码，扫码成功后发生异常，返回/login?error页面提示错误msg：[authorization_request_not_found]</a></p><h3 id="1-2-问题跟踪"><a href="#1-2-问题跟踪" class="headerlink" title="1.2 问题跟踪"></a><strong>1.2 问题跟踪</strong></h3><p>&emsp;&emsp;开始调试代码，并记录访问流程。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">--首先客户发起请求，收到rep重定向到/index</span><br><span class="line">http://localhost:<span class="number">7990</span>/</span><br><span class="line">    Status Code: <span class="number">302</span> </span><br><span class="line">    Response：</span><br><span class="line">        Location: http://localhost:<span class="number">7990</span>/index</span><br><span class="line"></span><br><span class="line">--请求/index，收到rep重定向到/oauth2/authorization/cpdemo-client，并用Cookie保存session：OAUTH2CLIENTSESSION</span><br><span class="line">http://localhost:<span class="number">7990</span>/index</span><br><span class="line">    Status Code: <span class="number">302</span> </span><br><span class="line">    Response：</span><br><span class="line">        Location: http://localhost:<span class="number">7990</span>/oauth2/authorization/cpdemo-client</span><br><span class="line">        Set-Cookie: OAUTH2CLIENTSESSION=<span class="number">907</span>AE53F4C3C1DA967944F7B89E295EA; Path=/; HttpOnly</span><br><span class="line"></span><br><span class="line">--请求/oauth2/authorization/cpdemo-client，携带Cookie，收到rep重定向到www.xxx.com的授权接口，注意此时<span class="keyword">state</span>为WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ%<span class="number">3</span>D</span><br><span class="line">http://localhost:<span class="number">7990</span>/oauth2/authorization/cpdemo-client</span><br><span class="line">    Status Code: <span class="number">302</span> </span><br><span class="line">    Request：</span><br><span class="line">        Cookie: OAUTH2CLIENTSESSION=<span class="number">907</span>AE53F4C3C1DA967944F7B89E295EA</span><br><span class="line">    Response：</span><br><span class="line">        Location: https://www.xxx.com/connect/oauth2/authorize?response_type=code&amp;client_id=xxx&amp;scope=get_user_info&amp;<span class="keyword">state</span>=WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ%<span class="number">3</span>D&amp;redirect_uri=http://localhost:<span class="number">7990</span>/login/oauth2/code/cpdemo-client</span><br><span class="line"></span><br><span class="line">--请求www.cpdemo.com的授权接口，收到rep重定向到/pc/qrcode/index.html，并用保存Cookie：acw_tc，授权服务器检测到PC端访问，跳转到一个二维码界面</span><br><span class="line">https://www.cpdemo.com/connect/oauth2/authorize?response_type=code&amp;client_id=xxx&amp;scope=get_user_info&amp;<span class="keyword">state</span>=WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ%<span class="number">3</span>D&amp;redirect_uri=http://localhost:<span class="number">7990</span>/login/oauth2/code/cpdemo-client</span><br><span class="line">    Status Code: <span class="number">302</span> </span><br><span class="line">    Response</span><br><span class="line">        Location: https://www.cpdemo.com/connect/pc/qrcode/index.html?response_type=code&amp;scope=get_user_info&amp;client_id=<span class="number">15764595791470995</span>&amp;redirect_uri=http%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Flocalhost%<span class="number">3</span>A7990%<span class="number">2</span>Flogin%<span class="number">2</span>Foauth2%<span class="number">2</span>Fcode%<span class="number">2</span>Fcpdemo-client&amp;<span class="keyword">state</span>=WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=&amp;top_redirect=&amp;support_free_login=&amp;_=<span class="number">1577692641980</span><span class="comment">#</span></span><br><span class="line">        Set-Cookie: acw_tc=<span class="number">76</span>b20fec15776926419723186e2e77475066dc07c6ab3101e3cd340c96ff46;path=/;HttpOnly;Max-Age=<span class="number">2678401</span></span><br><span class="line"></span><br><span class="line">--请求/pc/qrcode/index.html，携带Cookie，获取二维码界面</span><br><span class="line">https://www.cpdemo.com/connect/pc/qrcode/index.html?response_type=code&amp;scope=get_user_info&amp;client_id=xxx&amp;redirect_uri=http%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Flocalhost%<span class="number">3</span>A7990%<span class="number">2</span>Flogin%<span class="number">2</span>Foauth2%<span class="number">2</span>Fcode%<span class="number">2</span>Fcpdemo-client&amp;<span class="keyword">state</span>=WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=&amp;top_redirect=&amp;support_free_login=&amp;_=xxx</span><br><span class="line">    Status Code: <span class="number">200</span> </span><br><span class="line">    Request：</span><br><span class="line">        Cookie: acw_tc=<span class="number">76</span>b20fec15776926419723186e2e77475066dc07c6ab3101e3cd340c96ff46</span><br><span class="line"></span><br><span class="line">--扫码登陆，并携带新的参数，注意此时<span class="keyword">state</span>值为login</span><br><span class="line">https://www.cpdemo.com/connect/qrcode/jsLogin</span><br><span class="line">    Status Code: <span class="number">200</span> </span><br><span class="line">    Request：</span><br><span class="line">        Cookie: acw_tc=<span class="number">76</span>b20fec15776926419723186e2e77475066dc07c6ab3101e3cd340c96ff46</span><br><span class="line">    Playload：</span><br><span class="line">        clientId: <span class="string">"xxx"</span></span><br><span class="line">        redirectUri: <span class="string">"http://localhost:7990/login/oauth2/code/cpdemo-client"</span></span><br><span class="line">        scope: <span class="string">"get_user_info"</span></span><br><span class="line">        responseType: <span class="string">"code"</span></span><br><span class="line">        <span class="keyword">state</span>: <span class="string">"login"</span></span><br><span class="line">        supportFreeLogin: <span class="string">""</span></span><br><span class="line"></span><br><span class="line">--登陆成功，重定向到redirectUri：/login/oauth2/code/cpdemo-client，并携带授权code和<span class="keyword">state</span>，请求失败，跳转error界面</span><br><span class="line">http://localhost:<span class="number">7990</span>/login/oauth2/code/cpdemo-client?code=cCrxmz1ds745WmV4WPYa1577692667&amp;<span class="keyword">state</span>=login</span><br><span class="line">    Request：</span><br><span class="line">        Cookie: OAUTH2CLIENTSESSION=<span class="number">907</span>AE53F4C3C1DA967944F7B89E295EA</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再看DEBUG日志</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="bullet">-本地客户端服务器收到code和state</span></span><br><span class="line"><span class="string">o.a.coyote.http11.Http11InputBuffer</span>      <span class="string">:</span> <span class="string">Received</span> <span class="string">[GET</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Host:</span> <span class="attr">localhost:7990</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">keep-alive</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">max-age=0</span></span><br><span class="line"><span class="attr">Upgrade-Insecure-Requests:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">Mozilla/5.0</span> <span class="string">(Windows</span> <span class="string">NT</span> <span class="number">10.0</span><span class="string">;</span> <span class="string">Win64;</span> <span class="string">x64)</span> <span class="string">AppleWebKit/537.36</span> <span class="string">(KHTML,</span> <span class="string">like</span> <span class="string">Gecko)</span> <span class="string">Chrome/79.0.3945.88</span> <span class="string">Safari/537.36</span></span><br><span class="line"><span class="attr">Accept:</span> <span class="string">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="attr">Sec-Fetch-Site:</span> <span class="string">cross-site</span></span><br><span class="line"><span class="attr">Sec-Fetch-Mode:</span> <span class="string">navigate</span></span><br><span class="line"><span class="attr">Accept-Encoding:</span> <span class="string">gzip,</span> <span class="string">deflate,</span> <span class="string">br</span></span><br><span class="line"><span class="attr">Accept-Language:</span> <span class="string">zh-CN,zh;q=0.9,en;q=0.8</span></span><br><span class="line"><span class="attr">Cookie:</span> <span class="string">OAUTH2CLIENTSESSION=9F0F448755B953A5542B4E2856AC7C54</span></span><br><span class="line"></span><br><span class="line"><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-过滤器校验</span></span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">1</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'WebAsyncManagerIntegrationFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">2</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'SecurityContextPersistenceFilter'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-HttpSessionSecurityContextRepository提示取不到HttpSession</span></span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">w.c.HttpSessionSecurityContextRepository</span> <span class="string">:</span> <span class="literal">No</span> <span class="string">HttpSession</span> <span class="string">currently</span> <span class="string">exists</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">w.c.HttpSessionSecurityContextRepository</span> <span class="string">:</span> <span class="literal">No</span> <span class="string">SecurityContext</span> <span class="string">was</span> <span class="string">available</span> <span class="string">from</span> <span class="string">the</span> <span class="attr">HttpSession:</span> <span class="literal">null</span>. <span class="string">A</span> <span class="string">new</span> <span class="string">one</span> <span class="string">will</span> <span class="string">be</span> <span class="string">created.</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">3</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'HeaderWriterFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">4</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'CsrfFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">5</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'LogoutFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.w.u.matcher.AntPathRequestMatcher</span>  <span class="string">:</span> <span class="string">Request</span> <span class="string">'GET /login/oauth2/code/cpdemo-client'</span> <span class="string">doesn't</span> <span class="string">match</span> <span class="string">'POST /logout'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">6</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'OAuth2AuthorizationRequestRedirectFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.w.u.matcher.AntPathRequestMatcher</span>  <span class="string">:</span> <span class="string">Checking</span> <span class="string">match</span> <span class="string">of</span> <span class="string">request</span> <span class="string">:</span> <span class="string">'/login/oauth2/code/cpdemo-client'</span><span class="string">;</span> <span class="string">against</span> <span class="string">'/oauth2/authorization/&#123;registrationId&#125;'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">org.apache.tomcat.util.http.Parameters</span>   <span class="string">:</span> <span class="string">Set</span> <span class="string">encoding</span> <span class="string">to</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">org.apache.tomcat.util.http.Parameters</span>   <span class="string">:</span> <span class="string">Decoding</span> <span class="string">query</span> <span class="literal">null</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">org.apache.tomcat.util.http.Parameters</span>   <span class="string">:</span> <span class="string">Start</span> <span class="string">processing</span> <span class="string">with</span> <span class="string">input</span> <span class="string">[code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login]</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">7</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'OAuth2LoginAuthenticationFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.905</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.w.u.matcher.AntPathRequestMatcher</span>  <span class="string">:</span> <span class="string">Checking</span> <span class="string">match</span> <span class="string">of</span> <span class="string">request</span> <span class="string">:</span> <span class="string">'/login/oauth2/code/cpdemo-client'</span><span class="string">;</span> <span class="string">against</span> <span class="string">'/login/oauth2/code/*'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-OAuth2LoginAuthenticationFilter抛出异常OAuth2AuthenticationException：[authorization_request_not_found]</span> </span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.905</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.s.o.c.w.OAuth2LoginAuthenticationFilter</span> <span class="string">:</span> <span class="string">Request</span> <span class="string">is</span> <span class="string">to</span> <span class="string">process</span> <span class="string">authentication</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.912</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.s.o.c.w.OAuth2LoginAuthenticationFilter</span> <span class="string">:</span> <span class="string">Authentication</span> <span class="string">request</span> <span class="attr">failed:</span> <span class="string">org.springframework.security.oauth2.core.OAuth2AuthenticationException:</span> <span class="string">[authorization_request_not_found]</span> </span><br><span class="line"></span><br><span class="line"><span class="string">org.springframework.security.oauth2.core.OAuth2AuthenticationException:</span> <span class="string">[authorization_request_not_found]</span> </span><br><span class="line"><span class="string">at</span> <span class="string">org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter.attemptAuthentication(OAuth2LoginAuthenticationFilter.java:163)</span> <span class="string">~[spring-security-oauth2-client-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span></span><br><span class="line"><span class="string">at</span> <span class="string">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212)</span> <span class="string">~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span></span><br><span class="line"><span class="string">at</span> <span class="string">org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)</span> <span class="string">[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.914</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.s.o.c.w.OAuth2LoginAuthenticationFilter</span> <span class="string">:</span> <span class="string">Updated</span> <span class="string">SecurityContextHolder</span> <span class="string">to</span> <span class="string">contain</span> <span class="literal">null</span> <span class="string">Authentication</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.914</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.s.o.c.w.OAuth2LoginAuthenticationFilter</span> <span class="string">:</span> <span class="string">Delegating</span> <span class="string">to</span> <span class="string">authentication</span> <span class="string">failure</span> <span class="string">handler</span> <span class="string">org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler@48edcd38</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.914</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.a.SimpleUrlAuthenticationFailureHandler</span> <span class="string">:</span> <span class="string">Redirecting</span> <span class="string">to</span> <span class="string">/login?error</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.914</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.web.DefaultRedirectStrategy</span>        <span class="string">:</span> <span class="string">Redirecting</span> <span class="string">to</span> <span class="string">'/login?error'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.915</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.w.header.writers.HstsHeaderWriter</span>  <span class="string">:</span> <span class="string">Not</span> <span class="string">injecting</span> <span class="string">HSTS</span> <span class="string">header</span> <span class="string">since</span> <span class="string">it</span> <span class="string">did</span> <span class="string">not</span> <span class="string">match</span> <span class="string">the</span> <span class="string">requestMatcher</span> <span class="string">org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@93c27ef</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.915</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">w.c.HttpSessionSecurityContextRepository</span> <span class="string">:</span> <span class="string">SecurityContext</span> <span class="string">is</span> <span class="string">empty</span> <span class="string">or</span> <span class="string">contents</span> <span class="string">are</span> <span class="string">anonymous</span> <span class="bullet">-</span> <span class="string">context</span> <span class="string">will</span> <span class="string">not</span> <span class="string">be</span> <span class="string">stored</span> <span class="string">in</span> <span class="string">HttpSession.</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.915</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">s.s.w.c.SecurityContextPersistenceFilter</span> <span class="string">:</span> <span class="string">SecurityContextHolder</span> <span class="string">now</span> <span class="string">cleared,</span> <span class="string">as</span> <span class="string">request</span> <span class="string">processing</span> <span class="string">completed</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;定位到异常发生的代码，部分源码如下。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OAuth2LoginAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    public <span class="type">Authentication</span> attemptAuthentication(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response) <span class="keyword">throws</span> <span class="type">AuthenticationException</span> &#123;</span><br><span class="line">        <span class="type">MultiValueMap</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; params = <span class="type">OAuth2AuthorizationResponseUtils</span>.toMultiMap(request.getParameterMap());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="type">OAuth2AuthorizationResponseUtils</span>.isAuthorizationResponse(params)) &#123;</span><br><span class="line">            <span class="type">OAuth2Error</span> oauth2Error = <span class="keyword">new</span> <span class="type">OAuth2Error</span>(<span class="string">"invalid_request"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OAuth2AuthenticationException</span>(oauth2Error, oauth2Error.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">OAuth2AuthorizationRequest</span> authorizationRequest = <span class="keyword">this</span>.authorizationRequestRepository.removeAuthorizationRequest(request, response);<span class="comment">//此处获取authorizationRequest为null</span></span><br><span class="line">            <span class="keyword">if</span> (authorizationRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">OAuth2Error</span> oauth2Error = <span class="keyword">new</span> <span class="type">OAuth2Error</span>(<span class="string">"authorization_request_not_found"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OAuth2AuthenticationException</span>(oauth2Error, oauth2Error.toString());<span class="comment">//此处抛出异常</span></span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;继续跟踪代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionOAuth2AuthorizationRequestRepository</span> <span class="keyword">implements</span> <span class="title">AuthorizationRequestRepository</span>&lt;<span class="title">OAuth2AuthorizationRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    public OAuth2AuthorizationRequest removeAuthorizationRequest(HttpServletRequest request) &#123;</span><br><span class="line">        Assert.notNull(request, <span class="string">"request cannot be null"</span>);</span><br><span class="line">        <span class="built_in">String</span> stateParameter = <span class="keyword">this</span>.getStateParameter(request);<span class="comment">//取得state参数值为login</span></span><br><span class="line">        <span class="keyword">if</span> (stateParameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, OAuth2AuthorizationRequest&gt; authorizationRequests = <span class="keyword">this</span>.getAuthorizationRequests(request);<span class="comment">//获得映射："WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=" -&gt; req</span></span><br><span class="line">            OAuth2AuthorizationRequest originalRequest = (OAuth2AuthorizationRequest)authorizationRequests.remove(stateParameter);<span class="comment">//获得originalRequest为null</span></span><br><span class="line">            <span class="keyword">if</span> (!authorizationRequests.isEmpty()) &#123;</span><br><span class="line">                request.getSession().setAttribute(<span class="keyword">this</span>.sessionAttributeName, authorizationRequests);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                request.getSession().removeAttribute(<span class="keyword">this</span>.sessionAttributeName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> originalRequest;<span class="comment">//返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private <span class="built_in">String</span> getStateParameter(HttpServletRequest request) &#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="string">"state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, OAuth2AuthorizationRequest&gt; getAuthorizationRequests(HttpServletRequest request) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, OAuth2AuthorizationRequest&gt; authorizationRequests = session == <span class="keyword">null</span> ? <span class="keyword">null</span> : (<span class="built_in">Map</span>)session.getAttribute(<span class="keyword">this</span>.sessionAttributeName);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Map</span>)(authorizationRequests == <span class="keyword">null</span> ? <span class="keyword">new</span> HashMap() : authorizationRequests);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们得到的session中有两个attribute：AUTHORIZATION_REQUEST和SPRING_SECURITY_SAVED_REQUEST，前者存储了一组映射（”WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=” -&gt; req），后者则是默认Req：<a href="http://localhost:7990/index。" target="_blank" rel="noopener">http://localhost:7990/index。</a></p><p>&emsp;&emsp;所以此处是根据state参数值来获取session中存储的信息，但我们知道在首次请求授权服务器时我们提供的state为：WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=，扫码登陆后又提交了state为：login，但这里需要的是旧的state参数。</p><p>&emsp;&emsp;所以要么授权服务器在扫码登陆时不要替换state为login，而是WiSv；要么授权服务器在扫码登陆后返回code和state时给旧值WiSv；要么我们客户端重构。</p><p>&emsp;&emsp;联系对方工程师后，回复：“<strong>把state写死试试</strong>”。虽然有点无语，但好吧。</p><h3 id="1-3-问题处理"><a href="#1-3-问题处理" class="headerlink" title="1.3 问题处理"></a><strong>1.3 问题处理</strong></h3><h4 id="1-3-1-自定义Authorization-Code-Request"><a href="#1-3-1-自定义Authorization-Code-Request" class="headerlink" title="1.3.1 自定义Authorization_Code_Request"></a><strong>1.3.1 自定义Authorization_Code_Request</strong></h4><p>&emsp;&emsp;写死state，首先要自定义authorization code request，首先自定义OAuth2AuthorizationRequestResolver，覆盖state参数，代码如下。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class CustomAuthorizationRequestResolver implements OAuth2AuthorizationRequestResolver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientRegistrationRepository clientRegistrationRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AntPathRequestMatcher authorizationRequestMatcher;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringKeyGenerator stateGenerator = <span class="keyword">new</span> Base64StringKeyGenerator(Base64.getUrlEncoder());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringKeyGenerator secureKeyGenerator = <span class="keyword">new</span> Base64StringKeyGenerator(Base64.getUrlEncoder().withoutPadding(), <span class="number">96</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomAuthorizationRequestResolver(</span><br><span class="line">            ClientRegistrationRepository clientRegistrationRepository, <span class="keyword">String</span> authorizationRequestBaseUri) &#123;</span><br><span class="line">        Assert.notNull(clientRegistrationRepository, <span class="string">"clientRegistrationRepository cannot be null"</span>);</span><br><span class="line">        Assert.hasText(authorizationRequestBaseUri, <span class="string">"authorizationRequestBaseUri cannot be empty"</span>);</span><br><span class="line">        <span class="keyword">this</span>.clientRegistrationRepository = clientRegistrationRepository;</span><br><span class="line">        <span class="keyword">this</span>.authorizationRequestMatcher = <span class="keyword">new</span> AntPathRequestMatcher(authorizationRequestBaseUri + <span class="string">"/&#123;"</span> + <span class="string">"registrationId"</span> + <span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> OAuth2AuthorizationRequest resolve(HttpServletRequest request) &#123;</span><br><span class="line">        <span class="keyword">String</span> registrationId = <span class="keyword">this</span>.resolveRegistrationId(request);</span><br><span class="line">        <span class="keyword">String</span> redirectUriAction = <span class="keyword">this</span>.getAction(request, <span class="string">"login"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.resolve(request, registrationId, redirectUriAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> OAuth2AuthorizationRequest resolve(HttpServletRequest request, <span class="keyword">String</span> registrationId) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registrationId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> redirectUriAction = <span class="keyword">this</span>.getAction(request, <span class="string">"authorize"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resolve(request, registrationId, redirectUriAction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> getAction(HttpServletRequest request, <span class="keyword">String</span> defaultAction) &#123;</span><br><span class="line">        <span class="keyword">String</span> action = request.getParameter(<span class="string">"action"</span>);</span><br><span class="line">        <span class="keyword">return</span> action == <span class="keyword">null</span> ? defaultAction : action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OAuth2AuthorizationRequest resolve(HttpServletRequest request, <span class="keyword">String</span> registrationId, <span class="keyword">String</span> redirectUriAction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registrationId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ClientRegistration clientRegistration = <span class="keyword">this</span>.clientRegistrationRepository.findByRegistrationId(registrationId);</span><br><span class="line">            <span class="keyword">if</span> (clientRegistration == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid Client Registration with Id: "</span> + registrationId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; attributes = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">                attributes.put(<span class="string">"registration_id"</span>, clientRegistration.getRegistrationId());</span><br><span class="line">                OAuth2AuthorizationRequest.Builder builder;</span><br><span class="line">                <span class="keyword">if</span> (AuthorizationGrantType.AUTHORIZATION_CODE.equals(clientRegistration.getAuthorizationGrantType())) &#123;</span><br><span class="line">                    builder = OAuth2AuthorizationRequest.authorizationCode();</span><br><span class="line">                    Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; additionalParameters = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!CollectionUtils.isEmpty(clientRegistration.getScopes()) &amp;&amp; clientRegistration.getScopes().contains(<span class="string">"openid"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.addNonceParameters(attributes, additionalParameters);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ClientAuthenticationMethod.NONE.equals(clientRegistration.getClientAuthenticationMethod())) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.addPkceParameters(attributes, additionalParameters);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    builder.additionalParameters(additionalParameters);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!AuthorizationGrantType.IMPLICIT.equals(clientRegistration.getAuthorizationGrantType())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid Authorization Grant Type ("</span> + clientRegistration.getAuthorizationGrantType().getValue() + <span class="string">") for Client Registration with Id: "</span> + clientRegistration.getRegistrationId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    builder = OAuth2AuthorizationRequest.implicit();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">String</span> redirectUriStr = expandRedirectUri(request, clientRegistration, redirectUriAction);</span><br><span class="line"><span class="comment">//                OAuth2AuthorizationRequest authorizationRequest = builder.clientId(clientRegistration.getClientId()).authorizationUri(clientRegistration.getProviderDetails().getAuthorizationUri()).redirectUri(redirectUriStr).scopes(clientRegistration.getScopes()).state(this.stateGenerator.generateKey()).attributes(attributes).build();</span></span><br><span class="line">                <span class="comment">//stateGenerator.generateKey()替换为常量login</span></span><br><span class="line">                OAuth2AuthorizationRequest authorizationRequest = builder.clientId(clientRegistration.getClientId()).authorizationUri(clientRegistration.getProviderDetails().getAuthorizationUri()).redirectUri(redirectUriStr).scopes(clientRegistration.getScopes()).state(<span class="string">"login"</span>).attributes(attributes).build();</span><br><span class="line">                <span class="comment">//自定义修改请求</span></span><br><span class="line">                <span class="keyword">return</span> customizeAuthorizationRequest(authorizationRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义请求参数</span></span><br><span class="line">    <span class="keyword">private</span> OAuth2AuthorizationRequest customizeAuthorizationRequest(</span><br><span class="line">            OAuth2AuthorizationRequest req) &#123;</span><br><span class="line">        Map&lt;<span class="keyword">String</span>,<span class="keyword">Object</span>&gt; extraParams = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        System.out.<span class="built_in">println</span>(req.getAdditionalParameters());</span><br><span class="line">        extraParams.putAll(req.getAdditionalParameters());</span><br><span class="line">        <span class="comment">//覆盖state</span></span><br><span class="line">        extraParams.put(<span class="string">"state"</span>, <span class="string">"login"</span>);</span><br><span class="line">        <span class="keyword">return</span> OAuth2AuthorizationRequest</span><br><span class="line">                .from(req)</span><br><span class="line">                .additionalParameters(extraParams)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> resolveRegistrationId(HttpServletRequest request) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.authorizationRequestMatcher.matches(request) ? (<span class="keyword">String</span>)<span class="keyword">this</span>.authorizationRequestMatcher.matcher(request).getVariables().<span class="built_in">get</span>(<span class="string">"registrationId"</span>) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> expandRedirectUri(HttpServletRequest request, ClientRegistration clientRegistration, <span class="keyword">String</span> action) &#123;</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; uriVariables = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">        uriVariables.put(<span class="string">"registrationId"</span>, clientRegistration.getRegistrationId());</span><br><span class="line">        UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(UrlUtils.buildFullRequestUrl(request)).replacePath(request.getContextPath()).replaceQuery((<span class="keyword">String</span>)<span class="keyword">null</span>).fragment((<span class="keyword">String</span>)<span class="keyword">null</span>).build();</span><br><span class="line">        <span class="keyword">String</span> scheme = uriComponents.getScheme();</span><br><span class="line">        uriVariables.put(<span class="string">"baseScheme"</span>, scheme == <span class="keyword">null</span> ? <span class="string">""</span> : scheme);</span><br><span class="line">        <span class="keyword">String</span> host = uriComponents.getHost();</span><br><span class="line">        uriVariables.put(<span class="string">"baseHost"</span>, host == <span class="keyword">null</span> ? <span class="string">""</span> : host);</span><br><span class="line">        <span class="built_in">int</span> port = uriComponents.getPort();</span><br><span class="line">        uriVariables.put(<span class="string">"basePort"</span>, port == <span class="number">-1</span> ? <span class="string">""</span> : <span class="string">":"</span> + port);</span><br><span class="line">        <span class="keyword">String</span> path = uriComponents.getPath();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(path) &amp;&amp; path.charAt(<span class="number">0</span>) != <span class="string">'/'</span>) &#123;</span><br><span class="line">            path = <span class="string">'/'</span> + path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uriVariables.put(<span class="string">"basePath"</span>, path == <span class="keyword">null</span> ? <span class="string">""</span> : path);</span><br><span class="line">        uriVariables.put(<span class="string">"baseUrl"</span>, uriComponents.toUriString());</span><br><span class="line">        uriVariables.put(<span class="string">"action"</span>, action == <span class="keyword">null</span> ? <span class="string">""</span> : action);</span><br><span class="line">        <span class="keyword">return</span> UriComponentsBuilder.fromUriString(clientRegistration.getRedirectUriTemplate()).buildAndExpand(uriVariables).toUriString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> addNonceParameters(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; attributes, Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; additionalParameters) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> nonce = <span class="keyword">this</span>.secureKeyGenerator.generateKey();</span><br><span class="line">            <span class="keyword">String</span> nonceHash = createHash(nonce);</span><br><span class="line">            attributes.put(<span class="string">"nonce"</span>, nonce);</span><br><span class="line">            additionalParameters.put(<span class="string">"nonce"</span>, nonceHash);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var5) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> addPkceParameters(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; attributes, Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; additionalParameters) &#123;</span><br><span class="line">        <span class="keyword">String</span> codeVerifier = <span class="keyword">this</span>.secureKeyGenerator.generateKey();</span><br><span class="line">        attributes.put(<span class="string">"code_verifier"</span>, codeVerifier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> codeChallenge = createHash(codeVerifier);</span><br><span class="line">            additionalParameters.put(<span class="string">"code_challenge"</span>, codeChallenge);</span><br><span class="line">            additionalParameters.put(<span class="string">"code_challenge_method"</span>, <span class="string">"S256"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var5) &#123;</span><br><span class="line">            additionalParameters.put(<span class="string">"code_challenge"</span>, codeVerifier);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> createHash(<span class="keyword">String</span> value) <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">        <span class="built_in">byte</span>[] digest = md.digest(value.getBytes(StandardCharsets.US_ASCII));</span><br><span class="line">        <span class="keyword">return</span> Base64.getUrlEncoder().withoutPadding().encodeToString(digest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在SecurityConfig中配置应用CustomAuthorizationRequestResolver。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.oauth2Login()</span><br><span class="line">                .authorizationEndpoint()</span><br><span class="line">                    .authorizationRequestRepository(authorizationRequestRepository())</span><br><span class="line">                    .authorizationRequestResolver(<span class="keyword">new</span> CustomAuthorizationRequestResolver(</span><br><span class="line">                                clientRegistrationRepository(), <span class="string">"/oauth2/authorization"</span>))</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationRequestRepository&lt;OAuth2AuthorizationRequest&gt; <span class="title">authorizationRequestRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpSessionOAuth2AuthorizationRequestRepository();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//clientRegistrationId集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; clients = Arrays.asList(<span class="string">"cpdemo-client"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CLIENT_PROPERTY_KEY = <span class="string">"spring.security.oauth2.client.registration."</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CLIENT_PROVIDER_KEY = <span class="string">"spring.security.oauth2.client.provider."</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientRegistrationRepository <span class="title">clientRegistrationRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Steam获取clients对应ClientRegistration，筛掉空值</span></span><br><span class="line">        List&lt;ClientRegistration&gt; registrations = clients.stream()</span><br><span class="line">                .map(c -&gt; getRegistration(c))</span><br><span class="line">                .filter(registration -&gt; registration != <span class="keyword">null</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InMemoryClientRegistrationRepository(registrations);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ClientRegistration <span class="title">getRegistration</span><span class="params">(String client)</span> </span>&#123;</span><br><span class="line">        String clientId = env.getProperty(CLIENT_PROPERTY_KEY + client + <span class="string">".client-id"</span>);</span><br><span class="line">        <span class="keyword">if</span> (clientId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String clientSecret = env.getProperty(CLIENT_PROPERTY_KEY + client + <span class="string">".client-secret"</span>);</span><br><span class="line">        <span class="keyword">if</span> (client.equals(<span class="string">"cpdemo-client"</span>)) &#123;</span><br><span class="line">            String provider = <span class="string">"cpdemo"</span>;</span><br><span class="line">            ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(client);</span><br><span class="line">            <span class="keyword">return</span> builder.clientId(clientId)</span><br><span class="line">                    .clientSecret(clientSecret)</span><br><span class="line">                    .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)</span><br><span class="line">                    .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                    .redirectUriTemplate(env.getProperty(CLIENT_PROPERTY_KEY + client + <span class="string">".redirect-uri"</span>))</span><br><span class="line">                    .scope(env.getProperty(CLIENT_PROPERTY_KEY + client + <span class="string">".scope"</span>))</span><br><span class="line">                    .authorizationUri(env.getProperty(CLIENT_PROVIDER_KEY + provider + <span class="string">".authorization-uri"</span>))</span><br><span class="line">                    .tokenUri(env.getProperty(CLIENT_PROVIDER_KEY + provider + <span class="string">".token-uri"</span>))</span><br><span class="line">                    .userInfoUri(env.getProperty(CLIENT_PROVIDER_KEY + provider + <span class="string">".user-info-uri"</span>)).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现之前的问题解决，但发现授权平台提供的token请求和响应格式与标准不同，需要自定义修改。</p><h4 id="1-3-2-自定义Access-Token-Request和Access-Token-Response"><a href="#1-3-2-自定义Access-Token-Request和Access-Token-Response" class="headerlink" title="1.3.2 自定义Access_Token_Request和Access_Token_Response"></a><strong>1.3.2 自定义Access_Token_Request和Access_Token_Response</strong></h4><p>&emsp;&emsp;首先实现CustomRequestEntityConverter，为token请求增加参数client_id和client_secret。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRequestEntityConverter</span> <span class="title">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">Converter</span>&lt;<span class="title">OAuth2AuthorizationCodeGrantRequest</span>, <span class="title">RequestEntity</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> CLIENT_PROPERTY_KEY = <span class="string">"spring.security.oauth2.client.registration.cpdemo-client."</span>;</span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OAuth2AuthorizationCodeGrantRequestEntityConverter defaultConverter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomRequestEntityConverter(Environment env) &#123;</span><br><span class="line">        defaultConverter = <span class="keyword">new</span> <span class="type">OAuth2AuthorizationCodeGrantRequestEntityConverter</span>();</span><br><span class="line">        <span class="built_in">this</span>.env = env;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定以请求参数格式，增加client_id和client_secret</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> RequestEntity&lt;?&gt; convert(OAuth2AuthorizationCodeGrantRequest req) &#123;</span><br><span class="line">        RequestEntity&lt;?&gt; entity = defaultConverter.convert(req);</span><br><span class="line">        MultiValueMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; params = (MultiValueMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;) entity.getBody();</span><br><span class="line">        params.add(<span class="string">"client_id"</span>, env.getProperty(CLIENT_PROPERTY_KEY + <span class="string">"client-id"</span>));</span><br><span class="line">        params.add(<span class="string">"client_secret"</span>, env.getProperty(CLIENT_PROPERTY_KEY + <span class="string">"client-secret"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">RequestEntity</span>&lt;&gt;(params, entity.getHeaders(),</span><br><span class="line">                entity.getMethod(), entity.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后实现CustomTokenResponseConverter，为token响应配置参数格式。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CustomTokenResponseConverter</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">Converter</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;, <span class="title">OAuth2AccessTokenResponse</span>&gt; </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; TOKEN_RESPONSE_PARAMETER_NAMES = Stream.of(</span><br><span class="line">            OAuth2ParameterNames.ACCESS_TOKEN,</span><br><span class="line">            OAuth2ParameterNames.TOKEN_TYPE,</span><br><span class="line">            OAuth2ParameterNames.EXPIRES_IN,</span><br><span class="line">            OAuth2ParameterNames.REFRESH_TOKEN,</span><br><span class="line">            OAuth2ParameterNames.SCOPE).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义OAuth2AccessTokenResponse返回参数格式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public OAuth2AccessTokenResponse convert(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; tokenResponseParameters) &#123;</span><br><span class="line">        <span class="built_in">String</span> accessToken = tokenResponseParameters.<span class="keyword">get</span>(OAuth2ParameterNames.ACCESS_TOKEN);</span><br><span class="line"></span><br><span class="line">        long expiresIn = Long.valueOf(tokenResponseParameters.<span class="keyword">get</span>(OAuth2ParameterNames.EXPIRES_IN));</span><br><span class="line">        OAuth2AccessToken.TokenType accessTokenType = OAuth2AccessToken.TokenType.BEARER;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; scopes = Collections.emptySet();</span><br><span class="line">        <span class="keyword">if</span> (tokenResponseParameters.containsKey(OAuth2ParameterNames.SCOPE)) &#123;</span><br><span class="line">            <span class="built_in">String</span> scope = tokenResponseParameters.<span class="keyword">get</span>(OAuth2ParameterNames.SCOPE);</span><br><span class="line">            scopes = Arrays.stream(StringUtils.delimitedListToStringArray(scope, <span class="string">","</span>))</span><br><span class="line">                    .collect(Collectors.toSet());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> OAuth2AccessTokenResponse.withToken(accessToken)</span><br><span class="line">                .tokenType(accessTokenType)</span><br><span class="line">                .expiresIn(expiresIn)</span><br><span class="line">                .scopes(scopes)</span><br><span class="line"><span class="comment">//                .refreshToken(refreshToken)</span></span><br><span class="line"><span class="comment">//                .additionalParameters(additionalParameters)</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后修改SecurityConfig，增加token端点配置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        http.oauth2Login()</span><br><span class="line">                .authorizationEndpoint()</span><br><span class="line">                    .authorizationRequestRepository(authorizationRequestRepository())</span><br><span class="line">                    .authorizationRequestResolver(<span class="keyword">new</span> <span class="type">CustomAuthorizationRequestResolver</span>(</span><br><span class="line">                                clientRegistrationRepository(), <span class="string">"/oauth2/authorization"</span>))</span><br><span class="line">                    .and()</span><br><span class="line">                .tokenEndpoint()</span><br><span class="line">                    .accessTokenResponseClient(accessTokenResponseClient())</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过自定义OAuth2AccessTokenResponseClient来自定义token请求</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">OAuth2AccessTokenResponseClient</span>&lt;<span class="type">OAuth2AuthorizationCodeGrantRequest</span>&gt; accessTokenResponseClient()&#123;</span><br><span class="line">        <span class="type">DefaultAuthorizationCodeTokenResponseClient</span> accessTokenResponseClient =</span><br><span class="line">                <span class="keyword">new</span> <span class="type">DefaultAuthorizationCodeTokenResponseClient</span>();</span><br><span class="line">        <span class="comment">//自定义req</span></span><br><span class="line">        accessTokenResponseClient.setRequestEntityConverter(<span class="keyword">new</span> <span class="type">CustomRequestEntityConverter</span>(env));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启用OAuth2AccessTokenResponseHttpMessageConverter来转换HTTP消息，获取OAuth2AccessTokenResponse</span></span><br><span class="line">        <span class="type">OAuth2AccessTokenResponseHttpMessageConverter</span> tokenResponseHttpMessageConverter =</span><br><span class="line">                <span class="keyword">new</span> <span class="type">OAuth2AccessTokenResponseHttpMessageConverter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义rep</span></span><br><span class="line">        tokenResponseHttpMessageConverter.setTokenResponseConverter(<span class="keyword">new</span> <span class="type">CustomTokenResponseConverter</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为Rest Http工具配置适用的HttpMessageConverter</span></span><br><span class="line">        <span class="type">RestTemplate</span> restTemplate = <span class="keyword">new</span> <span class="type">RestTemplate</span>(<span class="type">Arrays</span>.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="type">FormHttpMessageConverter</span>(), tokenResponseHttpMessageConverter));</span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> <span class="type">OAuth2ErrorResponseErrorHandler</span>());</span><br><span class="line">        accessTokenResponseClient.setRestOperations(restTemplate);</span><br><span class="line">        <span class="keyword">return</span> accessTokenResponseClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现之前的问题解决，但获取用户信息的响应格式需要自定义。</p><h4 id="1-3-3-自定义User-Info-Response"><a href="#1-3-3-自定义User-Info-Response" class="headerlink" title="1.3.3 自定义User_Info_Response"></a><strong>1.3.3 自定义User_Info_Response</strong></h4><p>&emsp;&emsp;创建CustomOAuth2User，对应user-info响应消息格式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomOAuth2User</span> <span class="title">implements</span> <span class="title">OAuth2User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities =</span><br><span class="line">            AuthorityUtils.createAuthorityList(<span class="string">"ROLE_USER"</span>);</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attributes;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"campus_user_id"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"campus_id"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"tenant_code"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String tenantCode;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"user_name"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"user_type"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"gender"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; getAttributes() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.attributes = new HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"id"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"userId"</span>, <span class="keyword">this</span>.userId);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"tenantCode"</span>, <span class="keyword">this</span>.tenantCode);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"name"</span>, <span class="keyword">this</span>.name);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"type"</span>, <span class="keyword">this</span>.type);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"gender"</span>, <span class="keyword">this</span>.gender);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> attributes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改SecurityConfig，增加customUserType配置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        http.oauth2Login()</span><br><span class="line">                .authorizationEndpoint()</span><br><span class="line">                    .authorizationRequestRepository(authorizationRequestRepository())</span><br><span class="line">                    .authorizationRequestResolver(<span class="keyword">new</span> <span class="type">CustomAuthorizationRequestResolver</span>(</span><br><span class="line">                                clientRegistrationRepository(), <span class="string">"/oauth2/authorization"</span>))</span><br><span class="line">                    .and()</span><br><span class="line">                .tokenEndpoint()</span><br><span class="line">                    .accessTokenResponseClient(accessTokenResponseClient())</span><br><span class="line">                    .and()</span><br><span class="line">                .userInfoEndpoint()</span><br><span class="line">                    .customUserType(<span class="type">CustomOAuth2User</span>.<span class="keyword">class</span>,<span class="string">"cpdemo-client"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现get user info流程报错，如下，user-info的响应编码格式为octet-stream，但默认的转换器不支持。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">no</span> suitable HttpMessageConverter found <span class="keyword">for</span> response<span class="built_in"> type </span>[XXX] <span class="keyword">and</span> content<span class="built_in"> type </span>[application/octet-stream]</span><br></pre></td></tr></table></figure><h4 id="1-3-4-自定义User-Info-Request"><a href="#1-3-4-自定义User-Info-Request" class="headerlink" title="1.3.4 自定义User_Info_Request"></a><strong>1.3.4 自定义User_Info_Request</strong></h4><p>&emsp;&emsp;自定义OAuth2UserService，为RestTemplate配置支持OCTET_STREAM（CustomOAuth2UserRequestEntityConverter此时还为OAuth2UserRequestEntityConverter）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomUserService</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">OAuth2UserService</span></span>&lt;<span class="title">OAuth2UserRequest</span>, <span class="title">OAuth2User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> final Map&lt;<span class="keyword">String</span>, Class&lt;? extends OAuth2User&gt;&gt; customUserTypes;</span><br><span class="line">    <span class="keyword">private</span> Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt; requestEntityConverter = <span class="keyword">new</span> <span class="type">CustomOAuth2UserRequestEntityConverter</span>();</span><br><span class="line">    <span class="keyword">private</span> RestOperations restOperations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomUserService(Map&lt;<span class="keyword">String</span>, Class&lt;? extends OAuth2User&gt;&gt; customUserTypes) &#123;</span><br><span class="line">        Assert.notEmpty(customUserTypes, <span class="string">"customUserTypes cannot be empty"</span>);</span><br><span class="line">        <span class="built_in">this</span>.customUserTypes = Collections.unmodifiableMap(<span class="keyword">new</span> <span class="type">LinkedHashMap</span>(customUserTypes));</span><br><span class="line">        <span class="comment">//打印RestTemplate的Http请求日志</span></span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> <span class="type">RestTemplate</span>(<span class="keyword">new</span> <span class="type">BufferingClientHttpRequestFactory</span>(<span class="keyword">new</span> <span class="type">SimpleClientHttpRequestFactory</span>()));</span><br><span class="line">        List&lt;ClientHttpRequestInterceptor&gt; interceptors = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="type">LoggingRequestInterceptor</span>());</span><br><span class="line">        restTemplate.setInterceptors(interceptors);</span><br><span class="line">        <span class="comment">//解决no suitable HttpMessageConverter found for response type [CustomOAuth2User] and content type [application/octet-stream]</span></span><br><span class="line">        MappingJackson2HttpMessageConverter converter = <span class="keyword">new</span> <span class="type">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        converter.setSupportedMediaTypes(Arrays.asList(<span class="keyword">new</span> <span class="type">MediaType</span>[]&#123;MediaType.APPLICATION_JSON, MediaType.APPLICATION_OCTET_STREAM&#125;));</span><br><span class="line">        restTemplate.setMessageConverters(Arrays.asList(converter, <span class="keyword">new</span> <span class="type">FormHttpMessageConverter</span>()));</span><br><span class="line">        <span class="built_in">this</span>.restOperations = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException &#123;</span><br><span class="line">        Assert.notNull(userRequest, <span class="string">"userRequest cannot be null"</span>);</span><br><span class="line">        <span class="keyword">String</span> registrationId = userRequest.getClientRegistration().getRegistrationId();</span><br><span class="line">        Class customUserType;</span><br><span class="line">        <span class="keyword">if</span> ((customUserType = (Class)<span class="built_in">this</span>.customUserTypes.<span class="keyword">get</span>(registrationId)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//添加参数</span></span><br><span class="line">            System.out.println(<span class="string">"此时access token ："</span> + userRequest.getAccessToken().getTokenValue());</span><br><span class="line">            System.out.println(<span class="string">"此时AdditionalParameters ："</span> + userRequest.getAdditionalParameters().toString());</span><br><span class="line"></span><br><span class="line">            RequestEntity request = (RequestEntity)<span class="built_in">this</span>.requestEntityConverter.convert(userRequest);</span><br><span class="line"></span><br><span class="line">            ResponseEntity response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response = <span class="built_in">this</span>.restOperations.exchange(request, customUserType);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RestClientException var8) &#123;</span><br><span class="line">                OAuth2Error oauth2Error = <span class="keyword">new</span> <span class="type">OAuth2Error</span>(<span class="string">"invalid_user_info_response"</span>, <span class="string">"An error occurred while attempting to retrieve the UserInfo Resource: "</span> + var8.getMessage(), (<span class="keyword">String</span>)<span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OAuth2AuthenticationException</span>(oauth2Error, oauth2Error.toString(), var8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            OAuth2User oauth2User = (OAuth2User)response.getBody();</span><br><span class="line">            <span class="keyword">return</span> oauth2User;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> final void setRequestEntityConverter(Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt; requestEntityConverter) &#123;</span><br><span class="line">        Assert.notNull(requestEntityConverter, <span class="string">"requestEntityConverter cannot be null"</span>);</span><br><span class="line">        <span class="built_in">this</span>.requestEntityConverter = requestEntityConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> final void setRestOperations(RestOperations restOperations) &#123;</span><br><span class="line">        Assert.notNull(restOperations, <span class="string">"restOperations cannot be null"</span>);</span><br><span class="line">        <span class="built_in">this</span>.restOperations = restOperations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过实现ClientHttpRequestInterceptor接口来对RestTemplate打印日志。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class LoggingRequestInterceptor implements ClientHttpRequestInterceptor &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Logger <span class="built_in">log</span> = LoggerFactory.getLogger(LoggingRequestInterceptor.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse intercept(HttpRequest httpRequest, <span class="built_in">byte</span>[] bytes, ClientHttpRequestExecution clientHttpRequestExecution)<span class="keyword">throws</span> UnsupportedEncodingException,IOException &#123;</span><br><span class="line">        traceRequest(httpRequest,bytes);</span><br><span class="line">        ClientHttpResponse response = clientHttpRequestExecution.execute(httpRequest,bytes);</span><br><span class="line">        traceResponse(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> traceRequest(HttpRequest httpRequest, <span class="built_in">byte</span>[] bytes)<span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=============================request begin=============================="</span>);</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"URI            : &#123;&#125;"</span>,httpRequest.getURI());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Method         : &#123;&#125;"</span>,httpRequest.getMethod());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Headers        : &#123;&#125;"</span>,httpRequest.getHeaders());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Body           : &#123;&#125;"</span>,<span class="keyword">new</span> <span class="keyword">String</span>(bytes,<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=============================request end=============================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> traceResponse(ClientHttpResponse response)<span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        StringBuilder inputStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">BufferedReader</span> reader = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(response.getBody(),<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">line</span> = reader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">line</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inputStringBuilder.<span class="built_in">append</span>(<span class="built_in">line</span>);</span><br><span class="line">            inputStringBuilder.<span class="built_in">append</span>(<span class="string">'\n'</span>);</span><br><span class="line">            <span class="built_in">line</span> = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=============================response begin=============================="</span>);</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"StatusCode     : &#123;&#125;"</span>,response.getStatusCode());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"StatusText     : &#123;&#125;"</span>,response.getStatusText());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Headers        : &#123;&#125;"</span>,response.getHeaders());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Body           : &#123;&#125;"</span>,inputStringBuilder.toString());</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=============================response end=============================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改SecurityConfig，增加userService配置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/"</span>,<span class="string">"/home"</span>, <span class="string">"/login**"</span>,<span class="string">"/callback/"</span>, <span class="string">"/webjars/**"</span>, <span class="string">"/error**"</span>, <span class="string">"/oauth2/authorization/**"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">String</span>,<span class="type">Class</span>&lt;? <span class="keyword">extends</span> <span class="type">OAuth2User</span>&gt;&gt; customUserTypes = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        customUserTypes.put(<span class="string">"cpdemo-client"</span>,<span class="type">CustomOAuth2User</span>.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">        http.oauth2Login()</span><br><span class="line">                .authorizationEndpoint()</span><br><span class="line">                    .authorizationRequestRepository(authorizationRequestRepository())</span><br><span class="line">                    .authorizationRequestResolver(<span class="keyword">new</span> <span class="type">CustomAuthorizationRequestResolver</span>(</span><br><span class="line">                                clientRegistrationRepository(), <span class="string">"/oauth2/authorization"</span>))</span><br><span class="line">                    .and()</span><br><span class="line">                .tokenEndpoint()</span><br><span class="line">                    .accessTokenResponseClient(accessTokenResponseClient())</span><br><span class="line">                    .and()</span><br><span class="line">                .userInfoEndpoint()</span><br><span class="line">                    .userService(<span class="keyword">new</span> <span class="type">CustomUserService</span>(customUserTypes))</span><br><span class="line">                    .customUserType(<span class="type">CustomOAuth2User</span>.<span class="keyword">class</span>,<span class="string">"cpdemo-client"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">AuthorizationRequestRepository</span>&lt;<span class="type">OAuth2AuthorizationRequest</span>&gt; authorizationRequestRepository() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">HttpSessionOAuth2AuthorizationRequestRepository</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现提示请求Token时未提供所需参数，根据接口文档发现授权服务器要求把授权令牌写入Get_Parm，查看源码可以发现默认Converter会根据请求类别把授权令牌放入HEADER或FORM_PARM。</p><p>&emsp;&emsp;自定义转换器CustomOAuth2UserRequestEntityConverter，强行将access_token拼入URL。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomOAuth2UserRequestEntityConverter</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Converter</span></span>&lt;<span class="title">OAuth2UserRequest</span>, <span class="title">RequestEntity</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final MediaType DEFAULT_CONTENT_TYPE = MediaType.valueOf(<span class="string">"application/x-www-form-urlencoded;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomOAuth2UserRequestEntityConverter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> RequestEntity&lt;?&gt; convert(OAuth2UserRequest userRequest) &#123;</span><br><span class="line">        ClientRegistration clientRegistration = userRequest.getClientRegistration();</span><br><span class="line">        HttpMethod httpMethod = HttpMethod.GET;</span><br><span class="line">        <span class="keyword">if</span> (AuthenticationMethod.FORM.equals(clientRegistration.getProviderDetails().getUserInfoEndpoint().getAuthenticationMethod())) &#123;</span><br><span class="line">            httpMethod = HttpMethod.POST;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> <span class="type">HttpHeaders</span>();</span><br><span class="line">        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));</span><br><span class="line"><span class="comment">//        URI uri = UriComponentsBuilder.fromUriString(clientRegistration.getProviderDetails().getUserInfoEndpoint().getUri()).build().toUri();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//强行拼接</span></span><br><span class="line">        URI uri = UriComponentsBuilder.fromUriString(clientRegistration.getProviderDetails().getUserInfoEndpoint().getUri()</span><br><span class="line">                + <span class="string">"?access_token="</span> + userRequest.getAccessToken().getTokenValue()).build().toUri();</span><br><span class="line"></span><br><span class="line">        RequestEntity request;</span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.POST.equals(httpMethod)) &#123;</span><br><span class="line">            headers.setContentType(DEFAULT_CONTENT_TYPE);</span><br><span class="line">            MultiValueMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; formParameters = <span class="keyword">new</span> <span class="type">LinkedMultiValueMap</span>();</span><br><span class="line">            formParameters.add(<span class="string">"access_token"</span>, userRequest.getAccessToken().getTokenValue());</span><br><span class="line">            request = <span class="keyword">new</span> <span class="type">RequestEntity</span>(formParameters, headers, httpMethod, uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            headers.setBearerAuth(userRequest.getAccessToken().getTokenValue());</span><br><span class="line">            request = <span class="keyword">new</span> <span class="type">RequestEntity</span>(headers, httpMethod, uri);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现问题解决，流程跑通。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide" title="Title" target="_blank" rel="noopener">OAuth-2.0-Migration-Guide</a></p></blockquote><blockquote><p><a href="https://projects.spring.io/spring-security-oauth/docs/Home.html" title="Title" target="_blank" rel="noopener">spring-security-oauth</a></p></blockquote><blockquote><p><a href="https://mrbird.cc/Spring-Security-OAuth2-Guide.html" title="Title" target="_blank" rel="noopener">Spring Security OAuth2入门</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/cb886f995e86?utm_source=oschina-app" title="Title" target="_blank" rel="noopener">深入理解Spring Cloud Security OAuth2及JWT</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/74267287" title="Title" target="_blank" rel="noopener">OAuth2实现单点登录SSO</a></p></blockquote><blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/webclient.html" title="Title" target="_blank" rel="noopener">Spring文档-26. WebClient</a></p></blockquote><blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/oauth2login-advanced.html#oauth2login-advanced-userinfo-endpoint" title="Title" target="_blank" rel="noopener">Spring文档-31.OAuth 2.0 Login</a></p></blockquote><blockquote><p><a href="https://www.ziyueknow.com/page/spring-security/part06-3.html#oauth2login-advanced-userinfo-endpoint" title="Title" target="_blank" rel="noopener">Spring文档中文翻译</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/cjsblog/p/9241217.html" title="Title" target="_blank" rel="noopener">Spring Boot OAuth 2.0 客户端</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/spring-webclient-oauth2" title="Title" target="_blank" rel="noopener">baeldung：Spring WebClient and OAuth2 Support</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/spring-security-custom-oauth-requests" title="Title" target="_blank" rel="noopener">baeldung：Customizing Authorization and Token Requests with Spring Security 5.1 Client</a></p></blockquote><blockquote><p><a href="https://github.com/eugenp/tutorials/tree/master/spring-5-security-oauth" title="Title" target="_blank" rel="noopener">github：spring-5-security-oauth</a></p></blockquote><blockquote><p><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">github：spring-security-oauth-5-2-migrate</a></p></blockquote><blockquote><p><a href="https://objectpartners.com/2018/03/01/log-your-resttemplate-request-and-response-without-destroying-the-body/" title="Title" target="_blank" rel="noopener">Log your RestTemplate Request and Response without destroying the body</a></p></blockquote><blockquote><p><a href="https://dzone.com/articles/spring-boot-how-to-solve-oauth2-err-too-many-redir" title="Title" target="_blank" rel="noopener">Spring Boot: Solving OAuth2 ERR_TOO_MANY_REDIRECTS [Snippet]</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/57761917/spring-5-security-oauth2-login-redirect-loop" title="Title" target="_blank" rel="noopener">stackoverflow：Spring 5 Security OAuth2 Login Redirect Loop</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/49315552/authorizationgranttype-cannot-be-null-in-spring-security-5-oauth-client-and-spri" title="Title" target="_blank" rel="noopener">stackoverflow：authorizationGrantType cannot be null in Spring Security 5 OAuth Client and Spring Boot 2.0</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/49062866/spring-boot-resttemplate-response-body-is-null-while-interceptor-clearly-shows-b" title="Title" target="_blank" rel="noopener">stackoverflow：Spring-boot Resttemplate response.body is null while interceptor clearly shows body</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/50908023/using-spring-security-oauth-using-a-custom-oauth-provider-i-get-authorization" title="Title" target="_blank" rel="noopener">stackoverflow：Using Spring security oauth, using a custom OAuth provider, I get [authorization_request_not_found], should I handle the callback method myself?</a><br>y-shows-b “Title”)</p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/7952154/spring-resttemplate-how-to-enable-full-debugging-logging-of-requests-responses" title="Title" target="_blank" rel="noopener">stackoverflow：Spring RestTemplate - how to enable full debugging/logging of requests/responses?</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Security OAuth2实战练习，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring boot" scheme="http://linyishui.top/tags/spring-boot/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="oauth2" scheme="http://linyishui.top/tags/oauth2/"/>
    
      <category term="spring security" scheme="http://linyishui.top/tags/spring-security/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2协议框架</title>
    <link href="http://linyishui.top/2019111601.html"/>
    <id>http://linyishui.top/2019111601.html</id>
    <published>2019-11-16T10:30:59.000Z</published>
    <updated>2019-12-25T06:30:59.939Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a><strong>OAuth2</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;随着分布式Web服务和云计算的流行，一些第三方应用常常要访问一些服务器托管资源。这些资源通常都是受保护的，需要请求者携带资源拥有者允许的私有证书进行身份验证。</p><p>&emsp;&emsp;在传统的基于客户端-服务器的身份验证模型中，客户端为了访问服务器的受保护资源，通过私有证书来做身份验证。而现在这个私有证书往往要同时提供给第三方，这就带来了很多的问题，也存在着很多的局限性。</p><blockquote><p><strong>传统身份验证模型的问题：</strong></p><ul><li>第三方应用需要用明文保存私有证书，以便持续的使用，这种对称的密码验证方式会带来安全隐患。</li><li>第三方应用对受保护资源获得了过多的使用权限，但资源拥有者却没办法来限制到具体的资源子集，比如限制权限的时间，或是限制支持的访问方式等。</li><li>资源拥有者无法在不影响第三方应用的前提下撤销某个第三方的访问权限，只能通过修改密码的方法来回收权限。</li></ul></blockquote><p>&emsp;&emsp;OAuth通过将客户端和资源拥有者的<strong>角色分离</strong>来解决这些问题，在OAuth中，客户端提出请求访问由资源拥有者控制，并由资源服务器托管的资源，然后会得到与资源拥有者不同的一套私有证书。客户端不会像以前那样直接使用资源拥有者的证书来访问，而是得到了一个<strong>访问令牌</strong>（access token）：一个代表着某一特定作用域、持续时间和其它属性的字符串。</p><p>&emsp;&emsp;访问令牌由<strong>授权服务器</strong>在资源拥有者的授意下分发给第三方客户端，客户端携带访问令牌访问由<strong>资源服务器</strong>托管的受保护资源。</p><h3 id="1-1-符号规范"><a href="#1-1-符号规范" class="headerlink" title="1.1 符号规范"></a><strong>1.1 符号规范</strong></h3><p>&emsp;&emsp;这篇文档中的关键词“必须”、“一定不能”、“要求”、“会”、“不会”、“应该”、“不应该”、“建议”、“可以”、“可选的”，遵从<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC2119" title="Title" target="_blank" rel="noopener">[RFC2119]</a>中的解释。</p><p>&emsp;&emsp;这篇文档使用出自<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#I-D.ietf-httpbis-p1-messaging" title="Title" target="_blank" rel="noopener">[I-D.ietf-httpbis-p1-messaging]</a>的增强型巴科斯范式（ABNF）标记法。另外，介绍一些规则定义的出处：URI-Reference出自<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC3986" title="Title" target="_blank" rel="noopener">[RFC3986]</a>；OWS、RWS和quoted-string出自<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#I-D.ietf-httpbis-p1-messaging" title="Title" target="_blank" rel="noopener">[I-D.ietf-httpbis-p1-messaging]</a>。</p><p>&emsp;&emsp;除非特别提到，否则所有协议参数的名字和值都是大小写敏感的。</p><h3 id="1-2-技术术语"><a href="#1-2-技术术语" class="headerlink" title="1.2 技术术语"></a><strong>1.2 技术术语</strong></h3><blockquote><ul><li>受保护资源（protected resource）：能够使用OAuth请求获取的访问限制性资源。</li><li>资源服务器（resource server）：能够接受和响应受保护资源请求的服务器。</li><li>客户端（client）：获取授权和发送受保护资源请求的应用。</li><li>资源拥有者（resource owner）：能够对受保护资源进行访问许可控制的实体。</li><li>终端用户（end-user）：起到资源拥有者角色的用户。</li><li>令牌（token）：分发给客户端的代表访问授权的字符串。通常这个字符串对客户端来说是不透明的。令牌代表资源拥有者许可的访问作用域和持续时间，并由资源服务器和授权服务器强制保证。这个令牌可以代表一个标识符，用于检索授权信息，或以一种可验证的方式自包含授权信息（即一个包含数据和签名的令牌字符串）。令牌可能只代表纯粹的访问能力。而为了让客户端使用令牌，也可能需要一些多余的特定验证证书。</li><li>访问令牌（access token）：被客户端用来代表资源拥有者发送验证请求的令牌。</li><li>刷新令牌（refresh token）：被客户端用来获取新的访问令牌的令牌，而不用资源拥有者的参与。</li><li>授权码（authorization code）：一个短期令牌，代表终端用户的授权。授权码用于获取一个访问令牌和一个刷新令牌。</li><li>访问许可（access grant）：用于描述中间形式的私有证书（如终端用户的密码或授权码）的一个通用词汇，代表资源拥有者的授权。客户端使用访问许可来获取访问令牌。通过将各种形式的访问许可都交换成访问令牌，资源服务器只需要支持一种验证机制。</li><li>授权服务器（authorization server）：能够成功验证资源拥有者和获取授权，并在此之后分发令牌的服务器。授权服务器可以和资源服务器是同一个服务器，也可以是不同的实体。单独一个授权服务器可以为多个资源服务器分发令牌。</li><li>终端用户授权端点（end-user authorization endpoint）：授权服务器上能够验证终端用户并获取授权的HTTP endpoint。终端用户授权endpoint在第4节详细描述。</li><li>令牌端点（token endpoint）：授权服务器上能够分发令牌和刷新过期令牌的HTTP endpoint。令牌endpoint在第5节详细描述。</li><li>客户端标识符（client identifier）：分发给客户端的唯一标识，用于客户端向授权服务器标识自己。客户端标识符可以有一个对应的密钥。客户端标识符在第3节详细描述。</li></ul></blockquote><h3 id="1-3-概述"><a href="#1-3-概述" class="headerlink" title="1.3 概述"></a><strong>1.3 概述</strong></h3><p>&emsp;&emsp;OAuth为客户端提供了一种代表资源拥有者访问受保护资源的方法。在客户端访问受保护资源之前，它必须先从资源拥有者获取授权 （访问许可，access grant），然后用访问许可交换访问令牌（access token，代表许可的作用域、持续时间和其它属性）。客户端通过向资源服务器出示访问令牌来访问受保护资源。</p><p>&emsp;&emsp;访问令牌提供了一个抽象层，将不同的授权结构（如用户名密码、断言）替换成资源服务器可以理解的单一令牌。这种抽象使得分发短期有效的访问令牌成为可能，也使得资源服务器不必理解多种多样的授权机制。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|  <span class="built_in"> Resource </span>   |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(B)----- Access Grant -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |           Access Grant &amp;      +---------------+</span><br><span class="line">|        |--(C)---<span class="built_in"> Client </span>Credentials --&gt;| Authorization |</span><br><span class="line">|<span class="built_in"> Client </span>|                               |    <span class="built_in"> Server </span>   |</span><br><span class="line">|        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(E)----- Access Token ------&gt;|   <span class="built_in"> Resource </span>  |</span><br><span class="line">|        |                               |    <span class="built_in"> Server </span>   |</span><br><span class="line">|        |&lt;-(F)--- Protected<span class="built_in"> Resource </span>---|               |</span><br><span class="line">+--------+                               +---------------+</span><br><span class="line">图1: 抽象的协议流程</span><br></pre></td></tr></table></figure><blockquote><p>图1所示的抽象流程协议的总体架构，它包含下列步骤：</p><p>&emsp;(A) 客户端从资源拥有者那里请求授权。授权请求能够直接发送给资源拥有者，或者间接地通过授权服务器这样的中介，而后者更为可取。</p><p>&emsp;(B) 客户端收到一个访问许可，它代表由资源服务器提供的授权。</p><p>&emsp;(C) 客户端使用它自己的私有证书到授权服务器上验证，并出示访问许可，来请求一个访问令牌。</p><p>&emsp;(D) 授权服务器验证客户端私有证书和访问许可的有效性，如果验证通过则分发一个访问令牌。</p><p>&emsp;(E) 客户端通过出示访问令牌向资源服务器请求受保护资源。</p><p>&emsp;(F) 资源服务器验证访问令牌的有效性，如果验证通过则响应这个资源请求。</p></blockquote><h3 id="1-4-访问许可-Access-Grants"><a href="#1-4-访问许可-Access-Grants" class="headerlink" title="1.4 访问许可 Access Grants"></a><strong>1.4 访问许可 Access Grants</strong></h3><p>&emsp;&emsp;访问许可代表资源拥有者提供的授权。访问许可的类型取决于客户端使用的获取方式和授权服务器所支持的方式。</p><h4 id="1-4-1-授权码-Authorization-Code"><a href="#1-4-1-授权码-Authorization-Code" class="headerlink" title="1.4.1 授权码 Authorization Code"></a><strong>1.4.1 授权码 Authorization Code</strong></h4><p>&emsp;&emsp;授权码是通过将终端用户引导到授权服务器而获得的一种访问许可。授权服务器验证终端用户，获得授权，然后向客户端分发一个授权码。因为终端用户只在授权服务器上进行验证，所以终端用户的密码从来不用分享给客户端。</p><p>&emsp;&emsp;当客户端通过一个user-agent同终端用户进行交互的时候，授权码这种访问许可是很合适的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|          |</span><br><span class="line">| End-User |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">     ^</span><br><span class="line">     |</span><br><span class="line">    (B)</span><br><span class="line">+----|-----+       <span class="built_in"> Client </span>Identifier     +---------------+</span><br><span class="line">|         -+--(A)--- &amp; Redirect URI -----&gt;|               |</span><br><span class="line">|  User-   |                              | Authorization |</span><br><span class="line">|  Agent  -|--(B)--<span class="built_in"> User </span>authenticates --&gt;|    <span class="built_in"> Server </span>   |</span><br><span class="line">|          |                              |               |</span><br><span class="line">|         -+--(C)-- Authorization Code --&lt;|               |</span><br><span class="line">+-|----|---+                              +---------------+</span><br><span class="line"> (A)  (C)</span><br><span class="line">  |    |</span><br><span class="line">  ^    v</span><br><span class="line">+---------+</span><br><span class="line">|         |</span><br><span class="line">| <span class="built_in"> Client </span>|</span><br><span class="line">|         |</span><br><span class="line">+---------+</span><br><span class="line">图2: 获取授权码</span><br></pre></td></tr></table></figure><blockquote><p>图2所示的授权码获取流程包含下列步骤：</p><p>&emsp;(A) 客户端通过将终端用户的user-agent引导到授权服务器的终端用户授权端点来发起这个流程。客户端传入标识符、请求作用域、本地状态，和一个重定向URI（在访问被许可或被拒绝后授权服务器会重新将user-agent引导回这个URI）。</p><p>&emsp;(B) 授权服务器验证终端用户的身份（通过user-agent），并且确定终端用户是许可还是拒绝了客户端的访问请求。</p><p>&emsp;(C) 如果访问被许可，授权服务器会使用重定向URI将user-agent引导回客户端。授权服务器传回一个授权码给客户端，用于进一步获取访问令牌。</p></blockquote><p>&emsp;&emsp;一旦客户端获得了授权码，它会到授权服务器上去做验证（使用客户端私有证书）并出示授权码（访问许可），以借此请求一个访问令牌。</p><p>&emsp;&emsp;在客户端无法维护它自己的私有证书的情况下（如原生程序或用某种user-agent脚本实现的程序），授权服务器在(C)步直接给客户端分发一个访问令牌，而不再分发一个授权码。</p><p>&emsp;&emsp;获得授权码的过程在第4节详述。</p><h4 id="1-4-2-资源拥有者密码证书-Resource-Owner-Password-Credentials"><a href="#1-4-2-资源拥有者密码证书-Resource-Owner-Password-Credentials" class="headerlink" title="1.4.2 资源拥有者密码证书 Resource Owner Password Credentials"></a><strong>1.4.2 资源拥有者密码证书 Resource Owner Password Credentials</strong></h4><p>&emsp;&emsp;资源拥有者密码证书（例如用户名和密码）可以直接用作访问许可来获取访问令牌。这种私有证书只应该在以下两种情况下使用：当在资源拥有者和客户端之间有很强的信任关系的时候（例如，资源拥有者的计算机操作系统，或具有很高特权的程序），以及当其它访问许可类型（如授权码）不可用的时候。</p><p>&emsp;&emsp;即使这种许可类型需要客户端直接访问资源拥有者的私有证书，资源拥有者的私有证书也只是在一个请求中使用，并交换成访问令牌。与<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC2617" title="Title" target="_blank" rel="noopener">[RFC2617]</a>定义的HTTP Basic验证机制不同，这种许可类型不再需要客户端存储资源拥有者的私有证书以备日后使用。</p><p>&emsp;&emsp;在图3中，客户端直接从资源拥有者请求授权。当资源拥有者是一个终端用户时，客户端通常的做法是提示终端用户输入用户名和密码。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +----------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|<span class="built_in"> Resource </span>|</span><br><span class="line">|<span class="built_in"> Client </span>|                               |   Owner  |</span><br><span class="line">|        |&lt;-(B)-- Username &amp; Password ---|          |</span><br><span class="line">+--------+                               +----------+</span><br><span class="line">图3: 获取资源拥有者密码证书</span><br></pre></td></tr></table></figure><h4 id="1-4-3-客户端私有证书-Client-Credentials"><a href="#1-4-3-客户端私有证书-Client-Credentials" class="headerlink" title="1.4.3 客户端私有证书 Client Credentials"></a><strong>1.4.3 客户端私有证书 Client Credentials</strong></h4><p>&emsp;&emsp;当授权作用域限制在客户端所控制的受保护资源或之前与授权服务器约定好的受保护资源时，客户端本身的私有证书可被用作访问许可。客户端私有证书用作访问许可的典型例子是，当客户端代表它自己执行操作时（客户端同时也是资源拥有者）。</p><h4 id="1-4-4-刷新令牌-Refresh-Token"><a href="#1-4-4-刷新令牌-Refresh-Token" class="headerlink" title="1.4.4 刷新令牌 Refresh Token"></a><strong>1.4.4 刷新令牌 Refresh Token</strong></h4><p>&emsp;&emsp;访问令牌的生命周期通常比资源拥有者授予的要短一些。当分发一个访问令牌时，授权服务器可以同时传回一个刷新令牌，在当前访问令牌超时后，客户端可以用这个刷新令牌重新获取一个访问令牌。当请求新的访问令牌时，刷新令牌担当起访问许可的角色。使用刷新令牌，不再需要再次与资源拥有者交互，也不需要存储原始的访问许可来获得访问令牌和刷新令牌。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  +--------+          Access Grant &amp;      +---------------+</span><br><span class="line">  |        |--(A)--<span class="built_in"> Client </span>Credentials --&gt;| Authorization |</span><br><span class="line">  |        |                              |    <span class="built_in"> Server </span>   |</span><br><span class="line">  |        |&lt;-(B)---- Access Token -------|               |</span><br><span class="line">  |        |         &amp; Refresh Token      +---------------+</span><br><span class="line">  |        |</span><br><span class="line">  |        |                              +---------------+</span><br><span class="line">  |        |--(C)----- Access Token -----&gt;|               |</span><br><span class="line">  |        |                              |               |</span><br><span class="line">  |        |&lt;-(D)-- Protected<span class="built_in"> Resource </span>---|   <span class="built_in"> Resource </span>  |</span><br><span class="line">  |<span class="built_in"> Client </span>|                              |    <span class="built_in"> Server </span>   |</span><br><span class="line">  |        |--(E)----- Access Token -----&gt;|               |</span><br><span class="line">  |        |                              |               |</span><br><span class="line">  |        |&lt;-(F)-- Invalid Token <span class="builtin-name">Error</span> --|               |</span><br><span class="line">  |        |                              +---------------+</span><br><span class="line">  |        |</span><br><span class="line">  |        |          Refresh Token &amp;     +---------------+</span><br><span class="line">  |        |--(G)--<span class="built_in"> Client </span>Credentials --&gt;| Authorization |</span><br><span class="line">  |        |                              |    <span class="built_in"> Server </span>   |</span><br><span class="line">  |        |&lt;-(H)----- Access Token ------|               |</span><br><span class="line">  +--------+     &amp; Optional Refresh Token +---------------+</span><br><span class="line"></span><br><span class="line">图4: 刷新访问令牌</span><br></pre></td></tr></table></figure><blockquote><p>图4所示的刷新令牌流程包含下列步骤：</p><p>&emsp;(A) 客户端通过使用它自己的私有证书在授权服务器上验证，并出示一个访问许可。</p><p>&emsp;(B) 授权服务器验证客户端私有证书和访问许可的有效性，如果通过则分发一个访问令牌和刷新令牌。</p><p>&emsp;(C) 客户端通过出示访问令牌向资源服务器请求受保护资源。</p><p>&emsp;(D) 资源服务器验证访问令牌的有效性，如果通过，则相应这个请求。</p><p>&emsp;(E) 步骤(C)(D)不停重复，直到访问令牌过期。如果客户端不知道访问令牌过期，它会再请求一次受保护资源。否则，跳到步骤(G)。</p><p>&emsp;(F) 因为访问令牌是无效的（过期了），资源服务器返回一个无效令牌错误。</p><p>&emsp;(G) 客户端通过使用它的私有证书在授权服务器上验证并出示刷新令牌（用作访问许可），来请求一个新的访问令牌。</p><p>&emsp;(H) 授权服务器验证客户端私有证书的有效性，如果通过则分发一个新的访问令牌（也可能还有一个刷新令牌）。</p></blockquote><h4 id="1-4-5-断言-Assertion"><a href="#1-4-5-断言-Assertion" class="headerlink" title="1.4.5 断言 Assertion"></a><strong>1.4.5 断言 Assertion</strong></h4><p>&emsp;&emsp;断言在OAuth和其它信任框架之间架起一座桥梁。它们允许客户端利用现成的信任关系来获取访问令牌。一个断言所代表的访问许可取决于断言类型、断言内容，以及断言被分发的方式，而这些内容不在本规范的规定范围之内。</p><p>&emsp;&emsp;断言可以用在协议扩展模型的部分，它为授权服务器提供了一种支持其它访问许可类型的方式。</p><hr><h2 id="第二节-Client-Profiles"><a href="#第二节-Client-Profiles" class="headerlink" title="第二节 Client Profiles"></a><strong>第二节 Client Profiles</strong></h2><h3 id="2-1-服务端-Web-Server"><a href="#2-1-服务端-Web-Server" class="headerlink" title="2.1 服务端 Web Server"></a><strong>2.1 服务端 Web Server</strong></h3><p>&emsp;&emsp;服务端概要(Web Server profile) 适用于有能力与终端用户的user-agent（通常是浏览器）交互并能够从授权服务器接收（通过重定向）请求（即有能力担当HTTP服务器的角色）的客户端。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  +----------+          Client Identifier      +---------------+</span><br><span class="line">  |<span class="string">         -+----(A)--- &amp; Redirect URI ------&gt;</span>|<span class="string">               </span>|</span><br><span class="line">  |<span class="string"> End-user </span>|<span class="string">                                 </span>|<span class="string"> Authorization </span>|</span><br><span class="line">  |<span class="string">    at    </span>|<span class="string">&lt;---(B)-- User authenticates ---&gt;</span>|<span class="string">     Server    </span>|</span><br><span class="line">  |<span class="string"> Browser  </span>|<span class="string">                                 </span>|<span class="string">               </span>|</span><br><span class="line">  |<span class="string">         -+----(C)-- Authorization Code ---&lt;</span>|<span class="string">               </span>|</span><br><span class="line">  +-|<span class="string">----</span>|<span class="string">---+                                 +---------------+</span></span><br><span class="line"><span class="string">    </span>|<span class="string">    </span>|<span class="string">                                         ^      v</span></span><br><span class="line"><span class="string">   (A)  (C)                                        </span>|<span class="string">      </span>|</span><br><span class="line">    |<span class="string">    </span>|<span class="string">                                         </span>|<span class="string">      </span>|</span><br><span class="line">    ^    v                                         |<span class="string">      </span>|</span><br><span class="line">  +---------+                                      |<span class="string">      </span>|</span><br><span class="line">  |<span class="string">         </span>|<span class="string">&gt;---(D)-- Client Credentials, --------'      </span>|</span><br><span class="line">  |<span class="string">  Server </span>|<span class="string">          Authorization Code,                </span>|</span><br><span class="line">  |<span class="string">  -Based </span>|<span class="string">            &amp; Redirect URI                   </span>|</span><br><span class="line">  |<span class="string">  Client </span>|<span class="string">                                             </span>|</span><br><span class="line">  |<span class="string">         </span>|<span class="string">&lt;---(E)----- Access Token -------------------'</span></span><br><span class="line"><span class="string">  +---------+       (w/ Optional Refresh Token)</span></span><br><span class="line"><span class="string">图5: Web Server流程</span></span><br></pre></td></tr></table></figure><blockquote><p>图5所示的web server流程包含下列步骤：</p><p>&emsp;(A) 如第4节所述，web客户端通过将终端用户的user-agent重定向到授权服务器来发起这个流程。客户端传入它的客户端标识符、请求作用域、本地状态和一个重定向URI，在访问被许可（或被拒绝）后授权服务器会重新将终端用户引导回这个URI。</p><p>&emsp;(B) 授权服务器验证终端用户（借助于user-agent），并确定终端用户是否许可客户端的访问请求。</p><p>&emsp;(C) 假定终端用户许可了这次访问，授权服务器会将user-agent重定向到之前提供的重定向URI上去。授权服务器为客户端传回一个授权码做获取访问令牌之用。</p><p>&emsp;(D) 如第5节所述，客户端通过验证并传入上一步取得的授权码从授权服务器请求一个访问令牌。</p><p>&emsp;(E) 授权服务器验证客户端私有证书和授权码的有效性并返回访问令牌。</p></blockquote><h3 id="2-2-用户代理-User-Agent"><a href="#2-2-用户代理-User-Agent" class="headerlink" title="2.2 用户代理 User-Agent"></a><strong>2.2 用户代理 User-Agent</strong></h3><p>&emsp;&emsp;User-Agent子态适用于常驻user-agent的客户端应用，典型的例子是用诸如JavaScript语言编写并运行在浏览器的程序。这些客户端不能保存客户端私有证书，并且客户端的验证基于user-agent的同源策略。</p><p>&emsp;&emsp;在其它子态中，客户端对于终端用户的授权和访问令牌使用分开的不同请求来完成，而与之不同的是，在user-agent子态中，客户端以HTTP重定向的方式在终端用户授权请求的结果中获取到访问令牌。客户端请求授权服务器将user-agent重定向到另一个web服务器或user-agent能访问到的本地资源，而且user-agent有能力从响应信息中提取出访问令牌并传给客户端。</p><p>&emsp;&emsp;这种user-agent子态并不使用客户端密钥，因为客户端执行程序常驻于终端用户的计算机或设备上，这使得客户端密钥可以被访问或收集到。因为访问令牌被编码到重定向URI中，所以它可能会暴露给终端用户和常驻计算机或设备上的其它应用。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">         +----------+         <span class="built_in"> Client </span>Identifier     +----------------+</span><br><span class="line">         |          |&gt;---(A)-- &amp; Redirection URI ---&gt;|                |</span><br><span class="line">         |          |                                |                |</span><br><span class="line">  End &lt;--+  -  -  - +----(B)--<span class="built_in"> User </span>authenticates --&gt;|  Authorization |</span><br><span class="line"> <span class="built_in"> User </span>  |          |                                |    <span class="built_in"> Server </span>    |</span><br><span class="line">         |          |&lt;---(C)--- Redirect URI -------&lt;|                |</span><br><span class="line">         | <span class="built_in"> Client </span> |         with Access Token      |                |</span><br><span class="line">         |    <span class="keyword">in</span>    |            <span class="keyword">in</span> Fragment         +----------------+</span><br><span class="line">         |  Browser |</span><br><span class="line">         |          |                                +----------------+</span><br><span class="line">         |          |&gt;---(D)--- Redirect URI -------&gt;|                |</span><br><span class="line">         |          |         without Fragment       |   Web<span class="built_in"> Server </span>  |</span><br><span class="line">         |          |                                |   with<span class="built_in"> Client </span> |</span><br><span class="line">         |    (F)   |&lt;---(E)--- Web<span class="built_in"> Page </span>with ------&lt;|   <span class="built_in"> Resource </span>   |</span><br><span class="line">         |  Access  |             <span class="built_in"> Script </span>           |                |</span><br><span class="line">         |   Token  |                                +----------------+</span><br><span class="line">         +----------+</span><br><span class="line">图6: User-Agent流程</span><br></pre></td></tr></table></figure><blockquote><p>图6所示的user-agent流程包含下列步骤：</p><p>&emsp;(A) 如第5节所述，客户端将user-agent引导到终端用户授权endpoint。客户端传入它的客户端标识符、请求作用域、本地状态和一个重定向URI，在访问被许可（或被拒绝）后授权服务器会重新将终端用户引导回这个URI。</p><p>&emsp;(B) 授权服务器验证终端用户（通过user-agent）并确认终端用户是许可还是拒绝了客户端的访问请求。</p><p>&emsp;(C) 如果终端用户许可了这次访问，那么授权服务器会将user-agent引导到之前提供的重定向URI。重定向URI会在URI片断{译者注：URI片断是指URI中#号之后的内容}中包含访问令牌。</p><p>&emsp;(D) user-agent响应重定向指令，向web服务器发送不包含URI片断的请求。user-agent在本地保存URI片断。</p><p>&emsp;(E) web服务器返回一个web页面（通常是嵌入了脚本的HTML网页），这个页面能够访问完整的重定向URI，它包含了由user-agent保存的URI片断，同时这个页面能够将包含在URI片断中的访问令牌（和其它参数）提取出来。</p><p>&emsp;(F) user-agent在本地执行由web服务器提供的脚本，该脚本提取出访问令牌并将它传递给客户端。</p></blockquote><h3 id="2-3-原生程序-Native-Application"><a href="#2-3-原生程序-Native-Application" class="headerlink" title="2.3 原生程序 Native Application"></a><strong>2.3 原生程序 Native Application</strong></h3><p>&emsp;&emsp;原生程序是作为原生代码运行在终端用户计算机或设备上的客户端（即，在user-agent之外运行或作为一个桌面程序）。这些客户端通常有能力与终端用户的user-agent交互（或嵌入user-agent），但是在这些交互如何影响终端用户体验的方式上受到限制。在很多情况下，原生程序无法直接从服务器接收回调请求（例如，防火墙、操作系统限制）。</p><p>&emsp;&emsp;基于不同的需求和期望的终端用户体验，原生程序客户端可以用不同的方式实现。原生程序客户端可以：</p><blockquote><ul><li>如第4节所述，通过启动一个外部user-agent来访问终端用户授权endpoint。客户端可以通过下面的方式捕获响应文本：提供一个具有自定义URI scheme{译者注：URI scheme就是一个URI里面的第一部分，即冒号前面的部分}的重定向URI（在操作系统上注册过以便调用客户端应用），或者提供一个指向在客户端控制下的服务器资源的重定向URI，这使得响应文本对客户端可见（例如，使用窗口标题或在user-agent外面可以访问到的其它位置）。</li><li>如第4节所述，通过嵌入一个user-agent来访问终端用户授权endpoint。客户端通过与嵌入的user-agent直接通信获取到响应文本。</li><li>提示终端用户输入密码，使用密码直接获得一个访问令牌。通常来讲，这是一种不推荐的方式，因为它将终端用户的密码直接交给了第三方客户端，而客户端不得不用明文存储密码。它还要求服务器支持基于密码的身份验证。</li></ul></blockquote><p>&emsp;&emsp;当在启动外部浏览器和嵌入的user-agent之间进行选择时，开发者应该考虑下列因素：</p><blockquote><ul><li>外部浏览器可能会提高完成比率，因为终端用户可能已经登录过了而不需要重新进行身份验证。</li><li>嵌入的user-agent通常能提供更好的用户流程，因为它不必切换上下文并打开新窗口。</li><li>嵌入的user-agent对安全提出了挑战，因为用户在一个无法辨别的窗口之中进行身份验证，而不像很多user-agent那样能提供可视化的保护。</li></ul></blockquote><h3 id="2-4-自治态-Autonomous"><a href="#2-4-自治态-Autonomous" class="headerlink" title="2.4 自治态 Autonomous"></a><strong>2.4 自治态 Autonomous</strong></h3><p>&emsp;&emsp;自治客户端使用现成的信任关系或框架来建立授权。基于自治客户端的需求和他们所依赖的现存信任框架，自治客户端可以用不同的方式实现。自治客户端可以：</p><blockquote><ul><li>通过使用客户端私有证书与授权服务器进行验证，从而获得访问令牌。访问令牌的作用域局限于受客户端控制的受保护资源，或者其它资源拥有者与授权服务器预先约定的资源。</li><li>使用现存的某种访问许可，它被表达成授权服务器所支持的某种断言格式。使用断言需要客户端从一个断言发行方获得一个断言（如SAML[OASIS.saml-core-2.0-os]断言）或自己分发一个断言。断言的格式、获得断言的过程，以及验证断言的方法，由断言发行方和授权服务器定义，不在本规范的规定范围之内。</li></ul></blockquote><hr><h2 id="第三节-客户端私有证书-Client-Credentials"><a href="#第三节-客户端私有证书-Client-Credentials" class="headerlink" title="第三节 客户端私有证书 Client Credentials"></a><strong>第三节 客户端私有证书 Client Credentials</strong></h2><p>&emsp;&emsp;当与授权服务器进行交互时，客户端使用一个私有证书集合来标识自己，这个证书集合包含一个客户端标识符和用于客户端身份验证的其它一些属性。客户端获得私有证书的方式不在本规范的规定范围之内，不过这通常都包含一个在授权服务器上注册的过程。</p><p>&emsp;&emsp;考虑到一些客户端的本质特性，在与客户端没有确立信任关系的前提下，授权服务器不应该对客户端密钥的私密性做出任何假设。授权服务器不应该向没有能力对密钥进行秘密保存的客户端分发密钥。</p><p>&emsp;&emsp;授权服务器可以使用任一合适的私有证书集合和验证机制来对客户端进行身份验证。客户端一定不能在一个请求中使用多个私有证书集合和验证机制。</p><h3 id="3-1-客户端密码证书-Client-Password-Credentials"><a href="#3-1-客户端密码证书-Client-Password-Credentials" class="headerlink" title="3.1 客户端密码证书 Client Password Credentials"></a><strong>3.1 客户端密码证书 Client Password Credentials</strong></h3><p>&emsp;&emsp;客户端密码证书使用一个共享的对称密钥来验证客户端。客户端标识符和密码被包含在请求当中，使用<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC2617" title="Title" target="_blank" rel="noopener">[RFC2617]</a>定义的HTTP Basic验证机制，将客户端标识符作为用户名（username）并将客户端密码作为密码（password）来传送。</p><p>&emsp;&emsp;例如（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=i1WsRn1uB1&amp;</span><br><span class="line">redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;作为可选方式，客户端可以使用下列参数将密码包含在请求体（request body）中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_id</span><br><span class="line">    必需参数。客户端标识符。</span><br><span class="line">client_secret</span><br><span class="line">    必需参数。客户端密钥。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">client_secret=gX1fBat3bV&amp;code=i1WsRn1uB1&amp;</span><br><span class="line">redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须能够使用请求参数和HTTP Basic验证协议两种方式接受客户端私有证书。授权服务器可以支持更多适合于密码证书传输的验证机制。</p><h3 id="3-2-客户端断言证书-Client-Assertion-Credentials"><a href="#3-2-客户端断言证书-Client-Assertion-Credentials" class="headerlink" title="3.2 客户端断言证书 Client Assertion Credentials"></a><strong>3.2 客户端断言证书 Client Assertion Credentials</strong></h3><p>&emsp;&emsp;客户端断言证书用于不宜使用密码（明文共享对称密钥）或密码无法为客户端验证提供足够安全性的情况。在这样的情况下，常见的做法是使用诸如HMAC或数字签名之类不需要发送明文密钥的其它机制。客户端断言证书提供了一种扩展机制，能够使用被授权服务器所支持的某种断言格式进行客户端身份验证。</p><p>&emsp;&emsp;使用断言需要客户端从一个断言发行方获得一个断言（如SAML[OASIS.saml-core-2.0-os]断言）或自己分发一个断言。断言的格式、获得断言的过程，以及验证断言的方法，由断言发行方和授权服务器定义，不在本规范的规定范围之内。</p><p>&emsp;&emsp;当使用客户端断言时，客户端传送下列参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_assertion_type</span><br><span class="line">    必需参数。由授权服务器定义的断言格式。这个值必须是一个绝对URI。</span><br><span class="line">client_assertion</span><br><span class="line">    必需参数。客户端断言。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端使用一个SAML 2.0断言发送如下访问令牌请求来验证自己（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=i1WsRn1uB1&amp;</span><br><span class="line">client_assertion=PHNhbWxwOl[...omitted for brevity...]ZT4%3D&amp;</span><br><span class="line">client_assertion_type=</span><br><span class="line"><span class="attribute">urn%3Aoasis%3Anames%sAtc%3ASAML%3A2.0%3Aassertion&amp;</span></span><br><span class="line">redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当使用一个客户端断言和一个授权码获得一个访问令牌的时候，需要一个机制在用于获取授权码的“client_id”参数值和客户端断言之间完成映射。这个机制不在本规范的规定范围之内，但对于与授权码结合使用的任何客户端断言类型都必须明确指明。</p><p>&emsp;&emsp;对于那些使用客户端断言证书但不包含能够提供下列信息的HMAC或签名值的访问令牌请求，授权服务器必须拒绝响应：</p><blockquote><ul><li>指明这个断言是专门分发给当前接收endpoint来处理的（一般是通过一个包含接收endpoint标识符的audience或recipient值）。</li><li>标识出分发断言的实体（一般是通过一个issuer值）。</li><li>用一个绝对时间标识出断言在何时过期（一般是通过一个包含UTC日期/时间值的过期值）。授权服务器必须拒绝过期的断言。</li></ul></blockquote><hr><h2 id="第四节-获得终端用户授权-Obtaining-End-User-Authorization"><a href="#第四节-获得终端用户授权-Obtaining-End-User-Authorization" class="headerlink" title="第四节 获得终端用户授权 Obtaining End-User Authorization"></a><strong>第四节 获得终端用户授权 Obtaining End-User Authorization</strong></h2><p>&emsp;&emsp;在客户端能够访问一个受保护资源之前，它必须首先从终端用户那里获取授权。为了获得终端用户授权，客户端需要将终端用户引导到终端用户授权endpoint。一旦获得授权，终端用户的访问许可会被表示成一个授权码，客户端能够使用它去获取一个访问令牌。</p><p>&emsp;&emsp;在终端用户授权endpoint上，终端用户首先在授权服务器上完成身份验证，然后允许或者拒绝当前访问请求。授权服务器验证用户的方式（例如，用户名和密码登录，OpenID，会话cookie）和授权服务器获取终端用户授权的方式，以及是否使用诸如TSL之类的安全通道，不在本规范的规定范围之内。然而，授权服务器必须要首先验证终端用户的身份。</p><p>&emsp;&emsp;终端用户授权endpoint的位置能够在服务器文档中找到。终端用户授权endpoint的URI可以按照[RFC3986]第3节的定义包含一个查询参数部分，它们在添加其它参数时必须被保留。</p><p>&emsp;&emsp;既然对于终端用户授权endpoint的请求会导致用户身份验证和敏感信息的传输，授权服务器应该要求在向终端用户授权endpoint发送请求的时候使用诸如TLS之类的传输层安全机制。</p><h3 id="4-1-授权请求-Authorization-Request"><a href="#4-1-授权请求-Authorization-Request" class="headerlink" title="4.1 授权请求 Authorization Request"></a><strong>4.1 授权请求 Authorization Request</strong></h3><p>&emsp;&emsp;为了将终端用户的user-agent引导到授权服务器，客户端将下列参数添加到终端用户授权endpoint URI的查询参数部分，并使用如<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#W3C.REC-html401-19991224" title="Title" target="_blank" rel="noopener">[W3C.REC-html401-19991224]</a>所定义的“application/x-www-form-urlencoded”格式构建起一个请求URI，如下定义：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">response_type</span><br><span class="line">    必需参数。请求的响应中：一个访问令牌、一个授权码，或两者都有。请求访问令牌参数值必须设为“token”，请求授权码参数值必须设为“code”，或者使用参数值为“code_and_token”同时请求两者。授权服务器可能拒绝提供这些响应类型中的一种或多种。</span><br><span class="line">client_id</span><br><span class="line">    必需参数。如第<span class="number">3</span>节所述的客户端标识符。</span><br><span class="line">redirect_uri</span><br><span class="line">    必需参数，除非通过其它方式在客户端和授权服务器之间已经确定了一个重定向URI。这是当终端用户的授权步骤完成时授权服务器将要把user-agent重定向到的一个绝对URI。授权服务器应该要求客户端预先注册它们的重定向URI。</span><br><span class="line">scope</span><br><span class="line">    可选参数。访问请求的作用域，以空格隔开的字符串列表来表示。“scope”参数的值由授权服务器定义。如果这个值包含多个空格隔开的字符串，那么它们的顺序不分先后，而且每个字符串都为请求的作用域增加一个新的访问范围。</span><br><span class="line"><span class="keyword">state</span></span><br><span class="line">    可选参数。被客户端用来在请求和回调之间维护状态的值，对授权服务器来说是不透明的。授权服务器在将user-agent重定向回客户端时传回这个值。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端通过user-agent使用HTTP重定向响应，或者其它可用的方式，将终端用户引导到构建好的URI上。对于终端用户授权endpoint，授权服务器必须支持HTTP的“GET”方法，也可以支持使用“POST”方法。</p><p>&emsp;&emsp;例如，客户端引导终端用户的user-agent使用传输层安全机制发送下列HTTP请求（换行符只用于显示目的）:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span> /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">    <span class="attribute">redirect_uri</span>=https<span class="number">%3</span>A<span class="number">%2</span>F<span class="number">%2</span>Fclient<span class="number">%2</span>Eexample<span class="number">%2</span>Ecom<span class="number">%2</span>Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果客户端已经在授权服务器上预先注册了一个重定向URI，授权服务器必须保证收到的重定向URI与当前客户端标识符所对应的注册URI相匹配。授权服务器不应该将user-agent重定向到没有注册过的或不信任的URI，以避免endpoint被用作一个公开的转向器。如果没有可用的有效重定向URI，授权服务器应该将发生的错误报告给用户[[提供如何执行匹配操作的建议]]。</p><p>&emsp;&emsp;没有值的参数必须被当做它们在请求中不存在一样。授权服务器应该忽略识别不了的请求参数。</p><p>&emsp;&emsp;授权服务器对请求进行验证以保证所有必需参数都存在并有效。如果请求是无效的，授权服务器将使用重定向URI把user-agent重定向回客户端，并且URI后面加上适当的错误码，如4.3节所述。</p><p>&emsp;&emsp;授权服务器验证终端用户的身份并获得一个授权决定（通过询问用户或通过其它方式认可）。当一个决定被做出后，授权服务器将终端用户的user-agent引导到客户端提供的重定向URI，这个重定向或者使用HTTP重定向响应，或者通过终端用户user-agent的其它可用的方式。</p><h3 id="4-2-授权响应-Authorization-Response"><a href="#4-2-授权响应-Authorization-Response" class="headerlink" title="4.2 授权响应 Authorization Response"></a><strong>4.2 授权响应 Authorization Response</strong></h3><p>&emsp;&emsp;如果终端用户许可了访问请求，授权服务器会分发一个访问令牌，或一个授权码，或者两者都有，并且通过将下列参数添加到重定向URI将这些分发结果传递给客户端（如下所述）。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">code</span><br><span class="line">    如果响应类型是“code”或“code_and_token”则是必需的，否则一定不能包含这个参数。表示由授权服务器产生的授权码。授权码应该在分发后迅速过期，以降低泄露风险。客户端一定不能重用同一个授权码。如果一个授权码被多次使用，授权服务器可能撤销之前基于这个授权码分发的所有令牌。授权码与客户端标识符和重定向URI相绑定。</span><br><span class="line">access_token</span><br><span class="line">    如果响应类型是“token”或“code_and_token”则是必需的，否则一定不能包含这个参数。表示由授权服务器分发的访问令牌。</span><br><span class="line">token_type</span><br><span class="line">    如果响应中包含一个访问令牌则是必需的。表示分发的令牌类型。令牌类型告诉客户端一个信息，即当访问一个受保护资源时访问令牌应该如何被使用，如<span class="number">6.1</span>节所述。</span><br><span class="line">expires_in</span><br><span class="line">    可选参数。如果包含访问令牌参数，则表示访问令牌生命周期的秒数。例如，“<span class="number">3600</span>”表示自响应被授权服务器产生的时刻起，访问令牌将在一小时后过期。</span><br><span class="line">scope</span><br><span class="line">    可选参数。如果包含访问令牌参数，则表示访问令牌的作用域，表示为一个空格隔开的字符串列表。“scope”参数的值由授权服务器定义。如果这个值包含多个空格隔开的字符串，那么它们的顺序不分先后，而且每个字符串都为请求的作用域增加一个新的访问范围。如果请求到的作用域不同于客户端申请的作用域，授权服务器应该传回这个参数。</span><br><span class="line"><span class="keyword">state</span></span><br><span class="line">    如果“<span class="keyword">state</span>”参数在客户端授权请求中存在，则这个参数是必需的。需要精确地设置成从客户端接收到的值。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器在重定向URI上添加参数的方式取决于客户端在授权请求中请求的响应类型，由“response_type”参数指定。</p><p>&emsp;&emsp;如果响应类型是“code”，授权服务器使用如<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#W3C.REC-html401-19991224" title="Title" target="_blank" rel="noopener">[W3C.REC-html401-19991224]</a>所定义的“application/x-www-form-urlencoded”格式添加参数到重定向URI的查询参数部分。</p><p>&emsp;&emsp;例如，授权服务器通过发送下列HTTP响应将终端用户的user-agent进行重定向：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line"><span class="string">Location:</span> <span class="string">https:</span><span class="comment">//client.example.com/cb?code=i1WsRn1uB1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果响应类型是“code”或“code_and_token”，授权服务器使用如<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#W3C.REC-html401-19991224" title="Title" target="_blank" rel="noopener">[W3C.REC-html401-19991224]</a>所定义的“application/x-www-form-urlencoded”格式添加参数到重定向URI的分段参数部分。</p><p>&emsp;&emsp;例如，授权服务器通过发送下列HTTP响应将终端用户的user-agent进行重定向（URI换行符只用于显示目的）：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line"><span class="symbol">  Location:</span> http:<span class="comment">//example.com/rd#access_token=FJQbwq9&amp;</span></span><br><span class="line">            token_type=example<span class="variable">&amp;expires_in</span>=<span class="number">3600</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端应该忽略无法识别的响应参数。从授权服务器接收到的令牌和其它参数值的大小，本规范未作定义。客户端应该避免对参数值大小做任何假设。服务器应该对它们所分发的任何参数值的期望大小做出文档说明。</p><h3 id="4-3-错误响应-Error-Response"><a href="#4-3-错误响应-Error-Response" class="headerlink" title="4.3 错误响应 Error Response"></a><strong>4.3 错误响应 Error Response</strong></h3><p>&emsp;&emsp;如果终端用户拒绝了访问请求，或者由于除了缺少或无效重定向URI之外的其它原因而导致请求失败，授权服务器使用如<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#W3C.REC-html401-19991224" title="Title" target="_blank" rel="noopener">[W3C.REC-html401-19991224]</a>所定义的“application/x-www-form-urlencoded”格式添加下列参数到重定向URI的查询参数部分以通知客户端：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error</span><br><span class="line">    必需参数。如<span class="number">4.3</span>.<span class="number">1</span>节所述的一个错误码。</span><br><span class="line">error_description</span><br><span class="line">    可选参数。提供额外信息的一段人类可读的文字，用来帮助理解和解决发生的错误。</span><br><span class="line">error_uri</span><br><span class="line">    可选参数。指明了一个人类可读的网页URI，带有关于错误的信息，用来为终端用户提供与错误有关的额外信息。</span><br><span class="line"><span class="keyword">state</span></span><br><span class="line">    如果“<span class="keyword">state</span>”参数在客户端授权请求中存在，则这个参数是必需的。需要精确地设置成从客户端接收到的值。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，授权服务器通过发送下列HTTP响应将终端用户的user-agent进行重定向：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line"><span class="string">Location:</span> <span class="string">https:</span><span class="comment">//client.example.com/cb?error=access_denied</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果由于缺少或无效重定向URI而导致请求失败，授权服务器应该通知终端用户这个错误，而一定不能将终端用户的user-agent重定向到这个无效的重定向URI。</p><h4 id="4-3-1-错误码-Error-Codes"><a href="#4-3-1-错误码-Error-Codes" class="headerlink" title="4.3.1 错误码 Error Codes"></a><strong>4.3.1 错误码 Error Codes</strong></h4><p>&emsp;&emsp;授权服务器在错误响应中包含下列错误码之一：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">invalid_request</span><br><span class="line">    请求缺少某个必需参数，包含一个不支持的参数或参数值，或者格式不正确。</span><br><span class="line">invalid_client</span><br><span class="line">    提供的客户端标识符是无效的。</span><br><span class="line">unauthorized_client</span><br><span class="line">    客户端没有权限使用该请求的响应类型。</span><br><span class="line">redirect_uri_mismatch</span><br><span class="line">    提供的重定向URI与预先注册的值不匹配。</span><br><span class="line">access_denied</span><br><span class="line">    终端用户或授权服务器拒绝了请求。</span><br><span class="line">unsupported_response_type</span><br><span class="line">    请求的响应类型不为授权服务器所支持。</span><br><span class="line">invalid_scope</span><br><span class="line">    请求的作用域是无效的、未知的，或格式不正确的。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;[[增加扩展错误码的机制]]</p><hr><h2 id="第五节-获取访问令牌"><a href="#第五节-获取访问令牌" class="headerlink" title="第五节 获取访问令牌"></a><strong>第五节 获取访问令牌</strong></h2><p>&emsp;&emsp;客户端通过在授权服务器上验证并出示它的访问许可（表示成授权码、资源拥有者私有证书、断言或刷新令牌的形式）来获取一个访问令牌。</p><p>&emsp;&emsp;既然对于令牌endpoint的请求会导致在HTTP请求和响应中传输明文证书，授权服务器必需要求在向令牌endpoint发送请求的时候使用传输层安全机制。服务器必需支持<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC5246" title="Title" target="_blank" rel="noopener">[RFC5246]</a>所定义的TLS 1.2，并且可能支持额外的传输层安全机制。</p><p>&emsp;&emsp;客户端通过向令牌endpoint发送一个HTTP POST请求来获取一个访问令牌。令牌endpoint的位置能够在服务器文档中找到。令牌endpoint URI可能包含一个查询参数部分。</p><p>&emsp;&emsp;客户端通过在请求中添加客户端私有证书与授权服务器进行验证，如第3节所述。当客户端标识符不重要的时候（例如匿名客户端），或当客户端标识符通过其它方式确定的时候（例如使用一个断言访问许可），授权服务器可能允许不经验证的访问令牌请求。</p><p>&emsp;&emsp;客户端通过在HTTP请求的entity-body中使用“application/x-www-form-urlencoded”格式包含下列参数，来构建请求：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant_type</span><br><span class="line">    必需参数。在请求中所包含的访问许可类型。它的值必须是“authorization_code”、“password”、“refresh_token”、“client_credentials”或一个用来标识被授权服务器所支持的断言类型的绝对URI。</span><br><span class="line"><span class="keyword">scope</span></span><br><span class="line">    可选参数。访问请求的作用域，表达为一个由空格隔开的字符串列表。“<span class="keyword">scope</span>”参数的值由授权服务器定义。如果这个值包含多个空格隔开的字符串，那么它们的顺序不分先后，而且每个字符串都为请求的作用域增加一个新的访问范围。如果使用的访问许可已经代表了一个许可作用域（例如，授权码、断言），那么请求的作用域必须等于或少于之前许可的作用域，如果缺少这个参数就认为是等于之前的许可作用域。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;另外，对于5.1节列出的某个访问许可类型，客户端必须包含合适的参数。</p><p>&emsp;&emsp;没有值的参数必须被当做它们在请求中不存在一样。授权服务器应该忽略识别不了的请求参数。</p><h3 id="5-1-访问许可类型-Access-Grant-Types"><a href="#5-1-访问许可类型-Access-Grant-Types" class="headerlink" title="5.1 访问许可类型 Access Grant Types"></a><strong>5.1 访问许可类型 Access Grant Types</strong></h3><p>&emsp;&emsp;客户端使用一个授权码、资源拥有者密码证书、客户端私有证书、刷新令牌或断言来请求一个访问许可。</p><h4 id="5-1-1-授权码-Authorization-Code"><a href="#5-1-1-授权码-Authorization-Code" class="headerlink" title="5.1.1 授权码 Authorization Code"></a><strong>5.1.1 授权码 Authorization Code</strong></h4><p>&emsp;&emsp;客户端使用“authorization_code”访问许可类型和下列参数传入授权码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code</span><br><span class="line">    必需参数。从授权服务器接收到的授权码。</span><br><span class="line">redirect_uri</span><br><span class="line">    必需参数。在最初请求中使用的重定向URI。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端通过如第3节所述的“client_secret”参数包含客户端私有证书，并使用传输层安全机制，来发送下列HTTP请求（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">client_secret=gX1fBat3bV&amp;code=i1WsRn1uB1&amp;</span><br><span class="line">redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须：</p><blockquote><ul><li>验证客户端私有证书（如果存在）并保证它们与授权码匹配。</li><li>验证授权码和重定向URI都是有效的，并且与存储的关联关系相匹配。</li></ul></blockquote><p>&emsp;&emsp;如果请求有效，授权服务器分发一个成功响应，如5.2节所述。</p><h4 id="5-1-2-资源拥有者密码证书-Resource-Owner-Password-Credentials"><a href="#5-1-2-资源拥有者密码证书-Resource-Owner-Password-Credentials" class="headerlink" title="5.1.2 资源拥有者密码证书 Resource Owner Password Credentials"></a><strong>5.1.2 资源拥有者密码证书 Resource Owner Password Credentials</strong></h4><p>&emsp;&emsp;客户端使用“password”访问许可类型和下列参数传入资源拥有者密码证书：[[增加对于用户名和密码的国际化考虑]]</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">username</span><br><span class="line">    必需参数。资源拥有者的用户名。</span><br><span class="line">password</span><br><span class="line">    必需参数。资源拥有者的密码。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端通过如第3节所述的“client_secret”参数包含客户端私有证书，并使用传输层安全机制，来发送下列HTTP请求（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">client_secret=47HDu8s&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须验证客户端私有证书（如果存在）和终端用户私有证书，而且如果发现有效则必须发布一个访问令牌响应，如5.2节所述。</p><h4 id="5-1-3-客户端私有证书-Client-Credentials"><a href="#5-1-3-客户端私有证书-Client-Credentials" class="headerlink" title="5.1.3 客户端私有证书 Client Credentials"></a><strong>5.1.3 客户端私有证书 Client Credentials</strong></h4><p>&emsp;&emsp;客户端可以仅仅使用它的客户端私有证书来请求一个访问令牌，即使用“client_credentials”访问许可类型。当省略一个显式的访问许可时，客户端是在请求访问它所控制的受保护资源，或另一个资源拥有者之前与授权服务器约定好的受保护资源（约定方式不在本规范的规定范围之内）。</p><h4 id="5-1-4-刷新令牌-Refresh-Token"><a href="#5-1-4-刷新令牌-Refresh-Token" class="headerlink" title="5.1.4 刷新令牌 Refresh Token"></a><strong>5.1.4 刷新令牌 Refresh Token</strong></h4><p>&emsp;&emsp;客户端使用“refresh_token”访问许可类型和下列参数传入刷新令牌：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refresh_token</span><br><span class="line">    必需参数。与待刷新的访问令牌相关联的刷新令牌。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端通过如第3节所述的“client_secret”参数包含客户端私有证书，并使用传输层安全机制，来发送下列HTTP请求（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">client_secret=8eSEIpnqmM&amp;refresh_token=n4E9O119d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须验证客户端私有证书（如果存在），验证刷新令牌是否有效，以及验证资源拥有者的授权是否仍然有效。如果请求有效，授权服务器则发布一个访问令牌响应，如5.2节所述。授权服务器可以发布一个新的刷新令牌，在这种情况下，客户端必须丢弃旧的刷新令牌并且用新的访问令牌替换。</p><h4 id="5-1-5-断言-Assertion"><a href="#5-1-5-断言-Assertion" class="headerlink" title="5.1.5 断言 Assertion"></a><strong>5.1.5 断言 Assertion</strong></h4><p>&emsp;&emsp;客户端使用一个绝对URI（由授权服务器定义）作为“grant_type”参数的值指定断言格式，并添加下列参数，来传入一个断言：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertion</span><br><span class="line">    必需参数。断言。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端使用传输层安全机制来发送下列HTTP请求，且客户端验证通过断言来完成（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=urn%3Aoasis%3Anames%3Atc%3ASAML%3A2.0%3Aassertion&amp;</span><br><span class="line">assertion=PHNhbWxwOl[...omitted for brevity...]ZT4%3D</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须验证客户端私有证书（如果存在）和断言，而且如果发现有效则必须发布一个访问令牌响应，如5.2节所述。授权服务器不应该分发一个刷新令牌（而是应该要求客户端使用相同的或新的断言）。</p><p>&emsp;&emsp;授权服务器应该分发具有有限生命周期的访问令牌，并且要求客户端使用仍然有效的同一个断言来请求新的访问令牌，从而完成对令牌的刷新。</p><h3 id="5-2-访问令牌响应-Access-Token-Response"><a href="#5-2-访问令牌响应-Access-Token-Response" class="headerlink" title="5.2 访问令牌响应 Access Token Response"></a><strong>5.2 访问令牌响应 Access Token Response</strong></h3><p>&emsp;&emsp;在接收到并验证过来自客户端的一个有效且经授权的访问令牌请求之后，授权服务器分发访问令牌和可选的刷新令牌，并且通过一个200（OK）状态码在HTTP响应的entity body中添加下列参数来构造响应：</p><p>&emsp;&emsp;令牌响应包含下列参数：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">access_token</span><br><span class="line">    必需参数。由授权服务器分发的访问令牌。</span><br><span class="line">token_type</span><br><span class="line">    必需参数。分发的令牌类型。令牌类型告诉客户端一个信息，即当访问一个受保护资源时访问令牌应该如何被使用，如<span class="number">6.1</span>节所述。</span><br><span class="line">expires_in</span><br><span class="line">    可选参数。访问令牌生命周期的秒数。例如，“<span class="number">3600</span>”表示自响应被授权服务器产生的时刻起，访问令牌将在一小时后过期。</span><br><span class="line">refresh_token</span><br><span class="line">    可选参数。用来获取新的访问令牌的刷新令牌，如<span class="number">5.1</span><span class="number">.4</span>节所述使用相同的终端用户访问许可。当访问许可类型是一个断言或一个客户端私有证书集合时，授权服务器不应该分发一个刷新令牌。</span><br><span class="line">scope</span><br><span class="line">    可选参数。访问令牌的作用域，表示为一个空格隔开的字符串列表。“scope”参数的值由授权服务器定义。如果这个值包含多个空格隔开的字符串，那么它们的顺序不分先后，而且每个字符串都为请求的作用域增加一个新的访问范围。如果请求到的作用域不同于客户端申请的作用域，授权服务器应该传回这个参数。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;参数包含在HTTP响应的entity body中，使用<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC4627" title="Title" target="_blank" rel="noopener">[RFC4627]</a>定义的“application/json”媒体类型。通过在最高结构层次上添加每个参数，将它们序列化成一个JSON结构。参数名和字符串值都表示成JSON字符串。数字值表示成JSON数字。</p><p>&emsp;&emsp;在任何包含令牌、密钥或其它敏感信息的响应中，授权服务器必须在“Cache-Control”响应头部字段中传入一个“no-store”的值。</p><p>&emsp;&emsp;例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "access_token":"SlAV32hkKG",</span><br><span class="line">  "token_type":"example",</span><br><span class="line">  "expires_in":3600,</span><br><span class="line">  "refresh_token":"8xLOxBtZp8"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端应该忽略无法识别的响应参数。从授权服务器接收到的令牌和其它参数值的大小，本规范未作定义。客户端应该避免对参数值大小做任何假设。服务器应该对它们所分发的任何参数值的期望大小做出文档说明。</p><h3 id="5-3-错误响应-Error-Response"><a href="#5-3-错误响应-Error-Response" class="headerlink" title="5.3 错误响应 Error Response"></a><strong>5.3 错误响应 Error Response</strong></h3><p>&emsp;&emsp;如果令牌请求是无效的或未经授权的，授权服务器通过在HTTP响应的entity body中添加下列参数并使用“application/json”媒体类型来构造响应：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error</span><br><span class="line">    必需参数。如4.3.1节所述的一个错误码。</span><br><span class="line">error_description</span><br><span class="line">    可选参数。提供额外信息的一段人类可读的文字，用来帮助理解和解决发生的错误。</span><br><span class="line">error_uri</span><br><span class="line">    可选参数。指明了一个人类可读的网页URI，带有关于错误的信息，用来为终端用户提供与错误有关的额外信息。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "error":"invalid_request"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果客户端通过“Authorization”请求头部字段使用HTTP验证机制这种方式提供了无效的私有证书，那么授权服务器必须用HTTP 401（Unauthorized）状态码进行响应。否则，授权服务器应该用HTTP 400（Bad Request）状态码进行响应。</p><h4 id="5-3-1-错误码-Error-Codes"><a href="#5-3-1-错误码-Error-Codes" class="headerlink" title="5.3.1 错误码 Error Codes"></a><strong>5.3.1 错误码 Error Codes</strong></h4><p>&emsp;&emsp;授权服务器在错误响应中传回下列错误码之一：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">invalid_request</span><br><span class="line">    请求缺少某个必需参数，包含一个不支持的参数或参数值，参数重复，包含多个私有证书，使用了多种验证客户端的机制，或者请求格式不正确。</span><br><span class="line">invalid_client</span><br><span class="line">    提供的客户端标识符是无效的，客户端验证失败，客户端不包含私有证书，提供了多个客户端私有证书，或使用了不支持的证书类型。</span><br><span class="line">unauthorized_client</span><br><span class="line">    经过验证的客户端没有权限使用提供的访问许可类型。</span><br><span class="line">invalid_grant</span><br><span class="line">    提供的访问许可是无效的、过期的或已撤销的（例如，无效的断言，过期的授权令牌，错误的终端用户密码证书，或者不匹配的授权码和重定向URI）。</span><br><span class="line">unsupported_grant_type</span><br><span class="line">    包含的访问许可——它的类型或其它属性——不被授权服务器所支持。</span><br><span class="line">invalid_scope</span><br><span class="line">    请求的作用域是无效的、未知的、格式不正确的，或超出了之前许可的作用域。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;[[增加扩展错误码的机制]]</p><hr><h2 id="第六节-访问受保护资源-Accessing-a-Protected-Resource"><a href="#第六节-访问受保护资源-Accessing-a-Protected-Resource" class="headerlink" title="第六节 访问受保护资源 Accessing a Protected Resource"></a><strong>第六节 访问受保护资源 Accessing a Protected Resource</strong></h2><p>&emsp;&emsp;客户端通过向资源服务器出示一个访问令牌来访问受保护资源。资源服务器必须验证访问令牌，保证它没有过期并且它的作用域覆盖了请求的资源。被资源服务器用来验证访问令牌的方式不在本规范的规定范围之内，但是它通常需要在资源服务器和授权服务器之间进行交互或配合。</p><p>&emsp;&emsp;客户端利用访问令牌来验证资源服务器的方式取决于由授权服务器分发的访问令牌类型。</p><h3 id="6-1-访问令牌类型-Access-Token-Types"><a href="#6-1-访问令牌类型-Access-Token-Types" class="headerlink" title="6.1 访问令牌类型 Access Token Types"></a><strong>6.1 访问令牌类型 Access Token Types</strong></h3><p>&emsp;&emsp;[[增加令牌类型的解释，可能包含指定其它规范的链接]]</p><h3 id="6-2-WWW-Authenticate响应头部字段-The-WWW-Authenticate-Response-Header-Field"><a href="#6-2-WWW-Authenticate响应头部字段-The-WWW-Authenticate-Response-Header-Field" class="headerlink" title="6.2 WWW-Authenticate响应头部字段 The WWW-Authenticate Response Header Field"></a><strong>6.2 WWW-Authenticate响应头部字段 The WWW-Authenticate Response Header Field</strong></h3><p>&emsp;&emsp;如果对于受保护资源的请求不包含验证证书，包含一个无效的访问令牌，或格式不正确，那么资源服务器必须包含一个HTTP “WWW-Authenticate”响应头部字段。这个“WWW-Authenticate”头部字段使用<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC2617" title="Title" target="_blank" rel="noopener">[RFC2617]</a>定义的框架，如下所示：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">challenge       = <span class="string">"OAuth2"</span> [ RWS 1#param ]</span><br><span class="line"></span><br><span class="line">param           = scope /</span><br><span class="line">                  <span class="keyword">error</span> / <span class="keyword">error</span>-<span class="keyword">desc</span> / <span class="keyword">error</span>-uri /</span><br><span class="line">                  ( <span class="keyword">token</span> <span class="string">"="</span> ( <span class="keyword">token</span> / quoted-string ) )</span><br><span class="line"></span><br><span class="line">scope           = <span class="string">"scope"</span> <span class="string">"="</span> &lt;<span class="string">"&gt; scope-v *( SP scope-v ) &lt;"</span>&gt;</span><br><span class="line">scope-v         = 1*quoted-<span class="built_in">char</span></span><br><span class="line"></span><br><span class="line">quoted-<span class="keyword">char</span>     = <span class="keyword">ALPHA</span> / DIGIT /</span><br><span class="line">                  <span class="string">"!"</span> / <span class="string">"#"</span> / <span class="string">"$"</span> / <span class="string">"%"</span> / <span class="string">"&amp;"</span> / <span class="string">"'"</span> / <span class="string">"("</span> / <span class="string">")"</span> /</span><br><span class="line">                  <span class="string">"*"</span> / <span class="string">"+"</span> / <span class="string">"-"</span> / <span class="string">"."</span> / <span class="string">"/"</span> / <span class="string">":"</span> / <span class="string">"&lt;"</span> / <span class="string">"="</span> /</span><br><span class="line">                  <span class="string">"&gt;"</span> / <span class="string">"?"</span> / <span class="string">"@"</span> / <span class="string">"["</span> / <span class="string">"]"</span> / <span class="string">"^"</span> / <span class="string">"_"</span> / <span class="string">"`"</span> /</span><br><span class="line">                  <span class="string">"&#123;"</span> / <span class="string">"|"</span> / <span class="string">"&#125;"</span> / <span class="string">"~"</span> / <span class="string">"\"</span> / <span class="string">","</span> / <span class="string">";"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">error</span>           = <span class="string">"error"</span> <span class="string">"="</span> quoted-<span class="built_in">string</span></span><br><span class="line"><span class="keyword">error</span>-<span class="keyword">desc</span>      = <span class="string">"error_description"</span> <span class="string">"="</span> quoted-<span class="built_in">string</span></span><br><span class="line"><span class="keyword">error</span>-uri       = <span class="string">"error_uri"</span> = &lt;<span class="string">"&gt; URI-reference &lt;"</span>&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;“scope”属性是一个空格隔开的作用域值的列表，表明了为了访问受保护资源所需要访问令牌作用域。“scope”属性一定不能出现多次。</p><p>&emsp;&emsp;如果对于受保护资源的请求包含一个访问令牌并且验证失败了，那么资源服务器应该包含“error”属性来向客户端提供为何访问请求被拒绝的原因。参数值在6.2.1中描述。另外，资源服务器可能包含“error_description”属性来提供一个人类可读的解释，或者包含“error-uri”属性用一个绝对URI来指定一个用于解释错误的人类可读的网页。“error”、“error_description”和“error-uri”属性一定不能出现多次。</p><p>&emsp;&emsp;例如，对于一个缺少验证的受保护资源请求的响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: OAuth2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于一个使用过期访问令牌尝试验证的受保护资源请求的响应：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">WWW-Authenticate: OAuth2</span><br><span class="line">                  <span class="attribute">error</span>=<span class="string">"invalid_token"</span>,</span><br><span class="line">                  <span class="attribute">error_description</span>=<span class="string">"The access token expired"</span></span><br></pre></td></tr></table></figure><h4 id="6-2-1-错误码-Error-Codes"><a href="#6-2-1-错误码-Error-Codes" class="headerlink" title="6.2.1 错误码 Error Codes"></a><strong>6.2.1 错误码 Error Codes</strong></h4><p>&emsp;&emsp;当一个请求失败时，资源服务器使用恰当的HTTP状态码（典型的如400、401或403）进行响应，并且在响应中包含下列错误码之一：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invalid_request</span><br><span class="line">    请求缺少某个必需参数，包含一个不支持的参数或参数值，参数重复，使用多种方式包含访问令牌，或者请求格式不正确。资源服务器应该使用HTTP <span class="number">400</span>（Bad Request）状态码进行响应。</span><br><span class="line">invalid_token</span><br><span class="line">    提供的访问令牌是过期的、已撤销的、格式不正确的，或由于其它原因是无效的。资源服务器应该使用HTTP <span class="number">401</span>（Unauthorized）状态码进行响应。客户端可能请求一个新的访问令牌并重试受保护资源请求。</span><br><span class="line">insufficient_scope</span><br><span class="line">    请求需要比访问令牌所提供的权限更高的权限。资源服务器应该使用HTTP <span class="number">403</span>（Forbidden）状态码进行响应并且包含“scope”属性，带上访问该受保护资源必需的作用域。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;[[增加扩展错误码的机制]]</p><p>&emsp;&emsp;如果请求中缺少任何验证信息（即客户端没有意识到验证是必需的或尝试使用一个不支持的验证方法），那么资源服务器不应该包含一个错误码和其它错误信息。</p><p>&emsp;&emsp;例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: OAuth2</span><br></pre></td></tr></table></figure><hr><h2 id="第七节-扩展-Extensibility"><a href="#第七节-扩展-Extensibility" class="headerlink" title="第七节 扩展 Extensibility"></a><strong>第七节 扩展 Extensibility</strong></h2><h3 id="7-1-定义新的客户端证书类型-Defining-New-Client-Credentials-Types"><a href="#7-1-定义新的客户端证书类型-Defining-New-Client-Credentials-Types" class="headerlink" title="7.1 定义新的客户端证书类型 Defining New Client Credentials Types"></a><strong>7.1 定义新的客户端证书类型 Defining New Client Credentials Types</strong></h3><p>&emsp;&emsp;[[待定]]</p><h3 id="7-2-定义新的Endpoint参数-Defining-New-Endpoint-Parameters"><a href="#7-2-定义新的Endpoint参数-Defining-New-Endpoint-Parameters" class="headerlink" title="7.2 定义新的Endpoint参数 Defining New Endpoint Parameters"></a><strong>7.2 定义新的Endpoint参数 Defining New Endpoint Parameters</strong></h3><p>&emsp;&emsp;希望在终端用户授权endpoint和令牌endpoint上定义新的请求和响应参数的应用，应该使用下列两种方式之一：在参数注册表中注册（遵从9.1节描述的流程），或使用“x_”参数名前缀。</p><p>&emsp;&emsp;使用“x_”参数名前缀的参数必须局限于那些不会被广泛应用的针对厂商特性的扩展，并且特定于授权服务器使用场景的实现细节。所有其它参数必须被注册，并且一定不能使用“x_”参数名前缀。</p><p>&emsp;&emsp;参数名必须遵从param-name的ABNF，并且参数值语法必须被规范地定义（例如，使用ABNF，或者引用到现存参数的语法）。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">param-name</span>  = <span class="number">1</span>*name-char</span><br><span class="line"><span class="attribute">name-char</span>   = <span class="string">"-"</span> / <span class="string">"."</span> / <span class="string">"_"</span> / <span class="keyword">DIGIT</span> / <span class="keyword">ALPHA</span></span><br></pre></td></tr></table></figure><h3 id="7-3-定义新的头部字段参数-Defining-New-Header-Field-Parameters"><a href="#7-3-定义新的头部字段参数-Defining-New-Header-Field-Parameters" class="headerlink" title="7.3 定义新的头部字段参数 Defining New Header Field Parameters"></a><strong>7.3 定义新的头部字段参数 Defining New Header Field Parameters</strong></h3><p>&emsp;&emsp;希望在OAuth “WWW-Authenticate”头部字段中定义新参数的应用必须在参数注册表中进行注册，遵从9.1节描述的流程。</p><p>&emsp;&emsp;参数名必须遵从param-name的ABNF并且不能以“x_”开头。参数值必须遵从param-value的ABNF并且语法必须被规范地定义（例如，使用ABNF，或者引用到现存参数的语法）。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">param</span>-<span class="built_in">value</span> = quoted-<span class="built_in">value</span> | quoted-<span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="7-4-定义新的访问许可类型-Defining-New-Access-Grant-Types"><a href="#7-4-定义新的访问许可类型-Defining-New-Access-Grant-Types" class="headerlink" title="7.4 定义新的访问许可类型 Defining New Access Grant Types"></a><strong>7.4 定义新的访问许可类型 Defining New Access Grant Types</strong></h3><p>&emsp;&emsp;断言访问许可类型允许授权服务器接受其它未规定的访问许可。希望定义其它访问许可类型的应用能够通过利用新的或现存的断言类型和格式进行实现。</p><hr><h2 id="第八节-安全考虑-Security-Considerations"><a href="#第八节-安全考虑-Security-Considerations" class="headerlink" title="第八节 安全考虑 Security Considerations"></a><strong>第八节 安全考虑 Security Considerations</strong></h2><p>&emsp;&emsp;[[待定]]</p><hr><h2 id="第九节-IANA事项-IANA-Considerations"><a href="#第九节-IANA事项-IANA-Considerations" class="headerlink" title="第九节 IANA事项 IANA Considerations"></a><strong>第九节 IANA事项 IANA Considerations</strong></h2><h3 id="9-1-OAuth参数注册表-The-OAuth-Parameters-Registry"><a href="#9-1-OAuth参数注册表-The-OAuth-Parameters-Registry" class="headerlink" title="9.1 OAuth参数注册表 The OAuth Parameters Registry"></a><strong>9.1 OAuth参数注册表 The OAuth Parameters Registry</strong></h3><p>&emsp;&emsp;本文档设立参数注册表。</p><p>&emsp;&emsp;用于终端用户授权endpoint的请求、终端用户授权endpoint的响应、令牌endpoint的请求、令牌endpoint的响应或“WWW-Authenticate”头部字段的多余参数，在一个或多个“指派专家”（由IESG或他们的代理机构指定）的指导下进行注册，遵从所需的规范（使用[RFC5226]的术语）。然而，为了允许在发布之前对值进行分配，“指派专家”们一旦认同这样的一个规范能够发布，可能就立即批准注册。</p><p>&emsp;&emsp;注册请求应该发送给[待定]@ietf.org邮件组进行评审和讨论，使用恰当的标题（如“Request for parameter: example”）。[[RFC-EDITOR注解：邮件组名称应该在与IESG和IANA磋商后确定。建议名称：oauth-ext-review。]]</p><p>&emsp;&emsp;在14天之内，“指派专家”们会批准或拒绝注册请求，并将结果告知邮件组和IANA。拒绝的决定应该包含一个解释，并且，如果可行的话，应该包含如何进行修改的建议。在21天以上未确定的注册请求会交由IESG处理（使用<a href="mailto:iesg@iesg.org" target="_blank" rel="noopener">iesg@iesg.org</a>邮件组）。</p><h4 id="9-1-1-注册模板-Registration-Template"><a href="#9-1-1-注册模板-Registration-Template" class="headerlink" title="9.1.1 注册模板 Registration Template"></a><strong>9.1.1 注册模板 Registration Template</strong></h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Parameter</span> name: 请求的名称（例如“example”）。</span><br><span class="line"><span class="keyword">Parameter</span> <span class="comment">usage location:</span> 参数能够被使用的位置。可能的位置包括：终端用户授权<span class="comment">endpoint</span>的请求、终端用户授权<span class="comment">endpoint</span>的响应、令牌<span class="comment">endpoint</span>的请求、令牌<span class="comment">endpoint</span>的响应或“<span class="comment">WWW-Authenticate</span>”头部字段。</span><br><span class="line">Change <span class="comment">controller:</span> 对于标准轨道的<span class="comment">RFC</span>，写明“<span class="comment">IETF</span>”。对于其它规范，使用负责机构的名称。其它细节（例如，邮编地址，电子邮件地址，主页<span class="comment">URI</span>）也可以包含。</span><br><span class="line">Specification <span class="comment">document(s):</span> 对规定参数的文档引用，可取的方式是包含一个能够获取到文档拷贝的<span class="comment">URI</span>。对于相关章节的标示也可以包含</span><br><span class="line">Related <span class="comment">information:</span></span><br><span class="line">Optionally, citations <span class="comment">to additional documents containing further relevant information.</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;未完待续。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html" title="Title" target="_blank" rel="noopener">The OAuth 2.0 Protocol Framework</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      The OAuth 2.0 Protocol Framework文档翻译，内容包括：引文（符号规范、技术术语、概述、访问许可），Client Profiles（Web Server、User-Agent、原生程序、自治态），客户端私有证书（客户端密码证书、客户端断言证书），获得终端用户授权（授权请求、授权响应、错误响应），获取访问令牌（访问许可类型、访问令牌响应、错误响应），访问受保护资源（访问令牌类型、WWW-Authenticate响应头部字段），扩展（定义新的客户端证书类型、定义新的Endpoint参数、定义新的头部字段参数、定义新的访问许可类型），安全考虑，IANA事项等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="oauth2" scheme="http://linyishui.top/tags/oauth2/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Zuul API网关</title>
    <link href="http://linyishui.top/2019111401.html"/>
    <id>http://linyishui.top/2019111401.html</id>
    <published>2019-11-14T09:35:25.000Z</published>
    <updated>2019-12-23T09:38:33.504Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-Zuul-API网关"><a href="#Spring-Cloud-Zuul-API网关" class="headerlink" title="Spring Cloud-Zuul API网关"></a><strong>Spring Cloud-Zuul API网关</strong></h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节 "></a><strong>第一节 </strong></h2><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud Zuul API网关
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Hystrix 服务容错处理</title>
    <link href="http://linyishui.top/2019111301.html"/>
    <id>http://linyishui.top/2019111301.html</id>
    <published>2019-11-13T09:35:16.000Z</published>
    <updated>2019-12-23T09:38:22.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-Hystrix-服务容错处理"><a href="#Spring-Cloud-Hystrix-服务容错处理" class="headerlink" title="Spring Cloud-Hystrix 服务容错处理"></a><strong>Spring Cloud-Hystrix 服务容错处理</strong></h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节 "></a><strong>第一节 </strong></h2><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud Hystrix 服务容错处理
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Feign 声明式REST客户端</title>
    <link href="http://linyishui.top/2019111201.html"/>
    <id>http://linyishui.top/2019111201.html</id>
    <published>2019-11-12T09:35:08.000Z</published>
    <updated>2019-12-23T09:38:12.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-Feign-声明式REST客户端"><a href="#Spring-Cloud-Feign-声明式REST客户端" class="headerlink" title="Spring Cloud-Feign 声明式REST客户端"></a><strong>Spring Cloud-Feign 声明式REST客户端</strong></h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节 "></a><strong>第一节 </strong></h2><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud Feign 声明式REST客户端
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Ribbon 客户端负载均衡</title>
    <link href="http://linyishui.top/2019111101.html"/>
    <id>http://linyishui.top/2019111101.html</id>
    <published>2019-11-11T09:32:58.000Z</published>
    <updated>2019-12-23T09:38:04.391Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-Ribbon-客户端负载均衡"><a href="#Spring-Cloud-Ribbon-客户端负载均衡" class="headerlink" title="Spring Cloud-Ribbon 客户端负载均衡"></a><strong>Spring Cloud-Ribbon 客户端负载均衡</strong></h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节 "></a><strong>第一节 </strong></h2><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud Ribbon 客户端负载均衡
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Eureka 注册中心</title>
    <link href="http://linyishui.top/2019111001.html"/>
    <id>http://linyishui.top/2019111001.html</id>
    <published>2019-11-10T09:30:48.000Z</published>
    <updated>2019-12-24T10:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-Eureka-注册中心"><a href="#Spring-Cloud-Eureka-注册中心" class="headerlink" title="Spring Cloud-Eureka 注册中心"></a><strong>Spring Cloud-Eureka 注册中心</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;Eureka是Spring Cloud Netflix微服务套件的一部分，基于Netflix Eureka做了二次封装，主要负责实现微服务架构中的服务治理功能。Eureka是一个基于REST的服务，并且提供了基于Java的客户端组件，可以非常方便的将服务注册到Eureka中进行统一管理。</p><p>&emsp;&emsp;<strong>服务治理</strong>：服务治理是微服务架构中不可缺少的一部分，如阿里的Dubbo框架也是针对服务治理的，而<strong>服务治理必须有一个注册中心</strong>，除了Eureka还可以使用Consul、Etcd、Zookeeper等来作为注册中心。Dubbo中也有几种注册中心，如基于Zookeeper或基于Redis等，Dubbo主要使用ZooKeeper，而Spring Cloud首选Eureka。</p><p>&emsp;&emsp;<strong>注册中心无非就是管理所有服务的信息和状态</strong>。比如我们可以把12306当作一个注册中心，顾客就相当于调用的客户端，当需要坐车时就登陆12306查询余票，邮票就购买，然后获取火车的车次等信息，最后出发。程序也一样，当需要调用某一个服务时，会先去Eureka中取拉取服务表，查看要调用的服务在不在其中，有的话就拿到服务地址、端口等信息，然后调用。</p><p>&emsp;&emsp;使用<strong>注册中心的好处</strong>是，我们不需要关注提供方，只需关注注册中心即可，就像乘客不必关心有多少火车，只需去12306上看有没有票即可。</p><blockquote><p><strong>为什么说Eureka比Zookeeper更适合作为注册中心？</strong><br>&emsp;&emsp;因为Eureka是基于AP原则构建的，而ZooKeeper是基于CP原则构建的。</p></blockquote><p>&emsp;&emsp;在分布式领域有个著名的CAP定理：即C为数据一致性，A为服务可用性，P为服务对网络分区故障的容错性。这三个特性在任何分布式系统中都不能同时满足，最多同时满足两个。</p><p>&emsp;&emsp;ZooKeeper有一个Leader，在Leader无非使用时通过Paxos(ZAB)算法选举出一个新的Leader。这个Leader的任务就是保证写数据的时候只向这个Leader写入，Leader会同步信息到其他节点，所以通过这个操作可以保证数据的一致性。</p><hr><h2 id="第二节-实战"><a href="#第二节-实战" class="headerlink" title="第二节 实战"></a><strong>第二节 实战</strong></h2><h3 id="2-1-搭建Eureka-Server"><a href="#2-1-搭建Eureka-Server" class="headerlink" title="2.1 搭建Eureka Server"></a><strong>2.1 搭建Eureka Server</strong></h3><p>&emsp;&emsp;新建一个Maven项目，在pom中配置Eureka依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Eureka --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- Spring Cloud --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在启动类中使用注解@EnableEurekaServer，表示开启Eureka Server。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@EnableEurekaServer</span></span><br><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line">public class EurekaServerApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在配置文件中添加如下配置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.<span class="attribute">name</span>=eureka-server</span><br><span class="line">server.<span class="attribute">port</span>=8761</span><br><span class="line"><span class="comment"># 此应用为注册中心，所以不需要再注册自己</span></span><br><span class="line">eureka.client.<span class="attribute">register-with-eureka</span>=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 注册中心职责即维护服务实例，不需要再检索服务</span></span><br><span class="line">eureka.client.<span class="attribute">fetch-registry</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动并访问<a href="http://localhost:8761/，便可以看到Eureka提供的控制台。" target="_blank" rel="noopener">http://localhost:8761/，便可以看到Eureka提供的控制台。</a></p><h3 id="2-2-创建服务提供者"><a href="#2-2-创建服务提供者" class="headerlink" title="2.2 创建服务提供者"></a><strong>2.2 创建服务提供者</strong></h3><p>&emsp;&emsp;接下来实现一个服务提供者eureka-client-user-service，将其注册到Eureka中，并提供一个接口给其他服务调用。</p><p>&emsp;&emsp;新建一个Maven项目，在pom中配置相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Eureka --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Spring Cloud --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在启动类中使用注解@EnableDiscoveryClient，表示当前服务是Eureka的一个客户端。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@EnableDiscoveryClient</span></span><br><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line">public class EurekaClientUserServiceApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(EurekaClientUserServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在配置文件中添加如下配置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="attribute">port</span>=8081</span><br><span class="line">spring.application.<span class="attribute">name</span>=eureka-client-user-service</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.<span class="attribute">defaultZone</span>=http://localhost:8761/eureka</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用IP注册</span></span><br><span class="line">eureka.instance.<span class="attribute">prefer-ip-address</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 采用实例ID格式</span></span><br><span class="line">eureka.instance.<span class="attribute">instance-id</span>=<span class="variable">$&#123;spring.application.name&#125;</span>:$&#123;spring.cloud.client.ip-address&#125;:<span class="variable">$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动服务，控制台会输出注册信息的日志：-redistration status等，回到Eureka控制台并刷新页面，会发现出现了新注册的服务信息。</p><p>&emsp;&emsp;在客户端新建一个接口，重启服务并访问<a href="http://localhost:8081/user/hello。" target="_blank" rel="noopener">http://localhost:8081/user/hello。</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/user/hello"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String hello()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-创建服务消费者"><a href="#2-3-创建服务消费者" class="headerlink" title="2.3 创建服务消费者"></a><strong>2.3 创建服务消费者</strong></h3><p>&emsp;&emsp;接下来实现一个服务消费者eureka-client-article-service，消费刚刚创建的hello接口。</p><p>&emsp;&emsp;依赖和启动类与上一个service相同，配置信息略有不同。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="attribute">port</span>=8082</span><br><span class="line">spring.application.<span class="attribute">name</span>=eureka-client-article-service</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Spring提供了用于访问Rest服务的客户端：RestTemplate。RestTemplate提供了一系列便捷访问远程HTTP服务的方法，可以大大提高客户端的编写效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;创建接口并调用hello接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/article/callHello"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String callHello()&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://localhost:8081/user/hello"</span>,String.<span class="keyword">class</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动服务，并访问/article/callHello查看是否有返回hello。</p><p>&emsp;&emsp;上述调用接口是直接通过服务接口的地址来调用的，既然使用了注册中心，消费者就不在需要知道由哪些服务提供接口，我们可以改写代码如下。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line">public class BeanConfig &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LoadBalanced会自动构造LoadBalancerClient接口的实现类到Spring容器</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    <span class="variable">@LoadBalanced</span></span><br><span class="line">    public RestTemplate getRestTemplate()&#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Eureka来消费接口</span></span><br><span class="line">    @<span class="selector-tag">RequestMapping</span>(<span class="string">"/article/callHello2"</span>)</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">callHello2</span>()&#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">restTemplate</span><span class="selector-class">.getForObject</span>(<span class="string">"http://eureka-client-user-service/user/hello"</span>,String.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Eureka不在使用固定地址，而是服务注册到Eureka的名称，对应服务的spring.application.name，即eureka-client-user-service。</p><h3 id="2-4-开启Eureka认证"><a href="#2-4-开启Eureka认证" class="headerlink" title="2.4 开启Eureka认证"></a><strong>2.4 开启Eureka认证</strong></h3><p>&emsp;&emsp;Eureka自带的Web管理页面可以帮助我们查询注册的实例信息，但如果在实际使用中，注册中心地址有公网IP的话，必然能直接访问到，这样是不安全的，所以我们要<strong>通过加权限认证来保证安全性</strong>。</p><p>&emsp;&emsp;添加security依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- security --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;配置文件中添加认证信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Security 用户名</span></span><br><span class="line">spring.security.user.<span class="attribute">name</span>=linyishui</span><br><span class="line"><span class="comment"># Security 密码</span></span><br><span class="line">spring.security.user.<span class="attribute">password</span>=123456</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;增加配置类。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@EnableWebSecurity</span></span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        <span class="comment">//关闭csrf</span></span><br><span class="line">        <span class="selector-tag">http</span><span class="selector-class">.csrf</span>()<span class="selector-class">.disable</span>();</span><br><span class="line">        <span class="comment">//支持httpBasic</span></span><br><span class="line">        <span class="selector-tag">http</span><span class="selector-class">.authorizeRequests</span>()</span><br><span class="line">                <span class="selector-class">.anyRequest</span>()</span><br><span class="line">                <span class="selector-class">.authenticated</span>()</span><br><span class="line">                <span class="selector-class">.and</span>()</span><br><span class="line">                <span class="selector-class">.httpBasic</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重启注册中心，并访问<a href="http://localhost:8761/，此时浏览器会提示输入账户密码。" target="_blank" rel="noopener">http://localhost:8761/，此时浏览器会提示输入账户密码。</a></p><p>&emsp;&emsp;开启认证后，客户端注册的配置也要添加认证的用户名和密码。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 添加Security</span></span><br><span class="line">eureka.<span class="keyword">client</span>.service-url.defaultZone=http:<span class="comment">//linyishui:123456@localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><hr><h2 id="第三节-高可用搭建"><a href="#第三节-高可用搭建" class="headerlink" title="第三节 高可用搭建"></a><strong>第三节 高可用搭建</strong></h2><h3 id="3-1-高可用原理"><a href="#3-1-高可用原理" class="headerlink" title="3.1 高可用原理"></a><strong>3.1 高可用原理</strong></h3><p>&emsp;&emsp;</p><h3 id="3-2-Eureka高可用搭建"><a href="#3-2-Eureka高可用搭建" class="headerlink" title="3.2 Eureka高可用搭建"></a><strong>3.2 Eureka高可用搭建</strong></h3><p>&emsp;&emsp;我们已搭建的注册中心只适合于本地开发使用，在生产环境中必须搭建一个集群来保证高可用。Eureka搭建集群的方法很简单：每一台Eureka只需要在配置中指定另外多个Eureka的地址即可。</p><p>&emsp;&emsp;假设我们有master和slaveone两台机器，我们要做的就是把master注册到slaveone上，以及把slaveone注册到master上。</p><p>&emsp;&emsp;新建项目eureka-server-cluster，搭建步骤和前面相同，增加两个属性文件：application-master.properties和application-slaveone.properties</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application-master.properties中添加</span></span><br><span class="line">server.<span class="attribute">port</span>=9999</span><br><span class="line">eureka.client.service-url.<span class="attribute">defaultZone</span>=http://linyishui:123456@localhost:9998/eureka</span><br><span class="line"><span class="comment"># application-slaveone.properties中添加</span></span><br><span class="line">server.<span class="attribute">port</span>=9998</span><br><span class="line">eureka.client.service-url.<span class="attribute">defaultZone</span>=http://linyishui:123456@localhost:9999/eureka</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后在application.properties中添加以下内容。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring.application.<span class="attribute">name</span>=eureka-server-cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此应用为注册中心，所以不需要再注册自己</span></span><br><span class="line">eureka.client.<span class="attribute">register-with-eureka</span>=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 注册中心职责即维护服务实例，不需要再检索服务</span></span><br><span class="line">eureka.client.<span class="attribute">fetch-registry</span>=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Security 用户名</span></span><br><span class="line">spring.security.user.<span class="attribute">name</span>=linyishui</span><br><span class="line"><span class="comment"># Security 密码</span></span><br><span class="line">spring.security.user.<span class="attribute">password</span>=123456</span><br><span class="line"></span><br><span class="line"><span class="comment">#环境配置</span></span><br><span class="line"><span class="comment">#部署时通过java -jar xxx.jar --spring.profiles.active=dev来指定所用配置</span></span><br><span class="line">spring.profiles.<span class="attribute">active</span>=master</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样在A机器中通过默认master启动，在B机器上添加–spring.profiles.active=slaveone启动。这样无论哪台机器上出问题，都可以继续使用存活的注册中心。</p><p>&emsp;&emsp;然后在客户端中指定多个注册中心。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个节点</span></span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="regexp">//</span>linyishui:<span class="number">123456</span>@localhost:<span class="number">9999</span><span class="regexp">/eureka,http:/</span><span class="regexp">/linyishui:123456@localhost:9998/</span>eureka</span><br></pre></td></tr></table></figure><hr><h2 id="第四节-常用配置"><a href="#第四节-常用配置" class="headerlink" title="第四节 常用配置"></a><strong>第四节 常用配置</strong></h2><h3 id="4-1-关闭自我保护"><a href="#4-1-关闭自我保护" class="headerlink" title="4.1 关闭自我保护"></a><strong>4.1 关闭自我保护</strong></h3><p>&emsp;&emsp;保护模式主要用于在一组客户端和Eureka Server之间存在网络分区场景时使用。一旦进入保护模式，Eureka Server会尝试保护其服务的注册表中的信息，不再删除其中数据。当网络故障恢复后，此Eureka Server节点会自动退出保护模式。可以通过以下配置关闭自我保护模式。 </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 关闭自我保护模式</span></span><br><span class="line">eureka.<span class="keyword">server</span>.enableSelfPreservation=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="4-2-自定义Eureka的InstanceID"><a href="#4-2-自定义Eureka的InstanceID" class="headerlink" title="4.2 自定义Eureka的InstanceID"></a><strong>4.2 自定义Eureka的InstanceID</strong></h3><p>&emsp;&emsp;客户端注册时，服务的默认InstanceID格式如下，即“主机名：服务名：服务端口”。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;spring<span class="selector-class">.cloud</span><span class="selector-class">.client</span><span class="selector-class">.hostname</span>&#125;:$&#123;spring<span class="selector-class">.application</span><span class="selector-class">.name</span>&#125;:$&#123;spring<span class="selector-class">.cloud</span><span class="selector-class">.client</span><span class="selector-class">.instance_id</span>:$&#123;server.port&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有时我们会想把IP显示在InstanceID中，可以改为如下格式。</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka.instance.instance-id=$&#123;<span class="attribute">spring.application.name&#125;</span>:$&#123;spring<span class="variable">.cloud</span><span class="variable">.client</span><span class="variable">.ip-address</span>&#125;:$&#123;server<span class="variable">.port</span>&#125;</span><br><span class="line"></span><br><span class="line"># 使跳转链接也显示IP</span><br><span class="line">eureka<span class="variable">.instance</span><span class="variable">.prefer-ip-address</span>=true</span><br></pre></td></tr></table></figure><h3 id="4-3-自定义实例跳转链接"><a href="#4-3-自定义实例跳转链接" class="headerlink" title="4.3 自定义实例跳转链接"></a><strong>4.3 自定义实例跳转链接</strong></h3><p>&emsp;&emsp;我们实现了IP进行注册，跳转时默认地址为：IP+PORT/info，我们也可以自定义这个跳转的地址。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义实例跳转链接</span></span><br><span class="line">eureka.instance.<span class="attribute">status-page-url</span>=http:/www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="4-4-快速移除已经失效的服务信息"><a href="#4-4-快速移除已经失效的服务信息" class="headerlink" title="4.4 快速移除已经失效的服务信息"></a><strong>4.4 快速移除已经失效的服务信息</strong></h3><p>&emsp;&emsp;实际开发中，我们可能会不停的重启服务，由于Eureka的保护机制，节点下线后其服务信息还会一直存在于Eureka中。我们可以通过配置来让移除的速度加快，当然这只推荐在开发环境下使用，生产环境不建议这样配置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭自我保护模式</span></span><br><span class="line">eureka.server.<span class="attribute">enableSelfPreservation</span>=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 修改移除服务信息频率，默认60000毫秒</span></span><br><span class="line">eureka.server.<span class="attribute">eviction-interval-timer-in-ms</span>=5000</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在客户端中添加如下配置。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启健康检查</span></span><br><span class="line">eureka.client.healthcheck.<span class="attribute">enabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Eureka Client发送心跳频率给Server的频率，默认 30 秒</span></span><br><span class="line">eureka.instance.<span class="attribute">lease-renewal-interval-in-seconds</span>=5</span><br><span class="line"><span class="comment"># Eureka Server至上一次收到client的心跳后，等待下一次心跳的超时时间，在这个时间内若没有收到下一次心跳，则移除该Instance，默认 90 秒</span></span><br><span class="line">eureka.instance.<span class="attribute">lease-expiration-duration-in-seconds</span>=5</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;开启健康检查需要引入actuator依赖。</p><hr><h2 id="第五节-扩展"><a href="#第五节-扩展" class="headerlink" title="第五节 扩展"></a><strong>第五节 扩展</strong></h2><h3 id="5-1-Eureka-REST-API"><a href="#5-1-Eureka-REST-API" class="headerlink" title="5.1 Eureka REST API"></a><strong>5.1 Eureka REST API</strong></h3><p>&emsp;&emsp;Eureka作为注册中心其本质是存储了每个客户端的注册信息，Ribbon在转发的时候会获取注册中心的服务列表，然后根据对应的路由规则来选择一个服务给Feign进行调用。</p><p>&emsp;&emsp;Eureka提供了REST API来让我们调用去获取如服务注册信息等常用数据，在我们不选用Spring Cloud技术栈仍要使用Eureka时会比较有用。</p><p>&emsp;&emsp;举个例子如对Nginx动态进行upstream的配置：在架构变成微服务之后，微服务是没有依赖的，可以独立部署，端口也可以随机分配，反正会注册到注册中心，调用方也无需关心提供方的IP和Port。但API网关的部署可以这样吗？API网关大部分会用Nginx作为负载，所以Nginx必须知道API网关又哪几个节点，这样网关服务就不能随便启动了，而是需要固定。当然网关不会经常变动，也不会经常发布，唯一不好的地方是不能自动扩容。</p><p>&emsp;&emsp;其实利用Eureka提供的API我们可以获取某个服务的实例信息，也就是说我们可以根据Eureka中的数据动态配置Nginx的upstream。这样就可以实现网关的自动部署和扩容了，当然也有很多方案：Lua脚本或自己实现Sheel脚本等。</p><p>&emsp;&emsp;Eureka的相关接口信息可以查看官方文档：<a href="https://github.com/Netfix/eureka/wiki/Eureka-REST-operations" target="_blank" rel="noopener">https://github.com/Netfix/eureka/wiki/Eureka-REST-operations</a></p><p>&emsp;&emsp;获取某个服务的注册信息，可以直接GET请求：<a href="http://localhost:8761/eureka/apps/eureka-client-user-service。浏览器中返回数据的默认格式是XML，如果想要获取Json格式的数据，可以尝试使用如Postman等接口测试工具，在请求头添加以下两行即可。" target="_blank" rel="noopener">http://localhost:8761/eureka/apps/eureka-client-user-service。浏览器中返回数据的默认格式是XML，如果想要获取Json格式的数据，可以尝试使用如Postman等接口测试工具，在请求头添加以下两行即可。</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>:application/json </span><br><span class="line"><span class="keyword">Accept</span>:application/json</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果Eureka开启了认证，记得添加认证信息，用户密码必须是Base64编码过的Authorization:Basic 用户名:密码。Postman支持Basic认证，将选项从Headers切换到Authorization，选择认证方式为Basic Auth就可以填写用户信息了。填写完直接发起请求。</p><h3 id="5-2-元数据使用"><a href="#5-2-元数据使用" class="headerlink" title="5.2 元数据使用"></a><strong>5.2 元数据使用</strong></h3><p>&emsp;&emsp;Eureka的元数据有两种类型，分别是框架制订的<strong>标准元数据</strong>和<strong>用户自定义元数据</strong>。标准元数据指的是：主机名、IP地址、端口号、状态页、健康检查等信息，这些信息会被发布在服务注册表中，用于服务间的调用。自定义元数据可以使用eureka.instance.metadataMap进行配置。</p><p>&emsp;&emsp;自定义元数据可以用来做一些扩展信息，比如灰度发布之类的功能，可以用元数据来存储灰度发布的状态数据，Ribbon转发的时候就可以根据服务的元数据来做一些处理。当不需要灰度发布的时候可以调用Eureka提供的REST API将元数据清除掉。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka<span class="selector-class">.instance</span><span class="selector-class">.metadataMap</span><span class="selector-class">.a</span>=b</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此配置定义了一个key为a的配置，value为b。重启服务，然后通过Eureka提供的RET API来查看刚刚配置的元数据是否已存在与Eureka中。</p><h3 id="5-3-EurekaClient使用"><a href="#5-3-EurekaClient使用" class="headerlink" title="5.3 EurekaClient使用"></a><strong>5.3 EurekaClient使用</strong></h3><p>&emsp;&emsp;我们可以使用EurekaClient来获取一些我们想要的数据，比如上面自定义的元数据可以直接通过EurekaClient来获取，而不用再调用Eureka REST API。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/article/infos"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">serviceUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> eurekaClient.<span class="title">getInstanceByVipAddress</span><span class="params">(<span class="string">"eureka-client-user-service"</span>, <span class="keyword">false</span>)</span></span>;</span><br><span class="line"><span class="comment">//  return discoveryClient.getInstances("eureka-client-user-service");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了EurekaClient，也可以使用DiscoveryClient，这个是Spring Cloud重新封装的类。</p><h3 id="5-4-健康检查"><a href="#5-4-健康检查" class="headerlink" title="5.4 健康检查"></a><strong>5.4 健康检查</strong></h3><p>&emsp;&emsp;默认情况下，Eureka通过心跳和服务端通信来判断客户端是否存活，在某些场景下，比如MongoDB出现了异常，但你的应用进程还是存在的，这就意味着应用会继续通过心跳上报。</p><p>&emsp;&emsp;Spring Boot Actuator提供的/actuator/health端点可以展示应用程序的健康信息，当MongoDB出现异常，端点状态变为DOWN。这时我们希望可以将健康信息传递给Eureka服务端，这样Eureka就可以把应用的实例信息下线，隔离正常请求以防止出错。通过以下配置开启健康检查。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka<span class="selector-class">.client</span><span class="selector-class">.healthcheck</span><span class="selector-class">.enable</span>=true</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;扩展健康检查端点来模拟异常。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CustomHealthIndicator</span> <span class="keyword">extends</span> <span class="title">AbstractHealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doHealthCheck(<span class="type">Health</span>.<span class="type">Builder</span> builder) &#123;</span><br><span class="line">        builder.down().withDetail(<span class="string">"status"</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问/actuator/health发现现在状态是DOWN，但此时Eureka中的状态还是UP。通过配置开启监控检查，再重启后发现已修改为DOWN。</p><h3 id="5-5-服务上下线监控"><a href="#5-5-服务上下线监控" class="headerlink" title="5.5 服务上下线监控"></a><strong>5.5 服务上下线监控</strong></h3><p>&emsp;&emsp;有时我们想要对服务的上线和下限进行监控，并通过邮件通知。</p><blockquote><p>Eureka提供了事件监听的方式来扩展：</p><ul><li>EurekaInstanceCanceledEvent：服务下线事件</li><li>EurekaInstanceRegisteredEvent：服务注册事件</li><li>EurekaInstanceRenewedEvent：服务续约事件</li><li>EurekaRegistryAvailableEvent：Eureka 注册中心启动事件</li><li>EurekaServerStartedEvent：Eureka Server启动事件</li></ul></blockquote><p>&emsp;&emsp;如下代码演示了监控的过程，但未发送邮件。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EurekaStateChangeListener</span> &#123;</span><br><span class="line">    @EventListener</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span>(<span class="params">EurekaInstanceCanceledEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">event</span>.getSeverId() + <span class="string">"\t"</span> + <span class="keyword">event</span>.getAppName() + <span class="string">" 服务下线 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventListener</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span>(<span class="params">EurekaInstanceRegisteredEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">        InstanceInfo instanceInfo = <span class="keyword">event</span>.getInstanceInfo();</span><br><span class="line">        System.<span class="keyword">out</span>.println(instanceInfo.getAppName() + <span class="string">" 进行注册 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventListener</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span>(<span class="params">EurekaInstanceRenewedEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">event</span>.getSeverId() + <span class="string">"\t"</span> + <span class="keyword">event</span>.getAppName() + <span class="string">" 服务进行续约 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventListener</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span>(<span class="params">EurekaRegistryAvailableEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">" 注册中心 启动 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventListener</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span>(<span class="params">EurekaServerStartedEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">" Eureka Server 启动 "</span>);</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Eureka集群的环境下，每个节点都会触发事件，这时需要控制下发送通知的行为，不然每个节点都会发送通知。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud Eureka 注册中心
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="http://linyishui.top/2019110901.html"/>
    <id>http://linyishui.top/2019110901.html</id>
    <published>2019-11-09T02:02:13.000Z</published>
    <updated>2019-12-23T09:29:01.676Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a><strong>SpringBoot入门</strong></h1><h2 id="第一节-Spring-Boot-简介"><a href="#第一节-Spring-Boot-简介" class="headerlink" title="第一节 Spring Boot 简介"></a><strong>第一节 Spring Boot 简介</strong></h2><p>&emsp;&emsp;Spring Boot设计目的是为了简化Spring应用的初始搭建和开发过程，；</p><h3 id="1-1-功能"><a href="#1-1-功能" class="headerlink" title="1.1 功能"></a><strong>1.1 功能</strong></h3><blockquote><ul><li><strong>快速搭建</strong>：习惯优于配置，搭建项目过程简单，可以一分钟即完成初始配置。 </li><li><strong>独立运行</strong>：单独Spring Boot项目以jar包方式独立运行。</li><li><strong>内嵌Servlet</strong>：可以使用内嵌的Tomcat、Jetty或Undertow，项目可以直接启动而无需再通过war包部署在应用服务器中。</li><li><strong>Starter简化配置</strong>：通过Starter轻松集成第三方框架，而不需再一个个的管理第三方依赖。</li><li><strong>自动配置</strong>：通过starter pom，Spring Boot会自动配置绝大部分需要的Bean。</li><li><strong>应用监控</strong>：提供基于http、ssh、telnet对运行时项目进行监控。</li><li><strong>注解代替XML</strong>：取消XML配置的方式，完全用注解代替。</li></ul></blockquote><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a><strong>1.2 优点</strong></h3><blockquote><ul><li>快速搭建项目</li><li>无配置集成</li><li>项目可独立运行</li><li>提高了开发、部署效率</li><li>与微服务和云计算的适配</li><li>运行时应用监控</li><li>轻松集成Spring系列框架</li></ul></blockquote><h3 id="1-3-启动类"><a href="#1-3-启动类" class="headerlink" title="1.3 启动类"></a><strong>1.3 启动类</strong></h3><p>&emsp;&emsp;通过注解@SpringBootApplication表示此类是Spring Boot应用入口，main函数是入口方法。只需要执行main方法便可以启动一个Web服务，相比旧的Spring要简单和安全很多。</p><h3 id="1-4-配置文件"><a href="#1-4-配置文件" class="headerlink" title="1.4 配置文件"></a><strong>1.4 配置文件</strong></h3><p>&emsp;&emsp;Spring Boot采用一个全局配置文件：application.properties或application.yml，取代繁琐的XML配置文件。</p><blockquote><p>读取配置文件的方式有三种：</p><ul><li>Environment，通过其getProperty方法读取配置信息。</li><li>@Value，通过注解获取配置信息。</li><li>自定义配置类，使用@ConfigurationProperties注解，参数prefix对应配置的前缀，通过类的getter获取配置信息。</li></ul></blockquote><h3 id="1-5-profiles多环境"><a href="#1-5-profiles多环境" class="headerlink" title="1.5 profiles多环境"></a><strong>1.5 profiles多环境</strong></h3><p>&emsp;&emsp;项目开发中会部署到测试和生产环境，往往每个环境对应的数据库等信息都是不同的，通过profile激活不同环境下的配置文件从而灵活应对环境的改变。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=dev</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分别创建application.properties、application-dev.properties、application-test.properties、application-prod.properties创建不同环境下的配置文件，application.properties是全局配置不区分环境。</p><h3 id="1-6-日志"><a href="#1-6-日志" class="headerlink" title="1.6 日志"></a><strong>1.6 日志</strong></h3><p>&emsp;&emsp;Spring Boot支持Java Util Logging、Log4J、Log4J2和Logback作为日志框架，默认使用Logback。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging<span class="selector-class">.level</span><span class="selector-class">.root</span>=info</span><br></pre></td></tr></table></figure><h3 id="1-7-热部署"><a href="#1-7-热部署" class="headerlink" title="1.7 热部署"></a><strong>1.7 热部署</strong></h3><p>&emsp;&emsp;通过devtools可以实现热部署功能，自动重新加载改动的部分。Idea启动热部署需要开启自动编译功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-8-统一异常处理"><a href="#1-8-统一异常处理" class="headerlink" title="1.8 统一异常处理"></a><strong>1.8 统一异常处理</strong></h3><p>&emsp;&emsp;项目中对异常的处理机制的设计一般会统一定义一组错误编码，一种固定的异常消息格式，我们往往需要在开发过程中手动的实现异常的捕获和处理。Spring Boot应用可以@ControllerAdvice注解实现一个全局异常处理类，即使是发生一些系统异常也可以进行自定义处理，当然也刻意统一记录异常日志。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> ResponseData defaultErrorHandler(HttpServletRequest req,Exception e)throws Exception&#123;</span><br><span class="line">        logger.error(<span class="string">"捕获"</span>,e);</span><br><span class="line">        ResponseData <span class="keyword">data</span>;</span><br><span class="line">        <span class="keyword">if</span>(e instanceof NoHandlerFoundException)&#123;</span><br><span class="line">            <span class="keyword">data</span> = new ResponseData(HttpStatus.NOT_FOUND.value(),<span class="string">"未找到请求路径"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">data</span> = new ResponseData(HttpStatus.INTERNAL_SERVER_ERROR.value(),<span class="string">"未知错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一返回格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> boolean status;</span><br><span class="line">    <span class="keyword">private</span> int code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">data</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ResponseData(Integer code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ResponseData(Integer code, String msg, Object <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-异步执行"><a href="#1-9-异步执行" class="headerlink" title="1.9 异步执行"></a><strong>1.9 异步执行</strong></h3><p>&emsp;&emsp;通常Java开发使用异步操作要创建一个新线程，虽然Java引入了流和Lambda表达式来对多线程进行简化和优化，但仍显得不是那么优雅。而在Spring Boot中只需要一个注解@Async就可以实现异步代码，然后在Controller中调用就是异步执行的（调用者一定要是外部类），最后在启动类上通过注解@EnableAsync开启即可。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也可以通过配置类来对线程池进行管理和自定义</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.task.pool"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThreadPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 线程池维护线程所允许的空闲时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds = <span class="number">60</span>;</span><br><span class="line">    <span class="comment">// 队列长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 线程名称前缀</span></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix = <span class="string">"LAI-AsyncTask-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskExecutePool</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(AsyncTaskExecutePool.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskThreadPoolConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(config.getCorePoolSize());</span><br><span class="line">        executor.setMaxPoolSize(config.getMaxPoolSize());</span><br><span class="line">        executor.setQueueCapacity(config.getQueueCapacity());</span><br><span class="line">        executor.setKeepAliveSeconds(config.getKeepAliveSeconds());</span><br><span class="line">        executor.setThreadNamePrefix(config.getThreadNamePrefix());</span><br><span class="line">        <span class="comment">//线程池拒绝策略，当线程数量太大，任务会被缓存到本地队列，超过队列大小时就需要拒绝策略</span></span><br><span class="line">        <span class="comment">//AbortPolicy-直接抛出异常RejectedExecutionHandler</span></span><br><span class="line">        <span class="comment">//CallerRunsPolicy-主线程直接执行此任务，执行完后尝试添加下一任务到线程池，这样可以有效降低向线程场添加任务的速度</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncUncaughtExceptionHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable throwable, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//异步任务异常处理</span></span><br><span class="line">                logger.<span class="keyword">error</span>(<span class="string">"============"</span> + throwable.getMessage() + <span class="string">"============"</span>,throwable);</span><br><span class="line">                logger.<span class="keyword">error</span>(<span class="string">"exception method:"</span> + method.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程池配置有两种拒绝策略：</p><ul><li>AbortPolicy：直接抛出java.util.RejectExecutionException异常</li><li>CallerRunsPolicy：主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，这样可以有效降低向线程池内添加任务的速度</li></ul></blockquote><p>&emsp;&emsp;建议使用CallerRunsPolicy，因为当队列任务满了以后，如果直接抛出异常，这个任务就会被丢弃，而CallerRunsPolicy策略则会用主线程去执行，也就是同步执行。</p><h3 id="1-10-随机端口"><a href="#1-10-随机端口" class="headerlink" title="1.10 随机端口"></a><strong>1.10 随机端口</strong></h3><p>&emsp;&emsp;开发项目时端口号往往是确定的，但如果一个服务想要启动多个实例，特别是在Spring Cloud中，服务要注册到注册中心，为了使服务能够随时扩容，在启动时能生成一个随机端口是很重要的。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class StartCommand &#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(StartCommand.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StartCommand(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">        Boolean isServerPort = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">String</span> serverPort = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//判断是否指定端口</span></span><br><span class="line">        <span class="keyword">if</span>(args != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">String</span> arg : args)&#123;</span><br><span class="line">                <span class="keyword">if</span>(StringUtils.hasText(arg) &amp;&amp; arg.startsWith(<span class="string">"--server.port"</span>))&#123;</span><br><span class="line">                    isServerPort = <span class="keyword">true</span>;</span><br><span class="line">                    serverPort = arg;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有指定端口，则随机生成一个可用端口</span></span><br><span class="line">        <span class="keyword">if</span>(!isServerPort)&#123;</span><br><span class="line">            <span class="built_in">int</span> port = ServerPortUtils.getAvailablePort();</span><br><span class="line">            logger.info(<span class="string">"current server.port="</span> + port);</span><br><span class="line">            System.setProperty(<span class="string">"server.port"</span>,<span class="keyword">String</span>.valueOf(port));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"current server.port="</span> + serverPort.<span class="built_in">split</span>(<span class="string">"="</span>)[<span class="number">1</span>]);</span><br><span class="line">            System.setProperty(<span class="string">"server.port"</span>,serverPort.<span class="built_in">split</span>(<span class="string">"="</span>)[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class ServerPortUtils &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> getAvailablePort()&#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">65535</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = <span class="number">200</span>;</span><br><span class="line">        Random <span class="built_in">random</span> = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="built_in">int</span> port = <span class="built_in">random</span>.nextInt(<span class="built_in">max</span>)%(<span class="built_in">max</span>-<span class="built_in">min</span>+<span class="number">1</span>) + <span class="built_in">min</span>;</span><br><span class="line">        <span class="built_in">boolean</span> using = NetUtils.isLoclePortUsing(port);</span><br><span class="line">        <span class="keyword">if</span>(using)&#123;</span><br><span class="line">            <span class="keyword">return</span> getAvailablePort();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line"><span class="keyword">public</span> class IboxApplication &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">//启动参数设置</span></span><br><span class="line">        <span class="keyword">new</span> StartCommand(args);</span><br><span class="line">        SpringApplication.run(IboxApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-11-编译打包"><a href="#1-11-编译打包" class="headerlink" title="1.11 编译打包"></a><strong>1.11 编译打包</strong></h3><p>&emsp;&emsp;传统Web项目需要编译出一个war包然后部署到Tomcat等应用服务器去执行，而Spring Boot因为内嵌服务器的原因，只需要打包成jar，就可以直接通过执行java -jar命名来启动应用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打包插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>top.linyishui.ibox.IboxApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 编译插件，指定JDK版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第二节-Spring-Boot-Starter"><a href="#第二节-Spring-Boot-Starter" class="headerlink" title="第二节 Spring Boot Starter"></a><strong>第二节 Spring Boot Starter</strong></h2><p>&emsp;&emsp;用来简化jar包依赖，执行引入一个Starter，然后在属性文件配置一些值，整个集成过程就完成了。所以通过引入各种Spring Boot Starter包可以款速的搭建出一个项目的脚手架。</p><blockquote><p>常用的Spring Boot Starter如：</p><ul><li>spring-boot-starter-web：快速搭建基于Spring MVC的Web项目，使用Tomcat作为默认嵌入式容器。</li><li>spring-boot-starter-redis：操作Redis。</li><li>spring-boot-starter-mongodb：操作Mongodb。</li><li>spring-boot-starter-jpa：操作Mysql。</li><li>spring-boot-starter-activemq：操作Activemq。</li><li>……</li></ul></blockquote><h3 id="2-1-自定义Starter"><a href="#2-1-自定义Starter" class="headerlink" title="2.1 自定义Starter"></a><strong>2.1 自定义Starter</strong></h3><p>&emsp;&emsp;尝试自定义一个Starter，从而了解Starter的工作流程。</p><p>&emsp;&emsp;首先创建一个项目，并引入starter-web和lombok依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;创建一个配置类，用来在属性文件中配置值。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@ConfigurationProperties</span>(<span class="string">"spring.user"</span>)</span><br><span class="line">public class UserProperties &#123;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">name</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再定义一个客户端类，定义一个用于获取配置中值的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClient</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> UserProperties userProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserClient</span><span class="params">(UserProperties p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userProperties = p;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userProperties.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最基础的Starter包定义好了，但还不能自动构建UserClient的实例，所以我们要定义一个自动创建UserClient实例的类。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@EnableConfigurationProperties</span>(UserProperties.class)</span><br><span class="line">public class UserAutoConfigure &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    <span class="variable">@ConditionalProperty</span>(prefix = <span class="string">"spring.user"</span>, value = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line">    public UserClient userClient(UserProperties userProperties) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">UserClient</span>(userProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Spring Boot会默认扫描和启动类平级的包，如果我们的Starter和启动类不在同一个包下，如何使UserAutoConfigure生效？ 在resources下创建一个META-INF文件夹，然后创建一个spring.factories文件，文件内指定自动配置的类，Spring Boot启动时会读取此文件，根据配置激活对应的配置类。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.EnableAutoConfiguration</span>=\</span><br><span class="line">com<span class="selector-class">.xxx</span><span class="selector-class">.xxx</span><span class="selector-class">.UserAutoConfigure</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着就可以尝试在其他项目中引用这个Starter包，成功引入后就可以直接使用UserClient。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.user</span><span class="selector-class">.name</span>=xxx</span><br><span class="line">spring<span class="selector-class">.user</span><span class="selector-class">.enable</span>=true</span><br></pre></td></tr></table></figure><h3 id="2-2-使用注解开启Starter自动构建"><a href="#2-2-使用注解开启Starter自动构建" class="headerlink" title="2.2 使用注解开启Starter自动构建"></a><strong>2.2 使用注解开启Starter自动构建</strong></h3><p>&emsp;&emsp;有时我们希望由用户指定是否使用自动配置，而不是默认引入包后就要初始化，这时会如@EnableAsync这样的注解来开启调用方法异步执行的功能。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@Import</span>(&#123;UserAutoConfigure.class&#125;)</span><br><span class="line">public interface EnableUserClient&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个组合注解的核心是@Import({UserAutoConfigure.class})，通过导入的方式实现把UserAutoConfigure实例加入SpringIOC容器中，来开启自动配置。然后就可以在启动类中添加此注解来开启功能了。</p><h3 id="2-3-使用配置开启Starter自动构建"><a href="#2-3-使用配置开启Starter自动构建" class="headerlink" title="2.3 使用配置开启Starter自动构建"></a><strong>2.3 使用配置开启Starter自动构建</strong></h3><p>&emsp;&emsp;有些场景下，UserAutoConfigure需要配置多个对象，这些对象我们不希望全部配置，而是在用户指定需要开启配置时再去构建对象，可以通过@ConditionalOnProperty</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.user"</span>, value = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line">public UserClient userClient(UserProperties userProperties) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">UserClient</span>(userProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样只有启动类添加@EnableUserClient注解，并在配置文件中添加spring.user.enable=true后才会自动配置UserClient。</p><h3 id="2-4-配置Starter内容显示"><a href="#2-4-配置Starter内容显示" class="headerlink" title="2.4 配置Starter内容显示"></a><strong>2.4 配置Starter内容显示</strong></h3><p>&emsp;&emsp;在META-INF文件夹中创建spring-configuration-metadata.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"spring.user.name"</span>,</span><br><span class="line">            <span class="attr">"defaultValue"</span>: <span class="string">"cxytinadi"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"spring.user.enable"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"java.lang.Boolean"</span>,</span><br><span class="line">            <span class="attr">"defaultValue"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三节-Spring-Boot-Actuator"><a href="#第三节-Spring-Boot-Actuator" class="headerlink" title="第三节 Spring Boot Actuator"></a><strong>第三节 Spring Boot Actuator</strong></h2><p>&emsp;&emsp;Spring Boot提供了actuator模块用来监控和管理自身应用信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># actuator监控配置</span></span><br><span class="line"><span class="comment"># 显示一些详细信息</span></span><br><span class="line">management.endpoint.health.<span class="attribute">show-details</span>=always</span><br><span class="line"><span class="comment"># 暴漏一些隐藏端点，*表示所有</span></span><br><span class="line">management.endpoints.web.exposure.<span class="attribute">include</span>=health,configprops,beans,httptrace</span><br></pre></td></tr></table></figure><h3 id="3-1-自定义端点"><a href="#3-1-自定义端点" class="headerlink" title="3.1 自定义端点"></a><strong>3.1 自定义端点</strong></h3><p>&emsp;&emsp;有些时候我们需要自定义一些规则来判断应用是否健康，如果我们只是需要对应用的健康状态增加一些其他维度的数据，可以通过继承AbstractHealthIndicator来实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserHealthIndicator</span> <span class="keyword">extends</span> <span class="title">AbstractHealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doHealthCheck(<span class="type">Health</span>.<span class="type">Builder</span> builder) &#123;</span><br><span class="line">        <span class="comment">//withDetail用来添加信息</span></span><br><span class="line">        builder.up().withDetail(<span class="string">"status"</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//builder.down().withDetail("status",false);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;up方法指定应用状态为健康，down方法指定应用状态为不健康。访问/actuator/health可以得到自定义的健康状态的信息。</p><p>&emsp;&emsp;有时我们需要开发一个新的端点，比如查看当前登陆用户信息，通过@Endpoint注解来实现。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Endpoint(id = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> class UserEndpoint &#123;</span><br><span class="line">    @ReadOperation</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,Object&gt;&gt; health()&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,Object&gt;&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,Object&gt; <span class="built_in">map</span> = <span class="literal">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">"userId"</span>,<span class="number">10001</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">"userName"</span>,<span class="string">"linyishui"</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问/actuator/user来查看用户信息。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><blockquote><p>《Spring Boot实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      SpringBoot入门介绍
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring boot" scheme="http://linyishui.top/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>算法复习 (二) 查找-平衡查找树</title>
    <link href="http://linyishui.top/2019110801.html"/>
    <id>http://linyishui.top/2019110801.html</id>
    <published>2019-11-08T10:44:43.000Z</published>
    <updated>2019-12-20T10:46:14.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a><strong>平衡查找树</strong></h1><p>&emsp;&emsp;一棵有N个节点的树，我们希望它的树高为lgN，这样可以保证所有查找都在lgN次比较内结束，但可惜在动态插入中保证树的完美平衡代价太高了。</p><h2 id="第一节-2-3查找树"><a href="#第一节-2-3查找树" class="headerlink" title="第一节 2-3查找树"></a><strong>第一节 2-3查找树</strong></h2><p>&emsp;&emsp;二叉树中的节点可以称作2-结点：含有一个键和两个链接，现在我们引入3-结点，含有两个键和三个链接。每条链接都对应着其中保存的键所分割产生的一个区间。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010101.png" alt="2-3查找树示意图"></p><p>&emsp;&emsp;一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。</p><h3 id="1-1-查找"><a href="#1-1-查找" class="headerlink" title="1.1 查找"></a><strong>1.1 查找</strong></h3><p>&emsp;&emsp;将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。具体查找过程如图 3.3.2 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010102.png" alt="2-3树中的查找命中（左）和未命中（右）">　</p><h3 id="1-2-向2-结点中插入新键"><a href="#1-2-向2-结点中插入新键" class="headerlink" title="1.2 向2-结点中插入新键"></a><strong>1.2 向2-结点中插入新键</strong></h3><p>&emsp;&emsp;要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用2-3树的主要原因就在于它能够在插入后继续保持平衡。如果未命中的查找结束于一个2-结点，事情就好办了：我们<strong>只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可</strong>。如果未命中的查找结束于一个3-结点，事情就要麻烦一些。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010103.png" alt="向2-结点中插入新的键"></p><h3 id="1-3-向一棵只含有一个3-结点的树中插入新键"><a href="#1-3-向一棵只含有一个3-结点的树中插入新键" class="headerlink" title="1.3 向一棵只含有一个3-结点的树中插入新键"></a><strong>1.3 向一棵只含有一个3-结点的树中插入新键</strong></h3><p>&emsp;&emsp;在考虑一般情况之前，先假设我们需要向一棵只含有一个3-结点的树中插入一个新键。这棵树中有两个键，所以在它唯一的结点中已经没有可插入新键的空间了。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。它很自然地扩展了以前的结点并含有3个键和4条链接。创建一个4-结点很方便，因为很容易将它转换为一棵由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点的右链接相连）。这棵树既是一棵含有3个结点的二叉查找树，同时也是一棵完美平衡的2-3树，因为其中所有的空链接到根结点的距离都相等。插入前树的高度为0，插入后树的高度为1。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010104.png" alt="向一棵只含有一个3-结点的树中插入新键"></p><h3 id="1-4-向一个父结点为2-结点的3-结点中插入新键"><a href="#1-4-向一个父结点为2-结点的3-结点中插入新键" class="headerlink" title="1.4 向一个父结点为2-结点的3-结点中插入新键"></a><strong>1.4 向一个父结点为2-结点的3-结点中插入新键</strong></h3><p>&emsp;&emsp;作为第二轮热身，假设未命中的查找结束于一个3-结点，而它的父结点是一个2-结点。在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间。我们先像刚才一样构造一个临时的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。你可以将这次转换看成将指向原3-结点的一条链接替换为新父结点中的原中键左右两边的两条链接，并分别指向两个新的2-结点。根据我们的假设，父结点中是有空间的：父结点是一个2-结点（一个键两条链接），插入之后变为了一个3-结点（两个键3条链接）。另外，这次转换也并不影响（完美平衡的）2-3树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同。请确认你完全理解了这次转换——它是2-3 树的动态变化的核心，其过程如图 3.3.5 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010105.png" alt="向一个父结点为2-结点的3-结点中插入新键"></p><h3 id="1-5-向一个父结点为3-结点的3-结点中插入新键"><a href="#1-5-向一个父结点为3-结点的3-结点中插入新键" class="headerlink" title="1.5 向一个父结点为3-结点的3-结点中插入新键"></a><strong>1.5 向一个父结点为3-结点的3-结点中插入新键</strong></h3><p>&emsp;&emsp;现在假设未命中的查找结束于一个父结点为3-结点的结点。我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此我们再用这个中键构造一个新的临时4-结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，我们就这样一直向上不断分解临时的4-结点并将中键插入更高层的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。该过程如图 3.3.6 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010106.png" alt="向一个父结点为3-结点的3-结点中插入新键"></p><h3 id="1-6-分解根结点"><a href="#1-6-分解根结点" class="headerlink" title="1.6 分解根结点"></a><strong>1.6 分解根结点</strong></h3><p>&emsp;&emsp;如果从插入结点到根结点的路径上全都是3-结点，我们的根结点最终变成一个临时的4-结点。此时我们可以按照向一棵只有一个3-结点的树中插入新键的方法处理这个问题。我们将临时的4-结点分解为3个2-结点，使得树高加1，如图 3.3.7 所示。请注意，这次最后的变换仍然保持了树的完美平衡性，因为它变换的是根结点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010107.png" alt="分解根结点"></p><h3 id="1-7-局部变换"><a href="#1-7-局部变换" class="headerlink" title="1.7 局部变换"></a><strong>1.7 局部变换</strong></h3><p>&emsp;&emsp;将一个4-结点分解为一棵2-3树可能有6种情况，都总结在了图 3.3.8 中。这个4-结点可能是根结点，可能是一个2-结点的左子结点或者右子结点，也可能是一个3-结点的左子结点、中子结点或者右子结点。23树插入算法的根本在于这些变换都是局部的：<strong>除了相关的结点和链接之外不必修改或者检查树的其他部分</strong>。每次变换中，变更的链接数量不会超过一个很小的常数。需要特别指出的是，不光是在树的底部，树中的任何地方只要符合相应的模式，变换都可以进行。每个变换都会将4结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010108.png" alt="在一棵2-3树中分解一个4-结点的情况汇总"></p><h3 id="1-8-全局性质"><a href="#1-8-全局性质" class="headerlink" title="1.8 全局性质"></a><strong>1.8 全局性质</strong></h3><p>&emsp;&emsp;这些局部变换不会影响树的全局有序性和平衡性：<strong>任意空链接到根结点的路径长度都是相等的</strong>。作为参考，图 3.3.9 所示的是当一个4-结点是一个 3-结点的中子结点时的完整变换情况。如果在变换之前根结点到所有空链接的路径长度为h，那么变换之后该长度仍然为h。所有的变换都具有这个性质，即使是将一个4-结点分解为两个2-结点并将其父结点由2-结点变为3-结点，或是由3-结点变为一个临时的4-结点时也是如此。当根结点被分解为3个2-结点时，所有空链接到根结点的路径长度才会加1。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010109.png" alt="4-结点的分解是一次局部变换，不会影响树的有序性和平衡性"></p><p>&emsp;&emsp;和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。 如果你花点时间仔细研究一下图 3.3.10，就能很好地理解2-3树的构造方式。它给出了我们的标准索引测试用例中产生的一系列2-3树，以及一系列由同一组键按照升序依次插入到树中时所产生的所有2-3树。还记得在二叉查找树中，按照升序插入10 个键会得到高度为9的一棵最差查找树吗？如果使用2-3树，树的高度是2。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010110.png" alt="2-3树的构造轨迹"></p><h3 id="1-9-性能分析"><a href="#1-9-性能分析" class="headerlink" title="1.9 性能分析"></a><strong>1.9 性能分析</strong></h3><p>&emsp;&emsp;2-3树的分析和二叉查找树的分析大不相同，因为我们主要感兴趣的是最坏情况下的性能，而非一般情况（这种情况下我们会用随机键模型分析预期的性能）。在符号表的实现中，一般我们无法控制用例会按照什么顺序向表中插入键，因此对最坏情况的分析是唯一能够提供性能保证的办法。</p><blockquote><ul><li>命题 F。在一棵大小为的2-3树中，查找和插入操作访问的结点必然不超过lgN个。</li><li>证明。一棵含有N个结点的2-3树的高度在log3(N)=[lgN / lg3]（如果树中全是3-结点）和[lgN]（如果树中全是2-结点）之间。</li></ul></blockquote><p>&emsp;&emsp;因此我们可以确定2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。通过对比图 3.3.11 中的2-3树和图 3.2.8 中由相同的键构造的二叉查找树，你也可以看到，完美平衡的 2-3树要平展得多。例如，含有 10 亿个结点的一棵2-3树的高度仅在19到30之间。我们最多只需 访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是相当惊人的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010111.png" alt="由随机键构造的一棵典型的2-3树"></p><p>&emsp;&emsp;但是，我们和真正的实现还有一段距离。尽管我们可以用不同的数据类型表示2-结点和3-结点并写出变换所需的代码，但用这种直白的表示方法实现大多数的操作并不方便，因为需要处理的情况实在太多。我们需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。幸运的是你将看到，我们只需要一点点代价就能用一种统一的方式完成所有变换。</p><hr><h2 id="第二节-红黑查找树"><a href="#第二节-红黑查找树" class="headerlink" title="第二节 红黑查找树"></a><strong>第二节 红黑查找树</strong></h2><h3 id="2-1-替换3-结点"><a href="#2-1-替换3-结点" class="headerlink" title="2.1 替换3-结点"></a><strong>2.1 替换3-结点</strong></h3><p>&emsp;&emsp;红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。我们将树中的链接分为两种类型：<strong>红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接</strong>。确切地说，我们<strong>将3-结点表示为由一条左斜的红色链接相连的两个2-结点</strong>，如图 3.3.12 所示。这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。我们将用这种方式表示2-3树的二叉查找树称为红黑二叉查找树（以下简称为红黑树）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010112.png" alt="由一条红色左链接相连的两个2-结点表示一个3-结点"></p><h3 id="2-2-一种等价的定义"><a href="#2-2-一种等价的定义" class="headerlink" title="2.2 一种等价的定义"></a><strong>2.2 一种等价的定义</strong></h3><p>&emsp;&emsp;红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：</p><blockquote><ul><li>红链接均为左链接；</li><li>没有任何一个结点同时和两条红链接相连； </li><li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li></ul></blockquote><p>&emsp;&emsp;满足这样定义的红黑树和相应的 2-3 树是<strong>一一对应</strong>的。</p><h3 id="2-3-一一对应"><a href="#2-3-一一对应" class="headerlink" title="2.3 一一对应"></a><strong>2.3 一一对应</strong></h3><p>&emsp;&emsp;如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相同的（如图 3.3.13 所示）。如果我们将由红链接相连的结点合并，得到的就是一棵2-3树。相反，如果将一棵2-3树中的3-结点画作由红色左链接相连的两个2-结点，那么不会存在能够和两条红链接相连的结点，且树必然是完美黑色平衡的，因为黑链接即2-3树中的普通链接，根据定义这些链接必然是完美平衡的。无论我们选择用何种方式去定义它们，红黑树都既是二叉查找树，也是2-3树，如图 3.3.14 所示。因此，如果我们能够在保持一一对应关系的基础上实现2-3树的插入算法，那么我们就能够将两个算法的优点结合起来：二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010113.png" alt="将红链接画平时，一棵红黑树就是一棵2-3树"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010114.png" alt="红黑树和2-3树的一一对应关系"></p><h3 id="2-4-颜色表示"><a href="#2-4-颜色表示" class="headerlink" title="2.4 颜色表示"></a><strong>2.4 颜色表示</strong></h3><p>&emsp;&emsp;方便起见，因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量 color 中。如果指向它的链接是红色的，那么该变量为true，黑色则为false。我们约定空链接为黑色。为了代码的清晰我们定义了两个常量 RED 和 BLACK 来设置和测试这个变量。我们使用私有方法 isRed() 来测试一个结点和它的父结点之间的链接的颜色。颜色表示的代码实现如图 3.3.15 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010115.png" alt="红黑树的结点表示"></p><h3 id="2-5-旋转"><a href="#2-5-旋转" class="headerlink" title="2.5 旋转"></a><strong>2.5 旋转</strong></h3><p>&emsp;&emsp;在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地旋转并修复。旋转操作会改变红链接的指向。首先，假设我们有一条红色的右链接需要被转化为左链接（请见图 3.3.16）。这个操作叫做<strong>左旋转</strong>，它对应的方法接受一条指向红黑树中的某个结点的链接作为参<br>数。假设被指向的结点的右链接是红色的，这个方法会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根结点的链接。<strong>我们只是将用两个键中的较小者作为根结点变为将较大者作为根结点</strong>。实现将一个红色左链接转换为一个红色右链接的一个右旋转的代码完全相同，只需要将 left 和 right 互换即可（如图 3.3.17 所示）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010116.png" alt="左旋转h的右链接"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010117.png" alt="右旋转h的左链接"></p><h3 id="2-6-在旋转后重置父结点的链接"><a href="#2-6-在旋转后重置父结点的链接" class="headerlink" title="2.6 在旋转后重置父结点的链接"></a><strong>2.6 在旋转后重置父结点的链接</strong></h3><p>&emsp;&emsp;无论左旋转还是右旋转，旋转操作都会返回一条链接。我们总是会用rotateRight()或rotateLeft()的返回值重置父结点（或是根结点）中相应的链接。返回的链接可能是左链接也可能是右链接，但是我们总会将它赋予父结点中的链接。这个链接可能是红色也可能是黑色——rotateLeft()和rotateRight()都通过将x.color设为h.color保留它原来的颜色。这可能会产生两条连续的红链接，但我们的算法会继续用旋转操作修正这种情况。例如，代码h = rotateLeft(h); 将旋转结点h的红色右链接，使得h指向了旋转后的子树的根结点（组成该子树中的所有键和旋转前相同，只是根结点发生了变化）。这种简洁的代码是我们使用递归实现二叉查找树的各种方法的主要原因。你会看到，它使得旋转操作成为了普通插入操作的一个简单补充。</p><p>&emsp;&emsp;在插入新的键时我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：有序性和完美平衡性。也就是说，我们在红黑树中进行旋转时无需为树的有序性或者完美平衡性担心。下面我们来看看应该如何使用旋转操作来保持红黑树的另外两个重要性质（不存在两条连续的红链接和不存在红色的右链接）。我们先用一些简单的情况热热身。</p><h3 id="2-7-向单个2-结点中插入新键"><a href="#2-7-向单个2-结点中插入新键" class="headerlink" title="2.7 向单个2-结点中插入新键"></a><strong>2.7 向单个2-结点中插入新键</strong></h3><p>&emsp;&emsp;一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键之后，我们马上就需要将它们旋转。如果新键小于老键，我们只需要新增一个红色的结点即可，新的红黑树和单个3-结点完全等价。如果新键大于老键，那么新增的红色结点将会产生一条红色的右链接。我们需要使用 root = rotateLeft(root); 来将其旋转为红色左链接并修正根结点的链接，插入操作才算完成。两种情况的结果均为一棵和单个3- 结点等价的红黑树，其中含有两个键，一条红链接，树的黑链接高度为1， 如图 3.3.18 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010118.png" alt="向单个2-结点中插入一个新键"></p><h3 id="2-8-向树底部的2-结点插入新键"><a href="#2-8-向树底部的2-结点插入新键" class="headerlink" title="2.8 向树底部的2-结点插入新键"></a><strong>2.8 向树底部的2-结点插入新键</strong></h3><p>&emsp;&emsp;用和二叉查找树相同的方式向一棵红黑树中插入一个新键会在树的底部新增一个结点（为了保证有序性），但总是用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种处理方法仍然适用。如果指向新结点的是父结点的左链接，那么父结点就直接成为了一个3-结点；如果指向新结点的是父结点的右链接，这就是一个错误的3-结点，但一次左旋转就能够修正它，如图 3.3.19 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010119.png" alt="向树底部的2-结点插入一个新键"></p><h3 id="2-9-向一棵双键树（即一个3-结点）中插入新键"><a href="#2-9-向一棵双键树（即一个3-结点）中插入新键" class="headerlink" title="2.9 向一棵双键树（即一个3-结点）中插入新键"></a><strong>2.9 向一棵双键树（即一个3-结点）中插入新键</strong></h3><p>&emsp;&emsp;这种情况又可分为三种子情况：<strong>新键小于树中的两个键</strong>，<strong>在两者之间</strong>，<strong>或是大于树中的两个键</strong>。每种情况中都会产生一个同时连接到两条红链接的结点，而我们的目标就是修正这一点。</p><blockquote><ul><li>三者中最简单的情况是新键大于原树中的两个键，因此它被连接到3-结点的右链接。此时树是平衡的，根结点为中间大小的键，它有两条红链接分别和较小和较大的结点相连。如果我们将两条链接的颜色都由红变黑，那么我们就得到了一棵由三个结点组成、高为2的平衡树。它正好能够对应一棵2-3树，如图 3.3.20（左）。其他两种情况最终也会转化为这种情况。 </li><li>如果新键小于原树中的两个键，它会被连接到最左边的空链接，这样就产生了两条连续的红链接，如图 3.3.20（中）。此时我们只需要将上层的红链接右旋转即可得到第一种情况（中值键为根结点并和其他两个结点用红链接相连）。 </li><li>如果新键介于原树中的两个键之间，这又会产生两条连续的红链接，一条红色左链接接一条红色右链接，如图 3.3.20（右）。此时我们只需要将下层的红链接左旋转即可得到第二种情况（两条连续的红色左链接）。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010120.png" alt="向一棵双键树（即一个3-结点）中插入一个新键的三种情况"></p><p>&emsp;&emsp;总的来说，我们通过 0 次、1 次和 2 次旋转以及颜色的变化得到了期望的结果。在 2-3 树中，请确认你完全理解了这些转换，它们是红黑树的动态变化的关键。</p><h3 id="2-10-颜色转换"><a href="#2-10-颜色转换" class="headerlink" title="2.10 颜色转换"></a><strong>2.10 颜色转换</strong></h3><p>&emsp;&emsp;如图 3.3.21 所示，我们专门用一个方法 flipColors() 来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将父结点的颜色由黑变红。这项操作最重要的性质在于它和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性。根据这一点，我们马上能够在下面完整地实现红黑树。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010121.png" alt="通过转换链接的颜色来分解4-结点"></p><h3 id="2-11-根结点总是黑色"><a href="#2-11-根结点总是黑色" class="headerlink" title="2.11 根结点总是黑色"></a><strong>2.11 根结点总是黑色</strong></h3><p>&emsp;&emsp;在 3.3.2.9 所述的情况中，颜色转换会使根结点变为红色。这也可能出现在很大的红黑树中。严格地说，红色的根结点说明根结点是一个3结点的一部分，但实际情况并不是这样。因此我们在每次插入后都会将根结点设为黑色。注意，每当根结点由红变黑时树的黑链接高度就会加1。</p><h3 id="2-12-向树底部的3-结点插入新键"><a href="#2-12-向树底部的3-结点插入新键" class="headerlink" title="2.12 向树底部的3-结点插入新键"></a><strong>2.12 向树底部的3-结点插入新键</strong></h3><p>&emsp;&emsp;现在假设我们需要在树的底部的一个3-结点下加入一个新结点。前面讨论过的三种情况都会出现，如图 3.3.22 所示。指向新结点的链接可能是3-结点的右链接（此时我们只需要转换颜色即可），或是左链接（此时我们需要进行右旋转然后再转换颜色），或是中链接（此时我们 需要先左旋转下层链接然后右旋转上层链接，最后再转换颜色）。颜色转换会使到中结点的链接变红，相当于将它送入了父结点。这意味着在父结点中继续插入一个新键，我们也会继续用相同的办法解决这个问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010122.png" alt="向树底部的3-结点插入一个新键"></p><h3 id="2-13-将红链接在树中向上传递"><a href="#2-13-将红链接在树中向上传递" class="headerlink" title="2.13 将红链接在树中向上传递"></a><strong>2.13 将红链接在树中向上传递</strong></h3><p>&emsp;&emsp;2-3 树中的插入算法需要我们分解 3- 结点，将中间键插入父结点，如此这般直到遇到一个2-结点或是根结点。我们所考虑过的所有情况都正是为了达成这个目标：每次必要的旋转之后我们都会进行颜色转换，这使得中结点变红。在父结点看来，处理这样一个红色结点的方式和处理一个新插入的红色结点完全相同，即继续把红链接转移到中结点上去。图 3.3.23 中总结的三种情况显示了在红黑树中实现2-3树的插入算法的 关键操作所需的步骤：要在一个3-结点下插入新键，先创建一个临时 的4-结点，将其分解并将红链接由中间键传递给它的父结点。重复这个过程，我们就能将红链接在树中向上传递，直至遇到一个2-结点或者根结点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010123.png" alt="红黑树中红链接向上传递"></p><p>&emsp;&emsp;总之，只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作，我们就能够保证插入操作后红黑树和2-3树的一一对应关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：</p><blockquote><ul><li>如果右子结点是红色的而左子结点是黑色的，进行左旋转； </li><li>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；</li><li>如果左右子结点均为红色，进行颜色转换。</li></ul></blockquote><p>&emsp;&emsp;你应该花点时间确认以上步骤处理了前文描述的所有情况。请注意，第一个操作表示将一个2-结点变为一个3-结点和插入的新结点与树底部的3-结点通过它的中链接相连的两种情况。</p><hr><h2 id="第三节-实现"><a href="#第三节-实现" class="headerlink" title="第三节 实现"></a><strong>第三节 实现</strong></h2><p>&emsp;&emsp;因为保持树的平衡性所需的操作是由下向上在每个所经过的结点中进行的，将它们植入我们已有的实现中十分简单：只需要在递归调用之后完成这些操作即可，如算法 3.4 所示。上一段中列出的三种操作都可以通过一个检测两个结点的颜色的if语句完成。尽管实现所需的代码量很小，但如果没有我们学习过的两种抽象数据结构（2-3 树和红黑树）作为铺垫，这段实现仍然会非常难以理解。在检查了三到五个结点的颜色之后（也许还需要进行一两次旋转以及颜色转换），我们就可以得到一棵近乎完美平衡的二叉查找树。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST&lt;Key</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;Key&gt;</span>, <span class="title">Value&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> root;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="title">//</span> <span class="title">含有color变量的Node对象（请见3</span>.3.2.4<span class="title">节）</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">boolean</span> <span class="title">isRed</span>(<span class="params"><span class="type">Node</span> h</span>)    <span class="title">//</span> <span class="title">请见3</span>.3.2.4<span class="title">节</span>   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Node</span> <span class="title">rotateLeft</span>(<span class="params"><span class="type">Node</span> h</span>)  <span class="title">//</span> <span class="title">请见图3</span>.3.16   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Node</span> <span class="title">rotateRight</span>(<span class="params"><span class="type">Node</span> h</span>) <span class="title">//</span> <span class="title">请见图3</span>.3.17   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">void</span> <span class="title">flipColors</span>(<span class="params"><span class="type">Node</span> h</span>)  <span class="title">//</span> <span class="title">请见图3</span>.3.21</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">int</span> <span class="title">size</span>(<span class="params"></span>)               <span class="title">//</span> <span class="title">请见算法3</span>.3</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">put</span>(<span class="params"><span class="type">Key</span> key, <span class="type">Value</span> val</span>)</span>&#123;  </span><br><span class="line">       <span class="comment">// 查找key，找到则更新其值，否则为它新建一个结点      </span></span><br><span class="line">       root = put(root, key, <span class="keyword">val</span>);      </span><br><span class="line">       root.color = <span class="type">BLACK</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> put(<span class="type">Node</span> h, <span class="type">Key</span> key, <span class="type">Value</span> <span class="keyword">val</span>)   &#123;     </span><br><span class="line">        <span class="comment">// 标准的插入操作，和父结点用红链接相连    </span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>)       </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Node</span>(key, <span class="keyword">val</span>, <span class="number">1</span>, <span class="type">RED</span>);</span><br><span class="line"></span><br><span class="line">        int cmp = key.compareTo(h.key);      </span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">            h.left  = put(h.left,  key, <span class="keyword">val</span>);      </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">            h.right = put(h.right, key, <span class="keyword">val</span>);      </span><br><span class="line">        <span class="keyword">else</span> h.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))  h = rotateLeft(h);             </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left))  h = rotateRight(h);             </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right))  flipColors(h);</span><br><span class="line">            </span><br><span class="line">        h.<span class="type">N</span> = size(h.left) + size(h.right) + <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">return</span> h;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了递归调用后的三条 if 语句，红黑树中 put() 的递归实现和二叉查找树中 put() 的实现完全相同。它们在查找路径上保证了红黑树和2-3树的一一对应关系，使得树的平衡性接近完美。第一条 if 语句会将任意含有红色右链接的3-结点（或临时的4-结点）向左旋转；第二条 if 语句会将临时的4-结点中两条连续红链接中的上层链接向右旋转；第三条 if 语句会进行颜色转换并将红链接在树中向上传递（详情请见正文）。</p><p>&emsp;&emsp;图 3.3.24 给出了使用我们的标准索引测试用例进行测试的轨迹和用同一组键按照升序构造一棵红黑树的测试轨迹。仅从红黑树的三种标准操作的角度分析这些例子对我们理解问题很有帮助，之前我们也是这样做的。另一个基本练习是检查它们和2-3树的一一对应关系（可以对比图 3.3.10 中由同一组键构造的2-3树）。在两种情况中你都能通过思考将 P 插入红黑树所需的转换来检验你对算法的理解程度（请见练习 3.3.12）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010124.png" alt="红黑树的构造轨迹"></p><hr><h2 id="第四节-删除操作"><a href="#第四节-删除操作" class="headerlink" title="第四节 删除操作"></a><strong>第四节 删除操作</strong></h2><p>&emsp;&emsp;算法3.4中的 put() 方法是本书中最复杂的实现之一，而红黑树的 deleteMin()、deleteMax() 和 delete() 的实现更麻烦，我们将它们的完整实现留做练习，但这里仍然需要学习它们的基本原理。要描述删除算法，首先我们要回到2-3树。和插入操作一样，我们也可以定义一系列局部变换来在删除一个结点的同时保持树的完美平衡性。这个过程比插入一个结点更加复杂，因为我们不仅要在（为了删除一个结点而）构造临时4-结点时沿着查找路径向下进行变换，还要在分解遗留的4-结点时沿着查找路径向上进行变换（同插入操作）。</p><h3 id="4-1-自顶向下的2-3-4树"><a href="#4-1-自顶向下的2-3-4树" class="headerlink" title="4.1 自顶向下的2-3-4树"></a><strong>4.1 自顶向下的2-3-4树</strong></h3><p>&emsp;&emsp;作为第一轮热身，我们先学习一个沿查找路径既能向上也能向下进行变换的稍简单的算法：2-3-4树的插入算法，2-3-4树中允许存在我们以前见过的4-结点。它的插入算法沿查找路径向下进行变换是为了保证当前结点不是4-结点（这样树底才有空间来插入新的键），沿查找路径向上进行变换是为了将之前创建的4-结点配平，如图 3.3.25 所示。向下的变换和我们在2-3树中分解4-结点所进行的变换完全相同。如果 根结点是4-结点，我们就将它分解成三个2-结点，使得树高加1。在向下查找的过程中，如果遇到一个父结点为2-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点 变为一个3-结点；如果遇到一个父结点为3-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点变为一个4-结点；我们不必担心会遇到父结点为4-结点的4-结点，因为插入算法本身就保证了这种情况不会出现。到达树的底部之后，我们也只会遇到2-结点或者3-结点，所以我们可以插入新的键。要用红黑树实现这个算法，我们需要：</p><blockquote><ul><li>将4-结点表示为由三个2-结点组成的一棵平衡的子树，根结点和两个子结点都用红链接相连； </li><li>在向下的过程中分解所有4-结点并进行颜色转换； </li><li>和插入操作一样，在向上的过程中用旋转将4-结点配平 。</li></ul></blockquote><p>&emsp;&emsp;因为4-结点可以存在，所以可以允许一个结点同时连接到两条链接。——译者注</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010125.png" alt="自顶向下的2-3-4树的插入算法中的变换"></p><p>&emsp;&emsp;令人惊讶的是，你只需要移动算法3.4的 put() 方法中的一行代码就能实现2-3-4树中的插入操作：将 colorFlip() 语句（及其 if 语句）移动到递归调用之前（null 测试和比较操作之间）。在多个进程可以同时访问同一棵树的应用中这个算法优于2-3树，因为它操作的总是当前结点的一个或两个链接。我们下面要讲的删除算法和它的插入算法类似，而且也适用于2-3树。</p><h3 id="4-2-删除最小键"><a href="#4-2-删除最小键" class="headerlink" title="4.2 删除最小键"></a><strong>4.2 删除最小键</strong></h3><p>&emsp;&emsp;在第二轮热身中我们要学习2-3树中删除最小键的操作。我们注意到从 树底部的3-结点中删除键是很简单的，但2-结点则不然。从2-结点中删除一个键会留下一个空结点，一般我们会将它替换为一个空链接，但这样会破坏树的完美平衡性。所以我们需要这样做：为了保证我们不会 删除一个2-结点，我们沿着左链接向下进行变换，确保当前结点不是2-结点（可能是3-结点，也可能是临时的4-结点）。首先，根结点可 能有两种情况。如果根是2-结点且它的两个子结点都是2-结点，我们可以直接将这三个结点变成一个4-结点；否则我们需要保证根结点的左子结点不是2-结点，如有必要可以从它右侧的兄弟结点“借”一个键 来。以上情况如图 3.3.26 所示。在沿着左链接向下的过程中，保证以下情况之一成立：</p><blockquote><ul><li>如果当前结点的左子结点不是2-结点，完成； </li><li>如果当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移动到左子结点中； </li><li>如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个 4结点，使父结点由3-结点变为2-结点或者由4-结点变为3-结点。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010126.png" alt="删除最小键操作中的变换"></p><p>&emsp;&emsp;在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接从中将其删除，将3-结点变为2结点，或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。</p><h3 id="4-3-删除操作"><a href="#4-3-删除操作" class="headerlink" title="4.3 删除操作"></a><strong>4.3 删除操作</strong></h3><p>&emsp;&emsp;在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后继结点交换，就和二叉查找树一样。因为当前结点必然不是 2-结点，问题已经转化为在一棵根结点不是2-结点的子树中删除最小的键，我们可以在这棵子树中使用前文所述的算法。和以前一样，删除之后我们需要向上回溯并分解余下的4-结点。</p><p>&emsp;&emsp;本节末尾的练习中有几道是关于这些删除算法的例子和实现的。有兴趣理解或实现删除算法的读者应该掌握这些练习中的细节。对算法研究感兴趣的读者应该认识到这些方法的重要性，因为这是我们见过的第一种能够同时实现高效的查找、插入和删除操作的符号表实现。下面我们将会验证这一点。</p><hr><h2 id="第五节-红黑树的性质"><a href="#第五节-红黑树的性质" class="headerlink" title="第五节 红黑树的性质"></a><strong>第五节 红黑树的性质</strong></h2><p>&emsp;&emsp;研究红黑树的性质就是要检查对应的2-3树并对相应的2-3树进行分析的过程。我们的最终结论是所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别（范围查找除外，它所需的额外时间和返回的键的数量成正比）。我们重复并强调这一点是因为它十分重要。</p><h3 id="5-1-性能分析"><a href="#5-1-性能分析" class="headerlink" title="5.1 性能分析"></a><strong>5.1 性能分析</strong></h3><p>&emsp;&emsp;首先，无论键的插入顺序如何，红黑树都几乎是完美平衡的（请见图 3.3.27）。这从它和2-3树的一一对应关系以及 2-3 树的重要性质可以得到。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010127.png" alt="使用随机键构造的典型红黑树，没有画出空链接"></p><p>&emsp;&emsp;命题 G。一棵大小为N的红黑树的高度不会超过2lgN。</p><p>&emsp;&emsp;简略的证明。红黑树的最坏情况是它所对应的 2-3 树中构成最左边 的路径结点全部都是 3- 结点而其余均为 2- 结点。最左边的路径长 度是只包含 2- 结点的路径长度（~lgN）的两倍。要按照某种顺序 构造一棵平均路径长度为2lgN的最差红黑树虽然可能，但并不容 易。如果你喜欢数学，你也许会喜欢在练习 3.3.24 中探究这个问题 的答案。</p><p>&emsp;&emsp;这个上界是比较保守的。使用随机的键序列和典型应用中常见的键序列 进行的实验都证明，在一棵大小为N的红黑树中一次查找所需的比较 次数约为（1.00lgN - 0.5）。另外，在实际情况下你不太可能遇到比这个数字高得多的平均比较次数，如表 3.3.1 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010128.png" alt="使用RedBlackBST的FrequencyCounter的每次put()操作平均所需的比较次数"></p><p>&emsp;&emsp;命题H。一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。</p><p>&emsp;&emsp;例证。和典型的二叉查找树（例如图 3.2.8 中所示的树）相比，一棵典型的红黑树的平衡性是很好的，例如图 3.3.27 所示（甚至是图 3.3.28 中由升序键列构造的红黑树）。表 3.3.1 显示的数据表明FrequencyCounter在运行中构造的红黑树的路径长度（即查找成本）比初等二叉查找树低40%左右，和预期相符。自红黑树的发明以来，无数的实验和实际应用都印证了这种性能改进。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010129.png" alt="使用升序键列构造的一棵红黑树，没有画出空链接"></p><p>&emsp;&emsp;以使用 FrequencyCounter 在处理长度大于等于8的单词时put()操作的成本为例，我们可以看到平均成本降低得更多（如图 3.3.29 所示）。这又一次验证了理论模型所预测的对数级别的运行时间，只不过这次的惊喜比二叉查找树的小，因为性质G已经向我们保证了这一点。节约的总成本低于在查找上节约的40%的成本，因为除了比较我们也统计了旋转和颜色变换的次数。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010130.png" alt="使用RedBlackBST，运行java FrequencyCounter 8 &lt; tale.txt的成本"></p><p>&emsp;&emsp;红黑树的get()方法不会检查结点的颜色，因此平衡性相关的操作不会产生任何负担；因为树是平衡的，所以查找比二叉查找树更快。每个键只会被插入一次，但却可能被查找无数次，因此最后我们只用了很小的代价（和二分查找不同，我们可以保证插入操作是对数级别的）就取得了和最优情况近似的查找时间（因为树是接近完美平衡的，且查找过程中不会进行任何平衡性的操作）。查找的内循环只会进行一次比较并更新一条链接，非常简短，和二分查找的内循环类似（只有比较和索引运算）。这是我们见到的第一个能够保证对数级别的查找和插入操作的实现，它的内循环更紧凑。它通过了各种应用的考验，包括许多库实现。</p><h3 id="5-2-有序符号表API"><a href="#5-2-有序符号表API" class="headerlink" title="5.2 有序符号表API"></a><strong>5.2 有序符号表API</strong></h3><p>&emsp;&emsp;红黑树最吸引人的一点是它的实现中最复杂的代码仅限于 put()（和删除）方法。二叉查找树中的查找最大和最小 键、select()、rank()、floor()、ceiling() 和范围查找方法不做任何变动即可继续使用，因为红黑树也是二叉查找树而这些操作也不会涉及结点的颜色。算法 3.4 和这些方法（以及删除方法）一起完整地实现了我们的有序符号表 API。这些方法都能从红黑树近乎完美的平衡性中受益，因为它们最多所需的时间都和树高成正比。因此命题G和命题E一起保证了所有操作的运行时间是对数级别的。</p><p>&emsp;&emsp;命题I。在一棵红黑树中，以下操作在最坏情况下所需的时间是对数级别的：查找（get()）、插入（put()）、查找最小键、查找最大键、floor()、ceiling()、rank()、select()、删除最小键（deleteMin()）、删除最大键（deleteMax()）、删除（delete()）和范围查询（range()）。</p><p>&emsp;&emsp;证明。我们已经讨论过 put()、get() 和 delete() 方法。对于其他方法，代码可以从3.2节中照搬（它们不涉及结点颜色）。命题G和命题E可以保证算法是对数级别的，所有操作在所经过的结点上只会进行常数次数的操作也说明了这一点。</p><p>&emsp;&emsp;各种符号表实现的性能总结如表 3.3.2 所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010131.png" alt="各种符号表实现的性能总结"></p><p>&emsp;&emsp;想想看，这样的保证是一个非凡的成就。在信息世界的汪洋大海中，表的大小可能上千亿，但我们仍能够确保在几十次比较之内就完成这些操作。</p><h3 id="5-3-答疑"><a href="#5-3-答疑" class="headerlink" title="5.3 答疑"></a><strong>5.3 答疑</strong></h3><blockquote><ul><li>问　为什么不允许存在红色右链接和4-结点？</li><li>答　它们都是可用的，并且已经应用了几十年了。在练习中你会遇到它们。只允许红色左链接的存在能够减少可能出现的情况，因此实现所需的代码会少得多。</li></ul></blockquote><blockquote><ul><li>问　为什么不在Node类型中使用一个Key类型的数组来表示2-结点、 3-结点和4-结点？</li><li>答　问得好。这正是我们在B-树（请见第６章）的实现中使用的方案，它的每个结点中可以保存更多的键。因为2-3树中的结点较少，数组所带来的额外开销太高了。</li></ul></blockquote><blockquote><ul><li>问　在分解一个4-结点时，我们有时会在 rotateRight() 中将右结点的颜色设为RED（红）然后立即在 flipColors() 中将它的颜色变为BLACK（黑）。这不是浪费时间吗？</li><li>答　是的，有时我们还会不必要地反复改变中结点的颜色。从整体来看，多余的几次颜色变换和将所有方法的运行时间的增长数量级从线性级别提升到对数级别不是一个级别的。当然，在有性能要求的应用中，你可以将 rotateRight() 和 flipColors() 的代码在所需要的地方展开来消除那些额外的开销。我们在删除中也会使用这两个方法。在能够保证树的完美平衡的前提下，它们更加容易使用、理解和维护。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      算法复习 (二) 查找-平衡查找树，主要内容包括：2-3查找树（查找、向2-结点中插入新键、向一棵只含有一个3-结点的树中插入新键、向一个父结点为2-结点的3-结点中插入新键、向一个父结点为3-结点的3-结点中插入新键、分解根结点、局部变换、全局性质、性能分析），红黑查找树（替换3-结点、一种等价的定义、一一对应、颜色表示、旋转、在旋转后重置父结点的链接、向单个2-结点中插入新键、向树底部的2-结点插入新键、向一棵双键树（即一个3-结点）中插入新键、颜色转换、根结点总是黑色、向树底部的3-结点插入新键、将红链接在树中向上传递），实现，删除操作（自顶向下的2-3-4树、删除最小键、删除操作）红黑树的性质（性能分析、有序符号表API、答疑）等
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码解读-1.8版</title>
    <link href="http://linyishui.top/2019110601.html"/>
    <id>http://linyishui.top/2019110601.html</id>
    <published>2019-11-06T02:37:13.000Z</published>
    <updated>2019-12-26T07:57:47.028Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentHashMap源码解读"><a href="#ConcurrentHashMap源码解读" class="headerlink" title="ConcurrentHashMap源码解读"></a><strong>ConcurrentHashMap源码解读</strong></h1><h2 id="第一节-结构"><a href="#第一节-结构" class="headerlink" title="第一节 结构"></a><strong>第一节 结构</strong></h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a><strong>1.1 基本结构</strong></h3><p>&emsp;&emsp;继承抽象类AbstractMap，实现ConcurrentMap和Serializable接口。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ConcurrentHashMap&lt;K,V&gt; <span class="keyword">extends</span> AbstractMap&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 散列表即桶数组，首次put时延迟初始化，大小总是2的幂，由迭代器直接访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下个要用的表，仅在resize时不为空，也就是用于扩容，扩容后更新为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础计数器，主要在没有线程竞争时使用，但也在表初始化竞争中当作备用方案，通过CAS更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表的初始化和resize控制器数，也用来作扩容阈值。</span></span><br><span class="line"><span class="comment">     * 如果为负数，表示散列表正在初始化或扩容(-1：表示初始化，-n：表示负的活跃的resize线程数+1)。</span></span><br><span class="line"><span class="comment">     * 当table为空时将保留创建时要使用的初始表大小，默认为0，会大概设置为0.75s左右，通过sc = n - (n &gt;&gt;&gt; 2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容时用来转移的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建或resize CounterCells时要用的自旋锁（通过CAS锁定）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数单元的数组，非空时大小是2的幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// views</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Node单向链表节点"><a href="#1-2-Node单向链表节点" class="headerlink" title="1.2 Node单向链表节点"></a><strong>1.2 Node单向链表节点</strong></h3><p>&emsp;&emsp;通过Node链表来应对哈希冲突，在结构上和1.8版本的HashMap的Node类似，但val和next是volatile修饰的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-主要方法"><a href="#第二节-主要方法" class="headerlink" title="第二节 主要方法"></a><strong>第二节 主要方法</strong></h2><h3 id="2-1-get"><a href="#2-1-get" class="headerlink" title="2.1 get"></a><strong>2.1 get</strong></h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//高位异或到低位，更多哈希冲突的场景用红黑树来优化，所以采用这种即方便又能解决问题的方案。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> spread(<span class="built_in">int</span> h) &#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定下标在哈希表中的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, <span class="built_in">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//先把hashcode再散列得到h</span></span><br><span class="line">    <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="comment">//散列表不为空，获取节点e，通过(n - 1) &amp; h与运算定位下标</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//e不为空且hash值等于h，且key相等，则直接返回对应的值</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash值不等于h，且为负数，表示此时结构为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//则尝试遍历树查询key并返回</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//e还有后续节点，则遍历链表查询key并返回</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未能找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-put"><a href="#2-2-put" class="headerlink" title="2.2 put"></a><strong>2.2 put</strong></h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Encodings for Node hash fields. 特殊的哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MOVED     = <span class="number">-1</span>; <span class="comment">// hash for forwarding nodes 转移节点的hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TREEBIN   = <span class="number">-2</span>; <span class="comment">// hash for roots of trees 树根的hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> RESERVED  = <span class="number">-3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V putVal(K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent) &#123;</span><br><span class="line">    <span class="comment">//首先不允许新增空键或空值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//把hashcode再散列得到hash</span></span><br><span class="line">    <span class="built_in">int</span> hash = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="comment">//初始化binCount，用来记录修改的长度</span></span><br><span class="line">    <span class="built_in">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//死循环，直到操作成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="built_in">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//首次执行putVal()调用initTable进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//已有哈希表，并且hash对应下标节点还未赋值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过Unsafe实现CAS新增链表节点，完成任务跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已有哈希表，节点也已存在，但f处于MOVED状态表示正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);<span class="comment">//帮助扩容</span></span><br><span class="line">        <span class="comment">//已有哈希表，链表也已初始化，且节点不在移动状态，则加锁进行操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//oldVal用来记录旧值</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//代码块加锁同步f节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//如果f此时未被修改</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//节点hash&gt;=0表示正常态</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//binCount记录为1，至少已有一个</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历节点链表，直到完成操作显式终止循环，计算链表长度</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//当前节点hash相等，key也相等，表示找到键，完成操作后跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//记录oldVal，此时表示map中此键已对应有值</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//当onlyIfAbsent为false时才进行覆盖</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="comment">//跳出循环</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点还不是，e移到下个节点next</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//已遍历完链表，未找到则新增节点，尾插法，完成跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//非正常态，而是TreeBin节点，则向红黑树插入节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//binCount更新为2，没必要+</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//插入树节点，完成操作</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同步块结束</span></span><br><span class="line">            <span class="comment">//binCount不为0表示put已对数据产生了影响，不管是否有覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//若达到链表阈值，就转链表为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);<span class="comment">//转换红黑树</span></span><br><span class="line">                <span class="comment">//oldVal不为空，表示是一次更新操作，没有对元素个数产生影响，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="comment">//跳出死循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//binCount还为0，put操作未成功，继续死循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新计数值，并继续判断是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1</span>L, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="built_in">int</span> sc;</span><br><span class="line">    <span class="comment">//当哈希表为空或长度为0时循环</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//正在被其他线程处理</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin 自旋等待</span></span><br><span class="line">        <span class="comment">//否则CAS更新sizeCtl为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, <span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//确认此时还未初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//初始化时sizeCtl可能会自定义，若未自定义则取默认值</span></span><br><span class="line">                    <span class="built_in">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//新建节点数组，初始化table</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//sizeCtl取和无符号右移2位后的差，即每隔n个4，就要减去n，也就是合理的取阈值0.75</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//更新sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-size"><a href="#2-3-size" class="headerlink" title="2.3 size"></a><strong>2.3 size</strong></h3><p>&emsp;&emsp;CounterCell是一个计数单元，无并发时只要用baseCount就足以，但一旦并发时CAS修改baseCount失败，就要启用counterCells，计算size时会将所有计数单元数组中元素累加。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 8提供了mappingCount返回long，因为int可能会限制size最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0</span>L) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">final <span class="keyword">long</span> <span class="title">sumCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="comment">//若计数单元数组counterCells不为空，即已初始化，就遍历其中元素，并得到元素和</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder and Striped64. </span></span><br><span class="line"><span class="comment"> * @sun.misc.Contended会影响计数单元性能，用于防止伪共享，即本应独立的缓存变量却共享一个缓存行，从而影响各自的性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@sun.misc.Contended <span class="keyword">static</span> final <span class="keyword">class</span> <span class="title">CounterCell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> <span class="keyword">value</span>;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; <span class="keyword">value</span> = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addCount源码解读"><a href="#addCount源码解读" class="headerlink" title="addCount源码解读"></a><strong>addCount源码解读</strong></h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 增加哈希表计数值</span></span><br><span class="line"><span class="comment">  * 若表需要扩容且未在扩容，则开始transfer，若已经在扩容，则在可以时帮助transfer</span></span><br><span class="line"><span class="comment">  * 重新检查占用，确认会不会已要进行另一次resize，因为resize远远滞后于add</span></span><br><span class="line"><span class="comment">  * @param x the count to add</span></span><br><span class="line"><span class="comment">  * @param check if &lt;0, don't check resize, if &lt;= 1 only check if uncontended</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> final <span class="keyword">void</span> <span class="title">addCount</span>(<span class="params"><span class="keyword">long</span> x, <span class="keyword">int</span> check</span>) </span>&#123;</span><br><span class="line">     CounterCell[] <span class="keyword">as</span>; <span class="keyword">long</span> b, s;</span><br><span class="line">     <span class="comment">//counterCells计数单元数组不为空，或CAS对baseCount原子操作 +x 时失败</span></span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">as</span> = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">         !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">         CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">         <span class="comment">//标识没有竞争</span></span><br><span class="line">         boolean uncontended = <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">//如果counterCells为空，或其中元素为0，表示尚未出现并发</span></span><br><span class="line">         <span class="comment">//如果本地线程随机取余对应counterCells下标为空</span></span><br><span class="line">         <span class="comment">//如果CAS对取到的元素进行原子操作 +x 失败了，表示出现并发情况</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">as</span> == <span class="literal">null</span> || (m = <span class="keyword">as</span>.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">             (a = <span class="keyword">as</span>[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">             !(uncontended =</span><br><span class="line">               U.compareAndSwapLong(a, CELLVALUE, v = a.<span class="keyword">value</span>, v + x))) &#123;</span><br><span class="line">             <span class="comment">//总之就是未成功执行计数单元数组counterCells更新计数值</span></span><br><span class="line">             <span class="comment">//执行fullAddCount，其会一直执行直到成功，并直接返回</span></span><br><span class="line">             fullAddCount(x, uncontended);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//若check小于等于1，直接返回</span></span><br><span class="line">         <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">//若check大于1，更新一下s</span></span><br><span class="line">         s = sumCount();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果需要检查，即检查是否需要扩容，putVal调用时所给check必然&gt;=0</span></span><br><span class="line">     <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">         <span class="comment">//当map的size达到sizeCtl扩容阈值，哈希表不为空，且哈希表还未到最大值，则进行扩容</span></span><br><span class="line">         <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             <span class="comment">//通过哈希表长度获得一个resize标识，得到一个低16位首位为1的大数。</span></span><br><span class="line">             <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">             <span class="comment">//若此时正在扩容</span></span><br><span class="line">             <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//开启扩容后会把sizeCtl替换为(rs &lt;&lt; 16) + 2</span></span><br><span class="line">                 <span class="comment">//1.若sizeCtl右移16位，其高16位不等于rs，表示sizeCtl被改变了（2这些低位值会被右移掉）</span></span><br><span class="line">                 <span class="comment">//2.此处rs + 1应该是BUG，应该改为(rs &lt;&lt; 16) + 1，表示所有线程都完成了扩容工作</span></span><br><span class="line">                 <span class="comment">//   默认第一个线程设置sizeCtl = (rs &lt;&lt; 16) + 2，之后的线程会+1</span></span><br><span class="line">                 <span class="comment">//   所以没有线程时基础值就为(rs &lt;&lt; 16) + 1</span></span><br><span class="line">                 <span class="comment">//   此处读源码时隐隐感觉有BUG，去sof搜了一下，果然有人已经发过类似的题问，还是一位国人</span></span><br><span class="line">                 <span class="comment">//   看描述已经被JDK BUG审核通过了，省去大麻烦，十分感谢</span></span><br><span class="line">                 <span class="comment">//3.此处rs + MAX_RESIZERS应该是BUG，改为(rs &lt;&lt; 16)+MAX_RESIZERS，表示帮助线程数已达到最大值</span></span><br><span class="line">                 <span class="comment">//4.若nextTable为空，表示扩容已结束</span></span><br><span class="line">                 <span class="comment">//5.若transferIndex &lt;= 0，表示所有区间都已分配或完成了，不再需要线程协助</span></span><br><span class="line">                 <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                     sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                     transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">break</span>;<span class="comment">//结束循环</span></span><br><span class="line">                 <span class="comment">//CAS原子操作sizeCtl++，表示帮助线程+1，并执行扩容</span></span><br><span class="line">                 <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                     transfer(tab, nt);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//此时不在扩容</span></span><br><span class="line">             <span class="comment">//CAS原子操作将sizeCtl更新为resize标识左移16位并+2</span></span><br><span class="line">             <span class="comment">//因为resize得到了一个低16位首尾为1的整型，这样就变成一个负数</span></span><br><span class="line">             <span class="comment">//所以开始扩容后sizeCtl的初始值为(rs &lt;&lt; 16) + 2，此时一个线程在进行扩容</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                          (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                 transfer(tab, <span class="literal">null</span>);<span class="comment">//更新sizeCtl为负数后开始扩容</span></span><br><span class="line">             <span class="comment">//更新size，即使已经在扩容了，也可能马上迎来下次扩容</span></span><br><span class="line">             s = sumCount();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取用来调整大小为n的哈希表的标记位，得到低16位，符号位为1</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> final <span class="keyword">int</span> <span class="title">resizeStamp</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//n自左连续0的位数x 和 后续二进制数进行或运算</span></span><br><span class="line">     <span class="comment">// x | 1000 0000 0000 0000</span></span><br><span class="line">     <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span>(<span class="params"><span class="keyword">int</span> i</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// HD, Figure 5-6</span></span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">     <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//高16位为0，n为17，i左移16位</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">16</span> == <span class="number">0</span>) &#123; n += <span class="number">16</span>; i &lt;&lt;= <span class="number">16</span>; &#125;</span><br><span class="line">     <span class="comment">//高8位为0，n为9，i左移8位</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">24</span> == <span class="number">0</span>) &#123; n +=  <span class="number">8</span>; i &lt;&lt;=  <span class="number">8</span>; &#125;</span><br><span class="line">     <span class="comment">//高4位为0，n为5，i左移4位</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">28</span> == <span class="number">0</span>) &#123; n +=  <span class="number">4</span>; i &lt;&lt;=  <span class="number">4</span>; &#125;</span><br><span class="line">     <span class="comment">//高2位为0，n为3，i左移2位</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">30</span> == <span class="number">0</span>) &#123; n +=  <span class="number">2</span>; i &lt;&lt;=  <span class="number">2</span>; &#125;</span><br><span class="line">     <span class="comment">//此时n是左移位数+1</span></span><br><span class="line">     <span class="comment">//此时i是左移(n-1)后的值</span></span><br><span class="line">     <span class="comment">//将i无符号右移31位，并从n中去掉</span></span><br><span class="line">     n -= i &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">     <span class="comment">//最后得到从左到右连续0的个数</span></span><br><span class="line">     <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;addCount将哈希表元素数+1，对baseCount和counterCells进行了修改，当counterCells被初始化就优先使用。并检查当前是否需要扩容，若需要扩容就开启扩容，若正在扩容就帮助进行扩容。</p><h3 id="helpTransfer源码解读"><a href="#helpTransfer源码解读" class="headerlink" title="helpTransfer源码解读"></a><strong>helpTransfer源码解读</strong></h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当扩容正在进行时，帮忙进行transfer</span></span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] <span class="keyword">tab</span>, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="comment">//若节点f为转发节点，且节点为转移类型，且新表不为空，则尝试帮助扩容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">tab</span> != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; </span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">        <span class="comment">//通过表长获得一个resize标识，低16位首位为1，以便左移后得到一个负数</span></span><br><span class="line">        int rs = resizeStamp(<span class="keyword">tab</span>.length);</span><br><span class="line">        <span class="comment">//当nextTable和table还未被修改，且正在扩容</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; <span class="keyword">table</span> == <span class="keyword">tab</span> &amp;&amp;</span><br><span class="line">               (<span class="keyword">sc</span> = sizeCtl) &lt; 0) &#123;</span><br><span class="line">            <span class="comment">//开启扩容后会把sizeCtl替换为(rs &lt;&lt; 16) + 2</span></span><br><span class="line">            <span class="comment">//1.若sizeCtl右移16位，其高16位不等于rs，表示sizeCtl被改变了（2这些低位值会被右移掉）</span></span><br><span class="line">            <span class="comment">//2.此处rs + 1应该是BUG，应该改为(rs &lt;&lt; 16) + 1，表示所有线程都完成了扩容工作</span></span><br><span class="line">            <span class="comment">//   默认第一个线程设置sizeCtl = (rs &lt;&lt; 16) + 2，之后的线程会+1</span></span><br><span class="line">            <span class="comment">//   所以没有线程时基础值就为(rs &lt;&lt; 16) + 1</span></span><br><span class="line">            <span class="comment">//   此处读源码时隐隐感觉有BUG，去sof搜了一下，果然有人已经发过类似的题问，还是一位国人</span></span><br><span class="line">            <span class="comment">//   看描述已经被JDK BUG审核通过了，省去大麻烦，十分感谢</span></span><br><span class="line">            <span class="comment">//3.此处rs + MAX_RESIZERS应该是BUG，改为(rs &lt;&lt; 16)+MAX_RESIZERS，表示帮助线程数已达到最大值</span></span><br><span class="line">            <span class="comment">//4.若nextTable为空，表示扩容已结束</span></span><br><span class="line">            <span class="comment">//5.若transferIndex &lt;= 0，表示所有区间都已分配或完成了，不再需要线程协助</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">sc</span> &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || <span class="keyword">sc</span> == rs + 1 ||</span><br><span class="line">                <span class="keyword">sc</span> == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//这些情况不需要再协助了，直接跳出循环</span></span><br><span class="line">            <span class="comment">//CAS原子操作使sizeCtl++，表示增加了一个帮助线程</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, <span class="keyword">sc</span> + 1)) &#123;</span><br><span class="line">                <span class="comment">//进行转移</span></span><br><span class="line">                transfer(<span class="keyword">tab</span>, nextTab);</span><br><span class="line">                <span class="comment">//并跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;<span class="comment">//返回新表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">table</span>;<span class="comment">//返回旧表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transfer源码解读"><a href="#transfer源码解读" class="headerlink" title="transfer源码解读"></a><strong>transfer源码解读</strong></h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//CPU核心数大于1时，除以8得到结果如果小于MTS，就直接使用MTS</span></span><br><span class="line">    <span class="comment">//MTS是每次transfer最小绑定数为16，同来限制哈希表被分的太小，所以默认情况下一个线程要处理16块桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range 细分范围</span></span><br><span class="line">    <span class="comment">//若所给的参数新表还未初始化，则创建新表进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//扩容2倍，创建哈希表</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//赋值给nextTab</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            <span class="comment">//扩容失败，sizeCtl直接采用int最大值</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容初始化成功，更新nextTable</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//更新转移下标，指向除了旧表长度后的首位</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新表的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//创建一个转移节点，用于占位，其他线程看到转移节点会知道对应区域正在进行扩容转移</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//推进标识，</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//结束标识，指扩容过程</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//最外层死循环，</span></span><br><span class="line">    <span class="comment">//i是指向桶数组的指针</span></span><br><span class="line">    <span class="comment">//bound则是指向当前线程可以处理的桶区间最小下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">//循环推进，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//i减1，说明是对桶集合倒序处理</span></span><br><span class="line">            <span class="comment">//如果大于等于bound，说明指针还未移出划分区域，表示之前分配的区间还未结束，跳出循环，继续工作</span></span><br><span class="line">            <span class="comment">//若结束标识为真，则表示表示扩容结束，跳出循环，扩容结束</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;<span class="comment">//防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">            <span class="comment">//若转移索引小于0，表示没有区间了，跳出循环，扩容结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//更新i为-1，表示扩容结束</span></span><br><span class="line">                i = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">//防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS原子操作更新transferIndex为nextIndex和stride的差</span></span><br><span class="line">            <span class="comment">//比如旧表64扩容，区间16，第一次分配区间为48-63，下一次为32-47</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                <span class="comment">//值为当前线程可以处理的当前区间的最小下标 |nextBound ... nextIndex-1|</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">//初次对i赋值，当前线程可以处理的当前区间的最大下标</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i &lt; 0，表示已经没有区间了，扩容任务都已完成或分配出去了</span></span><br><span class="line">        <span class="comment">//i &gt;= n，当前下标超过旧表容量，表示i异常</span></span><br><span class="line">        <span class="comment">//i + n &gt;= nextn，当前下标+旧表长超过新表长度，表示i异常</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//若已完成了扩容，则进行收尾工作</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">//重置新表为空</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//将当前表指向新表</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">//更新sizeCtl为2n-n/2</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//直接结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若还未未完成扩容任务</span></span><br><span class="line">            <span class="comment">//CAS原子操作更新sizeCtl--，表示当前线程要结束帮助任务了</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//若(sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//若相等，表示已无帮助线程，说明此次扩容已结束</span></span><br><span class="line">                <span class="comment">//更新结束标识为true，表示已完成这次扩容任务</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//重置i，还不急return，再检查一下再返回</span></span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果旧表i对应节点为空，不用操作了，就用转移节点来占位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);<span class="comment">//占位并恢复推进标识</span></span><br><span class="line">        <span class="comment">//如果旧表i对应节点不为空，且已被标注为转移节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed 说明其他线程已经处理过了，不用管，恢复推进标识</span></span><br><span class="line">        <span class="comment">//以上都不满足，表示下标对应节点有值，且不是占位符，则开始操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//先对节点加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//如果f此时未被修改</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//声明低位节点和高位节点</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//节点f的hash&gt;=0表示这是正常链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//首节点hash值和旧表长进行与运算，因为表长都是只有一位是1其他位是0的二进制</span></span><br><span class="line">                        <span class="comment">//所以与运算结果只有1或0，分别对应高位和低位</span></span><br><span class="line">                        <span class="comment">//目的是将链表重新散列，放到对应的位置上，让新的取余算法能够击中他。</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        <span class="comment">//lastRun用来标记最后一次变化的节点</span></span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">//遍历当前桶，即节点对应链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">//和旧表长与运算，得到此节点的“命运”</span></span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="comment">//不等于runBit则更新</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                <span class="comment">//更新runBit，用于判断赋值低位还是高位</span></span><br><span class="line">                                runBit = b;</span><br><span class="line">                                <span class="comment">//更新lastRun，纪录变化的节点，后续节点自然和此节点相同</span></span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果最后更新的runBit为0，放置到低位节点</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果最后更新的runBit为1，放置到高位节点</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//再次遍历链表，生成高位和低位链表，lastRun纪录的最后一次变化节点作为结束标记</span></span><br><span class="line">                        <span class="comment">//未被遍历到的节点保持原样，避免不必要的循环操作</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//类似于HashMap，低位链表放置于i，高位链表放置于i+n</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//旧链表设为转移节点占位，提醒其他线程</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//这样就完成了这个桶/链表的转移工作，恢复推进标识，继续推进</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树优化</span></span><br><span class="line">                    <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(f <span class="keyword">instanceof</span> TreeBin)</span> </span>&#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fullAddCount源码解读"><a href="#fullAddCount源码解读" class="headerlink" title="fullAddCount源码解读"></a><strong>fullAddCount源码解读</strong></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程的探测值，注意调用ThreadLocalRandom.current()会在返回0时强制进行初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> getProbe() &#123;</span><br><span class="line">    <span class="keyword">return</span> U.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See LongAdder version for explanation</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> fullAddCount(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended) &#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//从本地获取探测值，若为0，则强制进行初始化并再获取，更新无竞争标识符为true</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty 若最后一个插槽为空则为true</span></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] <span class="keyword">as</span>; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//若counterCells不为空，且有元素，则不断尝试新增或更新对应计数单元</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">as</span> = counterCells) != <span class="literal">null</span> &amp;&amp; (n = <span class="keyword">as</span>.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若探测值对应计数单元为空，(length-1) &amp; probe定位元素，则尝试创建新的计数单元</span></span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//自旋锁cellsBusy=0</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">//乐观的创建一个新计数单元，计数值即为参数x</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">//若自旋锁cellsBusy依旧=0</span></span><br><span class="line">                    <span class="comment">//且尝试CAS更新自旋锁为1</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="literal">false</span>;</span><br><span class="line">                        <span class="comment">//更新成功，锁死后复查</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">//counterCells已创建，且已有元素，且探测值对应计数单元为空，则将创建的计数单元赋予</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;<span class="comment">//恢复自旋锁</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//若成功添加就跳出死循环</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//添加失败，说明对应计数单元不为空</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计数单元不为空，且若有竞争，表示CAS操作失败，重置标识，等待再散列后重试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//计数单元不为空，重新尝试CAS更新计数值，若成功则跳出循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//计数单元不为空，重新尝试CAS失败，且counterCells已被修改或元素数超过CPU核数，更新collide继续循环尝试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != <span class="keyword">as</span> || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale 表示此时已达到最大值或计数单元是旧数据</span></span><br><span class="line">            <span class="comment">//以上都不符合，且collide依然为false，更新collide继续循环尝试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//collide为true，可能另外的线程完成了对这个计数单元的操作，尝试获得自旋锁，并扩大计数单元数组容量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == <span class="keyword">as</span>) &#123;<span class="comment">// Expand table unless stale 只要表还未被修改就把它展开</span></span><br><span class="line">                    <span class="comment">//创建一个新计数单元数组，扩大一倍容量</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="comment">//拷贝旧值</span></span><br><span class="line">                            rs[i] = <span class="keyword">as</span>[i];</span><br><span class="line">                        counterCells = rs;<span class="comment">//更新</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table 用新的数组重试</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新探测值</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计数单元数组为空或还未有元素，获取自旋锁，并占用成功，则尝试初始化计数单元数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == <span class="keyword">as</span> &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="comment">//初始化计数单元数组，创建首个计数单元</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == <span class="keyword">as</span>) &#123;</span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自旋锁正在被占用，重新尝试更新baseCount，若更新成功就跳出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-总结"><a href="#第三节-总结" class="headerlink" title="第三节 总结"></a><strong>第三节 总结</strong></h2><h3 id="怎么获取元素？"><a href="#怎么获取元素？" class="headerlink" title="怎么获取元素？"></a><strong>怎么获取元素？</strong></h3><p>&emsp;&emsp;先对哈希码进行再散列，并定位到散列表坐标，找到桶对应的首节点，如果是链表实现就遍历链表查询，如果是红黑树，就遍历树查询。</p><h3 id="怎么放置元素？"><a href="#怎么放置元素？" class="headerlink" title="怎么放置元素？"></a><strong>怎么放置元素？</strong></h3><p>&emsp;&emsp;首先校验不允许空值或空键，先对哈希码进行再散列，然后进行死循环，不断尝试后续操作。</p><p>&emsp;&emsp;哈希表还未初始化，则会先进行初始化，然后继续循环。</p><p>&emsp;&emsp;已有哈希表，且桶还未创建，CAS新增节点完成任务。</p><p>&emsp;&emsp;已有哈希表，桶也存在，但对应桶正在扩容，则先协助扩容，然后继续循环。</p><p>&emsp;&emsp;已有哈希表，桶也存在，桶可正常使用，则锁住链表，并遍历链表完成放置任务，操作若成功则判断是否达到链表长阈值，若达到就把链表转为红黑树；若操作未成功就继续循环。</p><p>&emsp;&emsp;最后调用addCount更新计数器值，并在这个过程中继续判断是否需要扩容。</p><h3 id="怎么获取元素数目？"><a href="#怎么获取元素数目？" class="headerlink" title="怎么获取元素数目？"></a><strong>怎么获取元素数目？</strong></h3><p>&emsp;&emsp;若计数单元数组counterCells不为空，就遍历其内元素求和，得到总数</p><p>&emsp;&emsp;若为空则直接返回baseCount</p><p>&emsp;&emsp;无并发时只要用baseCount就足以，但一旦并发时CAS修改baseCount失败，就要启用counterCells，计算size时会将所有计数单元数组累加</p><p>&emsp;&emsp;两种技术器都是通过addCount来更新，但可能会因为并发而更新失败，会采用备用方法fullAddCount，死循环不断尝试。</p><h3 id="怎么协助扩容？"><a href="#怎么协助扩容？" class="headerlink" title="怎么协助扩容？"></a><strong>怎么协助扩容？</strong></h3><p>&emsp;&emsp;ConcurrentHashMap如果正在扩容，其余线程可以参与扩容流程帮助进行扩容，每个线程会被分配一定的工作区间。</p><p>&emsp;&emsp;首先判断节点处是否是转移节点以及新表是否也已经创建，则不是则直接返回旧表</p><p>&emsp;&emsp;如果是则先通过resizeStamp获得一个低16位首位为1的大数作为rs标识，默认第一个线程开启扩容后会把sizeCtl置为(rs &lt;&lt; 16) + 2，所以(rs &lt;&lt; 16) + 1可以用来判断是否所有扩容线程都已结束任务。</p><p>&emsp;&emsp;如果此时还在扩容流程，即sizeCtl&lt;0，则进行循环，先判断几种转移或扩容流程已结束的情况，如果满足就直接跳出循环，返回新表</p><p>&emsp;&emsp;如果不满足则循环尝试进行CAS操作使sizeCtl++，代表着增加一个协助线程，调用transfer进行协助，成功后跳出循环，返回新表</p><h3 id="怎么更新计数器？"><a href="#怎么更新计数器？" class="headerlink" title="怎么更新计数器？"></a><strong>怎么更新计数器？</strong></h3><p>&emsp;&emsp;首先判断计数单元数组是否已创建，或CAS对baseCount计数更新是否可以成功</p><p>&emsp;&emsp;如果不满足，则根据check参数是否&gt;=0判断是否需要扩容检查，如果不需要则结束。</p><p>&emsp;&emsp;如果满足，则表示baseCount不可靠，需要更新计数单元数组，</p><p>&emsp;&emsp;若当前计数单元数组为空，或不含元素，或CAS更新失败，则调用备案fullAddCount，然后结束。</p><p>&emsp;&emsp;若非上述情况，则CAS更新成功，若所给check&lt;=1，则直接返回，不进行扩容检查</p><p>&emsp;&emsp;若check&gt;1，先算一下此时的总数，然后进入扩容检查</p><p>&emsp;&emsp;扩容检查部分和put放置元素雷同，区别就是当前线程可能是第一个发现要扩容的线程，所以当此时不在扩容状态，但需要扩容时，要重置sizeCtl为(rs &lt;&lt; 16) + 2，rs左移后变成一个大的负数，所以用来标识正在扩容以及当前正在扩容的线程数</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://stackoverflow.com/questions/53493706/how-the-conditions-sc-rs-1-sc-rs-max-resizers-can-be-achieved-in" target="_blank" rel="noopener">https://stackoverflow.com/questions/53493706/how-the-conditions-sc-rs-1-sc-rs-max-resizers-can-be-achieved-in</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/shadow_zed/article/details/82079579" title="Title" target="_blank" rel="noopener">ConcurrentHashMap源码解读-1.8版</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/lijiasnong/p/9963808.html" title="Title" target="_blank" rel="noopener">高并发编程系列：ConcurrentHashMap的实现原理(JDK1.7和JDK1.8)</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      对JDK 1.8版本中ConcurrentHashMap的源码进行分析，内容包括：结构（基本结构、Node单向链表节点），主要方法（get、put、size、addCount、helpTransfer、transfer、fullAddCount源码解读），总结（怎么获取元素、怎么放置元素、怎么获取元素数目、怎么协助扩容、怎么更新计数器）等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>页面置换算法</title>
    <link href="http://linyishui.top/2019110301.html"/>
    <id>http://linyishui.top/2019110301.html</id>
    <published>2019-11-03T03:28:48.000Z</published>
    <updated>2019-12-26T07:54:38.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a><strong>页面置换算法</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;页面置换算法：操作系统中内存内没有空闲页面，而又需要加载一个未载入内存的页面时，需要有一个置换算法可以淘汰出页面以便腾出空间。最理想的算法是发生缺页时，把当前所存页面中最晚被访问的页面淘汰，但操作系统并不能预知页面下一次被访问的时间，所以无法实现。</p><blockquote><ul><li>FIFO: 先进先出，总是置换掉最先进入也就是停留最久的一页，理由是最早被存入的比刚被存入的页面被调用的几率小。</li><li>LRU: 最近最久未使用，总是置换掉过去最久未被使用的一页。</li><li>LFU: 最近最少使用，总是置换掉过去被使用次数最少的一页。</li></ul></blockquote><p>&emsp;&emsp;假设我们内存已存页面[1,2,3]，过去访问顺序依次为：2，1，1，1，3，2。那么按照三种算法分别选出的淘汰页是？<br>&emsp;&emsp;使用FIFO：淘汰2，因为它最新进入内存。</p><p>&emsp;&emsp;使用LRU：淘汰1，因为它最近未被用过。</p><p>&emsp;&emsp;使用LFU：淘汰3，因为它被使用的次数最少。</p><hr><h2 id="第二节-FIFO"><a href="#第二节-FIFO" class="headerlink" title="第二节 FIFO"></a><strong>第二节 FIFO</strong></h2><p>&emsp;&emsp;FIFO（first input first output），即<strong>先进先出算法</strong>。这种算法只有在按线性顺序访问地址空间时才是理想的，否则效率不高。因为那些常被访问的页，往往在主存中也停留得最久，结果它们因变“老”而不得不被置换出去。</p><p>&emsp;&emsp;缺点：判断一个页面置换算法优劣的指标就是<strong>缺页率</strong>，而FIFO算法的一个显著的缺点是，在某些特定的时刻，缺页率反而会随着分配页面的增加而增加，这称为<strong>Belady现象</strong>。产生Belady现象现象的原因是：FIFO置换算法与进程访问内存的动态特征是不相容的，被置换的内存页面往往是被频繁访问的，或者没有给进程分配足够的页面，因此FIFO算法会使一些页面频繁地被替换和重新申请内存，从而导致缺页率增加。因此，现在不再使用FIFO算法。</p><hr><h2 id="第三节-LRU"><a href="#第三节-LRU" class="headerlink" title="第三节 LRU"></a><strong>第三节 LRU</strong></h2><p>&emsp;&emsp;LRU（Least recently used），即<strong>最近最久未使用算法</strong>，是页面置换算法的其中一种，用于很多分布式缓存系统，其设计思想是：<strong>如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）</strong>。</p><p>&emsp;&emsp;因为要找出最近最久未使用的页面，就必须为每一页设置相关记录项，用于记录页面的访问情况，并且每访问一次页面都须更新该信息。这将使系统的开销加大，所以在实际系统中往往使用该算法的近似算法。</p><p>&emsp;&emsp;实现方案：最朴素的思想就是用数组+时间戳的方式，不过这样做效率较低。因此，我们可以用双向链表（LinkedList）+哈希表（HashMap）实现（链表用来表示位置，哈希表用来存储和查找），在Java里有对应的数据结构LinkedHashMap。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用LinkedHashMap实现LRU置换算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="keyword">public</span> LRUCache(<span class="keyword">int</span> cacheSize) &#123;</span><br><span class="line">        super(<span class="number">16</span>, (<span class="keyword">float</span>) <span class="number">0.75</span>, true);</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">size</span>() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class LRUCacheTest &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LRUCache&lt;<span class="keyword">String</span>, Integer&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cache.<span class="built_in">put</span>(<span class="string">"k"</span> + i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"all cache :'&#123;&#125;'"</span> + cache);</span><br><span class="line">        cache.<span class="built_in">get</span>(<span class="string">"k3"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"get k3 :'&#123;&#125;'"</span>+ cache);</span><br><span class="line">        cache.<span class="built_in">get</span>(<span class="string">"k4"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"get k4 :'&#123;&#125;'"</span>+ cache);</span><br><span class="line">        cache.<span class="built_in">get</span>(<span class="string">"k4"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"get k4 :'&#123;&#125;'"</span>+ cache);</span><br><span class="line">        cache.<span class="built_in">put</span>(<span class="string">"k"</span> + <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"After running the LRU algorithm cache :'&#123;&#125;'"</span>+ cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打印结果如下</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all cache :'&#123;&#125;'&#123;<span class="attr">k0=0,</span> <span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k3=3,</span> <span class="attr">k4=4,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9&#125;</span></span><br><span class="line">get k3 :'&#123;&#125;'&#123;<span class="attr">k0=0,</span> <span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k4=4,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9,</span> <span class="attr">k3=3&#125;</span></span><br><span class="line">get k4 :'&#123;&#125;'&#123;<span class="attr">k0=0,</span> <span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9,</span> <span class="attr">k3=3,</span> <span class="attr">k4=4&#125;</span></span><br><span class="line">get k4 :'&#123;&#125;'&#123;<span class="attr">k0=0,</span> <span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9,</span> <span class="attr">k3=3,</span> <span class="attr">k4=4&#125;</span></span><br><span class="line">After running the LRU algorithm cache :'&#123;&#125;'&#123;<span class="attr">k1=1,</span> <span class="attr">k2=2,</span> <span class="attr">k5=5,</span> <span class="attr">k6=6,</span> <span class="attr">k7=7,</span> <span class="attr">k8=8,</span> <span class="attr">k9=9,</span> <span class="attr">k3=3,</span> <span class="attr">k4=4,</span> <span class="attr">k10=10&#125;</span></span><br></pre></td></tr></table></figure><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a><strong>算法题</strong></h3><p>&emsp;&emsp;运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>&emsp;&emsp;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。</p><p>&emsp;&emsp;当缓存容量达到上限时，它应该在写入新数据之前删除最长时间未使用的数据值，从而为新的数据值留出空间。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先我们根据存储键值对知道要选择Map，但一般映射的Key是无序的，所以我们应该要实现一个有序的哈希映射，一般用双向链表来实现有序Key。</p><p>&emsp;&emsp;用Java语言可以自己实现一个LinkedHashMap来解答，可以参考<a href="../2019041501.html" title="Title">Java集合(五) Map</a>。</p><hr><h2 id="第四节-LFU"><a href="#第四节-LFU" class="headerlink" title="第四节 LFU"></a><strong>第四节 LFU</strong></h2><p>&emsp;&emsp;LFU（Least Frequently Used），即<strong>最近最少使用算法</strong>。LFU算法的思想是：如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。</p><p>&emsp;&emsp;算法实现策略：考虑到 LFU 会淘汰访问频率最小的数据，我们需要一种合适的方法按大小顺序维护数据访问的频率。LFU 算法本质上可以看做是一个 top K 问题(K = 1)，即选出频率最小的元素，因此我们很容易想到可以用二项堆来选择频率最小的元素，这样的实现比较高效。最终实现策略为小顶堆+哈希表。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.cnblogs.com/hongdada/p/10406902.html" title="Title" target="_blank" rel="noopener">缓存算法（FIFO 、LRU、LFU三种算法的区别）</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/mengheng/p/3683137.html" title="Title" target="_blank" rel="noopener">LinkedHashMap实现LRU算法</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      内容：等
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>死亡会是解脱吗</title>
    <link href="http://linyishui.top/2019110201.html"/>
    <id>http://linyishui.top/2019110201.html</id>
    <published>2019-11-02T10:03:51.000Z</published>
    <updated>2019-12-16T09:01:18.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-qfPYzLbm" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-qfPYzLbm"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "曾经我也想过一了百了",              author: "中島美嘉",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/%E4%B8%AD%E5%B3%B6%E7%BE%8E%E5%98%89%20-%20%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp3",              pic: "http://p1.music.126.net/HE-K4mxyNGF84xlyuxx9Wg==/109951163825342747.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-KBLkETdj" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-KBLkETdj"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "僕らの手には何もないけど、",              author: "RAM WIRE",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/RAM%20WIRE%20-%20%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81.mp3",              pic: "http://p2.music.126.net/V1o9XDhAnI1ayWW5elJwFQ==/109951163338252165.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-nFAQBjiO" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-nFAQBjiO"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "ごはんを食べよう",              author: "Goose house",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/Goose%20house%20-%20%E3%81%94%E3%81%AF%E3%82%93%E3%82%92%E9%A3%9F%E3%81%B9%E3%82%88%E3%81%86.mp3",              pic: "http://p1.music.126.net/niXAzTEt2zlFpcLiPedX3g==/5754843859843186.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>&emsp;&emsp;可能会有那么一刻感叹自己的人生很空虚，世界好像和我无关，就算在这里死掉也不会有人会发现吧。</p><p>&emsp;&emsp;可能会有那么一刻觉得活着好累，死了就会好一些吧。</p><p>&emsp;&emsp;可能会有那么一刻无力反抗背上的压力，想着死了就轻松了吧。</p><p>&emsp;&emsp;活着似乎总是要担负一些东西，嘴里说着要放下一切，只有死去的那一刻才能真的放下吧。</p><p>&emsp;&emsp;世界是这样吗，不像幻想中那么美好、那么宽容，我好像也没那么坚强。</p><p>&emsp;&emsp;也曾想向世界传递善意，但身边的世界好像是空空的，是不是只有坏的记忆才能留在人的心里。</p><p>&emsp;&emsp;也曾想对世界倾诉，但好像没人有在乎，渐渐的也不知道该怎么说话了。</p><p>&emsp;&emsp;是啊，大家活着都很累啊，慢慢地封闭了自己的内心。</p><p>&emsp;&emsp;为了不受伤害而戴上的面具，也遮挡住了阳光，勉强才能维持着正常人的姿态。</p><p>&emsp;&emsp;“你没事吧”，“休息一下就好了”，“为家人考虑一下”，“再多坚强一些”，“还是内心不够强大”，“看不起这种自私的人”</p><p>&emsp;&emsp;说什么把握当下，生命要活得精彩，只是漂亮话罢了。</p><p>&emsp;&emsp;永别的时候告诉自己这不是放弃，是放下了。</p><p>&emsp;&emsp;好像这一生积攒的勇气终于释放了，好像扮演了一生的舞台剧终于谢幕了。</p><p>&emsp;&emsp;黑暗中死的无声无息，似乎从来没有存在过，直到最后也没有选择在阳光下，是担心围观的人肆意评论吗，人的恶意从来不会消失吧。</p><p>&emsp;&emsp;曾经也活着啊，匆匆的这一生有什么意义？</p><p>&emsp;&emsp;可能最后时刻的你也曾许愿，如果有来生，希望和能相互拥抱的人相遇。</p><p>&emsp;&emsp;哪怕一直聊着没有营养的话题，只想这样呆在一起。</p><p>&emsp;&emsp;就算还是一样活的辛苦，至少能感受到温暖。</p><p>&emsp;&emsp;希望那时可以相信这世界一切美好的存在，希望我也能成为温暖别人的存在。</p><p>&emsp;&emsp;但死了就什么都没有了，如果坚持到明天会不会有不同？</p><p>&emsp;&emsp;已放下所有的你，也许在明天的街头，可以邂逅一个阳光一样的人，也许再尝试一次就能找到一个同样孤独的人相拥取暖。</p><p>&emsp;&emsp;也许是一个多年未联系的老友，敞开心扉后，发现被社会打磨的油滑的他内心也还保留着一颗温热的心。</p><p>&emsp;&emsp;即便因奔忙无法相见，即便相互已无法变得坦率，但只要能够回到每个人都怀念的那个地方的话，是能让时光从那个时候开始延续吧</p><p>&emsp;&emsp;找到一个活下去的理由，只要能继续努力的活着，一切都还有重来的机会。</p><p>&emsp;&emsp;原本以为做不到的事情实际却可以做到的，世界渐渐变得广阔，因为相信现在所处的世界，即使一无所有仍可以顽强的活下去。</p><p>&emsp;&emsp;是啊，活着就是一件麻烦的事情，觉得不行了就暂停一下，无法面对了就逃避一下，总有一天，我们会从所有束缚我们的事之中，从肉眼看不到的微痛之中，得以解放。</p>        <div id="aplayer-BoWRflxd" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-BoWRflxd"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "面会菜",              author: "林生祥",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/OM/%E6%9E%97%E7%94%9F%E7%A5%A5%20-%20%E9%9D%A2%E4%BC%9A%E8%8F%9C.mp3",              pic: "http://p2.music.126.net/cLoAM3X8pIuCil_oJpxjWw==/18511377767183768.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><blockquote><p>&emsp;&emsp;这篇博客算是记录一下最近几年的一些感想吧，经历了一些生活中、网络中发生的事情会有些感受，这些碎片式的感受还挺难整理的，很多回忆融合到一起，写的时候有些混乱了，写着写着也搞不清想要说什么了。<br>&emsp;&emsp;有些事情发生了，可能并没有一个简单的答案，局外人却可以随心所欲的谈论自己的观点，虽然他们可能什么都不知道，却能没有责任的随便开口。事情已经发生了，当事人也没办法为自己辩护了。<br>&emsp;&emsp;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日志" scheme="http://linyishui.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="diary" scheme="http://linyishui.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Spring和SpringMVC</title>
    <link href="http://linyishui.top/2019110101.html"/>
    <id>http://linyishui.top/2019110101.html</id>
    <published>2019-11-01T09:42:38.000Z</published>
    <updated>2019-12-12T09:44:08.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h1><!--说说Spring的生命周期吧Spring的单例是怎么实现的？SpringMVC不同用户登录的信息怎么保证线程安全的？AOPspringmvc执行流程。3. ioc与aop的原理与流程4. aop实现原理？动态代理与CGlib的区别？5. bean对象的生命周期？6. bean成员变量的参数注入有哪种方式？7. spring常用的注解有哪些？8. @Autowired和@Resource的区别？9. spring提供的扩展组件有用过吗？比如拦截器？说下这个拦截器的api（疯狂问还有没用过其它的组件）10. 登录态怎么去处理的？11. 用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？12. SpringBoot的自动配置流程？Spring IOC是怎么管理bean的？给你spring的jar包你要怎么让它启动20.假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？21.Spring Bean是如何注入的？单例的情况下怎么实例化，什么时候，多例呢？22.Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库基本上涉及到框架的，都是问里面怎么实现的，回答得太表层没什么用，感觉不是他想要的答案，有时搞不清他要问框架的整个处理流程还是底层怎么实现，知道的点很多但是不知道怎么回答，而且情景不是应用在web项目里的，而是一个普通的Java项目你怎么使用。--><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a><strong>SpringMVC</strong></h1><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Spring和SpringMVC相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——数据库</title>
    <link href="http://linyishui.top/2019102901.html"/>
    <id>http://linyishui.top/2019102901.html</id>
    <published>2019-10-29T08:24:25.000Z</published>
    <updated>2019-12-13T02:53:06.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：查询姓名，课程名，成绩-（自定义设计表，写出sql）？"><a href="#问：查询姓名，课程名，成绩-（自定义设计表，写出sql）？" class="headerlink" title="问：查询姓名，课程名，成绩?（自定义设计表，写出sql）？"></a><strong>问：查询姓名，课程名，成绩?（自定义设计表，写出sql）？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？"><a href="#问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？" class="headerlink" title="问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？"></a><strong>问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？</strong></h3><details><br><br>&emsp;&emsp;脏读、幻影读、不可重复读？<br><br></details><h3 id="问：你们生产用的是哪种事务隔离级别，为什么？"><a href="#问：你们生产用的是哪种事务隔离级别，为什么？" class="headerlink" title="问：你们生产用的是哪种事务隔离级别，为什么？"></a><strong>问：你们生产用的是哪种事务隔离级别，为什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么是索引覆盖？"><a href="#问：什么是索引覆盖？" class="headerlink" title="问：什么是索引覆盖？"></a><strong>问：什么是索引覆盖？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：你们数据库的高可用架构是怎么样的？"><a href="#问：你们数据库的高可用架构是怎么样的？" class="headerlink" title="问：你们数据库的高可用架构是怎么样的？"></a><strong>问：你们数据库的高可用架构是怎么样的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何保证数据库主从一致性？"><a href="#问：如何保证数据库主从一致性？" class="headerlink" title="问：如何保证数据库主从一致性？"></a><strong>问：如何保证数据库主从一致性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库存储引擎特点与区别-还有应用场景"><a href="#问：数据库存储引擎特点与区别-还有应用场景" class="headerlink" title="问：数据库存储引擎特点与区别?还有应用场景"></a><strong>问：数据库存储引擎特点与区别?还有应用场景</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库的存储引擎有哪几种？有什么区别？"><a href="#问：数据库的存储引擎有哪几种？有什么区别？" class="headerlink" title="问：数据库的存储引擎有哪几种？有什么区别？"></a><strong>问：数据库的存储引擎有哪几种？有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么时候该用索引-（字段查询过多时）除了这个还有吗"><a href="#问：什么时候该用索引-（字段查询过多时）除了这个还有吗" class="headerlink" title="问：什么时候该用索引?（字段查询过多时）除了这个还有吗?"></a><strong>问：什么时候该用索引?（字段查询过多时）除了这个还有吗?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：聚簇和非聚簇又可细分哪一些？"><a href="#问：聚簇和非聚簇又可细分哪一些？" class="headerlink" title="问：聚簇和非聚簇又可细分哪一些？"></a><strong>问：聚簇和非聚簇又可细分哪一些？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：B-树与B树的区别？索引为什么选择B-树？说下索引结构，为什么使用B-树？"><a href="#问：B-树与B树的区别？索引为什么选择B-树？说下索引结构，为什么使用B-树？" class="headerlink" title="问：B+树与B树的区别？索引为什么选择B+树？说下索引结构，为什么使用B+树？"></a><strong>问：B+树与B树的区别？索引为什么选择B+树？说下索引结构，为什么使用B+树？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：组合索引？"><a href="#问：组合索引？" class="headerlink" title="问：组合索引？"></a><strong>问：组合索引？</strong></h3><details><br><br>&emsp;&emsp;（写了一个例子，选择会走索引的sql）。like索引的例子？(就是以like %李%和like 李%为例子讲)有没有其它例子也是这样跳过索引的？<br><br></details><h3 id="问：主从的模式有哪些？实现同步的方式？"><a href="#问：主从的模式有哪些？实现同步的方式？" class="headerlink" title="问：主从的模式有哪些？实现同步的方式？"></a><strong>问：主从的模式有哪些？实现同步的方式？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有考虑过大数据量优化的情况吗？"><a href="#问：有考虑过大数据量优化的情况吗？" class="headerlink" title="问：有考虑过大数据量优化的情况吗？"></a><strong>问：有考虑过大数据量优化的情况吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Innodb中索引的实现？"><a href="#问：Innodb中索引的实现？" class="headerlink" title="问：Innodb中索引的实现？"></a><strong>问：Innodb中索引的实现？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a><strong>MySql</strong></h2><h3 id="问：知道mysql的索引算法么？"><a href="#问：知道mysql的索引算法么？" class="headerlink" title="问：知道mysql的索引算法么？"></a><strong>问：知道mysql的索引算法么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：为什么mongodb的索引用了B树，而mysql用B-树？"><a href="#问：为什么mongodb的索引用了B树，而mysql用B-树？" class="headerlink" title="问：为什么mongodb的索引用了B树，而mysql用B+树？"></a><strong>问：为什么mongodb的索引用了B树，而mysql用B+树？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql索引的执行计划有了解过吗？"><a href="#问：mysql索引的执行计划有了解过吗？" class="headerlink" title="问：mysql索引的执行计划有了解过吗？"></a><strong>问：mysql索引的执行计划有了解过吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有用过explain吗？它执行的结果重要的参数是什么？"><a href="#问：有用过explain吗？它执行的结果重要的参数是什么？" class="headerlink" title="问：有用过explain吗？它执行的结果重要的参数是什么？"></a><strong>问：有用过explain吗？它执行的结果重要的参数是什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql的主从复制有了解过吗？"><a href="#问：mysql的主从复制有了解过吗？" class="headerlink" title="问：mysql的主从复制有了解过吗？"></a><strong>问：mysql的主从复制有了解过吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql常用的索引类型有哪些？"><a href="#问：mysql常用的索引类型有哪些？" class="headerlink" title="问：mysql常用的索引类型有哪些？"></a><strong>问：mysql常用的索引类型有哪些？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：MySQL有哪些锁？"><a href="#问：MySQL有哪些锁？" class="headerlink" title="问：MySQL有哪些锁？"></a><strong>问：MySQL有哪些锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：MySQL行锁是否会有死锁的情况？"><a href="#问：MySQL行锁是否会有死锁的情况？" class="headerlink" title="问：MySQL行锁是否会有死锁的情况？"></a><strong>问：MySQL行锁是否会有死锁的情况？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：AUTO-INCREMENT原理（考察并发情况）？"><a href="#问：AUTO-INCREMENT原理（考察并发情况）？" class="headerlink" title="问：AUTO_INCREMENT原理（考察并发情况）？"></a><strong>问：AUTO_INCREMENT原理（考察并发情况）？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库的索引有哪几种？"><a href="#问：数据库的索引有哪几种？" class="headerlink" title="问：数据库的索引有哪几种？"></a><strong>问：数据库的索引有哪几种？</strong></h3><details><br><br>&emsp;&emsp;为什么要用B+树来做索引？<br><br>&emsp;&emsp;组合索引和几个单个的索引有什么区别？<br><br>&emsp;&emsp;数据库的大表查询优化了解吗？<br><br>&emsp;&emsp;MVCC机制了解不？<br><br>&emsp;&emsp;MVCC机制有什么问题？<br><br>&emsp;&emsp;怎么去解决这个问题？<br><br>&emsp;&emsp;mysql慢语句调优做过吗？<br><br>&emsp;&emsp;说说你是怎么做的？<br><br></details><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h2><h3 id="问：redis了解吗？你说说怎么用redis实现分布式锁？"><a href="#问：redis了解吗？你说说怎么用redis实现分布式锁？" class="headerlink" title="问：redis了解吗？你说说怎么用redis实现分布式锁？"></a><strong>问：redis了解吗？你说说怎么用redis实现分布式锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构-分别用在什么场景-zset底层怎么实现的"><a href="#问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构-分别用在什么场景-zset底层怎么实现的" class="headerlink" title="问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构? 分别用在什么场景? zset底层怎么实现的?"></a><strong>问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构? 分别用在什么场景? zset底层怎么实现的?</strong></h3><details><br><br>&emsp;&emsp;既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树。你们用了redis，redis的底层数据结构了解多少？<br><br></details><h3 id="问：如何解决-Redis-的并发竞争-Key-问题？"><a href="#问：如何解决-Redis-的并发竞争-Key-问题？" class="headerlink" title="问：如何解决 Redis 的并发竞争 Key 问题？"></a><strong>问：如何解决 Redis 的并发竞争 Key 问题？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何保证缓存与数据库双写时的数据一致性？"><a href="#问：如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="问：如何保证缓存与数据库双写时的数据一致性？"></a><strong>问：如何保证缓存与数据库双写时的数据一致性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：项目用到了redis，讲讲你项目用到了redis的哪些特性？"><a href="#问：项目用到了redis，讲讲你项目用到了redis的哪些特性？" class="headerlink" title="问：项目用到了redis，讲讲你项目用到了redis的哪些特性？"></a><strong>问：项目用到了redis，讲讲你项目用到了redis的哪些特性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；"><a href="#问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；" class="headerlink" title="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；"></a><strong>问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis支持哪些数据类型？"><a href="#问：redis支持哪些数据类型？" class="headerlink" title="问：redis支持哪些数据类型？"></a><strong>问：redis支持哪些数据类型？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis中的字符串类型是怎么实现的？"><a href="#问：redis中的字符串类型是怎么实现的？" class="headerlink" title="问：redis中的字符串类型是怎么实现的？"></a><strong>问：redis中的字符串类型是怎么实现的？</strong></h3><details><br><br>&emsp;&emsp;(SDS)注:sds为redis底层数据结构之一<br><br></details><h3 id="问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？"><a href="#问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？" class="headerlink" title="问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？"></a><strong>问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？</strong></h3><details><br><br>&emsp;&emsp;（共有4个优点，前不久刚看过，当时只回忆起1个优点。。）<br><br></details><h3 id="问：关于redis对象系统的一个问题？"><a href="#问：关于redis对象系统的一个问题？" class="headerlink" title="问：关于redis对象系统的一个问题？"></a><strong>问：关于redis对象系统的一个问题？</strong></h3><details><br><br>&emsp;&emsp;（我说忘记了，记得redis设计与实现有写，面试小哥：忘记了那就不问了）<br><br></details><h3 id="问：Redis高并发快的原因？"><a href="#问：Redis高并发快的原因？" class="headerlink" title="问：Redis高并发快的原因？"></a><strong>问：Redis高并发快的原因？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis主从机制了解么？怎么实现的？"><a href="#问：redis主从机制了解么？怎么实现的？" class="headerlink" title="问：redis主从机制了解么？怎么实现的？"></a><strong>问：redis主从机制了解么？怎么实现的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何利用Redis处理热点数据？"><a href="#问：如何利用Redis处理热点数据？" class="headerlink" title="问：如何利用Redis处理热点数据？"></a><strong>问：如何利用Redis处理热点数据？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈Redis哨兵、复制、集群？"><a href="#问：谈谈Redis哨兵、复制、集群？" class="headerlink" title="问：谈谈Redis哨兵、复制、集群？"></a><strong>问：谈谈Redis哨兵、复制、集群？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：你们怎么解决缓存击穿问题的？"><a href="#问：你们怎么解决缓存击穿问题的？" class="headerlink" title="问：你们怎么解决缓存击穿问题的？"></a><strong>问：你们怎么解决缓存击穿问题的？</strong></h3><details><br><br>&emsp;&emsp;注:估计答了Hystrix<br><br></details><h3 id="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"><a href="#问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？" class="headerlink" title="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"></a><strong>问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？</strong></h3><details><br><br>&emsp;&emsp;注:估计答了Hystrix<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的数据库相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——分布式</title>
    <link href="http://linyishui.top/2019102801.html"/>
    <id>http://linyishui.top/2019102801.html</id>
    <published>2019-10-28T08:24:18.000Z</published>
    <updated>2019-12-13T02:35:30.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>zookeeper怎么保证数据一致性的</p><p>讲讲你对zk的理解吧</p><p>Spring Cloud用到什么东西？<br>如何实现负载均衡？<br>服务挂了注册中心怎么判断？</p><p>分布式锁的实现你知道的有哪些？具体详细谈一种实现方式</p><p>高并发的应用场景，技术需要涉及到哪些？怎样来架构设计？</p><p>接着高并发的问题，谈到了秒杀等的技术应用：kafka、redis、mycat等</p><p>最后谈谈你参与过的项目，技术含量比较高的，相关的架构设计以及你负责哪些核心编码</p><p>部门组织结构是怎样的？<br>系统有哪些模块，每个模块用了哪些技术，数据怎么流转的？给了我一张纸，我在上面简单画了下系统之间的流转情况<br>链路追踪的信息是怎么传递的？</p><p>SpanId怎么保证唯一性？<br>RpcContext是在什么维度传递的？<br>Dubbo的远程调用怎么实现的？</p><p>为什么要单独实现一个服务治理框架？<br>谁主导的？内部还在使用么？<br>逆向有想过怎么做成通用么？</p><p>说下Dubbo的原理?</p><p>分布式追踪的上下文是怎么存储和传递的？</p><p>Dubbo的RpcContext是怎么传递的？主线程的ThreadLocal怎么传递到线程池？你说的内存泄漏具体是怎么产生的？<br>线程池的线程是不是必须手动remove才可以回收value？那你说的内存泄漏是指主线程还是线程池？</p><p>介绍一下自己对 Netty 的认识，为什么要用。说说业务中，Netty 的使用场景。什么是TCP 粘包/拆包,解决办法。Netty线程模型。Dubbo 在使用 Netty 作为网络通讯时候是如何避免粘包与半包问题？讲讲Netty的零拷贝？巴拉巴拉问了好多，我记得有好几个我都没回答上来，心里想着凉凉了啊。</p><p>NginX如何做负载均衡、常见的负载均衡算法有哪些、一致性哈希的一致性是什么意思、一致性哈希是如何做哈希的</p><p>你们项目中微服务是怎么划分的，划分粒度怎么确定？<br>那在实践微服务架构中，有遇到什么问题么？<br>你们在关于微服务间数据一致性问题，是如何解决的？<br>你们为什么不用其他的MQ,最终选择了RocketMQ？<br>为什么RocketMQ没有选择ZooKeeper，而是自己实现了一个NameServer集群？<br>嗯，理解的不错，Zookeeper在选举的过程中，还能对外提供服务么？<br>对Paxos算法了解多少？<br>如果让你来设计一个春晚抢红包架构，你会怎么设计？</p><p>你们在微服务中用RPC通信还是REST？<br>RPC和HTTP的关系是什么？</p><p>谈一谈你对微服务架构的理解</p><p>你用过哪些RPC框架，讲讲他们优缺点</p><p>用过docker么，对容器了解多少</p><p>RPC是什么，如何实现？发送请求之后如何阻塞？让你来设计你会怎么做？这里讨巧，回答用restful做，但是同样问了发送之后怎么确定收到了这个请求的数据</p><h2 id="消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现"><a href="#消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现" class="headerlink" title="消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现"></a>消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现</h2><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的分布式相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——操作系统</title>
    <link href="http://linyishui.top/2019102701.html"/>
    <id>http://linyishui.top/2019102701.html</id>
    <published>2019-10-27T08:24:13.000Z</published>
    <updated>2019-12-13T02:34:28.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：说一下操作系统的内存管理机制？"><a href="#问：说一下操作系统的内存管理机制？" class="headerlink" title="问：说一下操作系统的内存管理机制？"></a><strong>问：说一下操作系统的内存管理机制？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：页面置换算法有哪些，介绍一下？"><a href="#问：页面置换算法有哪些，介绍一下？" class="headerlink" title="问：页面置换算法有哪些，介绍一下？"></a><strong>问：页面置换算法有哪些，介绍一下？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：试着实现一下LRU算法？"><a href="#问：试着实现一下LRU算法？" class="headerlink" title="问：试着实现一下LRU算法？"></a><strong>问：试着实现一下LRU算法？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><strong>进程和线程</strong></h2><h3 id="问：fork和exec有深入了解吗？"><a href="#问：fork和exec有深入了解吗？" class="headerlink" title="问：fork和exec有深入了解吗？"></a><strong>问：fork和exec有深入了解吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？"><a href="#问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？" class="headerlink" title="问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？"></a><strong>问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？</strong></h3><details><br><br>&emsp;&emsp;答：只有一个线程<br><br>&emsp;&emsp;为什会只fork一个线程？会带来什么问题？<br><br>&emsp;&emsp;答：扯了一下unix设计fork接口那会还没有多线程的概念，所以就没考虑复制多个线程，会带来线程安全性问题，略去。<br><br></details><hr><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><strong>Linux</strong></h2><h3 id="问：linux中有哪些常见的指令？"><a href="#问：linux中有哪些常见的指令？" class="headerlink" title="问：linux中有哪些常见的指令？"></a><strong>问：linux中有哪些常见的指令？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：select、poll、epoll有没有了解过，讲解一下？区别？"><a href="#问：select、poll、epoll有没有了解过，讲解一下？区别？" class="headerlink" title="问：select、poll、epoll有没有了解过，讲解一下？区别？"></a><strong>问：select、poll、epoll有没有了解过，讲解一下？区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何查看Linux系统运行状态？"><a href="#问：如何查看Linux系统运行状态？" class="headerlink" title="问：如何查看Linux系统运行状态？"></a><strong>问：如何查看Linux系统运行状态？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一下Linux软链接以及和硬链接的区别？"><a href="#问：说一下Linux软链接以及和硬链接的区别？" class="headerlink" title="问：说一下Linux软链接以及和硬链接的区别？"></a><strong>问：说一下Linux软链接以及和硬链接的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一下Linux进程间通信的方式？"><a href="#问：说一下Linux进程间通信的方式？" class="headerlink" title="问：说一下Linux进程间通信的方式？"></a><strong>问：说一下Linux进程间通信的方式？</strong></h3><p>&emsp;&emsp;答：管道，信号量，消息队列，共享内存，套接字。</p><h3 id="问：说一下命名管道和匿名管道的特点和区别？"><a href="#问：说一下命名管道和匿名管道的特点和区别？" class="headerlink" title="问：说一下命名管道和匿名管道的特点和区别？"></a><strong>问：说一下命名管道和匿名管道的特点和区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的操作系统相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
</feed>
